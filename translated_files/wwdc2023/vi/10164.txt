10164

♪ ♪

Ben: Xin chào, và chào mừng đến với "Có gì mới trong Swift 5.9."

Tôi là Ben, và cùng với đồng nghiệp Doug của tôi, chúng tôi sẽ đưa bạn qua một số cải tiến đối với ngôn ngữ Swift trong năm nay.

Chúng ta sẽ nói về một số cách dễ dàng hơn để diễn đạt ý của bạn bằng cách sử dụng cú pháp sạch của Swift, một số tính năng mới mạnh mẽ giúp các tác giả khung làm cho API mới của họ tự nhiên hơn để sử dụng và chúng ta sẽ xem xét một số cách mới để kiểm soát nhiều hơn hiệu suất và an toàn trong mã cấp thấp.

Nhưng hãy bắt đầu bằng cách nói về dự án mã nguồn mở Swift.

Đây là một bản cập nhật tuyệt vời cho Swift và nó không thể xảy ra nếu không có cộng đồng Swift, những người đóng góp và người dùng ngôn ngữ tập trung tại swift.org, làm việc cùng nhau để phát triển ngôn ngữ và hỗ trợ các sáng kiến mới.

Swift tuân theo một quá trình mở cho sự tiến hóa ngôn ngữ.

Các tính năng mới hoặc thay đổi hành vi quan trọng được đề xuất và xem xét mở trên các diễn đàn Swift.

Nếu bạn muốn theo dõi, bạn có thể tìm thấy bảng điều khiển của tất cả các đề xuất ngôn ngữ trên trang web Swift.

Một năm trước, chúng tôi đã chứng kiến sự tái cấu trúc đáng kể của quản trị Dự án Swift.

Nhóm nòng cốt đã công bố thành lập Nhóm Chỉ đạo Ngôn ngữ, chịu trách nhiệm chính trong việc giám sát sự phát triển ngôn ngữ Swift và thư viện tiêu chuẩn.

Kể từ đó, nhóm ngôn ngữ đã giám sát 40 đề xuất ngôn ngữ mới và chúng ta sẽ nói về một số trong số đó ngày hôm nay.

Nhưng đôi khi, các đề xuất ngôn ngữ riêng lẻ kết hợp với nhau như một phần của chủ đề rộng hơn, như việc bổ sung Swift đồng thời, được giới thiệu thông qua mười đề xuất riêng biệt.

Đối với những trường hợp như thế này, nhóm chỉ đạo ngôn ngữ đã giới thiệu một cách mới để gắn kết các đề xuất này lại với nhau, thông qua các tài liệu tầm nhìn.

Những tài liệu này đưa ra một đề xuất cho những thay đổi lớn hơn đối với ngôn ngữ.

Cái đầu tiên được nhóm chỉ đạo ngôn ngữ chấp nhận là tầm nhìn về macro Swift, một tính năng mới trong Swift 5.9 mà chúng ta sẽ đề cập sau trong buổi nói chuyện này.

Tất nhiên, sự phát triển của ngôn ngữ chỉ là một phần công việc của cộng đồng Swift.

Một ngôn ngữ thành công cần nhiều hơn thế này.

Nó cần công cụ tuyệt vời, hỗ trợ mạnh mẽ cho nhiều nền tảng và tài liệu phong phú.

Để giám sát sự tiến bộ trong lĩnh vực này, nhóm cốt lõi đang tạo ra một nhóm chỉ đạo hệ sinh thái song song với nhóm chỉ đạo ngôn ngữ.

Cấu trúc mới này gần đây đã được trình bày trong một bài đăng trên blog trên Swift.org, để tìm kiếm các thông báo thêm về việc thành lập nhóm mới này sớm.

Bây giờ hãy nói về những thay đổi đối với ngôn ngữ Swift trong năm nay, bắt đầu với những cách tốt hơn để thể hiện bản thân trong mã của bạn.

Swift 5.9 bao gồm những gì có lẽ là cải tiến ngôn ngữ được yêu cầu phổ biến nhất của chúng tôi, cho phép các câu lệnh if/else và switch được sử dụng làm biểu thức, cung cấp một cách hay để dọn dẹp mã của bạn.

Ví dụ, nếu bạn muốn khởi tạo một biến let dựa trên một số điều kiện phức tạp, bạn phải dùng đến các thủ thuật, như biểu thức bậc ba ghép khó đọc này.

Thay vào đó, các biểu thức If cho phép bạn sử dụng một chuỗi câu lệnh if quen thuộc và dễ đọc hơn nhiều.

Một nơi khác mà điều này hữu ích là nếu bạn đang khởi tạo một biến toàn cục hoặc một thuộc tính được lưu trữ.

Các biểu thức đơn hoạt động tốt ở đây, nhưng nếu bạn muốn một điều kiện, bạn phải sử dụng thủ thuật gói nó trong một phần đóng mà sau đó bạn đã thực hiện ngay lập tức.

Bây giờ một câu lệnh if có thể là một biểu thức, bạn có thể bỏ sự lộn xộn đó, để lại cho bạn mã gọn gàng hơn.

Trình tạo kết quả, cú pháp khai báo thúc đẩy các tính năng như SwiftUI, đã chứng kiến những cải tiến đáng kể trong năm nay, bao gồm hiệu suất kiểm tra loại được tối ưu hóa, hoàn thành mã và thông báo lỗi được cải thiện.

Cải tiến này đặc biệt tập trung vào mã không hợp lệ.

Trước đây, mã trình tạo kết quả có lỗi sẽ mất nhiều thời gian để thất bại, vì trình kiểm tra kiểu đã khám phá nhiều đường dẫn không hợp lệ có thể xảy ra.

Kể từ Swift 5.8, loại mã không hợp lệ kiểm tra nhanh hơn nhiều và thông báo lỗi trên mã không hợp lệ giờ đây chính xác hơn.

Ví dụ, trước đây, một số mã không hợp lệ có thể dẫn đến lỗi gây hiểu lầm trong một phần hoàn toàn khác của trình tạo kết quả.

Trong Swift 5.7, bạn sẽ nhận được một lỗi như thế này, khi lỗi thực sự nằm ở đây.

Trong bản phát hành mới nhất, bây giờ bạn nhận được chẩn đoán trình biên dịch chính xác hơn để xác định vấn đề thực sự.

Tiếp theo, hãy nói về cách bổ sung vào hệ thống generics sẽ cho phép một số cải tiến tuyệt vời cho các khuôn khổ bạn sử dụng hàng ngày.

Hầu như tất cả Swift bạn viết đều sử dụng thuốc generic theo một cách nào đó.

Suy luận kiểu cho phép sử dụng các loại này mà không cần hiểu các khả năng nâng cao mà chúng được xây dựng.

Ví dụ, loại mảng thư viện tiêu chuẩn sử dụng generics để cung cấp một mảng hoạt động với bất kỳ loại dữ liệu nào mà bạn có thể muốn lưu trữ.

Khi bạn sử dụng một mảng, tất cả những gì bạn cần làm là cung cấp các phần tử.

Không cần chỉ định một đối số rõ ràng cho loại phần tử vì nó có thể được suy ra từ các giá trị phần tử.

Hệ thống generics của Swift cho phép các API tự nhiên bảo toàn thông tin loại để mã của bạn hoạt động liền mạch trên các loại cụ thể mà bạn cung cấp.

Đây là một ví dụ lấy cảm hứng từ cơ sở mã riêng của trình biên dịch Swift: Một API lấy một loại yêu cầu và đánh giá nó để tạo ra một giá trị được nhập mạnh.

Vì vậy, bạn có thể yêu cầu giá trị Boolean và nhận lại kết quả Boolean.

Bây giờ, một số API muốn trừu tượng hóa không chỉ trên các loại cụ thể, mà còn cả số lượng đối số mà bạn chuyển vào.

Vì vậy, một hàm có thể nhận một yêu cầu và trả về một hoặc hai kết quả yêu cầu và trả về hai hoặc ba kết quả và trả về ba kết quả.

Để hỗ trợ điều này, hệ thống generics phải được sử dụng cùng với một cơ chế để xử lý nhiều độ dài đối số để tất cả các loại mà bạn chuyển vào được liên kết với các loại mà bạn nhận được.

Trước Swift 5.9, cách duy nhất để thực hiện mẫu này là thêm quá tải cho từng độ dài đối số cụ thể mà API hỗ trợ.

Nhưng cách tiếp cận này có những hạn chế.

Nó buộc giới hạn trên nhân tạo về số lượng đối số bạn có thể vượt qua, dẫn đến lỗi trình biên dịch nếu bạn vượt qua quá nhiều.

Trong trường hợp này, không có quá tải nào có thể xử lý nhiều hơn sáu đối số, nhưng chúng tôi đã vượt qua bảy.

Mô hình quá tải này và những hạn chế của nó phổ biến trên các API xử lý về mặt khái niệm độ dài đối số tùy ý.

Trong Swift 5.9, hệ thống generics đang nhận được sự hỗ trợ hạng nhất cho mẫu API này bằng cách cho phép trừu tượng hóa chung trên độ dài đối số.

Điều này được thực hiện với một khái niệm ngôn ngữ mới có thể đại diện cho nhiều tham số loại riêng lẻ được "đóng gói" cùng nhau.

Khái niệm mới này được gọi là gói tham số kiểu.

Sử dụng các gói tham số, các API hiện có quá tải riêng lẻ cho mỗi độ dài đối số cố định có thể được thu gọn thành một hàm duy nhất.

Thay vì chấp nhận một tham số loại duy nhất, Kết quả, đại diện cho loại kết quả của một yêu cầu duy nhất, hàm đánh giá hiện chấp nhận một yêu cầu riêng biệt trên mỗi loại Kết quả.

Hàm trả về mỗi trường hợp kết quả trong ngoặc đơn, sẽ là một giá trị duy nhất hoặc một bộ chứa mỗi giá trị.

Hàm đánh giá hiện xử lý tất cả độ dài đối số mà không có giới hạn nhân tạo.

Suy luận kiểu làm cho API sử dụng các gói tham số tự nhiên để sử dụng mà không cần biết rằng API đang sử dụng chúng.

Gọi hàm đánh giá mới của chúng tôi hiện có thể xử lý bất kỳ số lượng đối số nào, trông giống như gọi quá tải có độ dài cố định.

Swift suy ra loại của mỗi đối số cùng với tổng số dựa trên cách bạn gọi hàm.

Để tìm hiểu về cách viết các API thư viện chung như thế này, hãy xem Generalize APIs bằng cách sử dụng các gói tham số.

Gọi các API chung một cách tự nhiên thể hiện một trong những mục tiêu thiết kế cơ bản của Swift, thể hiện rõ ràng thông qua mã ngắn gọn.

Các tính năng ngôn ngữ nâng cao của Swift cho phép các API đẹp mắt giúp bạn dễ dàng nói ra ý của mình hơn.

Bạn được hưởng lợi từ các tính năng ngôn ngữ nâng cao này ngay từ những dòng đầu tiên của Swift mà bạn từng viết, cho dù đó là sử dụng chung chung thông qua mảng hoặc từ điển hay thiết kế giao diện người dùng trong SwiftUI.

Việc Swift nắm bắt tiết lộ tiến bộ có nghĩa là bạn có thể tìm hiểu về các tính năng nâng cao hơn khi bạn sẵn sàng.

Swift 5.9 đưa cách tiếp cận thiết kế này lên một tầm cao mới bằng cách cung cấp cho các tác giả thư viện một hộp công cụ mới để thiết kế API biểu cảm bằng cách sử dụng một hệ thống vĩ mô mới.

Đây là Doug để cho bạn biết thêm.

Doug: Với macro, bạn có thể mở rộng khả năng của chính ngôn ngữ, loại bỏ bản mẫu và mở khóa nhiều sức mạnh biểu cảm của Swift hơn.

Hãy xem xét hàm khẳng định luôn hiện diện, kiểm tra xem một điều kiện có đúng hay không.

Assert sẽ dừng chương trình nếu điều kiện sai, nhưng khi điều đó xảy ra, bạn sẽ nhận được rất ít thông tin về những gì đã xảy ra, chỉ có tệp và số dòng.

Bạn sẽ cần thêm một số ghi nhật ký hoặc bẫy chương trình trong trình gỡ lỗi để tìm hiểu thêm.

Đã có những nỗ lực để cải thiện điều này.

XCTest cung cấp một phép toán khẳng định bằng nhau lấy hai giá trị riêng biệt, vì vậy khi mọi thứ thất bại, ít nhất bạn có thể thấy hai giá trị không bằng nhau.

Nhưng chúng tôi vẫn không biết giá trị nào sai ở đây.

Đó là a, b, hay kết quả của max?

Và cách tiếp cận này thực sự không mở rộng quy mô cho tất cả các loại kiểm tra mà chúng tôi thực hiện trong các khẳng định.

Nếu chúng ta quay lại khẳng định ban đầu, có rất nhiều thông tin ở đây trong mã nguồn mà chúng ta muốn thấy trong nhật ký khi khẳng định của chúng ta không thành công.

Mã là gì?

Các giá trị của a, và b, và c là gì?

Max đã sản xuất cái gì?

Chúng tôi không thể cải thiện điều này trong Swift trước đây nếu không có một số tính năng tùy chỉnh, nhưng macro làm cho nó có thể.

Trong ví dụ này, cú pháp "hash-assert" đang mở rộng macro được gọi là "assert".

Cú pháp băm có thể trông quen thuộc vì Swift đã có một vài thứ với cùng cách viết này, như tệp băm, bộ chọn băm và cảnh báo băm.

Macro khẳng định trông và cảm thấy giống như phiên bản chức năng, nhưng vì nó là một macro, nó có thể cung cấp trải nghiệm phong phú hơn khi khẳng định không thành công.

Bây giờ chương trình đang hiển thị mã cho xác nhận không thành công, cùng với từng giá trị đã đóng góp vào kết quả.

Trong Swift, macro là API, giống như các loại hoặc hàm, vì vậy bạn truy cập chúng bằng cách nhập mô-đun xác định chúng.

Giống như nhiều API khác, macro được phân phối dưới dạng các gói.

Macro khẳng định ở đây đến từ thư viện khẳng định sức mạnh, một gói Swift mã nguồn mở có sẵn trên GitHub.

Nếu bạn nhìn vào gói macro, bạn sẽ tìm thấy một khai báo macro để khẳng định.

Nó được giới thiệu với từ khóa "macro", nhưng nếu không, nó trông rất giống một hàm.

Có một tham số Bool không được gắn nhãn duy nhất cho điều kiện được kiểm tra.

Nếu macro này tạo ra một giá trị, loại kết quả đó sẽ được viết bằng cú pháp mũi tên thông thường.

Việc sử dụng macro sẽ được kiểm tra kiểu dựa trên các tham số.

Điều đó có nghĩa là, nếu bạn mắc lỗi khi sử dụng macro, chẳng hạn như quên so sánh giá trị tối đa với thứ gì đó, bạn sẽ nhận được thông báo lỗi hữu ích ngay lập tức, trước khi macro được mở rộng.

Điều này cho phép Swift cung cấp trải nghiệm phát triển tuyệt vời khi sử dụng macro vì macro hoạt động trên các đầu vào được nhập tốt và tạo mã giúp tăng cường chương trình của bạn theo những cách có thể dự đoán được.

Hầu hết các macro được định nghĩa là "các macro bên ngoài", chỉ định mô-đun và loại để triển khai macro thông qua các chuỗi.

Các loại macro bên ngoài được xác định trong các chương trình riêng biệt hoạt động như các plugin trình biên dịch.

Trình biên dịch Swift chuyển mã nguồn để sử dụng macro cho plugin.

Plugin tạo ra mã nguồn mới, sau đó được tích hợp lại vào chương trình Swift.

Ở đây, macro đang mở rộng xác nhận thành mã nắm bắt các giá trị riêng lẻ và nơi chúng sẽ được hiển thị trong mã nguồn.

Bạn sẽ không muốn tự viết bản mẫu, nhưng macro sẽ làm điều đó cho bạn.

Khai báo vĩ mô có một phần thông tin bổ sung, vai trò của chúng.

Macro khẳng định ở đây là một macro biểu thức độc lập.

Nó được gọi là độc lập vì nó sử dụng cú pháp "hash" và hoạt động trực tiếp trên cú pháp đó để tạo ra mã mới.

Nó là một biểu thức vĩ mô bởi vì nó có thể được sử dụng ở bất cứ nơi nào mà người ta có thể tạo ra một giá trị.

Các API Foundation Predicate mới cung cấp một ví dụ tuyệt vời về macro biểu thức.

Vĩ mô vị ngữ cho phép người ta viết vị ngữ theo cách an toàn kiểu bằng cách sử dụng các đóng.

Các giá trị vị ngữ kết quả sau đó có thể được sử dụng với một số API khác, bao gồm các hoạt động thu thập Swift SwiftUI và SwiftData.

Bản thân macro là chung chung so với tập hợp các loại đầu vào.

Nó chấp nhận một đối số đóng là một hàm hoạt động trên các giá trị của các loại đầu vào đó và tạo ra kết quả Boolean, tập hợp các đầu vào có khớp hay không?

Và macro trả về một thể hiện của loại Vị ngữ mới, có thể được sử dụng ở nơi khác trong chương trình.

Nhưng có nhiều macro hơn vì rất nhiều bản mẫu mà chúng tôi cuối cùng viết là vì chúng tôi cần tăng cường mã mà chúng tôi đã viết với thứ khác có nguồn gốc từ nó.

Hãy lấy một ví dụ.

Tôi thấy rằng tôi sử dụng enums rất nhiều trong mã của riêng mình, như Enum Đường dẫn này nắm bắt các đường dẫn tương đối hoặc tuyệt đối.

Nhưng tôi thường thấy mình cần kiểm tra một trường hợp cụ thể, giả sử, bằng cách lọc tất cả các đường dẫn tuyệt đối từ một bộ sưu tập.

Tất nhiên, tôi có thể viết đây là Kiểm tra tuyệt đối như một thuộc tính được tính toán.

Nhưng sớm hay muộn, tôi sẽ phải viết một cái khác.

Điều này đang trở nên hơi tẻ nhạt.

Macros có thể giúp ích ở đây bằng cách tạo ra bản mẫu cho chúng tôi.

Phát hiện trường hợp là một macro đính kèm, được viết bằng cách sử dụng cú pháp thuộc tính tùy chỉnh giống như trình bao bọc thuộc tính.

Các macro đính kèm lấy cú pháp của khai báo mà chúng áp dụng làm đầu vào - đây là chính khai báo enum - và sẽ tạo mã mới.

Mã mở rộng vĩ mô này là mã Swift bình thường, mà trình biên dịch tích hợp vào chương trình của bạn.

Bạn có thể kiểm tra mã được tạo vĩ mô trong trình chỉnh sửa của mình, gỡ lỗi vào nó, sao chép nó nếu bạn muốn tùy chỉnh nó hơn nữa, v.v.

Các macro đính kèm được phân thành năm vai trò khác nhau dựa trên cách chúng tăng cường tuyên bố mà chúng được đính kèm.

Macro phát hiện trường hợp mà chúng ta vừa thảo luận là macro đính kèm "thành viên", có nghĩa là nó tạo ra các thành viên mới trong một loại hoặc tiện ích mở rộng.

Các macro ngang hàng thêm các khai báo mới cùng với khai báo mà chúng được đính kèm, ví dụ, để tạo phiên bản xử lý hoàn thành của một phương thức không đồng bộ hoặc ngược lại.

Các macro truy cập có thể biến một thuộc tính được lưu trữ thành một thuộc tính được tính toán, có thể được sử dụng để thực hiện các hành động cụ thể về quyền truy cập thuộc tính hoặc trừu tượng hóa lưu trữ thực tế theo cách tương tự, nhưng linh hoạt hơn các trình bao bọc thuộc tính.

Và các macro đính kèm có thể giới thiệu các thuộc tính cho các thành viên cụ thể của một loại, cũng như thêm các tuân thủ giao thức mới.

Một số vai trò vĩ mô đính kèm có thể được cấu tạo cùng nhau để đạt được các hiệu ứng hữu ích.

Một ví dụ quan trọng về điều này là với sự quan sát.

Quan sát luôn là một phần của SwiftUI.

Để có thể quan sát các thay đổi đối với các thuộc tính của một lớp, người ta chỉ cần làm cho loại phù hợp với ObservableObject và đánh dấu mọi thuộc tính tại-Published và sử dụng trình bao bọc thuộc tính ObservedObject trong chế độ xem của bạn.

Đó là một loạt các bước và việc bỏ lỡ một bước có thể có nghĩa là giao diện người dùng không cập nhật như mong đợi.

Chúng ta có thể làm tốt hơn với quan sát dựa trên vĩ mô.

Gắn macro Observable vào một lớp cung cấp sự quan sát cho tất cả các thuộc tính được lưu trữ của nó.

Không cần phải chú thích từng thuộc tính được lưu trữ hoặc lo lắng về những gì sẽ xảy ra nếu bạn không làm vậy vì macro Observable xử lý tất cả.

Vĩ mô có thể quan sát được hoạt động thông qua thành phần của ba vai trò vĩ mô.

Hãy đi sâu vào cách những vai trò này hoạt động cùng nhau.

Mỗi vai trò vĩ mô tương ứng với một cách cụ thể trong đó lớp Person được tăng cường bởi macro Observable.

Vai trò thành viên giới thiệu các thuộc tính và phương pháp mới.

Vai trò thuộc tính thành viên sẽ thêm macro @ObservationTracked vào các thuộc tính được lưu trữ của lớp quan sát được, từ đó mở rộng thành getters và setters để kích hoạt các sự kiện quan sát.

Cuối cùng, vai trò phù hợp giới thiệu sự phù hợp với giao thức Observable.

Điều này có thể trông giống như rất nhiều mã, nhưng tất cả chỉ là mã Swift bình thường và nó được gấp gọn gàng phía sau macro Observable.

Bất cứ khi nào bạn cần xem bất kỳ macro nào mở rộng như thế nào để hiểu rõ hơn về ảnh hưởng của nó đối với chương trình của bạn, nó sẽ nằm ngay trong tầm tay bạn trong Xcode.

Sử dụng hành động "Mở rộng Macro" để xem mã nguồn mở rộng vĩ mô trong trình chỉnh sửa của bạn.

Bất kỳ thông báo lỗi nào trong mã được tạo vĩ mô sẽ tự động hiển thị mã mở rộng và bạn có thể bước vào và ra khỏi nó bằng trình gỡ lỗi của mình.

Các macro Swift cung cấp một công cụ mới để cho phép các API biểu cảm hơn và loại bỏ bản mẫu khỏi mã Swift của bạn, giúp mở khóa sức mạnh biểu cảm của Swift.

Kiểu macro - kiểm tra đầu vào của chúng, tạo mã Swift bình thường và tích hợp tại các điểm xác định trong chương trình của bạn, vì vậy hiệu ứng của chúng rất dễ suy luận.

Và bất cứ khi nào bạn cần hiểu macro đã làm gì, mã nguồn mở rộng của nó sẽ ở ngay trong trình chỉnh sửa của bạn.

Chúng tôi vừa làm xước bề mặt của macro.

"Mở rộng trên macro Swift" sẽ đi sâu vào thiết kế của macro Swift để trả lời tất cả những câu hỏi mà bạn phải có.

Và bạn có thể thực hành triển khai macro của riêng mình với "Write Swift macros".

Tôi nóng lòng muốn xem cộng đồng Swift sẽ xây dựng những macro mới nào.

Ben: Ngay từ đầu, Swift đã được thiết kế để trở thành một ngôn ngữ có thể mở rộng.

Thiết kế của Swift nhấn mạnh tính biểu cảm với mã rõ ràng và súc tích, ít nghi lễ và dễ đọc và viết.

Bằng cách tận dụng các tính năng mạnh mẽ của Swift, như generics và hỗ trợ đồng thời gốc, các khuôn khổ như SwiftUI hoặc SwiftData cho phép bạn nhanh chóng đạt được kết quả bạn muốn, giúp bạn có nhiều thời gian hơn để tập trung vào những gì quan trọng.

Mặc dù có những khả năng cấp cao này, Swift cũng hiệu quả.

Nó biên dịch nguyên bản và việc sử dụng các loại giá trị và đếm tham chiếu thay vì thu gom rác có nghĩa là nó có thể đạt được dấu chân bộ nhớ thấp.

Khả năng mở rộng này có nghĩa là chúng tôi có thể đẩy Swift đến nhiều nơi hơn so với trước đây có thể với Objective-C, đến các hệ thống cấp thấp, nơi trước đây bạn có thể mong đợi phải sử dụng C hoặc C++.

Điều này có nghĩa là mang mã rõ ràng hơn của Swift và đảm bảo an toàn quan trọng đến nhiều nơi hơn.

Gần đây chúng tôi đã mở nguồn bắt đầu viết lại khung Foundation trong Swift.

Sáng kiến này sẽ dẫn đến một triển khai chung duy nhất của Foundation trên cả nền tảng Apple và không phải của Apple.

Nhưng nó cũng có nghĩa là viết lại một lượng lớn mã Objective-C và C trong Swift.

Kể từ MacOS Sonoma và iOS 17, có các triển khai mới được hỗ trợ bởi Swift của các loại thiết yếu như Ngày và Lịch, các yếu tố cần thiết về định dạng và quốc tế hóa như Locale và AttributedString, và triển khai Swift mới của mã hóa và giải mã JSON.

Và những chiến thắng về hiệu suất rất đáng kể.

Khả năng tính toán các ngày quan trọng của lịch có thể tận dụng tốt hơn ngữ nghĩa giá trị của Swift để tránh phân bổ trung gian, dẫn đến cải thiện hơn 20% trong một số điểm chuẩn.

Định dạng ngày sử dụng FormatStyle cũng đã đạt được một số nâng cấp hiệu suất lớn, cho thấy sự cải thiện lớn 150% trong điểm chuẩn định dạng với mẫu ngày và giờ tiêu chuẩn.

Thú vị hơn nữa là những cải tiến để giải mã JSON trong gói mới.

Foundation có triển khai Swift hoàn toàn mới cho JSONDecoder và JSONEncoder, loại bỏ các chuyến đi khứ hồi tốn kém đến và đi từ các loại bộ sưu tập Objective-C.

Sự tích hợp chặt chẽ của phân tích cú pháp JSON trong Swift để khởi tạo các loại Codable cũng cải thiện hiệu suất.

Trong điểm chuẩn phân tích cú pháp dữ liệu kiểm tra, việc triển khai mới nhanh hơn từ hai đến năm lần.

Những cải tiến này đến từ việc giảm chi phí bắc cầu từ việc triển khai Objective-C cũ sang Swift, mà còn do việc triển khai dựa trên Swift mới nhanh hơn.

Hãy xem xét một điểm chuẩn làm ví dụ.

Ở Ventura, việc gọi enumerateDates từ Objective-C nhanh hơn một chút so với gọi nó từ Swift vì chi phí bắc cầu.

Trong MacOS Sonoma, việc gọi chức năng tương tự từ Swift nhanh hơn 20%.

Một số tốc độ tăng đó đến từ việc loại bỏ chi phí bắc cầu, nhưng bản thân việc triển khai chức năng mới cũng nhanh hơn, như đã thấy khi gọi nó từ Objective-C.

Việc tính toán ngày cụ thể này không quá phức tạp, vì vậy đây là một cách tuyệt vời để xem việc giảm chi phí giữa hai ngôn ngữ.

Bây giờ, đôi khi, khi bạn đang hoạt động ở các cấp thấp hơn của hệ thống, bạn cần kiểm soát chi tiết hơn để đạt được mức hiệu suất cần thiết.

Swift 5.9 giới thiệu một số khả năng chọn tham gia mới giúp bạn đạt được mức độ kiểm soát này.

Những khả năng này tập trung vào khái niệm quyền sở hữu, nghĩa là phần nào của mã "sở hữu" một giá trị khi nó truyền qua ứng dụng của bạn.

Để xem khi nào bạn có thể muốn sử dụng các tính năng này, trước tiên chúng ta hãy xem xét một số mã ví dụ.

Ở đây chúng tôi có một trình bao bọc rất đơn giản cho một bộ mô tả tệp cho phép chúng tôi cung cấp các cuộc gọi hệ thống cấp thấp một giao diện Swift đẹp hơn.

Nhưng vẫn còn một số cách dễ dàng để mắc lỗi với API này.

Ví dụ, bạn có thể thử ghi vào tệp sau khi bạn đã gọi đóng.

Và bạn phải cẩn thận để luôn đóng nó theo cách thủ công bằng cách gọi phương thức đóng trước khi loại đó đi ra khỏi phạm vi.

Nếu không, bạn sẽ bị rò rỉ tài nguyên.

Một giải pháp sẽ là biến nó thành một lớp với một deinit tự động đóng nó khi loại đó nằm ngoài phạm vi.

Nhưng điều đó có những nhược điểm khác nhau, như phân bổ bộ nhớ bổ sung, thường không phải là vấn đề lớn, ngoại trừ trong một số bối cảnh hệ thống rất hạn chế.

Các lớp học cũng có ngữ nghĩa tham chiếu.

Bạn có thể vô tình chia sẻ một loại mô tả tệp trên các luồng, dẫn đến điều kiện cuộc đua hoặc vô tình lưu trữ nó.

Nhưng chúng ta hãy quay lại và nhìn vào phiên bản cấu trúc.

Thực sự, cấu trúc này cũng hoạt động giống như một loại tham chiếu.

Nó chứa một số nguyên tham chiếu đến giá trị thực, đó là một tệp đang mở.

Tạo một bản sao thuộc loại này cũng có thể dẫn đến việc chia sẻ trạng thái có thể thay đổi không chủ ý trên ứng dụng của bạn theo những cách có thể dẫn đến lỗi.

Những gì bạn muốn là ngăn chặn khả năng tạo một bản sao của cấu trúc này.

Các loại Swift, dù là cấu trúc hay lớp, đều có thể sao chép theo mặc định.

Đây là sự lựa chọn đúng đắn hầu hết thời gian.

Mặc dù các bản sao không cần thiết quá mức đôi khi có thể là nút cổ chai trong mã của bạn, nhưng tốt hơn là thỉnh thoảng nên dành thời gian tìm những nút thắt cổ chai đó trong các công cụ hơn là liên tục bị làm phiền bởi trình biên dịch yêu cầu bạn phải rõ ràng về những bản sao đó.

Nhưng đôi khi bản sao ngầm đó không phải là những gì bạn muốn - đặc biệt, khi tạo bản sao của một giá trị có thể dẫn đến các vấn đề về tính chính xác, như với trình bao bọc mô tả tệp của chúng tôi.

Trong Swift 5.9, bạn có thể làm điều đó với cú pháp mới này có thể được áp dụng cho các khai báo cấu trúc và liệt kê và ngăn chặn khả năng ngầm để sao chép một loại.

Khi một kiểu không thể sao chép được, bạn có thể cung cấp cho nó một deinit, giống như bạn có thể là một lớp, sẽ chạy khi một giá trị của kiểu đó nằm ngoài phạm vi.

Các loại không thể sao chép cũng có thể được sử dụng để giải quyết vấn đề gọi đóng và sau đó sử dụng các phương pháp khác.

Hoạt động đóng có thể được đánh dấu là tiêu thụ.

Gọi một phương thức hoặc đối số tiêu thụ từ bỏ quyền sở hữu một giá trị cho phương thức bạn đã gọi.

Vì loại của chúng tôi không thể sao chép được, từ bỏ quyền sở hữu có nghĩa là bạn không thể sử dụng giá trị nữa.

Theo mặc định, các phương thức trong Swift mượn các đối số của chúng, bao gồm cả bản thân.

Vì vậy, bạn có thể gọi phương thức ghi, mượn bộ mô tả tệp, sử dụng nó để ghi vào bộ đệm và sau đó, quyền sở hữu giá trị trả về cho người gọi và bạn có thể gọi một phương thức khác, như đóng.

Nhưng vì đóng cửa đã được đánh dấu là tiêu thụ, không phải là mặc định của việc vay, nó phải là mục đích sử dụng cuối cùng của nó.

Điều này có nghĩa là, nếu bạn đóng tệp trước và sau đó cố gắng gọi một phương thức khác, như ghi, bạn sẽ nhận được thông báo lỗi tại thời điểm biên dịch, thay vì lỗi thời gian chạy.

Trình biên dịch cũng sẽ chỉ ra nơi sử dụng tiêu thụ xảy ra.

Các loại không thể sao chép là một tính năng mới mạnh mẽ cho lập trình cấp hệ thống trong Swift.

Chúng vẫn đang ở giai đoạn đầu trong quá trình tiến hóa của chúng.

Các phiên bản sau của Swift sẽ mở rộng trên các loại không thể sao chép trong mã chung.

Nếu bạn quan tâm đến việc theo dõi cùng với công việc này, nó đang được thảo luận tích cực trên các diễn đàn Swift.

Doug: Chìa khóa thành công của Swift là khả năng tương tác với Objective-C.

Ngay từ đầu, các nhà phát triển đã có thể thực hiện các bước gia tăng để áp dụng Swift trong các cơ sở mã hiện có của họ, trộn vào Swift một tệp hoặc mô-đun tại một thời điểm.

Nhưng chúng tôi biết rất nhiều bạn không chỉ có mã được viết bằng Objective-C.

Nhiều ứng dụng cũng có logic kinh doanh cốt lõi được triển khai trong C++ và việc giao tiếp với điều đó không hề dễ dàng như vậy.

Thường thì nó có nghĩa là thêm một lớp bắc cầu thủ công bổ sung, đi từ Swift, qua Objective-C, và sau đó vào C++, và tất cả các con đường trở lại.

Swift 5.9 giới thiệu khả năng tương tác với các loại và hàm C++ trực tiếp từ Swift.

Khả năng tương tác C++ hoạt động giống như khả năng tương tác Objective-C luôn có, ánh xạ các API C++ vào các tương đương Swift của chúng mà bạn có thể sử dụng trực tiếp từ mã Swift.

C++ là một ngôn ngữ lớn với các khái niệm riêng về các ý tưởng như lớp, phương thức, vùng chứa, v.v.

Trình biên dịch Swift hiểu các thành ngữ C++ phổ biến, vì vậy nhiều loại có thể được sử dụng trực tiếp.

Ví dụ, kiểu Người này xác định năm hàm thành viên đặc biệt được mong đợi của loại giá trị C++: Sao chép và di chuyển hàm tạo, toán tử gán và trình hủy.

Trình biên dịch Swift coi đây là một loại giá trị và sẽ tự động gọi đúng hàm thành viên đặc biệt vào đúng thời điểm.

Ngoài ra, các thùng chứa C++ như vectơ và bản đồ có thể truy cập được dưới dạng bộ sưu tập Swift.

Kết quả của tất cả những điều này là chúng ta có thể viết mã Swift đơn giản sử dụng trực tiếp các hàm và loại C++.

Chúng ta có thể lọc qua vectơ của các phiên bản Person, gọi các hàm thành viên C++ và truy cập trực tiếp vào các thành viên dữ liệu.

Theo hướng khác, việc sử dụng mã Swift từ C++ dựa trên cơ chế tương tự như với Objective-C.

Trình biên dịch Swift sẽ tạo ra một "tiêu đề được tạo" có chứa chế độ xem C++ trên các API Swift.

Tuy nhiên, không giống như Objective-C, bạn không cần hạn chế bản thân chỉ sử dụng các lớp Swift được chú thích bằng thuộc tính objc.

C++ có thể trực tiếp sử dụng hầu hết các loại Swift và các API đầy đủ của chúng, bao gồm các thuộc tính, phương thức và trình khởi tạo, mà không cần bất kỳ chi phí bắc cầu nào.

Ở đây chúng ta có thể thấy cách C++ có thể sử dụng cấu trúc Điểm của chúng ta.

Sau khi bao gồm tiêu đề được tạo, C++ có thể gọi trình khởi tạo Swift để tạo các phiên bản Point, gọi các phương thức đột biến và truy cập cả thuộc tính được lưu trữ và tính toán, tất cả mà không có bất kỳ thay đổi nào đối với chính mã Swift.

Khả năng tương tác C++ của Swift giúp tích hợp Swift với các cơ sở mã C++ hiện có trở nên dễ dàng hơn bao giờ hết.

Nhiều thành ngữ C++ có thể được thể hiện trực tiếp bằng Swift, thường là tự động, nhưng đôi khi yêu cầu một số chú thích để chỉ ra ngữ nghĩa mong muốn.

Và Swift APIs có thể được truy cập trực tiếp từ C++, không yêu cầu chú thích hoặc thay đổi mã, giúp bạn có thể áp dụng Swift từng bước trong toàn bộ cơ sở mã bằng cách sử dụng bất kỳ sự kết hợp nào của C, C++ và Objective-C.

Khả năng tương tác C++ là một câu chuyện đang phát triển, được hướng dẫn bởi nhóm làm việc khả năng tương tác C++.

Để biết thêm thông tin, vui lòng xem bài nói chuyện "Trộn Swift và C++", hoặc tham gia cùng chúng tôi trong cuộc thảo luận trên diễn đàn Swift.

Khả năng tương tác ở cấp độ ngôn ngữ thực sự quan trọng, nhưng bạn cũng phải có khả năng xây dựng mã của mình.

Và việc phải thay thế hệ thống xây dựng hiện tại của bạn bằng Xcode hoặc Trình quản lý gói Swift để thậm chí bắt đầu với Swift có thể là một rào cản lớn như viết lại một lượng lớn mã.

Đó là lý do tại sao chúng tôi làm việc với cộng đồng CMake để cải thiện hỗ trợ Swift trong CMake.

Bạn có thể tích hợp mã Swift vào bản dựng CMake của mình bằng cách khai báo Swift là một trong những ngôn ngữ cho dự án và đưa các tệp Swift vào mục tiêu.

Quan trọng hơn, bạn có thể kết hợp C++ và Swift trong một mục tiêu duy nhất và CMake sẽ đảm bảo biên dịch từng thư riêng biệt và liên kết tất cả các thư viện hỗ trợ và thời gian chạy thích hợp cho cả hai ngôn ngữ.

Điều này có nghĩa là bạn có thể bắt đầu áp dụng Swift trong các dự án C++ đa nền tảng của mình ngay hôm nay, từng tệp hoặc nhắm mục tiêu theo mục tiêu.

Chúng tôi cũng đang cung cấp một kho lưu trữ mẫu với các dự án CMake chứa Swift và các mục tiêu C++/Swift hỗn hợp, bao gồm cả việc sử dụng các tiêu đề bắc cầu và được tạo, để giúp bạn bắt đầu.

Một vài năm trước, chúng tôi đã giới thiệu một mô hình đồng thời mới vào Swift dựa trên các khối xây dựng của async/await, đồng thời có cấu trúc và các tác nhân.

Mô hình đồng thời của Swift là một mô hình trừu tượng, có thể được điều chỉnh cho các môi trường và thư viện khác nhau.

Mô hình trừu tượng có hai phần chính: Nhiệm vụ và diễn viên.

Các nhiệm vụ đại diện cho một đơn vị công việc tuần tự có thể chạy về mặt khái niệm ở bất cứ đâu.

Các nhiệm vụ có thể bị đình chỉ bất cứ khi nào có "chờ đợi" trong chương trình, và sau đó tiếp tục khi nhiệm vụ có thể tiếp tục.

Các tác nhân là một cơ chế đồng bộ hóa cung cấp quyền truy cập độc quyền lẫn nhau vào trạng thái biệt lập.

Bước vào một diễn viên từ bên ngoài yêu cầu "chờ đợi" vì nó có thể tạm dừng nhiệm vụ.

Các nhiệm vụ và tác nhân được tích hợp vào mô hình ngôn ngữ trừu tượng, nhưng trong mô hình đó, chúng có thể được thực hiện theo nhiều cách khác nhau để phù hợp với các môi trường khác nhau.

Các nhiệm vụ được thực hiện trên nhóm đồng thời toàn cầu.

Làm thế nào mà nhóm đồng thời toàn cầu quyết định lên lịch làm việc tùy thuộc vào môi trường.

Đối với các nền tảng của Apple, thư viện Dispatch cung cấp lịch trình được tối ưu hóa cho toàn bộ hệ điều hành và đã được điều chỉnh rộng rãi cho từng nền tảng.

Trong các môi trường hạn chế hơn, chi phí của bộ lập lịch đa luồng có thể không được chấp nhận.

Ở đó mô hình đồng thời của Swift được triển khai với một hàng đợi hợp tác đơn luồng.

Cùng một mã Swift hoạt động trong cả hai môi trường vì mô hình trừu tượng đủ linh hoạt để ánh xạ đến các môi trường thời gian chạy đa dạng.

Ngoài ra, khả năng tương tác với các thư viện dựa trên cuộc gọi lại đã được tích hợp vào hỗ trợ không đồng bộ/chờ đợi của Swift ngay từ đầu.

Các hoạt động withCheckedContinuation cho phép người ta tạm dừng một nhiệm vụ và sau đó tiếp tục nó sau đó để phản hồi cuộc gọi lại.

Điều này cho phép tích hợp với các thư viện hiện có tự quản lý các nhiệm vụ.

Việc triển khai tiêu chuẩn của các tác nhân trong thời gian chạy đồng thời Swift là một hàng đợi các tác vụ không cần khóa để thực hiện trên tác nhân, nhưng nó không phải là cách triển khai khả thi duy nhất.

Trong một môi trường hạn chế hơn, người ta có thể không có nguyên tử, và thay vào đó có thể sử dụng một nguyên thủy đồng thời khác như spinlocks.

Nếu môi trường đó là đơn luồng, không cần đồng bộ hóa, nhưng mô hình diễn viên vẫn duy trì mô hình đồng thời trừu tượng cho chương trình bất kể.

Bạn vẫn có thể mang cùng một mã đó đến một môi trường khác có nhiều luồng.

Với Swift 5.9, các trình thực thi diễn viên tùy chỉnh cho phép một diễn viên cụ thể thực hiện cơ chế đồng bộ hóa của riêng nó.

Điều này làm cho các diễn viên linh hoạt hơn và thích nghi với môi trường hiện có.

Hãy lấy một ví dụ.

Ở đây chúng tôi xem xét một diễn viên quản lý kết nối cơ sở dữ liệu.

Swift đảm bảo quyền truy cập độc quyền lẫn nhau vào bộ nhớ của tác nhân này, vì vậy sẽ không có bất kỳ quyền truy cập đồng thời nào vào cơ sở dữ liệu.

Tuy nhiên, điều gì sẽ xảy ra nếu bạn cần kiểm soát nhiều hơn đối với cách thức cụ thể mà đồng bộ hóa được thực hiện?

Ví dụ, điều gì sẽ xảy ra nếu bạn muốn sử dụng một hàng đợi điều phối cụ thể cho kết nối cơ sở dữ liệu của mình, có lẽ vì hàng đợi đó được chia sẻ với mã khác chưa áp dụng các tác nhân?

Với những người thực thi diễn viên tùy chỉnh, bạn có thể.

Ở đây chúng tôi đã thêm một hàng đợi điều phối nối tiếp cho tác nhân của chúng tôi và triển khai thuộc tính người thực thi không thuộc sở hữu tạo ra người thực thi tương ứng với hàng đợi điều phối đó.

Với sự thay đổi này, tất cả sự đồng bộ hóa cho các trường hợp diễn viên của chúng tôi sẽ xảy ra thông qua hàng đợi đó.

Khi bạn "chờ đợi" cuộc gọi cắt tỉaOldEntries từ bên ngoài diễn viên, điều này bây giờ sẽ thực hiện một công văn không đồng bộ trên hàng đợi tương ứng.

Điều này cho phép bạn kiểm soát nhiều hơn cách các diễn viên riêng lẻ cung cấp đồng bộ hóa và thậm chí cho phép bạn đồng bộ hóa một diễn viên với mã khác chưa sử dụng diễn viên, có lẽ vì nó được viết bằng Objective-C hoặc C++.

Việc đồng bộ hóa các tác nhân thông qua hàng đợi điều phối được thực hiện bởi vì hàng đợi điều phối phù hợp với giao thức SerialExecutor mới.

Bạn có thể cung cấp cơ chế đồng bộ hóa của riêng mình để sử dụng với các tác nhân bằng cách xác định một loại mới phù hợp với giao thức này chỉ có một vài thao tác cốt lõi: Kiểm tra xem mã đã được thực thi trong ngữ cảnh của người thực thi hay chưa.

Ví dụ, chúng ta có đang chạy trên luồng chính không?

Trích xuất một tham chiếu không thuộc sở hữu cho người thực thi để cho phép truy cập vào nó mà không cần lưu lượng truy cập đếm tham chiếu dư thừa.

Và hoạt động cốt lõi nhất, enqueue, có quyền sở hữu một "công việc" thực thi.

Một công việc là một phần của nhiệm vụ không đồng bộ cần chạy đồng bộ trên người thực thi.

Tại thời điểm mà enqueue được gọi, người thực thi có trách nhiệm chạy công việc đó tại một thời điểm nào đó khi không có mã nào khác chạy trên trình thực thi nối tiếp.

Ví dụ, enqueue cho một hàng đợi công văn sẽ gọi công văn không đồng bộ trên hàng đợi đó.

Swift Concurrency đã được sử dụng trong vài năm nay và mô hình trừu tượng của nó bao gồm các tác vụ và diễn viên bao gồm một loạt các tác vụ lập trình đồng thời.

Bản thân mô hình trừu tượng khá linh hoạt, giúp nó thích ứng với các môi trường thực thi khác nhau, từ iPhone đến Đồng hồ Apple, đến máy chủ và hơn thế nữa.

Nó cũng cho phép tùy chỉnh tại các điểm chính để cho phép nó tương tác với mã chưa áp dụng đầy đủ Swift Concurrency.

Để biết thêm thông tin, vui lòng xem bài nói chuyện "Hậu trường" của chúng tôi, cũng như "Ngoài những điều cơ bản về Đồng thời có cấu trúc."

Tôi muốn kết thúc với một nghiên cứu điển hình về Swift hoạt động trong một môi trường rất khác với các ứng dụng iOS hoặc MacOS nơi chúng ta đã quen nhìn thấy nó.

FoundationDB là một cơ sở dữ liệu phân tán, cung cấp một giải pháp có thể mở rộng cho các kho lưu trữ khóa-giá trị rất lớn chạy trên phần cứng hàng hóa và hỗ trợ nhiều nền tảng khác nhau, bao gồm MacOS, Linux và Windows.

FoundationDB là một dự án mã nguồn mở với cơ sở mã lớn được viết bằng C++.

Mã không đồng bộ nhiều, với dạng tác nhân phân tán và thời gian chạy riêng cung cấp một môi trường mô phỏng xác định cực kỳ quan trọng cho mục đích thử nghiệm.

FoundationDB đang tìm cách hiện đại hóa cơ sở mã của họ và nhận thấy Swift phù hợp với hiệu suất, độ an toàn và độ rõ ràng của mã.

Viết lại hoàn toàn sẽ là một nỗ lực lớn, đầy rủi ro.

Thay vào đó, chúng tôi tận dụng khả năng tương tác của Swift để tích hợp vào cơ sở mã hiện có.

Ví dụ, đây là một phần của việc triển khai C++ của diễn viên "dữ liệu chính" của FoundationDB.

Có rất nhiều điều đang diễn ra ở đây, và bạn không cần phải hiểu tất cả C++ này.

Tuy nhiên, tôi muốn chỉ ra một vài khía cạnh chính của mã.

Đầu tiên, C++ không có async/await, vì vậy FoundationDB có cách tiếp cận giống như bộ tiền xử lý của riêng họ để mô phỏng nó.

Giống như nhiều cơ sở mã C++, họ đã triển khai loại C++ Future của riêng mình để quản lý các tác vụ không đồng bộ.

Chúng kết hợp với tin nhắn rõ ràng để gửi phản hồi cho các yêu cầu.

Lưu ý việc ghép nối cẩn thận việc gửi câu trả lời với việc trả về từ chức năng.

Cuối cùng, FoundationDB có các con trỏ thông minh đếm tham chiếu của riêng mình để giúp quản lý bộ nhớ tự động.

Chúng ta có thể thực hiện toàn bộ điều này một cách sạch sẽ hơn nhiều trong Swift.

Điều đó tốt hơn.

Chức năng này có thể được triển khai trực tiếp như một chức năng không đồng bộ trong Swift.

Chúng tôi có một loại trả về bình thường và các câu lệnh trả về bình thường để cung cấp phản hồi cho yêu cầu này, vì vậy bạn không bao giờ có thể không đồng bộ.

Chúng tôi có một "chờ đợi" để chỉ ra điểm tạm ngưng theo cách tương tự như tất cả các mã Swift không đồng bộ khác.

Và mã Swift này liên kết với loại Tương lai C++ được điều chỉnh bằng cách sử dụng tiếp tục.

Chúng tôi đang sử dụng một số loại C++ ở đây.

Kiểu MasterData trong C++ đang sử dụng một con trỏ thông minh đếm tham chiếu.

Bằng cách chú thích loại trong C++, trình biên dịch Swift có thể sử dụng loại này giống như bất kỳ lớp nào khác, tự động quản lý số lượng tham chiếu cho chúng tôi.

Các loại khác, chẳng hạn như các loại yêu cầu và trả lời, là các loại giá trị C++ đang được sử dụng trực tiếp trong Swift.

Và khả năng tương tác đi theo cả hai cách.

Chức năng không đồng bộ này, và thực sự, tất cả các công việc được giới thiệu bởi mô hình đồng thời Swift, chạy trên thời gian chạy xác định hiện có của FoundationDB.

Vì vậy, chúng tôi có thể nhận được lợi ích của Swift ở nơi chúng tôi muốn, giao tiếp với C++ hiện có để cho phép áp dụng dần dần trong suốt.

Trong phiên này, chúng tôi đã bao quát rất nhiều nền tảng.

Chúng tôi đã mô tả các tính năng như gói tham số và macro cho phép các API biểu cảm hơn và có thể giúp bạn viết mã tốt hơn nhanh hơn.

Chúng tôi đã nói về việc sử dụng Swift trong mã nhạy cảm với hiệu suất và giới thiệu các loại không thể sao chép để cung cấp quản lý tài nguyên mà không cần chi phí đếm tham chiếu.

Sau đó, chúng tôi đi sâu vào khả năng tương tác C++, cung cấp hỗ trợ cho việc sử dụng API C++ trong Swift và ngược lại, giúp mang lại lợi ích của Swift cho nhiều mã của bạn dễ dàng hơn.

Cuối cùng, chúng tôi đã nói về cách mô hình đồng thời linh hoạt của Swift có thể thích ứng với vô số môi trường trên các thiết bị và ngôn ngữ để giúp đồng thời dễ dàng và an toàn hơn.

Các gói thông số, macro, các loại không thể sao chép và tất cả các cải tiến ngôn ngữ khác trong Swift 5.9 đã được thiết kế và phát triển công khai thông qua quy trình Swift Evolution và phản hồi của cộng đồng rất quan trọng trong việc định hình các tính năng này.

Swift 5.9 là đỉnh cao của vô số đóng góp từ các thành viên trong cộng đồng Swift, bao gồm các cuộc thảo luận thiết kế tích cực, báo cáo lỗi, yêu cầu kéo, nội dung giáo dục và hơn thế nữa.

Cảm ơn bạn đã biến Swift 5.9 thành bản phát hành tuyệt vời.

♪ ♪