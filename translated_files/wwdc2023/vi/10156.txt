10156

♪ ♪

Kyle: Xin chào, tôi là Kyle một thành viên của nhóm SwiftUI.

Hoạt hình là một thành phần quan trọng của thiết kế ứng dụng hiện đại.

Khi được áp dụng trang nhã, nó có thể mang lại cả sự rõ ràng và sức sống cho giao diện người dùng của bạn.

Làm cho việc thêm hoạt ảnh vào ứng dụng của bạn trở nên đơn giản là một trong những động lực cốt lõi của chúng tôi khi chúng tôi bắt đầu phát triển SwiftUI.

Đó là một lý do lớn tại sao SwiftUI được định hình theo cách của nó.

Phiên này là tổng quan về khả năng hoạt hình mạnh mẽ của SwiftUI và cách chúng hoạt động cùng nhau để tạo ra các hiệu ứng hình ảnh ấn tượng.

Tôi sẽ đề cập đến cách SwiftUI làm mới kết xuất của chế độ xem, xác định những gì cần tạo hiệu ứng động bằng Animatable, nội suy các giá trị theo thời gian bằng Animation và truyền ngữ cảnh cho bản cập nhật hiện tại bằng Giao dịch.

Trong những năm gần đây, đã có cuộc tranh luận giữa các đồng nghiệp của tôi về việc ai làm cho bộ lông tốt nhất - hay không có lông - đồng hành.

Chúng tôi tò mò liệu chúng tôi có thể đi đến một sự đồng thuận hay không, vì vậy chúng tôi đã tạo một ứng dụng để tham gia một cuộc thăm dò ý kiến.

Có một nút để bỏ phiếu cho mỗi thú cưng.

Khi bạn nhấn, số phiếu bầu sẽ thay đổi và hình đại diện sẽ trượt xung quanh để phản ánh bảng xếp hạng hiện tại.

Trong cuộc thăm dò cuối cùng, như là thích hợp, mèo đứng ở vị trí đầu tiên, nhưng chỉ trong gang tấc.

Tiền đặt cược quá cao để rời khỏi cuộc thăm dò tiếp theo này hoàn toàn là cơ hội, vì vậy tôi đang thêm một tính năng mới.

Khi nhấn, hình đại diện mà tôi chọn sẽ mở rộng quy mô để thúc đẩy mọi người bỏ phiếu cho thú cưng thích hợp.

Và tôi có thể nhấn lại để thu nhỏ lại.

Điều này đã hoạt động khá tốt, nhưng nó sẽ tốt hơn với một hình ảnh động.

Trước khi thêm điều đó, tôi sẽ theo dõi cách SwiftUI làm mới kết xuất chế độ xem để giúp bạn hiểu rõ hơn về giải phẫu của bản cập nhật chế độ xem.

Đối với bài tập này, tôi sẽ tập trung vào chế độ xem hình đại diện thú cưng một cách riêng biệt.

SwiftUI theo dõi các phụ thuộc của chế độ xem, như biến trạng thái đã chọn này.

Khi một sự kiện, như một cú chạm, xuất hiện, một giao dịch cập nhật sẽ được mở.

Nếu bất kỳ phụ thuộc nào của nó thay đổi, chế độ xem sẽ bị vô hiệu và khi kết thúc giao dịch, khung sẽ gọi nội dung tạo ra một giá trị mới để làm mới kết xuất.

Phần thân của chế độ xem này bao gồm một cử chỉ chạm, hiệu ứng tỷ lệ và một hình ảnh.

Đằng sau hậu trường, SwiftUI duy trì một biểu đồ phụ thuộc tồn tại lâu dài để quản lý tuổi thọ của lượt xem và dữ liệu của chúng.

Mỗi nút trong biểu đồ này, được gọi là thuộc tính, ánh xạ đến một phần chi tiết của giao diện người dùng.

Khi trạng thái được chọn thay đổi thành true, giá trị của mỗi thuộc tính hạ nguồn này trở nên cũ kỹ.

Chúng được làm mới bằng cách mở gói giá trị chế độ xem mới từng lớp một.

Khi các thuộc tính biểu đồ tương ứng đã được cập nhật, giá trị cơ thể của chế độ xem sẽ bị loại bỏ.

Cuối cùng, biểu đồ thay mặt bạn phát ra các lệnh vẽ để cập nhật kết xuất.

Tôi sẽ phóng to chỉ trên biểu đồ để hình dung tuổi thọ của một thuộc tính.

Một thuộc tính được sinh ra với một giá trị ban đầu.

Một sự kiện diễn ra và một giao dịch cập nhật sẽ mở ra.

Sự phụ thuộc ngược dòng thay đổi.

Khuôn khổ gọi là cơ thể.

Giá trị của thuộc tính được cập nhật.

Giao dịch kết thúc.

Và theo cách này, giá trị hiện tại của mỗi thuộc tính trong biểu đồ phát triển theo thời gian.

Vậy đó là giải phẫu của bản cập nhật chế độ xem.

Bây giờ tôi sẽ thêm một hình ảnh động.

Nếu tôi kết thúc với Hoạt hình xung quanh sự thay đổi trạng thái của mình, khi thao tác đóng cử chỉ nhấn sẽ kích hoạt, hình sẽ được đặt cho giao dịch.

Sau đó được chọn được chuyển đổi và các thuộc tính hạ nguồn bị vô hiệu.

Như trước đây, cơ thể được gọi để cung cấp các giá trị thuộc tính mới.

Và đây là nơi nó trở nên thú vị.

scaleEffect là một thuộc tính đặc biệt, một "thuộc tính hoạt hình".

Khi giá trị của một thuộc tính hoạt hình thay đổi, nó sẽ kiểm tra xem một hình ảnh động có được đặt cho giao dịch hay không.

Nếu vậy, nó tạo một bản sao và sử dụng hình ảnh động để nội suy từ giá trị cũ sang giá trị mới khi thời gian trôi qua.

Tôi sẽ phóng to thuộc tính hoạt hình scaleEffect để kiểm tra xem điều này diễn ra như thế nào.

Điều đầu tiên cần lưu ý là các thuộc tính hoạt hình về mặt khái niệm có cả giá trị mô hình và bản trình bày.

Ngay bây giờ chúng giống nhau.

Sau đó, một sự kiện xuất hiện và một giao dịch được mở, lần này với một hình ảnh động.

Trạng thái được thay đổi và phần thân được gọi để làm mới các giá trị thuộc tính cũ.

Bởi vì giá trị đã thay đổi, thuộc tính tạo một bản sao cục bộ của hoạt ảnh để tính toán giá trị trình bày hiện tại.

SwiftUI biết khi nào biểu đồ thuộc tính chứa các hoạt ảnh đang chạy và sẽ gọi các thuộc tính có thể hoạt hình thích hợp để tạo ra khung tiếp theo.

Đối với các thuộc tính hoạt hình tích hợp như scaleEffect, SwiftUI rất hiệu quả.

Nó có thể thực hiện công việc này từ chuỗi chính và không cần gọi bất kỳ mã xem nào của bạn.

Đây là hình ảnh động đang hoạt động.

Tốt.

Khi ai đó sử dụng từ "hoạt hình", có lẽ họ đang đề cập đến trải nghiệm hình ảnh tổng thể về cách chế độ xem thay đổi theo thời gian.

Những gì tôi đã đề cập cho đến nay là, trong SwiftUI, có hai khía cạnh trực giao góp phần vào trải nghiệm hình ảnh tổng thể.

Các thuộc tính hoạt hình, như scaleEffect, xác định dữ liệu đang được hoạt hình, trong khi Animation xác định dữ liệu đó thay đổi như thế nào theo thời gian.

Tôi sẽ lần lượt đi sâu hơn vào từng thứ này, bắt đầu với Animatable, quyết định những gì cần tạo hiệu ứng động.

SwiftUI xây dựng một thuộc tính hoạt hình cho bất kỳ chế độ xem nào phù hợp với giao thức Hoạt hình.

Yêu cầu duy nhất là chế độ xem xác định một vectơ readwrite của dữ liệu mà nó muốn tạo hiệu ứng động.

Dữ liệu phải phù hợp với VectorArithmetic.

VectorArithmetic khớp với định nghĩa sách giáo khoa của một vectơ từ lớp toán của bạn.

Nó hỗ trợ phép cộng vectơ và phép nhân vô hướng.

Nếu bạn bị gỉ hoặc không quen thuộc với vectơ, đừng nản lòng.

Một vectơ về cơ bản chỉ là một danh sách các số có độ dài cố định và đối với hoạt hình SwiftUI, mục đích của việc xử lý các vectơ chủ yếu chỉ là trừu tượng hóa độ dài của danh sách đó.

Ví dụ, CGFloat và Double là vectơ một chiều, trong khi CGPoint và CGSize xác định vectơ hai chiều và CGRect xác định vectơ bốn chiều.

Bằng cách xử lý các vectơ, SwiftUI có thể tạo hiệu ứng động cho tất cả các loại này và hơn thế nữa với một triển khai chung duy nhất.

Cho đến nay, vì mục đích đơn giản, tôi đã trình bày scaleEffect như thể nó là một yếu tố tỷ lệ một chiều.

Sự phù hợp Animatable cho hiệu ứng thang đo một chiều sẽ rất đơn giản.

Dữ liệu hoạt hình của nó sẽ chỉ là một CGFloat.

Trong thực tế, scaleEffect cho phép bạn định cấu hình độc lập chiều rộng, chiều cao và điểm neo tương đối của phép biến đổi - tất cả đều có thể hoạt hình.

Vì vậy, scaleEffect thực sự xác định một vectơ bốn chiều cho dữ liệu có thể hoạt hình của nó, một CGSize cho tỷ lệ chiều rộng và chiều cao, được ghép nối với UnitPoint cho neo tương đối.

AnimatablePair hợp nhất hai vectơ lại với nhau thành một vectơ duy nhất, lớn hơn.

Đó là một loại công khai, và bạn cũng có thể sử dụng nó.

Nó có thể có ích nếu bạn đang tuân thủ một trong những quan điểm của riêng mình với Animatable.

scaleEffect chỉ là một trong nhiều hiệu ứng hình ảnh có thể hoạt hình được tích hợp trong SwiftUI, vì vậy phần lớn thời gian, Animatable không phải là một API bạn sẽ cần sử dụng trực tiếp.

Tuy nhiên, trong những trường hợp hiếm hoi, một trường hợp sử dụng nâng cao có thể yêu cầu phù hợp một trong những quan điểm của riêng bạn với Animatable.

Hãy xem xét chế độ xem Podium của thú cưng, phân phối các chế độ xem phụ của nó dọc theo vòng cung của một vòng tròn bằng cách sử dụng RadialLayout tùy chỉnh.

Theo mặc định, việc thay đổi góc bù trong một hình ảnh động làm sinh động hình đại diện thú cưng đến vị trí mới của chúng dọc theo một đường thẳng.

Chú ý cách thú cưng đang đi đường tắt và xâm phạm bên trong vòng tròn?

Đó không phải là điều tôi muốn.

Thay vào đó, tôi muốn hình đại diện của mình hoạt hình dọc theo chu vi của vòng tròn.

Tôi có thể có được hiệu ứng này bằng cách điều hướng Podium với animatable và sử dụng góc bù làm dữ liệu animatable của nó.

Tại sao điều này lại dẫn đến một hiệu ứng khác như vậy?

Để giải thích, tôi sẽ xem qua bản cập nhật hoạt hình cho từng phiên bản của chế độ xem Podium, bắt đầu với hành vi mặc định, làm sinh động các hình đại diện dọc theo một đường thẳng.

Cơ thể của Podium bao gồm một RadialLayout và ba hình đại diện.

Khi một giao dịch mở ra, nếu góc bù đã thay đổi, phần thân được gọi để làm mới các giá trị thuộc tính hạ lưu cũ.

Sau đó bố cục được chạy, cập nhật vị trí của mỗi chế độ xem phụ.

Vì vậy, đây là bản cập nhật hoạt hình trong phiên bản mặc định.

Dữ liệu hoạt hình hoạt động là vị trí xem CGPoint, nội suy trong không gian tọa độ Cartesian, có nghĩa là mỗi hình đại diện di chuyển dọc theo một đường thẳng.

Trong phiên bản tùy chỉnh, khi tôi tuân thủ Podium với Animatable, điều thay đổi là phần thân đó trở thành thuộc tính hoạt hình hoạt động, với góc bù làm dữ liệu hoạt hình của nó.

Điều này dẫn đến việc mỗi hình đại diện di chuyển dọc theo một vòng cung như thế nào?

Trong phiên bản tùy chỉnh này, đối với mỗi khung hình của hoạt ảnh, phần thân sẽ được SwiftUI gọi với góc bù mới và bố cục sẽ được chạy lại.

Điều này cực kỳ mạnh mẽ, và đôi khi, giống như khi bạn đang tạo hiệu ứng động cho bố cục tùy chỉnh hoặc mã vẽ, đó có thể là cách duy nhất để đạt được hiệu quả mà bạn đang đạt được.

Chỉ cần nhớ rằng sự phù hợp Animatable tùy chỉnh có thể đắt hơn nhiều để tạo hiệu ứng động so với hiệu ứng tích hợp vì nó sẽ chạy phần thân cho mọi khung hình của hoạt hình.

Vì vậy, chỉ sử dụng công cụ này nếu bạn không thể đạt được hiệu quả mà bạn sẽ sử dụng các hiệu ứng tích hợp sẵn.

Tiếp theo, tôi sẽ đề cập đến Animation, các thuật toán chung nội suy dữ liệu có thể hoạt hình theo thời gian.

Trước đó, tôi đã thêm một hình ảnh động vào chế độ xem hình đại diện thú cưng bằng cách gói thay đổi trạng thái trong withAnimation.

Bạn có thể tùy chỉnh điều này bằng cách chuyển một hình ảnh động rõ ràng, như một lò xo nảy.

SwiftUI đi kèm với rất nhiều hình ảnh động mạnh mẽ được tích hợp sẵn.

Chúng có thể được phân loại thành ba nhóm: Hoạt ảnh đường cong thời gian, hoạt ảnh mùa xuân và hoạt ảnh bậc cao hơn, sửa đổi hoạt ảnh cơ bản.

Hoạt hình đường cong thời gian có thể là thể loại hoạt hình mà bạn quen thuộc nhất.

Ví dụ, easeInOut là một hình ảnh động đường cong thời gian.

Tất cả các hình ảnh động đường cong thời gian đều có một đường cong, xác định tốc độ của hình ảnh động và thời lượng.

Một đường cong thời gian có thể được tạo ra bằng cách sử dụng các điểm kiểm soát bezier.

Bằng cách điều chỉnh các điểm kiểm soát bắt đầu và kết thúc, bạn thay đổi vận tốc ban đầu và cuối cùng của hoạt ảnh.

Loại UnitCurve có thể được sử dụng độc lập để tính toán giá trị và vận tốc tại một điểm tương đối từ 0 đến 1.

SwiftUI đi kèm với một số cài đặt trước đường cong thời gian tích hợp: Tuyến tính, dễ dàng, dễ dàng và dễ dàngInOut.

Tất cả các hình ảnh động đường cong thời gian cũng có thể chỉ định thời lượng tùy chỉnh.

Thể loại hoạt hình tiếp theo, Springs, xác định giá trị tại một thời điểm nhất định bằng cách chạy mô phỏng lò xo.

Bạn có thể quen thuộc với các cách truyền thống để xác định lò xo, ví dụ như khối lượng, độ cứng và giảm xóc.

Nhưng chúng tôi chưa bao giờ thấy những cách này đặc biệt trực quan, vì vậy chúng tôi đã phát minh ra một cách mới.

Bạn chỉ cần chỉ định thời lượng nhận thức của hoạt hình và mức độ bồng bềnh mà bạn muốn mùa xuân diễn ra.

Nó dễ tiếp cận hơn nhiều.

Tương tự như UnitCurve, loại Lò xo có thể được sử dụng độc lập để tính toán giá trị và vận tốc của lò xo tại một thời điểm nhất định.

SwiftUI đi kèm với ba cài đặt trước lò xo tích hợp: Smooth, không có độ nảy, linh hoạt, có một lượng nhỏ độ nảy và độ nảy, có độ nảy lớn hơn.

Nếu bạn không thoải mái khi tham số hóa hoạt ảnh mùa xuân, những cài đặt trước này là một cách đáng tin cậy để có được thứ gì đó cảm thấy tốt.

Mỗi cài đặt trước cũng có thể được điều chỉnh để điều chỉnh thời lượng hoặc điều chỉnh độ sáng.

Chúng tôi thực sự khuyên bạn nên sử dụng hình ảnh động mùa xuân vì chúng mang lại cho giao diện người dùng của bạn cảm giác hữu cơ bằng cách duy trì vận tốc và tự nhiên nghỉ ngơi.

Trên thực tế, chúng tôi cảm thấy rất mạnh mẽ về lợi ích của hoạt ảnh mùa xuân đến nỗi chúng tôi đã biến một mùa xuân mượt mà thành mặc định mới khi bạn sử dụng bare withAnimation trong iOS 17 và các bản phát hành được căn chỉnh.

Danh mục hoạt ảnh cuối cùng, Bậc cao hơn, sửa đổi hoạt ảnh cơ bản.

Họ có thể làm chậm nó hoặc tăng tốc nó.

Họ có thể thêm độ trễ trước khi hoạt ảnh cơ bản bắt đầu.

Và họ có thể lặp lại một hình ảnh động cơ bản bất kỳ số lần nào, tùy chọn chuyển đổi giữa chơi chuyển tiếp và chơi ngược lại.

Và bây giờ chúng tôi đang giới thiệu một thể loại hoạt hình hoàn toàn mới: Hoạt hình tùy chỉnh.

Giao thức CustomAnimation cung cấp cho bạn quyền truy cập vào cùng một điểm vào chung cấp thấp mà chúng tôi sử dụng để triển khai tất cả các hoạt ảnh được tích hợp trong SwiftUI.

Giao thức CustomAnimation có ba yêu cầu: animate, shouldMerge và velocity.

Tôi sẽ bắt đầu bằng cách tập trung vào hoạt hình.

shouldMerge và vận tốc là những yêu cầu tùy chọn.

Tôi sẽ quay lại với họ sau.

Animate được truyền vectơ để hoạt hình về phía, lượng thời gian đã trôi qua kể từ khi hoạt hình bắt đầu và ngữ cảnh, bao gồm trạng thái hoạt hình bổ sung.

Animate trả về giá trị hiện tại của hoạt ảnh, hoặc nil nếu hoạt hình đã hoàn thành.

Vectơ giá trị này đến từ đâu?

Nó đến từ dữ liệu có thể hoạt hình của chế độ xem.

Trong chế độ xem hình đại diện thú cưng, đó là hiệu ứng tỷ lệ.

Nhớ lại rằng dữ liệu có thể hoạt hình của scaleEffect là một vectơ bốn chiều, bao gồm thang đo chiều rộng và chiều cao hai chiều.

Khi hình đại diện được chọn, nó hoạt hình theo hệ số tỷ lệ 1,5 x 1,5 từ hệ số tỷ lệ 1 x 1.

Phép cộng vectơ và phép nhân vô hướng cho phép SwiftUI trừ hai vectơ này khỏi nhau để tính đồng bằng giữa chúng.

Đồng bằng này thực sự là những gì đang được hoạt hình.

Điều này có nghĩa là, trong thực tế, hoạt ảnh chạy trong thuộc tính hoạt hình hiệu ứng tỷ lệ không nội suy từ 1 đến 1,5, mà từ 0 đến 0,5.

Trong số những thứ khác, điều này giúp việc triển khai phương pháp hoạt hình thuận tiện hơn.

Để tôi chỉ cho bạn.

Tôi sẽ triển khai một hình ảnh động đường cong thời gian tuyến tính được cấu hình bởi một khoảng thời gian để nội suy.

Nhớ lại rằng hoạt hình được truyền vectơ delta để hoạt hình về phía.

Tôi có thể sử dụng phép nhân vô hướng để chia tỷ lệ vectơ theo tỷ lệ của khoảng thời gian đã trôi qua.

Và khi toàn bộ thời lượng đã trôi qua, tôi sẽ quay lại nil để chỉ ra rằng hình ảnh động đã hoàn thành và có thể bị xóa.

Thế là xong.

Và bởi vì việc triển khai này là chung chung, nó hoạt động với dữ liệu có thể hoạt hình của bất kỳ số lượng kích thước nào.

Vì vậy, đó là cách Animatable và Animation làm việc cùng nhau để tạo ra các hiệu ứng hình ảnh ấn tượng xuất hiện trong giao diện người dùng của bạn.

Tiếp theo, tôi sẽ quay lại hai yêu cầu tùy chọn của CustomAnimation: shouldMerge và velocity.

Chúng dùng để làm gì?

Hãy tưởng tượng trong giây lát rằng bạn là thuộc tính có thể hoạt hình scaleEffect.

Người dùng nhấn xuống, một giao dịch mở ra, giá trị của bạn thay đổi, bạn tạo một bản sao cục bộ của hoạt ảnh và bạn bắt đầu vui vẻ tạo hoạt ảnh vector delta của mình.

Mọi thứ đang diễn ra tốt đẹp.

Đó là, cho đến khi người dùng phiền phức nhấn lại trước khi hoạt ảnh kết thúc.

Bạn làm gì?

Bạn thiết lập một hình ảnh động mới, và bạn gọi shouldMerge trên đó.

Việc triển khai mặc định trả về sai - đây là những gì hoạt ảnh đường cong thời gian làm - trong trường hợp đó cả hai hoạt ảnh sẽ được chạy cùng nhau và kết quả của chúng sẽ được kết hợp bởi hệ thống.

Đây là một lý do khác tại sao hoạt hình SwiftUI liên quan đến các vectơ delta.

Nó giúp dễ dàng tính toán giá trị trình bày kết hợp chính xác khi nhiều hình ảnh động đang chạy.

Nhưng điều gì sẽ xảy ra nếu tôi chọn một hình ảnh động mùa xuân, không phải một hình ảnh động đường cong thời gian?

Ghi đè hoạt ảnh mùa xuân nên Hợp nhất để trả về đúng và kết hợp trạng thái của hoạt ảnh trước đó.

Điều này cho phép họ bảo toàn vận tốc và nhắm mục tiêu lại đến giá trị mới, điều này có thể cảm thấy tự nhiên hơn là kết hợp phụ gia, như hoạt ảnh đường cong thời gian.

Và đó là những gì yêu cầu vận tốc cuối cùng này dành cho.

Việc triển khai nó cho phép vận tốc được bảo toàn khi một hình ảnh động đang chạy được hợp nhất với một hình ảnh động mới.

Vì vậy, tôi sẽ hoàn thành hoạt ảnh đường cong thời gian tuyến tính của mình bằng cách thêm một triển khai cho vận tốc.

Tôi đã sử dụng thuật ngữ "giao dịch" trong suốt buổi nói chuyện này để chỉ tập hợp công việc được thực hiện cho một bản cập nhật nhất định cho giao diện người dùng.

Trong mã SwiftUI, Giao dịch cũng đề cập đến một cấu trúc luồng dữ liệu mạnh mẽ, có liên quan và họ API.

Bạn có thể đã quen thuộc với Môi trường và Sở thích, từ điển SwiftUI ngầm truyền xuống và lên hệ thống phân cấp chế độ xem, tương ứng.

Giao dịch cũng tương tự.

Đó là một từ điển mà SwiftUI sử dụng để ngầm truyền bá tất cả ngữ cảnh cho bản cập nhật hiện tại, đáng chú ý nhất là hoạt ảnh.

Lời giải thích của tôi trước đó về cách một thuộc tính hoạt hình đọc hoạt ảnh hiện tại hơi mơ hồ.

Vì vậy, tôi sẽ theo dõi qua một bản cập nhật hoạt hình khác của chế độ xem hình đại diện.

Lần này, tôi sẽ nói cụ thể hơn.

Khi đóng cử chỉ nhấn kích hoạt, withAnimation sẽ đặt một hình ảnh động trong từ điển giao dịch gốc.

Phần thân được gọi để cập nhật các giá trị thuộc tính.

Từ điển giao dịch được truyền qua biểu đồ thuộc tính.

Khi nó đạt đến một thuộc tính hoạt hình, thuộc tính sẽ kiểm tra xem một hình ảnh động có được đặt hay không.

Và nếu vậy, nó tạo ra một bản sao để thúc đẩy giá trị trình bày của nó.

Giao dịch chỉ liên quan đến một bản cập nhật cụ thể, vì vậy một khi các thuộc tính cũ đã được làm mới, nó sẽ bị loại bỏ.

Việc truyền hình ảnh động xuống hệ thống phân cấp chế độ xem trong từ điển giao dịch giúp một số API mạnh mẽ có thể kiểm soát thời điểm và cách thức hoạt ảnh áp dụng cho chế độ xem của bạn.

Ngay bây giờ, chế độ xem hình đại diện thú cưng chỉ có thể được chọn thông qua chạm.

Tôi sẽ thay đổi biến Trạng thái đã chọn thành Ràng buộc.

Bằng cách đó, nó cũng có thể được lựa chọn theo chương trình.

Nhưng làm cách nào để tạo hiệu ứng động cho một thay đổi có lập trình đối với thuộc tính chế độ xem?

Tôi có thể sử dụng công cụ sửa đổi giao dịch để truy cập hoạt ảnh khi nó chảy xuống hệ thống phân cấp chế độ xem bên trong từ điển giao dịch.

Nếu tôi đặt một hình ảnh động từ bên trong công cụ sửa đổi này, thì bất cứ khi nào nội dung được gọi, ngay cả khi không có hình ảnh động hoặc hình ảnh động khác trong giao dịch, thuộc tính sẽ ghi đè lên hình ảnh động.

Và khi nó đạt đến hiệu ứng tỷ lệ, hình ảnh động này sẽ được sử dụng để nội suy yếu tố tỷ lệ.

Khá tuyệt.

Nhưng có một vấn đề với mô hình này.

Ghi đè một cách bừa bãi hình ảnh động cho tất cả con cháu bất cứ khi nào SwiftUI làm mới chế độ xem có thể dẫn đến hoạt ảnh vô tình.

Thay vào đó, đối với các trường hợp sử dụng như thế này, SwiftUI cung cấp một công cụ sửa đổi chế độ xem hoạt hình.

Nó cần một đối số giá trị bổ sung, cho phép bạn xác định phạm vi hiệu ứng chính xác hơn nhiều.

Nó sẽ chỉ ghi hoạt ảnh vào giao dịch nếu giá trị đã thay đổi.

Bây giờ điều đó đã được kết nối, điều này với Hoạt hình không hoàn thành bất cứ điều gì, vì vậy chúng tôi có thể loại bỏ nó.

Công cụ sửa đổi chế độ xem hoạt hình cũng là một công cụ mạnh mẽ cho các tình huống mà bạn muốn áp dụng các hình ảnh động khác nhau cho các phần khác nhau của chế độ xem.

Ví dụ, hình đại diện thú cưng có một cái bóng, mà tôi đã bỏ qua cho đến nay so với ví dụ vì mục đích đơn giản.

Bán kính bóng tăng lên khi hình đại diện được chọn để làm nổi bật ảo ảnh rằng nó được nâng lên trên nền.

Sau khi chơi với nó, tôi đã quyết định tôi muốn hình ảnh động của bóng tối dịu hơn hiệu ứng tỷ lệ.

Để thực hiện điều này, tôi có thể chèn một công cụ sửa đổi chế độ xem hoạt hình khác giữa scaleEffect và shadow.

Bây giờ giao dịch chọn lò xo nảy để tạo hiệu ứng quy mô.

Và nó chọn lò xo mịn tinh tế hơn để làm sinh động bán kính bóng tối.

Bởi vì các công cụ sửa đổi hoạt ảnh chỉ hoạt động khi giá trị của chúng đã thay đổi, tỷ lệ hoạt ảnh ngẫu nhiên sẽ giảm đi rất nhiều.

Nhưng nếu hình ảnh của hình đại diện vừa tình cờ thay đổi trong cùng một giao dịch như đã chọn, nó sẽ kế thừa hoạt ảnh mùa xuân mượt mà của bóng tối để chuyển đổi nội dung của nó.

Đây là một điểm đáng để nán lại.

Công cụ sửa đổi chế độ xem hoạt hình này hoạt động tốt cho các thành phần lá nơi toàn bộ hệ thống phân cấp phụ nằm dưới sự kiểm soát của bạn.

Nhưng đối với các thành phần không phải lá, chứa nội dung con tùy ý, nhiều khả năng xảy ra hoạt ảnh ngẫu nhiên hơn.

Ví dụ: nếu tôi muốn sử dụng lại hình đại diện của mình trong một ứng dụng khác không liên quan gì đến thú cưng, tôi có thể làm cho nó chung chung hơn bằng cách chấp nhận nội dung trẻ em tùy ý.

Trong trường hợp này, tôi ít đảm bảo rằng khi được chọn thay đổi, nội dung con cũng sẽ không thay đổi.

Điều này có thể dẫn đến một hình ảnh động tình cờ.

Rất tiếc.

Tin tốt.

Chúng tôi có một phiên bản mới của công cụ sửa đổi chế độ xem hoạt hình được thiết kế đặc biệt cho các trường hợp sử dụng như thế này.

Nó hẹp phạm vi hoạt hình đến các thuộc tính hoạt hình được chỉ định trong phần đóng thân của nó.

Đây là cách nó hoạt động.

Hãy tưởng tượng không có hình ảnh động nào trong giao dịch.

Khi giao dịch đạt đến thuộc tính của công cụ sửa đổi chế độ xem hoạt ảnh, một bản sao được tạo ra được điền với hoạt ảnh được chỉ định.

Bản sao được truyền xuôi dòng, nhưng chỉ đến các thuộc tính có thể hoạt hình có phạm vi.

Sau khi hoàn thành công việc của mình, bản sao sẽ bị loại bỏ và giao dịch ban đầu sẽ tiếp tục ở nơi nó đã dừng lại.

Vì vậy, khi giao dịch đạt đến nội dung con, vì giao dịch ban đầu không bị ảnh hưởng bởi bất kỳ công cụ sửa đổi chế độ xem hoạt ảnh trung gian nào, không có nguy cơ hoạt ảnh ngẫu nhiên.

Một bộ API giao dịch giới hạn đã có sẵn kể từ phiên bản đầu tiên của SwiftUI.

Bây giờ chúng tôi đang giới thiệu khả năng xác định các khóa giao dịch tùy chỉnh, vì vậy bạn có thể tận dụng từ điển giao dịch để ngầm truyền bá dữ liệu cập nhật cụ thể của riêng bạn.

Nếu bạn đã từng khai báo khóa môi trường tùy chỉnh, việc khai báo khóa giao dịch tùy chỉnh sẽ quen thuộc.

Mẫu là tạo ra một loại duy nhất phù hợp với giao thức TransactionKey.

Yêu cầu duy nhất là cung cấp Giá trị mặc định.

Sau đó khai báo một thuộc tính được tính toán như một phần mở rộng trên Giao dịch đọc và ghi từ từ điển giao dịch bằng khóa của bạn.

Ở đây, tôi đã xác định một phím boolean để theo dõi xem, đối với bản cập nhật đã cho, hình đại diện có được nhấn hay không.

Tôi sẽ quyết định sử dụng hình ảnh động nào dựa trên giá trị của nó.

Nếu hình đại diện được chọn tương tác, tôi sẽ mở rộng nó lên hoặc xuống bằng cách sử dụng một mùa xuân sống động hơn.

Nhưng nếu hình đại diện được chọn theo chương trình, tôi sẽ chia tỷ lệ nó bằng cách sử dụng một lò xo dịu hơn.

Tôi có thể đặt một giá trị trong từ điển giao dịch cho bản cập nhật đã cho bằng cách gói với Giao dịch xung quanh sự thay đổi trạng thái của tôi.

Điều này có vẻ quen thuộc.

withAnimation chỉ là một trình bao bọc mỏng xung quanh với Giao dịch.

Các đối số được chuyển đến withTransaction là đường dẫn chính đến một thuộc tính được tính toán trên Giao dịch và giá trị cần đặt.

Giao dịch là duy nhất trong số các cấu trúc luồng dữ liệu ngầm của SwiftUI vì nó bị loại bỏ vào cuối mỗi bản cập nhật.

Điều này có nghĩa là, trừ khi được đặt rõ ràng cho bản cập nhật hiện tại, mọi giá trị trong từ điển giao dịch sẽ trở lại chỉ là giá trị mặc định cho khóa của nó.

Trong chế độ xem hình đại diện, khi đóng cử chỉ nhấn kích hoạt, avatarTapped được đặt thành true cho bản cập nhật hiện tại.

Giao dịch cũng chứa giá trị mặc định cho khóa hoạt hình, đó là số không.

Giao dịch lan truyền qua hệ thống phân cấp chế độ xem cho đến khi nó đạt đến công cụ sửa đổi giao dịch.

Ở đây, chế độ xem hình đại diện đọc avatarTapped và dựa trên giá trị của nó, đặt hoạt ảnh thích hợp...

Mà truyền bá xuống hệ thống phân cấp chế độ xem.

Điều này hoạt động khá tốt, nhưng giống như trước đó, nó có thể dẫn đến hoạt ảnh tình cờ.

Để cung cấp cho bạn quyền kiểm soát chi tiết hơn đối với việc sửa đổi giao dịch, chúng tôi đang giới thiệu hai biến thể mới của công cụ sửa đổi giao dịch.

Một cho phép bạn phạm vi sử dụng đối số giá trị.

Và cái còn lại cho phép bạn phạm vi đến một hệ thống phân cấp phụ được xác định trong phần đóng nội dung.

Các biến thể này phản ánh các công cụ sửa đổi chế độ xem hoạt hình có phạm vi được đề cập trước đó.

Trong phiên này, tôi đã giải thích các nguyên thủy hoạt hình mạnh mẽ của SwiftUI, Animatable, Animation và Transaction.

Bước tiếp theo, tôi khuyên bạn nên kiểm tra hai phiên liên quan.

"Animate with springs" cung cấp thêm hướng dẫn về lý do và cách sử dụng hiệu quả hoạt ảnh lò xo trong ứng dụng của bạn.

Và "Gió theo cách của bạn thông qua các hình ảnh động nâng cao trong SwiftUI" giới thiệu các công cụ mới mạnh mẽ để xây dựng các hình ảnh động nhiều bước.

Tôi hy vọng nội dung này giúp bạn hiểu rõ hơn về cách hoạt hình SwiftUI hoạt động và trao quyền cho bạn tận dụng hoạt hình một cách khéo léo hơn trong ứng dụng của mình.

Cảm ơn.

♪ ♪