10089

♪ Hip-hop nhạc cụ êm dịu ♪

♪

Này, tôi là Pau Sastre Miguel, một kỹ sư phần mềm tại Apple.

Hôm nay tôi sẽ nói về cách tạo ra những trải nghiệm nhập vai với Metal trên xrOS.

Năm nay, với sự ra mắt của xrOS, bạn sẽ có thể tạo ra những trải nghiệm nhập vai với các công nghệ quen thuộc trong hệ sinh thái Apple.

Với RealityKit, bạn sẽ có thể tạo ra những trải nghiệm kết hợp nội dung ảo của mình với thế giới thực.

Mặt khác, nếu ứng dụng của bạn sẽ đưa người dùng vào trải nghiệm nhập vai hoàn toàn, xrOS cũng cho phép bạn thay thế hoàn toàn nội dung trong thế giới thực bằng nội dung ảo của riêng bạn.

Khi tạo ra những trải nghiệm hoàn toàn nhập vai, bạn có một vài lựa chọn khi nói đến phương pháp kết xuất của mình.

Bạn vẫn có thể sử dụng RealityKit, hoặc nếu bạn thích, bạn có thể chọn Metal và ARKit APIs.

RecRoom là một ví dụ tuyệt vời về một ứng dụng cung cấp trải nghiệm nhập vai hoàn toàn bằng cách sử dụng CompositorServices để tạo phiên kết xuất, API kim loại để hiển thị khung và ARKit để theo dõi thế giới và tay.

Họ đã có thể mang lại sự hỗ trợ cho tất cả các công nghệ này nhờ trình chỉnh sửa Unity.

Nếu bạn muốn viết công cụ của riêng mình, CompositorServices API cung cấp cho bạn quyền truy cập vào kết xuất Metal trên xrOS.

Bạn có thể kết hợp nó với ARKit, bổ sung tính năng theo dõi thế giới và theo dõi tay, để tạo ra trải nghiệm hoàn toàn nhập vai.

CompositorServices là chìa khóa để cấu hình công cụ của bạn hoạt động trên xrOS.

Tôi sẽ chỉ cho bạn cách thiết lập vòng lặp kết xuất và sau đó là cách kết xuất một khung.

Cuối cùng, tôi sẽ chỉ cho bạn cách sử dụng ARKit để làm cho trải nghiệm của bạn tương tác.

Bắt đầu với kiến trúc của một ứng dụng xrOS.

Bạn sẽ tận dụng tối đa phiên hôm nay nếu bạn có kinh nghiệm trước đây với Metal APIs và kỹ thuật kết xuất Metal.

Nếu bạn chưa từng sử dụng Metal trước đây, hãy xem các mẫu mã và tài liệu trong developer.apple.com/Metal.

Khi bạn tạo ra những trải nghiệm nhập vai trên xrOS với Metal, bạn sẽ bắt đầu với SwiftUI để tạo ứng dụng và phiên kết xuất.

Sau khi tạo phiên kết xuất, bạn có thể chuyển sang ngôn ngữ mà bạn có thể quen thuộc hơn, như C hoặc C++, để xác định các phần bên trong của công cụ.

Bạn bắt đầu bằng cách tạo một loại phù hợp với giao thức ứng dụng SwiftUI.

Để phù hợp với giao thức này, bạn sẽ xác định danh sách các cảnh trong ứng dụng của mình.

Trên xrOS, có ba loại cảnh chính.

Loại cửa sổ cung cấp trải nghiệm tương tự như nền tảng 2D như macOS.

Loại âm lượng hiển thị nội dung trong giới hạn của nó và nó cùng tồn tại trong Không gian chia sẻ với các ứng dụng khác.

Và ImmersiveSpace cho phép bạn hiển thị nội dung ở bất cứ đâu.

Bất cứ khi nào bạn hiển thị trải nghiệm nhập vai hoàn toàn với Metal, bạn sẽ chọn loại ImmersiveSpace.

ImmersiveSpace là một loại Cảnh SwiftUI mới có sẵn trên xrOS.

Nó đóng vai trò là vật chứa cho những trải nghiệm nhập vai hoàn toàn.

Để tìm hiểu cách sử dụng ImmersiveSpace, hãy xem phiên "Vượt ra ngoài cửa sổ với SwiftUI."

Khi bạn tạo một cảnh ImmersiveSpace, ứng dụng của bạn cung cấp nội dung bằng cách sử dụng một loại phù hợp với giao thức ImmersiveSpaceContent.

Thông thường, khi tạo nội dung cho Cảnh ImmersiveSpace, các ứng dụng sẽ sử dụng RealityKit.

Nó sử dụng CoreAnimation và MaterialX dưới mui xe.

Nhưng nếu thay vào đó, bạn muốn sử dụng sức mạnh của Metal để hiển thị nội dung ứng dụng của mình, bạn có một lựa chọn khác.

CompositorServices API sử dụng Metal và ARKit để cung cấp khả năng kết xuất nhập vai cho ứng dụng của bạn.

CompositorServices API mới, được giới thiệu trong xrOS, cung cấp giao diện kết xuất Metal để có thể hiển thị nội dung của ImmersiveSpace.

Với CompositorServices, các ứng dụng có thể kết xuất trực tiếp vào máy chủ tổng hợp.

Nó có chi phí IPC thấp để giảm thiểu độ trễ và nó được xây dựng từ đầu để hỗ trợ cả API C và Swift.

Khi sử dụng CompositorServices, ImmersiveSpaceContent được gọi là CompositorLayer.

Để tạo một CompositorLayer bạn sẽ cần cung cấp hai tham số.

Cái đầu tiên là giao thức CompositorLayerConfiguration.

Giao thức này xác định hành vi và khả năng của phiên kết xuất của bạn.

Thứ hai là LayerRenderer.

Đây là giao diện cho phiên kết xuất lớp.

Ứng dụng của bạn sẽ sử dụng đối tượng này để lên lịch và hiển thị các khung mới.

Khi viết một trải nghiệm nhập vai với Metal, hãy bắt đầu bằng cách xác định loại ứng dụng.

Là loại cảnh, hãy sử dụng ImmersiveSpace.

Đối với loại nội dung, hãy sử dụng CompositorLayer.

Khi CompositorLayer đã sẵn sàng để hiển thị nội dung, hệ thống sẽ gọi ứng dụng với phiên bản của phiên kết xuất.

Đây là một nơi tốt để tạo phiên bản công cụ tùy chỉnh của bạn.

Bây giờ bạn đã có phiên bản công cụ, bạn có thể tạo chuỗi kết xuất và chạy vòng lặp kết xuất bằng cách gọi bắt đầu.

Một điều cần lưu ý khi xác định danh sách cảnh trong ứng dụng của bạn, là theo mặc định SwiftUI tạo cảnh cửa sổ, ngay cả khi cảnh đầu tiên trong ứng dụng của bạn là ImmersiveSpace.

Để thay đổi hành vi mặc định đó, bạn có thể sửa đổi danh sách thông tin của ứng dụng của mình.

Bạn có thể thêm khóa UIApplicationPreferred DefaultSceneSessionRole vào bản kê khai cảnh ứng dụng của mình để thay đổi loại cảnh mặc định của ứng dụng.

Nếu bạn đang sử dụng một không gian với Compositor SpaceContent, bạn sẽ sử dụng CPSceneSessionRole ImmersiveSpaceApplication.

Sau khi thiết lập ứng dụng và trước khi vào vòng lặp kết xuất, bạn sẽ cho CompositorServices biết cách định cấu hình LayerRenderer.

Để cung cấp cấu hình cho CompositorLayer, bạn sẽ tạo một loại mới phù hợp với giao thức CompositorLayerConfiguration.

Giao thức này cho phép bạn sửa đổi thiết lập và một số hành vi của phiên kết xuất.

CompositorLayerConfiguration cung cấp cho bạn hai tham số.

Cái đầu tiên là khả năng của lớp.

Nó cho phép bạn truy vấn những tính năng nào có sẵn trên thiết bị.

Sử dụng các khả năng để tạo ra một cấu hình hợp lệ.

Và tham số thứ hai là Cấu hình LayerRenderer.

Loại này xác định cấu hình của phiên kết xuất của bạn.

Với cấu hình, bạn có thể xác định cách công cụ của bạn ánh xạ nội dung của nó vào lớp, cho phép kết xuất theo hướng và xác định quản lý màu sắc của đường ống của bạn.

Bây giờ, tôi sẽ nói về việc mỗi thuộc tính này sẽ ảnh hưởng đến động cơ của bạn như thế nào.

Cái đầu tiên là kết xuất theo hướng.

Mục tiêu chính của tính năng này là cho phép bạn hiển thị nội dung ở mật độ điểm ảnh trên mỗi độ cao hơn mà không cần sử dụng kích thước kết cấu lớn hơn.

Trong một đường ống hiển thị thông thường, các điểm ảnh được phân bố tuyến tính theo kết cấu.

xrOS tối ưu hóa quy trình làm việc này bằng cách tạo bản đồ xác định những khu vực nào trong màn hình có thể sử dụng tốc độ lấy mẫu thấp hơn.

Điều này giúp giảm công suất cần thiết để hiển thị khung hình của bạn trong khi vẫn duy trì độ trung thực trực quan của màn hình.

Sử dụng foveation bất cứ khi nào có thể là điều quan trọng, vì nó sẽ mang lại trải nghiệm hình ảnh tốt hơn.

Một cách tuyệt vời để hình dung cách foveation ảnh hưởng đến đường ống kết xuất của bạn là sử dụng Trình gỡ lỗi kim loại của Xcode.

Với Metal Debugger, bạn có thể kiểm tra kết cấu mục tiêu và bản đồ tốc độ rasterization đang được sử dụng trong đường ống kết xuất.

Ảnh chụp này hiển thị nội dung của kết cấu mà không cần chia tỷ lệ cho bản đồ tốc độ rasterization.

Bạn có thể nhận thấy các tỷ lệ mẫu khác nhau bằng cách tập trung vào các vùng của kết cấu được nén nhiều hơn.

Với các tùy chọn trình xem tệp đính kèm trong Trình gỡ lỗi kim loại, bạn có thể chia tỷ lệ hình ảnh để hình dung kết quả cuối cùng mà màn hình sẽ hiển thị.

Compositor cung cấp bản đồ foveation bằng cách sử dụng MTLRasterizationRateMap cho mỗi khung hình.

Luôn luôn kiểm tra xem foveation có được hỗ trợ hay không là một cách tốt.

Điều này sẽ thay đổi tùy thuộc vào nền tảng.

Ví dụ, trong trình mô phỏng xrOS, foveation không khả dụng.

Để kích hoạt foveation, bạn có thể đặt isFoveationEnabled trên cấu hình.

Thuộc tính thứ hai là bố cục LayerRenderer.

Thuộc tính này là một trong những cấu hình quan trọng nhất cho động cơ của bạn.

Nó xác định cách mỗi màn hình từ tai nghe được ánh xạ vào nội dung được hiển thị của ứng dụng của bạn.

Mỗi mắt đầu tiên ánh xạ vào một kết cấu Kim loại do Compositor cung cấp.

Sau đó, Compositor cung cấp chỉ mục của lát cắt nào để sử dụng trong kết cấu đó.

Và cuối cùng, Compositor cung cấp khung nhìn để sử dụng trong lát kết cấu đó.

Bố cục LayerRenderer cho phép bạn chọn các ánh xạ khác nhau giữa lát kết cấu và khung nhìn.

Với nhiều lớp, Compositor sẽ sử dụng một kết cấu với hai lát cắt và hai khung nhìn.

Với chuyên dụng, Compositor sẽ sử dụng hai kết cấu với một lát cắt và mỗi khung nhìn.

Và cuối cùng với việc chia sẻ, Compositor sẽ sử dụng một kết cấu, một lát cắt và hai khung nhìn khác nhau cho lát cắt đó.

Việc chọn bố cục để sử dụng sẽ phụ thuộc vào cách bạn thiết lập đường ống kết xuất của mình.

Ví dụ, với phân lớp và chia sẻ, bạn sẽ có thể thực hiện kết xuất của mình trong một lần duy nhất, vì vậy bạn có thể tối ưu hóa quy trình kết xuất của mình.

Với bố cục được chia sẻ, có thể dễ dàng chuyển các cơ sở mã hiện có trong đó kết xuất theo hướng không phải là một tùy chọn.

Bố cục phân lớp là bố cục tối ưu vì nó cho phép bạn kết xuất cảnh của mình trong một lần duy nhất trong khi vẫn duy trì kết xuất theo hướng.

Thuộc tính cấu hình cuối cùng cần thảo luận là quản lý màu sắc.

Compositor hy vọng nội dung sẽ được hiển thị với không gian màu P3 hiển thị tuyến tính mở rộng.

xrOS hỗ trợ khoảng không EDR là 2.0.

Đó là gấp hai lần phạm vi SDR.

Theo mặc định, Compositor không sử dụng định dạng pixel có thể hiển thị HDR, nhưng nếu ứng dụng của bạn hỗ trợ HDR, bạn có thể chỉ định rgba16Float trong cấu hình lớp.

Nếu bạn muốn biết thêm về cách kết xuất HDR với EDR, hãy xem phiên "Khám phá kết xuất HDR với EDR."

Để tạo một cấu hình tùy chỉnh trong ứng dụng của bạn, hãy bắt đầu bằng cách xác định một loại mới phù hợp với giao thức CompositorLayerConfiguration.

Để phù hợp với giao thức này, hãy thêm phương thức makeConfiguration.

Phương pháp này cung cấp khả năng lớp và cấu hình bạn có thể sửa đổi.

Để kích hoạt ba thuộc tính mà tôi đã đề cập trước đây, trước tiên hãy kiểm tra xem foveation có được hỗ trợ hay không.

Sau đó kiểm tra xem bố cục nào được hỗ trợ trong thiết bị này.

Với thông tin này, bạn có thể thiết lập một bố cục hợp lệ trong cấu hình.

Trong một số thiết bị như trình giả lập, nơi Compositor chỉ hiển thị một chế độ xem, phân lớp sẽ không khả dụng.

Đối với foveation, hãy đặt nó thành true nếu thiết bị hỗ trợ nó.

Và cuối cùng, đặt colorFormat thành rgba16Float để có thể hiển thị nội dung HDR.

Quay trở lại mã đã tạo ra lớp Compositor, bây giờ bạn có thể thêm loại cấu hình bạn vừa tạo.

Bây giờ phiên kết xuất đã được định cấu hình, bạn có thể thiết lập vòng lặp kết xuất.

Bạn sẽ bắt đầu bằng cách sử dụng đối tượng LayerRenderer từ CompositorLayer.

Đầu tiên, bạn sẽ tải tài nguyên và khởi tạo bất kỳ đối tượng nào mà công cụ của bạn sẽ cần để hiển thị khung.

Sau đó kiểm tra trạng thái của lớp.

Nếu lớp bị tạm dừng, hãy đợi cho đến khi lớp đang chạy.

Khi lớp được bỏ chặn khỏi thời gian chờ đợi, hãy kiểm tra lại trạng thái lớp.

Nếu lớp đang chạy, bạn sẽ có thể hiển thị một khung.

Và một khi khung đó được hiển thị, hãy kiểm tra lại trạng thái lớp trước khi hiển thị khung tiếp theo.

Nếu trạng thái lớp bị vô hiệu, hãy giải phóng tài nguyên bạn đã tạo cho vòng lặp kết xuất.

Bây giờ, đã đến lúc xác định hàm chính của render_loop.

Cho đến bây giờ tôi đã sử dụng Swift vì ImmersiveSpace API chỉ có sẵn trong Swift.

Nhưng từ đây tôi sẽ chuyển sang C để viết vòng lặp kết xuất.

Như tôi đã đề cập, bước đầu tiên trong vòng lặp kết xuất là phân bổ và khởi tạo tất cả các đối tượng bạn sẽ cần để kết xuất khung.

Bạn sẽ làm điều này bằng cách gọi chức năng thiết lập trong công cụ tùy chỉnh của bạn.

Tiếp theo, là phần chính của vòng lặp.

Bước đầu tiên là kiểm tra trạng thái layerRenderer.

Nếu trạng thái bị tạm dừng, luồng sẽ ngủ cho đến khi layerRenderer chạy.

Nếu trạng thái lớp đang chạy, công cụ sẽ hiển thị một khung.

Và cuối cùng, nếu lớp bị vô hiệu hóa, vòng lặp kết xuất sẽ kết thúc.

Bước cuối cùng của hàm render_loop sẽ là xóa mọi tài nguyên đã sử dụng.

Bây giờ ứng dụng đang trải qua vòng lặp kết xuất, tôi sẽ giải thích cách kết xuất một khung.

Kết xuất nội dung trong xrOS luôn từ quan điểm của thiết bị.

Bạn có thể sử dụng ARKit để có được định hướng và dịch thiết bị.

ARKit đã có sẵn trên iOS và bây giờ xrOS đang giới thiệu một API hoàn toàn mới, có các tính năng bổ sung có thể giúp bạn tạo ra trải nghiệm nhập vai.

Với ARKit, bạn có thể thêm tính năng theo dõi thế giới, theo dõi tay và các khả năng cảm biến thế giới khác vào ứng dụng của mình.

ARKit API mới cũng được xây dựng từ đầu để hỗ trợ các API C và Swift, điều này sẽ cho phép tích hợp dễ dàng hơn với các công cụ kết xuất hiện có.

Để tìm hiểu thêm về ARKit trên xrOS, hãy xem "Gặp gỡ ARKit để tính toán không gian."

Trong vòng lặp kết xuất, đã đến lúc kết xuất một khung.

Khi kết xuất một khung, Compositor xác định hai phần chính.

Cái đầu tiên là bản cập nhật.

Đây là nơi bạn sẽ làm bất kỳ công việc nào không quan trọng về độ trễ đầu vào.

Đây có thể là những thứ như cập nhật hình ảnh động trong cảnh của bạn, cập nhật nhân vật của bạn hoặc thu thập đầu vào trong hệ thống của bạn như tư thế bộ xương tay.

Phần thứ hai của khung là phần gửi.

Đây là nơi bạn sẽ thực hiện bất kỳ công việc quan trọng nào về độ trễ.

Bạn cũng sẽ hiển thị bất kỳ nội dung nào phụ thuộc vào vị trí tai nghe ở đây.

Để xác định thời gian cho mỗi phần đó, Compositor cung cấp một đối tượng thời gian.

Sơ đồ này xác định thời gian ảnh hưởng như thế nào đến các phần khung khác nhau.

Các bản nhạc CPU và GPU đại diện cho công việc đang được thực hiện bởi ứng dụng của bạn.

Và bản nhạc Compositor đại diện cho công việc được thực hiện bởi máy chủ Compositor để hiển thị khung của bạn.

Loại thời gian từ Dịch vụ Compositor xác định ba giá trị thời gian chính.

Đầu tiên là thời gian đầu vào tối ưu.

Đó là thời điểm tốt nhất để truy vấn đầu vào quan trọng về độ trễ và bắt đầu hiển thị khung của bạn.

Thứ hai là thời hạn kết xuất.

Đó là thời điểm mà CPU và GPU của bạn hoạt động để hiển thị khung hình nên được hoàn thành.

Và thứ ba là thời gian thuyết trình.

Đó là lúc khung hình của bạn sẽ được trưng bày.

Trong hai phần của khung hình của bạn, phần cập nhật sẽ diễn ra trước thời gian nhập tối ưu.

Sau khi cập nhật, bạn sẽ đợi thời gian nhập tối ưu trước khi bắt đầu gửi khung.

Sau đó, bạn sẽ thực hiện gửi khung, điều này sẽ gửi công việc kết xuất đến GPU.

Điều quan trọng cần lưu ý là công việc CPU và GPU cần phải hoàn thành trước thời hạn kết xuất, nếu không máy chủ Compositor sẽ không thể sử dụng khung này và sẽ sử dụng khung trước đó thay thế.

Cuối cùng, vào thời hạn kết xuất, máy chủ Compositor sẽ kết hợp khung này với các lớp khác trong hệ thống.

Quay lại mã vòng lặp kết xuất, đã đến lúc xác định hàm render_new_frame.

Trong chức năng render_new_frame của công cụ của bạn, trước tiên bạn sẽ truy vấn một khung từ layerRenderer.

Với đối tượng khung, bạn sẽ có thể dự đoán thông tin thời gian.

Sử dụng thông tin thời gian đó để mở rộng phạm vi cập nhật và gửi các khoảng thời gian.

Tiếp theo, thực hiện phần cập nhật.

Xác định phần này bằng cách gọi cập nhật bắt đầu và kết thúc trên khung.

Bên trong, bạn sẽ thu thập các đầu vào của thiết bị và cập nhật nội dung của khung.

Sau khi cập nhật xong, hãy đợi thời gian nhập tối ưu trước khi bắt đầu gửi.

Sau khi chờ đợi, xác định phần gửi bằng cách gọi bắt đầu và kết thúc gửi.

Bên trong phần này, trước tiên hãy truy vấn đối tượng có thể vẽ được.

Tương tự như CAMetalLayer, đối tượng có thể vẽ được chứa kết cấu đích và thông tin mà bạn sẽ cần để thiết lập đường ống kết xuất.

Bây giờ bạn đã có thể vẽ được, bạn có thể nhận được thông tin thời gian cuối cùng mà Compositor sẽ sử dụng để hiển thị khung này.

Với thời gian cuối cùng, bạn có thể truy vấn ar_pose.

Điều quan trọng là phải đặt tư thế trong bản vẽ được vì nó sẽ được Compositor sử dụng để thực hiện chiếu lại trên khung.

Ở đây tôi đang tạo dáng bằng cách gọi hàm get_ar_pose trong đối tượng động cơ của tôi.

Nhưng bạn sẽ cần triển khai nội dung của chức năng này bằng cách sử dụng API theo dõi thế giới ARKit.

Bước cuối cùng của chức năng sẽ là mã hóa tất cả các công việc GPU và gửi khung.

Bên trong khung đệ trình, sử dụng khả năng vẽ để hiển thị nội dung của khung như bình thường.

Bây giờ vòng lặp kết xuất là các khung kết xuất, đã đến lúc làm cho trải nghiệm nhập vai của bạn tương tác.

Video này cho thấy cách RecRoom sử dụng Unity đã tận dụng ARKit và Compositor APIs để thêm tính tương tác vào ứng dụng của họ.

Có hai nguồn đầu vào chính thúc đẩy sự tương tác này.

HandTracking của ARKit đang cung cấp bộ xương bàn tay để hiển thị các bàn tay ảo.

Và các sự kiện chèn ép từ LayerRenderer đang thúc đẩy các tương tác của người dùng.

Để làm cho trải nghiệm tương tác, trước tiên bạn sẽ thu thập đầu vào của người dùng và sau đó áp dụng nó vào nội dung cảnh của bạn.

Tất cả công việc này sẽ xảy ra trong phần cập nhật của khung.

Có hai nguồn đầu vào chính, LayerRenderer và nhà cung cấp ARKit HandTracking.

Với LayerRenderer, bạn sẽ nhận được các bản cập nhật mỗi khi ứng dụng nhận được sự kiện pinch.

Những cập nhật này được hiển thị dưới dạng các sự kiện không gian.

Những sự kiện này chứa ba thuộc tính chính.

Giai đoạn sẽ cho bạn biết nếu sự kiện đang hoạt động, nếu nó kết thúc, hoặc nếu nó bị hủy bỏ.

Tia lựa chọn sẽ cho phép bạn xác định nội dung của cảnh được chú ý khi sự kiện bắt đầu.

Và thuộc tính sự kiện cuối cùng là tư thế thao túng.

Đây là tư thế của nhúm và được cập nhật mọi khung hình trong suốt thời gian diễn ra sự kiện.

Từ HandTracking API, bạn sẽ có thể lấy bộ xương cho cả tay trái và tay phải.

Bây giờ, đã đến lúc thêm hỗ trợ đầu vào vào mã.

Trước khi thu thập đầu vào, bạn sẽ quyết định xem ứng dụng của bạn đang hiển thị các kim ảo hay nó sử dụng các kim truyền qua.

Thêm công cụ sửa đổi cảnh LimbVisibility phía trên vào ImmersiveSpace để làm cho các bàn tay truyền qua hiển thị hoặc ẩn.

Để truy cập các sự kiện không gian, hãy quay lại nơi bạn đã xác định trình xử lý kết xuất CompositorLayer.

Tại đây, đăng ký một khối trong layerRenderer để nhận thông tin cập nhật mỗi khi có sự kiện không gian mới.

Nếu bạn đang viết mã động cơ của mình bằng C, bạn sẽ ánh xạ sự kiện không gian SwiftUI sang loại C.

Bên trong mã C, bây giờ bạn có thể nhận được bộ sưu tập sự kiện C.

Một điều cần lưu ý khi xử lý các bản cập nhật sự kiện không gian là các bản cập nhật được phân phối trong chuỗi chính.

Điều này có nghĩa là bạn sẽ sử dụng một số cơ chế đồng bộ hóa khi đọc và ghi các sự kiện trong công cụ của mình.

Bây giờ các sự kiện được lưu trữ trong công cụ, đã đến lúc triển khai chức năng thu thập đầu vào.

Bước đầu tiên là tạo một đối tượng để lưu trữ trạng thái đầu vào hiện tại cho khung này.

Trạng thái đầu vào này sẽ lưu trữ các sự kiện mà bạn nhận được từ LayerRenderer.

Đảm bảo rằng bạn đang truy cập bộ nhớ trong của mình một cách an toàn.

Đối với bộ xương bàn tay, bạn có thể sử dụng API của nhà cung cấp dịch vụ theo dõi tay từ ARKit để có được các neo tay mới nhất.

Và bây giờ ứng dụng của bạn có hỗ trợ đầu vào, bạn có tất cả các công cụ theo ý của mình để tạo ra những trải nghiệm nhập vai hoàn toàn trên xrOS.

Tóm lại, với SwiftUI, bạn sẽ xác định ứng dụng.

Với CompositorServices và Metal, bạn sẽ thiết lập vòng lặp kết xuất và hiển thị nội dung 3D.

Và cuối cùng, với ARKit, bạn sẽ có thể làm cho trải nghiệm của mình tương tác.

Cảm ơn bạn đã xem!

♪