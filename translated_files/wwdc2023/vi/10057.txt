10057

♪ ♪

Tyler: Chào mừng đến với "Giải phóng Hệ thống Đặc điểm UIKit."

Tôi là Tyler Fox, một kỹ sư khung giao diện người dùng và tôi rất vui được nói với bạn về một số tính năng UIKit mới đáng kinh ngạc mà bạn có thể tận dụng trong iOS 17.

Để bắt đầu, tôi sẽ xem xét các nguyên tắc cơ bản về hệ thống đặc điểm trong UIKit.

Sau đó, tôi sẽ hướng dẫn bạn các tính năng và khả năng mới, bao gồm khả năng xác định các đặc điểm tùy chỉnh để thêm dữ liệu của riêng bạn vào UITraitCollection, các cách dễ dàng hơn để áp dụng ghi đè đặc điểm trong hệ thống phân cấp ứng dụng của bạn và các cách linh hoạt hơn để xử lý khi các đặc điểm thay đổi.

Cuối cùng, tôi sẽ giải thích cách bạn có thể kết nối các đặc điểm UIKit với các khóa môi trường SwiftUI để chuyển dữ liệu liền mạch giữa các thành phần UIKit và SwiftUI trong ứng dụng của bạn.

Đã đến lúc xem lại một số nguyên tắc cơ bản.

Đặc điểm là những mẩu dữ liệu độc lập mà hệ thống tự động truyền đến mọi bộ điều khiển chế độ xem và chế độ xem trong ứng dụng của bạn.

UIKit cung cấp nhiều đặc điểm hệ thống tích hợp, chẳng hạn như kiểu giao diện người dùng, lớp kích thước ngang và danh mục kích thước nội dung ưa thích.

Trong iOS 17, bạn cũng có thể xác định các đặc điểm tùy chỉnh của riêng mình.

Điều này mở ra một cách mới mạnh mẽ để bạn cung cấp dữ liệu cho bộ điều khiển chế độ xem và chế độ xem của ứng dụng.

Tôi sẽ cho bạn biết tất cả về các đặc điểm tùy chỉnh một lát sau.

Cách chính mà bạn làm việc với các đặc điểm trong UIKit là sử dụng các bộ sưu tập đặc điểm.

Một bộ sưu tập đặc điểm chứa các đặc điểm và giá trị liên quan của chúng.

Có một số API mới trong iOS 17 giúp làm việc với các bộ sưu tập đặc điểm dễ dàng hơn.

Đầu tiên, có một trình khởi tạo mới cần đóng cửa.

Bên trong đóng cửa đó, bạn nhận được một vùng chứa các đặc điểm có thể thay đổi mà bạn có thể đặt các giá trị thành.

Vùng chứa có thể thay đổi này phù hợp với một giao thức mới có tên UIMutableTraits.

Bên trong phần đóng, tôi đặt thành ngữ giao diện người dùng thành điện thoại và lớp kích thước ngang thành thông thường.

Khi việc đóng kết thúc việc thực thi, trình khởi tạo sẽ trả về một phiên bản UITraitCollection bất biến chứa tất cả các giá trị đặc điểm mà tôi đã đặt bên trong việc đóng.

Ngoài ra còn có một phương thức modifyingTraits mới cho phép bạn tạo một phiên bản mới bằng cách sửa đổi các giá trị từ bộ sưu tập đặc điểm ban đầu bên trong đóng cửa.

Ở đây tôi đã thay đổi lớp kích thước ngang thành nhỏ gọn và tôi đã điền một giá trị tối cho kiểu giao diện người dùng.

Vì tôi chưa thay đổi thành ngữ giao diện người dùng, nó vẫn bằng điện thoại từ bộ sưu tập đặc điểm ban đầu của tôi.

Mặc dù bạn có thể tạo các bộ sưu tập đặc điểm của riêng mình như thế này, nhưng hầu hết thời gian bạn có được các bộ sưu tập đặc điểm từ môi trường đặc điểm.

Môi trường đặc điểm trong ứng dụng của bạn là cảnh cửa sổ, cửa sổ, bộ điều khiển bản trình bày, bộ điều khiển chế độ xem và chế độ xem.

Mỗi môi trường đặc điểm này đều có bộ sưu tập đặc điểm riêng và mỗi bộ sưu tập đặc điểm có thể chứa các giá trị khác nhau.

Môi trường đặc điểm được kết nối trong hệ thống phân cấp đặc điểm, đó là cách các đặc điểm chảy qua ứng dụng của bạn.

Đây là một ví dụ về cấu trúc cây của hệ thống phân cấp đặc điểm, từ mỗi cảnh cửa sổ cho đến các bộ điều khiển và chế độ xem riêng lẻ.

Mỗi môi trường đặc điểm kế thừa các giá trị đặc điểm từ môi trường mẹ của nó.

Luôn sử dụng bộ sưu tập đặc điểm của môi trường đặc điểm cụ thể nhất có thể.

Tôi sẽ đi sâu hơn vào cách các đặc điểm chảy qua bộ điều khiển chế độ xem và chế độ xem.

Đây là một ví dụ về bộ điều khiển chế độ xem mẹ, chứa bộ điều khiển chế độ xem con.

Đường đứt nét đại diện cho hệ thống phân cấp bộ điều khiển chế độ xem.

Bộ điều khiển mẹ sở hữu một chế độ xem và đường liền nét kết nối chúng đại diện cho mối quan hệ của chúng.

Chế độ xem mẹ có một chế độ xem con và đường đứt nét xuyên qua chế độ xem đại diện cho hệ thống phân cấp chế độ xem.

Cuối cùng, chế độ xem của bộ điều khiển con là chế độ xem phụ của chế độ xem giữa đó.

Đầu tiên tôi sẽ giải thích cách các đặc điểm chảy qua bộ điều khiển chế độ xem và chế độ xem trước iOS 17.

Bộ điều khiển chế độ xem các đặc điểm được thừa hưởng trực tiếp từ bộ điều khiển chế độ xem mẹ của chúng.

Và các chế độ xem thuộc sở hữu của bộ điều khiển chế độ xem thừa hưởng các đặc điểm của họ trực tiếp từ bộ điều khiển chế độ xem của họ.

Cuối cùng, các chế độ xem không có bộ điều khiển chế độ xem thừa hưởng các đặc điểm trực tiếp từ chế độ xem của chúng.

Hành vi này có nghĩa là dòng chảy của các đặc điểm trong hệ thống phân cấp chế độ xem dừng lại ở mỗi chế độ xem thuộc sở hữu của bộ điều khiển chế độ xem.

Ví dụ, một giá trị đặc điểm từ chế độ xem của bộ điều khiển mẹ sẽ chỉ được kế thừa bởi chế độ xem phụ trực tiếp của nó.

Chế độ xem của bộ điều khiển con sẽ không nhận được giá trị đó, mặc dù nó là chế độ xem con trong hệ thống phân cấp chế độ xem bên dưới các chế độ xem đó.

Hành vi này có thể gây ngạc nhiên.

Trong iOS 17, chúng tôi đã loại bỏ vấn đề này bằng cách thống nhất hệ thống phân cấp đặc điểm cho bộ điều khiển chế độ xem và chế độ xem.

Bộ điều khiển chế độ xem hiện kế thừa bộ sưu tập đặc điểm của họ từ chế độ xem của chế độ xem, thay vì trực tiếp từ bộ điều khiển chế độ xem mẹ của chúng.

Điều này tạo ra một dòng chảy tuyến tính đơn giản của các đặc điểm thông qua bộ điều khiển chế độ xem và chế độ xem.

Lưu ý cách bộ điều khiển chế độ xem vẫn kế thừa các đặc điểm từ bộ điều khiển chế độ xem mẹ của chúng, nó chỉ xảy ra gián tiếp thông qua các chế độ xem ở giữa chúng.

Bởi vì các bộ điều khiển chế độ xem hiện kế thừa các đặc điểm của họ từ hệ thống phân cấp chế độ xem, chế độ xem của bộ điều khiển chế độ xem phải nằm trong hệ thống phân cấp để bộ điều khiển chế độ xem nhận được các đặc điểm cập nhật.

Kết quả là, nếu bạn truy cập bộ sưu tập đặc điểm của bộ điều khiển chế độ xem trước khi chế độ xem của nó được thêm vào hệ thống phân cấp, bộ điều khiển chế độ xem sẽ không có các giá trị cập nhật cho các đặc điểm của nó.

Nơi phổ biến nhất mà bạn có thể tìm thấy mã bị ảnh hưởng là bên trong viewWillAppear, vì nó luôn được gọi trước khi chế độ xem được thêm vào hệ thống phân cấp.

Có một cuộc gọi lại mới có tên viewIsAppearing mà bạn có thể sử dụng thay thế.

viewIsAppearing được gọi sau viewWillAppear khi chế độ xem đã được thêm vào hệ thống phân cấp và cả bộ điều khiển chế độ xem và chế độ xem đều có bộ sưu tập đặc điểm cập nhật.

viewIsAppearing là một sự thay thế thả vào cho gần như tất cả các trường hợp mà bạn đang sử dụng viewWillAppear hôm nay.

Và phần hay nhất là phương pháp mới này triển khai lại cho iOS 13.

Xem "Có gì mới trong UIKit" để tìm hiểu thêm về cuộc gọi lại mới này và cách nó phù hợp với vòng đời của bộ điều khiển chế độ xem.

iOS 17 cũng cải thiện tính nhất quán và hiệu suất để cập nhật đặc điểm chế độ xem.

Lượt xem chỉ cập nhật bộ sưu tập đặc điểm của họ khi họ ở trong hệ thống phân cấp.

Và một khi ở trong hệ thống phân cấp, mỗi chế độ xem chỉ cập nhật bộ sưu tập đặc điểm của nó ngay lập tức trước khi nó thực hiện bố cục.

Cách thực hành tốt nhất là sử dụng các đặc điểm trong quá trình bố trí.

Đối với chế độ xem, điều đó có nghĩa là sử dụng traitCollection từ bên trong phương thức layoutSubviews.

Hãy nhớ rằng layoutSubviews chạy lại bất cứ lúc nào setNeedsLayout được gọi trên chế độ xem, vì vậy việc triển khai của bạn sẽ tránh trùng lặp công việc nếu được gọi nhiều lần.

Các đặc điểm tùy chỉnh là một tính năng mới mạnh mẽ trong iOS 17.

Chúng mở ra một cách hoàn toàn mới để bạn cung cấp dữ liệu cho bộ điều khiển chế độ xem và chế độ xem của mình.

Khi bạn làm việc với dữ liệu trong ứng dụng của mình, hãy xem xét những điều sau đây để giúp bạn quyết định khi nào nên xác định một đặc điểm tùy chỉnh mới.

Đặc điểm là một lựa chọn tuyệt vời khi bạn cần truyền dữ liệu đến nhiều trẻ em, chẳng hạn như từ bộ điều khiển chế độ xem mẹ đến nhiều bộ điều khiển chế độ xem con hoặc từ chế độ xem trên đến tất cả các chế độ xem con của nó.

Bạn cũng có thể sử dụng các đặc điểm để truyền dữ liệu đến các thành phần khác có thể được lồng sâu nhiều lớp, nơi bạn không có kết nối trực tiếp với chúng.

Bởi vì các đặc điểm được kế thừa thông qua hệ thống phân cấp, chúng có thể cung cấp bối cảnh cho quan điểm của bạn và bộ điều khiển chế độ xem về môi trường của chúng, chẳng hạn như cung cấp thông tin về bộ điều khiển chế độ xem chứa.

Mặc dù hệ thống đặc điểm rất mạnh, nhưng việc sử dụng nó để truyền dữ liệu không miễn phí.

Để có hiệu suất tốt nhất, hãy sử dụng các đặc điểm khi chúng tăng thêm giá trị, nhưng tránh sử dụng các đặc điểm khi bạn có thể dễ dàng truyền dữ liệu trực tiếp.

Bây giờ bạn đã sẵn sàng để xác định đặc điểm tùy chỉnh đầu tiên của mình.

Hãy tưởng tượng rằng tôi có màn hình Cài đặt trong ứng dụng của mình và tôi muốn triển khai một đặc điểm cho biết liệu chế độ xem có được chứa bên trong bộ điều khiển chế độ xem Cài đặt của tôi hay không.

Tôi có thể xác định một đặc điểm tùy chỉnh chỉ với một vài dòng mã.

Để bắt đầu, tôi khai báo một cấu trúc mới và tuân thủ giao thức UITraitDefinition.

Tôi triển khai một thuộc tính tĩnh bắt buộc, defaultValue.

Đây là giá trị mặc định cho đặc điểm khi không có giá trị nào được đặt.

Mỗi định nghĩa đặc điểm có một loại giá trị liên quan, được suy ra từ Giá trị mặc định.

Trong trường hợp này, vì tôi đang gán Giá trị mặc định là sai, loại giá trị của đặc điểm này được suy ra là Bool.

Nếu bạn đã từng xác định khóa môi trường tùy chỉnh trong SwiftUI trước đây, điều này sẽ cảm thấy rất quen thuộc.

Khi bạn đã xác định được một đặc điểm, bạn có thể sử dụng nó ngay lập tức với các API mới trên UITraitCollection và UIMutableTraits.

Bạn có thể nghĩ về đặc điểm như một chìa khóa mà bạn sử dụng để lấy và đặt các giá trị.

Bên trong trình khởi tạo UITraitCollection mới, tôi có thể đặt giá trị cho đặc điểm của mình bằng cách sử dụng toán tử chỉ số trên UIMutableTraits.

Và sau đó tôi có thể đọc lại giá trị cho đặc điểm bằng cách sử dụng toán tử chỉ số trên UITraitCollection.

Thêm hai tiện ích mở rộng đơn giản sẽ cho phép tôi truy cập đặc điểm này bằng cú pháp thuộc tính tiêu chuẩn, giống như tất cả các đặc điểm của hệ thống.

Ở đây tôi đã khai báo một thuộc tính chỉ đọc trong một phần mở rộng của lớp UITraitCollection bất biến.

Và sau đó tôi đã khai báo một thuộc tính đọc-ghi trong một phần mở rộng của giao thức UIMutableTraits.

Bây giờ tôi đã thêm các tiện ích mở rộng rất đơn giản này, tôi có thể sử dụng cú pháp thuộc tính tiêu chuẩn để truy cập đặc điểm của mình ở mọi nơi.

Luôn viết các tiện ích mở rộng này khi bạn xác định các đặc điểm tùy chỉnh của riêng mình.

Tôi có một ý tưởng cho một đặc điểm tùy chỉnh khác.

Hãy tưởng tượng tôi đang xây dựng hỗ trợ cho các chủ đề màu tùy chỉnh trong ứng dụng của mình.

Tôi có một enum tên là MyAppTheme đại diện cho bốn chủ đề màu sắc khác nhau mà ứng dụng của tôi hỗ trợ.

Điều đầu tiên tôi sẽ làm là khai báo một cấu trúc mới phù hợp với giao thức UITraitDefinition.

Tôi sẽ sử dụng chủ đề tiêu chuẩn làm giá trị mặc định cho đặc điểm này.

Vì tôi dự định sử dụng đặc điểm chủ đề mới này trong các màu động tùy chỉnh của ứng dụng của mình, tôi chỉ ra rằng đặc điểm này ảnh hưởng đến giao diện màu sắc và hệ thống sẽ tự động vẽ lại chế độ xem khi đặc điểm này thay đổi.

Các đặc điểm ảnh hưởng đến ngoại hình màu sắc đắt hơn nhiều, vì vậy hãy sử dụng điều này một cách tiết kiệm và chỉ cho những đặc điểm thay đổi không thường xuyên.

Các đặc điểm cũng có tên, được sử dụng cho những thứ như in đặc điểm trong trình gỡ lỗi.

Theo mặc định, nó sẽ sử dụng tên của chính loại đặc điểm, nhưng tôi có thể đặt cho nó một cái tên ngắn hơn, như "Chủ đề". Và cuối cùng, tôi có thể cung cấp một chuỗi nhận dạng.

Mã định danh làm cho đặc điểm đủ điều kiện cho các tính năng bổ sung như mã hóa.

Sử dụng định dạng DNS ngược để đảm bảo số nhận dạng của mỗi đặc điểm là duy nhất trên toàn cầu trong ứng dụng của bạn.

Tôi muốn có thể sử dụng cú pháp thuộc tính thông thường để đặt và lấy đặc điểm này, vì vậy tôi sẽ mở rộng UITraitCollection và UIMutableTraits để khai báo một thuộc tính, giống như tôi đã làm trước đây trong ví dụ trước.

Và đó là tất cả những gì tôi cần làm để thực hiện một đặc điểm chủ đề tùy chỉnh.

Bây giờ tôi có thể bắt đầu sử dụng đặc điểm mới này.

Ví dụ, đây là cách xác định màu động tùy chỉnh thay đổi giao diện của nó dựa trên chủ đề.

Tôi tạo một UIColor mới bằng cách sử dụng trình khởi tạo nhà cung cấp động.

Bên trong phần đóng, tôi sử dụng chủ đề của bộ sưu tập đặc điểm được chuyển vào để xác định màu nào sẽ trả lại.

Bây giờ tôi có thể đặt màu nền tùy chỉnh này thành chế độ xem.

Bởi vì tôi đã chỉ ra rằng đặc điểm này ảnh hưởng đến giao diện màu sắc khi tôi xác định nó, bất kỳ chế độ xem nào sử dụng màu nền tùy chỉnh này sẽ tự động cập nhật khi chủ đề thay đổi.

Khi xác định một đặc điểm, điều quan trọng nhất cần xem xét là kiểu dữ liệu liên quan của các giá trị của đặc điểm đó.

Các đặc điểm tốt nhất được xây dựng xung quanh các loại giá trị, bao gồm các cấu trúc và liệt kê đơn giản.

Tránh các đặc điểm dựa trên các lớp học trong Swift.

Các kiểu dữ liệu hiệu quả nhất cho các đặc điểm là Bool, Int và Double, hoặc một enum sử dụng giá trị thô Int.

Enums là một trong những kiểu dữ liệu hữu ích nhất cho các đặc điểm.

Chỉ cần đảm bảo chỉ định rõ ràng Int là kiểu dữ liệu thô của enum để đạt hiệu quả tối đa.

Bất kỳ loại dữ liệu cấu trúc tùy chỉnh nào mà bạn sử dụng làm giá trị đặc điểm phải có cách triển khai hiệu quả giao thức Equatable.

Hệ thống sẽ so sánh các giá trị đặc điểm thường xuyên để xác định khi nào các đặc điểm đã thay đổi, vì vậy chức năng ngang bằng của bạn phải càng nhanh càng tốt.

Đối với những người bạn có ứng dụng sử dụng Objective-C, chức năng hệ thống đặc điểm mới cũng có sẵn ở đó.

API cho các đặc điểm tùy chỉnh khác nhau trong Swift và Objective-C.

Tuy nhiên, bạn có thể xác định một đặc điểm tùy chỉnh trong Swift và một trong Objective-C, và cả hai đều trỏ đến cùng một dữ liệu cơ bản.

Tham khảo tài liệu để biết thêm chi tiết và cân nhắc đặc biệt.

Khi bạn đã xác định một đặc điểm tùy chỉnh, bước tiếp theo là điền một số dữ liệu cho nó vào hệ thống phân cấp đặc điểm của ứng dụng của bạn.

Ghi đè đặc điểm là cơ chế bạn sử dụng để sửa đổi dữ liệu trong hệ thống phân cấp đặc điểm.

Trong iOS 17, việc áp dụng ghi đè đặc điểm trở nên dễ dàng hơn bao giờ hết.

Có một thuộc tính traitOverrides mới trên mỗi lớp môi trường đặc điểm, bao gồm cảnh cửa sổ, cửa sổ, chế độ xem, bộ điều khiển chế độ xem và bộ điều khiển bản trình bày.

Quay trở lại hình minh họa của hệ thống phân cấp đặc điểm, ghi đè đặc điểm thay đổi giá trị cho các đặc điểm ở bất kỳ vị trí nào trong cây này.

Khi bạn áp dụng ghi đè đặc điểm cho một trong các môi trường đặc điểm trong hệ thống phân cấp này, nó sẽ sửa đổi giá trị cho đặc điểm đó trong bộ sưu tập đặc điểm của đối tượng đó và tất cả các hậu duệ của nó.

Lấy môi trường đặc điểm cha mẹ và con cái từ hệ thống phân cấp đặc điểm, đây là cách ghi đè đặc điểm ảnh hưởng đến cả hai.

Ghi đè đặc điểm được áp dụng cho cha mẹ ảnh hưởng đến bộ sưu tập đặc điểm của cha mẹ.

Và sau đó các giá trị từ bộ sưu tập đặc điểm của cha mẹ được thừa hưởng cho đứa trẻ.

Cuối cùng, ghi đè đặc điểm của đứa trẻ được áp dụng cho các giá trị mà nó được thừa hưởng để tạo ra bộ sưu tập đặc điểm của riêng nó.

Hãy nghĩ về ghi đè đặc điểm là đầu vào tùy chọn và bộ sưu tập đặc điểm là đầu ra.

Bất kỳ đặc điểm nào không ghi đè sẽ kế thừa từ cha mẹ.

Tôi sẽ xem qua một ví dụ về việc sử dụng ghi đè đặc điểm để thay đổi chủ đề màu sắc cho các phần cụ thể của ứng dụng của tôi.

Ở bên phải, tôi có một minh họa về hệ thống phân cấp đặc điểm của ứng dụng của tôi.

Ban đầu, tôi chưa áp dụng bất kỳ ghi đè nào để điền giá trị cho đặc điểm chủ đề của mình, vì vậy tất cả các bộ sưu tập đặc điểm này đều có giá trị mặc định, đó là chủ đề tiêu chuẩn.

Tôi sẽ bắt đầu bằng cách áp dụng ghi đè đặc điểm cho thư mục gốc của hệ thống phân cấp này trên cảnh cửa sổ.

Thuộc tính traitOverrides tận dụng giao thức UIMutableTraits để cho phép bạn dễ dàng đặt các giá trị đặc điểm.

Do đó, bạn có thể đặt các giá trị ghi đè cho các đặc điểm tùy chỉnh với cú pháp thuộc tính tiêu chuẩn bằng cách sử dụng tiện ích mở rộng cho UIMutableTraits mà tôi đã giải thích trước đó.

Bằng cách đặt chủ đề thành màu phấn trên các ghi đè đặc điểm của cảnh cửa sổ, tất cả các cửa sổ, bộ điều khiển chế độ xem và chế độ xem bên trong cảnh cửa sổ đó hiện kế thừa giá trị màu phấn trong bộ sưu tập đặc điểm của chúng.

Vì vậy, bằng cách đặt chủ đề ở một nơi ở gốc của hệ thống phân cấp, tôi đã thay đổi giá trị cơ sở được truyền đến mọi thứ trong hệ thống phân cấp đó.

Ví dụ, tôi có thể đọc chủ đề từ bộ sưu tập đặc điểm của bất kỳ bộ điều khiển chế độ xem nào bên trong cảnh cửa sổ đó và lấy lại màu phấn.

Sau đó, tôi có thể sử dụng thuộc tính traitOverrides trên chế độ xem sâu hơn trong hệ thống phân cấp để sửa đổi chủ đề cho chế độ xem đó và bất kỳ thứ gì bên dưới nó.

Ở đây tôi đang thiết lập một đặc điểm chủ đề đơn sắc ghi đè cho chế độ xem này.

Vì vậy, giá trị đơn sắc này là những gì được kế thừa bởi chế độ xem con của nó, ghi đè lên giá trị pastel từ cao hơn trong hệ thống phân cấp.

Bạn có thể không thấy những thay đổi đối với ghi đè đặc điểm được phản ánh ngay lập tức trong bộ sưu tập đặc điểm.

Ví dụ, vì các chế độ xem cập nhật bộ sưu tập đặc điểm của chúng ngay trước khi bố cục, các sửa đổi đối với ghi đè đặc điểm của chế độ xem không được phản ánh trong bộ sưu tập đặc điểm của nó cho đến ngay trước khi nó chạy layoutSubviews.

Thuộc tính traitOverrides cũng cho phép bạn kiểm tra xem các ghi đè có được áp dụng hay không và loại bỏ hoàn toàn các ghi đè.

Đây là một ví dụ về việc chuyển đổi ghi đè bằng cách sử dụng phương thức chứa để kiểm tra xem ghi đè có tồn tại hay không và phương pháp xóa để xóa hoàn toàn ghi đè.

Mỗi lần phương pháp này được gọi, nó sẽ xóa ghi đè hiện có hoặc áp dụng ghi đè chủ đề mới khi chưa có.

Ghi đè đặc điểm là một cơ chế đầu vào để thiết lập các giá trị.

Để đọc các giá trị đặc điểm, luôn sử dụng thuộc tính traitCollection.

Đọc từ traitOverrides khi không có ghi đè nào được đặt sẽ tạo ra một ngoại lệ.

Dưới đây là một số cân nhắc về hiệu suất cần ghi nhớ khi bạn sử dụng ghi đè đặc điểm.

Đầu tiên, mỗi ghi đè đặc điểm có một chi phí nhỏ, vì vậy chỉ đặt ghi đè đặc điểm ở những nơi bạn cần chúng và tránh đặt ghi đè đặc điểm không được sử dụng.

Và mỗi khi bạn thay đổi ghi đè đặc điểm, hệ thống cần cập nhật bộ sưu tập đặc điểm của bất kỳ hậu duệ nào trong hệ thống phân cấp.

Do đó, hãy giảm thiểu số lần bạn thay đổi ghi đè đặc điểm.

Cuối cùng, các ghi đè đặc điểm được áp dụng gần gốc của hệ thống phân cấp, chẳng hạn như trên cảnh cửa sổ hoặc cửa sổ, ảnh hưởng đến mọi thứ bên dưới chúng.

Điều này rất hữu ích và có nhiều trường hợp sử dụng tuyệt vời để áp dụng ghi đè đặc điểm cho cảnh cửa sổ hoặc cửa sổ.

Tuy nhiên, khi một đặc điểm chỉ ảnh hưởng đến một vài chế độ xem sâu trong hệ thống phân cấp, thì thay vào đó hãy áp dụng ghi đè đặc điểm cho tổ tiên chung gần nhất của các chế độ xem đó, chẳng hạn như chế độ xem chung hoặc bộ điều khiển chế độ xem.

Bằng cách đó, bạn không phải trả chi phí truyền bá đặc điểm cho toàn bộ hệ thống phân cấp của mình khi chỉ một phần nhỏ của hệ thống phân cấp sử dụng dữ liệu đó.

Bây giờ bạn đã biết cách xác định các đặc điểm và điền dữ liệu cho chúng vào hệ thống phân cấp, bạn cần xử lý khi chúng thay đổi giá trị.

traitCollectionDidChange bị phản đối trong iOS 17.

Khi bạn triển khai traitCollectionDidChange, hệ thống không biết bạn thực sự quan tâm đến những đặc điểm nào, vì vậy nó phải gọi phương thức đó mỗi khi bất kỳ đặc điểm nào thay đổi giá trị.

Tuy nhiên, hầu hết các lớp học chỉ sử dụng một số đặc điểm và không quan tâm đến những thay đổi đối với bất kỳ lớp nào khác.

Đây là lý do tại sao traitCollectionDidChange không mở rộng quy mô khi bạn thêm ngày càng nhiều đặc điểm tùy chỉnh.

Thay vào đó, có các API đăng ký đặc điểm mới linh hoạt hơn và cải thiện hiệu suất.

Bằng cách đăng ký thay đổi các đặc điểm cụ thể, hệ thống biết chính xác bạn phụ thuộc vào đặc điểm nào.

Các API mới cho phép bạn nhận các cuộc gọi lại bằng cách sử dụng mẫu hành động mục tiêu hoặc đóng cửa.

Và bởi vì bạn không còn cần phải ghi đè một phương thức trong lớp con của mình nữa, giờ đây thật dễ dàng để quan sát những thay đổi đặc điểm từ bất cứ đâu.

Tôi sẽ bắt đầu bằng cách giải thích cách cập nhật triển khai hiện có của traitCollectionDidChange.

Đây là cách triển khai hiện tại của tôi.

Lưu ý cách tôi kiểm tra xem đặc điểm horizontalSizeClass có thay đổi hay không trước khi gọi updateViews, vì phương thức đó chỉ dựa vào một đặc điểm này.

Nếu bạn cần tiếp tục sử dụng traitCollectionDidChange vì bạn đang triển khai ứng dụng của mình cho các phiên bản iOS cũ hơn, hãy đảm bảo rằng việc triển khai của bạn sẽ kiểm tra xem các đặc điểm cụ thể mà bạn quan tâm có thay đổi hay không.

Bây giờ tôi sẽ thay thế việc triển khai này bằng các phương thức đăng ký đặc điểm mới trong iOS 17.

Tôi sẽ bắt đầu với phương pháp dựa trên đóng cửa.

Tôi gọi registerForTraitChanges và chuyển một loạt các đặc điểm để đăng ký.

Có các biểu tượng UITrait mới cho tất cả các đặc điểm của hệ thống, chẳng hạn như biểu tượng này cho lớp kích thước ngang.

Sau đó, tôi vượt qua một kết thúc được gọi là khi những đặc điểm cụ thể đó thay đổi.

Việc đóng cửa không được yêu cầu thay đổi bất kỳ đặc điểm nào khác, vì vậy không cần phải so sánh các giá trị đặc điểm cũ và mới ở đây.

Đối tượng có các đặc điểm đã thay đổi được chuyển làm tham số đầu tiên để đóng.

Sử dụng tham số này để bạn không phải nắm bắt một tham chiếu yếu đến đối tượng đó.

Khi bạn đăng ký thay đổi đặc điểm về bản thân, hãy luôn viết "bản thân: Bản thân" tại đây.

Bạn cũng có thể quan sát sự thay đổi đặc điểm cho một môi trường đặc điểm khác.

Ở đây tôi đang đăng ký thay đổi hai đặc điểm, lớp kích thước ngang và đặc điểm tùy chỉnh ContainedInSettings mà tôi đã xác định trước đó.

Việc đóng cửa thực hiện khi một trong hai đặc điểm này thay đổi ở chế độ xem khác này.

Tôi viết loại chế độ xem mà tôi đang đăng ký làm tham số đầu tiên của việc đóng cửa.

Đây là một ví dụ về phương pháp dựa trên hành động mục tiêu mới.

Gọi registerForTraitChanges và chuyển một loạt các đặc điểm để đăng ký cũng như phương pháp mục tiêu và hành động để kêu gọi các thay đổi.

Tham số mục tiêu là tùy chọn.

Nếu bạn bỏ qua nó, mục tiêu sẽ là cùng một đối tượng mà registerForTraitChanges được gọi.

Trong trường hợp này, đó là bản thân.

Như với phương pháp đóng, bạn cũng có thể đăng ký các thay đổi trên các môi trường đặc điểm khác.

Ở đây tôi đang đăng ký thay đổi đặc điểm ở chế độ xem khác, nhưng thiết lập lệnh gọi đến một phương thức trên handleTraitChange tự đặt tên.

Khi đăng ký thay đổi đặc điểm bằng cách sử dụng hành động mục tiêu, phương thức hành động của bạn có thể có không, một hoặc hai tham số.

Tham số đầu tiên luôn là đối tượng có đặc điểm đang thay đổi.

Sử dụng tham số này để lấy traitCollection mới.

Tham số thứ hai sẽ luôn là bộ sưu tập đặc điểm trước đó cho đối tượng đó trước khi thay đổi.

Ngoài việc đăng ký các đặc điểm riêng lẻ, bạn cũng có thể đăng ký bằng cách sử dụng các bộ đặc điểm hệ thống ngữ nghĩa mới.

Ví dụ, có systemTraitsAffectingColorAppearance, trả về bất kỳ đặc điểm hệ thống nào có thể ảnh hưởng đến cách phân giải màu động của hệ thống.

Ngoài ra còn có systemTraitsAffectingImageLookup, trả về tập hợp con các đặc điểm hệ thống được xem xét khi bạn tải một hình ảnh bằng UIImage (có tên:).

Chuyển trực tiếp một trong các bộ này sang registerForTraitChanges để thực hiện vô hiệu hóa tùy chỉnh.

Đăng ký được tự động dọn dẹp khi bạn sử dụng các phương pháp mới để đăng ký thay đổi đặc điểm.

Nếu bạn có trường hợp sử dụng nâng cao, bạn có thể hủy đăng ký thủ công bằng cách sử dụng mã thông báo được trả về bởi mỗi phương thức đăng ký.

Nhưng những trường hợp này rất hiếm, vì vậy nói chung bạn chỉ nên bỏ qua giá trị trả về khi bạn gọi registerForTraitChanges.

Khi bạn áp dụng API đăng ký đặc điểm mới, có hai phương pháp hay nhất cần ghi nhớ.

Đầu tiên, chỉ đăng ký các đặc điểm mà bạn thực sự phụ thuộc vào để bạn không thực hiện công việc khi các đặc điểm không liên quan thay đổi giá trị.

Cuối cùng, cố gắng vô hiệu hóa để đáp ứng với những thay đổi đặc điểm mà không cần cập nhật ngay lập tức.

Ví dụ: nếu bạn sử dụng các đặc điểm bên trong phương thức layoutSubviews của lớp con view, hãy gọi setNeedsLayout để vô hiệu hóa thay đổi đặc điểm.

Điều này lên lịch xem để nhận layoutSubviews, nhưng không thực hiện cập nhật ngay lập tức.

Giờ đây, bạn có thể truyền dữ liệu của riêng mình bằng cách sử dụng hệ thống đặc điểm trong UIKit, nó mở ra một cách hoàn toàn mới để bạn chuyển dữ liệu liền mạch giữa các thành phần UIKit và SwiftUI trong ứng dụng của mình.

Các đặc điểm tùy chỉnh trong UIKit rất giống với các khóa môi trường tùy chỉnh trong SwiftUI.

Bạn có thể kết nối chúng để truy cập cùng một dữ liệu từ cả UIKit và SwiftUI.

Cho dù bạn đang nhúng các thành phần SwiftUI vào bên trong UIKit hay các thành phần UIKit bên trong SwiftUI, dữ liệu cầu nối sẽ chuyển liền mạch giữa chúng.

Bạn có thể đọc và ghi vào cùng một dữ liệu cơ bản bằng cách sử dụng API đặc điểm trong mã UIKit và API môi trường trong mã SwiftUI của bạn.

Thật dễ dàng để lấy đặc điểm chủ đề màu mới mà tôi đã xác định cho mã UIKit của ứng dụng và kết nối nó với khóa môi trường tương ứng trong SwiftUI.

Giả sử tôi có một đặc điểm tùy chỉnh trong UIKit và một khóa môi trường tùy chỉnh trong SwiftUI đại diện cho cùng một dữ liệu, tất cả những gì tôi cần làm để kết nối chúng là thêm sự phù hợp với giao thức UITraitBridgedEnvironmentKey.

Để làm điều này, tôi thực hiện một phương thức để đọc đặc điểm từ UIKit và trả lại giá trị cho SwiftUI và một phương pháp để viết giá trị môi trường SwiftUI cho đặc điểm UIKit.

Và bây giờ cả đặc điểm UIKit và khóa môi trường SwiftUI đều truy cập lưu trữ hợp nhất, vì vậy tôi có thể đọc hoặc ghi vào cùng một dữ liệu từ các thành phần được viết bằng một trong hai khuôn khổ.

Đây là một ví dụ về cách tôi có thể sử dụng đặc điểm cầu nối và khóa môi trường.

Ở thư mục gốc của ứng dụng của tôi, tôi áp dụng ghi đè đặc điểm cho đặc điểm chủ đề lên cảnh cửa sổ UIKit.

Điều này truyền giá trị chủ đề đơn sắc đến mọi thứ chứa bên trong cảnh cửa sổ đó.

Sau đó, sâu hơn bên trong cửa sổ trong cảnh cửa sổ đó, tôi có chế độ xem bộ sưu tập UIKit.

Chế độ xem bộ sưu tập này chứa các ô, được cấu hình bằng UIHostingConfiguration, để hiển thị chế độ xem SwiftUI trong mỗi ô.

Bên trong SwiftUI CellView, tôi có một thuộc tính có tên là "theme", sử dụng trình bao bọc thuộc tính Môi trường để đọc giá trị từ môi trường SwiftUI.

Giá trị trong môi trường tương ứng với cùng một giá trị cho đặc điểm bắc cầu trong UIKit.

Và cuối cùng, tôi sử dụng thuộc tính chủ đề để kiểm soát màu sắc của văn bản bên trong chế độ xem SwiftUI này.

Bởi vì SwiftUI tự động theo dõi các phụ thuộc dữ liệu, nếu đặc điểm chủ đề ghi đè lên trên cảnh cửa sổ UIKit thay đổi sang một giá trị khác, chế độ xem ô SwiftUI của tôi sẽ tự động cập nhật để phản ánh chủ đề mới.

Cầu nối cũng hoạt động theo hướng khác.

Ở đây tôi có chế độ xem SwiftUI hiển thị cài đặt ứng dụng của tôi.

Tôi sử dụng công cụ sửa đổi môi trường để đặt chủ đề tiêu chuẩn, điều này sẽ áp dụng cho mọi thứ trong bộ điều khiển cài đặt.

Điều này về mặt khái niệm tương đương với việc áp dụng ghi đè đặc điểm trong UIKit.

Sau đó, trong bộ điều khiển chế độ xem Cài đặt dựa trên UIKit chứa bên trong UIViewControllerRepresentable, tôi đọc giá trị chủ đề từ đặc điểm bắc cầu và sử dụng nó để cập nhật tiêu đề được hiển thị cho bộ điều khiển chế độ xem này.

Đây là cách dễ dàng truy cập dữ liệu liền mạch bằng cách sử dụng các đặc điểm UIKit bắc cầu và các khóa môi trường SwiftUI.

Bây giờ bạn đã tìm hiểu về các tính năng mới mạnh mẽ này, hãy đến và tìm các địa điểm trong ứng dụng của bạn, nơi bạn có thể tận dụng hệ thống đặc điểm để tự động truyền dữ liệu bằng cách xác định các đặc điểm tùy chỉnh của riêng bạn.

Tiếp theo, áp dụng thuộc tính traitOverrides mới để dễ dàng sửa đổi dữ liệu trong hệ thống phân cấp đặc điểm.

Và sau đó sử dụng các API đăng ký đặc điểm linh hoạt hơn để tạo ra sự phụ thuộc chính xác vào các đặc điểm chính xác mà bạn sử dụng.

Cuối cùng, kết nối các đặc điểm UIKit tùy chỉnh của bạn với các khóa môi trường SwiftUI tùy chỉnh để dữ liệu của bạn chuyển liền mạch giữa các thành phần UIKit và SwiftUI trong ứng dụng của bạn.

Bây giờ tùy thuộc vào bạn để giải phóng sức mạnh của các đặc điểm.

Cảm ơn vì đã xem.

♪ ♪