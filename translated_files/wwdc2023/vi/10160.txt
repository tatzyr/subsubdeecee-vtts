10160

♪ ♪

Người: Xin chào, và chào mừng đến với "Demystify SwiftUI Performance."

SwiftUI giúp dễ dàng xây dựng các ứng dụng phức tạp, mạnh mẽ, cung cấp một tập hợp lớn các tính năng và các điều khiển phức tạp như danh sách và bảng.

Khi bạn mới bắt đầu và ứng dụng của bạn không phức tạp lắm, các vấn đề về hiệu suất không rõ ràng.

Nhưng khi sự phức tạp của ứng dụng của bạn tăng lên, hiệu suất trở nên quan trọng hơn.

Các vấn đề nhỏ có thể được khuếch đại và mã hoạt động tốt cho nguyên mẫu có thể không hoạt động tốt trong sản xuất.

Phiên này là tất cả về việc xây dựng một mô hình tinh thần cho hiệu suất trong SwiftUI bởi vì nếu bạn hiểu cách viết mã nhanh ngay từ đầu quá trình phát triển, bạn sẽ gặp ít vấn đề hơn khi ứng dụng của bạn trở nên phức tạp hơn.

Hãy kiểm tra vòng phản hồi liên quan đến việc giải quyết vấn đề hiệu suất.

Các vấn đề về hiệu suất bắt đầu bằng một triệu chứng.

Có lẽ có một cú đẩy điều hướng chậm, một hình ảnh động bị hỏng hoặc bạn đang nhìn thấy con trỏ chờ quay trên macOS.

Khi bạn xác định được một vấn đề về hiệu suất, bước đầu tiên để giải quyết nó là đo lường.

Khi bạn đã đo lường và xác minh rằng triệu chứng tồn tại, hãy xác định nguyên nhân của nó.

Đây thường có thể là một trong những giai đoạn phức tạp hơn của vòng lặp này bởi vì nó đòi hỏi trực giác về cách mọi thứ được cho là hoạt động.

Lỗi phát sinh khi ứng dụng của bạn có giả định không chính xác.

Phiên này nhằm giúp bạn xác định sự không phù hợp giữa các giả định và thực tế của ứng dụng của bạn.

Sau khi xác định nguyên nhân gốc rễ, hãy khắc phục sự cố thông qua tối ưu hóa.

Nhưng các vấn đề về hiệu suất không kết thúc sau khi bạn đã tìm ra nguyên nhân gốc rễ và tối ưu hóa mã của mình.

Bạn cần đo lại và xác minh lại bất kỳ bản sửa lỗi nào bạn thực hiện để đảm bảo rằng nó giải quyết được vấn đề.

Đây là một phương pháp hay cho tất cả các lỗi, nhưng nó đặc biệt quan trọng đối với hiệu suất.

Sau khi bạn đã xác minh rằng vấn đề đã được giải quyết, bạn phá vỡ vòng lặp.

Sơ đồ này đặt phiên này vào ngữ cảnh.

Lý tưởng nhất, bạn không bao giờ kết thúc trong chu kỳ này và bạn có thể tránh được nhiều vấn đề về hiệu suất bằng cách viết mã nhanh khi tạo mẫu.

Tuy nhiên, không thể tránh khỏi rằng, khi ứng dụng của bạn trở nên phức tạp hơn, bạn sẽ gặp phải lỗi hiệu suất.

Nó xảy ra với những người giỏi nhất trong chúng ta.

Và khi bạn gặp phải các vấn đề về hiệu suất, thật tốt khi có nhiều công cụ theo ý của bạn để phân loại và khắc phục chúng.

Phiên này nhằm mục đích giúp việc vượt qua vòng lặp dễ dàng hơn.

Đây là một phiên nâng cao, và có một số điều kiện tiên quyết.

Bạn nên hiểu sơ lược về danh tính SwiftUI, bao gồm sự khác biệt giữa danh tính ngầm và danh tính rõ ràng.

Điều quan trọng là phải biết sự khác biệt giữa tuổi thọ quan điểm và bản sắc quan điểm.

Nếu bạn không có những điều kiện tiên quyết này, đừng lo lắng.

Phiên "Demystify SwiftUI" từ WWDC21 đã giúp bạn.

Phiên hôm nay tiếp tục nơi mà phiên đó đã dừng lại.

Hãy xem qua chương trình nghị sự.

Chúng ta sẽ bắt đầu với một cuộc thảo luận chuyên sâu về các phụ thuộc và khám phá quy trình cập nhật SwiftUI một cách chi tiết.

Tiếp theo, chúng ta sẽ chuyển sang thảo luận về các bản cập nhật và cách cải thiện tốc độ SwiftUI cập nhật giao diện của bạn.

Và cuối cùng, nhưng chắc chắn không kém phần quan trọng, chúng ta sẽ thảo luận về danh tính trong danh sách và bảng.

Trên đường đi, chúng ta sẽ xem qua SwiftUI và xem một số mẹo và thủ thuật để sử dụng khi phát triển.

Phiên này chủ yếu liên quan đến việc cập nhật chậm vào hệ thống phân cấp chế độ xem, nhưng hoàn toàn không phải là một cái nhìn toàn diện về tất cả các vấn đề về hiệu suất mà bạn có thể gặp phải khi phát triển một ứng dụng.

Hãy bắt đầu với Phụ thuộc.

Đã vài năm kể từ phiên "Demystify SwiftUI" cuối cùng và tôi đã bỏ lỡ việc làm việc trên các ứng dụng theo chủ đề chó.

Vì vậy, tiếp tục chủ đề từ phiên đó, tôi đã làm việc trên một ứng dụng mới cho phép tôi theo dõi những người bạn lông lá yêu thích của mình và thiết lập thời gian để chơi với họ.

Đây là một trong những khung cảnh, một bảng hiển thị tất cả những con chó.

Ứng dụng cũng có chế độ xem chi tiết, được hiển thị ở đây trên iPhone, hiển thị hình ảnh lớn hơn về từng con chó, sở thích của con chó và cung cấp một nút để thiết lập thời gian chơi.

Đây là mã cho cùng một chế độ xem đó.

Chế độ xem lấy một con chó làm tham số và cũng có một thuộc tính môi trường để biết liệu đó có phải là thời gian chơi hay không.

Như đã đề cập trong phiên Demystify trước đó, điều này có nghĩa là con chó và các biến thời gian chơi là phụ thuộc của chế độ xem và một cách khác để hiển thị chế độ xem này là dưới dạng biểu đồ.

Đây là một biểu đồ cơ bản đại diện cho cùng một chế độ xem.

Mỗi mũi tên đại diện cho phần thân của một khung cảnh.

Chế độ xem chó tạo ra một ngăn xếp.

Và ngăn xếp có nhiều con, như một số văn bản, hình ảnh con chó có thể mở rộng, chế độ xem chi tiết và nút.

Tiếp tục, mỗi chế độ xem đó đều có con và biểu đồ tiếp tục cho đến khi đạt đến chế độ xem lá, như hình ảnh, văn bản hoặc màu sắc.

Tất cả các quan điểm cuối cùng đều giải quyết thành một cái nhìn lá.

Có rất nhiều lượt xem lá trong SwiftUI, vì vậy tôi sẽ không bao gồm tất cả chúng ở đây.

Kiểm tra tài liệu để biết thêm thông tin.

Hãy quay lại ứng dụng.

Bất cứ khi nào tôi sử dụng ứng dụng, tôi có thể đăng nhập bất cứ khi nào tôi chơi với một trong những người bạn của mình.

Tôi vừa chơi xong trò tìm nạp với Rocky ở đây, vì vậy tôi đã lưu ý điều đó trong ứng dụng, ứng dụng này cập nhật nút và hình ảnh.

Rocky trông khá hạnh phúc, nhưng anh ấy chắc chắn quá mệt mỏi để chơi bây giờ.

Khi dữ liệu này thay đổi trong mô hình, SwiftUI sẽ cập nhật chế độ xem này.

Hãy cùng khám phá quá trình cập nhật chuyên sâu bằng cách quay lại biểu đồ và xem điều gì sẽ xảy ra khi thay đổi này xảy ra.

Đây là biểu đồ của chúng tôi một lần nữa.

Đây là nơi phiên Demystify trước đó dừng lại, giải thích rằng các chế độ xem tạo thành một biểu đồ và SwiftUI xem xét các phụ thuộc khi đánh giá mã của bạn.

Hãy phóng to và cung cấp cái nhìn sâu sắc hơn về nguồn gốc của những phụ thuộc đó và cách bạn có thể kiểm soát chúng.

Mỗi chế độ xem con phụ thuộc vào giá trị chế độ xem được tạo ra bởi tổ tiên của nó.

Nhưng cũng có những hình thức phụ thuộc khác.

Các thuộc tính động cũng là một nguồn phụ thuộc phổ biến.

Ví dụ, DogView đọc liệu đó có phải là thời gian phát từ môi trường hay không bằng cách sử dụng trình bao bọc thuộc tính @Environment.

Do đó, nó phụ thuộc cả vào giá trị do cha mẹ tạo ra và giá trị từ môi trường.

Nếu chúng ta hình dung thời gian trên trục X, bước đầu tiên trong quá trình cập nhật là tạo ra một giá trị mới cho chế độ xem.

Giá trị này bao gồm tất cả các thuộc tính được lưu trữ của chế độ xem, như giá trị chó và giá trị ban đầu của thuộc tính động.

Tiếp theo, SwiftUI cập nhật tất cả các thuộc tính động của chế độ xem, thay thế các giá trị của chúng bằng các giá trị hiện tại từ biểu đồ.

Cuối cùng, với giá trị cập nhật, cơ thể chạy để tạo ra con cái của chế độ xem.

Hãy mang biểu đồ vào một lần nữa.

Quá trình này hoàn trả để cập nhật giao diện, chỉ cập nhật những chế độ xem có giá trị mới hoặc các phụ thuộc đã thay đổi khác.

Khi chúng tôi đánh dấu Rocky là mệt mỏi, chúng tôi nhận được một con chó mới - xin lỗi, một giá trị cấu trúc con chó mới, nhưng nó vẫn giữ nguyên Rocky.

Bởi vì dữ liệu của chúng tôi là một loại giá trị, một bản sao mới của nó được tạo ra khi nó bị đột biến.

Và điều đó dẫn đến việc DogView tạo ra nội dung mới cho ngăn xếp, Cập nhật con của ngăn xếp.

Tôi chỉ tập trung vào ScalableDogImage ở đây, nhưng các chế độ xem khác có thể cập nhật nếu chúng phụ thuộc vào giá trị của chó.

ScalableDogImage cuối cùng tạo ra một hình ảnh mới.

Hình ảnh là chế độ xem lá, vì vậy phần còn lại của công việc được SwiftUI thực hiện từ đây.

Quá trình sau đó kết thúc, và một kết xuất mới được tạo ra.

Đó là cách nhìn vào biểu đồ phụ thuộc.

Hãy xem qua một số mẹo để cải thiện quy trình này.

Điều quan trọng là phải giảm các bản cập nhật xuống chỉ những cập nhật cần thiết.

Để hiểu khi nào chế độ xem được cập nhật, SwiftUI có phương thức printChanges.

Điều này cho phép bạn in ra lý do tại sao trình đánh giá biểu đồ SwiftUI gọi vào phần thân của chế độ xem.

Hãy xem qua một ví dụ về cách sử dụng nó.

Ở đây chúng tôi có hình ảnh con chó có thể mở rộng của chúng tôi, chứa một phần của trạng thái.

Khi chúng ta nhấn vào hình ảnh, trạng thái sẽ thay đổi như vậy.

Chỉ tập trung vào chế độ xem hình ảnh, nếu chúng ta đặt điểm dừng trong phần thân chế độ xem của mình, từ bảng điều khiển LLDB, chúng ta có thể gọi Self._printChanges bằng cách sử dụng lệnh LLDB "biểu thức".

printChanges là một cơ sở chỉ gỡ lỗi đưa ra lời giải thích nỗ lực nhất về lý do tại sao SwiftUI yêu cầu nội dung của chế độ xem.

Trong trường hợp này, đó là vì scaleToFill đã thay đổi.

Bạn có thể sử dụng printChanges để hiểu liệu một chế độ xem có thể có thêm phụ thuộc hay không.

Ví dụ, tôi hiện đang chạy ứng dụng của mình và gỡ lỗi và muốn xem liệu chế độ xem này có phụ thuộc thêm hay không.

Tôi có thể thêm một cuộc gọi để inThay đổi vào nội dung của chế độ xem này để in mỗi khi nội dung của chế độ xem được truy cập.

Tuy nhiên, lưu ý rằng printChanges có tiền tố là dấu gạch dưới.

Trong trường hợp này, điều đó có nghĩa là, nó không bao giờ được đảm bảo luôn tồn tại và thậm chí có thể bị xóa trong bản phát hành trong tương lai, vì vậy đừng bao giờ gửi cuộc gọi đến phương thức này đến cửa hàng ứng dụng.

Tôi sẽ cần xóa cuộc gọi này sau.

Nó chỉ có nghĩa là để gỡ lỗi và có tác động đến hiệu suất thời gian chạy.

Nếu tôi chạy lại ứng dụng của mình và thay đổi món ăn yêu thích của Rocky, chẳng hạn như từ bánh quy sang thứ khác, chẳng hạn như dưa chuột, tôi sẽ nhận thấy nhật ký vào bảng điều khiển từ hình ảnh của chúng tôi.

Nó nói rằng "bản thân" đã thay đổi.

Điều này có nghĩa là giá trị chế độ xem đã thay đổi, vì vậy chế độ xem hình ảnh có thể mở rộng phải có một số phụ thuộc vào điều trị, nhưng nó không thực sự cần thiết.

Tập trung vào mã, giá trị của chế độ xem chỉ có thành viên scaleToFill và thuộc tính chó.

Vì scaleToFill là một thuộc tính động SwiftUI, nó sẽ hiển thị trong nhật ký thay đổi nếu nó đã thay đổi, vì vậy "@Self" ở đây có nghĩa là giá trị con chó đã thay đổi.

Nhưng nhìn vào khung cảnh này, chúng tôi chỉ quan tâm đến hình ảnh.

Vì vậy, chúng ta có thể loại bỏ sự phụ thuộc này bằng cách thay vào đó chỉ sử dụng hình ảnh.

Và bây giờ, khi tôi thay đổi tài sản của con chó không liên quan đến hình ảnh, tôi không thấy nhật ký.

Các phụ thuộc của chế độ xem có phạm vi chặt chẽ.

Nếu bạn làm theo kỹ thuật này, đừng quên xóa lệnh gọi printChanges.

Hãy cập nhật chế độ xem phụ huynh để khớp.

Đây là mã cho chế độ xem chó mẹ.

Tôi cần cập nhật trình khởi tạo cho ScalableDogImage để chụp ảnh, như vậy.

Bằng cách trích xuất ScalableDogImage ra, tôi đã giảm các phụ thuộc xuống chỉ còn những phụ thuộc quan trọng.

Tôi cũng có thể làm tương tự với tiêu đề và trích xuất nó theo chế độ xem riêng của nó.

Điều này có một số lợi ích.

Mã này bây giờ dễ đọc hơn và các phụ thuộc của DogHeader rõ ràng tại trang web sử dụng của nó.

Kỹ thuật này hoạt động tốt cho tầm nhìn nhỏ hơn, nhưng hãy cẩn thận với các cấu trúc rất lớn.

Không phải mọi sự phụ thuộc đều xứng đáng được mở rộng phạm vi như thế này.

Bạn sẽ cần sử dụng phán đoán tốt nhất của mình.

Ít cập nhật hơn có nghĩa là hiệu suất tốt hơn khi dữ liệu thay đổi trong ứng dụng của bạn.

Như chúng ta vừa khám phá, một cách để làm điều này là giảm sự phụ thuộc.

Hãy thử giảm giá trị chế độ xem xuống chỉ còn dữ liệu mà chúng thực sự phụ thuộc vào.

Một mẹo khác là trích xuất các chế độ xem để giảm sự phụ thuộc.

Và cuối cùng, giao thức Observable mới cũng có thể giúp xác định phạm vi phụ thuộc bằng cách tự động giới hạn các phụ thuộc chỉ những gì được đọc.

Kiểm tra phiên "Khám phá Quan sát trong SwiftUI" để biết thêm thông tin.

Đó chỉ là một chuyến tham quan nhanh về cách nhìn vào các phụ thuộc.

Hãy tiếp tục nói về những cập nhật nhanh hơn.

Trong phần này, chúng ta sẽ thảo luận về cách giảm chi phí cho mỗi bản cập nhật SwiftUI.

Các bản cập nhật SwiftUI chậm có thể có một số tác động tiêu cực đến ứng dụng của bạn, bao gồm giảm khả năng phản hồi, chẳng hạn như treo và quá giang.

Treo là sự chậm trễ trong việc phản hồi tương tác của người dùng, giống như một chế độ xem mất nhiều thời gian để xuất hiện ban đầu.

Phiên "Phân tích treo trong dụng cụ" từ WWDC2023 đi vào chi tiết về cách sử dụng Dụng cụ để phân tích treo, bao gồm cách xác định xem treo có thể do công việc liên quan đến SwiftUI gây ra hay không.

Quá giang là một vấn đề hoạt hình có thể cảm nhận được của người dùng, chẳng hạn như tạm dừng trong khi cuộn hoặc bỏ qua các khung hình hoạt hình.

Nguyên nhân gốc rễ của treo và quá giang, đặc biệt là trong SwiftUI, thường có liên quan.

Để biết thêm thông tin về các trở ngại, bao gồm cách hoạt động của vòng lặp kết xuất hệ thống, hãy xem video thảo luận công nghệ "Khám phá các quá giang hoạt hình giao diện người dùng và vòng lặp kết xuất".

Cả hai lần treo và quá giang trong SwiftUI thường bắt nguồn từ một bản cập nhật chậm.

Những cập nhật chậm này có một số nguyên nhân phổ biến.

Đầu tiên là khởi tạo Thuộc tính Động tốn kém, chẳng hạn như phân bổ và khởi tạo một đối tượng trạng thái hoặc khởi tạo trạng thái.

Một nguồn khác là công việc được thực hiện trong cơ thể.

Đảm bảo kiểm tra nội suy chuỗi đắt tiền hoặc các hoạt động như lọc dữ liệu và các công việc khác bên trong cơ thể.

Điều quan trọng là bản thân cơ thể phải rẻ nhất có thể.

Tất cả đều liên quan đến nhau.

Ví dụ, một thuộc tính động có thể được tính toán từ phần thân của chế độ xem, khiến chế độ xem trở nên tốn kém để đánh giá.

Nhận dạng chậm cũng thường xuyên xảy ra trong cơ thể của chế độ xem.

Hãy bắt đầu bằng cách xem một ví dụ từ ứng dụng tìm nạp.

Trong ví dụ này, tôi đã làm việc trên chế độ xem gốc của ứng dụng, có một đối tượng mà tôi sử dụng để tạo danh sách chó.

Theo dõi mã nổi bật trên trang chiếu này, truy cập model.dogs trong cơ thể lười biếng khởi tạo đối tượng, điều này đưa chúng ta đến trình khởi tạo, tìm nạp danh sách những con chó.

Như nhận xét mã đã nói, việc này có thể mất nhiều thời gian.

Đây là công việc đồng bộ.

Một cách để khắc phục điều này là sử dụng công cụ sửa đổi nhiệm vụ.

Đầu tiên chúng ta sẽ làm cho việc tìm nạp không đồng bộ.

Tôi chỉ hiển thị việc bổ sung từ khóa không đồng bộ ở đây.

Tiếp theo, trong công cụ sửa đổi nhiệm vụ, chúng tôi sẽ tìm nạp không đồng bộ danh sách chó bằng cách chờ nó.

Bằng cách đó, ứng dụng sẽ phản hồi nhanh khi hoạt động tải dữ liệu đắt tiền xảy ra.

Có những nguồn công việc khác mà bạn có thể không nhận ra đang ảnh hưởng đến ứng dụng của mình.

Ví dụ, nội suy chuỗi thường có thể tốn kém, vì vậy hãy đảm bảo lưu trữ bất kỳ chuỗi nào bạn có thể cần sử dụng thường xuyên.

Tương tự, việc tra cứu các giá trị từ các gói có thể tốn kém.

Và tất nhiên, bất kỳ phân bổ đống nào, chẳng hạn như cho loại ràng buộc lớp, đều có thể cộng lại.

Hãy chuyển sang danh sách và bảng.

Danh sách và Bảng hỗ trợ các tính năng phong phú ngoài bố cục đơn giản, thêm lựa chọn, thao tác vuốt, sắp xếp lại hỗ trợ và hơn thế nữa.

Đây là những điều khiển phức tạp, nâng cao và hiểu danh tính là rất quan trọng để đảm bảo chúng hoạt động tốt trong ứng dụng của bạn.

Trong phần này, tôi sẽ thảo luận về danh tính trong danh sách và bảng và làm sáng tỏ cách tối đa hóa hiệu suất cập nhật cho các thành phần tích hợp này.

Trước khi chúng ta đi sâu vào chủ đề này, tôi muốn đề cập đến một số cải tiến.

Trong macOS Sonoma và iOS 17, SwiftUI có một số tối ưu hóa cho các trường hợp như lọc và cuộn.

Những cải tiến này có thể được thực hiện với nỗ lực tối thiểu từ phía bạn, và trong nhiều trường hợp, có thể dẫn đến thời gian tải và cập nhật phản hồi nhanh hơn đáng kể cho các danh sách và bảng lớn hơn.

Tuy nhiên, có một số cách nhất định để xây dựng danh sách và bảng dẫn đến hiệu suất tốt hơn.

Danh sách và Bảng sử dụng số nhận dạng để biết những thay đổi nào đã xảy ra với dữ liệu.

Để nhất quán, tất cả các ID của Danh sách và Bảng được thu thập một cách háo hức.

Do đó, có thể nhanh chóng tạo số nhận dạng cho danh sách và nội dung bảng của bạn trực tiếp chuyển thành thời gian tải và cập nhật nhanh hơn.

Identity giúp SwiftUI quản lý thời gian tồn tại của chế độ xem, điều này rất quan trọng để cập nhật gia tăng hệ thống phân cấp của bạn.

Thay đổi danh tính có nghĩa là chế độ xem đã thay đổi.

Điều này rất quan trọng đối với hoạt hình và hiệu suất.

Để biết thêm thông tin về hoạt ảnh, hãy xem phiên "Nguyên tắc cơ bản của hoạt ảnh SwiftUI".

Hiệu suất nhận dạng rất quan trọng vì số nhận dạng được thu thập thường xuyên, đặc biệt là cho các danh sách và bảng.

Hãy xem qua mô hình nhận dạng danh sách.

Tôi đã làm việc chăm chỉ trong danh sách những con chó trong ứng dụng.

Tôi đã bắt đầu chỉ với một hàng duy nhất.

Đây là mã cho danh sách, với một DogCell duy nhất bên trong.

Bước tiếp theo là sử dụng ForEach để lặp lại tất cả những con chó.

Ví dụ này rất đơn giản, nhưng nó liên quan trực tiếp đến danh tính và việc thêm ForEach vào Danh sách là thời điểm quan trọng để đánh giá hiệu suất.

Để hiểu tại sao, hãy xem chữ ký chung của ForEach tiếp theo.

Đây là chữ ký cho ForEach từ SwiftUI.

ForEach ánh xạ một tập hợp dữ liệu vào một chuỗi các chế độ xem kết quả, tạo ra danh tính rõ ràng cho mỗi chế độ xem của nó.

Khi bạn sử dụng Danh sách, nó cần tìm ra có bao nhiêu hàng để hiển thị, cũng như số nhận dạng cho mỗi hàng là gì.

Do đó, nó truy cập bộ sưu tập dữ liệu ở phía trước, xác định ID của từng phần tử.

Việc đóng nội dung được gọi để tạo ra mỗi chế độ xem.

Các hàng được tạo theo yêu cầu.

Danh sách sử dụng kết hợp danh tính và nội dung để tạo ra một hàng danh sách.

Các hàng được tạo theo yêu cầu tương quan với khu vực hiển thị, cộng với một số bộ đệm do hệ thống xác định để tìm nạp trước hoặc khả năng truy cập.

Khi chế độ xem được cuộn, nhiều chế độ xem sẽ tồn tại.

Đây là đoạn mã sản xuất ForEach này.

Lưu ý ở đây rằng nội dung chỉ là DogCell, bản thân nó là chế độ xem duy nhất, bởi vì nó sử dụng HStack bên trong.

ForEach rất quan trọng trong việc xác định ID hàng cuối cùng được sử dụng bởi Danh sách.

Và List cần biết trước tất cả các ID của nó.

Nhưng nó chỉ có thể làm điều này một cách hiệu quả mà không cần truy cập tất cả nội dung nếu nội dung phân giải thành một số hàng không đổi.

Ví dụ, giả sử chúng tôi muốn cấu trúc lại danh sách của mình để chỉ cho những con chó thích nhặt bóng.

Có thể rất hấp dẫn khi thêm bộ lọc bằng cách sử dụng chế độ xem có điều kiện, như thế này.

Ở đây, số lượt xem có thể thay đổi. Nó là một hoặc không.

Điều này thật tệ vì nó dẫn đến danh sách cần xây dựng tất cả các chế độ xem để truy xuất số nhận dạng hàng vì nó không biết mỗi phần tử phân giải thành bao nhiêu lượt xem.

Điều tương tự cũng đúng nếu bạn sử dụng AnyView.

Ở đây, số lượt xem bây giờ hoàn toàn không rõ.

Vì vậy, chúng tôi có cùng một vấn đề như trước đây: Tất cả các hàng phải được tạo.

Điều gì sẽ xảy ra nếu chúng ta di chuyển bộ lọc vào chính bộ sưu tập dữ liệu?

Bây giờ chúng ta quay trở lại số lượt xem không đổi trên mỗi phần tử và chỉ những chế độ cần thiết mới được xây dựng nội dung hàng của chúng, nhưng hãy cẩn thận: Bộ lọc nội tuyến ở đây là tuyến tính trên bộ sưu tập.

Điều này có thể hoạt động trong một nguyên mẫu, nhưng khi bộ sưu tập mở rộng quy mô, hoạt động này có thể nhanh chóng trở nên tốn kém, dẫn đến cập nhật chậm.

Tốt hơn là chuyển nó ra mô hình.

Bây giờ chúng ta có những điều tốt nhất của cả hai thế giới: Bộ lọc được lưu trong bộ nhớ cache, vì vậy nó sẽ không chạy mỗi khi danh sách này được xây dựng và số lượt xem trên mỗi phần tử là không đổi.

Dưới đây là một vài mẹo để đảm bảo số lượt xem của bạn không đổi.

Lưu ý rằng cách tiếp cận này để xem số lượng chỉ có liên quan trong ngữ cảnh của ForEach trong Danh sách và Bảng vì các thành phần đó thu thập số nhận dạng của chúng trước.

Như tôi vừa đề cập, tránh sử dụng AnyView và các điều kiện lệch lạc.

Bạn cũng có thể sử dụng một ngăn xếp rõ ràng khi thích hợp, nhưng lưu ý rằng một số công cụ sửa đổi nhất định như listRowBackground cần phải theo dõi ngăn xếp chứ không phải bên trong nó.

Cuối cùng, hãy cố gắng làm phẳng các công trình ForEach lồng nhau nếu bạn có thể.

Tuy nhiên, có một nơi mà ForEach lồng nhau có thể có giá trị, danh sách được phân đoạn.

Hãy xem xét một ví dụ.

Trong ví dụ này, tôi có một danh sách những con chó được phân chia theo đồ chơi yêu thích của mỗi con chó.

Tôi đang sử dụng ForEach để tạo ra một số phần động.

Và mỗi phần có một số hàng động bên trong nó bằng cách lồng một ForEach.

Danh sách sẽ cần truy xuất tất cả các số nhận dạng, nhưng vì chúng tôi đang sử dụng các phần ở đây, SwiftUI hiểu cấu trúc này và đảm bảo danh sách vẫn hiển thị nhanh.

Các phần động là một ví dụ điển hình khi sử dụng ForEach lồng nhau được khuyến nghị.

Phương trình cơ bản cần suy nghĩ là số lượng hàng kết quả từ ForEach trong Danh sách bằng số phần tử nhân với số lượt xem được tạo ra cho mỗi phần tử.

Bạn cần đảm bảo số lượt xem trên mỗi phần tử là không đổi, hoặc SwiftUI phải xây dựng các lượt xem ngoài các số nhận dạng để xác định các hàng.

Cho đến nay chúng ta đã nói về Danh sách, nhưng những quy tắc này cũng thường áp dụng cho Bảng.

Table sử dụng TableRow thay vì chế độ xem và TableRow luôn phân giải thành một hàng duy nhất.

Hãy nhìn vào một ví dụ Bảng.

Ở đây tôi có bàn cho chó, có một ForEach bên trong.

Bởi vì TableRow luôn là một hàng duy nhất, tổng số hàng ở đây chỉ là số phần tử trong bộ sưu tập chó.

Cấu trúc này phổ biến đến mức, mới trong iOS 17 và macOS Sonoma, SwiftUI cung cấp trình khởi tạo hợp lý cho phép bạn chỉ cần viết ForEach bộ sưu tập dữ liệu của mình và thay mặt bạn tạo các hàng bảng.

Mặc dù trình khởi tạo này là mới, nhưng nó triển khai lại cho tất cả các phiên bản hệ điều hành trước đó nơi Table có sẵn.

Cấu trúc này không chỉ đơn giản hơn mà còn thực thi số lượng hàng không đổi cho nội dung ForEach, giúp hiệu suất nhận dạng.

Tuy nhiên, có một sự thay đổi ngữ nghĩa mà tôi muốn gọi là mới.

Nếu bạn có mã như thế này, nó có thể hoạt động khác trong các phiên bản hệ điều hành mới nhất.

Trong ví dụ này, chúng tôi có một con chó ForEach over, nó cũng tạo ra một hàng chó.

Tuy nhiên, những con chó ở đây không phù hợp.

Những giá trị là người bạn tốt nhất của chú chó.

Trong iOS 16, mỗi hàng được xác định bởi giá trị của nó.

Trong iOS 17, hành vi này đã thay đổi để cải thiện hiệu suất.

Lý do là, bây giờ chúng ta không cần xác định từng hàng bảng bằng cách nhìn vào ForEach.

Vì vậy, ví dụ này bây giờ có ID của mỗi con chó, thay vì giá trị của TableRow.

Nếu bạn cần triển khai lại, bạn có thể lấy hành vi cũ bằng cách ánh xạ qua bộ sưu tập của mình hoặc bằng cách chỉ định rõ ràng đường dẫn khóa ID.

Phương trình cơ bản cần suy nghĩ là số lượng hàng kết quả từ ForEach trong Danh sách bằng số phần tử nhân với số lượt xem được tạo ra cho mỗi phần tử.

Trong Bảng, điều này tương tự, nhưng đó là số lượng TableRows trên mỗi phần tử.

Chúng tôi đã đề cập đến một số mẹo và thủ thuật để có danh sách và bảng nhanh hơn ở đây, cụ thể là bạn nên đảm bảo số nhận dạng rẻ để tạo và số lượt xem trong ForEach nội dung là không đổi.

Hôm nay chúng tôi đã đề cập rất nhiều.

Chúng tôi bắt đầu với việc khám phá biểu đồ để hiểu các phụ thuộc và tối ưu hóa chúng.

Sau đó, chúng tôi đã xem xét các bản cập nhật chậm và cách cải thiện khả năng phản hồi.

Và cuối cùng, chúng tôi đã thảo luận về tầm quan trọng của danh tính với Danh sách và Bảng.

Với các mô hình tinh thần phù hợp, bạn có thể dễ dàng có hiệu suất tuyệt vời ngay từ khi bắt đầu quá trình phát triển, điều này cho phép bạn tập trung nhiều hơn vào các chi tiết của ứng dụng của mình.

Cảm ơn vì đã xem.

♪ ♪