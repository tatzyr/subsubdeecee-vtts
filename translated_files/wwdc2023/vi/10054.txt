10054

♪ ♪

Aasim: Xin chào, tôi là Aasim Kandrikar, và sau đó, tôi sẽ được tham gia bởi Raleigh Ledet.

Cả hai chúng tôi đều là Kỹ sư trong nhóm AppKit.

Trong video này, chúng ta sẽ nói về "Có gì mới trong AppKit" trong macOS Sonoma.

Chúng tôi sẽ đề cập đến một loạt các chủ đề, bắt đầu với các tính năng mới và cải tiến API cho Điều khiển AppKit, cải tiến các menu được cung cấp bởi triển khai hoàn toàn mới, thay đổi cách kích hoạt ứng dụng hoạt động trên macOS, tinh chỉnh đồ họa và các tính năng mới cho hình ảnh và biểu tượng, trải nghiệm nhập văn bản mới và cải tiến

macOS Sonoma bao gồm một số tính năng mới thú vị và các cải tiến API cho các điều khiển AppKit.

NSTableView và NSOutlineView cung cấp rất nhiều chức năng ngay lập tức, khiến nó trở thành một yếu tố quan trọng trong việc thiết kế các ứng dụng Mac tuyệt vời bằng AppKit.

Trong macOS Sonoma, có API mới để trình bày các menu tùy chỉnh cột.

Trình đơn cho phép người dùng chuyển đổi khả năng hiển thị các cột trong bảng của bạn.

Trước đây, điều này sẽ yêu cầu triển khai tùy chỉnh để tạo và trình bày menu này, nhưng bây giờ bạn có thể thêm cái này chỉ trong ba dòng mã.

Áp dụng phương thức đại diện mới tableView userCanChangeVisibilityOf.

Chỉ định cột nào người dùng có thể ẩn và AppKit sẽ xử lý phần còn lại, bao gồm bản địa hóa menu và khôi phục trạng thái cột ẩn khi khởi chạy lại.

Loại Tiến độ từ Nền tảng đại diện cho công việc mà ứng dụng của bạn thực hiện.

Bạn có thể đang sử dụng điều này trong các ứng dụng của mình để thể hiện quá trình tải xuống đang diễn ra hoặc hình ảnh đang được xử lý.

Trong macOS Sonoma, bây giờ bạn có thể sử dụng loại Progress từ Foundation với NSProgressIndicator.

Chỉ định tiến độ cho thuộc tính tiến độ quan sát mới và chỉ báo tiến độ sẽ tự động cập nhật giá trị của nó khi tiến độ thay đổi, ngay cả trên các luồng nền.

API kiểu viền nút đã được cập nhật, bắt đầu với kiểu viền hoàn toàn mới, tự động.

Kiểu viền này sẽ thích ứng với kiểu phù hợp nhất tùy thuộc vào nội dung của nút và vị trí của nó trong hệ thống phân cấp chế độ xem.

Ví dụ, khi nút ở trong cửa sổ, nó sẽ chọn kiểu nút nhấn.

Khi nút được đặt trên thanh công cụ, nó sẽ chọn kiểu thanh công cụ.

Đối với nội dung cao, nút sẽ chọn kiểu nút nhấn linh hoạt.

Kiểu viền tự động hiện là kiểu viền mặc định cho tất cả các trình khởi tạo nút.

Các tên kiểu viền hiện có đã được cập nhật từ mô tả về ngoại hình của chúng sang tên hiện đại dựa trên cách sử dụng ngữ nghĩa của chúng.

Ví dụ, nút "Dõm" được đặt tên trước đây bây giờ là nút "Thanh phụ kiện", cho thấy kiểu viền này được sử dụng phổ biến nhất trong Thanh phụ kiện.

Các kiểu viền không khuyến khích hiện đã bị phản đối.

Các biện pháp không dùng nữa hiện đề cập đến các kiểu viền thay thế với cách sử dụng ngữ nghĩa rõ ràng.

Chúng tôi đã giới thiệu một loại chế độ xem phân chia hoàn toàn mới, thanh tra viên.

Thanh tra là một mục chế độ xem phân chia theo dõi hiển thị thông tin theo ngữ cảnh về nội dung hiện đang được chọn trong tài liệu.

Tương tự như thanh bên, các thanh tra viên sử dụng chiều cao đầy đủ của cửa sổ khi mặt nạ xem nội dung kích thước đầy đủ được đặt.

Các thanh tra viên mới triển khai lại macOS Big Sur.

Thêm một trình kiểm tra vào ứng dụng của bạn rất đơn giản.

Đầu tiên, tạo một mục chế độ xem phân chia mới bằng cách sử dụng trình khởi tạo inspectorWithViewController mới.

Sau đó, thêm splitViewItem mới vào bộ điều khiển chế độ xem phân chia hiện tại của bạn.

Tiếp theo, cập nhật đại diện thanh công cụ của bạn để bao gồm mục thanh công cụ thanh tra chuyển đổi mới.

Bạn thường muốn mục thanh tra chuyển đổi được đặt trên thanh tra ở cạnh sau của cửa sổ.

Để làm như vậy, hãy thêm dải phân cách theo dõi thanh tra mới và một không gian linh hoạt trước mục thanh tra chuyển đổi của bạn.

Chúng tôi đã mang lại một số cải tiến cho NSPopover.

Đầu tiên, chúng tôi đã thêm hỗ trợ cho việc neo các cửa sổ bật lên từ các mục trên thanh công cụ.

Chúng tôi cũng đã thêm một cách để hỗ trợ nội dung cửa sổ bật lên kích thước đầy đủ, vì vậy lượt xem của bạn lấp đầy toàn bộ giới hạn cửa sổ bật lên.

Tôi sẽ bắt đầu với việc neo thanh công cụ.

Có một phương pháp mới để trình bày cửa sổ bật lên của bạn liên quan đến một mục thanh công cụ.

Khi mục thanh công cụ nằm trong menu tràn, cửa sổ bật lên xuất hiện duyên dáng được neo vào chevron tràn.

Tiếp theo, nội dung cửa sổ bật lên bây giờ có thể mở rộng vào chevron cửa sổ bật lên.

Nếu bạn có một cửa sổ bật lên với chế độ xem tiêu đề nền màu, nó có thể trông giống như thế này.

Lưu ý rằng màu sắc trong nền tiêu đề không mở rộng vào chevron bật lên.

Để mở rộng nội dung cửa sổ bật lên vào khu vực chevron, hãy đặt thuộc tính hasFullSizeContent mới thành true.

Sử dụng khu vực an toàn trực tiếp để bố trí nội dung không nên bị che khuất bên trong cửa sổ bật lên.

Và bây giờ tôi sẽ chuyển nó cho Raleigh để nói về những thay đổi thú vị đối với Menus.

Raleigh: Cảm Ơn Aasim.

Các menu đã được viết lại để sử dụng đầy đủ Cocoa.

Điều này làm giảm lượng khí thải carbon của AppKit bằng cách giảm đáng kể việc sử dụng bộ nhớ và CPU.

Nó cũng cho phép các tính năng mới.

Cụ thể, tôi sẽ đề cập đến tiêu đề phần, menu bảng màu, hành vi lựa chọn mới và huy hiệu.

Những tính năng này mở ra những cơ hội mới và sẽ giảm lượng mã bạn cần viết.

Tiêu đề phần là một bổ sung mới hỗ trợ truyền đạt các nhóm trong menu của bạn và có thể được tạo bằng một dòng mã duy nhất.

Sử dụng chức năng lớp mới, sectionHeader(title:) để tạo một cái và thêm nó vào menu, giống như bất kỳ mục menu nào khác.

Trong ví dụ này, ba phần menu được tạo ra, mỗi phần có tiêu đề phần và hai mục.

Các menu bảng màu là một tính năng mới thú vị cho phép bạn xây dựng các menu trong đó các mục được sắp xếp theo một chuỗi nằm ngang.

Ví dụ, bộ chọn màu đơn giản này.

Bạn có thể biến bất kỳ menu nào thành menu bảng màu bằng cách đặt presentationStyle của menu thành .palette.

Đối với mỗi mục menu, hãy đặt hình ảnh của nó.

Đối với hình ảnh mẫu, AppKit sẽ tự động thêm tông màu lựa chọn thích hợp.

Ngoài ra, bạn có thể đặt offStateImage và onStateImage.

onStateImage được sử dụng để chỉ ra lựa chọn.

Có một vài chế độ lựa chọn mà bạn có thể chọn.

.selectAny chuyển đổi trạng thái của các mục menu riêng lẻ, nhưng sẽ không thay đổi trạng thái của các mục khác trong nhóm.

.selectOne sẽ đặt trạng thái của mục menu đã chọn thành bật trong khi tắt trạng thái của các thành viên khác trong nhóm.

Bạn cũng có thể lấy hoặc đặt mục nào ở trạng thái bật thông qua thuộc tính selectedItems.

Lưu ý: Chế độ lựa chọn và Mục đã chọn hoạt động bằng cách tổ chức các mục menu có cùng cặp mục tiêu/hành động thành một nhóm logic.

Khi tạo thủ công các mục menu bảng màu, hãy cung cấp cho mỗi mục cùng một cặp mục tiêu/hành động để tận dụng lợi thế của chế độ lựa chọn mới và hành vi của các mục đã chọn.

Và đây là một mẹo: Kỹ thuật này không giới hạn ở các menu bảng màu.

Nó cũng hoạt động cho các mục menu có cùng cặp mục tiêu/hành động trong các menu thông thường.

NSMenu cũng cung cấp một chức năng tiện lợi để tạo các menu bảng màu phổ biến.

Mảng màu xác định số lượng các mục bảng màu và tông màu của chúng.

Tiêu đề được sử dụng cho khả năng tiếp cận, vì vậy hãy đảm bảo rằng bạn thêm chúng.

Tham số mẫu tùy chọn chỉ định hình ảnh mẫu nào sẽ sử dụng để pha màu.

Ví dụ, hình ảnh biểu tượng cờ được sử dụng ở đây.

Nếu bạn không chỉ định một mẫu, thì AppKit sẽ mặc định điền vào các vòng tròn.

Ngoài ra còn có một tham số đóng tùy chọn.

Việc đóng cửa này được gọi bất cứ khi nào người dùng chuyển đổi một mục menu trong bảng màu.

Thực đơn được chuyển đến phần đóng.

Từ đó, bạn có thể nhận được một mảng các mục menu ở trạng thái bật với thuộc tính selectedItems.

Các mục trong thực đơn hiện có thể được gắn huy hiệu theo nhiều cách khác nhau.

Bạn có thể sử dụng một chuỗi đơn giản hoặc chỉ đếm.

Ngoài ra còn có ba huy hiệu đếm chuyên biệt: Vật phẩm mới, cảnh báo và cập nhật.

Khi bạn sử dụng một trong những huy hiệu này, AppKit sẽ tự động thêm văn bản thích hợp.

Hơn nữa, AppKit cũng sẽ bản địa hóa văn bản đúng cách.

Trong ví dụ này, tiếng Nhật.

Tuy nhiên, lưu ý rằng bạn vẫn chịu trách nhiệm bản địa hóa chính mục menu và biến thể huy hiệu chuỗi chung.

Đó là việc triển khai menu hoàn toàn mới: cải thiện hiệu suất, huy hiệu, bảng màu và tiêu đề phần.

Trong macOS Sonoma, chúng tôi đã giới thiệu Kích hoạt Ứng dụng Hợp tác.

Kích hoạt ứng dụng hợp tác làm giảm các công tắc ứng dụng bất ngờ, ví dụ, chuyển đổi ứng dụng trong khi bạn đang gõ.

Có hai phần để kích hoạt ứng dụng hợp tác.

Kích hoạt bây giờ là một yêu cầu, trái ngược với một lệnh.

Hệ thống xem xét bối cảnh rộng hơn về những gì người dùng đang làm để quyết định xem yêu cầu kích hoạt có phù hợp hay không.

API năng suất mới cho phép một ứng dụng ảnh hưởng đến bối cảnh của một yêu cầu kích hoạt trong tương lai.

Bây giờ kích hoạt là một yêu cầu, tham số và tùy chọn bỏ qua OtherApps bị bỏ qua.

Như vậy, trong macOS Sonoma, chức năng activate(ignoringOtherApps:) và tùy chọn activateIgnoringOtherApps đều bị phản đối.

Thay thế chúng bằng các API kích hoạt mới cho NSApplication và NSRunningApplication.

Chỉ có ứng dụng đang hoạt động mới có thể ảnh hưởng đến ngữ cảnh kích hoạt.

Nó làm như vậy bằng cách nhường cho một ứng dụng mục tiêu rõ ràng trước khi ứng dụng mục tiêu được kích hoạt.

Sau đó, khi ứng dụng mục tiêu yêu cầu kích hoạt, hệ thống sẽ sử dụng năng suất như một phần của ngữ cảnh khi đưa ra quyết định.

Nếu yêu cầu được tôn trọng, ứng dụng đang hoạt động sẽ hủy kích hoạt và ứng dụng đích sẽ kích hoạt.

Nếu không, ứng dụng đang hoạt động vẫn hoạt động.

NSWorkspace tự động xử lý việc này cho bạn khi mở URL hoặc ứng dụng.

Trong các trường hợp khác, để kích hoạt thủ công sang một ứng dụng khác, yieldActivation đến NSRunningApplication đích hoặc mã định danh gói.

Hệ thống sẽ sử dụng ngữ cảnh năng suất khi ứng dụng mục tiêu yêu cầu tự kích hoạt hoặc được kích hoạt thay mặt cho nó.

Đó là hành vi kích hoạt ứng dụng hợp tác mới.

Chúng tôi cũng đã thực hiện một số thay đổi quan trọng và thêm API mới vào đồ họa và bản vẽ trong macOS Sonoma.

Bây giờ bạn có thể tạo CGPaths từ NSBezierPaths và ngược lại.

NSBezierPath có được trình khởi tạo init(cgPath:) mới và thuộc tính cgPath.

Việc khởi tạo, cài đặt hoặc nhận cgPath luôn dẫn đến một bản sao của đường dẫn.

Các đột biến khác của NSBezierPath không được phản ánh trong các trường hợp CGPath gốc hoặc bản sao chép.

Đó là, chúng không phải là cầu nối miễn phí.

Sự bổ sung này tạo ra việc sử dụng NSBezierPath với CGPath API, chẳng hạn như thuộc tính đường dẫn trên CAShapeLayer, một dòng mã duy nhất.

Bây giờ bạn có thể tạo một đối tượng CADisplayLink trên macOS.

Đây là cùng một CADisplayLink mà bạn có thể quen thuộc từ iOS.

Đối với những người không quen thuộc với CADisplayLink, nó là một đối tượng hẹn giờ cho phép ứng dụng của bạn đồng bộ hóa bản vẽ của nó với tốc độ làm mới của màn hình.

Một đối tượng liên kết hiển thị được khởi tạo trực tiếp được đồng bộ hóa với màn hình chính, nhưng macOS không giới hạn ở một màn hình duy nhất.

Do đó, trên macOS, bạn có thể lấy đối tượng liên kết hiển thị trực tiếp từ NSView, NSWindow hoặc NSScreen với các chức năng displayLink(target:selector:) mới của họ.

Cách tiếp cận tốt nhất là lấy một đối tượng CADisplayLink trực tiếp từ phần tử có thể áp dụng cụ thể nhất, thường là chế độ xem.

Điều này là do, khi được tạo từ chế độ xem hoặc cửa sổ, CADisplayLink sẽ tự động theo dõi bất kỳ màn hình hoặc chế độ xem cửa sổ nào khi nó di chuyển xung quanh màn hình nền, bao gồm cả việc tự treo khi không hiển thị.

Trong lớp con chế độ xem này, khi startAnimating được gọi, với hai dòng mã, nó tạo ra một đối tượng DisplayLink để gọi hàm stepAnimation của nó, được đồng bộ hóa với bất kỳ màn hình nào mà chế độ xem đang bật và thêm displayLink vào vòng lặp chạy chính cho các chế độ phổ biến.

Khi hoạt ảnh hoàn tất, nó sẽ vô hiệu hóa để dừng liên kết hiển thị và xóa nó khỏi tất cả các chế độ runloop đã đăng ký.

NSColor hiện cung cấp năm màu hệ thống mới để lấp đầy các hình nền.

Các màu tô cung cấp mức độ nhấn mạnh khác nhau cho các hình dạng có kích thước khác nhau.

Các hình dạng nhỏ hơn trên tỷ lệ của rãnh trượt hoặc nền thanh tiến trình sử dụng mức độ nhấn mạnh cao hơn để nổi bật, chẳng hạn như điền hệ thống hoặc điền hệ thống phụ.

Các hình dạng lớn hơn, như hộp nhóm và nền phông chữ thích mức độ nhấn mạnh tinh tế hơn, chẳng hạn như lấp đầy hệ thống bậc bốn hoặc ngũ phân.

Những màu tô này rất năng động, vì vậy chúng tự động thích ứng với các giao diện khác nhau, bao gồm Tăng độ tương phản và Chế độ tối.

Nếu bạn đang xây dựng các yếu tố giao diện người dùng tùy chỉnh, những màu tô mới này là một cách thuận tiện để phù hợp với thiết kế hệ thống và hỗ trợ khả năng tiếp cận.

NSViews cắt nội dung bản vẽ của họ vào giới hạn của họ.

Điều đó đôi khi dẫn đến việc bản vẽ không hiển thị theo cách bạn muốn, như phần dưới cùng của glyph tiếng Hindi này trong cửa sổ cảnh báo FreeForm.

Những nơi phổ biến mà điều này có thể xảy ra là với kết xuất phông chữ, bóng tối hoặc các điểm nhấn chế độ xem phụ khác, như huy hiệu hoặc ngọn lửa trên mặt hàng "nóng" đó để bán.

Có nhiều cách để giải quyết vấn đề này.

Ví dụ, nhúng các chế độ xem kết hợp như anh chị em trong một chế độ xem lớn hơn.

Tuy nhiên, mỗi kỹ thuật đều có những nhược điểm riêng.

Trong trường hợp này, việc kết hợp chế độ xem kèm theo với một nút trong ngăn xếp ngang đơn giản sẽ không sắp xếp các dòng cơ sở của văn bản theo mặc định.

Và bây giờ bạn có một vấn đề khác cần giải quyết.

Có một cách tốt hơn.

Khi được liên kết trên macOS Sonoma, hầu hết NSViews không còn cắt vào giới hạn của chúng theo mặc định.

Thử nghiệm lượt truy cập vẫn không thay đổi và được xác định bởi hình dạng của chế độ xem.

Tất nhiên, bạn có thể ghi đè hitTest để thay đổi điều này.

Bây giờ một chế độ xem có thể vẽ bên ngoài giới hạn của nó, visibleRect được tính toán của nó cũng có thể mở rộng qua giới hạn của nó.

Xem lại bất kỳ mã nào sử dụng visibleRect và điều chỉnh cho phù hợp.

Điều này cũng ảnh hưởng đến tham số dirtyRect của hàm vẽ.

Cụ thể, dirtyRect không bị ràng buộc bởi giới hạn của chế độ xem.

AppKit có quyền vượt qua một dirtyRect lớn hơn giới hạn của chế độ xem.

AppKit cũng có quyền chia nhỏ bản vẽ thành nhiều hình chữ nhật tùy thích.

Điều này có ý nghĩa đối với bạn là bạn nên sử dụng dirtyRect để quyết định vẽ gì, chứ không phải vẽ ở đâu.

Đây là một ví dụ về kết quả vẽ bất ngờ có thể xảy ra.

Bản vẽ ghi đè này lấp đầy màu nền được truyền trong dirtyRect, khiến màu tô tràn ra ngoài giới hạn của chế độ xem, bao phủ giao diện người dùng khác trong cửa sổ.

Chế độ xem không sử dụng dirtyRect để vẽ khung.

Tương tự như vậy, việc lấp đầy nền của nó phải lấp đầy chính xác những gì thiết kế của bạn yêu cầu, không hơn không kém.

Vẽ bên ngoài dirtyRect luôn an toàn.

Lợi ích hiệu suất của dirtyRect xảy ra khi được sử dụng để quyết định phần nào trong dữ liệu của bạn mà bạn có thể tránh vẽ trong đường chuyền này.

Có lẽ việc tính toán đường nét của tên tôi theo phong cách lạ mắt này rất tốn kém.

Nếu dirtyRect chỉ là góc nhỏ này, nó sẽ không giao nhau với khung văn bản, vì vậy chế độ xem có thể tránh được những tính toán tốn kém đó.

Vẽ nền và khung vẫn được yêu cầu, nhưng, điền vào toàn bộ giới hạn và vẽ toàn bộ khung trong đường chuyền này sẽ không ảnh hưởng đến các phần khác đã được vẽ của chế độ xem vì AppKit kẹp bản vẽ vào dirtyRect.

Thuộc tính NSView .clipsToBounds mới có sẵn cho đến OS X Mavericks 10.9.

Nhưng lưu ý, trên các hệ điều hành cũ hơn, tắt .clipsToBounds có thể có một số cạnh thô.

Kiểm tra tương ứng.

Hầu hết các chế độ xem sẽ hoạt động tốt với cả bật và tắt.

Một số chế độ xem vùng chứa đưa ra quyết định rõ ràng của riêng họ.

NSClipView, đúng với tên gọi của nó, hoạt động theo cách này.

Có thể có những trường hợp cụ thể mà bạn không đồng ý với hành vi cắt xén mặc định của chế độ xem và cần thay đổi nó một cách có chọn lọc.

Xem xét trên cơ sở từng trường hợp xem lượt xem nào của riêng bạn yêu cầu giá trị clipsToBounds rõ ràng.

Sự lựa chọn đúng đắn là sự lựa chọn hiện thực hóa tầm nhìn của bạn cho ứng dụng của bạn.

Bây giờ quay lại Aasim để nói về hình ảnh.

Aasim: Cảm Ơn Raleigh.

Biểu tượng là một phần thiết yếu trong việc thiết kế ứng dụng của bạn.

Trong macOS Sonoma, các biểu tượng đạt được chức năng hoàn toàn mới, hiệu ứng biểu tượng.

Với các hiệu ứng biểu tượng, các biểu tượng của bạn giờ đây có thể có các hiệu ứng như nảy, chuyển tiếp thay thế và hoạt ảnh xung.

Hiệu ứng biểu tượng là cách tuyệt vời để nhấn mạnh một hành động đã xảy ra hoặc thay đổi trạng thái trong ứng dụng của bạn.

Thêm một hiệu ứng biểu tượng rất đơn giản.

Đầu tiên, đặt thuộc tính hình ảnh của imageView thành hình ảnh biểu tượng.

Sau đó, khi bạn muốn hiệu ứng, chỉ cần gọi addSymbolEffect vào chế độ xem hình ảnh.

Lưu ý rằng điều này sẽ chỉ hoạt động nếu NSImageView của bạn sử dụng hình ảnh biểu tượng.

Để biết thêm thông tin về việc sử dụng các hiệu ứng biểu tượng, hãy xem video "Tác động các biểu tượng trong ứng dụng của bạn".

Trong macOS Ventura, chúng tôi đã giới thiệu hỗ trợ cho Biểu tượng SF để tự động thích ứng với ngôn ngữ hiện tại của người dùng.

Bây giờ trong macOS Sonoma, hình ảnh và biểu tượng danh mục tài sản của bạn có cùng khả năng đó.

Giống như Biểu tượng SF trong macOS Ventura, chúng tuân theo ngôn ngữ hệ thống theo mặc định.

Sử dụng phương pháp ngôn ngữ hình ảnh để có được một hình ảnh với một ngôn ngữ cố định.

Tiếp theo, tôi sẽ nói về nội dung Dải động cao, hay viết tắt là HDR.

Nội dung HDR có thể thể hiện mức độ ánh sáng vượt xa nội dung tiêu chuẩn.

macOS đã hỗ trợ dải động mở rộng cho một số bản phát hành, cho phép bạn tận dụng tối đa các màn hình như Liquid Retina XDR trong Macbook Pros và Pro Display XDR.

macOS Sonoma giúp hiển thị nội dung HDR trong ứng dụng của bạn dễ dàng hơn bao giờ hết với NSImageView nhận được hỗ trợ cho nội dung HDR.

Hình ảnh chứa nội dung HDR bây giờ sẽ được hiển thị ở chế độ HDR trên phần cứng có khả năng Dải động mở rộng.

Để hiển thị nội dung HDR trong dải động tiêu chuẩn, hãy sử dụng thuộc tính ImageDynamicRange ưa thích để ghi đè.

Để biết thêm thông tin về việc áp dụng API này, hãy xem video "Hỗ trợ hình ảnh HDR trong ứng dụng của bạn".

Bắt đầu từ Xcode 15, hình ảnh và màu sắc trong Danh mục tài sản của bạn sẽ tự động được phản ánh vào mã của bạn dưới dạng các thuộc tính tĩnh trên NSImage và NSColor.

Điều này cho phép bạn sử dụng ký hiệu chấm sạch để truy cập hình ảnh thay vì khởi tạo nó bằng một chuỗi.

Các hình ảnh không phải là tùy chọn, vì vậy bạn cũng có thể loại bỏ bất kỳ lực mở gói hoặc kiểm tra bảo vệ nào.

Nếu bạn sửa đổi Danh mục tài sản để xóa hoặc đổi tên hình ảnh, trình biên dịch sẽ phát hiện bất kỳ sự không phù hợp nào với mã của bạn và tạo ra lỗi khi xây dựng ứng dụng của bạn, điều này cho phép bạn sửa nó ngay lập tức, thay vì bắt nó sau này trong thời gian chạy.

macOS Sonoma giới thiệu những thay đổi đáng kể đối với trải nghiệm đánh máy và cải tiến bố cục văn bản bằng các ngôn ngữ không phải tiếng Anh.

Nó bắt đầu với một chỉ báo chèn hoàn toàn mới thích ứng với màu nhấn hiện tại và để lại ánh sáng rực rỡ khi bạn đọc chính tả văn bản.

Tiếp theo, bây giờ có một phụ kiện con trỏ bên dưới chỉ báo chèn hiển thị thông tin chính, như chế độ nhập, trạng thái đọc chính tả và trạng thái khóa mũ.

Phụ kiện theo dõi vị trí chèn hiện tại và sẽ được ghim vào cuối tài liệu nếu vị trí chèn nằm ngoài chế độ xem hiển thị.

Các ứng dụng sử dụng chế độ xem văn bản AppKit tiêu chuẩn sẽ tự động nhận được điều này.

Nếu bạn có chế độ xem văn bản tùy chỉnh, chúng tôi có API mới mà bạn có thể áp dụng.

Bạn có thể thay thế bản vẽ chỉ báo chèn văn bản tùy chỉnh của mình bằng chế độ xem NSTextInsertionIndicator.

Thêm chế độ xem này dưới dạng chế độ xem phụ trên chế độ xem văn bản tùy chỉnh của bạn và bạn sẽ nhận được chỉ báo chèn mới nhất quán trên hệ điều hành.

Lưu ý rằng bạn sẽ chịu trách nhiệm cập nhật khung của chỉ báo chèn và liệu nó có hiển thị hay không.

Cập nhật thuộc tính displayMode thành ẩn khi chế độ xem văn bản của bạn từ bỏ phản hồi đầu tiên để ẩn chỉ báo.

MacOS Sonoma có một số cải tiến về bố cục văn bản cho các ngôn ngữ không phải tiếng Anh.

Một điểm nổi bật quan trọng là những thay đổi mà chúng tôi đã thực hiện để gói và gạch nối, vì một số ngôn ngữ yêu cầu các quy tắc khác nhau để ngắt dòng, tùy thuộc vào ngữ cảnh văn bản.

Ví dụ, trong cách sắp chữ truyền thống cho tiếng Hàn, nội dung văn bản có thể có dấu ngắt dòng ở giữa từ, nhưng văn bản tiêu đề sẽ chỉ quấn ở ranh giới từ.

Phá vỡ các từ trong tiêu đề có thể cảm thấy chói tai trong tiếng Hàn.

Trong tờ này từ Maps, từ tiếng Hàn có nghĩa là "thời gian" được chia thành hai dòng.

macOS Sonoma bây giờ sẽ thực hiện ngắt dòng khác nhau tùy thuộc vào phông chữ kiểu văn bản được sử dụng.

Trong tiếng Hàn, các kiểu văn bản tiêu đề và Tiêu đề như trong trang tính này sẽ không bao bọc ở ranh giới từ.

Trong khi kiểu văn bản nội dung có thể bị ngắt dòng trong các từ nếu thích hợp.

Đây là một ví dụ khác.

Trong bố cục hẹp, một số từ tiếng Đức có thể dài hơn toàn bộ chiều rộng dòng, điều này có thể khiến các ký tự riêng lẻ tràn sang dòng tiếp theo.

Gói này không lý tưởng.

Nó trông không cân bằng, và có một thành phần của từ - được gọi là hình thái - đang được phân chia theo các dòng.

Trong macOS Sonoma, nếu bạn có trường văn bản tiêu đề bị vô hiệu hóa dấu gạch nối, macOS sẽ tự động gạch nối văn bản ở ranh giới hình thái thay vì gói ký tự.

Bố cục kết quả cân bằng hơn và dễ đọc hơn.

Đây là thời điểm tuyệt vời để áp dụng các kiểu văn bản trong ứng dụng của bạn.

Trong macOS Sonoma, AppKit đã được cập nhật để giúp dễ dàng áp dụng các tính năng Swift đầu tiên như Swift đồng thời và có thể chuyển nhượng.

SwiftUI cũng đã được cập nhật để cho phép bạn sử dụng chế độ xem SwiftUI và công cụ sửa đổi ở nhiều nơi hơn trong ứng dụng AppKit của bạn.

Phần lớn các lớp AppKit bị giới hạn trong chuỗi chính.

Trong Swift concurrency, các lớp này được đánh dấu là tác nhân chính để tạo ra các lỗi trình biên dịch thích hợp.

Tuy nhiên, có một số lớp nhất định trong AppKit như NSColor và NSShadow có thể được truy cập an toàn bên ngoài chuỗi chính.

Trong macOS Sonoma, các lớp này phù hợp với giao thức Sendable, điều này chỉ ra rằng chúng có thể được chuyển tự do qua các ranh giới diễn viên.

Transferable là một giao thức Swift để mô tả cách các đối tượng có thể được tuần tự hóa và hủy nối tiếp.

Điều này cung cấp các tính năng như Kéo và Thả và Chia sẻ trong SwiftUI.

Trong macOS Sonoma NSImage, NSColor và NSSound phù hợp với giao thức Transferable.

Điều này giúp các ứng dụng AppKit dễ dàng áp dụng các tính năng như Kéo và Thả hoặc Chia sẻ trong Chế độ xem SwiftUI.

Trong macOS Ventura 13.3, chúng tôi đã giới thiệu một trình bao bọc thuộc tính mới cho NSViewController, ViewLoading.

Sử dụng ViewLoading trên các thuộc tính được khởi tạo trong loadView.

Nếu các thuộc tính này trước đây là tùy chọn, bạn có thể xóa tùy chọn và bất kỳ kiểm tra liên quan nào.

Bộ điều khiển chế độ xem sẽ đảm bảo rằng thuộc tính được khởi tạo bằng cách gọi loadViewIfNeeded.

Một trình bao bọc tài sản tương tự, WindowLoading, cũng có sẵn cho các tài sản trên NSWindowController.

Với Xcode 15, giờ đây bạn có thể sử dụng Bản xem trước để hiển thị chế độ xem AppKit và bộ điều khiển chế độ xem của mình.

Sử dụng macro Xem trước mới, cung cấp tên và trả lại chế độ xem hoặc bộ điều khiển chế độ xem của bạn.

Bản xem trước sẽ luôn được cập nhật khi bạn thực hiện các thay đổi đối với mã của mình.

Xem video "Xây dựng giao diện người dùng có lập trình với Bản xem trước Xcode" để biết thêm thông tin.

NSHostingView và NSHostingController là một cách tuyệt vời để dần dần áp dụng SwiftUI vào ứng dụng AppKit của bạn.

Trong macOS Sonoma, có một số tính năng mới cho phép bạn áp dụng SwiftUI ở nhiều nơi hơn.

Các công cụ sửa đổi SwiftUI như thanh công cụ và tiêu đề điều hướng hiện hoạt động trên NSWindows.

Nếu hostingView là contentView của cửa sổ, SwiftUI sẽ tự động kết nối tất cả các công cụ sửa đổi cảnh có sẵn với NSWindow của bạn.

Để kiểm soát nhiều hơn, có một thuộc tính mới trên NSHostingView và NSHostingController, sceneBridgingOptions.

Sử dụng điều này, bạn có thể nêu rõ những thuộc tính nào nên được bắc cầu từ chế độ xem SwiftUI của bạn đến NSWindow.

Đó chỉ là một số tính năng mới cho AppKit trong macOS Sonoma.

Tiếp theo là gì?

Đầu tiên, biên dịch các ứng dụng của bạn bằng cách sử dụng macOS Sonoma SDK và kiểm tra nó để đảm bảo rằng những thay đổi đối với việc cắt và kích hoạt không gây ra bất kỳ tác dụng phụ không mong muốn nào.

Tiếp theo, áp dụng API điều khiển mới, như trình kiểm tra chiều cao đầy đủ mới và API tùy chỉnh cột bảng mới.

Cập nhật thiết kế ứng dụng của bạn để tận dụng các hiệu ứng biểu tượng trong macOS Sonoma.

Và cuối cùng, sử dụng các bổ sung AppKit tập trung vào Swift mới, như Transferable và cải tiến cho NSHostingView, để áp dụng SwiftUI ở nhiều nơi hơn trong ứng dụng của bạn.

Cảm ơn rất nhiều vì đã xem.

Chúng tôi hy vọng bạn thích tất cả các tính năng mới của macOS Sonoma!

♪ ♪