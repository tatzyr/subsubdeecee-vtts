10154

Julia: Xin chào! Tên tôi là Julia.

Tôi là một Kỹ sư SwiftUI.

Gần đây, chúng tôi đã giới thiệu SwiftData, một cách mới để duy trì lớp mô hình của bạn trong Swift.

Trong phiên hôm nay, hãy xem cách tích hợp liền mạch SwiftData trong ứng dụng SwiftUI. Chúng ta sẽ thảo luận về các tính năng SwiftUI mới cho phép tích hợp trơn tru với các mô hình SwiftData.

Để đề cập đến những điều cơ bản của bạn, hãy xem phiên "Gặp gỡ SwiftData" trước nếu bạn chưa có.

Để xem SwiftData và SwiftUI chơi cùng nhau như thế nào, hãy xây dựng một ứng dụng flashcards.

Trong một thời gian, tôi đã muốn tạo ra một công cụ có thể giúp tôi nhớ ngày tháng và tác giả của những phát minh tuyệt vời, và SwiftData hoàn hảo cho nhiệm vụ này.

Nó sẽ giúp duy trì các bộ bài flashcard, vì vậy tôi có thể mở và nhấp qua chúng bất cứ khi nào tôi có một phút.

Tôi muốn ứng dụng này hoạt động ở mọi nơi: trên Mac, iPhone, Đồng hồ và TV, và SwiftData hỗ trợ tôi.

Nó có sẵn trên tất cả các nền tảng.

Đây là một mã-cùng.

Trong phiên này, tôi sẽ xây dựng một ứng dụng với bạn.

Nhấn tạm dừng ngay bây giờ và tải xuống các dự án Xcode đồng hành: một kho lưu trữ với điểm bắt đầu đã chuẩn bị và điểm đã hoàn thành.

Mở dự án khởi động và chuyển đến tệp ContentView.

Trong suốt phiên này, chúng tôi sẽ tận dụng một tính năng Xcode mới, Bản xem trước trực tiếp tương tác được nhúng cho Mac.

Trong phần Xem trước, có một lưới với một số thẻ nhớ.

Một cú nhấp chuột vào bất kỳ thẻ nào chuyển sang chế độ xem nơi chúng ta có thể cuộn từng thẻ một.

Bạn có nhớ ai đã phát minh ra trình biên dịch không?

Nhấp vào thẻ. Nó lật và đưa ra câu trả lời!

Ứng dụng được điền với các thẻ mẫu được lưu trữ trong bộ nhớ và nếu chúng tôi chạy ứng dụng và thêm các thẻ mới, chúng sẽ biến mất khi chúng tôi đóng ứng dụng.

Đây là nơi SwiftData xuất hiện.

Chúng tôi sẽ sử dụng nó để duy trì các thẻ ghi nhớ mà chúng tôi tạo ra.

Hôm nay, chúng ta sẽ nói về mọi thứ bạn cần biết để bắt đầu sử dụng SwiftData, kiểm tra hết mục này đến mục khác trong danh sách việc cần làm này mà tôi đã tổng hợp cho chúng tôi.

Bạn vừa gặp ứng dụng mà chúng tôi sẽ xây dựng.

Tiếp theo, chúng ta sẽ xem xét dự án khởi động và lớp mô hình của nó.

Sau đó, từng bước một, chúng tôi sẽ chuyển đổi và sửa đổi nó để sử dụng SwiftData làm nơi lưu trữ.

Chúng ta sẽ học cách mở rộng lớp mô hình để trở thành mô hình SwiftData, cách truy vấn dữ liệu và cập nhật chế độ xem trên mọi thay đổi trong lớp mô hình, tạo và lưu mô hình và liên kết các phần tử giao diện người dùng với chúng một cách thuận tiện.

Và cuối cùng, như một phần thưởng, chúng ta sẽ thấy việc tạo một ứng dụng dựa trên tài liệu dễ dàng như thế nào khi SwiftData đảm nhận việc lưu trữ.

Trong dự án khởi động, tôi đã xác định một mô hình Thẻ đại diện cho một thẻ flash duy nhất, một số chế độ xem và các tệp hỗ trợ để tiết kiệm thời gian của chúng tôi.

Mỗi thẻ lưu trữ văn bản cho mặt trước và mặt sau và ngày tạo.

Nó là một mô hình khá điển hình.

Hãy cập nhật nó để SwiftData có thể lưu trữ nó cho chúng tôi.

Đầu tiên, nhập SwiftData vào tệp này.

Và tiếp theo, thay đổi chính mà chúng ta cần thực hiện là thêm macro @Model vào định nghĩa.

Và bây giờ, lớp học hoàn toàn có thể tồn tại với SwiftData.

Không đánh máy nữa. Thế là xong!

Và thậm chí nhiều hơn: với @Model, Thẻ có được sự phù hợp với giao thức Observable và chúng tôi sẽ sử dụng nó thay vì ObservableObject.

Loại bỏ sự phù hợp với đối tượng Observable cũng như các trình bao bọc thuộc tính @Published.

Trước đây chúng tôi đã sử dụng tuân thủ ObservedObject để chỉnh sửa thẻ trực tiếp từ giao diện người dùng trong tệp CardEditorView.

Để áp dụng Observable ở đây, chúng tôi thay thế trình bao bọc thuộc tính "ObservedObject" bằng "Bindable".

Nó cho phép các trường văn bản liên kết trực tiếp với mặt trước của thẻ...

Và văn bản ngược.

Xong rồi!

Trình bao bọc thuộc tính Observable macro và Bindable mới cho phép dễ dàng thiết lập luồng dữ liệu trong một ứng dụng với ít mã hơn trước.

Khi một Chế độ xem sử dụng một thuộc tính thuộc loại Observable trong phần thân của nó, nó sẽ được cập nhật tự động khi thuộc tính đã cho thay đổi.

Và chưa bao giờ dễ dàng đến thế để liên kết trạng thái có thể thay đổi của mô hình với các phần tử giao diện người dùng!

Tôi khuyến khích bạn xem phiên WWDC23, "Khám phá Quan sát với SwiftUI."

Bạn sẽ ngạc nhiên về cách Observable đơn giản hóa mã luồng dữ liệu có hoặc không có SwiftData.

Và đó là tất cả những gì bạn cần biết về các mô hình.

Không có gì hơn. Điều đó tuyệt làm sao?

Tiếp theo, để truy vấn các mô hình từ SwiftData và hiển thị chúng trong giao diện người dùng, hãy chuyển sang ContentView.

Thay vì SampleDeck.contents, chúng tôi sẽ hiển thị các thẻ mà SwiftData có.

Và có một thay đổi duy nhất mà tôi cần thực hiện để liên kết mảng thẻ với bộ lưu trữ SwiftData: thay thế trình bao bọc thuộc tính @State bằng @Query.

Thế là xong!

Như chúng ta có thể thấy trong bản xem trước, không còn thẻ nào để hiển thị nữa, có lẽ vì chúng tôi chưa lưu bất kỳ thẻ nào.

Sử dụng @Query bất cứ khi nào bạn muốn hiển thị các mô hình, được quản lý bởi SwiftData, trong giao diện người dùng.

@Query là một trình bao bọc thuộc tính mới truy vấn các mô hình từ SwiftData.

Nó cũng kích hoạt chế độ xem được cập nhật trên mọi thay đổi của các mô hình, tương tự như cách @State sẽ làm điều đó.

Mỗi chế độ xem có thể có bao nhiêu thuộc tính được truy vấn tùy thích.

Truy vấn cung cấp cú pháp nhẹ để định cấu hình sắp xếp, sắp xếp, lọc và thậm chí tạo hoạt ảnh cho các thay đổi.

Dưới mui xe, nó sử dụng bối cảnh mô hình của chế độ xem làm nguồn dữ liệu.

Làm thế nào để chúng tôi cung cấp @Query một bối cảnh mô hình?

Chúng tôi sẽ lấy một cái từ một thùng chứa mô hình.

SwiftUI cung cấp một công cụ sửa đổi chế độ xem và cảnh mới để thiết lập thuận tiện ModelContainer của chế độ xem.

Để sử dụng SwiftData, bất kỳ ứng dụng nào cũng phải thiết lập ít nhất một ModelContainer.

Nó tạo ra toàn bộ ngăn xếp lưu trữ, bao gồm cả ngữ cảnh mà @Query sẽ sử dụng.

Một chế độ xem có một vùng chứa mô hình duy nhất, nhưng một ứng dụng có thể tạo và sử dụng bao nhiêu vùng chứa tùy thích cho các hệ thống phân cấp chế độ xem khác nhau.

Nếu ứng dụng không thiết lập modelContainer của nó, các cửa sổ và chế độ xem mà nó tạo ra không thể lưu hoặc truy vấn các mô hình thông qua SwiftData.

Nhiều ứng dụng cần một bộ chứa mô hình duy nhất.

Trong trường hợp này, bạn có thể thiết lập nó cho toàn bộ cảnh nhóm cửa sổ.

Cửa sổ và chế độ xem của nó sẽ kế thừa vùng chứa, cũng như bất kỳ cửa sổ nào khác được tạo từ cùng một nhóm.

Tất cả các chế độ xem này sẽ được viết và đọc từ một vùng chứa duy nhất.

Một số ứng dụng cần một vài ngăn xếp lưu trữ và chúng có thể thiết lập một số vùng chứa mô hình cho các cửa sổ khác nhau.

SwiftUI cũng cho phép thiết lập chi tiết ở cấp độ xem.

Các chế độ xem khác nhau trong cùng một cửa sổ có thể có các vùng chứa riêng biệt và việc lưu trong một vùng chứa sẽ không ảnh hưởng đến vùng chứa khác.

Bây giờ, hãy thiết lập modelContainer để cung cấp Truy vấn một nguồn dữ liệu.

Tôi mở định nghĩa ứng dụng...

Và thiết lập một vùng chứa mô hình cho các cửa sổ của ứng dụng.

Lưu ý rằng các chế độ xem phụ chỉ có thể tạo, đọc, cập nhật và xóa các loại mô hình được liệt kê trong công cụ sửa đổi chế độ xem.

Và chúng tôi đã hoàn thành việc thiết lập!

Mặc dù vậy, tôi muốn thực hiện thêm một bước nữa: cung cấp các bản xem trước của tôi với dữ liệu mẫu.

Trong ứng dụng, tôi đã xác định một thùng chứa trong bộ nhớ với các thẻ mẫu.

Hãy mở tệp "PreviewSampleData" và đưa nó vào mục tiêu.

Tệp này chứa định nghĩa của một vùng chứa với dữ liệu mẫu.

Tôi sẽ sử dụng nó trong ContentView để điền vào bản xem trước của mình bằng các thẻ mẫu.

Bây giờ @Query có nguồn dữ liệu, bản xem trước sẽ hiển thị các thẻ!

Và đây là tất cả các thiết lập được yêu cầu để sẵn sàng ngăn xếp SwiftData và tạo bản xem trước.

Tiếp theo, tôi muốn đảm bảo rằng SwiftData theo dõi và lưu các thẻ mới mà tôi tạo, cũng như các thay đổi được thực hiện đối với các thẻ hiện có.

Để làm điều đó, tôi sẽ sử dụng bối cảnh mô hình của chế độ xem.

Để truy cập bối cảnh mô hình, SwiftUI cung cấp một biến môi trường mới.

Tương tự như vùng chứa mô hình, mỗi chế độ xem có một ngữ cảnh duy nhất, nhưng một ứng dụng, nói chung, có thể có bao nhiêu tùy thích.

Trong ứng dụng của chúng tôi, ngữ cảnh đã được định cấu hình.

Biến môi trường này được điền tự động khi chúng tôi đặt vùng chứa mô hình trước đó.

Hãy chuyển trở lại Xcode.

Chúng tôi sẽ cần truy cập modelContext để lưu và cập nhật các thẻ.

Chúng tôi chèn thẻ mới được tạo vào ngữ cảnh mô hình để SwiftData nhận thức được mô hình mà chúng tôi muốn lưu trữ.

Bạn có thể nghĩ rằng sau khi chèn mô hình, bạn cần lưu ngữ cảnh, gọi "modelContext.save()," nhưng bạn không cần phải làm điều đó.

Một chi tiết hay về SwiftData là nó tự động lưu bối cảnh mô hình.

Việc lưu tự động được kích hoạt bởi các sự kiện liên quan đến giao diện người dùng và đầu vào của người dùng.

Chúng tôi không cần phải lo lắng về việc tiết kiệm vì SwiftData làm điều đó cho chúng tôi.

Chỉ có một vài trường hợp khi bạn muốn đảm bảo rằng tất cả các thay đổi được duy trì ngay lập tức, ví dụ, trước khi chia sẻ bộ nhớ SwiftData hoặc gửi nó qua.

Trong những trường hợp này, hãy gọi "lưu()" một cách rõ ràng.

Bây giờ ứng dụng của chúng tôi có thể lưu và truy vấn các thẻ, hãy tạo một thẻ!

Tôi chạy ứng dụng...

Và nhấn nút dấu cộng để tạo một thẻ.

Hãy thêm thẻ Trình biên dịch mà chúng ta đã thấy trước đây.

Bây giờ, hãy thoát khỏi ứng dụng, khởi chạy lại và xem thẻ mới của chúng ta có ở đó không.

Và nó đây rồi!

Bây giờ bạn đã biết cách truy cập bối cảnh mô hình của chế độ xem và thêm thẻ.

Xong rồi!

Hãy mở một cửa sổ mới.

Nó hiển thị cùng một bộ bài như bộ đầu tiên, điều này có ý nghĩa, vì cả hai cửa sổ đều sử dụng cùng một vùng chứa mô hình và truy cập cùng một dữ liệu.

Tuy nhiên, sẽ thật tuyệt nếu ứng dụng có thể mở các bộ thẻ flash khác nhau trong các cửa sổ khác nhau.

Về cơ bản, nó có nghĩa là tôi muốn coi mỗi bộ bài như một tài liệu riêng biệt.

Sau đó, tôi có thể chia sẻ những tài liệu này với bạn bè.

Các ứng dụng dựa trên tài liệu là một khái niệm được sử dụng trên macOS, iOS và iPadOS.

Nó mô tả các loại ứng dụng nhất định cho phép người dùng tạo, mở, xem hoặc chỉnh sửa các loại tài liệu khác nhau.

Mỗi tài liệu là một tệp và người dùng có thể lưu trữ, sao chép và chia sẻ chúng.

Và tôi rất vui được cho bạn biết rằng SwiftUI hỗ trợ các ứng dụng tài liệu được hỗ trợ bởi SwiftData.

Hãy thử cách tiếp cận này.

Tôi mở tệp FlashCardApp.

Các ứng dụng dựa trên tài liệu tồn tại trên iOS và macOS, và trên các nền tảng này, chúng tôi sẽ chuyển sang sử dụng trình khởi tạo DocumentGroup.

Tôi sẽ chuyển loại mô hình Card.self, loại nội dung và trình tạo chế độ xem.

Hãy đi đường vòng ngắn và nói về tham số thứ hai, loại nội dung, chi tiết hơn!

Các ứng dụng dựa trên Tài liệu SwiftData cần khai báo các loại nội dung tùy chỉnh.

Mỗi tài liệu SwiftData được xây dựng từ một tập hợp các mô hình duy nhất và do đó có một biểu diễn duy nhất trên đĩa.

Trong bối cảnh của các tài liệu, bạn có thể nghĩ về một loại nội dung như một định dạng tệp nhị phân, như JPEG.

Một loại tài liệu khác, một gói, là một thư mục có cấu trúc cố định trên đĩa, giống như một dự án Xcode.

Ví dụ, tất cả các hình ảnh JPEG đều có cùng cấu trúc nhị phân.

Nếu không, các biên tập viên ảnh sẽ không biết cách đọc chúng.

Tương tự, tất cả các dự án Xcode đều chứa các thư mục và tệp nhất định.

Khi người dùng mở bộ bài, chúng tôi cần hệ điều hành để liên kết định dạng bộ bài và phần mở rộng tệp với ứng dụng của chúng tôi.

Đó là lý do tại sao chúng ta cần khai báo loại nội dung.

Tài liệu SwiftData là các gói: nếu bạn đánh dấu một số thuộc tính của mô hình SwiftData bằng thuộc tính "externalStorage", tất cả các mục được lưu trữ bên ngoài sẽ là một phần của gói tài liệu.

Trong tệp UTType+FlashCards, tôi có định nghĩa về loại nội dung mới, vì vậy chúng tôi có thể sử dụng nó một cách thuận tiện trong mã.

Chúng tôi sẽ đưa định nghĩa tương tự vào Info.plist.

Chúng tôi sắp khai báo một loại nội dung mới trong hệ điều hành.

Chúng tôi cần chỉ định phần mở rộng tệp để giúp phân biệt các bộ bài do ứng dụng của chúng tôi tạo ra với bất kỳ tài liệu nào khác.

Đối với ứng dụng mẫu này, chúng tôi sẽ sử dụng "sampledeck" làm tiện ích mở rộng.

Tôi cũng sẽ thêm một mô tả ngắn, như Flash Cards Deck.

Mã định danh phải giống hệt với mã trong mã.

Bởi vì tài liệu SwiftData là các gói, chúng tôi phải đảm bảo loại của chúng tôi phù hợp với com.apple.package.

Và bây giờ, hãy sử dụng loại nội dung mà chúng tôi đã khai báo.

Tôi đang quay lại định nghĩa ứng dụng và chuyển loại nội dung cho DocumentGroup.

Trình tạo chế độ xem trông giống hệt nhau.

Đáng chú ý, chúng tôi không thiết lập thùng chứa mô hình.

Cơ sở hạ tầng tài liệu sẽ thiết lập một cho mỗi tài liệu.

Hãy chạy ứng dụng và xem nó trông như thế nào ngay bây giờ!

Ứng dụng khởi chạy với bảng điều khiển mở.

Hành vi tiêu chuẩn cho các ứng dụng dựa trên Tài liệu.

Tôi sẽ tạo một tài liệu mới và thêm một thẻ ở đó.

Tài liệu hiện có phụ đề thanh công cụ cho biết rằng nó có những thay đổi chưa được lưu.

Tôi nhấn Command+S, và hộp thoại lưu xuất hiện.

Lưu ý rằng bộ bài sẽ được lưu với cùng phần mở rộng tệp mà chúng tôi đã đưa vào Info.plist trước đó.

Tôi sẽ lưu bộ bài mới, và đây rồi, bộ bài flashcards đầu tiên của tôi, trên Máy tính để bàn.

Tôi cũng có thể nhấn Command+N để tạo một bộ bài mới, hoặc Command+O để mở một bộ bài.

Các phím tắt này, cũng như nhiều tính năng khác, các ứng dụng dựa trên Tài liệu sẽ tự động nhận được.

Tóm lại, hôm nay, chúng ta đã học cách sử dụng lưu trữ SwiftData trong các ứng dụng SwiftUI.

Chúng tôi đã nói về macro @Model mới, trình bao bọc thuộc tính @Query và biến Môi trường mới cho ngữ cảnh mô hình và thấy việc sử dụng SwiftData làm bộ lưu trữ cho tài liệu của bạn dễ dàng như thế nào.

Cảm ơn vì đã tham gia cùng tôi hôm nay, và vui vẻ xây dựng các ứng dụng!

♪ ♪