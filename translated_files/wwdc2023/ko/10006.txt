10006

♪ ♪

조나단: 안녕하세요, 저는 조나단이고, 인터넷 기술 팀의 엔지니어입니다.

오늘 우리는 URLSession을 사용하여 강력하고 재개 가능한 파일 전송을 구축하는 방법을 살펴볼 것입니다.

큰 파일 전송은 작은 중단이라도 사용자의 모든 진행 상황을 버리고 처음부터 시작하도록 강요할 수 있기 때문에 큰 도전이 될 수 있습니다.

게다가, 전송이 클수록, 더 오래 걸리고, 더 오래 걸릴수록, 무언가 잘못될 수 있는 더 많은 기회가 있다.

그 시간 동안, 사용자는 앱에서 벗어나거나, Wi-Fi 범위를 벗어나거나, 통제할 수 없는 많은 네트워크 문제 중 하나를 경험할 수 있습니다.

이 세션에서, 우리는 이러한 문제를 해결하고 사용자에게 강력한 네트워킹 경험을 제공하는 방법을 탐구할 것입니다.

우리의 첫 번째 중지는 연결이 중단될 때 사용자가 진행 상황을 유지할 수 있도록 하는 재개 가능한 HTTP 프로토콜입니다.

이것은 시간과 대역폭을 낭비하는 것을 방지하여, 이러한 프로토콜을 많은 양의 데이터를 전송할 때 강력한 도구로 만든다.

재개 가능한 업로드 작업을 위한 새로운 API를 포함하여 URLSession에서 다운로드와 업로드를 모두 재개하는 방법을 시연할 것입니다.

이러한 API의 메커니즘을 이해하는 것은 앱을 디버깅하거나 자체 서버 지원을 구축하는 데 정말 도움이 될 수 있습니다.

그렇기 때문에 우리는 재개 가능한 프로토콜 자체도 다룰 것이므로, 앱과 서버가 HTTP를 통해 이를 어떻게 달성하는지 정확히 알 수 있습니다.

다음으로, 서버에 대해 말하자면, SwiftNIO를 사용하는 모든 서버에 재개 가능한 업로드 지원을 제공하는 방법을 배우게 될 것입니다.

그리고 마지막으로, 우리는 백그라운드 URLSessions가 시스템 리소스를 효율적으로 사용하면서 사용자와 네트워크 중단을 어떻게 우아하게 처리할 수 있는지 검토할 것입니다.

URLSession에서 다운로드 및 업로드 재개에 대해 자세히 알아봅시다.

그래서 저는 최신 Xcode를 다운로드하고 있으며, 7기가바이트 다운로드가 거의 완료되었습니다.

바로 마지막에, 내 와이파이가 꺼진다.

하지만 잠시만요, 다운로드가 일시 중지되고, Wi-Fi가 온라인으로 돌아오면, 중단된 곳에서 다운로드를 재개할 수 있습니다.

나는 방금 많은 시간과 몇 번의 대역폭을 절약했다.

재개 가능한 다운로드는 놀랍다.

하지만 그들은 어떻게 작동하나요?

먼저, 클라이언트는 서버에서 다운로드를 검색하기 위해 GET 요청을 보냅니다.

응답에서, 서버는 Accept-Ranges 헤더를 사용하여 재개 가능한 다운로드에 대한 지원을 광고합니다.

Accept-Ranges: 바이트는 서버가 이 리소스의 특정 바이트에 대한 범위 요청을 지원한다는 것을 의미합니다.

서버 응답에는 현재 리소스를 고유하게 식별하는 ETag라고 불리는 것도 포함되어 있습니다.

서버의 콘텐츠가 변경되면, ETag도 변경됩니다.

그래서 이 다운로드가 중단되면 어떻게 되나요?

클라이언트는 부분 다운로드 데이터를 저장했기 때문에, 마지막 부분만 있으면 됩니다.

이를 달성하기 위해, 다운로드의 누락된 바이트를 검색하기 위한 범위 요청을 보낼 수 있습니다.

요청은 범위 필드를 사용하는 바이트를 나타냅니다.

하지만 클라이언트는 또한 리소스가 변경되지 않았는지 확인해야 합니다. 그렇지 않으면 새 리소스의 데이터를 저장된 이전 리소스에 추가할 수 있습니다.

이를 방지하기 위해, If-Range 필드에는 이전 응답에서 받은 ETag가 포함되어 있으며, ETag가 동일한 경우에만 부분 데이터를 보내도록 서버에 알려줍니다.

ETag가 동일하다면, 서버는 206개의 부분 콘텐츠로 응답합니다.

여기에 있는 Content-Range 필드는 이 응답에 포함된 바이트 범위를 나타내며, 다운로드를 완료합니다.

처음부터 URLSession은 Range 요청을 사용하여 다운로드 작업을 일시 중지하고 재개하는 API를 제공했습니다.

이제 업로드를 일시 중지하고 재개할 수도 있습니다.

이를 통해 진행 중인 작업을 수동으로 일시 중지할 수 있을 뿐만 아니라, 오류 처리를 수행하여 예상치 못한 연결 문제에서 복구하고 중단된 곳에서 바로 전송을 재개할 수 있습니다.

먼저 이것이 다운로드를 위해 어떻게 작동하는지 검토해 봅시다.

사용자가 수동으로 다운로드를 일시 중지하고 재개할 수 있는 UI를 만들고 있다고 상상해 보세요.

사파리 예제와 마찬가지로, 앱은 이 UI를 소유하지만, 후드 아래에서 URLSession을 사용하여 부분 다운로드 데이터, ETag 및 요청 헤더를 추적하는 것과 같은 모든 세부 사항을 처리할 수 있습니다.

다운로드를 시작하려면, 평소와 같이 다운로드 작업을 만들고, 이력서를 호출하여 시작하세요.

사용자가 일시 정지 버튼을 탭할 때와 같이 다운로드를 일시 중지하려면 cancelByProducingResumeData를 호출할 수 있습니다.

나중에 이 다운로드를 재개하려면, URLSession은 ETag, 현재 크기 및 디스크의 위치와 같은 부분 다운로드에 대한 정보가 필요합니다.

이것과 다른 메타데이터는 이 함수에서 반환된 이력서 데이터 객체에 편리하게 저장됩니다.

다시 말하지만, 이 이력서 데이터는 부분 다운로드 데이터가 아니라는 점에 유의하는 것이 중요합니다.

이력서 데이터가 0이면, 이는 재개 가능한 다운로드에 대한 하나 이상의 요구 사항이 충족되지 않는다는 것을 의미하며, 곧 다룰 것입니다.

반면에, 이력서 데이터가 0이 아니라면, 나중에 사용할 수 있도록 저장해야 합니다.

사용자가 이력서 버튼을 탭할 때와 같이 다운로드를 재개하려면 이 저장된 데이터를 downloadTask withResumeData 메소드에 전달하기 때문입니다.

그건 그렇게 간단해!

이 패턴은 수동으로 다운로드를 일시 중지하는 데 좋지만, URLSession은 예측되지 않은 연결 중단으로부터 복구하는 방법도 제공합니다.

네트워크 문제로 인해 다운로드 작업이 실패하면, 오류 자체에서 이력서 데이터를 확인할 수 있습니다.

다운로드를 재개할 수 있다면, 오류의 userInfo 사전에는 그 재개 데이터가 포함될 것이다.

URLError의 downloadTaskResumeData 속성을 사용하여 이 데이터에 편리하게 액세스할 수 있습니다.

URLSession에는 재개 가능한 다운로드에 대한 몇 가지 요구 사항이 있습니다.

다운로드는 본질적으로 데이터를 가져오고, 반복하는 것이 안전해야 하므로, URLSession은 다운로드 작업에 HTTP GET 요청이 필요합니다.

다른 계획이나 방법은 지원되지 않습니다.

다음으로, 서버는 바이트 범위 요청을 지원하고 Accept-Ranges 헤더를 사용하여 이를 광고해야 합니다.

서버는 응답의 리소스에 대해 ETag 또는 Last-Modified 필드를 제공해야 하지만, ETag가 선호됩니다.

그리고 마지막으로, 임시 다운로드 파일은 디스크 공간 압력에 대응하여 시스템에 의해 삭제되어서는 안 됩니다.

이러한 요구 사항을 충족하면 수동으로 다운로드를 일시 중지하고 재개하거나 연결 중단에서 복구할 수 있습니다.

재개 프로토콜이 없으면, 작은 중단이라도 처음부터 전송을 다시 시작해야 합니다.

이것은 업로드에 대한 훨씬 더 큰 문제이다.

업로드 속도는 종종 다운로드 속도보다 훨씬 느리기 때문에, 다시 시작하는 것은 더 많은 시간과 자원을 잃는 것을 의미합니다.

iOS 17은 재개 가능한 업로드 작업에 대한 새로운 지원을 소개합니다.

이것들이 정말 기대돼.

이제 서버가 최신 프로토콜 초안을 지원하는 경우 업로드 작업을 자동으로 재개할 수 있습니다.

먼저 새로운 API를 살펴본 다음, 재개 가능한 업로드 프로토콜의 세부 사항을 살펴봅시다.

다운로드 작업과 마찬가지로, 업로드 작업을 만들고 이력서를 호출하여 시작하세요.

일시 중지하려면, 업로드 작업은 이제 다운로드 작업과 동일한 cancelByProducingResumeData 방법을 지원합니다.

이 작업은 서버가 최신 재개 가능한 업로드 프로토콜을 지원하는지 자동으로 감지합니다.

서버가 그것을 지원한다면, 나중에 사용할 수 있도록 이력서 데이터를 저장할 수 있습니다.

그리고 마지막으로, 일시 중지된 업로드를 재개하려면, 새로운 uploadTask withResumeData 메소드를 사용하세요.

여기에 표시된 패턴이 다운로드 작업과 동일하다는 것을 알게 될 것입니다.

즉, 앱에서 다운로드를 일시 중지하고 재개할 수 있는 훌륭한 경험을 이미 만들었다면, 사용자를 위한 재개 가능한 업로드도 쉽게 구현할 수 있습니다.

일시적인 네트워크 중단이 있지만 서버에 여전히 연결할 수 있는 경우, URLSession은 자동으로 업로드를 재개하려고 시도합니다.

추가 코드가 필요하지 않습니다.

하지만 네트워크나 서버가 완전히 다운되는 경우와 같은 다른 광범위한 연결 문제의 경우, 다운로드 작업과 마찬가지로 재개 데이터에 대한 오류를 확인할 수 있습니다.

URLSession에서 재개 가능한 업로드를 보게 되어 매우 기쁘고, 당신도 그들을 사랑하기를 바랍니다.

하지만 이 기능을 활용하려면, 서버는 최신 재개 가능한 업로드 프로토콜도 지원해야 합니다.

이 프로토콜은 현재 개발 중이며, IETF에서 이를 표준화하기 위한 업계 전반에 걸친 노력이 있다.

프로토콜에서, 클라이언트는 자동으로 서버 지원을 발견할 수 있다.

이것은 URLSession이 첫 번째 요청에서 모든 업로드를 재개할 수 있도록 시도할 수 있다는 것을 의미합니다.

서버가 재개 가능한 업로드를 지원하지 않는 경우, 요청은 단순히 일반 업로드로 계속됩니다.

그것이 전선에서 어떻게 작동하는지 봅시다.

클라이언트는 먼저 업로드 엔드포인트에 요청을 보냅니다.

Upload-Incomplete 필드는 이 클라이언트가 재개 가능한 업로드를 지원한다는 것을 나타냅니다.

물음표 0은 구조화된 필드 부울로 알려진 것이며, 거짓 값을 나타낸다.

이것은 모든 업로드 데이터가 이 요청의 본문에 포함되어 있다는 것을 의미합니다.

서버가 재개 가능한 업로드를 지원하는 경우, 클라이언트의 헤더를 감지하고 104 정보 응답을 사용하여 자체 지원을 광고합니다.

104 응답에는 이력서 URL이 있는 위치 필드가 포함되어 있습니다.

이 이력서 URL은 업로드를 고유하게 식별하는 데 사용되므로, 클라이언트는 연결이 중단되면 업로드를 재개할 위치를 알고 있습니다.

서버는 수신한 업로드 데이터를 이 고유한 이력서 URL과 연결합니다.

업로드가 중단 없이 끝난다면, 좋습니다.

서버는 201을 보내고 완료되었습니다.

그러나, 업로드가 중단되면, 클라이언트와 서버는 재개 가능한 업로드 절차를 수행합니다.

서버는 이력서 URL에 대한 부분 업로드를 저장했지만, 클라이언트는 서버가 실제로 얼마나 많은 데이터를 얻었는지 결정할 방법이 필요합니다.

이를 위해, 클라이언트는 이력서 URL로 HEAD 요청을 보내 서버에 업로드 오프셋을 요청합니다.

이 오프셋은 서버가 받은 실제 바이트 수이다.

그런 다음 서버는 클라이언트의 특정 업로드에 대한 업로드 오프셋으로 응답합니다.

그리고 마지막으로, 클라이언트는 서버의 오프셋을 확인하고 나머지 데이터를 보내야 합니다.

이를 위해, 클라이언트는 일치하는 업로드 오프셋과 함께 이력서 URL로 PATCH 요청을 보냅니다.

이 요청의 본문에는 주어진 오프셋에서 시작하는 업로드 데이터가 포함되어 있습니다.

그것으로, 클라이언트는 마침내 모든 데이터를 서버로 보냈고, 업로드를 완료했다.

당신의 앱은 URLSession의 업로드 작업을 사용하여 이 모든 것을 무료로 받습니다.

이제, 서버 측으로 빠르게 가서 SwiftNIO로 자신만의 재개 가능한 업로드 서버를 구축하는 방법을 알아봅시다.

이미 서버에서 SwiftNIO를 사용하고 있는 사람들을 위해, 이 섹션은 당신을 위한 것입니다.

재개 가능한 업로드는 모든 서버에서 구현할 수 있지만, 서버가 이미 SwiftNIO를 사용하고 있다면, 지원을 정말 쉽게 추가할 수 있는 새로운 패키지가 있습니다.

간단한 예를 들어 봅시다.

익숙하지 않다면, SwiftNIO는 앱과 서버에서 작동하는 비동기 네트워크 애플리케이션 프레임워크입니다.

이 샘플 코드에서, 우리는 HTTP/2 서버를 설정하고 있습니다.

우리는 서버에 두 개의 핸들러를 추가했습니다.

코덱은 HTTP/2 프레임을 예제 핸들러가 이해할 수 있는 요청으로 변환합니다.

다른 방향으로, 그것은 예제 핸들러의 응답을 받아 HTTP/2 프레임으로 코딩한다.

ExampleChannelHandler는 우리 서버의 기본 라우팅과 논리를 수행합니다.

처음에는, 우리는 정기적인 업로드만 지원합니다.

재개 가능한 업로드를 지원하기 위해 서버를 변환하는 것이 얼마나 쉬운지 알아봅시다.

먼저, NIOResumableUpload 프로젝트를 다운로드하고, 종속성으로 추가하고, 코드로 가져옵니다.

그런 다음, 우리는 재개 가능한 업로드 컨텍스트를 정의합니다.

이것은 이력서 URL을 생성할 때 사용할 엔드포인트를 업로드하는 핸들러를 알려줍니다.

그리고 마지막으로, 우리는 현재 핸들러를 HTTPResumableUploadHandler로 래핑합니다.

이것은 우리의 현재 논리 위에 재개 가능한 업로드 절차를 수행합니다.

업로드할 때마다 무작위로 안전한 이력서 URL을 생성하고 이를 업로드 데이터와 연결합니다.

연결이 중단되면, 핸들러는 부분 데이터를 보유하고 우리를 위해 모든 재개 가능한 업로드 절차에 응답합니다.

와!

단 몇 줄의 코드로, 우리는 재개 가능한 업로드를 지원하기 위해 서버를 과급했습니다.

이미 서버에서 스위프트를 사용하고 있는 사람들을 위해, 이것을 시도해 보세요!

그리고 상관없이 모두를 위해, 설명의 링크에서 오픈 소스 샘플 코드를 확인하십시오.

샘플 코드는 또한 새로운 HTTP 유형을 사용하여 앱과 Swift on Server 프로젝트에서 동일한 유형을 사용할 수 있습니다.

이러한 데이터 유형은 SwiftNIO와 협력하여 오픈 소스 패키지로 출시되므로, Swift 블로그를 확인하여 자세히 알아보고 피드백을 제공하십시오.

재개 가능한 업로드 프로토콜이 104 상태 코드를 사용하여 정보 응답을 사용하는 것을 눈치챘을 것입니다.

새로운 HTTP 유형은 서버 측에서 이러한 응답을 쉽게 지원할 수 있게 해준다.

앱에서 URLSession은 재개 가능한 업로드를 위해 104개의 응답을 자동으로 처리합니다.

하지만 게다가, URLSession은 이제 대리자 메소드 didReceiveInformationalResponse를 제공합니다.

이를 통해 앱은 102 처리 또는 103 초기 힌트와 같은 다른 중간 응답을 처리할 수 있습니다.

재개 가능한 프로토콜은 네트워크 중단을 완화하고 대역폭을 절약할 수 있는 좋은 방법입니다.

백그라운드 URLSession은 대용량 파일 전송을 처리할 때도 유용할 수 있습니다.

사용자가 최신 스키 여행에서 거대한 4K 비디오를 업로드하고 싶다고 상상해 보세요.

연결이 중단되면, 가능하다면 업로드를 재개해야 합니다.

당신은 모든 오류를 스스로 처리할 수 있습니다.

또는, 당신은 배경 세션이 당신을 위해 그것을 하도록 할 수 있습니다.

사실, 백그라운드 세션은 서버가 지원하는 경우 다운로드 및 업로드 작업 모두에 대해 자동으로 재개를 처리합니다.

작업이 중단되면, 시스템은 증가하는 시간 간격으로 작업을 재개하려고 시도할 것이다.

작업을 재개할 수 없다면, 시스템은 처음부터 자동으로 작업을 다시 시도할 것이다.

사용자가 스키 산에서 셀 커버리지를 잃거나, 눈보라가 Wi-Fi를 꺼냈을 수도 있습니다.

백그라운드 세션은 항상 연결을 기다리므로, 장치가 인터넷에 다시 연결된 후 어느 시점에서 작업이 예약됩니다.

사용자가 비디오를 업로드하는 동안, 그들은 당신의 앱을 떠나거나 장치를 치울 수 있습니다.

아마도 그들은 더 많은 가루를 갈가리 찢을 준비를 하고 있고, 그들은 여전히 업로드가 계속될 것으로 예상한다.

이것은 특히 배경 세션을 요구한다.

백그라운드 작업은 시스템에 의해 예약되므로 앱 프로세스 외부에서 실행됩니다.

즉, 앱이 시스템에 의해 일시 중지되거나 종료되더라도 네트워크 작업이 안정적으로 계속됩니다.

시간이 오래 걸릴 수 있고 사용자가 앱을 떠날 때 지속해야 하는 대용량 파일 전송을 위해 백그라운드 세션을 사용하세요.

마지막으로, 사용자는 앱에 있을 때 최고의 경험을 할 자격이 있으며, 이는 나중에 덜 긴급한 작업을 예약하는 것을 의미할 수 있습니다.

백그라운드 세션을 사용하면 네트워크 활동을 효율적으로 예약하고 사용자를 위해 리소스를 저장할 수 있는 몇 가지 방법이 있습니다.

즉시 발생할 필요가 없는 작업의 경우, 백그라운드 구성에서 isDiscretionary 속성을 true로 설정하는 것을 고려하십시오.

이를 통해 시스템은 "사용자가 Wi-Fi에 있습니까", "장치가 전원에 연결되어 있습니까", "네트워크가 제한되어 있습니까"와 같은 요소를 고려하여 작업을 지능적으로 예약할 수 있습니다.

이것은 나중에 사용하기 위해 자산을 다운로드하거나 야간 백업 또는 분석을 업로드할 때 훌륭한 옵션이 될 수 있습니다.

낮은 데이터 모드에서 너무 많은 대역폭을 사용하지 않으려면, allowsConstrainedNetworkAccess 속성을 false로 설정하는 것을 고려하십시오.

앱에서 낮은 데이터 모드를 지원하는 방법에 대한 더 많은 팁을 보려면 네트워킹 세션의 발전을 확인하세요.

사람이 시스템 리소스를 사용할 가능성이 적을 때 나중에 시작하도록 백그라운드 작업 자체를 예약할 수도 있습니다.

늦은 밤은 종종 대규모 백업과 같은 작업을 예약하기에 좋은 시간이다.

시스템 스케줄링을 더 지원하기 위해, 우리는 countOfBytesClientExpectsToSend 및 Receive 속성을 설정할 수 있습니다.

이러한 속성을 활용함으로써, 당신은 시스템이 자원을 가장 잘 할당하고 그 혜택을 사용자에게 전달할 수 있도록 권한을 부여하고 있습니다.

백그라운드 세션은 즉시 발생할 필요가 없는 대용량 파일 전송이나 앱이 일시 중지될 때 계속되어야 하는 전송을 위한 훌륭한 도구입니다.

더 작은 작업이나 가능한 한 빨리 일어나야 하는 작업의 경우, 표준 URLSession을 사용할 수 있습니다.

앱에 재개의 힘을 가져와 사용자를 위해 네트워킹을 신뢰할 수 있게 만드세요.

SwiftNIO와 HTTP 유형을 확인하고, Swift에서 최고의 HTTP 경험을 만들기 위해 함께 일합시다.

그리고 마지막으로, 대규모 또는 임의 파일 전송을 위해 백그라운드 세션을 사용해 보세요.

사용자가 가장 필요로 할 때 자원을 절약할 수 있는 많은 방법을 찾을 수 있습니다.

시청해 주셔서 감사드리며, 아래의 다른 훌륭한 네트워킹 세션을 꼭 확인해 보세요.

그리고 그건 포장이야!

♪ ♪