10055

♪ ♪

디마: 안녕하세요, "iOS 17 UIKit의 새로운 기능"에 오신 것을 환영합니다.

저는 UIKit 팀의 엔지니어링 매니저인 Dima입니다.

애플리케이션의 강력한 프레임워크인 UIKit은 iOS 17의 새로운 기능을 지원하도록 업그레이드되었습니다.

이 비디오에서는 새로운 주요 기능과 핵심 아키텍처 개선, 언어 설정에 관계없이 모든 사용자를 위한 인터페이스 구축의 발전, iPadOS 앱의 개선, 릴리스에 포함된 수많은 일반적인 개선 사항을 안내할 것입니다.

우리는 UIKit에 주요 아키텍처 개선 사항을 도입하여 강력한 애플리케이션을 더 쉽게 만들 수 있을 뿐만 아니라 SwiftUI와의 통합을 획기적으로 개선했습니다.

5가지 주요 새로운 기능을 안내해 드리겠습니다.

Xcode 미리보기 지원, 컨트롤러 수명 주기 업데이트 보기, 특성 시스템의 발전, 애니메이션 기호 이미지 및 앱에서 빈 상태를 나타내는 새로운 API를 살펴볼 것입니다.

첫째, 큰 변화.

UIKit에서 직접 Xcode 미리보기를 사용할 수 있습니다.

이 기능을 활용하려면, 미리보기 매크로를 사용하여 미리보기의 이름을 지정하고 뷰 컨트롤러를 반환하십시오.

미리보기를 구성하고 데이터로 채우기 위해 뷰 컨트롤러의 속성을 설정할 수 있습니다.

뷰 컨트롤러 없이 UIViews를 직접 미리 볼 수도 있습니다.

미리보기는 UI 구성 요소를 시각화하고 코드를 반복할 때 즉각적인 피드백을 제공하는 데 도움이 됩니다.

그리고 앱이 생성되면, Xcode 미리보기는 다양한 구성과 설정에서 테스트를 가능하게 합니다.

다음으로, 뷰 컨트롤러를 제시하거나 내비게이션 컨트롤러를 누르거나 팝업할 때와 같이 외관 전환 중에 뷰 컨트롤러 수명 주기에 대한 중요한 개선 사항을 다루고 싶습니다.

viewIsAppearing이라는 이름의 새로운 뷰 컨트롤러 콜백이 있는데, 이는 viewWillAppear 이후 viewDidAppear 이전에 호출됩니다.

viewIsAppearing은 뷰가 나타날 때마다 일을 할 수 있는 최고의 장소입니다.

그것이 호출되면, 뷰 컨트롤러와 뷰 모두 최신 특성 컬렉션을 가지고 있다.

게다가, 그 뷰는 계층 구조에 추가되었고 슈퍼뷰에 의해 배치되었다.

이것은 viewIsAppearing을 크기를 포함하여 뷰의 초기 지오메트리에 따라 코드를 실행하기 위한 이상적인 콜백으로 만든다.

마지막으로, 이 새로운 viewIsAppearing 방법은 iOS 13까지 다시 배포되므로 앱이 이전 버전의 iOS에서 실행되더라도 이를 활용할 수 있습니다.

다음은 새로운 viewIsAppearing 콜백이 일반적인 뷰 컨트롤러 모양 전환 중에 다른 주요 이벤트와 어떻게 맞는지 보여줍니다.

나는 몇 가지를 지적하고 싶다.

먼저, 뷰가 계층 구조에 추가되기 전에, 그리고 레이아웃이 시작되기 전에 viewWillAppear가 어떻게 호출되는지 주목하세요.

이것이 특성 컬렉션을 사용하거나 뷰의 크기나 다른 기하학에 따라 무엇이든 하기에는 너무 이르다.

다음으로, 애니메이션이 일어난 후, 마지막에 별도의 CATransaction에서 viewDidAppear가 어떻게 호출되는지 주목하세요.

이것은 viewDidAppear에서 변경한 모든 변경 사항이 전환이 완료될 때까지 보이지 않는다는 것을 의미하므로, 전환 중에 보고 싶은 변경 사항을 만들기에는 너무 늦었습니다.

반면에, viewIsAppearing은 viewWillAppear와 동일한 거래 내에서 호출됩니다.

이것은 이러한 콜백 중 하나에서 변경한 모든 변경 사항이 전환의 첫 번째 프레임부터 동시에 사용자에게 표시된다는 것을 의미합니다.

마지막으로, 타이밍이 비슷할 수 있지만, viewIsAppearing과 viewWillLayoutSubviews와 같은 레이아웃 콜백 사이에는 중요한 차이가 있습니다.

레이아웃 콜백은 뷰가 layoutSubviews를 실행할 때마다 이루어지며, 이는 전환 중에 여러 번 발생하거나 나중에 뷰가 표시되는 동안 언제든지 발생할 수 있습니다.

하지만 viewIsAppearing은 외관 전환 중에 한 번만 호출되며, 뷰에 레이아웃이 필요하지 않더라도 여전히 호출됩니다.

이것이 내가 viewIsAppearing을 Goldilocks 콜백으로 생각하는 것을 좋아하는 이유이다: 너무 이르거나, 너무 늦거나, 너무 자주 호출되지 않는다.

그건 딱 맞아.

UIKit의 특성 시스템은 iOS 17에서 업그레이드되었다.

특성은 앱의 계층 구조를 통해 데이터를 자동으로 전파합니다.

UITraitCollection에는 사용자 인터페이스 스타일, 수평 및 수직 크기 클래스, 선호하는 콘텐츠 크기 카테고리와 같은 많은 시스템 특성이 포함되어 있습니다.

이제 사용자 지정 특성을 정의하여 UITraitCollection에 자신의 데이터를 추가할 수 있습니다.

이것은 앱의 뷰와 뷰 컨트롤러로 데이터를 전파하는 완전히 새로운 방법입니다.

우리는 또한 모든 뷰 또는 뷰 컨트롤러에서 특성 값을 쉽게 수정할 수 있도록 새로운 특성 재정의 API를 추가했습니다.

또한 하위 클래스에서 traitCollectionDidChange를 재정의하는 대신 특성이 값을 변경할 때 콜백을 받기 위해 보다 유연한 API를 채택할 수 있습니다.

마지막으로, 사용자 지정 UIKit 특성을 사용자 지정 SwiftUI 환경 키와 연결하여 앱의 UIKit과 SwiftUI 구성 요소 간에 데이터를 원활하게 전달할 수 있습니다.

이러한 흥미진진한 새로운 개선 사항에 대한 모든 것을 배우려면, "UIKit 특성 시스템 풀기" 비디오를 확인하세요.

모든 플랫폼에서 SF 기호는 도구 모음 아이콘, 탐색 모음 및 기타 UI 요소를 일관되게 찾을 수 있습니다.

그것들은 텍스트 라벨과 자동으로 정렬되도록 설계되었으며 앱의 디자인에 맞게 무게, 규모 및 모양에 맞게 쉽게 사용자 정의할 수 있습니다.

iOS 17에서 UIKit은 새로운 기호 효과 API로 애니메이션 기호를 지원합니다.

이러한 효과는 모든 기호 이미지, 심지어 사용자 지정 이미지에도 적용될 수 있습니다.

기호 효과를 적용하려면, UIImageView에서 새로운 addSymbolEffect() 메소드를 사용하세요.

여기서, 나는 기호가 한 번 튕기게 하는 바운스 효과를 추가한다.

이제 나는 다양한 색상 효과를 추가할 것이다.

바운스와 달리, 가변 색상 효과는 추가될 때 무기한으로 활성화됩니다.

removeSymbolEffect() 메서드를 사용하여 효과를 끝내세요.

마지막으로, 새로운 setSymbolImage() 메서드를 사용하여 기호에 걸쳐 전환 효과를 수행할 수 있습니다.

내가 살펴봤던 세 가지 기능보다 상징 효과에 더 많은 것이 있다.

자세한 내용은 "앱에서 기호 애니메이션" 비디오를 확인하세요.

다음으로, 우리는 빈 상태를 쉽게 나타낼 수 있도록 새로운 API를 추가했습니다.

빈 상태는 앱에서 표시할 콘텐츠가 없는 순간입니다.

콘텐츠가 생성되지 않기 때문에 일반적으로 앱의 첫 번째 실행 시 발생합니다.

또한 인터넷 연결 부족과 같은 제한으로 인해 앱이 콘텐츠를 표시할 수 없을 때 발생합니다.

UIContentUnavailableConfiguration은 빈 상태에 대한 구성 가능한 설명이며, 이미지나 텍스트와 같은 자리 표시자 콘텐츠와 함께 제공될 수 있습니다.

이 예시에서, 나는 표시할 가장 좋아하는 번역이 없다는 것을 알린다.

이 빈 상태를 나타내기 위해, 나는 구성을 뷰 컨트롤러의 contentUnavailableConfiguration으로 설정했다.

.Empty() 구성 외에도, UIKit은 준비 중인 콘텐츠를 나타내기 위해 .loading() 구성을 제공합니다.

게다가, UIHostingConfiguration API를 활용하여 SwiftUI 보기로 앱의 빈 상태를 나타낼 수 있습니다.

이것은 셀과 함께 UIHostingConfiguration을 사용하는 것처럼 작동합니다.

뷰 컨트롤러의 콘텐츠를 사용할 수 없는 구성을 업데이트하는 가장 좋은 장소는 새로운 방법인 updateContentUnavailableConfiguration(사용: 상태) 안에 있습니다.

이 예제는 결과를 반환하지 않는 쿼리를 위해 설계된 .search 구성을 사용합니다.

이 구성은 지역화된 1차 및 2차 텍스트를 제공하며, 쿼리는 인근 검색 컨트롤러에서 보간됩니다.

뷰 컨트롤러의 콘텐츠 가용성이 변경될 때마다 setNeedsUpdateContentUnavailable Configuration을 호출하여 업데이트를 요청하십시오.

모든 Apple 플랫폼에서 언어 설정에 관계없이 일관되고 고품질의 경험을 제공하는 것이 필수적이다.

그것을 용이하게 하기 위해, 우리는 글꼴과 텍스트 렌더링 분야에서 상당한 발전을 이듄습니다.

이 섹션에서는 특정 글꼴과 언어에서 텍스트의 클리핑과 충돌을 방지하는 데 도움이 되는 동적 선 높이 조정에 대해 알려드리겠습니다.

또한 개선된 줄 바꿈 및 하이픈 규칙과 로케일을 기반으로 이미지를 요청하는 새로운 API에 대해 배우게 될 것입니다.

먼저, 글꼴과 그 지표를 자세히 살펴보세요.

글꼴 메트릭은 여러 용어를 사용하여 정의됩니다.

기준선은 문자나 단어가 놓여 있는 가상의 선을 나타낸다.

선 높이는 이 기준선 사이의 공간을 가리킨다.

그리고, x-높이는 소문자 위에 있는 선이다.

일부 글꼴에는 이 선 너머로 확장되는 어센더와 디센더가 있다.

어센더는 x 높이 위로 확장되는 글꼴의 부분이다.

반면에, 디센더는 기준선 아래에 매달려 있다.

아랍어, 힌디어, 태국어와 같은 일부 언어의 경우, 이러한 요소는 라틴 문자보다 훨씬 더 많은 수직 공간을 필요로 하며, 충돌이나 클리핑 문제가 발생할 수 있다.

모든 언어로 어센더와 디센더가 겹치는 것을 방지하기 위해, 우리는 동적 선 높이 조정 기능을 도입했습니다.

이것은 UILabels와 같은 텍스트 요소가 최적의 가독성을 위해 선 높이와 수직 치수를 자동으로 조정하도록 보장합니다.

우리는 또한 중국어, 독일어, 일본어, 한국어와 같은 언어에 대한 줄 바꿈 행동을 상당히 개선했습니다.

이러한 개선 사항은 어떤 종류의 텍스트 스타일을 사용하고 있는지에 따라 다른 규칙을 적용합니다.

이것은 텍스트 스타일을 채택하는 한 대부분의 경우 자동으로 작동하지만, 모범 사례와 앱이 모든 언어에서 작동하는지 확인하는 방법에 대한 자세한 내용은 "텍스트 및 텍스트 상호 작용의 새로운 기능"을 확인하십시오.

특정 상황에서, UI의 상당 부분이 사용자가 선택한 언어와 다른 언어로 표시될 수 있습니다.

예를 들어, 콘텐츠가 웹에서 나올 때.

이러한 경우, 새로운 조판 언어 특성을 사용하여 인터페이스의 언어를 나타낼 수 있으며, 이는 그에 따라 줄 높이와 하이픈 규칙을 조정하는 데 도움이 될 것입니다.

UIKit은 이제 이미지의 특정 현지화된 변형에 대한 액세스를 지원합니다.

예를 들어, character.textbox SF Symbol에는 8개의 다른 로케일 기반 변형이 있습니다.

기본적으로, UIKit은 장치의 현재 언어 설정과 일치하는 변형을 가져옵니다.

그래서 만약 현재 언어가 미국이라면 영어, 그리고 라틴어 변형이 표시됩니다.

iOS 17에서 앱은 이미지 구성에서 로케인을 제공하여 특정 변형을 요청할 수 있습니다.

여기서, 저는 일본 로케일의 구성을 제공하여 기호의 일본어 버전을 찾습니다.

텍스트 렌더링 및 로케일 지원에 대한 이러한 모든 변경 사항으로, 당신의 앱은 모두를 위해 집과 더 가깝게 느낄 수 있습니다.

이제, iPad용 앱을 구축하기 위한 개선 사항을 안내해 드리겠습니다.

저는 5가지 영역에서 개선 사항을 다룰 것입니다: 새로운 창 드래그 상호 작용, 스테이지 관리자의 향상된 사이드바 동작, 키보드 스크롤 지원, 문서 중심 앱 구축의 발전, 새로운 Apple Pencil 기능 및 API.

iOS 17에서는 드래그 제스처를 시작할 수 있는 영역을 확장하여 스테이지 관리자의 창 드래그 기능을 업데이트했습니다.

이제, UINavigationBar 내부의 아무 곳이나 드래그하면 창이 움직이기 시작합니다.

이 제스처는 팬이나 스와이프 제스처와 같이 앱에 있을 수 있는 다른 제스처 인식기와 잘 어울립니다.

앱에서 UI의 일부로 UINavigationBar를 사용하지 않는 경우, UIWindowSceneDragInteraction을 채택하여 모든 보기에 추가할 수 있습니다.

또한 앱에서 다른 팬 제스처와 제스처 관계를 설정하여 충돌이 없는지 확인할 수 있습니다.

이것은 또한 Mac Catalyst에서 바로 작동합니다.

열 스타일의 UISplitViewControllers는 Stage Manager에서 우아한 새로운 크기 조정 동작을 얻었다.

사이드바는 필요할 때 자동으로 숨겨지며, 특별히 표시되도록 요청될 때까지 숨겨져 있습니다.

사이드바가 더 좁은 너비로 요청되면, UISplitViewController는 오버레이를 사용하거나 필요에 따라 동작을 대체합니다.

창의 크기가 더 커질 때 겹쳐진 사이드바가 유지됩니다.

더 큰 폭에서 해고되고 리콜되면, 그것은 타일로 돌아올 것이다.

메일과 같은 삼중 열 분할 뷰 컨트롤러는 비슷하게 동작한다.

이 새로운 동작은 이중 열 또는 삼중 열 스타일로 생성된 UISplitViewControllers에서 발생합니다.

요약하자면: 자동 동작은 가능할 때마다 열을 타일링하고, 너비가 줄어들 때 필요에 따라 사이드바를 숨기고, 사이드바 버튼을 탭할 때 타일링할 공간이 충분하지 않은 경우 사이드바로 보조 열을 오버레이하거나 대체하며, preferredDisplayMode 및 preferredSplitBehavior를 사용하여 응용 프로그램의 동작을 재정의할 수 있습니다.

iPadOS 17에서 우리는 문서 중심 앱에 대한 지원을 개선했습니다.

UIKit은 콘텐츠 뷰 컨트롤러의 기본 클래스 역할을 하는 새로운 UIDocumentViewController를 제공합니다.

그것은 시스템 기본 경험을 보장하고 제목 메뉴 자동 구성, 공유, 드래그 앤 드롭, 키 명령 등과 같은 추가 채택 없이 많은 기능을 제공합니다.

또한, UIDocument는 이제 UINavigationItemRenameDelegate를 준수하며 뷰 컨트롤러의 탐색 항목의 이름 변경 대리인으로 설정할 때 완전한 이름 바꾸기 경험을 제공합니다.

문서 관리에 중점을 둔 앱의 이러한 기능 및 기타 새로운 기능에 대해 자세히 알아보려면, '더 나은 문서 기반 앱 구축'을 확인하세요.

Apple Pencil은 iPadOS 앱에 추가 측면을 추가하며 새로운 API도 많이 있습니다.

새로운 iPad Pro와 iOS 16.4로, 우리는 Apple Pencil로 호버를 도입했습니다.

연필에서 호버를 캡처하려면 UIHoverGestureRecognizer를 사용할 수 있습니다.

Z 오프셋은 0에서 1 사이의 화면으로부터의 정규화된 호버 거리를 반영한다.

또한 호버 범위에서 연필의 고도와 방위각을 캡처하여 브러시 스트로크가 화면에서 어떻게 보일지 미리 볼 수 있는 미리보기를 정확하게 렌더링할 수 있습니다.

연필 호버를 사용하면 홈 화면과 앱의 도구 모음 아이콘을 가리킬 수도 있습니다.

UIPointerInteraction을 사용하는 경우, 추가 채택이 필요하지 않습니다.

그러나, 마우스나 트랙패드 입력과 애플 펜슬 입력을 사용할 때의 시각적 상호 작용은 약간 다르다는 점은 주목할 가치가 있다.

예를 들어, 시스템 포인터와 같은 포인터 스타일은 Apple Pencil을 사용하는 동안 보이지 않습니다.

앱으로 연필 호버를 사용해 보세요.

iOS 17에서 PencilKit은 훨씬 더 표현력이 뛰어나고 새로운 잉크를 소개합니다.

모노라인 펜은 디테일에 적합하며, 일관된 크기의 너비를 제공합니다.

만년필은 두꺼운 다운스트로크와 얇은 업스트로크로 서예를 모방한다.

수채화는 아름다운 스트로크와 표현력을 허용한다.

그리고 크레용은 재미있는 추가이다.

새로운 잉크로, 이전 버전과의 호환성을 염두에 두세요.

이전 버전의 iOS는 새 잉크가 포함된 PKDrawings를 로드할 수 없습니다.

PKDrawing, PKStroke 등과 같은 데이터 모델 유형의 새로운 콘텐츠 버전 속성은 개체를 로드하는 데 필요한 PencilKit 버전을 나타냅니다.

1의 콘텐츠 버전은 iOS 14와 2에서 출시된 잉크를 나타내며 iOS 17의 새로운 잉크를 위한 것입니다.

좋은 사용자 경험을 제공하려면, 이 API를 사용하여 비호환성을 감지하고 메시지를 제공하거나 대체 이미지를 렌더링하십시오.

이전 버전과의 호환성을 유지할 수 없는 경우, 새로운 maximumSupportedContentVersion API를 사용하여 캔버스와 툴피커를 통해 사용할 수 있는 기능을 제한하십시오.

매직 키보드와 같은 하드웨어 키보드와 페어링할 때 iPad를 더욱 강력하게 만들기 위해 키보드 스크롤 지원을 추가했습니다.

iOS 17의 새로운 기능, UIScrollViews는 가능한 경우 Page Up, Page Down, Home 및 End 키를 사용하여 스크롤할 수 있습니다.

UIScrollView의 새로운 API를 사용하여 이 동작을 재정의할 수 있으며, 키보드 스크롤을 허용합니다.

마지막으로, UIKit의 여러 영역에서 우리가 만든 일반적인 개선 사항을 안내할 것입니다.

8가지 일반적인 개선 사항에 대해 알려드리겠습니다: 컬렉션 보기 개선, 새로운 봄 애니메이션 매개 변수, 텍스트 상호 작용 등.

iOS 17에서 많은 성능 개선과 함께 크게 최적화된 컬렉션 보기부터 시작하겠습니다.

이 그래프는 많은 수의 항목으로 작업을 수행할 때 iOS 17에서 컬렉션 보기가 얼마나 빠른지 보여줍니다.

iOS 17은 1만 개의 항목이 포함된 컬렉션 보기의 정렬 순서를 뒤집기 위해 iOS 16보다 거의 두 배 빠르며, 해당 항목의 절반을 삭제하는 업데이트를 수행하는 것은 거의 세 배 빠릅니다.

게다가, 애니메이션 없이 업데이트를 수행하면 컬렉션 보기 성능이 더욱 향상됩니다.

분할 가능한 데이터 소스에 스냅샷을 적용하든, 수동으로 일괄 업데이트를 수행하든, iOS 17에서 컬렉션 보기는 전반적으로 더 빠릅니다.

이러한 개선은 앱이 더 반응성을 느끼게 하고 앱의 히치 감소를 초래합니다.

이제, 저는 먼저 상당히 전형적인 레이아웃의 예로 시작하여 구성 레이아웃의 강력한 새로운 기능에 대해 이야기할 것입니다.

여기 iPad의 새로운 건강 앱이 있습니다. 여기서 즐겨찾기 섹션은 2개의 항목의 행이 있는 구성 레이아웃을 사용하고 있으며, 모두 NSCollectionLayoutDimension.estimated를 사용하여 자체 크기를 조정합니다.

약물 세포가 어떻게 그 옆에 있는 세포와 일치하지 않는 높이를 가지고 있는지 주목하세요.

이 줄의 항목이 같은 높이를 가지고 있다면 이것은 훨씬 더 좋아 보일 것이다.

iOS 17에서 구성 레이아웃은 새로운 레이아웃 차원을 얻습니다: uniformAcrossSiblings.

이 새로운 기능을 사용하면 레이아웃의 자체 크기 조정 항목이 가장 큰 항목의 크기에 따라 일관된 크기를 받을 수 있습니다.

이런 종류의 레이아웃이 필요할 때, 예상 치수를 uniformAcrossSiblings로 바꾸세요.

이 기능을 사용할 때, 가장 큰 항목의 크기를 결정하기 위해 모든 형제 항목을 만들고 크기를 조정해야 한다는 것을 명심하세요. 따라서 그룹에 많은 수의 항목이 있을 때 사용하지 마세요.

건강 앱의 이 예시로 돌아가세요.

이 그룹에는 항목 높이가 다른 두 개의 항목이 있습니다.

우리는 uniformAcrossSiblings를 사용하기 위해 이 레이아웃의 모든 항목을 업데이트했습니다. 그래서 약물 셀은 사운드 레벨 셀의 높이와 일치하도록 성장하여 우리가 원하는 레이아웃을 얻을 수 있습니다.

다음으로, 봄 애니메이션을 위해, 우리는 이해하기 쉽고 작업하기 쉬운 매개 변수를 지정하는 새로운 방법을 다듬고 있습니다.

그것은 단지 두 가지 매개 변수를 사용한다: 지속 시간과 바운스.

지속 시간은 애니메이션이 완전히 완료되는 데 걸리는 시간이 아니라 봄 애니메이션을 인식할 때까지의 시간을 정의하며, 바운스와는 독립적입니다.

그리고 0에서 바운스를 늘리면 애니메이션의 느낌을 변경하지 않고도 애니메이션에 바운스가 추가됩니다.

우리는 이러한 스프링 매개 변수를 사용하는 UIView에 새로운 방법을 추가했습니다.

그리고 그것들은 모두 선택 사항이므로, 이제 "애니메이션"을 작성하고 시스템 기본값과 일치하는 스프링 애니메이션을 얻을 수도 있습니다.

스프링을 설명하는 이 새로운 방법에 대한 더 많은 통찰력을 얻기 위해 "Animate with Springs" 토크를 보세요.

다음으로, 텍스트와 상호 작용하기 위한 새로운 기능과 API를 다룰 것입니다.

우리는 새롭게 재설계된 선택 루페를 포함하여 iOS 17의 텍스트 커서와 텍스트 선택 UI를 크게 개선했습니다.

워드 프로세서와 같은 사용자 지정 텍스트 뷰를 가진 개발자는 이제 모든 UITextInteraction을 채택하지 않고도 선택 UI를 위해 시스템 제공 뷰를 사용할 수 있습니다.

텍스트 뷰의 텍스트 항목 상호 작용은 이제 UITextViewDelegate의 새로운 API를 통해 더 사용자 정의할 수 있으므로 링크 또는 텍스트 첨부 파일과 같은 텍스트 항목에 대한 기본 작업 또는 메뉴를 수정할 수 있습니다.

또한 콘텐츠의 사용자 지정 범위에 태그를 지정하여 상호 작용을 활성화할 수 있으므로 링크가 아닌 텍스트에 작업이나 메뉴를 더 쉽게 추가할 수 있습니다.

텍스트 커서 개선과 텍스트 항목 작업 및 메뉴에 대해 자세히 알아보려면, "텍스트 및 텍스트 상호 작용의 새로운 기능"을 보세요.

이제 저는 iOS의 잘 정립된 요소인 상태 표시줄에 대한 업데이트를 제공할 것입니다.

iOS의 상태 표시줄 스타일링은 앱 또는 뷰 컨트롤러가 어둡거나 밝은 모드에 있는 것을 기반으로 전환되는 기본 스타일로 그 아래의 응용 프로그램에 의해 제어됩니다.

대조를 보장하기 위해 바로 얻기가 까다로울 수 있는 사용자 콘텐츠가 있는 경우가 있습니다.

앱이 가벼운 사용자 인터페이스를 사용하고 있기 때문에 기본 스타일은 어둡습니다.

하지만 사용자 콘텐츠 중 일부는 어둡다.

이제 iOS 17에서 기본 스타일은 앱의 콘텐츠에 지속적으로 조정되며 대비를 유지하기 위해 어둡고 밝은 스타일 사이에서 자동으로 변경됩니다.

그것은 심지어 필요할 때 상태 표시줄이 스타일을 쏟을 수 있게 해준다.

앱은 더 이상 이러한 모든 경우에 어둡고 밝은 것을 명시적으로 지정할 필요가 없기 때문에, 사용자 지정 코드를 제거하고 기본 스타일을 사용할 수 있는 기회가 있습니다.

드래그 앤 드롭은 iOS 17에서 점점 더 강력해지고 있다.

지원되는 파일과 콘텐츠는 이제 홈 화면의 아이콘에 놓고 각 앱에서 직접 열 수 있습니다.

이것은 오늘날 많은 문서 기반 앱에서 변경 없이 자동으로 작동할 것이다.

이 시스템은 앱의 Info.plist 파일에 정의된 대로 CFBundleDocumentTypes를 사용하여 삭제된 파일이 지원되는지 확인합니다.

드롭 시, 파일은 다른 URL과 마찬가지로 기존 장면 대리자 방법을 사용하여 열립니다.

앱이 이 기능을 선택하기 위해 지원되는 문서 유형을 정의하는지 확인하기만 하면 됩니다.

UIKit은 ISO HDR 이미지에 대한 지원을 추가하여 UIImageView로 이러한 이미지를 쉽게 표시하고 UIGraphicsImageRenderer로 조작할 수 있습니다.

또한, 새로운 UIImageReader는 카메라 롤에서 ISO HDR로와 같은 일부 HDR 이미지 형식을 변환하는 것을 포함하여 이미지를 로드할 때 더 많은 제어를 제공합니다.

자세한 내용은 "앱에서 HDR 이미지 지원" 세션을 확인하세요.

UIPageControl은 분수 페이지 진행 상황을 나타내는 새로운 기능을 얻었다.

오늘날, 페이지 컨트롤은 일반적으로 앱에서 설정된 기간 또는 비디오 콘텐츠에 따라 자동으로 페이지를 표시하는 슬라이드쇼 콘텐츠를 표시하는 데 사용됩니다.

새로운 진행 및 타이머 진행 API를 사용하면 이제 활성 지표에서 분수 페이지 진행 상황을 표시하여 페이지가 언제 바뀔지에 대한 더 나은 컨텍스트를 제공할 수 있습니다.

분수 진행 페이지 컨트롤을 설정하려면, UIPageControl에서 진행 객체로 새로운 진행 속성을 설정하기만 하면 됩니다.

UIPageControlTimerProgress에는 각 페이지의 기간을 쉽게 구성할 수 있는 타이머가 내장되어 있습니다.

UIPageControl은 타이머 기간이 충족되면 자동으로 페이지를 변경합니다.

자체 소스가 있는 비디오 플레이어 또는 외부 타이머를 따라야 하는 페이지의 경우, 기본 UIPageControlProgress 유형을 사용하여 콘텐츠가 진행됨에 따라 currentProgress 값을 수동으로 업데이트하십시오.

iOS 17과 macOS 소노마는 팔레트 메뉴를 소개합니다.

팔레트는 일반적으로 항목 모음에서 선택하는 데 사용되는 메뉴 요소의 행이다.

이러한 제어 스타일은 iOS의 도서 앱이나 Mac의 Mail 및 Finder에서 찾을 수 있습니다.

이제 UIKit에서 일류 컨트롤로 사용할 수 있습니다.

메뉴를 팔레트로 바꾸려면, 다음과 같은 옵션에 .displayAsPalette를 추가하기만 하면 됩니다.

팔레트의 요소는 상대적으로 작기 때문에, 선택은 일반 메뉴 요소에서와 마찬가지로 체크 표시로 표시되지 않습니다.

대신, UIKit은 제공된 이미지를 기반으로 적절한 선택 지표를 선택할 것이다.

팔레트의 모든 요소가 단색 SF 기호 또는 템플릿 이미지를 사용하는 경우, 선택한 요소는 앱의 색조 색상으로 착색됩니다.

요소에 다색 SF 기호가 있는 경우, 선택한 기호 주위에 색조의 획이 그려집니다.

메뉴 요소에 완전히 사용자 지정 이미지를 사용하거나, 자신의 선택 표시기를 제공하여 내장된 동작을 재정의하려면, UIMenuLeaf 프로토콜에서 새로운 selectedImage 속성을 사용할 수 있습니다.

이 예에서, 선택된 이미지는 UIAction의 이니셜라이저에 설정되어 있다.

UIKit의 메뉴 API는 iOS, iPadOS 및 Mac Catalyst에서 사용할 수 있으므로 동일한 친숙한 API로 복잡한 메뉴를 만들 수 있습니다.

그리고 tvOS 17부터 모든 동일한 API를 새로운 외관과 기본 tvOS 동작으로 Apple TV에서 사용할 수 있습니다.

와! 우리는 많은 땅을 덮었다.

UIKit은 확실히 다양한 기능을 획득하여 기능을 더욱 향상시켰다.

다음은 뭐야?

iOS 17 SDK를 사용하여 앱을 컴파일하세요.

새로운 UIKit 기능을 통합하고 프로젝트에서 Xcode 미리보기를 활용하세요.

그리고 UI가 라틴어가 아닌 언어로 다양한 텍스트 메트릭을 수용할 수 있도록 유연하게 하십시오.

이 주제들에 대한 간략한 개요를 즐겼기를 바랍니다.

더 깊이 있게 보려면, 관련 비디오를 확인하세요.

고마워.

♪ ♪