10054

♪ ♪

Aasim: 안녕하세요, 저는 Aasim Kandrikar입니다. 나중에 Raleigh Ledet과 합류할 것입니다.

우리는 둘 다 AppKit 팀의 엔지니어입니다.

이 비디오에서, 우리는 macOS Sonoma의 "AppKit의 새로운 기능"에 대해 이야기할 것입니다.

우리는 AppKit 컨트롤의 새로운 기능 및 API 개선, 새로운 구현으로 구동되는 메뉴 개선, macOS에서 앱 활성화 작동 방식 변경, 이미지 및 기호에 대한 그래픽 개선 및 새로운 기능, 새로운 텍스트 입력 경험 및 비영어 언어의 텍스트 레이아웃 개선, Swift 및 SwiftUI 작업 개선 등 광범위한 주제를 다룰 것입니다.

macOS 소노마에는 AppKit 컨트롤에 대한 몇 가지 흥미로운 새로운 기능과 API 개선 사항이 포함되어 있습니다.

NSTableView와 NSOutlineView는 즉시 많은 기능을 제공하여 AppKit을 사용하여 훌륭한 Mac 앱을 설계하는 데 중요한 요소가 됩니다.

macOS 소노마에는 열 사용자 지정 메뉴를 제공하는 새로운 API가 있습니다.

이 메뉴를 통해 사용자는 테이블에서 열의 가시성을 전환할 수 있습니다.

이전에는 이 메뉴를 만들고 제시하기 위해 사용자 지정 구현이 필요했지만, 이제 최소 세 줄의 코드로 추가할 수 있습니다.

새로운 대리자 메소드 tableView userCanChangeVisibilityOf를 채택하세요.

사용자가 숨길 수 있는 열을 지정하면, AppKit은 메뉴를 현지화하고 재실행 시 숨겨진 열 상태를 복원하는 것을 포함하여 나머지를 처리합니다.

재단의 진행 유형은 애플리케이션이 수행하는 작업을 나타냅니다.

앱에서 이것을 사용하여 진행 중인 다운로드 또는 처리 중인 이미지를 나타낼 수 있습니다.

macOS 소노마에서는 이제 NSProgressIndicator와 함께 Foundation의 진행 유형을 사용할 수 있습니다.

새로운 관찰된 진행 속성에 진행 상황을 할당하고 진행률 표시기는 백그라운드 스레드에서도 진행 상황이 변경됨에 따라 자동으로 값을 업데이트합니다.

버튼 베젤 스타일 API는 새로운 베젤 스타일로 시작하여 자동으로 업데이트되었습니다.

이 베젤 스타일은 버튼의 내용과 뷰 계층 구조의 위치에 따라 가장 적절한 스타일에 적응할 것이다.

예를 들어, 버튼이 창에 있을 때, 푸시 버튼 스타일을 선택할 것이다.

버튼이 도구 모음에 배치되면, 도구 모음 스타일을 선택합니다.

키가 큰 콘텐츠의 경우, 버튼은 유연한 푸시 버튼 스타일을 선택할 것이다.

자동 베젤 스타일은 이제 모든 버튼 이니셜라이저의 기본 베젤 스타일입니다.

기존 베젤 스타일 이름은 의미론적 사용에 따라 외관에 대한 설명에서 현대적인 이름으로 업데이트되었습니다.

예를 들어, 이전에 "Recessed" 버튼은 이제 "액세서리 바" 버튼으로, 이 베젤 스타일이 액세서리 바에서 가장 일반적으로 사용된다는 것을 나타냅니다.

낙담한 베젤 스타일은 이제 더 이상 사용되지 않는다.

사용 중단은 이제 명확한 의미론적 사용을 가진 대체 베젤 스타일을 가리킨다.

우리는 새로운 분할 뷰 유형인 검사관을 도입했습니다.

인스펙터는 현재 문서에서 선택된 콘텐츠에 대한 문맥 정보를 표시하는 후행 분할 보기 항목입니다.

사이드바와 마찬가지로, 검사관은 전체 크기 콘텐츠 보기 마스크가 설정될 때 창의 전체 높이를 사용합니다.

새로운 검사관은 macOS Big Sur에 다시 배치한다.

앱에 관리자를 추가하는 것은 간단합니다.

먼저, 새로운 inspectorWithViewController 이니셜라이저를 사용하여 새로운 분할 보기 항목을 만드세요.

그런 다음, 기존 분할 뷰 컨트롤러에 새 splitViewItem을 추가하세요.

다음으로, 새로운 토글 인스펙터 도구 모음 항목을 포함하도록 도구 모음 대리인을 업데이트하십시오.

당신은 일반적으로 토글 인스펙터 항목이 창의 후행 가장자리에 있는 인스펙터 위에 배치되기를 원합니다.

그렇게 하려면, 토글 인스펙터 항목 앞에 새로운 인스펙터 추적 분리기와 유연한 공간을 추가하세요.

우리는 NSPopover에 몇 가지 개선을 가져왔다.

먼저, 도구 모음 항목에서 팝오버 고정에 대한 지원을 추가했습니다.

우리는 또한 풀 사이즈 팝오버 콘텐츠를 지원하는 방법을 추가했으므로, 당신의 견해가 전체 팝오버 경계를 채웁니다.

도구 모음 고정부터 시작하겠습니다.

도구 모음 항목과 관련하여 팝오버를 표시하는 새로운 방법이 있습니다.

도구 모음 항목이 오버플로 메뉴에 있을 때, 팝오버는 오버플로 쉐브론에 우아하게 고정되어 나타납니다.

다음으로, 팝오버 콘텐츠는 이제 팝오버 쉐브론으로 확장될 수 있다.

컬러 배경 헤더 보기가 있는 팝오버가 있다면, 이렇게 생겼을 수도 있습니다.

헤더 배경의 색상이 팝오버 쉐브론으로 확장되지 않는다는 점에 유의하십시오.

팝오버 콘텐츠를 쉐브론 영역으로 확장하려면, 새로운 hasFullSizeContent 속성을 true로 설정하십시오.

안전 영역 rect를 사용하여 팝오버 내부에서 가려져서는 안 되는 콘텐츠를 레이아웃하세요.

그리고 이제 나는 메뉴의 흥미진진한 변화에 대해 이야기하기 위해 그것을 롤리에게 넘길 것이다.

롤리: 고마워 아심.

메뉴는 코코아를 완전히 사용하기 위해 다시 작성되었다.

이것은 메모리와 CPU 사용량을 크게 줄임으로써 AppKit의 탄소 발자국을 줄인다.

그것은 또한 새로운 기능을 가능하게 한다.

특히, 저는 섹션 헤더, 팔레트 메뉴, 새로운 선택 행동 및 배지를 다룰 것입니다.

이러한 기능은 새로운 기회를 열어주고 작성해야 하는 코드의 양을 줄일 것입니다.

섹션 헤더는 메뉴에서 그룹을 전달하는 데 도움이 되는 새로운 추가 사항이며 한 줄의 코드로 만들 수 있습니다.

새로운 클래스 함수인 sectionHeader(title:)를 사용하여 하나를 만들고 다른 메뉴 항목과 마찬가지로 메뉴에 추가하십시오.

이 예에서는 세 개의 메뉴 섹션이 생성되며, 각 섹션에는 섹션 헤더와 두 개의 항목이 있습니다.

팔레트 메뉴는 항목이 수평 시리즈로 배치되는 메뉴를 만들 수 있는 흥미로운 새로운 기능입니다.

예를 들어, 이 간단한 색상 선택기.

메뉴의 프레젠테이션 스타일을 .palette로 설정하여 모든 메뉴를 팔레트 메뉴로 바꿀 수 있습니다.

각 메뉴 항목에 대해 이미지를 설정하세요.

템플릿 이미지의 경우, AppKit은 자동으로 적절한 선택 색조를 추가합니다.

또는, offStateImage와 onStateImage를 설정할 수 있습니다.

onStateImage는 선택을 나타내는 데 사용됩니다.

선택할 수 있는 몇 가지 선택 모드가 있습니다.

.selectAny는 개별 메뉴 항목의 상태를 전환하지만, 그룹의 다른 항목의 상태는 변경하지 않습니다.

.selectOne은 그룹 상태의 다른 구성원을 off로 설정하는 동안 선택한 메뉴 항목의 상태를 켜진 상태로 설정합니다.

또한 selectedItems 속성을 통해 상태에 있는 항목을 가져오거나 설정할 수 있습니다.

참고: selectionMode와 selectedItems는 동일한 대상/액션 쌍을 가진 메뉴 항목을 논리적 그룹으로 구성하여 작동합니다.

팔레트 메뉴 항목을 수동으로 만들 때, 새로운 선택 모드와 선택된 항목 동작을 활용하기 위해 각 항목에 동일한 대상/액션 쌍을 부여하십시오.

그리고 여기 팁이 있습니다: 이 기술은 팔레트 메뉴에만 국한되지 않습니다.

일반 메뉴에서 동일한 대상/액션 쌍을 가진 메뉴 항목에서도 작동합니다.

NSMenu는 또한 일반적인 팔레트 메뉴를 만드는 편리한 기능을 제공한다.

색상 배열은 팔레트 항목의 수와 색조를 결정합니다.

제목은 접근성을 위해 사용되므로, 반드시 추가하세요.

선택적 템플릿 매개 변수는 채색에 사용할 템플릿 이미지를 지정합니다.

예를 들어, 여기에 사용된 깃발 기호 이미지.

템플릿을 지정하지 않으면, AppKit은 기본적으로 채워진 원으로 설정됩니다.

선택적 폐쇄 매개 변수도 있습니다.

이 폐쇄는 사용자가 팔레트의 메뉴 항목을 토글할 때마다 호출됩니다.

메뉴는 폐쇄로 전달된다.

그것으로부터, 당신은 selectedItems 속성을 가진 on 상태의 메뉴 항목 배열을 얻을 수 있습니다.

메뉴 항목은 이제 다양한 방법으로 배지를 부착할 수 있습니다.

간단한 문자열이나 카운트만 사용할 수 있습니다.

또한 세 가지 전문 카운트 배지가 있습니다: 새로운 항목, 경고 및 업데이트.

이 배지 중 하나를 사용하면, AppKit은 자동으로 적절한 텍스트를 추가합니다.

게다가, AppKit은 텍스트도 적절하게 현지화할 것이다.

이 예에서, 일본어.

하지만, 당신은 여전히 메뉴 항목 자체와 일반 문자열 배지 변형을 현지화할 책임이 있습니다.

그것은 완전히 새로운 메뉴 구현입니다: 향상된 성능, 배지, 팔레트 및 섹션 헤더.

macOS 소노마에서, 우리는 협동 앱 활성화를 도입했습니다.

협력적인 앱 활성화는 예상치 못한 애플리케이션 스위치, 예를 들어, 입력하는 동안 앱 스위치를 줄입니다.

협력적인 앱 활성화에는 두 부분이 있다.

활성화는 이제 명령이 아닌 요청이다.

시스템은 활성화 요청이 적절한지 결정하기 위해 사용자가 하는 일의 더 넓은 맥락을 고려한다.

새로운 수율 API는 애플리케이션이 향후 활성화 요청의 맥락에 영향을 미칠 수 있게 해준다.

이제 활성화가 요청이기 때문에, ignoringOtherApps 매개 변수와 옵션은 무시됩니다.

따라서 macOS Sonoma에서는 activate(ignoringOtherApps:) 기능과 activateIgnoringOtherApps 옵션이 모두 더 이상 사용되지 않습니다.

NSApplication과 NSRunningApplication을 위한 새로운 활성화 API로 교체하세요.

활성 애플리케이션만이 활성화 컨텍스트에 영향을 미칠 수 있다.

그것은 대상 애플리케이션이 활성화되기 전에 명시적인 대상 애플리케이션에 양보함으로써 그렇게 한다.

그런 다음, 대상 애플리케이션이 활성화를 요청할 때, 시스템은 결정을 내릴 때 컨텍스트의 일부로 수율을 사용할 것이다.

요청이 받아들여지면, 활성 앱은 비활성화되고, 대상 앱은 활성화됩니다.

그렇지 않으면, 활성 앱은 활성 상태로 유지됩니다.

NSWorkspace는 URL이나 애플리케이션을 열 때 이것을 자동으로 처리합니다.

다른 경우, 수동으로 다른 애플리케이션에 활성화하려면, 대상 NSRunningApplication 또는 번들 식별자에 대한 yieldActivation.

시스템은 대상 앱이 활성화 자체를 요청하거나 대신 활성화될 때 수율 컨텍스트를 사용합니다.

그것은 새로운 협동 앱 활성화 행동이다.

우리는 또한 몇 가지 중요한 변경 사항을 만들었고 macOS Sonoma의 그래픽과 드로잉에 새로운 API를 추가했습니다.

이제 NSBezierPaths에서 CGPaths를 만들 수 있으며 그 반대의 경우도 마찬가지입니다.

NSBezierPath는 새로운 init(cgPath:) 이니셜라이저와 cgPath 속성을 얻습니다.

cgPath로 시작하거나, 설정하거나, 가져오는 것은 항상 경로의 복사본을 초래한다.

NSBezierPath의 추가 돌연변이는 원본 또는 복사 CGPath 인스턴스에 반영되지 않습니다.

즉, 그들은 수신자 부담으로 연결되어 있지 않다.

이 추가는 한 줄의 코드인 CAShapeLayer의 경로 속성과 같은 CGPath API와 함께 NSBezierPath를 사용할 수 있게 해준다.

이제 macOS에서 CADisplayLink 객체를 만들 수 있습니다.

이것은 당신이 iOS에서 익숙할 수 있는 것과 동일한 CADisplayLink입니다.

CADisplayLink에 익숙하지 않은 사람들을 위해, 앱이 그림을 디스플레이의 새로 고침 빈도와 동기화할 수 있는 타이머 객체입니다.

직접 초기화된 디스플레이 링크 객체는 메인 디스플레이와 동기화되지만, macOS는 단일 디스플레이에 국한되지 않습니다.

따라서 macOS에서는 새로운 displayLink(target:selector:) 기능을 사용하여 NSView, NSWindow 또는 NSScreen에서 직접 디스플레이 링크 개체를 얻을 수 있습니다.

가장 좋은 방법은 가장 구체적인 적용 가능한 요소, 일반적으로 보기에서 직접 CADisplayLink 객체를 얻는 것입니다.

이는 뷰나 창에서 만들 때, CADisplayLink는 디스플레이에 없을 때 일시 중지하는 것을 포함하여 데스크톱 주위를 이동할 때 창의 디스플레이 또는 뷰가 켜져 있는 것을 자동으로 추적하기 때문입니다.

이 뷰 서브클래스에서, startAnimating이 호출될 때, 두 줄의 코드로, stepAnimation 함수를 호출하는 DisplayLink 객체를 만들고, 뷰가 켜져 있는 모든 디스플레이와 동기화하고, 공통 모드의 메인 런루프에 displayLink를 추가합니다.

애니메이션이 완료되면, 표시 링크를 중지하고 등록된 모든 런루프 모드에서 제거하기 위해 무효화를 호출합니다.

NSColor는 이제 배경 모양을 채우기 위한 다섯 가지 새로운 시스템 색상을 제공합니다.

채우기 색상은 다양한 크기의 모양에 대해 다양한 수준의 강조를 제공한다.

슬라이더 트랙이나 진행률 표시줄 배경의 스케일에서 더 작은 모양은 시스템 채우기 또는 보조 시스템 채우기와 같이 눈에 띄기 위해 더 높은 수준의 강조를 사용합니다.

그룹 상자와 글꼴 배경과 같은 더 큰 모양은 4차 또는 5차 시스템 채우기와 같은 더 미묘한 수준의 강조를 선호한다.

이 채우기 색상은 역동적이므로, 증가된 대비와 다크 모드를 포함한 다양한 외모에 자동으로 적응합니다.

사용자 지정 UI 요소를 구축하는 경우, 이 새로운 채우기 색상은 시스템 설계에 적합하고 접근성을 지원하는 편리한 방법입니다.

NSViews는 그림 내용을 범위까지 클립한다.

그것은 때때로 FreeForm 경고 창에서 이 힌디어 글리프의 하단과 같이 원하는 방식으로 표시되지 않는 그림으로 이어집니다.

이것이 발생할 수 있는 일반적인 장소는 판매용 "뜨거운" 아이템의 배지나 불꽃과 같은 글꼴 렌더링, 그림자 또는 기타 하위 보기 악센트입니다.

이것을 해결할 방법이 있다.

예를 들어, 결합된 뷰를 더 큰 뷰에 형제로 삽입하세요.

그러나, 각 기술에는 고유한 단점이 있다.

이 경우, 둘러싸는 뷰를 간단한 수평 스택의 버튼과 결합하는 것은 기본적으로 텍스트의 기본 줄을 정렬하지 않습니다.

그리고 이제 당신은 해결해야 할 또 다른 문제가 있습니다.

더 좋은 방법이 있어.

macOS 소노마에서 연결되면, 대부분의 NSView는 더 이상 기본적으로 경계에 고정되지 않습니다.

히트 테스트는 변경되지 않으며 뷰의 기하학에 의해 결정됩니다.

물론, 당신은 이것을 바꾸기 위해 hitTest를 재정의할 수 있습니다.

이제 뷰가 경계를 벗어날 수 있으므로, 계산된 visibleRect는 또한 경계를 넘어 확장할 수 있다.

visibleRect를 사용하는 코드를 검토하고 그에 따라 조정하세요.

이것은 또한 그리기 함수의 dirtyRect 매개 변수에 영향을 미친다.

특히, dirtyRect는 뷰의 경계에 의해 제한되지 않는다.

AppKit은 뷰의 경계보다 큰 dirtyRect를 전달할 권리를 보유합니다.

AppKit은 또한 그림을 필요한 만큼 많은 직사각형으로 세분화할 수 있는 권리를 보유합니다.

이것이 당신에게 의미하는 바는 dirtyRect를 사용하여 그릴 곳이 아니라 무엇을 그릴지 결정해야 한다는 것입니다.

이것은 발생할 수 있는 예상치 못한 도면 결과의 예이다.

이 그리기 재정의는 dirtyRect에서 전달된 것을 배경색으로 채우고, 채우기가 뷰의 경계 밖으로 유출되어 창의 다른 UI를 덮습니다.

그 뷰는 프레임을 그리기 위해 dirtyRect를 사용하지 않는다.

마찬가지로, 배경 채우기는 당신의 디자인이 요구하는 것을 정확하게 채워야 합니다.

dirtyRect 밖에서 그림을 그리는 것은 항상 안전하다.

dirtyRect의 성능 이점은 이 패스에서 그리는 것을 피할 수 있는 데이터의 어느 부분을 결정하는 데 사용될 때 발생합니다.

아마도 이 멋진 스타일로 내 이름의 스트로크 경로를 계산하는 것은 비싸다.

dirtyRect가 이 작은 구석이라면, 텍스트 프레임과 교차하지 않으므로, 보기는 값비싼 계산을 피할 수 있습니다.

배경과 프레임을 그리는 것은 여전히 필요하지만, AppKit이 그림을 dirtyRect로 클립하기 때문에 전체 경계를 채우고 이 패스에서 전체 프레임을 그리는 것은 뷰의 다른 이미 그려진 부분에 영향을 미치지 않습니다.

새로운 NSView .clipsToBounds 속성은 OS X Mavericks 10.9로 거슬러 올라간다.

하지만, 오래된 OS에서 .clipsToBounds를 끄는 것은 거친 모서리를 가질 수 있습니다.

그에 따라 시험해봐.

대부분의 뷰는 클리핑을 켜고 끄면 모두 잘 작동할 것이다.

일부 컨테이너 뷰는 그들만의 명시적인 결정을 내린다.

그 이름에 충실한 NSClipView는 이런 식으로 행동한다.

뷰의 기본 클리핑 동작에 동의하지 않고 선택적으로 변경해야 하는 특정 사례가 있을 수 있습니다.

자신의 견해 중 명시적인 clipsToBounds 값을 요구하는 것을 사례별로 고려하십시오.

올바른 선택은 앱에 대한 당신의 비전을 실현하는 선택입니다.

이제 이미지에 대해 이야기하기 위해 아심으로 돌아가세요.

아심: 고마워 롤리.

기호는 앱을 디자인하는 데 필수적인 부분입니다.

macOS 소노마에서, 기호는 새로운 기능, 기호 효과를 얻는다.

기호 효과를 사용하면 기호는 이제 바운스, 대체 전환 및 펄스 애니메이션과 같은 효과를 가질 수 있습니다.

기호 효과는 앱에서 발생한 작업이나 상태 변경을 강조하는 좋은 방법입니다.

심볼 효과를 추가하는 것은 간단하다.

먼저, imageView의 이미지 속성을 심볼 이미지로 설정하세요.

그런 다음, 효과를 원할 때, 이미지 보기에 addSymbolEffect를 호출하기만 하면 됩니다.

이것은 NSImageView가 심볼 이미지를 사용하는 경우에만 작동한다는 점에 유의하십시오.

기호 효과 사용에 대한 자세한 정보는 "앱에서 기호 애니메이션" 비디오를 확인하세요.

macOS Ventura에서, 우리는 사용자의 현재 로케일에 자동으로 적응하기 위해 SF 심볼에 대한 지원을 도입했습니다.

이제 macOS 소노마에서 자산 카탈로그 이미지와 기호는 동일한 기능을 제공합니다.

macOS Ventura의 SF 기호와 마찬가지로, 그들은 기본적으로 시스템 로케일을 따른다.

이미지 로케일 방법을 사용하여 고정된 로케일로 이미지를 얻으세요.

다음으로, 하이 다이내믹 레인지 콘텐츠 또는 줄여서 HDR에 대해 이야기하겠습니다.

HDR 콘텐츠는 표준 콘텐츠를 훨씬 뛰어넘는 조명 수준을 표현할 수 있다.

macOS는 여러 릴리스에서 확장된 다이내믹 레인지를 지원하여 Macbook Pro의 Liquid Retina XDR 및 Pro Display XDR과 같은 디스플레이를 최대한 활용할 수 있습니다.

macOS Sonoma를 사용하면 HDR 콘텐츠를 지원하는 NSImageView를 통해 앱에서 HDR 콘텐츠를 그 어느 때보다 쉽게 표시할 수 있습니다.

HDR 콘텐츠가 포함된 이미지는 이제 확장된 다이내믹 레인지 지원 하드웨어에서 HDR로 표시됩니다.

HDR 콘텐츠를 표준 다이내믹 레인지로 표시하려면, preferredImageDynamicRange 속성을 사용하여 재정의하십시오.

이 API 채택에 대한 자세한 정보는 "앱에서 HDR 이미지 지원" 비디오를 확인하세요.

Xcode 15부터 자산 카탈로그의 이미지와 색상은 NSImage 및 NSColor의 정적 속성으로 코드에 자동으로 반영됩니다.

이를 통해 문자열로 초기화하는 대신 깨끗한 점 표기법을 사용하여 이미지에 액세스할 수 있습니다.

이미지는 선택 사항이 아니므로, 강제 풀기 또는 가드 검사를 제거할 수도 있습니다.

이미지의 이름을 제거하거나 바꾸기 위해 자산 카탈로그를 수정하면, 컴파일러는 코드와의 불일치를 포착하고 앱을 빌드할 때 오류를 생성하여 나중에 런타임에 잡는 대신 즉시 수정할 수 있습니다.

macOS 소노마는 타이핑 경험에 상당한 변화와 영어가 아닌 언어의 텍스트 레이아웃을 개선했습니다.

그것은 현재 악센트 색상에 적응하는 새로운 삽입 표시기로 시작하고, 텍스트를 지시할 때 후행 빛을 남깁니다.

다음으로, 입력 모드, 받아쓰기 상태 및 caps lock 상태와 같은 주요 정보를 표시하는 삽입 표시기 아래에 커서 액세서리가 있습니다.

액세서리는 현재 삽입 위치를 추적하고 삽입 위치가 보이는 보기 밖에 있는 경우 문서 하단에 고정됩니다.

표준 AppKit 텍스트 뷰를 사용하는 앱은 이것을 자동으로 얻을 것이다.

사용자 지정 텍스트 보기가 있다면, 당신이 채택할 수 있는 새로운 API가 있습니다.

사용자 지정 텍스트 삽입 표시기 그림을 NSTextInsertionIndicator 보기로 바꿀 수 있습니다.

이 보기를 사용자 지정 텍스트 보기의 하위 보기로 추가하면 OS 전반에 걸쳐 일관된 새로운 삽입 표시기를 얻을 수 있습니다.

삽입 표시기의 프레임과 그것이 보이는지 여부를 업데이트하는 것을 담당할 것입니다.

표시기를 숨기기 위해 텍스트 보기가 첫 번째 응답자를 사임할 때 displayMode 속성을 숨기도록 업데이트하십시오.

MacOS Sonoma는 영어가 아닌 언어의 텍스트 레이아웃을 몇 가지 개선했습니다.

일부 언어는 텍스트 컨텍스트에 따라 줄 바꿈에 대한 규칙이 다르기 때문에 중요한 하이라이트는 래핑과 하이픈에 대한 변경 사항입니다.

예를 들어, 한국어의 전통적인 조판에서, 본문 텍스트는 단어 중간에 줄 바꿈이 있을 수 있지만, 제목 텍스트는 단어 경계에서만 래핑됩니다.

제목의 단어를 깨는 것은 한국어로 거슬리게 느껴질 수 있다.

지도의 이 시트에서, "시간"에 대한 한국어 단어는 두 줄로 나뉜다.

macOS 소노마는 이제 사용된 텍스트 스타일 글꼴에 따라 다른 줄 바꿈을 수행합니다.

한국어에서, 이 시트와 같은 제목과 헤드라인 텍스트 스타일은 단어 경계에서 래핑되지 않습니다.

본문 텍스트 스타일은 적절한 경우 단어 내에서 줄 바꿈을 가질 수 있습니다.

여기 또 다른 예가 있습니다.

좁은 레이아웃에서, 일부 독일어 단어는 전체 줄 너비보다 길 수 있으며, 이로 인해 개별 문자가 다음 줄로 유출될 수 있습니다.

이 포장은 이상적이지 않다.

그것은 불균형해 보이며, 형태소라고 불리는 단어의 구성 요소가 선으로 나뉘어져 있다.

macOS 소노마에서 하이픈이 비활성화된 제목 텍스트 필드가 있는 경우, macOS는 문자 포장 대신 형태소 경계에서 텍스트를 자동으로 하이픈합니다.

그 결과 레이아웃은 더 균형 잡히고 읽기 쉽다.

앱에서 텍스트 스타일을 채택하기에 좋은 시기입니다.

macOS Sonoma에서 AppKit은 Swift 동시성 및 전송 가능과 같은 Swift 우선 기능을 더 쉽게 채택할 수 있도록 업데이트되었습니다.

SwiftUI는 또한 AppKit 앱의 더 많은 장소에서 SwiftUI 보기와 수정자를 사용할 수 있도록 업데이트되었습니다.

대부분의 AppKit 클래스는 메인 스레드로 제한됩니다.

스위프트 동시성에서, 이 클래스들은 적절한 컴파일러 오류를 생성하기 위해 주요 행위자로 표시됩니다.

그러나, AppKit에는 메인 스레드 외부에서 안전하게 액세스할 수 있는 NSColor 및 NSShadow와 같은 특정 클래스가 있습니다.

macOS 소노마에서, 이 클래스들은 전송 가능한 프로토콜을 준수하며, 이는 액터 경계를 넘어 자유롭게 전송될 수 있음을 나타냅니다.

전송 가능은 객체가 어떻게 직렬화되고 역직렬화될 수 있는지 설명하는 스위프트 프로토콜이다.

이것은 SwiftUI에서 드래그 앤 드롭 및 공유와 같은 기능을 강화합니다.

macOS Sonoma NSImage, NSColor 및 NSSound는 전송 가능한 프로토콜을 준수합니다.

이를 통해 AppKit 앱은 SwiftUI 뷰에서 드래그 앤 드롭 또는 공유와 같은 기능을 더 쉽게 채택할 수 있습니다.

macOS Ventura 13.3에서, 우리는 NSViewController, ViewLoading을 위한 새로운 속성 래퍼를 도입했습니다.

loadView에서 초기화된 속성에서 ViewLoading을 사용하세요.

이러한 속성이 이전에 선택 사항이었다면, 선택 사항과 관련 검사를 제거할 수 있습니다.

뷰 컨트롤러는 loadViewIfNeeded를 호출하여 속성이 초기화되었는지 확인합니다.

유사한 속성 래퍼인 WindowLoading은 NSWindowController의 속성에서도 사용할 수 있습니다.

Xcode 15를 사용하면 이제 미리보기를 사용하여 AppKit 보기와 보기 컨트롤러를 표시할 수 있습니다.

새로운 미리보기 매크로를 사용하고, 이름을 제공하고, 뷰 또는 뷰 컨트롤러를 반환하세요.

코드를 변경할 때 미리보기는 최신 상태로 유지됩니다.

자세한 내용은 "Xcode Previews로 프로그래밍 방식 UI 구축" 비디오를 확인하세요.

NSHostingView와 NSHostingController는 SwiftUI를 AppKit 앱에 점진적으로 채택할 수 있는 좋은 방법입니다.

macOS Sonoma에는 더 많은 곳에서 SwiftUI를 채택할 수 있는 몇 가지 새로운 기능이 있습니다.

도구 모음과 탐색 제목과 같은 SwiftUI 수정자는 이제 NSWindows에서 작동합니다.

hostingView가 창의 contentView인 경우, SwiftUI는 사용 가능한 모든 장면 수정자를 NSWindow에 자동으로 연결합니다.

더 많은 제어를 위해, NSHostingView와 NSHostingController에 새로운 속성인 sceneBridgingOptions가 있습니다.

이를 사용하면 SwiftUI 보기에서 NSWindow로 연결해야 하는 속성을 명시적으로 명시할 수 있습니다.

그것은 macOS 소노마의 AppKit의 새로운 기능 중 일부일 뿐입니다.

다음은 뭐야?

먼저, macOS Sonoma SDK를 사용하여 앱을 컴파일하고 클리핑 및 활성화의 변경 사항이 원치 않는 부작용을 일으키지 않도록 감사하십시오.

다음으로, 새로운 전체 높이 검사기와 새로운 테이블 열 사용자 지정 API와 같은 새로운 컨트롤 API를 채택하십시오.

macOS 소노마의 심볼 효과를 활용하기 위해 앱의 디자인을 업데이트하세요.

그리고 마지막으로, NSHostingView의 전송 가능 및 개선과 같은 새로운 Swift에 초점을 맞춘 AppKit 추가 기능을 사용하여 앱의 더 많은 곳에서 SwiftUI를 채택하십시오.

봐줘서 정말 고마워.

우리는 당신이 macOS Sonoma의 모든 새로운 기능을 즐기기를 바랍니다!

♪ ♪