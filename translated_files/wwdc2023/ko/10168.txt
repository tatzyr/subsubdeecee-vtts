10168

♪ ♪

소피아: 안녕하세요, "파라미터 팩으로 API 일반화"에 오신 것을 환영합니다.

제 이름은 소피아이고, 저는 스위프트 컴파일러 팀에서 일합니다.

오늘 저는 스위프트 매개 변수 팩과 일반 프로그래밍으로 새로운 차원의 유연성을 제공하는 방법에 대해 이야기할 것입니다.

이것은 고급 대화이며, 기존 제네릭 시스템을 기반으로 한다.

이 주제에 익숙하지 않다면, WWDC22의 "Embrace Swift generics"를 보는 것이 좋습니다.

오늘, 저는 매개 변수 팩이 해결할 수 있는 문제의 유형, 라이브러리에서 발생할 때 매개 변수 팩에 대해 생각하는 방법을 안내할 것이며, 마지막으로 매개 변수 팩을 활용하는 자체 코드를 구현하는 방법에 대해 자세히 알아보겠습니다.

매개 변수 팩에 뛰어들기 전에, 그것들이 왜 존재하는지 아는 것이 중요하다.

그래서 나는 제네릭과 variadics에 대해 조금 이야기하는 것으로 시작할 것이다.

당신이 쓰는 코드는 기본적으로 두 가지 범주로 구성되어 있습니다: 값과 유형.

다른 값을 매개 변수로 받아들이는 함수를 작성하여 값을 추상화할 수 있습니다.

예를 들어 라디안(from:) 함수는 입력으로 학위를 나타내는 이중 값을 받아들이고 출력을 위해 라디안을 나타내는 새로운 이중 값을 반환할 수 있습니다.

매개 변수에 대해 다양한 유형을 허용하는 일반 코드를 작성하여 유형을 추상화할 수 있습니다.

예를 들어, 표준 라이브러리 어레이 유형은 당신이 채우고 싶은 모든 형태의 데이터를 보유하도록 설계되었습니다.

배열의 주어진 인스턴스에 사용할 구체적인 유형의 자리 표시자인 요소 유형 매개 변수가 있습니다.

두 경우 모두, 구체적인 가치나 구체적인 유형은 추상화에 대한 주장으로 전달된다.

대부분의 일반 코드는 유형과 값 모두에 대한 추상화이다.

이것을 탐구하기 위해, 나는 서버에 쿼리를 보내기 위한 코드를 작성할 것이다.

기본 구현은 일부 페이로드 유형의 요청을 받은 다음, 이를 서버에 쿼리로 전달하고, 마지막으로 페이로드 유형의 서버 응답을 반환합니다.

이 함수에는 하나의 매개 변수가 있지만, 같은 호출에서 여러 요청을 쿼리하는 것을 지원하고 싶습니다.

다양한 수의 인수를 가질 수 있는 능력을 위해, 우리는 가변적인 매개 변수를 가지고 있다.

가변 매개 변수는 함수가 단일 유형의 인수를 유연하게 받아들일 수 있게 해준다.

하지만 가변적인 매개 변수에는 한계가 있다.

예를 들어, 주어진 인수를 길이가 인수 수와 같은 튜플에 매핑하고 싶을 수도 있습니다.

그러나, 가변적인 매개 변수를 사용하면, 인수 길이를 기반으로 하는 반환 유형을 선언할 방법이 없습니다.

또한 가변 매개 변수가 유형 삭제를 사용하지 않고 다양한 유형을 받아들일 수 있는 방법이 없으므로 각 인수의 특정 정적 유형 정보를 보존할 방법이 없습니다.

우리가 제네릭 시스템과 가변 매개 변수에서 부족한 것은 유형 정보를 보존하고 인수의 수를 변경할 수 있는 능력이다.

오늘날, 이것을 하는 유일한 방법은 당신이 지지하는 인수 수의 상한선을 선택하도록 강요하는 과부하를 하는 것이다.

두 가지 매개 변수가 충분할까요? 아마 아닐 거야.

최대 세 개의 매개 변수를 처리하는 것이 더 낫다.

하지만 우리가 네 개를 원한다면?

이 오버로드 패턴과 그 한계는 개념적으로 다양한 수의 유형 매개 변수를 처리하는 API에 널리 퍼져 있다.

이 접근 방식은 중복성의 단점을 가지고 있지만, 더 중요한 것은, 지원될 인수의 수에 대한 임의의 상한선을 선택하도록 강요한다는 것이다.

선택된 한도를 초과하면 추가 인수에 대한 컴파일러 오류가 발생합니다.

이것은 매개 변수 팩이 해결하는 종류의 문제이다.

만약 당신이 이 과부하 패턴에 빠지는 것을 발견한다면, 그것은 당신이 매개 변수 팩을 사용하고 싶다는 강력한 신호입니다.

스위프트 5.9에서 제네릭 시스템은 "파라미터 팩"이라는 새로운 구성으로 인수 길이에 대한 추상화에 대한 일류 지원을 얻고 있다.

이제 API에서 매개 변수 팩을 볼 때 어떤 의미인지에 대해 이야기할 것입니다.

코드에서, 대부분의 경우, 당신은 단일 유형이나 값으로 작업합니다.

매개 변수 팩은 모든 양의 유형이나 값을 저장할 수 있으며 함께 포장하여 함수에 인수로 전달할 수 있습니다.

개별 유형을 수용하는 팩을 타입 팩이라고 한다.

예를 들어, Bool, Int 및 String의 세 가지 개별 유형을 수용하는 유형 팩을 가질 수 있습니다.

개별 가치를 지닌 팩은 가치 팩이라고 불린다.

예를 들어, 세 가지 개별 값을 보유하는 값 팩을 가질 수 있습니다: true, 숫자 10, 그리고 빈 문자열.

타입 팩과 밸류 팩은 함께 사용됩니다.

유형 팩은 가치 팩의 각 개별 가치에 대해 각 개별 유형을 제공합니다.

해당 유형과 값은 각각의 팩에서 같은 위치에 있다.

위치 0에서, true 값의 유형은 Bool이다.

위치 1에서, 정수 리터럴 10의 유형은 Int이다.

그리고 위치 2에서, 빈 문자열 리터럴의 유형은 문자열이다.

매개 변수 팩을 사용하면 팩의 모든 개별 요소와 함께 작동하는 하나의 일반 코드를 작성할 수 있습니다.

이 개념은 스위프트에서 컬렉션을 사용할 때 다른 개별 요소와 함께 작동하는 하나의 코드를 작성하는 데 이미 익숙하기 때문에 친숙하게 들릴 수 있습니다.

당신이 그러한 코드를 작성하는 방식은 반복을 통해서입니다.

예를 들어, for-in 루프의 본문은 배열의 각 개별 요소에서 작동합니다.

매개 변수 팩을 컬렉션과 다르게 만드는 것은 팩의 각 요소가 다른 정적 유형을 가지고 있으며, 유형 수준에서 팩으로 작업할 수 있다는 것입니다.

일반적으로, 각 괄호 안에 유형 매개 변수를 선언하여 다른 구체적인 유형에서 작동하는 일반 코드를 작성합니다.

스위프트 5.9에서는 "각각"이라는 키워드로 유형 매개 변수 팩을 선언할 수 있습니다.

단일 유형 매개 변수를 갖는 대신, 이 함수는 쿼리하려는 각 페이로드 유형을 허용합니다.

이것은 유형 매개 변수 팩이라고 불린다.

유형 팩과 값 팩의 이름을 자연스럽게 읽으려면, "각 페이로드"가 아닌 "각 페이로드"와 같은 단일 명명 규칙을 사용하세요.

매개 변수 팩을 사용하는 일반 코드는 반복 패턴을 사용하여 각 페이로드에서 개별적으로 작동할 수 있습니다.

반복 패턴은 '반복' 키워드를 사용하여 표현되며, 패턴 유형이라는 유형이 뒤따른다.

패턴은 팩 요소에 대한 하나 이상의 참조를 포함할 것이다.

'반복'은 주어진 인수 팩의 모든 요소에 대해 패턴 유형이 반복될 것임을 나타냅니다.

'각각'은 모든 반복에서 개별 팩 요소로 대체되는 자리 표시자 역할을 한다.

이 교체품이 Bool, Int 및 String이 포함된 콘크리트 타입 팩에서 어떻게 작동하는지 봅시다.

패턴은 세 번 반복되며 자리 표시자 '각 페이로드'는 각 반복 중에 팩의 콘크리트 유형으로 대체됩니다.

결과는 쉼표로 구분된 유형 목록입니다: Bool 요청, Int 요청 및 문자열 요청.

반복 패턴은 쉼표로 구분된 유형 목록을 생성하기 때문에, 쉼표로 구분된 목록을 자연스럽게 받아들이는 위치에서만 사용할 수 있습니다.

여기에는 튜플 유형 또는 단일 유형인 괄호로 묶인 유형이 포함됩니다.

또한, 그것들은 함수 매개 변수 목록에서 사용될 수 있으며, 반복 패턴은 일반적인 인수 목록에서 사용될 수 있다.

반복 패턴을 함수 매개 변수의 유형으로 사용하면 함수 매개 변수가 값 매개 변수 팩으로 바뀝니다.

이를 통해 호출자는 임의의 수의 요청 인스턴스를 전달할 수 있으며, 인수 값은 팩으로 수집되어 함수에 전달됩니다.

그것은 매개 변수 팩의 기본 개념과 사용되는 구문을 다룹니다.

다음으로, API의 기능을 단순화하고 확장할 수 있는 방법을 보여주기 위해, 쿼리 API로 돌아가 봅시다.

변수 요청 인수와 해당 반환 유형을 제공하기 위해 여러 일반 오버로드를 추가했습니다.

각 과부하 선언은 예측 가능한 패턴을 따른다.

각 오버로드에는 각각 1, 2, 3, 4개의 유형 매개 변수가 있습니다.

각 오버로드는 각 유형 매개 변수를 매개 변수 목록의 해당 유형에 대한 요청에 매핑합니다.

그리고 각 오버로드는 반환 유형의 각 유형 매개 변수 목록을 포함합니다.

매개 변수 팩을 사용하여, 이 4개의 과부하는 단일 함수로 축소될 수 있다.

먼저 유형 매개 변수 선언, 함수 매개 변수 목록, 그리고 마지막으로 반환 유형을 고려해 봅시다.

각 유형 매개 변수는 유형 매개 변수 팩으로 축소될 수 있습니다.

각 개별 요청 매개 변수는 값 매개 변수 팩으로 축소될 수 있습니다.

그리고 반환 유형은 각 페이로드 유형을 반복하여 구성된 튜플로 축소될 수 있습니다.

이제 원하는 수의 요청 인수를 처리할 수 있는 하나의 쿼리 함수가 있습니다.

함수 매개 변수와 반환 유형은 모두 유형 매개 변수 팩 '각 페이로드'의 종속 유형이기 때문에, 함수의 값 매개 변수 팩의 길이는 항상 반환되는 튜플의 요소 수와 일치한다는 것을 알고 있습니다.

이제 이 API에서 매개 변수 팩을 채택했으므로, 하나의 인수 또는 세 개의 인수 또는 원하는 양으로 이 단일 쿼리 함수를 호출할 수 있습니다.

매개 변수 팩은 모든 인수 길이를 같은 방식으로 처리합니다.

세 가지 논쟁으로 통화에 집중합시다.

구체적인 인수 팩은 콜 사이트의 인수에서 추론된다.

자리 표시자 '각 페이로드'의 모든 구체적인 유형은 인수 목록에서 유형 팩으로 수집됩니다.

그리고 콘크리트 유형 팩은 반환 유형을 생산하기 위해 대체된다.

'각 페이로드'는 매개 변수 목록과 반환 유형에 나타납니다.

콘크리트 타입 팩 "Int, String, Bool"은 두 곳에서 모두 대체되어 패턴이 세 번 반복된다.

결국, 실행되는 코드는 유형 팩의 세 가지 유형 모두에 대한 반복과 같다.

이제 쿼리 API로 돌아가서 매개 변수 팩에 제약 조건을 추가하는 방법을 알아봅시다.

우리의 쿼리 페이로드가 동등해야 한다고 가정해 봅시다.

유형 매개 변수 팩 다음에 콜론과 프로토콜 이름 Equatable을 추가함으로써, 페이로드 팩의 모든 요소는 Equatable을 준수해야 합니다.

더 일반적인 요구 사항은 일반 제네릭과 마찬가지로 '어디' 조항으로 선언될 수 있다.

매개 변수 팩이 0개 이상의 인수를 포함할 수 있다는 것을 기억하면, 이 서버 쿼리 API는 0 인수를 받아들일 특별한 이유가 없다고 생각할 수 있습니다.

다행히도, 최소 인수 길이를 요구하는 간단한 기술이 있다.

이 경우, 나는 그 기능에 할 일을 주기 위해 적어도 하나의 인수를 요구하고 싶다.

이를 달성하기 위해, 유형 매개 변수 팩 앞에 일반 유형 매개 변수와 값 매개 변수 팩 앞에 해당하는 값 매개 변수를 추가합니다.

유형 매개 변수 팩에 대한 모든 제약은 새로운 유형 매개 변수에도 적용되어야 하며, 이 예에서는 Equatable에 부합합니다.

이제 함수 호출자는 적어도 하나의 인수를 제공해야 합니다.

이 시점에서, 우리는 매개 변수 팩이 해결하는 기초와 API에서 읽는 방법을 다루었습니다.

다음으로, 매개 변수 팩을 사용하는 코드를 구현하는 방법을 살펴봅시다.

우리는 매개 변수 팩을 사용하여 서버 쿼리의 구현을 구축할 것입니다.

쿼리 함수는 모든 개별 요소가 유형 팩의 모든 요소에 대한 요청인 값 팩을 받아들입니다.

요청 구조체에는 페이로드라는 단일 유형 매개 변수와 페이로드 인스턴스를 반환하는 평가 방법이 있습니다.

쿼리 함수의 본문은 '항목' 값 팩에서 작동할 것이다.

쿼리 본문 내에서, 나는 가치 팩의 모든 항목에 대한 평가 메소드를 호출하고 싶다.

반복 패턴을 사용하여 이것을 표현할 수 있습니다.

반복 패턴은 유형 수준과 값 수준에서 동일한 구문을 사용하여 표현됩니다.

값 수준에서, '반복' 키워드 뒤에 패턴 표현식이 따른다.

패턴 표현은 하나 이상의 가치 팩을 포함할 것이다.

팩은 포함된 모든 값을 통해 반복되며, 표현식은 값당 한 번 평가됩니다.

튜플에 포함된 모든 평가 결과 목록을 생성하려면, 패턴 표현식을 괄호로 묶을 수 있습니다.

함수에 전달된 값 팩이 비어 있다면, 결과는 빈 튜플이 될 것이다.

값 팩에 단일 요소가 있다면, 결과는 또 다른 단일 값이 될 것이다.

값 팩에 여러 요소가 있다면, 결과는 튜플이 될 것이다.

그리고 그게 다야.

이제, 우리는 결과의 값 팩을 받아들이고, 모든 개별 요청을 평가하고, 모든 요청의 결과를 튜플에서 함께 반환하는 쿼리 함수를 가지고 있습니다.

이것은 코드에서 매개 변수 팩을 사용하는 방법의 기초입니다.

이것은 매개 변수 팩이 아닌 여러 오버로드를 사용한 이전 예제보다 훨씬 적은 코드이며, 그 버전에는 구현조차 없었다.

유지 보수가 더 쉽고, 반복적인 코드 패턴에서 종종 발생하는 오류는 사라졌다.

이제 좀 더 유연성을 추가해 봅시다.

쿼리 API가 상태를 저장할 수 있도록 하고, 각 요청 평가가 다른 입력 및 출력 유형을 갖도록 허용하고, 매개 변수 팩 반복 중에 제어 흐름을 관리하기 위해 예제를 리팩토링할 것입니다.

평가자 구조체 내부의 쿼리 함수를 이동하고 쿼리 메서드에서 평가자 유형으로 유형 매개 변수 팩을 들어 올릴 것입니다.

평가자 구조체는 요청 팩을 괄호로 묶어 튜플 값으로 만들어 저장된 속성에 저장할 수 있습니다.

구체적인 페이로드 유형 인수 팩을 감안할 때, '항목' 변수는 단일 요청이거나 모든 요청의 튜플이 될 것이다.

다음으로, 요청을 구조체에서 출력이라는 관련 유형이 있는 프로토콜로 변경하겠습니다.

그리고 나는 입력이라는 요청 프로토콜에 또 다른 관련 유형을 추가할 것이다.

그런 다음 요청의 평가 방법을 업데이트하여 인수를 프로토콜의 입력 유형으로 만들 것입니다.

이것은 메서드의 반환 유형이 인수 유형과 다를 수 있게 해준다.

이 후, 나는 평가자를 업데이트하여 모든 페이로드 유형이 요청을 준수하도록 요구하고 그에 따라 '항목' 저장된 속성을 이제 단순히 '각 페이로드' 유형으로 업데이트합니다. 그러나, 이 시점에서, 평가자의 유형 매개 변수 팩의 "페이로드"라는 이름은 실제로 맞지 않는다.

페이로드는 더 이상 요청에 포함된 것이 아니라 대신 요청 전체를 준수합니다.

따라서, 우리는 페이로드의 이름을 Request로 변경하고 프로토콜의 이름을 RequestProtocol로 변경할 것입니다.

쿼리 메서드는 이제 각 요청의 입력 유형의 팩을 수락할 수 있으며, 각 요청의 출력 유형 목록을 반환합니다.

마지막으로, 쿼리 메소드에 대한 새로운 매개 변수 '입력'은 모든 항목의 평가 메소드에 대한 호출에 전달되어야 합니다.

이제 우리는 쿼리에 포함하는 데이터 유형과 서버의 응답에서 다른 유형을 반환할 수 있습니다.

메서드의 값 인수 팩의 길이가 반환되는 값 팩의 길이와 일치한다는 것을 알 수 있습니다. 왜냐하면 그들의 유형은 둘 다 평가자의 유형 팩을 기반으로 하기 때문입니다.

저장된 속성 '항목'의 인수 길이도 마찬가지입니다.

매개 변수 팩을 사용하는 것이 반복의 한 형태라는 점을 감안할 때, 반복에서 일찍 종료하고 싶다면 제어 흐름에 대해 궁금해할 수 있습니다.

아마도 쿼리 모음의 결과는 모든 쿼리가 성공한 경우에만 효력을 발휘해야 할 것이다.

던지기 오류는 이것을 위해 사용될 수 있다.

우리의 예에서, 당신은 RequestProtocol의 평가 방법을 던지기 함수로 업데이트하고 평가자의 쿼리 방법의 반환 유형을 선택 사항으로 수정할 수 있습니다.

쿼리 메서드의 본문을 do-catch 문으로 이동하여 do 절 내에 반환 문을 배치하고 catch 절에서 nil을 반환할 수 있습니다.

이제 필요한 경우 모든 개별 쿼리의 평가는 모든 쿼리에 대한 반복을 중단할 수 있습니다.

이 세션에서, 우리는 매개 변수 팩이 일반 코드의 인수 수뿐만 아니라 유형을 추상화할 수 있는 방법에 대해 이야기했습니다.

우리는 이전에 수많은 과부하가 필요했던 단일 일반 구현을 작성하여 코드의 제한을 단순화하고 제거하기 위해 매개 변수 팩을 사용하는 방법을 살펴보았다.

마지막으로, 우리는 매개 변수 팩을 활용하면서 서버에 쿼리를 보내는 것을 구현하기 위한 코드를 작성했습니다.

제네릭에 대해 자세히 알아보려면, WWDC22의 "Embrace Swift generics" 세션을 확인하세요.

그리고 프로토콜과 유형 삭제에 대해 자세히 알아보려면, WWDC22의 "스위프트에서 프로토콜 인터페이스 설계" 세션을 확인하세요.

스위프트 매개 변수 팩은 일반적인 일반 패턴을 단순화하는 동시에 일반 코드에서 가능한 것을 확장할 수 있는 강력한 도구입니다.

우리는 네가 그들과 함께 무엇을 만드는지 빨리 보고 싶어.

봐줘서 고마워.