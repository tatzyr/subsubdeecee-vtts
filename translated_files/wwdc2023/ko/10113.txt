10113

♪ 부드러운 기악 힙합 ♪

♪

안녕하세요, 제 이름은 마크이고, 저는 SwiftUI 엔지니어입니다.

SwiftUI를 사용하여 비행기에서 우주로의 여행에 당신을 초대하게 되어 기쁩니다.

SwiftUI가 새로운 차원에서 어떻게 작동하는지 시연하고, SwiftUI와 RealityKit이 시스템에서 어떻게 함께 작동하여 놀라운 경험을 가능하게 하는지 보여주기 위해, 우리는 우리가 만든 World라는 샘플 앱을 구동하는 소수의 API에 대해 이야기할 것입니다.

세계는 친숙한 창에서 새로운 볼륨에 이르기까지 여러 가지 형태의 응용 프로그램이 시스템에 취할 수 있음을 보여 주며, 제한된 3D 경험을 최대 공간으로 허용하여 무제한 가상 콘텐츠를 표시할 수 있습니다.

이 강연에서 논의할 대부분의 API는 주로 2D 창 앱에 약간의 3D를 추가하든, 전체 공간을 활용하는 몰입형 3D 경험을 만들든, 앱에서 SwiftUI를 사용하여 3D의 영역을 탐색할 수 있는 좋은 방법을 제공하기 때문에 볼륨을 컨테이너로 사용하는 데 집중할 것입니다.

SwiftUI 콘텐츠의 다른 컨테이너에 대해 자세히 알아보려면, "공간 컴퓨팅을 위해 윈도우 앱을 높이세요" 강연과 "SwiftUI로 창 너머로 가세요" 강연을 참조하십시오.

볼륨의 기본 사항을 다루면, 볼륨 뷰와 레이아웃으로 3D 콘텐츠를 만들고 배치하는 방법, SwiftUI 뷰를 새로운 RealityView에 통합하는 방법, 그리고 마지막으로 모든 것을 3D 제스처로 통합하는 방법에 대해 논의할 것입니다.

하지만 우리가 너무 앞서 나가기 전에, 볼륨이 무엇인지, 그리고 그들이 어떻게 우리가 3D의 영역으로 첫 걸음을 내딛는 데 도움이 될 수 있는지에 대해 이야기해 봅시다.

세계는 3D 콘텐츠를 강조하기 위해 볼륨을 사용한다.

이 장면에는 주요 유리창이 없다.

대신 3D 콘텐츠를 앞에 컨트롤 패널이 있는 장면에 직접 배치합니다.

하지만 3D 콘텐츠는 여기 쇼의 스타이다.

볼륨은 고정 스케일 컨테이너를 제공합니다.

당신과의 거리에 따라 동적으로 확장되는 창과 달리, 볼륨은 어떤 거리에서도 동일한 크기를 유지합니다.

볼륨은 수평으로 정렬되어 있으며 모든 각도에서 볼 수 있습니다.

볼륨은 전체 공간을 차지하지 않고도 앱에서 3D 콘텐츠를 표시할 수 있는 좋은 방법이며, 하나를 만드는 것은 믿을 수 없을 정도로 간단합니다.

창 그룹과 같은 새로운 장면을 만들 때 새로운 볼륨 창 스타일을 사용하기만 하면 이러한 모든 기능을 자동으로 얻을 수 있습니다.

이제 볼륨을 설정했으니, 그 안에 콘텐츠를 좀 넣자.

이를 돕기 위해 RealityKit은 자산 로딩 수명 주기의 다른 부분을 처리하는 단계를 제공하면서 USDZ와 같은 풍부한 3D 자산을 쉽게 로드할 수 있는 SwiftUI 뷰인 Model3D라는 새로운 API를 제공합니다.

Model3D를 AsyncImage에 대응하는 것으로 생각하세요.

앱을 원활하게 실행하면서 복잡한 지오메트리를 로드하는 모든 작업을 처리합니다.

Model3D를 사용하여 월드 앱의 다른 모델 중 하나인 달을 보여드리겠습니다.

이제, 저는 이미 프로젝트에 moon USDZ 파일을 추가했고, 그 이름을 Model3D 이니셜라이저에 전달할 수 있습니다.

이제 우리는 모델의 단계를 처리할 수 있다.

이제, 이것은 달의 위상이 아니다.

그것은 실제로 자산의 로딩 상태를 나타내며, 우리가 전환할 수 있는 몇 가지 다른 상태가 있다.

모델이 로드되기 전에, 사용자에게 콘텐츠가 아직 준비되지 않았음을 나타내는 텍스트나 다른 UI를 보여줄 수 있습니다.

나는 여기서 진행 상황을 볼 것이다.

모델이 로드되지 않으면, 오류의 현지화된 설명을 사용하여 오류 메시지를 표시할 수 있습니다.

그리고 모델이 성공하면, 내 UI에서 사용할 수 있다.

이미지와 마찬가지로, 나는 크기 조정 가능한 수정자를 사용하여 레이아웃 시스템에 사용 가능한 공간에 따라 모델의 크기를 조정할 수 있다고 말해야 한다.

그리고 나는 그 모델이 사용 가능한 공간에 맞기를 원하기 때문에, scaledToFit 수정자를 사용할 것이다.

이제 내 앱에 비동기적으로 로드되는 달이 있다.

SwiftUI에서 더 많은 3D 기능을 탐색하기 위해 이 예제를 계속 구축해 봅시다.

월드 앱에 등장하는 다른 모델들을 점검해 봅시다.

나는 그들 모두를 한 번에 일종의 디스플레이로 보여주고 싶다.

우리는 USDZ 파일 표시를 처리하기 위해 방금 작성한 MoonView의 용도를 변경할 수 있습니다.

그냥 이름을 바꾸자.

그리고 로드할 USDZ 파일의 이름을 전달하세요.

이제 나는 하드코딩된 달 문자열을 대체할 수 있다.

이제 천체를 나타내는 데이터 구조를 만들어 봅시다.

내가 각자에게 이름과 사이즈를 줄게.

나는 내 프로젝트에 있는 몇 가지 다른 물체를 나열할 것이다: 지구, 달, 그리고 태양.

이제 ForEach로 HStack의 각 개체를 표시할 수 있습니다.

각 객체에 대해, 객체의 이름을 사용하여 방금 만든 새로운 CelestialObjectView를 사용할 수 있습니다.

개체 크기를 사용하여 프레임 수정자를 사용하여 각 모델의 크기를 변경해 봅시다.

우리의 모델은 전면에서 멋져 보이지만, 우리가 3D에 있다는 것을 기억하세요.

관점의 변화는 우리의 물체가 마치 경계 상자가 세 개 모두 뒤에 있는 비행기와 수평을 이루는 것처럼 뒷면이 정렬되어 있다는 것을 보여준다.

이것은 SwiftUI의 3D 콘텐츠의 기본 정렬입니다.

우리가 그것을 바꾸고 싶다면, 프레임 깊이 수정자에서 사용할 깊이 정렬을 지정할 수 있습니다.

깊이에 사용할 물체의 크기를 전달하고 모델의 앞면이 뒷면 대신 정렬되도록 지정할 수 있습니다.

이제 모든 전망은 대신 앞면이 정렬되어 있다.

이제 나는 각 물건에 라벨을 붙이고 싶다.

나는 각 Model3D에 오버레이를 제공함으로써 그것을 할 수 있다.

내부에서 나는 항상 읽을 수 있도록 유리 배경 효과가 있는 텍스트 라벨을 만들 것이다.

나는 또한 이 라벨들이 모델의 하단에 정렬되도록 만들 것이다, 그래서 나는 콘텐츠를 차단하지 않는다.

디스플레이는 지금까지 멋져 보이지만, 약간 정적으로 느껴진다.

마지막으로, 기하학 효과에 대한 SwiftUI의 새로운 추가 사항 중 일부를 살펴봅시다.

나는 TimelineView를 사용하여 시간의 변화를 애니메이션화할 수 있다.

이제 나는 새로운 Rotation3DEffect를 사용하여 우리의 견해를 약간의 스핀을 줄 것이다.

내가 하나 만들어서 현재 날짜에 따라 스케일 팩터가 있는 각도를 줄게.

그리고 나는 물체들이 y축 주위를 돌게 할 것이다.

그리고 그렇게, 우리는 우리의 물건들이 회전하고 있다.

Model3D는 뷰 계층 구조에서 간단한 자산을 로드하고 표시하는 데 적합합니다.

하지만 더 많은 3D 모델, 장면 또는 경험을 위해, RealityView는 앱에서 RealityKit의 힘을 발휘할 수 있는 SwiftUI의 진입점입니다.

그리고 실제로, World 앱은 RealityView를 사용하여 RealityKit Entity-Component 시스템을 사용하여 더 복잡한 시각화를 분석합니다.

이를 통해 개별 모델과 조명 및 궤도 경로와 같은 고급 렌더링 효과를 렌더링할 수 있습니다.

새로운 RealityView 덕분에, SwiftUI와 RealityKit은 플랫폼에서 함께 진행됩니다.

RealityView와 더 많은 새로운 RealityKit 기능에 대한 자세한 내용은 "RealityKit으로 공간 경험 구축" 및 "RealityKit으로 공간 컴퓨팅 앱 향상"을 참조하십시오.

지금은 새로운 첨부 파일 API를 사용하여 RealityView 내에서 SwiftUI를 최대한 활용할 수 있는 방법에 대해 이야기해 봅시다.

첨부 파일을 사용하면 태그가 지정된 SwiftUI 보기를 RealityView 내에서 사용할 수 있는 엔티티와 페어링할 수 있습니다.

첨부 파일은 특정 엔티티와 관련하여 주석을 추가하거나 어포던스를 편집하는 데 좋습니다.

SwiftUI에서 캔버스 API를 사용했다면, 첨부 파일은 아마 친숙하게 느껴질 것입니다.

첨부 파일과의 주요 차이점은 스냅샷이 아니라 라이브 뷰라는 것이다.

이것은 그들이 상태 변화에 반응하고, 애니메이션을 실행하고, 제스처를 처리할 수 있다는 것을 의미한다.

전 세계에서 내가 가장 좋아하는 장소를 추적하는 마커를 배치할 수 있는 몇 가지 추가 기능을 추가하여 월드 앱 내부의 첨부 파일을 탐색해 봅시다.

지구 보기에서, 나는 각각 이름과 위치가 있는 내가 가장 좋아하는 장소의 배열을 추적하는 상태를 만들었다.

각 장소에 대해, 나는 그 이름으로 텍스트를 만들 수 있다.

그리고 나는 항상 읽을 수 있도록 유리 배경 효과를 줄 수 있다.

그리고 이제 나중에 RealityView에서 참조할 수 있도록 태그를 줄게.

이 태그는 해시 가능한 값이 될 수 있지만, 각 장소에 추가한 고유 식별자를 사용할 것입니다.

이제 내가 지정한 태그를 사용하여 각 첨부 파일 보기를 호스팅하는 엔티티를 찾을 수 있습니다.

이 엔티티를 RealityView 콘텐츠에 추가할 수 있습니다.

그리고 나서 나는 lookAt 기능을 사용하여 지구 표면을 따라 라벨을 배치하고 방향을 정할 수 있다.

우리는 지금 몇 개의 흥미로운 장소를 정확히 지적했다.

하지만 아직 이 앱에 너무 집착하지 말자.

나는 우리가 어떻게 그것을 다음 단계로 끌어올릴 수 있는지에 대한 더 많은 아이디어가 있다.

그래서, 이제 우리는 3D 콘텐츠를 배치하고 첨부 파일을 사용하여 RealityView 내부의 SwiftUI를 최대한 활용하는 방법을 알고 있습니다.

이제 이 모든 콘텐츠와 상호 작용하는 방법에 대해 이야기해 봅시다.

이 플랫폼은 손과 눈을 지원하고 새로운 트랙패드 메커니즘을 통해 이미 익숙한 제스처를 3차원으로 가져옵니다.

이 새로운 기능을 사용하여 월드 앱에 대한 진행 상황을 확장해 봅시다.

우리는 "좋아하는 장소" 확장과 함께 꽤 좋은 일을 하고 있다.

하지만 나는 우리가 계획한 장소의 수에 만족하지 않는다고 생각한다.

지구에서 탭 제스처를 사용하여 더 많은 것을 추가할 수 있는 방법을 만들어 봅시다.

하지만 그것에 뛰어들기 전에, 입력을 위해 엔티티를 구성하는 방법에 대해 이야기해 봅시다.

콘텐츠로 RealityView를 구성하고 있다고 가정해 봅시다.

여기에 나는 이미 지구의 모델을 추가했다.

엔티티 계층 구조는 RealityView 내부의 입력을 수신하기 위해 InputTargetComponent가 필요합니다.

구성 요소가 엔티티에 추가되면, 그 엔티티의 모든 후손은 달리 명시되지 않는 한 입력을 받을 수 있다.

RealityKit에서 CollisionComponent는 엔티티의 대화형 영역의 모양을 정의하는 데 사용됩니다.

표면에서 정확한 상호 작용 지점을 얻을 수 있도록 지구 모델에 구를 사용합시다.

이것이 우리의 엔티티가 RealityView 내에서 SwiftUI 제스처를 처리할 수 있도록 하는 데 필요한 전부입니다.

이 시점에서, 나는 RealityView에 SpatialTapGesture를 추가할 수 있다.

하지만 RealityKit 콘텐츠와 함께 SwiftUI 제스처를 더 쉽게 사용할 수 있도록, 우리는 내 earthEntity를 타겟팅하는 데 사용할 수 있는 targetedToEntity라는 새로운 제스처 수정자를 추가했습니다.

이 엔티티나 그 후손 중 하나에서 탭이 발생하지 않으면, 제스처는 실패할 것이다.

이제 제스처 값을 처리해 봅시다.

SpatialTapGesture는 새로운 location3D 속성을 가지고 있어 지구 표면에서 정확한 탭 포인트를 얻을 수 있습니다.

3D 위치는 미터가 아닌 점의 RealityView의 로컬 SwiftUI 좌표 공간에 있습니다.

새 라벨을 어디에 배치하고 싶은지 알아내려면, 위치를 RealityView의 장면으로 변환해야 합니다.

targetedToEntity 수정자는 제스처의 값 자체에 좌표 공간 변환 도우미를 추가하여 이를 매우 쉽게 만듭니다.

우리는 그것을 사용하여 SwiftUI 로컬 공간에서 장면의 좌표 공간으로 변환할 수 있습니다.

마지막으로, 방금 계산한 위치를 사용하여 새로운 장소에 대한 데이터를 추가할 수 있습니다.

나는 또한 라벨이 지구 표면 위로 약간 뜨도록 위치를 약간 확장할 것이다.

우리는 이제 탭 한 번으로 전 세계에 더 좋아하는 장소를 추가할 수 있는 방법이 있습니다.

하지만 이제 우리는 문제가 있다: 우리는 더 많은 장소를 발견해야 한다!

그렇게 하기 위해, 전 세계에서 더 흥미로운 장소를 고르는 데 도움이 될 수 있는 위성을 발사합시다.

지구에 위성 모델을 추가하는 한 가지 방법은 RealityKit을 사용하여 모델을 로드하는 것이지만, 우리가 배운 다른 기술을 사용합시다.

Model3D를 첨부 파일로 추가할 수 있습니다.

프레임을 지정하면 위성 모델의 크기를 합리적인 크기로 매우 쉽게 조정할 수 있습니다.

나는 또한 내 모델에게 태그를 주어 내 RealityView에서 참조할 수 있도록 할 것이다.

라벨과 마찬가지로, 나는 내 모델을 RealityView에 추가해야 한다.

이제, 위성의 규모, 회전 및 위치를 정의할 수 있는 3D 변환을 반환하는 제스처를 정의해 봅시다.

DragGesture를 사용하여 드래그하는 것으로 시작하겠습니다.

드래그 제스처에서 변환으로 변환하려면, 나는 지도를 사용할 것이다.

DragGesture에는 3D로 조작을 처리할 수 있는 몇 가지 새로운 속성이 있습니다.

DragGesture의 새로운 translation3D 속성을 사용하여 시작된 이래로 드래그가 얼마나 이동했는지 알 수 있습니다.

이제 나는 변형을 만들 것이다.

번역을 이니셜라이저에 전달하고 지도에서 반환할 수 있습니다.

이제 나는 내 위성을 변형시키기 위해 우리가 방금 쓴 조작 제스처를 사용할 수 있다.

나는 제스처가 활성화되었을 때를 추적하기 위해 업데이트 수정자를 사용할 것이다.

나는 이 상태를 사용하여 상호 작용 중에 우리의 모든 라벨을 축소하여 그들이 지구에 대한 우리의 견해를 막지 않도록 할 수 있다.

제스처가 실패하면 내 제스처 상태가 자동으로 재설정된다는 것을 보장하기 때문에 내가 가진 일시적인 제스처 상태를 추적하기 위해 업데이트를 사용하는 것이 중요합니다.

내 제스처 값이 바뀌면, 주의 새로운 변환을 설정한 다음 오프셋 수정자를 사용하여 위성 모델을 배치할 수 있습니다.

나는 또한 봄 애니메이션을 사용하여 변형에 대한 변화를 애니메이션화하여 위성을 놓을 때 원래 위치로 다시 애니메이션화할 것이다.

이제 우리는 위성을 끌고 다닐 수 있다.

이것은 좋은 시작이지만, 우리는 이것을 더 자세히 볼 필요가 있다.

이제 모든 것이 연결 되었으니, 스케일링 액션을 추가해 봅시다.

이를 위해 드래그와 동시에 인식하는 MagnifyGesture를 추가합니다.

나는 또한 사용자 손의 무제한 3D 회전을 측정할 수 있는 새로운 RotateGesture3D를 추가할 것이다.

나는 이 새로운 가치를 우리의 변환에 연결할 것이고, 마지막으로 엔티티의 회전과 규모를 업데이트해야 한다.

나는 이것을 위해 rotation3DEffect와 scaleEffect를 사용할 것이다.

그리고 거기에 우리가 가지고 있어!

우리는 이제 위성 엔티티를 자유롭게 드래그하고, 확장하고, 회전할 수 있다.

우리 위성은 항해할 준비가 된 것처럼 보인다.

우리가 추가한 제스처는 손과의 직접적인 상호 작용, 간접 핀치, 트랙패드 및 접근성 기능을 포함하여 당신이 기대하는 모든 입력 장치와 모드와 함께 작동합니다.

새로운 targetedToEntity 수정자와 함께 친숙한 SwiftUI 제스처를 사용하면 복잡한 엔티티 계층 내에서 상호 작용을 빠르게 구축할 수 있습니다.

우리는 이제 위성으로 지구를 탐험할 준비가 되었지만, 이제 앱에서 SwiftUI의 새로운 3D 기능을 탐험할 때입니다.

볼륨과 전체 공간과 같은 새로운 장면 유형을 사용하면 모든 새로운 방식으로 응용 프로그램이 될 수 있는 것을 고려할 수 있습니다.

SwiftUI의 강력한 레이아웃 및 렌더링 시스템은 SwiftUI가 iOS, macOS, tvOS 및 watchOS뿐만 아니라 완전히 새로운 플랫폼에서도 앱을 구축하는 강력한 방법으로 확장되었습니다.

새로운 첨부 파일 API는 SwiftUI 뷰를 3D 장면에 통합할 수 있는 놀라운 새로운 기회를 열어줍니다.

그리고 마지막으로 우리는 SwiftUI에서 친숙하고 강력한 제스처를 사용하여 사람들에게 말하는 이야기를 손바닥에 넣는 방법을 탐구했습니다.

SwiftUI와 RealityKit 덕분에, 당신은 2D 비행기의 경계를 넘어 흥미진진한 여행을 할 수 있습니다.

그리고 우리는 이제 막 시작했어.

플랫폼에 오신 것을 환영합니다!

♪