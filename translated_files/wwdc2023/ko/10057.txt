10057

♪ ♪

타일러: "UIKit 특성 시스템 해제"에 오신 것을 환영합니다.

저는 UI 프레임워크 엔지니어인 타일러 폭스이며, iOS 17에서 활용할 수 있는 놀라운 새로운 UIKit 기능에 대해 알려드리게 되어 기쁩니다.

우선, 나는 UIKit의 특성 시스템에 대한 기본 사항을 검토할 것이다.

그런 다음 UITraitCollection에 자신의 데이터를 추가하기 위해 사용자 지정 특성을 정의할 수 있는 기능, 앱의 계층 구조에서 특성 재정의를 적용하는 더 쉬운 방법, 특성이 변경될 때 처리하는 더 유연한 방법을 포함하는 새로운 기능과 기능을 안내해 드리겠습니다.

마지막으로, UIKit 특성을 SwiftUI 환경 키와 연결하여 앱의 UIKit과 SwiftUI 구성 요소 간에 데이터를 원활하게 전달하는 방법을 설명하겠습니다.

몇 가지 기본 사항을 검토할 시간이다.

특성은 시스템이 앱의 모든 뷰 컨트롤러와 뷰에 자동으로 전파되는 독립적인 데이터 조각입니다.

UIKit은 사용자 인터페이스 스타일, 수평 크기 클래스 및 선호하는 콘텐츠 크기 범주와 같은 많은 내장 시스템 특성을 제공합니다.

iOS 17에서는 자신만의 사용자 지정 특성도 정의할 수 있습니다.

이것은 앱의 뷰 컨트롤러와 뷰에 데이터를 제공할 수 있는 강력한 새로운 방법을 열어줍니다.

조금 이따가 사용자 지정 특성에 대해 모두 말해줄게.

UIKit에서 특성으로 작업하는 주요 방법은 특성 컬렉션을 사용하는 것입니다.

특성 컬렉션에는 특성과 관련 가치가 포함되어 있다.

iOS 17에는 특성 컬렉션으로 더 쉽게 작업할 수 있는 몇 가지 새로운 API가 있습니다.

먼저, 폐쇄가 필요한 새로운 이니셜라이저가 있다.

그 클로저 안에서, 당신은 값을 설정할 수 있는 가변 특성 컨테이너를 받습니다.

이 가변 컨테이너는 UIMutableTraits라는 새로운 프로토콜을 준수합니다.

폐쇄 내부에서, 나는 사용자 인터페이스 관용구를 전화로 설정하고 수평 크기 클래스를 일반으로 설정했다.

클로저 실행이 완료되면, 이니셜라이저는 클로저 내에서 설정한 모든 특성 값을 포함하는 불변의 UITraitCollection 인스턴스를 반환합니다.

클로저 내부의 원래 특성 컬렉션에서 값을 수정하여 새 인스턴스를 만들 수 있는 새로운 modifyingTraits 방법도 있습니다.

여기서 저는 수평 크기 클래스를 컴팩트로 변경했고, 사용자 인터페이스 스타일에 대한 어두운 값을 입력했습니다.

내가 사용자 인터페이스 관용구를 바꾸지 않았기 때문에, 그것은 내 원래 특성 컬렉션의 전화와 동일하다.

이와 같은 자신만의 특성 컬렉션을 만들 수 있지만, 대부분의 경우 특성 환경에서 특성 컬렉션을 얻습니다.

앱의 특성 환경은 창 장면, 창, 프레젠테이션 컨트롤러, 뷰 컨트롤러 및 뷰입니다.

이러한 특성 환경 각각에는 자체 특성 컬렉션이 있으며, 각 특성 컬렉션은 다른 값을 포함할 수 있습니다.

특성 환경은 특성 계층 구조에 연결되어 있으며, 이는 특성이 앱을 통해 흐르는 방식입니다.

다음은 각 창 장면에서 개별 뷰 컨트롤러 및 뷰에 이르기까지 특성 계층 구조의 트리 구조의 예입니다.

각 특성 환경은 부모 환경으로부터 특성 값을 상속한다.

항상 가능한 가장 구체적인 특성 환경의 특성 컬렉션을 사용하세요.

나는 뷰 컨트롤러와 뷰를 통해 특성이 흐르는 방식에 대해 더 깊이 파고들 것이다.

다음은 자식 뷰 컨트롤러가 포함된 상위 뷰 컨트롤러의 예입니다.

점선은 뷰 컨트롤러 계층 구조를 나타낸다.

부모 컨트롤러는 뷰를 소유하고 있으며, 그들을 연결하는 실선은 그들의 관계를 나타낸다.

부모 뷰에는 하나의 하위 뷰가 있으며, 뷰를 통한 파선은 뷰 계층 구조를 나타냅니다.

마지막으로, 자식 컨트롤러의 뷰는 그 중간 뷰의 하위 뷰이다.

먼저 iOS 17 이전에 뷰 컨트롤러와 뷰를 통해 특성이 어떻게 흘러갔는지 설명하겠습니다.

뷰 컨트롤러는 부모 뷰 컨트롤러에서 직접 특성을 상속받았다.

그리고 뷰 컨트롤러가 소유한 뷰는 뷰 컨트롤러에서 직접 특성을 물려받았다.

마지막으로, 뷰 컨트롤러가 없는 뷰는 슈퍼뷰에서 직접 특성을 물려받았다.

이 동작은 뷰 계층 구조의 특성 흐름이 뷰 컨트롤러가 소유한 각 뷰에서 멈췄다는 것을 의미했다.

예를 들어, 부모 컨트롤러의 관점에서의 특성 값은 직접적인 하위 보기에 의해서만 상속될 것이다.

자식 컨트롤러의 뷰는 그 뷰 아래의 뷰 계층 구조의 하위 뷰임에도 불구하고 그 값을 받지 못할 것이다.

이 행동은 놀라울 수 있다.

iOS 17에서 우리는 뷰 컨트롤러와 뷰의 특성 계층 구조를 통합하여 이 문제를 제거했습니다.

뷰 컨트롤러는 이제 부모 뷰 컨트롤러에서 직접가 아닌 뷰의 슈퍼뷰에서 특성 컬렉션을 상속합니다.

이것은 뷰 컨트롤러와 뷰를 통해 특성의 간단한 선형 흐름을 만든다.

뷰 컨트롤러가 여전히 부모 뷰 컨트롤러의 특성을 어떻게 상속하는지 주목하세요, 그것은 그들 사이의 뷰를 통해 간접적으로 발생합니다.

뷰 컨트롤러는 이제 뷰 계층 구조에서 특성을 상속하기 때문에, 뷰 컨트롤러의 뷰는 뷰 컨트롤러가 업데이트된 특성을 받을 수 있도록 계층 구조에 있어야 합니다.

결과적으로, 뷰가 계층 구조에 추가되기 전에 뷰 컨트롤러의 특성 컬렉션에 액세스하면, 뷰 컨트롤러는 특성에 대한 최신 값을 갖지 않습니다.

영향을 받는 코드를 찾을 수 있는 가장 일반적인 장소는 viewWillAppear 내부입니다. 이는 뷰가 계층 구조에 추가되기 전에 항상 호출되기 때문입니다.

대신 사용할 수 있는 viewIsAppearing이라는 새로운 콜백이 있습니다.

viewIsAppearing은 뷰가 계층 구조에 추가되고 뷰 컨트롤러와 뷰 모두 최신 특성 컬렉션을 갖게 되면 viewWillAppear 후에 호출됩니다.

viewIsAppearing은 오늘 viewWillAppear를 사용하는 거의 모든 경우에 대한 대체품입니다.

그리고 가장 좋은 점은 이 새로운 방법이 iOS 13까지 다시 배포된다는 것이다.

"UIKit의 새로운 기능"을 보고 이 새로운 콜백과 그것이 뷰 컨트롤러 수명 주기에 어떻게 맞는지에 대해 자세히 알아보세요.

iOS 17은 또한 뷰 특성 업데이트의 일관성과 성능을 향상시킵니다.

뷰는 계층 구조에 있을 때만 특성 컬렉션을 업데이트합니다.

그리고 계층 구조에 들어가면, 각 보기는 레이아웃을 수행하기 직전에 특성 컬렉션만 업데이트합니다.

가장 좋은 방법은 레이아웃 중에 특성을 사용하는 것이다.

뷰의 경우, 그것은 layoutSubviews 메소드 내부에서 traitCollection을 사용하는 것을 의미합니다.

layoutSubviews는 setNeedsLayout이 뷰에서 호출될 때마다 다시 실행되므로, 여러 번 호출되는 경우 구현이 중복 작업을 피해야 합니다.

사용자 지정 특성은 iOS 17의 강력한 새로운 기능입니다.

그들은 당신이 뷰 컨트롤러와 뷰에 데이터를 제공할 수 있는 완전히 새로운 방법을 열어줍니다.

앱에서 데이터로 작업할 때, 새로운 사용자 지정 특성을 정의할 시기를 결정하는 데 도움이 되는 다음 사항을 고려하십시오.

특성은 부모 뷰 컨트롤러에서 여러 자식 뷰 컨트롤러 또는 슈퍼뷰에서 모든 하위 뷰와 같은 많은 자식에게 데이터를 전파해야 할 때 훌륭한 선택입니다.

또한 특성을 사용하여 직접 연결되지 않은 많은 레이어가 중첩될 수 있는 다른 구성 요소에 데이터를 전달할 수 있습니다.

특성은 계층 구조를 통해 상속되기 때문에, 포함된 뷰 컨트롤러에 대한 정보를 제공하는 것과 같이 환경에 대한 뷰와 뷰 컨트롤러에 컨텍스트를 제공할 수 있습니다.

특성 시스템은 강력하지만, 데이터를 전파하는 데 사용하는 것은 자유롭지 않다.

최상의 성능을 위해, 가치를 더할 때 특성을 사용하되, 데이터를 직접 쉽게 전달할 수 있을 때 특성을 사용하지 마십시오.

이제 첫 번째 사용자 지정 특성을 정의할 준비가 되었습니다.

내 앱에 설정 화면이 있고, 내 설정 보기 컨트롤러 안에 뷰가 포함되어 있는지 여부를 나타내는 특성을 구현하고 싶다고 상상해 보세요.

나는 단지 몇 줄의 코드로 사용자 지정 특성을 정의할 수 있다.

시작하기 위해, 저는 새로운 구조를 선언하고 UITraitDefinition 프로토콜을 준수합니다.

나는 필요한 정적 속성인 defaultValue를 구현한다.

이것은 값이 설정되지 않았을 때 특성의 기본값입니다.

각 특성 정의에는 defaultValue에서 추론되는 관련 값 유형이 있습니다.

이 경우, false의 기본값을 할당하고 있기 때문에, 이 특성의 값의 유형은 Bool로 추론됩니다.

이전에 SwiftUI에서 사용자 지정 환경 키를 정의한 적이 있다면, 이것은 매우 친숙하게 느껴질 것입니다.

특성을 정의하면, UITraitCollection 및 UIMutableTraits의 새로운 API와 함께 즉시 사용할 수 있습니다.

당신은 그 특성을 가치를 얻고 설정하는 데 사용하는 열쇠로 생각할 수 있습니다.

새로운 UITraitCollection 이니셜라이저 내에서 UIMutableTraits의 첨자 연산자를 사용하여 특성 값을 설정할 수 있습니다.

그런 다음 UITraitCollection의 첨자 연산자를 사용하여 특성의 값을 다시 읽을 수 있습니다.

두 개의 간단한 확장을 추가하면 모든 시스템 특성과 마찬가지로 표준 속성 구문을 사용하여 이 특성에 액세스할 수 있습니다.

여기서 저는 불변의 UITraitCollection 클래스의 확장에서 읽기 전용 속성을 선언했습니다.

그리고 나서 나는 UIMutableTraits 프로토콜의 확장에서 읽기-쓰기 속성을 선언했다.

이제 이러한 매우 간단한 확장을 추가했으므로, 표준 속성 구문을 사용하여 모든 곳에서 내 특성에 액세스할 수 있습니다.

자신만의 사용자 지정 특성을 정의할 때 항상 이러한 확장을 작성하세요.

나는 또 다른 관습적인 특성에 대한 아이디어가 있다.

내 앱에서 사용자 지정 색상 테마에 대한 지원을 구축하고 있다고 상상해 보세요.

내 앱이 지원하는 네 가지 색상 테마를 나타내는 MyAppTheme이라는 열거형을 가지고 있다.

내가 가장 먼저 할 일은 UITraitDefinition 프로토콜을 준수하는 새로운 구조를 선언하는 것이다.

나는 표준 테마를 이 특성의 기본값으로 사용할 것이다.

앱의 사용자 지정 동적 색상에서 이 새로운 테마 특성을 사용할 계획이기 때문에, 이 특성이 색상 모양에 영향을 미치며, 이 특성이 변경되면 시스템이 자동으로 뷰를 다시 그릴 것임을 나타냅니다.

색상 외관에 영향을 미치는 특성은 훨씬 더 비싸므로, 드물게 변하지 않는 특성에만 이것을 사용하세요.

특성은 또한 디버거에서 특성을 인쇄하는 것과 같은 것에 사용되는 이름을 가지고 있다.

기본적으로, 그것은 특성 유형 자체의 이름을 사용하지만, "테마"와 같은 더 짧은 이름을 줄 수 있다. 그리고 마지막으로, 나는 식별자 문자열을 제공할 수 있다.

식별자는 특성을 인코딩과 같은 추가 기능을 사용할 수 있게 한다.

역방향 DNS 형식을 사용하여 각 특성의 식별자가 앱에서 전 세계적으로 고유한지 확인하십시오.

이 특성을 설정하고 얻기 위해 일반 속성 구문을 사용할 수 있기를 원하므로, 이전 예제에서 했던 것처럼 UITraitCollection과 UIMutableTraits를 확장하여 속성을 선언할 것입니다.

그리고 그것이 내가 사용자 지정 테마 특성을 구현하기 위해 해야 할 전부이다.

이제 나는 이 새로운 특성을 사용하기 시작할 수 있다.

예를 들어, 테마에 따라 모양을 변경하는 사용자 지정 동적 색상을 정의하는 방법은 다음과 같습니다.

동적 공급자 이니셜라이저를 사용하여 새로운 UIColor를 만듭니다.

폐쇄 내부에서, 나는 어떤 색을 반환할지 결정하기 위해 전달되는 특성 컬렉션의 테마를 사용한다.

이제 이 사용자 지정 배경색을 보기로 설정할 수 있습니다.

내가 정의했을 때 이 특성이 색상 모양에 영향을 미친다고 지적했기 때문에, 이 사용자 지정 배경색을 사용하는 모든 보기는 테마가 변경되면 자동으로 업데이트됩니다.

특성을 정의할 때, 고려해야 할 가장 중요한 것은 특성 값의 관련 데이터 유형이다.

최고의 특성은 간단한 구조체와 열거형을 포함한 가치 유형을 중심으로 구축된다.

스위프트의 수업을 기반으로 하는 특성을 피하세요.

특성에 대한 가장 효율적인 데이터 유형은 Bool, Int 및 Double 또는 Int 원시 값을 사용하는 열거형이다.

열거형은 특성에 가장 유용한 데이터 유형 중 하나이다.

최대 효율성을 위해 Enum의 원시 데이터 유형으로 Int를 명시적으로 지정해야 합니다.

특성 값으로 사용하는 모든 사용자 지정 구조체 데이터 유형은 Equatable 프로토콜을 효율적으로 구현해야 합니다.

이 시스템은 특성이 언제 바뀌었는지 결정하기 위해 특성 값을 자주 비교할 것이므로, 당신의 동등한 기능은 가능한 한 빨라야 합니다.

Objective-C를 사용하는 앱을 사용하는 사람들을 위해, 새로운 특성 시스템 기능도 사용할 수 있습니다.

사용자 지정 특성을 위한 API는 Swift와 Objective-C에서 다르다.

그러나, Swift에서 하나의 사용자 지정 특성을 정의하고 Objective-C에서 하나를 정의할 수 있으며, 둘 다 동일한 기본 데이터를 가리킬 수 있습니다.

자세한 내용과 특별한 고려 사항은 문서를 참조하십시오.

사용자 지정 특성을 정의하면, 다음 단계는 앱의 특성 계층 구조에 일부 데이터를 채우는 것입니다.

특성 재정의는 특성 계층 구조 내에서 데이터를 수정하는 데 사용하는 메커니즘입니다.

iOS 17에서는 특성 재정의를 적용하는 것이 그 어느 때보다 쉽다.

창 장면, 창, 보기, 뷰 컨트롤러 및 프레젠테이션 컨트롤러를 포함한 각 특성 환경 클래스에 새로운 traitOverrides 속성이 있습니다.

특성 계층 구조의 삽화로 돌아가서, 특성 재정의는 이 트리의 어느 위치에서나 특성의 값을 변경합니다.

이 계층 구조의 특성 환경 중 하나에 특성 재정의를 적용하면, 해당 객체와 모든 후손의 특성 컬렉션에서 해당 특성에 대한 값을 수정합니다.

특성 계층 구조에서 부모와 자식 특성 환경을 취하면, 특성 재정의가 둘 다에 어떤 영향을 미치는지 알 수 있습니다.

부모에게 적용되는 특성 재정의는 부모 자신의 특성 수집에 영향을 미친다.

그리고 나서 부모의 특성 컬렉션의 값은 아이에게 상속된다.

마지막으로, 아이의 특성 재정의는 자체 특성 컬렉션을 생성하기 위해 물려받은 값에 적용된다.

특성 재정의를 선택적 입력으로 생각하고, 특성 컬렉션을 출력으로 생각하십시오.

재정의가 없는 모든 특성은 부모로부터 물려받을 것이다.

내 앱의 특정 부분에 대한 색상 테마를 변경하기 위해 특성 재정의를 사용하는 예를 살펴보겠습니다.

오른쪽에, 나는 내 앱의 특성 계층 구조에 대한 삽화가 있다.

처음에는 테마 특성의 값을 채우기 위해 재정의를 적용하지 않았기 때문에, 이러한 모든 특성 컬렉션은 표준 테마인 기본값을 가지고 있습니다.

창 장면에서 이 계층 구조의 루트에 특성 재정의를 적용하는 것으로 시작하겠습니다.

traitOverrides 속성은 UIMutableTraits 프로토콜을 활용하여 특성 값을 쉽게 설정할 수 있습니다.

따라서 앞서 설명한 UIMutableTraits 확장을 사용하여 표준 속성 구문으로 사용자 지정 특성에 대한 재정의 값을 설정할 수 있습니다.

창 장면의 특성 오버라이드에서 테마를 파스텔로 설정함으로써, 모든 창, 뷰 컨트롤러 및 창 장면 내부의 뷰는 이제 특성 컬렉션에서 파스텔 값을 상속합니다.

그래서 계층 구조의 루트에 있는 한 곳에 테마를 설정함으로써, 나는 그 계층 구조의 모든 것에 전파되는 기본 값을 변경했다.

예를 들어, 나는 그 창 장면 안에 있는 모든 뷰 컨트롤러의 특성 컬렉션에서 테마를 읽고 파스텔을 다시 얻을 수 있다.

그런 다음 계층 구조의 더 깊은 뷰에서 traitOverrides 속성을 사용하여 해당 뷰와 그 아래의 모든 것에 대한 테마를 수정할 수 있습니다.

여기서 저는 이 보기에 대한 흑백 테마 특성 재정의를 설정하고 있습니다.

그래서 이 흑백 값은 하위 뷰에 의해 상속되는 것이며, 계층 구조에서 더 높은 곳에서 파스텔 값을 재정의한다.

특성 컬렉션에 즉시 반영된 특성 재정의에 대한 변경 사항을 볼 수 없습니다.

예를 들어, 뷰는 레이아웃 직전에 특성 컬렉션을 업데이트하기 때문에, 뷰의 특성 재정의에 대한 수정은 layoutSubviews를 실행하기 직전까지 특성 컬렉션에 반영되지 않습니다.

특성 오버라이드 속성을 사용하면 오버라이드가 적용되는지 확인하고 오버라이드를 모두 제거할 수 있습니다.

다음은 포함 메소드를 사용하여 재정의가 존재하는지 확인하고 재정의를 완전히 제거하는 제거 방법을 사용하여 재정의를 전환하는 예입니다.

이 방법이 호출될 때마다, 기존 재정의를 제거하거나 아직 없을 때 새로운 테마 재정의를 적용할 것이다.

특성 재정의는 값을 설정하는 입력 메커니즘이다.

특성 값을 읽으려면, 항상 traitCollection 속성을 사용하세요.

재정의가 설정되지 않았을 때 traitOverrides를 읽으면 예외가 발생합니다.

특성 재정의를 사용할 때 명심해야 할 몇 가지 성능 고려 사항이 있습니다.

첫째, 각 특성 재정의는 비용이 적기 때문에 필요한 장소에서만 특성 재정의를 설정하고 사용되지 않는 특성 재정의를 설정하지 마십시오.

그리고 특성 재정의를 변경할 때마다, 시스템은 계층 구조의 모든 후손의 특성 컬렉션을 업데이트해야 합니다.

따라서, 특성 재정의를 변경하는 횟수를 최소화하세요.

마지막으로, 창 장면이나 창과 같이 계층 구조의 루트 근처에 적용된 특성 재정의는 그 아래의 모든 것에 영향을 미친다.

이것은 매우 유용하며, 창 장면이나 창에 특성 재정의를 적용하기 위한 많은 훌륭한 사용 사례가 있습니다.

그러나, 특성이 계층 구조 깊은 곳에서 몇 가지 뷰에만 영향을 미치는 경우, 대신 공통 슈퍼뷰 또는 뷰 컨트롤러와 같은 해당 뷰의 가장 가까운 공통 조상에 특성 재정의를 적용하십시오.

그렇게 하면, 계층 구조의 작은 부분만이 그 데이터를 사용할 때 전체 계층 구조에 특성을 전파하는 비용을 지불하지 않습니다.

이제 계층 구조에서 특성을 정의하고 데이터를 채우는 방법을 알았으므로, 값을 변경할 때 처리해야 합니다.

traitCollectionDidChange는 iOS 17에서 더 이상 사용되지 않습니다.

traitCollectionDidChange를 구현할 때, 시스템은 당신이 실제로 어떤 특성을 신경 쓰는지 모르기 때문에, 특성이 값을 변경할 때마다 그 메소드를 호출해야 합니다.

그러나, 대부분의 수업은 소수의 특성만 사용하고 다른 것들에 대한 변화에 신경 쓰지 않는다.

이것이 당신이 점점 더 많은 사용자 지정 특성을 추가함에 따라 traitCollectionDidChange가 확장되지 않는 이유입니다.

그 자리에는 더 유연하고 성능을 향상시키는 새로운 특성 등록 API가 있다.

특정 특성에 대한 변경 사항을 등록함으로써, 시스템은 당신이 어떤 특성에 의존하는지 정확히 알고 있습니다.

새로운 API를 사용하면 대상 액션 패턴이나 클로저를 사용하여 콜백을 받을 수 있습니다.

그리고 더 이상 서브클래스에서 메소드를 재정의할 필요가 없기 때문에, 이제 어디서나 특성 변화를 쉽게 관찰할 수 있습니다.

traitCollectionDidChange의 기존 구현을 업데이트하는 방법을 설명하는 것으로 시작하겠습니다.

여기 제 기존 구현이 있습니다.

그 방법은 이 하나의 특성에만 의존하기 때문에 updateViews를 호출하기 전에 horizontalSizeClass 특성이 변경되었는지 확인하는 방법에 유의하십시오.

앱을 이전 iOS 버전에 배포하기 때문에 traitCollectionDidChange를 계속 사용해야 하는 경우, 구현이 관심 있는 특정 특성이 변경되었는지 확인해야 합니다.

이제 저는 이 구현을 iOS 17의 새로운 특성 등록 방법으로 대체할 것입니다.

나는 폐쇄 기반 방법으로 시작할 것이다.

나는 registerForTraitChanges를 호출하고 등록할 특성 배열을 전달한다.

수평 크기 클래스와 같은 모든 시스템 특성에 대한 새로운 UITrait 기호가 있습니다.

그런 다음 나는 그 특정 특성이 바뀔 때 불리는 폐쇄를 통과한다.

폐쇄는 다른 특성에 대한 변경을 요구하지 않으므로, 여기서 오래된 특성 가치와 새로운 특성 가치를 비교할 필요가 없습니다.

특성이 변경된 객체는 클로저의 첫 번째 매개 변수로 전달된다.

이 매개 변수를 사용하면 해당 객체에 대한 약한 참조를 캡처할 필요가 없습니다.

자아의 특성 변화에 등록할 때, 항상 여기에 "self: Self"라고 쓰세요.

당신은 또한 다른 특성 환경에 대한 특성 변화를 관찰할 수 있습니다.

여기서 저는 두 가지 특성, 수평 크기 클래스와 이전에 정의한 ContainedInSettings 사용자 지정 특성에 대한 변경 사항을 등록하고 있습니다.

폐쇄는 이러한 특성 중 하나가 다른 관점에서 바뀔 때 실행된다.

나는 내가 등록하고 있는 뷰의 유형을 클로저의 첫 번째 매개 변수로 쓴다.

다음은 새로운 목표 행동 기반 방법의 예입니다.

registerForTraitChanges를 호출하고 등록할 특성 배열과 변경 사항을 호출할 대상 및 작업 방법을 전달하십시오.

대상 매개 변수는 선택 사항입니다.

그것을 생략하면, 대상은 registerForTraitChanges가 호출되는 것과 동일한 객체가 될 것이다.

이 경우, 그것은 그 자체이다.

폐쇄 방법과 마찬가지로, 다른 특성 환경의 변경 사항에 등록할 수도 있습니다.

여기서 저는 다른 보기에서 특성 변경을 등록하고 있지만, handleTraitChange라는 이름의 메서드에 대한 호출을 설정하고 있습니다.

목표 행동을 사용하여 특성 변경을 등록할 때, 행동 방법은 0, 1 또는 두 개의 매개 변수를 가질 수 있습니다.

첫 번째 매개 변수는 항상 특성이 변하는 객체이다.

새로운 traitCollection을 얻으려면 이 매개 변수를 사용하세요.

두 번째 매개 변수는 항상 변경 전에 그 객체에 대한 이전 특성 컬렉션이 될 것이다.

개별 특성을 등록하는 것 외에도, 시스템 특성의 새로운 의미론적 집합을 사용하여 등록할 수도 있습니다.

예를 들어, 시스템 동적 색상이 해결되는 방식에 영향을 미칠 수 있는 시스템 특성을 반환하는 systemTraitsAffectingColorAppearance가 있습니다.

UIImage(named:)를 사용하여 이미지를 로드할 때 고려되는 시스템 특성의 하위 집합을 반환하는 systemTraitsAffectingImageLookup도 있습니다.

사용자 지정 무효화를 수행하기 위해 이 세트 중 하나를 registerForTraitChanges에 직접 전달하세요.

새로운 방법을 사용하여 특성 변경을 등록할 때 등록은 자동으로 정리됩니다.

고급 사용 사례가 있는 경우, 각 등록 방법에서 반환되는 토큰을 사용하여 수동으로 등록을 취소할 수 있습니다.

하지만 이러한 경우는 매우 드물기 때문에, 일반적으로 registerForTraitChanges를 호출할 때 반환 값을 무시해야 합니다.

새로운 특성 등록 API를 채택할 때, 명심해야 할 두 가지 모범 사례가 있습니다.

먼저, 관련 없는 특성이 가치를 바꿀 때 작업을 수행하지 않도록 실제로 의존하는 특성에 대해서만 등록하십시오.

마지막으로, 즉시 업데이트하지 않고 특성 변경에 대한 응답으로 무효화하려고 시도하세요.

예를 들어, 뷰 서브클래스의 layoutSubviews 메소드 내부의 특성을 사용하는 경우, setNeedsLayout을 호출하여 특성 변경을 무효화하십시오.

이것은 layoutSubviews를 받기 위해 보기를 예약하지만, 즉시 업데이트를 수행하지는 않습니다.

이제 UIKit의 특성 시스템을 사용하여 자신의 데이터를 전파할 수 있으므로, 앱의 UIKit과 SwiftUI 구성 요소 간에 데이터를 원활하게 전달할 수 있는 완전히 새로운 방법을 열어줍니다.

UIKit의 사용자 지정 특성은 SwiftUI의 사용자 지정 환경 키와 매우 유사합니다.

UIKit과 SwiftUI 모두에서 동일한 데이터에 액세스하기 위해 연결할 수 있습니다.

UIKit 내부에 SwiftUI 구성 요소를 포함하든, SwiftUI 내부에 UIKit 구성 요소를 포함하든, 브리지된 데이터는 그들 사이를 원활하게 전달합니다.

UIKit 코드의 특성 API와 SwiftUI 코드의 환경 API를 사용하여 동일한 기본 데이터를 읽고 쓸 수 있습니다.

앱의 UIKit 코드에 대해 정의한 새로운 색상 테마 특성을 SwiftUI의 해당 환경 키에 연결하는 것은 믿을 수 없을 정도로 쉽습니다.

UIKit의 사용자 지정 특성과 동일한 데이터를 나타내는 SwiftUI의 사용자 지정 환경 키가 있다고 가정하면, 이를 브리지하기 위해 해야 할 일은 UITraitBridgedEnvironmentKey 프로토콜에 적합성을 추가하는 것뿐입니다.

이를 위해, 저는 UIKit에서 특성을 읽고 SwiftUI에 값을 반환하는 한 가지 방법과 UIKit 특성에 SwiftUI 환경 값을 쓰는 한 가지 방법을 구현합니다.

그리고 이제 UIKit 특성과 SwiftUI 환경 키 모두 통합 스토리지에 액세스하므로, 두 프레임워크를 사용하여 작성된 구성 요소에서 동일한 데이터를 읽거나 쓸 수 있습니다.

다음은 브리지 특성과 환경 키를 어떻게 사용할 수 있는지에 대한 예입니다.

내 앱의 루트에서, 나는 UIKit 창 장면에 테마 특성에 대한 특성 재정의를 적용한다.

이것은 흑백 테마 값을 그 창 장면 안에 포함된 모든 것에 전파한다.

그런 다음, 그 창 장면의 창 안쪽 깊숙이, 나는 UIKit 컬렉션 뷰를 가지고 있다.

이 컬렉션 보기에는 각 셀에 SwiftUI 보기를 표시하기 위해 UIHostingConfiguration을 사용하여 구성된 셀이 포함되어 있습니다.

SwiftUI CellView 내부에는 환경 속성 래퍼를 사용하여 SwiftUI 환경에서 값을 읽는 "테마"라는 속성이 있습니다.

환경의 값은 UIKit의 브리지 특성과 동일한 값에 해당합니다.

그리고 마지막으로, 저는 테마 속성을 사용하여 이 SwiftUI 보기 내의 텍스트 색상을 제어합니다.

SwiftUI는 데이터 종속성을 자동으로 추적하기 때문에, UIKit 창 장면에서 테마 특성 재정의가 다른 값으로 변경되면, 내 SwiftUI 셀 뷰는 새로운 테마를 반영하기 위해 자동으로 업데이트됩니다.

브리징은 또한 다른 방향으로 작동한다.

여기 내 앱의 설정을 표시하는 SwiftUI 보기가 있습니다.

환경 수정자를 사용하여 설정 컨트롤러의 모든 것에 적용되는 표준 테마를 설정합니다.

이것은 개념적으로 UIKit에서 특성 재정의를 적용하는 것과 같다.

그런 다음 UIViewControllerRepresentable 내부에 포함된 UIKit 기반 설정 뷰 컨트롤러에서 브리지된 특성에서 테마 값을 읽고 이 뷰 컨트롤러에 표시된 제목을 업데이트하는 데 사용합니다.

이것은 브리지된 UIKit 특성과 SwiftUI 환경 키를 사용하여 데이터에 원활하게 액세스하는 것이 얼마나 쉬운지입니다.

이제 이러한 강력한 새로운 기능에 대해 배웠으니, 앱에서 특성 시스템을 활용하여 자신의 사용자 지정 특성을 정의하여 데이터를 자동으로 전파할 수 있는 장소를 찾으세요.

다음으로, 특성 계층 구조에서 데이터를 쉽게 수정하기 위해 새로운 traitOverrides 속성을 채택하십시오.

그런 다음 더 유연한 특성 등록 API를 사용하여 사용하는 정확한 특성에 대한 정확한 종속성을 만드세요.

마지막으로, 사용자 지정 UIKit 특성을 사용자 지정 SwiftUI 환경 키로 연결하여 데이터가 앱의 UIKit과 SwiftUI 구성 요소 간에 원활하게 흐르도록 합니다.

이제 특성의 힘을 발휘하는 것은 당신에게 달려 있습니다.

봐줘서 고마워.

♪ ♪