10108

♪ ♪

Jared: 안녕하세요, "배경 자산의 새로운 기능"에 오신 것을 환영합니다.

제 이름은 자레드이고, 저는 여기 애플의 소프트웨어 엔지니어입니다.

저는 올해 새로운 모든 것을 배경 자산과 공유하기를 정말 고대하고 있습니다.

이제, 우리 팀은 작년에 몇 가지를 바꿨다.

하지만, 배경 자산이 소개된 이전 세션을 확인해 보시기 바랍니다.

이 새로운 세션이 기반으로 하는 많은 자세한 정보가 있다.

이 세션에서는 백그라운드 자산에 대한 개요와 앱에 채택해야 하는 이유를 제공하는 것으로 시작하겠습니다.

그런 다음, 우리 팀이 당신과 공유하게 되어 정말 기뻤던 완전히 새로운 기능을 포함하는 배경 자산의 올해 새로운 기능에 대해 논의하겠습니다.

그런 다음 직접 다운로드할 수 있는 백그라운드 자산의 샘플 구현을 안내하고, 이 기술을 채택하면 앱의 사용자 경험을 크게 향상시킬 수 있는 방법을 보여 드리겠습니다.

그런 다음 앱 확장을 디버깅하고 진입점을 시뮬레이션하는 방법에 대한 지침을 드리겠습니다.

알았어! 배경 자산에 대한 간략한 요약을 살펴봅시다.

배경 자산의 주요 목표 중 하나는 기다림을 막는 것이다.

사용자가 경험하고 싶은 마지막 것은 앱을 실행하고 대량 다운로드가 완료될 때까지 기다려야 하는 것입니다.

백그라운드 자산은 프레임워크와 관련 앱 확장의 조합을 통해 이 문제를 해결합니다.

이 새로운 기술은 macOS Ventura의 초기 출시와 함께 iOS 16.1에 도입되었다.

CDN 공급자 또는 관리하는 서버를 사용하여 앱의 추가 콘텐츠를 다운로드할 수 있는 기능을 지원합니다.

예를 들어, 이 콘텐츠는 초기 앱 설치 중에, 앱이 업데이트될 때, 또는 사용자가 앱을 사용하지 않을 때 주기적으로 백그라운드에서 가져올 수 있습니다.

페어링된 앱 확장 프로그램을 통해 사용자가 앱을 적극적으로 사용하지 않을 때 실행되는 코드를 작성할 수 있습니다.

이 기술은 현재 macOS, iOS 및 iPadOS에서 지원되므로, 이미 좋아하는 플랫폼에서 사용할 수 있습니다.

백그라운드 자산 사용에 대한 가장 좋은 부분 중 하나는 사용자가 앱을 실행하기 전에 확장 프로그램을 실행할 수 있다는 것입니다.

이것은 App Store를 통해 앱이 설치되는 순간 자산을 가져오기 시작할 수 있는 방법을 제공합니다.

확장은 또한 백그라운드에서 주기적으로 시스템에 의해 시작될 수 있다.

이것은 사용자가 앱을 시작할 때 새롭거나 업데이트된 자산이 있는지 확인하기 위한 것입니다.

이 확장 프로그램은 또한 앱이 실행되지 않을 때 다운로드 서비스를 제공하는 데 사용됩니다.

예를 들어, 파일 다운로드가 완료되면, 파일을 최종 목적지로 이동할 수 있도록 확장자가 실행됩니다.

명심해야 할 것은 확장의 실행 시간이 제한되어 있다는 것이다.

이것은 사용자의 장치가 전력과 성능에 최적화되도록 하기 위한 것이다.

나는 곧 이것에 대해 더 자세히 설명할 것이다.

백그라운드 자산과 함께 사용하기 위해 개발한 앱 확장 프로그램이 특수 샌드박스에 배치된다는 것을 아는 것도 중요합니다.

이것은 확장이 백그라운드 자산을 통해 콘텐츠를 관리하는 데만 사용되도록 하기 위한 것이다.

샌드박스 내에서 기능이나 API를 사용할 수 없는 경우, 피드백 어시스턴트를 통해 저희에게 연락하십시오.

앱 확장은 세 가지 시스템 이벤트 중에 호출된다는 것을 앞서 언급했습니다: 앱 설치, 앱 업데이트 및 주기적으로 백그라운드에서.

이 수명 주기가 어떻게 관리되는지 살펴봅시다.

확장 프로그램의 수명 주기는 App Store가 장치에 앱을 설치하거나 업데이트할 때 시작됩니다.

그런 다음 백그라운드 자산 시스템 서비스가 통보되고 앱이 실행되는 것을 방지합니다.

그런 다음 시스템은 앱 번들을 검사하고 BAManifestURL 키에 대한 Info.plist를 읽습니다.

시스템은 해당 키로 참조된 매니페스트를 다운로드하기 시작하고 다운로드 진행 상황을 App Store로 다시 보고할 것입니다.

매니페스트가 다운로드되면, 시스템은 주어진 설치 또는 업데이트 이벤트에 대한 콘텐츠 요청을 발행하여 확장 프로그램을 깨웁니다.

콘텐츠 요청에는 다운로드한 매니페스트의 경로가 포함되어 있습니다.

확장 프로그램은 매니페스트를 사용하여 URL, 파일 크기 및 다운로드를 예약할 자산을 결정해야 합니다.

그런 다음 확장 프로그램이 어떤 자산을 다운로드해야 하는지 결정하면, 해당 다운로드를 BADownloads 세트로 반환합니다.

그런 다음 시스템은 장치의 전력과 성능을 절약하기 위해 앱 확장을 일시 중지하거나 때로는 종료합니다.

그러면 다운로드가 시작되고 확장 프로그램은 완료 직후에 통보될 것입니다.

주기적인 콘텐츠 요청은 앱 설치 이벤트와 거의 동일하며, 유일한 주요 차이점은 장치가 이벤트가 언제 발생할지 결정한다는 것입니다.

그 장치는 사용자가 장치를 어떻게 사용하고 있는지에 따라 이 결정을 내린다.

저전력 모드, 백그라운드 앱 새로 고침 또는 앱이 얼마나 자주 실행되었는지와 같은 주요 요인이 모두 고려됩니다.

이제, 조금 더 깊이 들어가서 확장이 주기적으로 실행될 때 기여하는 요인을 살펴봅시다.

우리는 장치의 전반적인 성능과 전력 사용량에 많은 관심을 가지고 있으며, 이것이 백그라운드 자산이 확장의 런타임에 제한을 두는 이유입니다.

여기에는 확장 프로그램의 메모리 사용에 대한 시행이 포함됩니다.

확장이 몇 메가바이트의 메모리를 초과하면, 시스템에 의해 종료될 수 있습니다.

따라서 장치의 스토리지로 뒷받침되는 메모리 매핑 데이터는 이 제한에 포함되지 않기 때문에 확장자가 읽어야 하는 대용량 파일을 메모리 매핑하는 것을 고려할 수 있습니다.

앱이 처음 설치되면, 하루에 몇 분의 런타임의 기본 할당이 제공됩니다.

이것은 많이 들리지 않을 수도 있지만, 적절하게 설계된 확장으로, 이것은 먼 길을 갈 수 있다.

런타임은 또한 앱 사용에 따라 변경됩니다.

앱이 한동안 실행되지 않았다면, 시스템은 확장 프로그램의 실행을 제한하기 시작할 수 있습니다.

예를 들어, 거의 사용되지 않는 앱은 런타임이 더 제한될 수 있는 반면, 일반적으로 사용되는 앱에는 추가 런타임이 주어질 수 있다.

BADownloaderExtension 프로토콜은 앱 확장의 진입점으로 사용되는 기능을 정의합니다.

런타임은 함수가 시스템에 의해 호출될 때 계산되기 시작하고 그 함수가 범위를 종료할 때 계산되는 것을 멈춘다.

기능이 범위를 종료하거나 확장 프로그램의 런타임이 소진되면, 시스템은 확장을 일시 중지하거나 종료할 수 있습니다.

잠시 후에 예를 들어볼게.

그러나, 확장의 런타임을 제어하는 기능 범위에는 한 가지 예외가 있습니다.

비동기 독점 제어 API가 호출되면, 확장은 완료 핸들러가 호출되고 반환될 때까지 계속 실행됩니다.

확장 프로그램의 런타임이 사용자가 제어할 수 있는 몇 가지 방법이 있습니다.

예를 들어, 장치가 저전력 모드에 있거나 백그라운드 앱 새로 고침이 비활성화된 경우, 글로벌이든 특정 앱이든, 확장 프로그램은 실행되지 않습니다.

이전에, 나는 확장 런타임이 기능 범위에 따라 어떻게 결정되는지 언급했다.

그것이 어떻게 작동하는지 더 잘 이해하기 위해 예시를 살펴봅시다.

이 코드는 백그라운드 다운로드 서비스를 제공하는 확장 프로그램의 인터페이스를 나타냅니다.

BADownloaderExtension 프로토콜은 시스템이 확장에 호출할 기능을 정의합니다.

이제 이 프로토콜을 준수하기 위해 필요한 기능 중 하나를 추가해 봅시다.

"요청 다운로드" 기능은 확장 프로그램의 주요 진입점 중 하나입니다.

BAContentRequest는 앱 설치, 앱 업데이트 또는 백그라운드에서 정기적인 검사의 일부로 호출되는지 정의합니다.

manifestURL 인수는 확장자가 호출되기 전에 다운로드된 로컬 파일의 경로를 제공합니다.

매니페스트 파일은 일반적으로 현재 다운로드된 것과 서버에서 다운로드할 수 있는 것을 비교하는 데 사용됩니다.

함수 정의의 반환 유형에는 BADownload 유형을 준수하는 다운로드 객체 세트가 필요합니다.

즉, 이 함수의 요청에 응답하려면 함수가 범위를 종료하기 전에 다운로드해야 하는 모든 콘텐츠를 동기적으로 반환해야 합니다.

그러나, 이 인위적인 예에서, 당신이 parseManifest라는 함수를 호출한다고 가정해 봅시다.

이 기능은 다운로드한 매니페스트를 읽은 다음 다운로드해야 하는 BADownload 객체를 반환합니다.

그러나, parseManifest 기능이 제대로 구현되지 않았고 다운로드를 구문 분석하고 구성하는 데 30분이 걸린다고 가정해 봅시다.

이것은 결국 연장의 런타임을 크게 초과할 것이며, 연장은 종료될 것이다.

확장 프로그램의 런타임은 "요청에 대한 다운로드" 기능이 호출되는 순간부터 범위를 종료하고 반환할 때까지 계산된다는 것을 기억하는 것이 중요합니다.

또 다른 문제가 되는 예를 살펴봅시다.

BADownloaderExtension 프로토콜 기능이 범위를 종료할 때마다 확장이 일시 중지된 다음 종료될 수 있습니다.

당신은 프로토콜이 그 어떤 기능도 돌연변이로 정의하지 않는다는 것을 알게 될 것이며, 이에 대한 타당한 이유가 있습니다.

확장이 종료되면, 인스턴스 변수나 인메모리 상태는 저장되지 않습니다.

확장 프로그램이 상태를 유지해야 하는 경우, 해당 상태를 디스크로 직렬화해야 합니다.

다음으로, 다운로드를 관리하기 위해 확장 프로그램과 앱 모두에서 사용할 API에 대해 이야기해 봅시다.

프레임워크 내의 다운로드 관리자는 백그라운드 자산 시스템 서비스와 통신하는 주요 방법입니다.

관리자는 앱 전체에서 사용할 수 있는 싱글톤 객체입니다.

관리자를 사용하여 백그라운드에서 자산의 다운로드를 예약하고 이미 예정된 다운로드를 전경으로 홍보할 수 있습니다.

다운로드 관리자에서, 당신은 또한 현재 비행 중인 다운로드를 관리할 수 있으며, 앞서 언급한 것은 앱이 출시되기 전에 확장 프로그램에 의해 예약되었을 수 있습니다.

앱과 관련 확장이 동시에 유사한 작업을 수행하지 않도록 하기 위해 사용할 수 있는 동기화 메커니즘도 있습니다.

다운로드 관리자에 대해 마지막으로 언급하고 싶은 것은 BADownloaderExtension 프로토콜과 유사하게 다운로드에 대한 콜백을 받을 수 있는 대리인이 있다는 것입니다.

BADownloadManager에 대리인을 등록하면, 내선 번호 대신 콜백을 받게 됩니다.

이것은 실행되는 동안 다운로드를 관리할 수 있는 방법을 제공하기 때문에 유용합니다.

이제 다운로드를 관리하는 방법에 대한 빠른 재교육을 받았으니, 이미 사용자의 장치에 있는 파일을 어떻게 관리해야 하는지에 대해 이야기해 봅시다.

백그라운드 자산으로 다운로드한 모든 파일은 제거 가능으로 표시되며, 이는 시스템이 중요한 상황에서 제거할 수 있음을 의미합니다.

시스템 보안 업데이트나 사용자가 자녀의 첫 번째 단계의 비디오를 캡처해야 하는지 생각해 보세요.

그러나, 다운로드한 자산을 수정하거나 확장하면, 해당 파일은 시스템에 의해 추적되지 않으므로 제거할 수 없습니다.

자산을 수정하거나 데이터를 추출하는 방법에 대해 신중하게 생각해야 합니다.

다운로드한 자산을 잘못 관리하는 경우, 사용자의 장치 백업 크기를 늘리거나 중요한 보안 업데이트가 다운로드되는 것을 방지할 수 있습니다.

따라서, 다운로드한 자산을 캐시 디렉토리에 저장해야 합니다.

그렇게 하면, 시스템은 그렇게 하는 것이 중요할 때 그들을 제거할 수 있다는 것을 알고 있다.

이제 이 모든 것이 어떻게 작동하는지에 대한 완전한 요약을 가졌으니, 배경 자산으로 올해 새로운 것을 살펴봅시다.

올해 초, 우리는 앱을 설치하거나 업데이트하는 동안 콘텐츠를 가져올 수 있는 방법을 제공하는 필수 다운로드를 도입했습니다.

이것은 당신의 다운로드가 iOS 홈 화면, macOS Launchpad 및 App Store에 완전히 통합된다는 것을 의미합니다.

최종 사용자에게 자산의 다운로드는 앱이 현재 App Store에서 여전히 다운로드되고 있는 것처럼 보입니다.

이것은 또한 필수 다운로드가 기내에 있는 동안, 사용자가 앱을 실행할 수 없다는 것을 의미합니다.

사용자가 할 수 있는 일은 설치를 취소하거나 일시 중지하는 것뿐입니다.

일시 정지가 지원되기 때문에, 재개가 가능할 수 있도록 서버는 HTTP 범위를 지원해야 합니다.

필수 다운로드는 앱 설치 중에 발생하기 때문에, 필수적이지 않은 다운로드보다 우선합니다.

한 번 보자.

모든 것은 App Store 또는 TestFlight에서 앱을 요청할 때 시작됩니다.

앱의 Info.plist에 필수 자산 키가 포함되어 있다면, 장치에 진행 상황이 설정되고 우리는 이 흐름을 거칩니다.

앱이 다운로드되고 설치되면, 시스템은 앱 설치, 앱 업데이트 또는 정기적인 가져오기에 대한 요청 여부를 포함하는 콘텐츠 요청을 발행하여 확장 프로그램을 깨웁니다.

이 기간 동안, 매니페스트를 다운로드하기 위해 인증 챌린지가 전송될 수 있습니다.

그러면 당신의 확장 프로그램은 필수 다운로드와 필수적이지 않은 다운로드의 조합을 다시 판매할 것입니다.

참고로, 이 기능이 돌아올 때까지 앱의 다운로드 진행 상황이 사용자에게 멈춘 것처럼 보이기 때문에 확장 프로그램이 다운로드를 빠르게 다시 판매하는 것이 중요합니다.

확장 프로그램이 다운로드를 제공하는 순간, 필수로 표시된 모든 다운로드가 즉시 시작됩니다.

당신의 연장은 또한 이 기간 동안 추가 인증 문제를 받을 수 있습니다.

모든 필수 다운로드가 완료되면, 시스템은 확장을 종료하고 사용자가 앱을 실행할 수 있습니다.

그러면 확장 프로그램은 성공적이고 잠재적으로 실패한 다운로드의 배치를 받게 될 것이다.

실패한 다운로드가 있는 경우 BADownloadManager를 사용하여 필수적이지 않은 것으로 다시 대기열에 넣을 수 있습니다.

당신의 확장 프로그램이 필수 다운로드에 대한 완료 메시지를 받고 있기 때문에, 시스템은 즉시 필수적이지 않은 자산을 다운로드하기 시작할 것입니다.

필수적이지 않은 다운로드는 다운로드가 완료되면 확장 프로그램으로 전송됩니다.

이제 필수 다운로드가 iOS 홈 화면의 App Store 설치 진행 상황에 어떻게 통합되는지 살펴봅시다.

진행률 지표의 비율은 기본 앱을 다운로드하는 데 걸리는 시간과 설치 시간, 필수 자산을 다운로드하는 데 필요한 시간으로 나뉩니다.

앱의 Info.plist에 정의된 새로운 BAEssentialDownloadAllowance 키는 초기 전체 진행률 지표를 설정하는 데 사용됩니다.

그런 다음 contentForRequest가 확장 프로그램에 호출되고 확장 프로그램이 다운로드를 반환하면, 각 필수 다운로드의 파일 크기가 함께 추가되어 실제로 얼마나 다운로드되고 있는지 결정합니다.

다운로드를 위해 예약한 금액이 필수 다운로드 허용량보다 훨씬 적다면, 진행 지표는 다소 빠르게 움직일 수 있습니다.

사용자의 원활한 진행을 보장하기 위해 실제로 다운로드되는 것과 가까운 필수 다운로드 수당을 얻는 것을 목표로 해야 합니다.

우리가 논의한 모든 것은 사용자가 비활성화할 수 있다는 것을 명심하는 것이 중요합니다.

App Store 설정 창에는 앱 내 콘텐츠를 비활성화하는 섹션이 있습니다.

이것은 백그라운드 자산을 완전히 비활성화하지는 않지만, 사용자가 앱을 시작하기 전에 필수 자산을 다운로드하고 확장 프로그램을 실행할 수 있는 기능을 방지합니다.

따라서 필수 자산을 그렇게 생각하는 것이 중요합니다: 필수적이지만 앱을 실행하기 위한 요구 사항은 아닙니다.

따라서, 앱이 실행될 때 필수 자산이 아직 장치에 없는 흐름을 처리하는 것이 중요합니다.

필수 자산을 사용할 수 있는 기능은 실제로 iOS 16.4와 macOS Ventura 13.3의 일부로 봄에 도입되었다.

새로운 API는 매우 미미하며 기존 확장 프로그램에 쉽게 추가되어야 합니다.

필수 다운로드를 지원하기 위해 만들어진 첫 번째 API는 실제로 BAURLDownload의 새로운 이니셜라이저였다.

이 기능을 지원하기 위해 특별히 추가한 두 가지 새로운 주장이 있습니다.

그 이름에서 알 수 있듯이, 필수적인 주장은 다운로드가 필수로 표시되어야 하는지를 명시하며, 필수는 앱의 전반적인 다운로드 및 설치 진행에 기여하는 것을 의미합니다.

파일 크기 인수는 다운로드될 자산의 크기이다.

필수 다운로드를 만들 때 파일 크기는 정확해야 합니다.

시스템은 사용자의 장치에 앱 설치 진행 상황을 제대로 표시할 수 있도록 이 정보가 필요합니다.

백그라운드 자산이 다운로드한 파일이 여기에 제공된 파일 크기와 일치하지 않으면, 다운로드가 필수로 표시되면 다운로드가 실패합니다.

확장자가 파일의 크기를 모르는 경우, 파일 크기는 확장자가 실행되기 전에 확장자에 제공되는 BAManifestURL에 포함되어야 합니다.

도입된 또 다른 API는 다운로드의 불필요한 표현을 만들기 위한 쉬운 원라이너를 제공한다.

필수 다운로드는 contentForRequest 기능에서만 호출할 수 있기 때문에, 이 API는 많은 경우에 유용할 수 있습니다.

예를 들어, 네트워킹 문제나 파일을 일시적으로 사용할 수 없기 때문에 필수 다운로드를 가져오는 데 실패했다고 가정해 봅시다.

음, 확장 프로그램 내의 백그라운드 다운로드 실패 기능에서, 당신은 쉽게 그 다운로드의 불필요한 표현을 만들고 다시 대기열에 넣을 수 있습니다.

그런 다음 다운로드가 백그라운드에서 시작되며 확장 프로그램이나 앱이 완료되면 알림을 받게 됩니다.

이제 앱의 Info.plist에 있어야 하는 몇 가지 필수 키를 살펴봅시다.

작년 세션에서, 나는 이 열쇠들 각각을 자세히 검토했다.

좀 더 심층적인 설명을 원하신다면, 그 이야기를 확인해 보시기 바랍니다.

이러한 키는 백그라운드 자산 프레임워크를 사용하는 데 필요할 뿐만 아니라 앱을 App Store에 제출하는 데에도 필요하다는 것을 명심하는 것이 중요합니다.

올해 필수 자산을 지원하는 데 필요한 두 가지 새로운 키가 있습니다: BAEssentialDownloadAllowance와 BAEssentialMaxInstallSize.

필수 다운로드 수당은 바이트로 표시되며 모든 필수 자산의 합계가 얼마나 큰지 상한선을 정의합니다.

사용자가 앱을 설치할 때 다운로드 진행이 원활하게 진행될 수 있도록 이 숫자를 대기열에 있는 필수 자산의 크기에 최대한 가깝게 맞추는 것이 중요합니다.

다른 새로운 키인 BAEssentialMaxInstallSize는 사용자의 장치에 추출된 자산의 최대 크기를 나타냅니다.

이 숫자는 필수 자산이 설치된 후 앱이 얼마나 많은 저장 공간을 사용할지 사용자에게 알려주는 방법으로 App Store에 나타납니다.

그것은 우리가 필수 자산을 위해 추가한 새로운 API를 거의 요약한 것이다.

방금 보셨듯이, 최소한의 코드 변경으로 기존 앱에 필수 자산 지원을 추가할 수 있습니다.

그건 정말 그렇게 쉬워.

이제 재미있는 부분을 위해.

URLSession을 사용하는 기존 앱을 백그라운드 자산을 사용하도록 확장하는 방법을 살펴봅시다.

오늘 보여줄 앱은 이것과 마찬가지로 WWDC 세션을 다운로드하고 오프라인으로 볼 수 있도록 장치에 저장합니다.

현재, 비디오가 다운로드되기 전에 앱을 실행해야 합니다.

백그라운드 자산을 채택함으로써, 우리는 앱이 출시되기 전에 이미 비디오를 다운로드함으로써 이 대기 시간을 없앨 수 있습니다.

한 번 보자.

여기 우리가 오늘 구축할 앱이 있습니다.

당신은 그것이 시작되는 순간, 세션이 즉시 다운로드되기 시작한다는 것을 알게 될 것입니다.

이 앱이 현재 작동하는 방식은 WWDC 세션 목록이 포함된 서버에서 매니페스트를 다운로드하는 것입니다.

매니페스트를 가져온 후, 세션은 다운로드를 시작한 다음 탭하면 볼 수 있게 됩니다.

이 프로젝트에 배경 자산을 채택하는 데 필요한 것이 무엇인지 살펴봅시다.

백그라운드 자산 API를 사용하기 전에, 가장 먼저 추가해야 할 것은 앞서 논의한 초기 Info.plist 키입니다.

이 키는 앱 번들의 Info.plist 파일에 있어야 합니다.

다음으로 해야 할 일은 백그라운드 다운로드 확장 프로그램을 추가하고 앱에 삽입하는 것입니다.

확장 프로그램의 번들 식별자가 앱의 번들 식별자와 접두사가 지정되어 있는지 확인해야 합니다.

또한 앱 그룹이 앱 그룹이 다운로드한 자산을 앱과 공유하는 방식이기 때문에 앱과 확장 프로그램이 공통 앱 그룹에 있는지 확인해야 합니다.

마지막으로 확인하고 싶은 것은 앱과 확장 프로그램이 모두 팀 식별자로 서명되어 있다는 것입니다.

그 단계를 벗어나면, 당신은 배경 자산을 채택하기 시작할 수 있습니다.

여기 당신 앞에는 방금 본 앱의 Xcode 프로젝트가 있습니다.

나는 이미 가서 다운로드 확장 프로그램을 만들고 앱에 포함시켰다.

나는 또한 필요한 Info.plist 키를 추가했다.

그 모든 것을 방해하지 않도록, SessionManager로 이동하는 것으로 시작합시다.

이 프로젝트의 SessionManager는 현재 URLSession을 사용하여 최신 다운로드를 가져옵니다.

URLSession은 환상적인 API이다.

우리는 매니페스트를 가져오기 위해 앱 내에서 계속 사용할 것입니다.

그러나, 우리는 실제 세션을 가져오기 위해 백그라운드 자산을 사용하여 마이그레이션할 것입니다.

이것은 앱이 앱이 시작될 때 포그라운드로 만들려는 확장에 의해 백그라운드에서 예정된 모든 자산을 홍보할 수 있도록 하기 위한 것입니다.

우선, 우리는 배경 자산 프레임워크 모듈을 가져오는 것으로 시작할 것이다.

그런 다음 아래로 스크롤하여 더 이상 필요하지 않기 때문에 URLSession과 관련된 변수를 제거하겠습니다.

이제 "다운로드 시작" 방법으로 이동하겠습니다.

보시다시피, 기존 코드는 URLSession 다운로드 작업으로 다운로드할 세션을 추적하고 있었습니다.

이것은 더 이상 필요하지 않을 것이므로, 그것을 제거합시다.

여기가 일이 흥미로워지기 시작하는 곳이다.

백그라운드 자산으로 작업할 때, 확장 프로그램과 앱이 동시에 실행되는 것에 대해 생각하는 것이 중요합니다.

이것을 거의 수월하게 조정하려면, 다른 프로세스와의 상호 배제가 필요한 모든 작업이 그렇게 할 수 있도록 보장하기 위해 withExclusiveControl을 사용해야 합니다.

지금 그걸 추가하자.

아시다시피, 이 API는 비동기적이고 탈출합니다.

확장이 이 API를 사용하는 경우 폐쇄 내에서 예정된 모든 작업은 확장과 독립적으로 실행되도록 보장됩니다.

우리는 잠시 후에 확장을 구현할 것이지만, 지금은 앱에 집중합시다.

우리가 상호 배타적인 맥락에서 실행되고 있다는 것을 알고 있기 때문에, 현재 기내에 다운로드가 있는지 다운로드 관리자에게 물어봅시다.

확장이 이미 예약되어 있다면 다운로드 일정을 다시 잡을 이유가 없습니다.

그러나, 우리가 할 수 있는 한 가지는, 우리가 기존 다운로드를 찾으면, 우리는 그것을 전경으로 홍보할 수 있다는 것이다.

다운로드를 전경으로 홍보하면 다운로드가 완료되는 데 걸리는 시간을 크게 줄일 수 있습니다.

사용자가 현재 앱을 사용하고 있기 때문에, 가능한 한 빨리 다운로드를 가져올 수 있는 좋은 기회입니다.

사용자는 그것을 보고 싶어할 수도 있다.

다운로드가 아직 존재하지 않는다면, 우리는 그것을 만들 것이다.

그런 다음, 우리가 방금 다운로드를 만들었는지 아니면 확장 프로그램을 만들었는지에 관계없이, 우리는 계속해서 전경에서 시작할 것입니다.

백그라운드에서 포그라운드로 다운로드를 홍보하면 다운로드가 다시 시작되지 않으며, 그 전환에서 중단된 곳에서 간단히 재개됩니다.

목록의 다음 단계는 BADownloadManagerDelegate를 구현하는 것이지만, 그렇게 하기 전에 이전 URLSessionDelegate를 삭제할 것입니다.

이제 이전 대리인이 사라졌으니, 백그라운드 자산 대리인을 만들어 봅시다.

세션 관리자가 이제 대리인을 준수하고 있기 때문에, 실제로 그 메시지를 받기 위해 유선으로 연결되는 것이 중요합니다.

그래서 나는 이니셜라이저로 올라가서 지금 그것을 연결할 것이다.

BADownloadManager는 시스템 스케줄러에 직접 연결되기 때문에, 싱글톤 객체이다.

이 대리인을 다운로드 관리자에 첨부하면 앱이 현재 실행 중인 경우 확장 프로그램을 통해 메시지를 받을 수 있습니다.

이제 우리가 구현해야 할 기능으로 돌아가자.

이 앱의 경우, 우리가 구현할 위임 프로토콜에는 세 가지 특정 기능이 있습니다.

첫 번째는 진행 처리를 위한 것이다. 지금 그것을 실행하자.

UI에서 진행 상황을 맹목적으로 업데이트하기 전에, 진행 상황 메시지를 받고 있는 다운로드가 매니페스트가 현재 추적하고 있는지 확인할 것입니다.

다운로드가 추적되는 경우, SwiftUI로 직접 진행 상황을 보내는 앱 내의 도우미 기능인 updateDownloadProgress를 호출할 것입니다.

다음으로, 나는 다운로드가 끝나면 일어나는 일을 구현할 것이다.

그것은 거의 같은 방식으로 시작하는데, 이는 예상되는 다운로드만 처리하고 있는지 확인하는 것이다.

그런 다음 replaceItemAt는 백그라운드 자산이 우리에게 준 임시 위치에서 최종 위치로 개체를 이동하는 데 사용됩니다.

장치가 공간이 부족하면 시스템이 파일을 추적하고 제거하기 때문에 여기에서 이동 작업을 사용하는 것이 중요합니다.

따라서 앱이 항상 누락된 파일이 있는지 확인하고 필요한 경우 다시 가져오는지 확인해야 합니다.

여기서 마지막으로 일어나는 일은, 작업이 MainActor에 대해 생성되고, 상태가 다운로드된 것으로 표시되고, 앱이 세션의 썸네일을 가져오기 시작한다는 것입니다.

이제, 저는 모든 다운로드가 성공할 것이라고 말하고 싶습니다.

그러나, 불행한 진실은 서버가 더 이상 그 자원을 가지고 있지 않거나 네트워크 문제가 있기 때문에 그들이 실패할 수 있다는 것이다.

백그라운드 자산은 재시도하고 네트워크 연결 문제를 기다리지만, 특정 시점이 지나면 파일이 진행 중이 아니라는 것을 알아야 합니다.

명심해야 할 또 다른 점은 네트워크 연결 문제가 있으면 포그라운드로 승격된 다운로드가 거의 즉시 실패한다는 것입니다.

다운로드가 실패했을 때 우리 앱이 해야 할 일은 많지 않다.

UI를 제시하거나 일정을 변경할 수 있지만, 이 예에서는 문제가 있었다는 것을 기록해 봅시다.

대리인이 이제 완전히 구현되었기 때문에, 앱을 다시 실행하고 어떻게 보이는지 봅시다.

음, 놀랍지 않게도, 그것은 똑같아 보이고, 그것이 우리가 여기서 정말 보고 싶었던 것이다.

URLSession 대신 백그라운드 자산을 추가하는 것은 꽤 쉽습니다.

다음으로 보여드릴 것은 백그라운드 다운로드를 처리하기 위한 앱 확장 프로그램을 구현하는 방법입니다.

이 앱 확장 프로그램을 추가하는 것은 앱이 설치되거나 업데이트되기 전에 백그라운드 자산을 활용하여 콘텐츠를 가져올 수 있는 방법이며 필수 자산의 queueing에 대한 지원을 제공합니다.

본질적으로, 확장 프로그램은 앱이 실행되지 않는 동안 다운로드를 예약하는 역할을 합니다.

한 번 보자.

여기 우리는 백그라운드 자산과 관련된 확장 프로그램 내에서 메시지를 받는 백그라운드 다운로드 핸들러에 있습니다.

확장 프로그램에서 가장 먼저 할 일은 확장 프로그램이 실행 중일 때 Console.app에서 볼 수 있도록 로거를 만드는 것입니다.

다음으로, 나는 BADownloaderExtension 프로토콜의 일부인 contentForRequest 기능을 구현할 것이다.

이 확장이 할 첫 번째 일은 확장이 시작되기 전에 미리 다운로드된 매니페스트를 구문 분석하는 것이다.

다운로드된 매니페스트가 어떻게든 유효하지 않은 경우, 확장 프로그램은 다운로드를 대기하지 않도록 구성됩니다.

확장 프로그램이 매니페스트가 유효하다는 것을 알게 되면, 앱 그룹에 원자적으로 저장됩니다.

이것은 앱과 확장 프로그램이 나중에 참조할 수 있는 최신 버전의 매니페스트를 로컬로 가질 수 있도록 하는 것이다.

이 저장은 원자적으로 수행되기 때문에, withExclusiveControl을 사용하는 것은 필요하지 않습니다.

그런 다음 확장 프로그램은 확장 프로그램이 예약할 시스템으로 돌아갈 변경 가능한 다운로드 객체 세트를 생성합니다.

앞서 논의한 바와 같이, 필수 다운로드는 앱 설치 또는 앱 업데이트 중에만 지원됩니다.

그런 다음 원격인 모든 세션에 대한 매니페스트를 반복할 것이며, 이는 이러한 맥락에서 다운로드되지 않았다는 것을 의미합니다.

그런 다음 예약해야 하는 모든 다운로드에 대해 BAURLDownload 객체가 생성됩니다.

다운로드에는 고유한 식별자, URLRequest, 다운로드를 필수로 가져와야 하는지에 대한 주석, 파일 크기, 자산이 다운로드될 앱 그룹 및 스케줄러가 먼저 시작해야 하는 다운로드 제어에 대한 상대적 우선 순위가 제공됩니다.

명심해야 할 한 가지 중요한 점은 필수로 표시된 모든 다운로드에는 정확한 파일 크기가 있어야 하며, 그렇지 않으면 다운로드가 실패로 표시된다는 것입니다.

이것은 iOS 홈 화면, macOS Launchpad 및 App Store에서 원활한 진행을 지원하기 위한 것입니다.

이제 다운로드를 받을 수 있도록 지원했으니, 성공적인 다운로드를 처리하는 방법을 살펴봅시다.

앱이 실행되고 있지 않거나 앱에 BADownloadManager에 할당된 대리인이 없는 경우 확장 프로그램은 다운로드를 처리합니다.

내가 다운로드 완료된 핸들러에서 가장 먼저 구현할 것은 비동기적으로 독점적인 제어를 획득하는 것이다.

독점적인 제어를 획득하는 것은 비동기적이기 때문에, 우리는 확장자가 방금 우리에게 판매한 임시 파일을 붙잡아야 한다.

보시다시피, 저는 이 기능의 범위를 능가할 임시 위치로 파일을 이동하여 이 작업을 수행하고 있습니다.

나는 또한 확장 프로그램을 다운로드하는 임시 파일이 항상 정리되도록 스위프트 연기를 추가할 것이다.

시스템이 당신을 위해 파일을 삭제할 것이지만, 직접 관리하는 것이 가장 좋습니다.

그런 다음 앱 그룹에서 매니페스트를 로드하고 유효성을 확인할 것입니다.

그런 다음 확장 프로그램은 처리 중인 다운로드된 식별자가 매니페스트에서 예상되는 세션과 일치하는지 확인합니다.

그런 다음 확장자는 그 파일을 임시 위치에서 앱 그룹 내의 최종 목적지로 옮길 것이다.

그런 다음 세션이 적절한 위치에 다운로드되는지 빠르게 확인하기 위해 LocalSession이 구성됩니다.

마지막으로 처리해야 할 것은 실패한 다운로드이다.

일반적으로 잊혀지는 중요한 것은 BAManifestURL이 다운로드되지 않으면 확장 프로그램이 실제로 그것에 대해 통보된다는 것이다.

그 유형은 BAURLDownload에서 상속된다.

그러나, 그것은 정확한 내부 유형이 아니다.

따라서, 확장 필터는 BAURLDownload 객체만 처리하도록 합니다.

필수 자산이 전경에서 다운로드되기 때문에, 다운로드가 앱 설치 진행에 영향을 미치기 때문에 네트워크 연결을 위해 몇 초만 기다립니다.

따라서, 필수 다운로드가 실패할 경우 필수적이지 않은 것으로 다시 대기열에 있는 것이 좋은 생각일 수 있습니다.

필수 다운로드를 필수적이지 않은 것으로 쉽게 변환할 수 있는 한 가지 방법은 새로운 removingEssential() 함수를 사용하는 것입니다.

그 함수는 불필요한 복사본을 반환한다.

그런 다음 그 복사본을 BADownloadManager의 scheduleDownload 기능으로 판매합니다.

그러면 시스템은 적절한 시간에 다운로드를 가져올 것이다.

이제 우리 앱과 확장 프로그램이 백그라운드 자산을 완전히 채택했으므로, 특정 세션이 필수적으로 다운로드되었음을 나타내는 UI를 추가해 봅시다.

기억하세요, 필수는 앱 설치와 앱 업데이트가 자산이 완전히 다운로드될 때까지 앱 실행을 금지한다는 것을 의미합니다.

그러나, 실행이 차단되는 앱은 App Store 또는 TestFlight에서 설치하는 동안에만 발생하기 때문에, 표시기가 있는 것은 이것을 눈에 띄게 인식하는 좋은 방법입니다.

이 표시기는 VideoSelector 보기 내의 SwiftUI에서 구현될 것이다.

세션이 매니페스트에서 필수로 표시되면, 탐색 보기에 녹색 원이 그려집니다.

그리고 그게 전부야.

이제 백그라운드 자산을 구현하는 것이 얼마나 쉬운지 보았으니, 확장을 디버깅하고 진입점을 시뮬레이션하는 것을 살펴봅시다.

앞서 논의했듯이, 확장 프로그램은 앱 설치, 앱 업데이트 또는 주기적으로 백그라운드에서 시작됩니다.

앱 설치는 App Store에 의해 제어되고 주기적인 이벤트는 장치에 의해 제어되기 때문에, 디버깅하기 위해 확장 프로그램을 강제로 실행할 수 있는 방법이 필요합니다.

다행히도, 우리 팀은 확장을 시작하고 진입점을 시뮬레이션하는 데 사용할 수 있는 Xcode와 함께 제공되는 도구를 만들었습니다.

이 도구는 터미널에서 액세스할 수 있으며 xcrun backgroundassets-debug를 입력하여 시작할 수 있습니다.

또한 도움말 정보와 그에 따른 매뉴얼 페이지가 있습니다.

Backgroundassets-debug를 사용할 때, 다양한 유형의 BAContentRequests를 트리거할 수 있는 기능을 제공하는 시뮬레이션 인수를 전달합니다.

이러한 시뮬레이션 메시지 중 하나라도 장치로 전송되면, 디버깅을 용이하게 하기 위해 확장 프로그램의 런타임이 재설정됩니다.

Backgroundassets-debug는 여러 장치에 대한 지원을 포함하여 다양한 기능을 제공합니다.

장치가 Mac과 페어링되어 있는 한, 확장을 시뮬레이션하는 데 사용할 수 있습니다.

이러한 명령은 블루투스 또는 Wi-Fi를 통해 전송될 수 있으므로 장치를 USB를 통해 Mac에 테더링할 필요가 없습니다.

마지막으로, 장치가 backgroundassets-debug에 의해 트리거된 시뮬레이션 이벤트를 존중하려면 개발자 모드를 켜야 합니다.

이것은 장치의 설정 앱 내의 개인 정보 보호 및 보안 섹션에서 쉽게 활성화할 수 있습니다.

이제 우리가 방금 만든 데모 앱과 함께 backgroundassets-debug 도구를 사용하는 것을 살펴봅시다.

여기 우리는 터미널에 있어.

Xcode가 이 Mac에 설치되어 있기 때문에, 연결된 장치를 나열하겠습니다.

당신은 현재 연결된 장치가 하나만 있다는 것을 알게 될 것이며, 그것은 제 아이폰입니다.

시뮬레이션하기로 선택한 장치의 UUID를 복사하고 싶을 것입니다.

제공된 인수에서 장치의 UUID가 앱의 번들 식별자와 함께 존재한다는 것을 알 수 있습니다.

앱 설치 인수와 혼합된 시뮬레이션 인수를 사용하여 도구를 호출할 것입니다.

이것은 앱 확장이 초기 앱 설치 이벤트 중에 깨어나는 것처럼 깨어나게 할 것이다.

이제 엔터를 눌렀으니, 이 도구는 앱 설치 이벤트가 장치로 전송되었음을 알려줍니다.

앱을 실행하고 어떻게 생겼는지 봅시다.

보시다시피, 모든 세션 비디오는 다운로드를 위해 예약되었습니다.

내가 말하고 있는 것처럼, 그들 중 일부는 이미 다운로드를 마쳤다.

그리고 그것은 실행 중인 배경 자산이다.

만약 당신이 저와 같다면, 당신은 아마 이미 앱에서 대기 시간을 줄이는 많은 잠재적인 방법에 대해 생각하기 시작했을 것입니다.

이제 앱 확장 프로그램을 디버깅하는 방법을 보여줬으니, 기억해야 할 몇 가지 중요한 것들을 살펴봅시다.

필수 자산은 앱으로 다운로드하고 앱 설치 진행에 기여합니다.

따라서, 이러한 유형의 자산은 확장 내에서 BAContentRequest 설치 또는 업데이트 이벤트 중에만 예약이 가능합니다.

확장에 의해 수열에 있는 필수 다운로드가 실패하면, 앱은 결국 여전히 실행 가능해질 것이다.

해당 자산이 필요한 경우 확장 프로그램 내에서 또는 첫 번째 앱 실행 시 필수 다운로드를 필수적이지 않은 것으로 다시 대기열에 올려야 합니다.

필수로 표시되지 않은 모든 다운로드는 앱이 설치되거나 업데이트된 후 다운로드되며 백그라운드 다운로드 우선 순위를 받습니다.

확장은 메모리 사용에 의해 제한된다는 것을 기억하는 것도 중요하다.

따라서 작성한 코드가 메모리 임계값보다 훨씬 낮은지 확인하기 위해 확장 프로그램을 디버깅해야 합니다.

확장 프로그램이 과도한 메모리를 사용하는 경우, 디버깅하는 동안 메모리 예외로 충돌한다는 것을 알 수 있습니다.

앱 설치 또는 앱 업데이트 콘텐츠 요청 중에 확장 프로그램이 충돌하면, 앱을 즉시 실행할 수 있습니다.

그리고 마지막으로, 다운로드한 자산을 적절하게 관리하여 앱을 좋은 시민으로 만드는 것을 잊지 마세요.

이러한 자산을 관리하는 한 가지 방법은 앱의 캐시 디렉토리에 넣는 것입니다.

그래서 그것이 우리가 올해 배경 자산에 대해 가지고 있는 것이다.

이 세션에서 가져가야 할 것이 있다면, 앱에서 기다리는 것을 없애기 위한 것입니다.

대기를 없앨 수 있는 한 가지 방법은 배경 자산을 채택하고 새로운 필수 자산 기능을 사용하는 것입니다.

App Store에 앱을 제출하기 전에 TestFlight를 활용하세요.

TestFlight를 사용하면 필수 자산이 앱과 함께 다운로드될 때 어떻게 보이는지 볼 수 있습니다.

언제든지 질문이 있다면, 개발자 문서를 확인하고 Apple 개발자 포럼에 자유롭게 연락하세요.

저는 또한 당신이 피드백 어시스턴트를 활용하도록 격려하고 싶습니다.

우리 팀은 지속적으로 배경 자산을 개선하고 있으며, 당신이 그것을 앱에 채택하기를 기대하고 있습니다.

오, 그리고 아직 하지 않았다면, 배경 자산이 도입된 이전 세션을 확인하는 것이 좋습니다.

거기에는 많은 추가 정보가 있다.

그리고 그것과 함께, 오늘 나와 함께 해줘서 고마워.

애플의 모든 사람들을 대신하여, 시청해 주셔서 감사합니다.