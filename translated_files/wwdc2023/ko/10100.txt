10100

♪ 부드러운 기악 힙합 ♪

♪

안녕하세요, 제 이름은 로이이고, 저는 퍼포먼스 팀의 엔지니어입니다.

오늘, 우리는 당신이 공간 컴퓨팅을 위해 앱을 최적화하는 방법을 배울 것입니다.

우리는 먼저 성능과 전력을 위한 이 새로운 플랫폼의 독특한 측면을 살펴볼 것이다.

그런 다음 앱 프로파일링부터 시작하여 성과 계획을 수립할 것입니다.

그리고 마지막으로, 우리는 이 플랫폼의 성능 문제를 최적화하는 가장 좋은 방법을 둘러볼 것입니다.

그렇다면 공간 컴퓨팅이 전력과 성능을 다르게 만드는 것은 무엇인가요?

예를 하나, 앱 업데이트에 관계없이 디스플레이의 콘텐츠는 항상 업데이트됩니다.

사람들이 몸, 손 또는 눈을 움직일 때마다, 콘텐츠를 업데이트해야 한다.

이것은 시스템이 항상 모든 프레임을 렌더링하고 있다는 것을 의미한다.

이 플랫폼은 또한 모든 앱에서 시각과 상호 작용을 만들기 위해 항상 공간 알고리즘을 실행하고 있으며, 동시에 여러 앱을 실행할 수 있습니다.

사람들은 당신의 앱을 다른 앱과 함께 사용할 것입니다.

멀티태스킹과 추가 시스템 작업을 처리하려면, 가능한 한 자신의 앱의 리소스 사용을 최적화하세요.

훌륭한 사용자 경험을 제공하기 위해서는 앱의 성능이 필수적입니다.

사람들은 앱이 입력에 즉시 반응하고 몰입감과 편안함을 위해 부드러운 시각적 업데이트를 제공하기를 원합니다.

성능 문제에 대해 앱을 프로파일링하고 분석하는 방법에 대해 이야기해 봅시다.

당신은 이미 다른 Apple 플랫폼의 성능 지표에 익숙할 수 있습니다.

어떤 플랫폼에서든, 사람들은 빠르게 실행되고, 디스크 마모를 피하고, 배터리를 너무 많이 사용하지 않는 앱을 원한다.

그들은 또한 비효율적인 메모리 사용으로 인한 종료를 피하는 앱을 원한다.

공간 컴퓨팅을 통해, 이러한 지표 중 일부는 새로운 의미를 갖는다.

힘을 가져.

사용자는 배터리 수명이 아니라 열압 때문에 전력에 최적화된 앱을 원합니다.

뛰어난 성능을 유지하기 위해, 앱은 시스템 전력 사용에 최적화되어 열압에 직면할 가능성을 줄여야 합니다.

교수형은 또 다른 예이다.

그것들은 앱의 메인 스레드가 일정 기간 동안 작업을 할 때 중단될 때 발생한다.

하지만 이 플랫폼에서, 작고 순간적인 노점조차도 반응성을 방해한다.

이제 렌더링을 고려해 보세요.

다른 플랫폼에서는 주로 부드러운 UI와 3D 애니메이션을 제공하기 위해 렌더링 성능을 최적화할 수 있습니다.

하지만 여기서는 시스템이 항상 렌더링되기 때문에 렌더링 성능은 정적 콘텐츠에도 필수적이다.

모든 Apple 플랫폼은 이러한 지표를 프로파일링하는 도구를 제공합니다.

오늘, 우리는 특히 공간 컴퓨팅 앱을 위한 성능 문제를 찾는 것을 다룰 것입니다.

하지만 모든 Apple 플랫폼에서 이러한 메트릭에 대한 최적화에 대해 자세히 알아보려면, "궁극적인 애플리케이션 성능 생존 가이드" 세션을 확인하세요.

앱을 최적화하려면, 인스트루먼트와 Xcode 게이지와 같은 도구를 사용하여 개발 중에 프로필을 만드세요.

앱이 출시되면, 현장에서 더 많은 데이터를 수집하여 앱을 더욱 최적화할 수 있습니다.

개발 중 프로파일링에 대해 더 이야기해 봅시다.

RealityKit Trace는 성능과 전력을 위해 모든 공간 컴퓨팅 앱을 프로파일링하는 데 도움이 되는 Instruments의 새로운 템플릿입니다.

앱의 렌더링 성능이 좋지 않거나 시스템 전력 사용량이 높을 때 식별하는 데 도움이 될 수 있는 놀라운 도구입니다.

당신이 사용할 수 있는 더 많은 악기 템플릿이 있습니다.

더 많은 것을 배우고 이 새로운 템플릿을 탐색하려면, "RealityKit Trace를 만나세요" 세션을 시청하세요.

앱의 성능과 성능은 누군가가 어떻게 상호 작용하는지에 달려 있습니다.

시뮬레이터는 실제 장치와 동일한 작업을 수행하지 않으므로 성능 데이터가 정확하지 않을 수 있습니다.

장치의 프로필.

오디오나 비디오를 재생하거나 FaceTime 및 페르소나와 같은 기술을 사용할 때 앱에서 다양한 상호 작용을 사용하는 프로필.

사용 몇 분 동안 좋은 성능과 낮은 시스템 전력을 확인하십시오.

마지막으로, 다른 앱도 실행되고 리소스를 사용하는 동안 프로파일링을 시도해 보세요.

호환 가능한 iPad 및 iPhone 앱을 가져오는 경우, 필요한 추가 최적화를 식별하기 위해 장치에 프로파일링해야 합니다.

개발 후, 사람들은 다양한 조건에서 앱을 실행할 수 있습니다.

현장의 데이터는 사람들이 실제로 마주치고 있는 문제를 찾을 수 있는 좋은 방법이다.

앱이 베타 버전이거나 공개적으로 출시되면, MetricKit을 사용하여 사용자로부터 진단 보고서를 받으세요.

Xcode Organizer는 전력 문제를 찾는 데 도움이 되는 에너지 진단을 포함하여 동의한 사용자의 장치에서 집계된 성능 데이터를 제공합니다.

수집하는 이 모든 데이터는 병목 현상을 찾고 앱의 성능 작업의 우선 순위를 정하는 데 도움이 됩니다.

이제, 공간 컴퓨팅 앱 최적화에 대해 이야기해 봅시다.

성능 문제는 많은 분야에서 발생할 수 있다.

오늘, 우리는 렌더링, 사용자 입력, ARKit, 오디오 및 비디오 재생, SharePlay 및 시스템 압력으로 인한 앱 종료와 같은 몇 가지 핵심 영역을 최적화하기 위한 전략을 다룰 것입니다.

훌륭한 렌더링 성능은 훌륭한 사용자 경험을 위한 최우선 과제 중 하나입니다.

뛰어들자.

이 플랫폼에서 렌더링 파이프라인은 앱의 콘텐츠를 업데이트하는 앱으로 시작됩니다.

모든 Apple 플랫폼과 마찬가지로, 앱의 인터페이스는 메인 스레드에서 업데이트되며 즉시 업데이트를 제공해야 합니다.

앱이 다른 앱과 함께 3D 공간에서 렌더링되기 때문에, 업데이트는 시스템 렌더링 서버로 전송됩니다.

렌더링 서버는 앱, 사용자의 입력, 공간 및 주변 환경의 업데이트를 처리하기 위해 지속적으로 실행됩니다.

이 모든 업데이트로 새 프레임을 렌더링하고 컴포지터로 보냅니다.

작곡가는 항상 렌더링하고 있다.

그것은 디스플레이의 재생률과 일치하는 속도로 디스플레이에 새로운 프레임을 공급합니다.

이것은 편안한 경험을 제공하는 데 도움이 된다.

이 속도는 보통 초당 90프레임이지만, 더 높을 수 있다.

컴포지터가 디스플레이를 지속적으로 업데이트하는 동안, 훌륭한 사용자 경험은 여전히 앱에서 빠른 시각적 업데이트가 필요합니다.

앱에 렌더링하는 데 너무 오래 걸리는 콘텐츠나 업데이트가 있는 경우, 렌더링 서버는 최적의 렌더링 대기 시간을 위해 렌더링 마감일을 놓칠 수 있습니다.

이것은 앱 비주얼이 프레임 Y의 컴포지터로 만들 수 있었지만, 대신 프레임 Y+1로 만들 수 있다는 것을 의미합니다.

이것은 사람들이 디스플레이에서 보는 시각적 업데이트를 지연시키고 앱이 반응하지 않게 만듭니다.

특히 심각한 렌더링 지연으로 인해 앱이 종료될 수도 있습니다.

앱이 SwiftUI, UIKit, RealityKit 또는 Metal을 기반으로 구축되었든, 콘텐츠와 업데이트를 최적화하여 프레임 드롭과 렌더링 서버에서 수행되는 작업을 줄이고 싶습니다.

SwiftUI와 UIKit 사용을 최적화하는 것부터 시작합시다.

이 플랫폼에서, 시스템은 앱 업데이트 없이도 정적 UI 콘텐츠에 대한 작업을 렌더링합니다.

이 렌더링 작업은 초과 인출에서 증가할 수 있다.

오버드로는 다른 가상 콘텐츠 앞에 반투명 콘텐츠가 있을 때 발생합니다.

GPU는 두 콘텐츠를 모두 렌더링하기 위해 작업을 해야 하지만, 반투명 콘텐츠가 완전히 불투명하다면, GPU는 그 뒤에 UI를 렌더링할 필요가 없을 것이다.

Z 오프셋과 겹치는 UI 뷰가 있다면, 반투명도를 추가하지 마세요.

또한, 앱의 UI가 차지하는 디스플레이의 픽셀이 많을수록, 창을 렌더링하기 위해 더 많은 작업이 수행됩니다.

기본 크기를 줄이는 것을 고려해 보세요.

렌더링 서버의 UI 다시 그리기는 일반적으로 앱 업데이트에 의해 트리거되지만, 이 플랫폼에서는 핵심 애니메이션 레이어의 동적 콘텐츠 확장에 의해 트리거됩니다.

이러한 동작으로, 텍스트 또는 벡터 기반 UI 콘텐츠의 해상도는 사용자가 더 선명한 비주얼을 허용하려는 위치에 따라 변경됩니다.

이것은 또한 앱 업데이트가 없어도 잠재적으로 더 높은 규모로 UI 콘텐츠를 더 자주 다시 그릴 수 있다.

SwiftUI와 UIKit은 기본적으로 이 동작을 활성화하지만, 사용자 지정 코어 애니메이션 또는 코어 그래픽 렌더링을 수행하는 앱은 이 동작을 선택할 수 있습니다.

시각적 이점과 절충에 대해 자세히 알아보려면, "공간 컴퓨팅을 위한 렌더링 탐색" 세션을 시청하세요.

이러한 다시 그리기의 비용은 오프스크린 렌더링 패스에 크게 영향을 받는다.

이것은 그림자, 흐림, 마스킹과 같은 시각 효과로 인해 발생할 수 있다.

시스템이 앱을 더 쉽게 렌더링할 수 있도록 이러한 효과를 줄이세요.

앱에서 다시 그린 것을 최소화하려면, 가능할 때마다 불필요한 보기 업데이트를 피하세요.

예를 들어, SwiftUI를 사용하면 @Observable을 사용하세요.

@Observable은 더 세분화된 변경 추적을 제공하고 불필요한 레이아웃 업데이트를 줄입니다.

다음으로, RealityKit으로 3D 렌더링을 최적화하는 것에 대해 이야기해 봅시다.

SwiftUI는 올해 공간 컴퓨팅을 위해 RealityView를 추가했다.

SwiftUI 계층 구조 내에서 RealityKit 3D 장면을 기본적으로 표시할 수 있습니다.

당신의 앱은 이러한 모든 RealityKit 기능에 대해 3D 장면을 최적화함으로써 플랫폼에서 좋은 시민이어야 합니다.

이 3D 장면에서, 그들이 포함하는 자산의 복잡성은 각 프레임에서 수행되는 렌더링 서버 작업의 양을 크게 증가시킬 수 있다.

그러니 이 자산들을 최적화하는 것부터 시작합시다.

Reality Composer Pro는 자산에서 RealityKit 장면을 만들 수 있도록 도와줍니다.

메쉬 렌더링, 입자, 애니메이션, 물리학 및 오디오 작업에서 이 도구는 성능 영향을 이해하는 데 도움이 될 수 있는 전체 장면에 대한 통계를 제공합니다.

이러한 통계를 검토할 때, 낮은 숫자는 일반적으로 렌더링 성능을 향상시킬 수 있는 더 적은 작업을 의미합니다.

"빠른 공간 경험을 위한 3D 모델 만들기" 세션을 시청하여 3D 자산의 비주얼 및 전력 사용에 대한 모범 사례에 대해 자세히 알아보세요.

특히 메쉬 렌더링은 3D 렌더링의 핵심 부분이다.

복잡한 메쉬와 재료는 빠르게 성능 병목 현상이 될 수 있다.

메쉬 자산의 형상을 최적화하세요.

재료를 공유하는 부품을 결합하여 별도의 메쉬 부품의 양을 줄이세요.

삼각형과 정점 수가 높은 메쉬 형상도 비용이 많이 들 수 있다.

필요에 따라 더 적은 수의 자산을 사용하세요.

3D 메쉬로 오버드로의 영향을 최소화하세요.

이렇게 하려면, UI 콘텐츠와 마찬가지로 투명성을 아껴서 사용하세요.

Reality Composer Pro의 "물리 기반" 재료는 환경 조명을 갖추고 있으며, 잘 최적화되어 있으며, 최소한의 투명성으로 메쉬에 가장 잘 작동합니다.

하지만 반투명하거나 매우 큰 콘텐츠의 경우, 조명이 켜지지 않은 표면이 있는 사용자 지정 재료를 사용하고, 구운 조명 질감 또는 기타 저렴한 비주얼을 사용하는 것을 고려하십시오.

이것은 더 비싼 조명 계산으로 잠재적인 병목 현상을 피하는 데 도움이 된다.

RealityKit에서 자료 구축 및 사용에 대한 추가 지침을 보려면, 이 두 세션을 시청하세요.

런타임 렌더링에 최적화된 콘텐츠를 갖는 것은 좋은 시작이다.

하지만 RealityKit으로 앱을 최적화하기 위해 할 수 있는 일이 훨씬 더 많습니다.

앱이 RealityKit 콘텐츠를 업데이트하면, 업데이트가 렌더링 서버로 전송되어 적용되고 렌더링됩니다.

하지만 짧은 기간에 너무 많은 업데이트는 렌더링 서버의 병목 현상이 될 수 있다.

예를 들어, 당신의 앱은 RealityKit 엔티티를 빠르게 만들고 파괴할 수 있습니다.

너무 많은 복잡한 애니메이션을 가지고 있거나, 너무 많은 SwiftUI 뷰를 업데이트하거나, 단일 프레임에 많은 자산을 로드할 수 있습니다.

엔티티를 미리 만들고, 필요에 따라 숨기거나 보여주세요.

그것들을 제거하여 장면 계층에 추가하거나, isEnabled 플래그를 사용할 수 있습니다.

메쉬 엔티티 계층을 평평하게 함으로써 업데이트되는 엔티티의 양을 최소화하세요.

코드 기반 애니메이션의 경우, 업데이트 속도를 낮추거나 애니메이션이 업데이트하는 엔티티의 수를 줄이는 것을 고려하십시오.

그리고 RealityKit 엔티티를 업데이트할 때, 실수로 과도한 SwiftUI 다시 그리기를 유발하지 마십시오.

첨부 파일을 사용할 때, 모든 SwiftUI 콘텐츠에 대해 최적화하는 것과 같은 방식으로 렌더링을 최적화해야 합니다.

복잡한 자산을 로드하는 것은 또한 값비싼 렌더링 업데이트를 유발할 수 있다.

복잡한 자산은 또한 높은 앱 출시와 콘텐츠 로딩 시간에 기여할 수 있다.

런타임에 비동기 로딩 API를 사용하여 메인 스레드를 차단하고 필요하기 전에 자산을 로드하십시오.

동일한 자산을 사용하는 엔티티는 그 자산을 공유하고 한 번만 로드할 수 있다.

이 파일들은 로딩 시간과 메모리 비용에 최적화되어 있으므로 Reality Composer Pro에서 내보낸 파일을 사용하세요.

또한 텍스처 압축을 무료로 받을 수 있습니다.

자산 크기를 줄이면 일반적으로 로딩 속도가 빨라지지만, 텍스처 압축은 이미 Reality Composer Pro 파일에서 발생하므로 직접 할 필요가 없을 수도 있습니다.

마지막으로, RealityKit의 몰입형 경험에 대해 이야기해 봅시다.

앱이 전용 전체 공간으로 이동하도록 요청하면, 실행되는 유일한 전경 경험이 됩니다.

포털을 사용하거나 완전히 몰입형 경험으로 이동할 때, 시스템은 또한 사람의 주변 환경의 일부 또는 전부를 숨깁니다.

당신의 앱은 공간을 채우기 위해 RealityKit 콘텐츠로 환경을 만들 수 있습니다.

완전한 몰입형 콘텐츠는 공유 공간이나 전체 공간의 장면보다 디스플레이에서 훨씬 더 많은 픽셀로 렌더링되어야 합니다.

이것은 그 콘텐츠를 렌더링하기 위해 GPU에서 더 많은 작업을 수행할 수 있다는 것을 의미한다.

GPU 전력 사용을 위해 이러한 유형의 콘텐츠를 최적화하세요.

최적의 전력 사용을 위해 Reality Composer Pro에서 조명이 켜지지 않은 표면이 있는 "사용자 지정" 재료로 시작하세요.

구운 조명 질감을 추가하거나 시간 기반 애니메이션을 사용하여 역동적인 조명의 느낌을 얻는 것을 고려해 보세요.

시스템 파워와 렌더링 성능을 위해 재료를 프로파일링하세요.

당신은 또한 메탈로 완전히 몰입감 넘치는 경험을 만들 수 있습니다.

3D 엔진을 구축하거나 Metal을 사용한 경험을 위해, 최적화해야 할 몇 가지 사항에 대해 이야기해 봅시다.

CompositorServices 프레임워크와 함께 Metal을 사용하여 렌더링 서버를 우회하고 렌더링된 표면을 작곡가에게 직접 보낼 수 있습니다.

이것을 제대로 하는 방법을 배우려면 "몰입형 앱을 위한 금속 발견" 세션을 시청하세요.

CompositorServices를 사용할 때, Compositor가 각 업데이트에서 새 프레임을 받을 수 있도록 Metal 프레임 제출 속도를 조정하십시오.

새로운 foviation 지도를 쿼리하고 각 프레임마다 예측을 게시하세요.

그리고 GPU 작업을 인코딩하기 위해 사용하기 전에 마지막 순간에 이 입력 데이터를 쿼리하세요.

이 세 가지를 모두 수행하면 사용자 움직임과 입력과 관련하여 반응형 가상 콘텐츠를 보장하는 데 도움이 됩니다.

앱이 새 프레임을 제출하는 데 너무 오래 걸리면, 시스템은 그것을 종료합니다.

긴 프레임 가판대를 피하세요.

앱을 실행하는 동안 Metal System Trace Instruments 템플릿을 사용하여 GPU 성능을 프로파일링해야 합니다.

Metal 앱이나 Reality Composer Pro의 사용자 지정 자료에서 장기간 실행되는 조각 및 정점 셰이더 실행은 시스템 렌더링 시간에 큰 영향을 미칠 수 있습니다.

조각과 정점 시간을 줄이려면, 셰이더에 의한 ALU 명령과 텍스처 액세스를 줄이는 것으로 시작하세요.

금속의 경우, 가능한 경우 대신 컴퓨팅 셰이더를 사용하세요.

이 강연을 검토하여 GPU 성능 최적화에 대해 자세히 알아보세요.

UI와 3D 렌더링 성능을 위해 앱을 최적화하는 것이 전반적인 사용자 경험에 도움이 된다는 것을 기억하십시오.

이제 입력 성능으로 넘어갑시다.

사람들은 이 플랫폼에서 눈, 손, 음성 및 하드웨어 입력을 사용할 수 있습니다.

입력에 대한 앱 업데이트는 메인 스레드에서 처리됩니다.

이것들이 너무 오래 걸리면, 앱이 느리고 반응이 없는 것처럼 느껴집니다.

메인 스레드의 입력 업데이트는 디스플레이 재생률에 따라 특정 마감일 내에 완료되어야 합니다.

이 플랫폼의 하드웨어는 보통 90헤르츠 이상의 재생률을 가지고 있다.

90 헤르츠 재생률의 경우, 최적의 대기 시간을 위해 입력 업데이트를 8밀리초 미만으로 유지하세요.

공간 콘텐츠와 상호 작용할 때, 시스템은 사용자가 상호 작용하려고 하는 UI 또는 3D 개체를 확인하기 위해 테스트 작업을 수행합니다.

RealityKit 콘텐츠의 경우, 그들과 상호 작용하기 위해 물리 충돌기를 추가할 것입니다.

이 충돌기를 추가할 때, 정적 충돌기가 더 저렴하기 때문에 가능할 때마다 동적 충돌기보다 정적 충돌기를 사용하세요.

앱에서 중복 히트 테스트 작업을 줄이려면, 대화형 콘텐츠가 겹치는 것을 최소화하십시오.

이제, ARKit으로 넘어가자.

이 플랫폼에서 ARKit 알고리즘은 모든 앱에서 비주얼과 상호 작용을 만들기 위해 항상 실행됩니다.

앱은 ARKit 데이터를 사용하고 가상 콘텐츠를 고정하는 방법에 따라 시스템 성능과 시각적 부드러움에 영향을 미칠 수 있습니다.

예를 들어, 앱은 ARKit 또는 RealityKit을 사용하여 사용자의 주변, 머리 또는 손에 앵커 콘텐츠를 배치할 수 있습니다.

모든 앵커는 시스템에 대한 추가 작업을 추가합니다.

콘텐츠를 고정할 때, 사용자의 공간에서 앵커를 지속적으로 추적해야 하는지 고려하십시오.

RealityKit에서 AnchorComponent를 사용할 때, 지속적인 추적 비용을 피하기 위해 "한 번" 추적 모드를 사용하세요.

앱에서 지속적이고 일시적인 앵커의 총량을 최소화하세요.

특히 지속적인 앵커의 경우, 모든 앱이 그것들을 추가할 수 있으므로, 자신의 앱에서 너무 많이 추가하지 마세요.

ARKit 데이터를 사용하는 동안 할 수 있는 더 많은 최적화가 있습니다.

앱 콘텐츠에 너무 오래된 ARKit 데이터를 적용하면, 앱 비주얼은 입력과 동기화되지 않는 것처럼 보일 수 있습니다.

사용하기 직전에 ARKit 데이터를 쿼리하고 즉시 업데이트에 적용하세요.

사후 예측은 계산하는 데 비용이 많이 든다.

일반적으로, 맞춤형 금속 렌더링 엔진만 이 데이터가 필요합니다.

앱 콘텐츠를 장면에 배치하고 싶다면, RealityKit은 대신 훌륭한 선택입니다.

장면 이해 메쉬를 위한 충돌 데이터를 생성하는 것도 비용이 많이 든다.

이 데이터를 사용하는 경우, 앱이 더 이상 필요하지 않을 때 끄세요.

이제, 공간 컴퓨팅을 위한 오디오 및 비디오 재생 최적화에 대해 이야기해 봅시다.

공간 오디오는 이 플랫폼에서 기본적으로 사용됩니다.

시스템은 사용자의 위치, 주변 환경 및 오디오 소스에 대한 정보를 실시간으로 처리하여 오디오를 출력합니다.

앱이 공간 오디오 작업을 너무 많이 유발하면 시스템 전력 사용에 문제가 발생하거나 오디오 출력이 지연될 수 있습니다.

이러한 문제를 본다면, 공간 오디오 작업을 줄이기 위해 살펴봐야 할 세 가지 주요 사항이 있습니다: 오디오 소스 동시 재생, 움직이는 오디오 소스의 수, 그리고 사운드 스테이지의 크기.

이 모든 것은 계산 작업을 증가시킬 수 있는 변수이다.

이제, 비디오를 고려해 봅시다.

공유 공간에서, 사람들은 한 번에 여러 개의 비디오를 재생할 수 있다.

각 비디오에 대해, 시스템은 그것을 디코딩하고 렌더링 서버에서 렌더링해야 합니다.

각각의 새로운 렌더링된 비디오 프레임은 훌륭한 비디오 시청 경험을 위해 일관된 간격으로 디스플레이에 표시되어야 합니다.

렌더링 서버에 렌더링 마감일을 맞출 수 있는 많은 전력과 시간을 제공하기 위해, 앱은 비디오 재생 중에 UI 또는 3D 콘텐츠에 대한 업데이트를 최소화해야 합니다.

비디오 프레임 속도는 또한 완료된 작업에 영향을 미친다.

최적의 성능과 전력을 위해 24 또는 30 헤르츠 비디오를 사용하는 것을 고려해 보세요.

마지막으로, 언제든지 앱에서 장치에서 재생하고 렌더링해야 하는 동시 비디오의 수를 줄이세요.

비디오 프레젠테이션 방법 중에서 선택할 때, 다양한 기능과 성능에 대해 어떻게 최적화하고 싶은지 고려하십시오.

자세한 내용을 보려면 "훌륭한 공간 재생 경험 만들기" 세션을 시청하세요.

이제, SharePlay에 대해 이야기해 봅시다.

이 플랫폼은 사람들과 협력하고 연결할 수 있는 완전히 새로운 경험을 열어줍니다.

진정으로 훌륭한 SharePlay 그룹 경험을 만들기 위해, 당신은 당신의 앱이 오랜 기간 동안 훌륭한 성능을 유지할 수 있도록 하고 싶을 것입니다.

그리고 SharePlay의 훌륭한 공간 컴퓨팅 성능은 기본부터 시작됩니다.

먼저 로컬 성능을 위해 앱을 프로파일링하고 최적화하세요.

그런 다음 SharePlay 중에 앱의 성능을 검사하여 값비싼 렌더링 업데이트가 장치 간에 동기화되지 않도록 하십시오.

시스템 전력 요구가 열압을 생성하지 않도록 전력에 대한 앱을 프로파일링하여 앱이 뛰어난 성능을 유지하는 것을 방지할 수 있습니다.

이를 돕기 위해, 앱의 어떤 작업과 기능이 앱의 SharePlay 경험에 필수적인지 신중하게 고려하고, 필요하지 않은 모든 것을 끄세요.

마지막으로, 열 또는 메모리 압력으로 인한 앱 종료를 살펴봅시다.

사람들은 따뜻한 곳에서 이 장치를 사용할 수 있다.

모든 Apple 플랫폼과 마찬가지로, 이 시스템은 사용할 때 장치를 시원하고 편안하게 유지하기 위해 열압 하에서 사용할 수 있는 계산 자원을 관리합니다.

계산 자원이 낮으면 앱의 성능에 영향을 미칠 수 있습니다.

시스템은 심각한 열압으로 인해 또는 렌더링 마감일이 더 이상 충족되지 않기 때문에 앱을 종료할 수도 있습니다.

열압이 있을 때, 좋은 성능을 유지하고 열압이 더 증가하지 않도록 앱에서 작업을 덜 하세요.

thermalStateDidChange 알림을 구독하여 이것을 하세요.

압력이 높아지면, 그에 따라 앱의 콘텐츠와 업데이트를 조정하세요.

앱이 열압 하에서 어떻게 작동하는지 보려면, Xcode의 열 유도기를 사용하여 장치의 더 높은 열 상태를 시뮬레이션하십시오.

열압에 대해 더 알아보려면, " 불리한 네트워크 및 온도 조건을 위한 설계" 세션을 확인하세요.

다음으로, 기억력 압력에 대해 이야기해 봅시다.

장치에는 시스템과 실행 중인 모든 앱 간에 공유되는 제한된 양의 메모리가 있습니다.

장치가 이 한도에 가까워지면, 시스템은 적극적으로 사용되지 않는 앱부터 시작하여 앱을 종료하기 시작합니다.

너무 많은 메모리를 사용하는 단일 앱은 사용되더라도 종료될 수 있다.

당신은 당신의 앱에서 이런 일이 일어나는 것을 원하지 않습니다.

앱의 메모리 사용량을 최대한 줄임으로써 이것을 피할 수 있습니다.

이 플랫폼에서 앱은 UI 및 3D 렌더링, 오디오 및 비디오 재생에 할당된 많은 양의 메모리를 가질 가능성이 더 높다.

앱에 UI 콘텐츠가 있는 경우, 오프스크린 렌더링 패스, 총 창 및 미디어 콘텐츠를 최소화하여 렌더링 메모리 할당을 줄이십시오.

RealityKit을 사용한 3D 메모리의 경우, 메쉬와 입자에 대한 텍스처와 지오메트리 사이저의 해상도는 메모리 사용에 크게 기여할 수 있습니다.

당신이 할 수 있는 곳에서 그것들을 줄이세요.

오디오와 비디오를 재생할 때, 앱의 모든 오디오 및 비디오 파일의 총 메모리 부하를 평가하십시오.

해상도, 비트레이트, 파일 형식 및 기간을 변경할 때, 메모리 절약에 대한 사용자 경험과 성능에 대한 절충점을 고려하십시오.

이 회담을 검토하여 모든 Apple 플랫폼에서 메모리 공간을 줄이기 위한 더 많은 팁을 알아보세요.

이 플랫폼에서 훌륭한 사용자 경험을 위해서는 성능이 필수적이라는 것을 기억하세요.

시작하려면, 성능과 전력 문제를 찾기 위해 개발 중에 앱을 적극적으로 프로파일링하세요.

공간 컴퓨팅을 위한 중요한 지표를 중심으로 성과 계획을 세우세요.

그리고 렌더링, 전력 및 오늘 다룬 다른 모든 영역을 위해 앱을 최적화하세요.

그리고 마지막으로, MetricKit 및 Xcode Organizer와 같은 도구로 성능 필드 데이터를 수집하세요.

당신이 이 플랫폼에서 생각해낸 모든 훌륭한 앱과 경험을 빨리 보고 싶어요.

봐줘서 고마워.

♪