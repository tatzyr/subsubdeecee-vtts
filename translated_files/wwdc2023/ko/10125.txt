10125

♪ ♪

조지: 안녕 그리고 환영해!

저는 GPU, 그래픽 및 디스플레이 소프트웨어의 소프트웨어 엔지니어인 Georgi Rakidov입니다.

이 세션은 게임을 Mac으로 가져오는 데 도움이 되는 3부작 시리즈 중 세 번째입니다.

첫 번째 세션은 새로운 게임 포팅 툴킷을 사용하여 Mac에서 수정되지 않은 Windows 게임을 실행하여 그래픽, 오디오 및 디스플레이 기능을 평가하는 방법을 다룹니다. 두 번째 세션은 새로운 메탈 셰이더 컨버터 도구를 사용하여 기존 HLSL 셰이더를 메탈로 컴파일하여 얼마나 많은 개발 시간을 절약할 수 있는지 보여줍니다.

이 세션은 렌더러를 메탈로 이식하고 Apple Silicon에서 뛰어난 성능을 얻는 방법에 대한 자세한 통찰력을 제공하여 게임을 Mac으로 가져오는 과정을 완료합니다.

렌더러를 메탈로 포팅할 때, 엔진이 다른 플랫폼 그래픽 API의 개념을 메탈에 매핑해야 한다는 것을 알게 될 것입니다.

이를 돕기 위해, 이 세션은 Metal 모범 사례와 함께 네 가지 주제를 다루므로 Apple GPU의 강력한 아키텍처를 활용할 수 있습니다.

각 게임은 텍스처와 데이터 버퍼를 포함한 GPU 리소스를 GPU에서 사용할 수 있도록 하고 셰이더가 액세스할 수 있는 방법을 구성할 책임이 있습니다.

당신의 게임은 GPU에 명령을 제출하는 방법을 최적화하여 Apple 프로세서의 강력한 그래픽 아키텍처를 활용할 수 있습니다.

게임은 일반적으로 간접 렌더링을 사용하여 현대적인 렌더링 기술을 구현합니다.

MetalFX는 게임이 더 낮은 해상도로 렌더링한 다음 MetalFX를 최종 해상도로 확장하여 각 프레임의 시간을 절약할 수 있도록 도와줍니다.

자원을 관리할 때, 각 엔진은 GPU가 각 텍스처, 데이터 버퍼에 어떻게 접근하는지 결정해야 한다.

메탈에서는 셰이더에게 바인딩이 있는 리소스에 대한 액세스를 제공하고, 리소스를 GPU 액세스 가능한 메모리에 상주하고 동기화된 액세스를 유지하는 것에 대해 생각하는 것이 중요합니다.

자원 바인딩과 셰이더는 함께 간다.

올해 새로운 도구인 메탈 셰이더 컨버터로 기존 셰이더를 번역하는 것으로 시작하여 셰이더를 메탈로 포팅하는 데 많은 시간을 절약할 수 있습니다.

이 시리즈의 "쉐이더 컴파일" 세션에서 더 많은 것을 배울 수 있습니다.

금속 셰이더 컨버터는 선택할 수 있는 두 가지 바인딩 모델을 제공합니다.

"자동 레이아웃"을 사용하면 변환기가 바인딩 정보를 자동으로 생성하거나, "명백한 레이아웃"을 사용하여 바인딩 정보를 Metal Shader Converter에 전달할 수 있습니다.

명시적인 레이아웃은 매우 유연하며 다른 플랫폼에서 바인딩 모델을 구현해야 할 때 도움이 될 수 있습니다.

예를 들어, 일부 API 디자인은 셰이더 루트 서명을 사용하며, 여기에 네 개의 항목이 있는 일반적인 것이 있습니다: 일련의 텍스처를 가리키는 설명자 테이블, 버퍼 루트 매개 변수, 32비트 상수 및 일련의 샘플러를 가리키는 또 다른 설명자 테이블.

각 설명자 테이블은 모든 텍스처, 모든 샘플러 또는 모든 버퍼와 같은 동일한 유형의 요소를 포함하는 리소스 배열입니다.

금속의 인수 버퍼는 요소가 여러 유형일 수 있다는 점에서 더 유연하다.

하지만 엔진이 동질적인 배열을 기대한다면, 인수 버퍼로 쉽게 인코딩할 수 있습니다.

이 예제는 텍스처 설명자 테이블과 동등한 것을 인코딩합니다.

각 텍스처에 대한 금속 리소스 ID를 저장하여 텍스처 설명자 테이블 역할을 하는 금속 버퍼를 할당하는 것으로 시작합니다.

각 텍스처를 만들 때, 코드는 resourceID를 테이블에 직접 저장합니다.

좋은 점은 렌더링 루프의 전면과 외부에서 이와 같은 코드를 실행할 수 있다는 것입니다!

샘플러 설명자 테이블을 인코딩하는 과정은 거의 동일합니다.

텍스처와 마찬가지로, 코드는 샘플러 설명자 테이블 역할을 하는 금속 버퍼를 만드는 것으로 시작합니다.

코드가 각 샘플러의 설명자를 구성할 때, supportArgumentBuffers 속성을 yes로 설정합니다.

코드가 설명자로 샘플러를 만든 후, 샘플러의 resourceID를 테이블에 저장합니다.

인수 버퍼를 사용하여 최상위 루트 서명 자체를 나타낼 수도 있습니다.

이 예제는 루트 서명의 구조를 정의하고 하나의 인스턴스를 저장할 수 있는 금속 버퍼를 만듭니다.

이 코드는 구조 필드의 각 필드에 텍스처와 샘플러 테이블의 GPU 주소를 포함하여 적절한 값을 할당합니다.

그것이 루트 서명을 변환하는 데 필요한 전부입니다.

인수 버퍼는 Metal 3에서 매우 효율적입니다!

이제 최상위 인수 버퍼를 셰이더에 바인딩할 수 있습니다.

이 부분은 렌더링 루프에서 수행되지만, 렌더링 루프 외부에서 사전에 설명자 테이블과 루트 구조를 만들 수 있습니다.

메탈 3 인수 버퍼는 루트 시그니처와 설명자 테이블을 포함한 다른 바인딩 모델을 번역하는 유연하고 성능이 뛰어난 방법을 제공합니다.

셰이더가 액세스하려면 주어진 패스 또는 렌더링 단계를 실행하는 동안 리소스가 상주해야 합니다.

그리고 자원이 패스 간에 공유된다면, 그 패스의 실행 순서는 동기화되어야 한다.

메탈 인수 버퍼와 함께 바인딩리스 리소스를 사용하려면 모든 GPU 아키텍처에서 명시적인 레지던시 관리가 필요하며, 메탈은 레지던시를 제어하는 효율적인 방법을 제공합니다.

권장 사항은 모든 읽기 전용 리소스를 큰 힙으로 그룹화하는 것이다.

그렇게 하면, 인코더당 useHeap을 한 번 호출할 수 있으며 모든 읽기 전용 리소스는 해당 패스 또는 렌더링 단계 기간 동안 상주하게 되며 셰이더가 액세스할 수 있습니다.

이게 네가 할 수 있는 방법이야.

모든 읽기 전용 리소스를 할당하는 데 필요한 크기의 힙을 만든 다음, 이 힙에서 각 리소스를 할당하십시오.

그리고 렌더링 시간에, useHeap에 전화하여 이 모든 자원을 상주하게 하세요.

쓸 수 있는 자원의 경우, 이야기는 조금 다르다.

쓰기 가능한 리소스를 개별적으로 할당하고 올바른 사용 플래그로 useResource를 호출하는 것을 고려하십시오.

이 경우, 메탈은 당신을 위해 동기화를 처리하고 성능을 최적화할 것입니다.

이것은 금속 인코더에서 자원을 수동으로 동기화하는 부담을 피하는 데 도움이 될 것입니다.

이전과 마찬가지로, 이번에는 힙에 의해 뒷받침되지 않는 자원을 할당하는 것으로 시작합니다.

그런 다음, 이러한 리소스에 액세스할 인코더의 경우에만 올바른 사용 플래그로 useResource를 호출하십시오.

이 예에서, 인코더는 텍스처에 쓰고 버퍼에서 읽고 있다.

여기 이 추천이 있는 테이블이 있습니다.

읽기 전용 리소스와 쓰기 가능한 리소스는 모두 최상위 인수 버퍼에서 액세스할 수 있습니다.

이상적인 경우, 인코더당 한 번만 설정하세요.

읽기 전용 리소스, 힙으로 그룹화, 위험 추적 모드가 추적되지 않음으로 설정됨.

힙 레지던트에 있는 모든 자원을 만들려면, 인코더당 한 번 useHeap을 호출하세요.

개별적으로 할당된 쓰기 가능한 자원은 위험 추적과 동기화를 금속에 남긴다.

그리고 각 리소스 호출에 대해, 인코더당 한 번 리소스를 사용하세요.

이건 효율적인 접근 방식이야!

CPU 오버헤드가 낮은 바인드리스 모델을 구현하며, 애플리케이션은 위험 추적 및 동기화, 심각한 노력이 필요한 복잡한 작업 및 개발 시간에 대해 걱정할 필요가 없습니다.

바인딩리스, 레지던시 및 동기화에 대한 자세한 내용은 "Go bindless with Metal 3" 세션을 참조하십시오. 코드에 리소스 바인딩, 레지던시 및 동기화가 구현되면 화면에서 무엇이든 렌더링하려면 엔진이 렌더러에 명령을 보내야 합니다.

애플 프로세서는 명령 실행을 최적화하는 많은 기능을 가지고 있다.

GPU는 CPU와 GPU가 시스템 메모리를 공유하는 통합 메모리 아키텍처를 갖춘 타일 기반 지연 렌더러 또는 TBDR입니다.

또한, GPU는 타일 메모리라고 불리는 빠른 온칩 메모리를 가지고 있다.

이 아키텍처를 활용하기 위해, 메탈은 패스의 개념을 가지고 있으며, 당신의 목표는 렌더링 명령을 패스로 그룹화하고 그 패스를 적절하게 구성하는 것입니다.

TBDR 아키텍처에 대해 자세히 알아보려면, "Metal 앱을 Apple Silicon Macs로 가져오세요" 및 "Harness AppleGPUs with Metal" 관련 프레젠테이션을 참조하십시오.

다른 API는 다른 유형의 GPU 명령을 혼합하는 지속적인 스트림을 가질 수 있으며, 엔진은 이것을 가정할 수 있습니다.

명령을 메탈로 번역하면, 먼저 명령 버퍼를 만듭니다.

그런 다음, 명령, 그래픽, 컴퓨팅 또는 Blit의 유형에 따라, 당신은 그것들을 패스로 그룹화합니다.

명령 인코더를 사용하여 각 패스에 대한 명령을 명령 버퍼에 작성합니다.

결국, 모든 명령이 인코딩되면, GPU에서 실행하기 위해 명령 버퍼를 명령 대기열에 제출하십시오.

당신의 엔진은 렌더링 명령을 메탈로 효율적으로 변환하기 위한 네 가지 모범 사례를 고려할 수 있습니다.

렌더링이 시작되기 전에 복사본을 일괄 처리하여 시작하고, 같은 유형의 명령을 그룹화하고, 렌더링 대상을 지우기 위해 빈 인코더를 사용하지 마십시오.

그리고 마지막으로, 메모리 대역폭을 최소화하기 위해 Metal Load and Store 작업을 최적화하세요.

이러한 모범 사례는 예를 사용하여 설명하기 쉽다.

다음 순서가 있다고 가정해 봅시다: 렌더링 대상 클리어, 무승부, 복사본, 디스패치 및 다른 무승부.

특히, 이 순서로 생성된 시스템과 타일 메모리 사이의 모든 메모리 트래픽을 보세요.

이건 이상적이지 않아!

스트림 중간에 있는 복사본은 후속 드로우를 위한 균일한 데이터를 복사하며, 이 경우 드로우 1이다.

가능하다면, 렌더링 패스를 방해하지 않기 위해 렌더링하기 전에 이 복사본들을 이동하고 배치하는 것이 좋습니다.

변경 후, 복사본은 이제 먼저, 그 다음 지우고, 0을 그리고, 디스패치하고, 1을 그립니다.

두 개의 드로우 호출과 디스패치 사이에 종속성이 없다면, 일괄 드로우와 디스패치를 함께 배치할 수 있도록 재정렬해야 합니다.

이 예에서, 드로우와 디스패치 호출의 순서를 전환한 후, 이제 서로 두 개의 렌더링 패스가 있습니다.

이 시나리오는 동일한 렌더링 대상을 공유하면 단일 렌더링 패스로 병합하여 상당한 메모리 대역폭을 절약하는 데 적합합니다.

그렇게 하면 데이터가 타일 메모리에서 시스템 메모리로 이동하고 두 그림 사이로 돌아갈 필요가 없기 때문에 불필요한 메모리 트래픽을 제거할 수 있습니다.

이것은 이미 더 낫지만, 더 최적화될 수 있다.

클리어는 오직 한 가지 목적을 가진 빈 인코더입니다: 다음 드로우에서 사용되는 렌더링 대상을 지우는 것입니다.

메탈에는 이것을 하는 매우 효율적인 방법이 있다.

렌더링 대상을 사용하는 첫 번째 렌더링 패스에 LoadActionClear를 사용하세요.

이것은 훨씬 낫지만, 로드를 최적화하고 작업을 저장할 수 있는 권장 사항이 하나 더 있습니다.

다음 패스에서 사용될 렌더링 대상의 내용만 시스템 메모리에 저장하면 됩니다.

이 예에서, 무승부 1 이후에 첫 번째 렌더링 대상만 사용된다고 가정합니다.

다른 모든 렌더링 대상은 중간이며 콘텐츠를 보존할 필요가 없습니다.

금속은 각 렌더링 대상에 대한 저장소 동작을 제어할 수 있게 해준다.

이 경우, 첫 번째 렌더링 대상에는 StoreActionStore를 사용하고 다른 대상에는 StoreActionDontCare를 사용할 수 있습니다.

그리고 그게 다야! 이것은 초기 명령 시퀀스이다.

타일 메모리와 시스템 메모리 사이에는 다섯 번의 왕복이 있다.

그리고 이것이 몇 가지 쉬운 최적화 후에 명령 시퀀스가 보이는 방식이다.

타일 메모리에서 시스템 메모리로 단 한 번의 최종 플러시.

메모리 대역폭이 크게 줄어듭니다!

그리고 그것은 렌더링하기 전에 복사본을 이동하고, 같은 유형의 명령을 그룹화하고, 빈 인코더로 렌더링 대상을 지우지 않고, 로드 및 저장 작업을 최적화함으로써 달성되었습니다.

GPU 도구는 이러한 문제를 식별하는 데 도움이 될 수 있습니다.

Xcode의 메탈 디버거는 자동으로 최적화 기회를 찾므로 게임에서 최고의 성능을 얻을 수 있습니다.

메탈 패스의 종속성을 검사하고 이해할 수 있으며, 모든 기능을 갖춘 디버깅 및 프로파일링 도구 제품군이 함께 제공됩니다.

금속 디버거를 사용하여 언급된 문제를 식별하는 것은 쉽다.

메탈 워크로드를 캡처할 때, 메탈 디버거는 요약 뷰어를 보여줍니다.

하단의 인사이트 섹션은 메모리, 대역폭, 성능 및 API 사용의 네 가지 범주로 분류된 최적화 기회를 보여줍니다.

이 워크로드에서 강조하고 싶은 두 가지 대역폭 통찰력이 있습니다.

첫 번째는 사용하지 않는 자원을 위한 것이다.

인사이트를 선택하면, 오른쪽 패널에서 그것을 다루기 위한 요약과 실행 가능한 조언을 찾을 수 있습니다.

GBuffer 패스는 필요한 것보다 더 많은 첨부 파일을 저장하고 있다.

이 경우, GBuffer 패스는 알베도/알파 텍스처를 로드하고 저장합니다.

그러나, 알베도 텍스처는 나중에 이 프레임에서 사용되지 않기 때문에, 상점은 중복되므로, 상점 작업을 DontCare로 설정하여 이 문제를 해결할 수 있습니다.

다음 인사이트를 확인해 봅시다.

렌더링 패스를 결합하면 대역폭을 줄이는 데 도움이 될 수 있으며, 여기서 통찰력은 GBuffer와 Forward 패스를 단일 패스로 결합할 수 있음을 시사한다.

또한 종속성 뷰어에서 이 렌더링 패스를 찾기 위해 오른쪽의 종속성 공개 버튼을 클릭하여 이 패스가 읽고 쓰는 것에 대해 더 많이 배울 수 있습니다.

종속성 뷰어는 패스 간의 종속성을 검사하는 훌륭한 도구입니다!

여기서, 렌더링 첨부 파일 위와 아래에 표시된 로드 및 저장 작업을 한 눈에 볼 수 있습니다.

이 패스의 모든 첨부 파일에는 저장 액션 저장소가 있지만, 향후 패스에는 색상 0과 깊이 첨부 파일만 사용됩니다.

이전의 통찰력은 이것을 드러냈다.

조금 축소하면, 데이터 가장자리가 GBuffer 패스에서 포워드 패스로 흐르는 것으로 표시됩니다.

통찰력에서 알 수 있듯이, GBuffer와 Forward 패스는 동일한 첨부 파일에서 저장하고 로드하기 때문에 대역폭을 절약하기 위해 병합할 수 있습니다.

이 두 패스를 병합하면 대역폭을 절약하고 성능을 향상시킬 수 있습니다.

그것은 Metal Debugger를 사용하여 게임에서 최적화 기회를 찾는 방법의 한 예일 뿐입니다.

메탈 디버거에 대해 자세히 알아보려면, 관련 세션 "Xcode 12로 메탈 앱에 대한 통찰력 얻기"와 "메탈 디버깅, 프로파일링 및 자산 생성 도구 발견"을 확인하세요.

간접 렌더링은 고급 렌더링 기술을 구현하는 데 고급 게임이 사용하는 중요한 기능이다.

이 주제는 ExecuteIndirect가 어떻게 작동하는지 그리고 이 특정 명령을 Metal로 번역하는 방법을 검토할 것이다.

간접 렌더링을 사용하면 여러 개의 그리기 명령을 인코딩하는 대신 인수가 메모리의 일반 버퍼에 저장되며 하나의 ExecuteIndirect 명령만 버퍼를 참조하고 GPU가 버퍼에서 각각에 대한 인수를 가져와서 실행해야 하는 그리기 호출 수를 지정합니다.

이 접근 방식의 주요 아이디어는 ExecuteIndirect 명령 전에 실행을 위해 예정된 컴퓨팅 셰이더로 간접 버퍼의 콘텐츠를 채울 수 있다는 것이다.

이런 식으로, GPU는 스스로 작업을 준비하고 무엇을 렌더링할지 결정한다.

간접 인수로 명령을 실행하는 것은 GPU 기반 렌더링 루프와 같은 고급 기술을 구현하는 핵심 기능입니다.

Draw Indirect 및 Metal Indirect Command 버퍼 또는 ICB를 사용하여 이 명령을 Metal으로 번역하는 두 가지 방법이 있습니다.

메탈에서 렌더러는 각 ExecuteIndirect를 DrawIndirect에 대한 일련의 API 호출로 변환해야 한다.

각각은 버퍼를 참조하고 드로우 인수에 대한 오프셋을 제공한다.

여기 코드가 있습니다.

이 ExecuteIndirect가 가질 수 있는 최대 드로우 호출 수를 살펴보세요.

각각에 대해, 그 버퍼에서 간접 인수 버퍼와 오프셋을 지정하는 별도의 드로우를 인코딩하십시오.

반복이 끝날 때, 오프셋을 다음 간접 인수 집합을 가리키도록 이동하십시오.

이 접근 방식은 구현하기 매우 쉽고 거의 모든 상황에서 작동할 것이다.

그러나, 게임에서 수천 개의 무승부 호출이 있는 장면이 있고 성능이 CPU 인코딩 시간에 의해 제한된다면, 메탈의 간접 명령 버퍼를 고려해야 합니다.

ICB는 간접적인 드로우 인수가 있는 버퍼의 상위 집합이다.

인수를 그리는 것 외에도, 버퍼 바인딩을 설정하고 GPU에서 파이프라인 상태 객체를 렌더링할 수도 있습니다.

GPU에서 실행을 위해 ICB의 명령을 예약하려면, executeCommandsInBuffer 명령을 인코딩해야 합니다.

보통 ExecuteIndirect를 사용하면, 모든 드로우 호출은 동일한 파이프라인 상태 객체를 공유한다.

그리고 PSO가 바뀔 때마다, 새로운 ExecuteIndirect 명령을 인코딩해야 합니다.

ICB를 사용하는 경우, 종종 상태 변경에 따라 간접 실행 명령을 분할할 필요가 없습니다.

모든 PSO와 버퍼 바인딩은 ICB에서 설정할 수 있으므로 인코딩할 필요가 없습니다.

장면의 구조에 따라, 이것은 인코딩 시간을 크게 줄일 수 있다.

ICB를 활용하기 위해, 간접 인수를 채우는 기존 셰이더를 수정할 필요가 없습니다.

동일한 셰이더를 다른 플랫폼과 공유하고 Metal Shader Converter로 컴파일한 다음 간접 인수 생성 후 간접 렌더링 패스 전에 작은 컴퓨팅 커널을 추가하여 draw 인수를 ICB로 변환할 수 있습니다.

컴퓨팅 커널에서 ICB를 인코딩하려면, 메탈 셰이딩 언어로 작성하세요.

셰이더에 대한 입력으로, 번역하고 싶은 간접 인수에 대한 포인터가 있습니다.

다음으로, 인수가 유효한지 확인하고, 그래야만 명령을 인코딩할 수 있습니다.

encodeCommand 함수에서 렌더링 파이프라인 상태, 버퍼 바인딩 및 드로우 호출을 설정하십시오.

이것은 그리기 인수를 간접 명령 버퍼의 렌더링 명령으로 변환합니다.

그리고 그것이 간접 렌더링을 금속으로 번역하는 방법이다.

일련의 그리기 간접 명령이나 금속 간접 명령 버퍼를 사용할 수 있습니다.

간접 렌더링을 사용하여 고급 렌더링 기술을 구현하는 방법을 배우고 싶다면, "금속으로 현대 렌더링" 샘플 코드를 확인하세요.

게임이 리소스를 파이프라인에 바인딩하고 명령을 명령 버퍼로 올바르게 인코딩하여 올바른 이미지를 생성하면, 업스케일링을 활용하여 플레이어의 장치에서 더 많은 성능을 얻을 수 있습니다.

MetalFX를 통한 업스케일링은 GPU 작업의 양을 줄임으로써 각 프레임의 시간을 절약하는 데 도움이 됩니다.

MetalFX는 업스케일링 파이프라인을 구현하기 위한 턴키 솔루션입니다.

출력 해상도에서 직접 렌더링하는 데 걸리는 시간보다 짧은 시간에 저해상도 이미지를 대상 출력 해상도로 확장하여 작동합니다.

MetalFX는 작년에 Mac용으로 소개되었으며, 고성능 업스케일링을 제공합니다!

MetalFX는 최고의 성능을 위한 "Spatial"과 출력 해상도에서 네이티브 렌더링에 접근하는 품질을 위한 "Temporal"이라는 두 가지 업스케일링 알고리즘을 지원합니다.

MetalFX를 엔진에 통합하면 더 나은 성능으로 더 높은 해상도로 렌더링하여 플레이어의 경험을 향상시킬 수 있습니다.

올해 새로운 기능에는 iOS 지원, 최대 3배 업스케일링 및 Metal-cpp 지원이 포함됩니다.

엔진이 이미 다른 플랫폼에서 기존 업스케일링 솔루션을 지원하는 경우, MetalFX 통합은 엔진 측면에서 많은 코딩과 수정이 필요하지 않습니다.

MetalFX를 지원하려면, 엔진의 확장 지원이 필요합니다.

또 다른 요구 사항은 재료 셰이더에서 텍스처 샘플링의 세부 수준을 수동으로 제어하는 렌더러입니다.

시간적 업스케일링은 지터 시퀀스와 모션 벡터를 필요로 한다.

당신의 엔진이 일시적인 안티앨리어싱을 지원한다면 당신은 아마 이미 그것들을 가지고 있을 것입니다.

MetalFX의 시간적 업스케일링은 렌더링의 노출을 고려할 수 있으며, 두 가지 옵션이 있습니다.

렌더러가 1 x 1 노출 텍스처를 지원한다면, 그것을 사용하세요.

그렇지 않으면, 자동 노출 기능을 활성화하고 품질이 향상되는지 확인할 수 있습니다.

카메라 컷과 극단적인 카메라 움직임의 기록을 재설정하는 것을 잊지 마세요.

애플리케이션에 MetalFX를 통합하는 방법에 대한 자세한 내용은 작년의 문서 및 "MetalFX 업스케일링으로 성능 향상"을 참조하십시오.

메탈은 앱의 렌더링 시간을 최대한 활용할 수 있는 몇 가지 강력한 옵션을 제공합니다.

자원을 관리하고 가능한 한 효율적으로 묶을 수 있습니다.

셰이더가 어떻게 액세스하는지에 따라, 자원을 공유하는 패스가 올바른 순서로 실행되도록 하고, 자원을 상주하고 GPU에서 사용할 수 있도록 합니다.

당신의 앱은 Xcode에서 Metal Debugger로 최적화 기회를 찾고 적용하고 명령 제출을 최적화함으로써 Apple의 강력한 그래픽 아키텍처의 잠재력을 최대한 활용할 수 있습니다.

GPU가 많은 현대 렌더링 기술의 핵심이 될 수 있는 간접 렌더링을 구현하여 수행할 작업을 스스로 결정하도록 하십시오.

MetalFX로 렌더링을 확장하여 렌더링 게임을 향상시키면 렌더링 루프에서 앱의 귀중한 시간을 절약할 수 있습니다.

더 많은 렌더링 팁과 지침은 "Apple 실리콘 Mac을 위한 금속 성능 최적화"를 확인하세요.

봐줘서 고마워!

♪ ♪