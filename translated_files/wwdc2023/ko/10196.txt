10196

♪ ♪

Nick Gillett: 안녕하세요, 저는 SwiftData 팀의 Apple 엔지니어인 Nick Gillett입니다.

이 세션에서, 저는 SwiftData로 구축된 애플리케이션이 이 풍부하고 강력한 새로운 프레임워크를 활용하기 위해 어떻게 진화하는지 자세히 살펴볼 것입니다.

먼저, 응용 프로그램에서 지속성을 구성하는 방법을 살펴보겠습니다.

다음으로, ModelContext를 사용하여 변경 사항을 추적하고 유지하는 방법에 대해 이야기하겠습니다.

마지막으로, 코드에서 객체로 작업할 때 SwiftData를 최대한 활용하는 방법을 살펴보겠습니다.

이 세션은 "Meet Swift Data"와 "Model your Schema with SwiftData"에 도입된 개념과 API를 기반으로 한다는 점에 주목하고 싶습니다.

나는 이것을 계속하기 전에 그 세션을 검토하는 것을 강력히 추천한다.

이 강연에서, 저는 SwiftData로 애플리케이션을 구축하는 것이 얼마나 쉬운지 보여주기 위해 올해 구축한 새로운 샘플 애플리케이션인 SampleTrips를 참조할 것입니다.

SampleTrips는 내가 언제 어디서 여행하고 싶은지에 대한 내 아이디어를 쉽게 정리할 수 있게 해준다.

SwiftData는 또한 사용자가 애플리케이션을 전환할 때 실행 취소 및 자동 저장과 같은 표준 플랫폼 관행을 쉽게 구현할 수 있게 해준다.

SwiftData는 Swift를 사용하는 애플리케이션에서 데이터를 유지하는 새로운 방법입니다.

클래스와 구조체와 같은 코드에서 이미 사용하고 있는 유형과 함께 작동하도록 설계되었습니다.

이 개념의 핵심은 SwiftData에 유지하려는 유형에 대해 알려주는 새로운 매크로 @Model에 의해 설명된 모델입니다.

이것은 SampleTrips 애플리케이션의 여행 수업입니다.

여행에 대한 정보와 SampleTrips에서 사용되는 다른 물체에 대한 몇 가지 참조를 캡처할 수 있는 몇 가지 속성이 있습니다.

우리는 여기에 있는 것처럼 지속성 없이 일반적으로 작성할 코드와 지속성으로 작성해야 하는 코드 사이의 최소 거리를 제공하도록 SwiftData를 설계했습니다.

몇 가지 변경 사항으로, 나는 SwiftData에게 이 여행이 내가 지속하고 싶은 모델이라고 말했고 BucketListItem과 LivingAccommodations와의 관계가 어떻게 행동해야 하는지 설명했다.

가능한 경우, SwiftData는 작성한 코드에서 사용하려는 구조를 자동으로 추론합니다.

하지만 SwiftData는 또한 데이터를 어떻게 저장하고 싶은지 정확히 설명하는 데 도움이 되는 강력한 사용자 지정 세트를 제공합니다.

"SwiftData로 스키마 모델링"에서 모델의 힘에 대한 모든 것을 배울 수 있습니다.

트립 클래스에 대한 이러한 주석은 SwiftData에서 두 가지 중요한 역할을 할 수 있게 해준다.

첫 번째는 스키마라고 불리는 애플리케이션의 객체 그래프를 설명하는 것이고, 두 번째는 트립 클래스가 내가 코드를 작성할 수 있는 인터페이스가 될 것이라는 것이다.

이 이중성, 두 부분을 모두 수행할 수 있는 능력은 @Model 매크로로 주석이 달린 클래스를 SwiftData를 사용하는 애플리케이션의 중심 접점으로 만들고, 이러한 각 역할을 지원하는 정렬된 API 개념이 있습니다.

스키마는 데이터가 어떻게 유지되어야 하는지 설명하기 위해 ModelContainer라는 클래스에 적용됩니다.

ModelContainer는 모델 클래스의 인스턴스를 저장할 수 있는 데이터베이스를 생성하기 위해 스키마를 사용합니다.

코드에서 모델 클래스의 인스턴스로 작업할 때, 이러한 인스턴스는 메모리의 상태를 추적하고 관리하는 ModelContext에 연결됩니다.

이 이중성은 SwiftData의 핵심이며, 이 섹션에서는 지속성의 구조와 ModelContainer와 어떻게 작동하는지 설명하기 위해 모델의 첫 번째 역할을 자세히 살펴보겠습니다.

ModelContainer는 데이터가 장치에 어떻게 저장되거나 유지되는지 설명하는 곳입니다.

우리는 모델컨테이너를 스키마와 그 지속성 사이의 다리로 생각할 수 있다.

메모리에 있든 디스크에 있든 객체가 어떻게 저장되는지에 대한 설명은 버전, 마이그레이션 및 그래프 분리와 같은 스토리지의 운영 및 진화적 의미를 충족시키는 곳입니다.

스키마로 컨테이너를 인스턴스화하는 것은 쉽다.

나는 내가 작업하고 싶은 유형만 제공할 수 있고 SwiftData는 나를 위해 스키마의 나머지 부분을 알아낼 것이다.

예를 들어, Trip 클래스는 다른 모델 유형과 관련이 있기 때문에, ModelContainer는 내가 단일 유형만 전달했음에도 불구하고 실제로 이 스키마를 추론한다.

ModelContainer에는 ModelConfiguration이라는 클래스를 사용하여 점점 더 복잡한 구성을 가능하게 하기 위해 코드와 함께 성장하도록 설계된 다른 많은 강력한 이니셜라이저가 있습니다.

ModelConfiguration은 스키마의 지속성을 설명한다.

그것은 일시적인 데이터의 메모리나 영구 데이터의 디스크와 같이 데이터가 저장되는 위치를 제어합니다.

ModelConfiguration은 귀하가 선택한 특정 파일 URL을 사용하거나, 그룹 컨테이너 권한과 같은 애플리케이션의 권한을 사용하여 자동으로 생성할 수 있습니다.

구성은 또한 지속성 파일을 읽기 전용 모드로 로드하여 민감한 데이터나 템플릿 데이터에 대한 쓰기를 방지해야 한다고 설명할 수 있다.

그리고 마지막으로, 하나 이상의 CloudKit 컨테이너를 사용하는 애플리케이션은 스키마의 ModelConfiguration의 일부로 지정할 수 있습니다.

새로운 사람과 주소 수업을 사용하여 SampleTrips에 연락처 정보를 추가하고 싶다고 상상해 봅시다.

먼저, 총 스키마는 내가 사용하고 싶은 모든 유형을 포함하는 것으로 선언된다.

다음으로, Trip, BucketListItem 및 LivingAccommodations 모델이 포함된 SampleTrips 데이터에 대한 구성이 선언됩니다.

이 특정 개체 그래프의 데이터를 저장하는 데 사용할 파일의 URL과 SampleTrips 데이터를 CloudKit에 동기화할 때 사용하려는 CloudKit 컨테이너의 컨테이너 식별자를 선언합니다.

그런 다음, 사람과 주소가 있는 새로운 스키마의 모델은 이 데이터를 Trips 그래프와 별도로 유지하기 위해 고유한 파일 URL과 CloudKit 컨테이너 식별자로 자체 구성으로 선언됩니다.

마지막으로, 스키마와 구성이 결합되어 ModelContainer를 형성한다.

ModelConfiguration의 힘으로, 아무리 복잡하더라도 애플리케이션의 지속성 요구 사항을 쉽게 설명할 수 있습니다.

손으로 컨테이너를 인스턴스화하는 것 외에도, SwiftUI 애플리케이션은 새로운 modelContainer 수정자를 사용하여 작업하고 싶은 컨테이너를 만들 수 있습니다.

modelContainer 수정자는 응용 프로그램의 모든 보기 또는 장면에 추가할 수 있으며 간단한 것부터 강력한 것까지 그리고 그 사이의 모든 것을 지원하는 ModelContainer를 지원합니다.

이 섹션에서, 나는 ModelContainer를 사용하여 스키마와 지속성을 결합하는 방법을 조사했다.

더 강력한 기능과 객체 그래프를 구축함에 따라 애플리케이션과 함께 성장합니다.

그리고 저는 ModelConfiguration을 사용하여 강력한 지속성 기능을 잠금 해제하는 방법을 시연했습니다.

"SwiftData 충족"에서 배운 바와 같이, 모델과 ModelContext는 사용자 인터페이스를 작성하거나 모델 객체에서 작동할 때 가장 자주 사용되는 개념 중 두 가지입니다.

이 섹션에서는 ModelContext가 ModelContainer를 통해 변경 사항을 추적하고 편집을 유지하는 방법에 대해 자세히 알아보겠습니다.

뷰 또는 씬 코드에서 modelContainer 수정자를 사용할 때, 특정 방식으로 애플리케이션의 환경을 준비합니다.

수정자는 환경의 새로운 modelContext 키를 컨테이너의 mainContext에 바인딩합니다.

주요 컨텍스트는 장면과 뷰에서 ModelObjects로 작업하기 위한 특별한 MainActor 정렬 모델 컨텍스트입니다.

환경에서 모델 컨텍스트를 사용함으로써, 뷰 코드는 여기에서 쿼리에서 사용하는 컨텍스트에 쉽게 액세스할 수 있으므로 여기에서 삭제와 같은 작업을 수행할 수 있습니다.

그래서 모델 컨텍스트는 사용하기 쉽고 접근하기 쉽지만 실제로 무엇을 하나요?

우리는 ModelContext를 애플리케이션이 관리하는 데이터에 대한 견해로 생각할 수 있다.

우리가 작업하고 싶은 데이터는 사용된 모델 컨텍스트로 가져온다.

SampleTrips에서, 다가오는 트립 뷰가 목록에 대한 데이터를 로드할 때, 각 트립 객체는 메인 컨텍스트로 가져옵니다.

여행이 편집되면, 그 변화는 모델 컨텍스트에 의해 스냅샷으로 기록된다.

새 트립을 삽입하거나 기존 트립을 삭제하는 것과 같은 다른 변경 사항이 이루어지면서, 컨텍스트는 "context.save()"를 호출할 때까지 이러한 변경 사항에 대한 상태를 추적하고 유지합니다.

이것은 삭제된 여행이 더 이상 목록에 표시되지 않더라도, save를 호출하여 삭제가 지속될 때까지 ModelContext에 여전히 존재한다는 것을 의미합니다.

저장이 호출되면, 컨텍스트는 ModelContainer의 변경을 지속하고 상태를 지웁니다.

목록에 표시하는 것과 같이 컨텍스트에서 객체를 여전히 참조하고 있다면, 끝날 때까지 컨텍스트에 존재할 것입니다.

어느 시점에서 그들은 해방되고 맥락은 비워질 것이다.

ModelContext는 바인딩된 ModelContainer와 협력하여 작동합니다.

뷰에서 가져오는 개체를 추적한 다음 저장이 실행될 때 변경 사항을 전파합니다.

ModelContext는 또한 필요할 때 캐시된 상태를 지우기 위한 롤백 또는 재설정과 같은 기능을 지원합니다.

이것은 실행 취소 및 자동 저장과 같은 플랫폼 기능을 지원하는 이상적인 장소입니다.

SwiftUI 애플리케이션에서 modelContainer 수정자는 창의 실행 취소 관리자를 컨테이너의 mainContext에 바인딩하는 isUndoEnabled 인수를 가지고 있습니다.

즉, 주요 컨텍스트에서 변경 사항이 이루어지기 때문에, 세 손가락 스와이프와 흔들기와 같은 시스템 제스처를 사용하여 추가 코드 없이 변경 사항을 실행 취소하거나 다시 실행할 수 있습니다.

ModelContext는 모델 객체가 변경됨에 따라 실행 취소 및 재실행 작업을 자동으로 등록합니다.

modelContainer 수정자는 일반적으로 시스템에서 창 또는 창 그룹의 일부로 제공하는 환경의 undoManager를 사용합니다.

그리고 이 때문에, 세 손가락 스와이프와 흔들기와 같은 시스템 제스처는 응용 프로그램에서 자동으로 작동합니다.

ModelContext가 지원하는 또 다른 표준 시스템 기능은 자동 저장이다.

자동 저장이 활성화되면 모델 컨텍스트는 전경이나 배경에 들어가는 애플리케이션과 같은 시스템 이벤트에 대한 응답으로 저장됩니다.

주요 컨텍스트는 또한 애플리케이션이 사용될 때 주기적으로 저장될 것이다.

자동 저장은 애플리케이션에서 기본적으로 활성화되어 있으며 modelContainer 수정자의 isAutosaveEnabled 인수를 사용하여 원하는 경우 비활성화할 수 있습니다.

손으로 만든 모델 컨텍스트에 대해 자동 저장이 비활성화됩니다.

"SwiftData를 만나다"에서, 우리는 애플리케이션에서 ModelContext로 작업하는 방법과 SwiftUI와 얼마나 잘 페어링하는지에 대해 많은 것을 배웠습니다.

하지만 사용자 인터페이스는 애플리케이션이 모델 객체와 함께 작업해야 하는 유일한 장소가 아니다.

이 섹션에서는 SwiftData가 어떻게 강력하고 확장 가능한 코드를 그 어느 때보다 쉽고 안전하게 만드는지 살펴보겠습니다.

백그라운드 큐의 데이터 작업, 원격 서버 또는 기타 지속성 메커니즘과의 동기화, 일괄 처리와 같은 작업은 종종 세트 또는 그래프에서 모델 객체와 함께 작동합니다.

이러한 작업의 대부분은 ModelContext의 가져오기 방법을 통해 작업할 객체 세트를 가져오는 것으로 시작할 것이다.

이 예에서, 트립 모델의 FetchDescriptor는 스위프트에게 트립 배열이 트립 객체의 모음이 될 것이라고 말한다.

걱정할 캐스팅이나 복잡한 결과 튜플은 없습니다.

FetchDescriptor를 사용하면 새로운 Predicate 매크로를 사용하여 복잡한 쿼리를 쉽게 만들 수 있습니다.

예를 들어, 특정 호텔에 머무르는 것과 관련된 모든 여행은 무엇인가요?

아니면 어떤 여행에서 아직 예약해야 할 활동이 있나요?

SwiftData에서 하위 쿼리와 조인을 지원하는 복잡한 쿼리는 모두 순수 스위프트로 작성할 수 있습니다.

Predicate는 당신이 만든 모델을 사용하고 SwiftData는 해당 모델에서 생성된 스키마를 사용하여 이러한 predicates를 데이터베이스 쿼리로 변환합니다.

FetchDescriptor는 새로운 Foundation Predicate 매크로의 힘을 스키마와 결합하여 처음으로 Apple 플랫폼에서 컴파일러 검증 쿼리를 지속성으로 가져옵니다.

SortDescriptor와 같은 FetchDescriptor 및 관련 클래스는 제네릭을 사용하여 결과 유형을 형성하고 컴파일러에게 사용할 수 있는 모델의 속성에 대해 알려줍니다.

오프셋 및 제한뿐만 아니라 결함 및 프리페칭을 위한 매개 변수와 같이 당신이 알고 사랑하게 된 많은 튜닝 옵션이 있습니다.

이 모든 힘은 ModelContext의 새로운 열거 함수에서 결합된다.

단일 통화 사이트에서 플랫폼 모범 사례를 캡슐화하여 배치 횡단 및 열거의 어려운 패턴을 암시적으로 효율적으로 만들 수 있도록 설계되었습니다.

Enumerate는 단순에서 강력한 것, 그리고 그 사이의 모든 것까지 복잡성에 관계없이 FetchDescriptors와 잘 작동합니다.

Enumerate는 배치 및 돌연변이 가드와 같은 횡단을 위한 플랫폼 모범 사례를 자동으로 구현합니다.

이것들은 당신의 특정 사용 사례의 요구를 충족시키기 위해 사용자 정의할 수 있습니다.

예를 들어, 열거하는 배치 크기는 기본값을 5,000개의 객체로 사용합니다.

하지만 메모리 성장을 희생시키면서 횡단 중에 I/O 작업을 줄이기 위해 10,000으로 변경할 수 있습니다.

이미지, 영화 또는 기타 큰 데이터 BLOB을 포함하는 것과 같은 더 무거운 개체 그래프는 더 작은 배치 크기를 사용하도록 선택할 수 있습니다.

배치 크기를 줄이면 메모리 성장이 줄어들지만 열거 중에 I/O가 증가한다.

열거는 또한 기본적으로 돌연변이 가드를 포함한다.

큰 횡단과 관련된 성능 문제의 가장 빈번한 원인 중 하나는 열거하는 동안 맥락에 갇힌 돌연변이이다.

allowEscapingMutations는 enumerate에게 이것이 의도적이라고 말하며, 설정되지 않았을 때, 열거를 수행하는 ModelContext가 더럽다는 것을 발견하면 enumerate가 던져져 이미 횡단된 객체를 해제하지 못하게 합니다.

이 세션에서, 우리는 스키마와 모델 구성으로 강력한 지속성 구성을 만드는 방법을 배웠습니다.

우리는 또한 ModelContainer와 ModelContext로 실행 취소 및 실행과 같은 표준 시스템 관행을 채택하는 것이 얼마나 쉬운지 배웠습니다.

그리고 오늘 SwiftData를 사용하여 FetchDescriptor, predicate 및 enumerate를 사용하여 프로젝트에서 안전하고 성능이 뛰어난 코드를 작성할 수 있습니다.

앞으로 몇 달과 몇 년 동안 이 새로운 프레임워크로 가능한 것의 한계를 어떻게 밀어붙이는지 빨리 보고 싶어요.

봐줘서 고맙고 코딩 잘 해.