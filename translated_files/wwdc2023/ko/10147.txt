10147

♪ ♪

니바시: 안녕하세요, 여러분.

저는 핵심 위치 프레임워크 팀의 엔지니어인 Nivash Raaja Karukankaatur Murugasamy입니다.

코어 위치 모니터에 대한 제 강연에 오신 것을 환영합니다.

우리의 새로운 CLMonitor API에 대해 이야기하게 되어 정말 기쁩니다.

스위프트에서 단 몇 줄의 코드로 간단하면서도 강력한 모니터링 논리를 작성할 수 있습니다.

모니터를 만들고, 조건을 추가하고, 이벤트를 기다리기만 하면 됩니다.

저기 있어. 안녕하세요, CLMonitor!

CLMonitor API의 세부 사항에 대해 알아보겠습니다.

사용자의 위치나 비콘을 모니터링하는 새롭고 간단하면서도 강력한 방법인 CLMonitor API에 대한 개요부터 시작하겠습니다.

그런 다음, 모니터링할 수 있는 조건의 유형과 그것들을 추가하거나 제거할 수 있는 방법에 대해 알려드리겠습니다.

그런 다음, 모니터링 기록, 포함된 내용, 그리고 앱의 수명 주기 동안 어떻게 액세스할 수 있는지 살펴볼 것입니다.

모니터링되는 조건 중 하나라도 이벤트가 발생하면 앱에서 취해야 할 단계를 따르세요.

그리고 마지막으로, CLMonitor를 사용할 때 도움이 될 몇 가지 요구 사항과 권장 사항으로 마무리하겠습니다.

먼저, 모니터가 무엇이고 모니터링을 위해 어떻게 만들 수 있는지 살펴봅시다.

CLMonitor는 최고 수준의 스위프트 액터이며 각 CLMonitor 인스턴스는 모니터링의 게이트웨이 역할을 한다.

그것은 배우이기 때문에, 스레드와 작업 동기화의 오버헤드에서 당신을 해방시켜줍니다.

따라서 언제든지 CLMonitor의 콘텐츠에 액세스하거나 조건을 추가하거나 제거하기만 하면 됩니다.

모니터를 만들려면, 영숫자 문자열로 모니터의 init 메소드를 호출합니다.

그 이름을 가진 사전 모니터가 없다면, 새로운 모니터가 만들어질 것이다.

그렇지 않으면, 기존의 것이 열릴 것이다.

어느 쪽이든, 모니터 인스턴스가 반환될 것이다.

주어진 이름을 가진 하나의 인스턴스만 언제든지 열 수 있다는 점에 유의하십시오.

모니터링되고 있는 실체는 조건이라고 불린다.

모니터링을 위해 CLMonitor 인스턴스에 조건을 추가하고 추가 방법을 사용하여 식별자와 연결할 수 있습니다.

식별자는 영숫자 문자열이다.

예를 들어, 이 예에서 "작업"은 사용자가 직장에 있을 때 만족되는 조건의 기록을 고유하게 식별합니다.

레코드 객체와 그 내용은 이 식별자로 접근할 수 있으며 제거될 때까지 조건이 모니터링됩니다.

동일한 식별자로 제거를 호출하여 모니터링에서 조건을 제거할 수 있습니다.

조건을 제거하면 해당 기록도 제거됩니다.

이제 모니터 인스턴스를 만드는 방법과 조건과 어떤 관련이 있는지 알았으니, 사용 가능한 조건의 유형과 모니터링을 위해 어떻게 만들고 추가할 수 있는지 살펴보겠습니다.

iOS에는 두 가지 유형의 조건이 지원됩니다.

첫째, 순환지리학적 조건.

원형 지리적 조건은 중심과 반경으로 정의된다.

센터는 그 조건의 지리적 위치를 정의한다.

반경은 조건이 충족된 것으로 간주되는 영역을 정의한다.

그 지역 밖의 어느 곳에서든, 우리는 그 상태를 불만족으로 보고할 것이다.

이것은 iOS 16 및 이전 릴리스의 CLCircularRegion과 유사합니다.

관심의 위도와 경도로 CLLocationCoordinate2D를 구성하여 중심을 정의합니다.

그런 다음 그 중심과 관심 반경으로 CircularGeographicCondition을 만듭니다.

iOS에서 지원되는 다른 유형의 조건은 BeaconIdentityCondition이다.

BeaconIdentityCondition은 iOS 16 및 이전 릴리스에서 사용했을 수 있는 CLBeaconIdentityConstraint 또는 CLBeaconRegion과 유사합니다.

회사가 다른 위치에 여러 사이트를 가지고 있는 경우, 사용자가 사이트 중 하나, 특정 사이트 또는 특정 사이트의 특정 섹션에 있는지 앱에서 감지하기 위해 비콘을 배포할 수 있습니다.

Apple의 카페테리아를 여러 사이트의 사무실에서 사용할 수 있는 간단한 예로 생각해 보세요.

관련 앱에서 위치 기반 동작을 활성화하기 위해 비콘을 어떻게 효과적으로 배포할 수 있는지 봅시다.

그리고 우리가 진행하면서, 나는 그 앱이 다른 상황에서 BeaconIdentityCondition의 다른 맛을 사용하여 이러한 비콘을 어떻게 모니터링할 수 있는지에 대해 이야기할 것이다.

비콘을 정의하는 것이 무엇인지 간략하게 살펴봅시다.

그것은 UUID 문자열, 주요 숫자, 그리고 작은 숫자를 포함한다.

BeaconIdentityCondition을 사용하면 UUID, major 및 minor의 세 가지를 모두 지정하여 특정 비콘을 모니터링할 수 있습니다.

또는 와일드카드로 UUID와 메이저만 지정하거나 UUID만 지정하여 비콘 그룹의 단일 비콘과 일치시킬 수 있습니다.

미성년자 또는 주요 및 미성년자를 지정하지 않을 때, 해당 속성에 대한 값을 가진 비콘이 일치할 수 있습니다.

우리의 예시에서 이것을 어떻게 사용할 수 있는지 봅시다.

우리는 모두 동일한 UUID를 가진 이 카페테리아 사이트에 비콘을 배치할 수 있다.

그리고 앱에서 이 UUID를 모니터링하기 위해 BeaconIdentityCondition을 만들 수 있습니다.

그런 다음, 사용자가 이 비콘 중 하나에 접근하면, 그 조건은 만족할 것이다.

그렇지 않으면, 그것은 불만족스러운 것으로 결정될 것이다.

코드에서, UUID만 지정하는 init 메소드를 호출하여 이 작업을 수행할 수 있습니다.

이제 필요한 위치에 비콘을 배치했으므로, 사용자가 특정 사이트 중 하나에 있는지 감지하는 데 관심이 있을 수 있습니다.

이 경우, 사용자가 Apple Park 사이트에 있는지 모니터링하는 방법을 봅시다.

이를 달성하기 위해, 각 사이트에 배치된 비콘은 고유한 주요 번호를 공유해야 할 것이다.

그런 다음 앱에서 해당 전공과 전체 UUID로 BeaconIdentityCondition을 모니터링할 수 있습니다.

조건의 상태는 장치가 비콘이 UUID와 주요 값 모두와 일치하는 사이트에 있을 때만 만족스러운 것으로 결정됩니다.

그것은 다른 사이트에서 만족스럽지 않을 것이다.

코드에서 UUID와 major만 지정하는 init 메서드를 호출하여 BeaconIdentityCondition을 만들 수 있습니다.

이제 당신은 모든 사이트 또는 특정 사이트를 모니터링하는 방법을 알고 있습니다.

하지만 특정 사이트 내의 특정 섹션을 모니터링할 수도 있습니다.

이것은 상응하는 사소한 값을 가진 각 사이트 내의 다른 위치, 예를 들어, 요리 스테이션에 비콘을 배치함으로써 달성될 수 있다.

앱에서 UUID 및 메이저와 함께 특정 마이너 값에 대한 BeaconIdentityCondition을 모니터링할 수 있습니다.

그러한 조건은 전체 UUID 및 메이저뿐만 아니라 미성년자가 있는 비콘이 감지될 때만 만족할 것이다.

코드에서, 이것은 UUID, 메이저 및 마이너를 전달하여 BeaconIdentityCondition을 만드는 것을 의미합니다.

BeaconIdentityCondition을 만들 때, 필요에 맞는 init 방법을 사용하세요.

좋아요, 이제 다양한 유형과 맛을 만드는 방법을 알았으니, 모니터링을 위해 어떻게 추가할 수 있는지 살펴봅시다.

CLMonitor 인스턴스에서 식별자라는 영숫자 문자열로 add 메소드를 호출하여 모니터링 조건을 추가할 수 있습니다.

그 조건은 식별자와 연관될 것이다.

조건이 이미 주어진 식별자로 모니터링되고 있다면, 전달된 새로운 조건으로 대체될 것이다.

조건을 추가하면, 핵심 위치에 의해 결정될 때까지 초기 상태를 알 수 없습니다.

추가하기 전에 상태의 현재 상태를 알고 있는 경우가 있을 수 있습니다.

이러한 경우, 모니터링을 위해 추가할 때 상태를 전달하여 기본 초기 상태를 재정의할 수 있습니다.

이 예에서, 당신의 앱이 당신이 애플 파크 사이트에 있지 않다고 추론하고 그 조건이 만족스럽지 않을 것으로 예상한다고 가정해 봅시다.

전화에 "assuming: .unsatisfied"를 추가할 수 있습니다.

그런 다음, 모니터링은 불만족으로 설정된 상태로 시작될 것이다.

하지만 걱정하지 마.

상태에 대한 당신의 가정이 틀렸다면, 핵심 위치는 일단 결정되면 당신에게 올바른 상태를 줄 것입니다.

모니터링에서 조건을 제거하려면, 조건이 추가되었을 때 전달된 식별자로 제거 메소드를 호출할 수 있습니다.

이제 조건이 무엇인지, 어떤 유형이 지원되는지, 모니터링에서 추가하거나 제거하는 방법을 알 수 있습니다.

기록의 내용과 언제든지 검사할 수 있는 기록이나 모니터의 모든 기록을 얻을 수 있는 방법을 자세히 살펴봅시다.

이전 슬라이드에서 기억할 수 있다면, 모니터링 조건을 추가할 때, Core Location은 레코드를 만들고 그 레코드에 조건을 추가합니다.

조건 외에도, 레코드에는 이벤트라는 또 다른 객체가 포함되어 있다.

이 이벤트에는 만족, 불만족 또는 알 수 없는 상태의 현재 관찰된 상태를 나타내는 상태와 그 상태가 그 상태에 직면한 날짜와 시간이 포함되어 있습니다.

이제 당신은 왜 그 사건에 또 다른 조건이 있는지 궁금할 것입니다.

이것은 세련미라고 불린다.

그건 뭘 위한 거야?

BeaconIdentityCondition에서 기억할 수 있다면, 앱은 UUID, 또는 UUID 및 전공, 또는 UUID와 전공 및 미성년자와 함께 모니터링할 수 있습니다.

메이저 및 마이너 와일드카드 조건이 충족되면, 그 이벤트는 정제된 상태로 전달될 것이다.

그 개선 조건은 UUID뿐만 아니라 관찰된 비콘의 주요 및 사소한 정보도 전달할 것이다.

그런 다음, 상태가 만족스럽지 않으면, 개선은 0으로 재설정될 것이다.

조건이 추가되었을 때 전달된 식별자에 의해 고유하게 주소가 지정된 각 레코드가 있는 여러 레코드 인스턴스가 있을 수 있습니다.

마지막 이벤트 및 식별자와 조건을 연결하는 모니터의 모든 기록은 앱에 저장됩니다.

이를 통해 언제든지 마지막으로 관찰된 조건과 해당 상태를 쿼리할 수 있습니다.

그게 코드에서 어떻게 생겼는지 보자.

조건과 관련된 레코드를 검색하려면, 식별자로 레코드 메소드를 호출할 수 있습니다.

전달한 식별자로 어떤 조건도 모니터링되지 않으면, nil이 반환됩니다.

그런 다음 조건 속성에 액세스하여 기본 모니터링 조건을 얻을 수 있습니다.

그리고 lastEvent 속성에 액세스하여 해당 조건에 대해 lastEvent를 앱으로 전달할 수 있습니다.

그런 다음, 이벤트에서 가장 최근에 관찰된 상태, 날짜 및 세련미를 얻을 수 있습니다.

이제 당신은 하나의 레코드를 검색하는 방법을 알고 있습니다.

모든 모니터링 기록을 어떻게 얻나요?

모든 식별자를 추적해야 하나요?

음, 그럴 필요 없어.

우리는 당신의 모니터의 식별자 속성에서 당신을 위해 목록을 유지합니다.

각 기록과 그 내용을 검색하기 위해 쉽게 반복할 수 있습니다.

이제 레코드의 내용에 액세스하는 방법을 알았으니, 변경 사항이 발생함에 따라 이벤트를 소비하는 방법을 봅시다.

이벤트를 수신하는 코드는 작업에 래핑된 간단한 루프를 사용하여 구현할 수 있습니다.

Core Location이 lastEvent에 보고된 상태와 다른 모니터링된 상태의 상태를 관찰하면, Core Location은 대기 루프를 재개하는 모니터의 이벤트 비동기 시퀀스 속성을 통해 새로운 이벤트를 제공합니다.

전달된 이벤트 객체는 새로운 상태와 영향을 받는 조건의 식별자를 제공합니다.

또는, 새 이벤트를 처리하는 동안, 식별자를 사용하여 해당 조건에 대한 레코드와 lastEvent를 얻을 수도 있습니다.

우리는 지금 일어난 일에 대한 더 많은 맥락을 얻기 위해 그 정보를 사용할 수 있다.

저기 있어!

우리의 간단한 인사 프로그램이 완료되었습니다.

이제 CLMonitor가 어떻게 작동하는지 알았으니, 가장 잘 사용하는 방법에 대한 조언이 있습니다.

세 가지 주요 요구 사항부터 시작합시다.

첫째, 다른 조건을 별도로 처리하기 위해 다른 이름을 가진 여러 모니터를 가질 수 있지만, 주어진 이름에 대해 한 번에 하나만 인스턴스화해야 합니다.

CLMonitor는 모니터링하는 조건의 상태를 유지하기 때문에, 같은 이름으로 다른 것을 초기화하려고 하면 원치 않는 행동이 발생할 수 있습니다.

둘째, 이벤트가 예측할 수 없게 도착할 수 있기 때문에, 항상 모니터의 이벤트 시퀀스에서 작업을 기다리는 것이 가장 좋습니다.

이벤트는 당신이 그것을 처리한 후에만 일부 기록의 마지막 이벤트가 될 수 있습니다.

따라서, 이벤트를 기다리지 않는 동안 조건이 상태를 변경하면, 모니터는 당신이 할 때까지 새로운 상태를 반영하지 않을 것입니다.

마지막으로, 앱이 종료된 경우, 모니터링된 조건이 이벤트에 발생하면, Core Location은 사용자 위치를 수신할 수 있는 권한이 있는 한 백그라운드에서 앱을 실행합니다.

즉, 앱이 모니터링 중인 조건의 상태에 관심이 있다면 실행될 때마다 모니터를 다시 활성화하고 이벤트를 기다려야 합니다.

이것을 하는 한 가지 방법은 didFinishLaunchingWithOptions 앱 대리자 콜백을 듣는 것이다.

새로운 API가 실행 동작을 초래하기 때문에, 앱에서만 CLMonitor를 사용하는 것이 좋습니다.

위젯이나 플러그인에서 사용하면 대신 앱을 실행하고, 한 번에 주어진 이름에 대해 하나의 모니터만 존재하도록 복잡하게 됩니다.

마지막으로, 저는 이것을 앞서 언급했습니다: 조건과 상태는 지속되며, CLMonitor가 모니터링하고 있는 조건 중 하나에서 상태의 변화를 관찰할 때 이벤트가 생성되므로, CLMonitor가 자체 테이블에서 유지하는 대신 해당 상태를 보고 도착하는 이벤트와 동기화되지 않는 것이 좋습니다.

즉, SwiftUI 시각화와 같은 일부 응용 프로그램은 별도의 표현을 유지해야 할 수도 있습니다.

그렇게 해야 한다면, SwiftUI를 위해 그 표현을 예약하고 예상되는 사건에 대해 추론하는 데 사용하지 마세요.

그래서 그게 CLMonitor야!

나는 우리의 새로운 API에 대해 정말 흥분된다.

한 번 해봐!

우리는 그것이 당신의 모니터링 경험을 크게 개선하기를 바랍니다.

우리는 당신의 피드백을 듣고 싶습니다.

우리는 또한 CLMonitor의 작동을 보여주는 샘플 앱을 가지고 있습니다.

이 비디오의 리소스 섹션에서 사용할 수 있습니다.

그것을 다운로드하고 시도해 보세요.

마지막으로, 위치 업데이트에 대한 제 동료 Siraj의 세션을 확인하세요.

봐줘서 고마워!