10143

♪ ♪

데이브: 안녕하세요, 저는 앱 스토어 커머스 팀의 개발자 옹호자인 데이브 웬드랜드입니다.

제 동료 알렉스와 저는 새로운 App Store 서버 라이브러리와 그 기능 세트가 어떻게 당신의 서버가 App Store 서버 API를 위한 JWT를 생성하는 것부터 구매 검증을 위해 verifyReceipt 엔드포인트에서 마이그레이션하는 것까지 다양한 기능을 활용할 수 있는지에 대해 논의할 것입니다.

우리가 되돌아보면, App Store는 앱이 무료이거나 유료인 2008년에 출시되었다.

곧, 우리는 인앱 구매를 추가했고, 그 이후로 개발자 커뮤니티는 전 세계적으로 규모와 복잡성이 증가했습니다.

App Store는 글로벌하고 역동적인 모바일 앱 생태계를 지원하기 위해 개발자와 고객을 위한 업데이트를 계속 출시하고 있다.

2021년에, 우리는 개선된 StoreKit Framework, App Store Server API 및 App Store Server Notifications v2와 함께 StoreKit 도구의 다음 시대를 출시했습니다.

2022년과 올해 WWDC 2023에서 더 많은 업데이트와 함께.

이 도구들은 서명된 JWS 형식으로 거래와 상태를 제공한다.

그리고 그들은 개발자에게 강력한 정보, 클라이언트 측 및 서버 측을 제공하도록 설계되었습니다.

이 API 세트는 App Store 서버 라이브러리에 영감을 주었다.

우리는 이 라이브러리가 개발자 커뮤니티가 현재와 미래에 사용 가능한 최신 API를 더 쉽게 채택하고 통합할 수 있는 일련의 기능을 제공한다는 것을 자랑스럽게 생각합니다.

라이브러리 베타 출시는 스위프트, 자바, 노드, 파이썬의 네 가지 언어를 지원하므로 백엔드와 전문 지식을 가장 잘 지원하는 언어를 선택할 수 있는 유연성을 제공합니다.

각 언어의 App Store 서버 라이브러리는 GitHub에서 사용할 수 있으며, 귀하의 피드백과 기여를 기대합니다.

나는 도서관이 제공해야 하는 것을 네 가지 주요 기능으로 분류했다.

첫 번째이자 가장 강력한 기능은 App Store Server API입니다.

JWT 생성을 간소화함으로써, App Store Server API가 제공하는 12개의 다른 엔드포인트 중 하나를 사용할 수 있습니다.

다음은 JWS가 서명한 데이터를 확인하는 핵심 기능이므로, 거래와 서버 알림이 Apple에 의해 생성되고 서명되었는지 확인할 수 있습니다.

다음은 추출 영수증 거래 유틸리티입니다.

이 간단한 도구는 앱 영수증에서 거래 식별자를 추출합니다.

이렇게 하면 verifyReceipt 엔드포인트를 사용해야 할 필요성을 완화하고 구매 확인 및 추가 기능을 위해 App Store Server API로 마이그레이션할 수 있습니다.

이것은 현재 및 레거시 앱 버전을 지원할 수 있는 명확한 경로를 제공합니다.

마지막으로, 구독 프로모션 제안 서명을 생성하는 유틸리티입니다.

이 유틸리티는 인앱 구매 개인 키를 사용하여 제안에 서명하고 생성하는 무거운 작업을 수행합니다.

구독 프로모션 제안에 익숙하지 않다면, "구독 제안 모범 사례"라는 제목의 세션에서 자세히 알아보세요.

이제 세 가지 핵심 라이브러리 기능에 대해 자세히 알아봅시다.

App Store Server API, 서명된 데이터 확인 및 App Store Server API로 이동.

App Store Server API를 시작합시다.

서버 API의 기초는 거래 기록 가져오기 엔드포인트이다.

단순히 거래 ID를 사용하여, 이 API는 고객의 완전한 인앱 구매 거래 내역을 제공합니다.

그리고 그것은 이 끝점을 넘어 훨씬 더 많은 기능을 가지고 있다.

이 API에는 12개의 엔드포인트가 있으며, 모두 인증 형태인 JSON 웹 토큰이 필요합니다.

JWT를 생성하는 것은 중요한 단계이며, 이 과정에 익숙하지 않다면, 그것이 도서관이 들어오는 곳입니다.

앱 스토어 서버 API와 함께 사용할 라이브러리 설정을 시연하기 위해 알렉스에게 넘어가세요.

알렉스: 안녕하세요, 저는 앱 스토어 서버 엔지니어인 알렉스 베이커입니다.

App Store Server 라이브러리를 시작하는 방법과 App Store Server API를 호출하는 방법을 보여드리겠습니다.

이 데모는 App Store 서버 라이브러리를 구성하는 데 필요한 정보를 수집한 다음 API 클라이언트를 만들고 API를 호출하는 예를 보여줍니다.

라이브러리와 함께 App Store Server API를 사용해야 하는 정보를 얻기 위해 App Store Connect에서 시작합니다.

사용자 및 액세스 모듈로 이동하세요...

그런 다음 키 탭, 인앱 구매 옵션.

여기에 몇 가지 유용한 정보가 있다.

먼저, 발행인 ID.

다음으로, 나는 새로운 개인 키를 생성할 것이다.

이름을 지정한 다음, 생성을 클릭하세요.

키를 생성하는 것은 두 가지 정보를 제공합니다: 키 ID와 개인 키를 다운로드하는 옵션.

다운로드는 한 번만 가능합니다.

Apple 공개 키 인프라 웹사이트로 전환하려면, 왼쪽 상단의 Apple 루트 인증서 섹션에 집중하세요.

루트 인증서를 다운로드하세요.

여기 Gradle 빌드 시스템을 사용하는 간단한 Java 프로젝트가 있습니다.

먼저, App Store 서버 라이브러리에 대한 종속성을 추가하세요.

ExampleApp 클래스로 이동하면, 여기에 이전에 얻은 정보, issuerId, keyId 및 개인 키가 있습니다.

또한, 앱의 bundleId를 저장하세요-- 이 데모에서, 저는 샌드박스를 사용하고 있습니다-- 그리고 적절한 열거형 값을 저장하세요.

이러한 정보를 사용하여 AppStoreServerAPIClient를 인스턴스화하세요.

이 클라이언트에서 테스트 알림 요청 엔드포인트를 호출하면 App Store 서버가 App Store Connect에서 구성한 URL로 TEST 유형의 알림을 보내도록 요청합니다.

마지막으로, testNotificationToken을 인쇄하세요.

이것을 실행하면, 우리는 testNotificationToken이 인쇄된 것을 보게 될 것이며, 예상대로 이 토큰을 보게 될 것입니다.

이것은 App Store Server 라이브러리를 사용하여 App Store Server API와 App Store Connect에서 필요한 정보를 사용하는 방법을 보여주었습니다.

이제 데이브에게 돌아가.

데이브: 고마워, 알렉스.

그 데모는 이 라이브러리가 서버 API와 함께 사용하기 위해 JWT를 얼마나 빨리 설정하고 생성하는지 보여줍니다.

이 라이브러리는 API를 채택할 때 구현 일정을 줄이는 데 의미 있는 영향을 미칠 것입니다.

라이브러리를 사용하는 것은 유용하고 간단하지만, 인앱 구매 개인 키를 안전하게 저장하는 것보다 더 중요한 것은 없습니다.

그리고 키가 손상되었다고 생각한다면, 언제든지 App Store Connect에서 새 키를 생성하세요.

개발을 시작할 때, 샌드박스와 TestFlight 거래로 시작하는 것이 좋습니다.

그리고 마지막으로, 업데이트된 Apple 루트 인증 기관을 정기적으로 확인하세요.

이제 서명된 데이터 검증이 인앱 구매로 비즈니스의 기본 조치인 이유에 대해 논의해 봅시다.

먼저 서명된 데이터에 무엇이 포함되어 있고 왜 중요한지 논의해 봅시다.

StoreKit 서명 데이터는 App Store에서 JSON 웹 서명 형식으로 생성되고 서명되었음을 의미하며 앱 구매, 인앱 구매, 고객 이벤트 및 고객 구독 상태에 대한 데이터를 포함합니다.

가장 일반적인 두 개의 서명된 데이터 페이로드는 JWS 거래와 JWS 갱신 정보이다.

그런 다음 appTransaction에는 원래 구매한 앱 버전과 현재 장치에 설치된 버전에 대한 세부 정보가 포함되어 있습니다.

그리고 우리는 App Store 서버 알림 V2를 가지고 있으며, 알림 자체는 서명된 데이터이며 추가로 JWS 거래 및 JWS 갱신 정보를 포함할 수 있습니다.

그리고 이미 잘 알고 계시겠지만, 이 JWS 서명된 데이터는 iOS 15 이상 버전의 StoreKit 2와 App Store Server API 및 App Store Server Notifications v2에서만 찾을 수 있습니다.

다음 이벤트 후에 JWS 서명된 데이터를 확인하는 것이 좋습니다: 장치에서 콘텐츠를 전달하거나 잠금 해제할 때 또는 서버가 서명된 데이터를 받았을 때, 자신의 앱, 다른 서버 또는 App Store 서버 알림에서 온 것이든.

그리고 마지막으로, App Store 서버 API로부터 응답을 받을 때.

JWS 서명된 데이터를 확인하는 방법과 라이브러리가 이를 처리하는 방법을 시연하는 알렉스가 있습니다.

알렉스: 이 섹션에서는 App Store에서 서명된 데이터를 확인하는 방법을 보여드리겠습니다.

당신이 수행해야 할 검증 과정을 설명하겠습니다.

그런 다음, App Store 서버 라이브러리의 SignedDataVerifier 클래스가 이 프로세스를 어떻게 수행할 수 있는지 살펴보겠습니다.

제가 설명하려고 하는 작업 뒤에 있는 RFC와 프로토콜에 익숙하지 않을 때 App Store Server Library와 같은 도구를 사용하는 것이 매우 바람직하다는 것을 강조하고 싶습니다.

여기 App Store에서 서명된 데이터가 있습니다.

여기서 많은 일이 일어나고 있는 것 같아.

컬러 코딩은 세 개의 섹션이 있음을 보여준다.

각 섹션은 마침표로 구분되며 Base64 URL로 인코딩됩니다.

첫 번째이자 가장 큰 섹션은 헤더이다.

일단 디코딩되면, 헤더는 JWS 사양에 의해 정의된 필드가 있는 JSON 구조이다.

이 경우, 우리의 헤더에는 두 개의 필드만 있습니다: 첫째, 항상 ES256인 알고리즘.

다음은 x5c라는 필드입니다.

이것은 JWS에 서명한 예상 공개 키를 계산하는 데 사용되는 인증서 배열입니다.

인증서 체인 건설 과정을 검토해 봅시다.

배열의 첫 번째 인증서는 리프 인증서이다.

이 인증서의 공개 키는 JWS에 서명했다.

이 인증서가 Apple에서 온 것인지 확인하려면, 알려진 신뢰할 수 있는 소스, 이 경우 Apple 루트 인증 기관에 대한 신뢰 체인을 구축하십시오.

배열의 다음 인증서는 Apple Worldwide Developer Relations 중간 인증 기관입니다.

이것을 개발자에게 초점을 맞춘 Apple Root Certificate Authority의 보다 전문화된 버전으로 생각하십시오.

체인의 마지막 인증서는 Apple 루트 인증 기관이므로 어떤 Apple 기관이 이 체인을 시작했는지 이해할 수 있습니다.

알림, 인증서가 이전에 Apple의 공개 키 인프라 웹사이트에서 얻은 루트 인증서와 정확히 일치하는지 확인하는 것이 중요합니다.

첫 번째 단계는 각 인증서가 체인의 이전 인증서에 의해 서명되었는지 확인하는 것입니다.

그런 다음 각 인증서에 유효한 날짜가 있는지, 제대로 포맷되었는지 확인하는 것과 같은 추가 확인 단계를 수행하십시오.

다음으로, 이러한 인증서가 Apple에서 온 것이며, App Store 데이터에 서명하는 데 유효하지 않은 관련 없는 사용 사례와는 달리 App Store 데이터에 서명하는 것이 목적인지 확인하십시오.

리프 인증서를 확인하려면, Mac App Store 영수증 서명을 위한 개체 식별자 또는 OID의 존재를 확인하여 목적을 확인하십시오.

중간 인증서의 경우, Apple Worldwide Developer Relations의 중간 기관 OID를 확인하세요.

마지막으로, 앞서 언급했듯이, 루트 인증 기관이 Apple 루트 인증 기관으로 저장한 인증서 중 하나인지 확인하십시오.

이제 실제로 리프 인증서를 디코딩하고 이러한 값을 확인하는 방법을 관찰해 봅시다.

다음은 OpenSSL x509 명령에 의해 생성된 인증서의 X.509 v3 확장 섹션입니다.

하단에는 이전 슬라이드에 나열된 OID가 있으며, 인증서의 목적은 App Store 영수증 서명임을 나타냅니다.

그러나, 확인해야 할 몇 가지 추가 필드가 있다.

여기서 우리는 발행인에 대한 정보를 제공하고, 중요한 것은 인증서가 취소되었는지 확인하기 위한 정보를 제공하는 권한 정보 액세스 섹션을 볼 수 있습니다.

온라인 인증서 상태 프로토콜 또는 OCSP 사용.

검증 절차를 진행하기 전에 인증서가 취소되었는지 확인하세요.

그렇게 하기 위한 프로세스와 암호화 절차는 RFC 6960에 정의되어 있다.

인증서 체인을 확인한 후, JWS가 리프 인증서의 공개 키로 서명되었는지 확인하세요.

이전에서 리프 인증서를 가져와, 리프 인증서의 공개 키를 추출하고, 키와 원본 JWS를 가져와 JWS 서명 확인 기능에 전달하십시오.

검증 기능은 데이터가 공개 키로 서명되어 있는지 확인하고 페이로드를 디코딩합니다.

그 과정은 거의 완료되었지만, 한 가지 추가 검증 단계가 있다.

여기 디코딩된 앱 스토어 서버 테스트 알림이 있습니다.

이전 단계는 데이터가 App Store에서 왔다는 것을 확인했다.

그러나, 또한 알림이 올바른 응용 프로그램과 환경을 대상으로 하고 있는지 확인하세요.

appAppleId와 bundleId를 확인하여 알림이 올바른 애플리케이션을 대상으로 하는지 확인하세요.

환경이 예상 환경과 일치하는지 확인하세요.

인증 프로세스의 다른 단계와 마찬가지로, App Store 서버 라이브러리는 인증을 수행할 때 이를 확인합니다.

그것은 App Store에서 서명된 데이터를 확인하는 과정을 완료합니다.

다음으로, App Store 서버 라이브러리에 포함된 SignedDataVerifier 클래스를 사용하여 서명된 데이터를 확인하기 위해 이전부터 프로젝트를 확장할 것입니다.

SignedDataVerifier 클래스는 이전에 다룬 검증 단계를 수행합니다.

이 데모에서는 이전에 요청한 테스트 알림을 받은 다음 서명된 알림을 검증하고 디코딩할 것입니다.

테스트 알림을 요청하는 것과 내 서버에서 알림을 받는 것 사이에 약간의 지연이 있다.

그러므로, 5초 지연을 추가하세요.

다음으로, 이전에 얻은 testNotificationToken을 사용하여 Get Test Notification Status 엔드포인트를 호출하세요.

마지막으로, 성공을 확인하기 위해 알림의 처음 몇 글자를 인쇄하세요.

Get Test Notification Status 엔드포인트는 전송 시도의 결과와 알림 페이로드를 반환합니다.

그 페이로드의 시작은 우리가 봐야 할 것이다.

예상대로, 나는 알림의 처음 몇 글자를 본다.

계속해서, 서명된 데이터 검증기를 만드세요.

이것은 애플 루트 인증 기관 목록부터 시작하는 세 가지 정보가 필요합니다.

이전에 다운로드한 인증서는 이제 리소스 폴더에 있습니다.

루트 인증서를 세트로 가져오세요.

샌드박스를 사용하고 있기 때문에, 앱 Apple ID가 필요하지 않습니다.

샌드박스에서 대신 null을 전달하세요.

마지막으로, 취소 확인을 수행할지 여부.

알림을 방금 받았기 때문에, 온라인 수표는 사실이어야 한다.

몇 달 또는 몇 년 전에 받은 알림의 경우, 인증서가 만료되었을 수 있기 때문에 이것은 거짓이어야 합니다.

이 필드를 새로운 SignedDataVerifier로 전달하세요.

그런 다음, 이전에 받은 알림을 전달하고, 결과를 인쇄한 다음, 프로그램을 실행하세요.

프로그램이 완료되면, 프로그램은 검증되고 디코딩된 알림을 표시합니다.

이것은 테스트 알림이기 때문에, 이것은 몇 가지 다른 필드와 함께 페이로드에 테스트 유형과 앱의 번들 식별자를 가질 것이다.

예상대로, 나는 TEST 유형의 디코딩된 알림을 본다.

나는 SignedDataVerifier 객체를 시연하기 위해 이전 데모를 확장했다.

여기 몇 가지 모범 사례를 검토할 데이브가 있습니다.

데이브: 와우, 그것은 서명된 데이터를 확인하는 데 필요한 모든 단계와 라이브러리가 그 복잡성을 어떻게 처리할 수 있는지를 보여줍니다. 그러니 서버 측 검증을 위해 SignedDataVerifier를 활용해야 합니다.

중요한 알림: 데이터를 확인할 때, 올바른 앱이나 서비스에 대한 구매를 승인하거나 취소하기 위해 앱과 제품 식별자를 확인해야 합니다.

마지막으로, 인증서가 만료되고 취소될 수 있으므로, 인증서, 클라이언트 측 또는 서버 측을 하드코딩하지 말고, 항상 활성화되어 있는지 확인하십시오.

이제 우리는 서버 측 앱 영수증 검증을 verifyReceipt 엔드포인트에서 App Store Server API로 이동하는 것을 돕기 위해 다른 App Store 서버 유틸리티를 검토할 것입니다.

App Store 서버 라이브러리는 이 마이그레이션을 특별히 돕는 유틸리티를 제공하며 앱이 뒤쳐지지 않도록 합니다.

App Store Server API로 이동하는 것을 고려할 때, 로드맵에서 이 작업의 우선 순위를 정해야 하는 많은 이유가 있습니다.

API는 구매 검증을 지원하며 고객 지원, 불만 완화 및 App Store 서버 알림 V2 테스트에 유용한 추가 엔드포인트를 포함합니다.

우리가 계속 업데이트하고 새로운 속성을 출시함에 따라, 이것들은 StoreKit 2, App Store Server API 및 App Store Server Notifications V2에서 지원하는 JWS 서명된 데이터로만 출시될 것입니다.

기록해야 하는 유일한 데이터인 추가 혜택은 원본 거래 ID 또는 거래 ID입니다.

더 이상 계정 시스템에 base64로 인코딩된 영수증을 저장할 필요가 없습니다.

그리고 최신 API에 대한 지속적인 투자로, 우리는 verifyReceipt 엔드포인트가 이제 더 이상 사용되지 않는다는 것을 발표했습니다.

자세한 내용은 "App Store 서버 API의 새로운 기능" 세션에서 자세한 업데이트 및 지침을 확인하세요.

이제 App Store 서버 라이브러리가 마이그레이션에 어떻게 도움이 될지 공유할 알렉스가 있습니다.

알렉스?

알렉스: 고마워, 데이브.

이제 앱 영수증의 흐름도를 살펴봅시다.

StoreKit 2와 App Store Server API는 사용하기에 좋은 도구이지만, 최근에 업데이트되지 않은 구형 장치 또는 사용자의 클라이언트를 지원하는 것이 중요하며, 앱 영수증만 서버에 제공될 수 있습니다.

이 장치들이 이전에 어떻게 지원되었는지, 그리고 verifyReceipt의 사용 중단에 따라 이러한 클라이언트를 계속 지원할 수 있는 방법을 보여 드리겠습니다.

먼저, 장치가 당신의 서버로 영수증을 보냅니다.

이전 모델에서, 당신의 서버는 이 영수증을 verifyReceipt에 전달한 다음, 디코딩된 영수증을 받습니다.

응답에는 App Store Server API의 Get Transaction History 엔드포인트로 전달되는 originalTransactionId가 포함되어 있습니다.

App Store 서버는 고객에게 서비스를 제공하는 데 사용하는 서명된 거래를 반환합니다.

이제 verify 영수증이 더 이상 사용되지 않습니다. 이 섹션을 교체해 봅시다.

App Store 서버 라이브러리의 영수증 유틸리티는 영수증에서 거래 ID를 직접 추출합니다.

거래 ID를 App Store Server API로 전달하여 두 번의 왕복 여행을 할 필요가 없습니다.

그 후, 엔드포인트에서 수정본을 저장하세요.

이것은 매번 전체 역사를 다시 분석할 필요가 없다.

앱 영수증에서 추출한 값은 원래 거래 ID일 수도 있고 아닐 수도 있기 때문에, 거래 기록 가져오기 엔드포인트를 포함한 많은 엔드포인트가 이제 원래 거래 ID뿐만 아니라 모든 거래 ID를 매개 변수로 지원한다는 것을 발표하게 되어 기쁩니다.

이제 App Store 서버 라이브러리를 사용하여 Get Transaction History 엔드포인트와 함께 사용할 거래 ID를 추출하는 것을 시연할 것입니다.

여기서 나는 앱 영수증을 받고, 거래 ID를 추출하고, ID를 사용하여 거래 내역 가져오기 엔드포인트를 호출할 것이다.

먼저, 앱 영수증.

장치 또는 App Store 서버 알림 V1에서 앱 영수증을 받을 수 있습니다.

나 여기 벌써 하나 있어.

다음으로, ReceiptUtility 클래스의 인스턴스를 만드세요.

거래 ID를 추출하려면, 앱 영수증 방법에서 추출 거래 ID를 호출하세요.

모든 영수증에 거래 ID가 있는 것은 아니다.

사용자가 구매를 하지 않을 수도 있다.

그러므로, 널 수표를 추가하세요.

이 문제에 대해 좀 더 깊이 있게 하기 위해, 우리가 이 사용자를 위한 가장 최근의 소모품에 대한 정보를 얻고 취소된 소모품을 제외하기를 원한다고 상상해 보세요.

거래 내역 요청 객체를 만들고, 취소된 거래를 제외하기 위해 CONSUMABLE 유형의 제품만 원하고 데이터가 내림차순으로 반환되어야 한다고 지정하십시오.

우리는 두 개의 도우미 객체, 응답 변수, 그리고 거래 목록이 필요하다.

거래 내역 엔드포인트의 응답을 통해 페이지를 반복하는 동안.

이것이 첫 번째 요청이 아니라면, 데이터를 통해 페이징을 유지하기 위해 이전 응답에서 수정 토큰을 가져오세요.

그런 다음, 앱 영수증, 요청 객체 및 수정본의 거래 ID로 거래 내역 가져오기 엔드포인트를 호출하십시오.

마지막으로, 응답에서 거래 목록에 대한 모든 거래를 추가하세요.

응답에서 hasMore 필드가 거짓이 될 때까지 이 과정을 반복하세요.

결과를 보려면 거래를 인쇄하세요.

여기서 API에서 반환된 거래 목록을 볼 수 있습니다.

이전 데모에서 SignedDataVerifier를 사용하여 디코딩할 수 있습니다.

App Store Server API로 앱 영수증을 사용하는 방법을 보여주는 최종 시연에 참여해 주셔서 감사합니다.

우리를 마무리하기 위해 데이브에게 돌아가.

데이브: 새로운 App Store Server 라이브러리가 정말 기대되며, 이러한 기능이 API 채택을 용이하게 하고 App Store Server API로 전환하는 것을 볼 수 있습니다.

여기 Github의 App Store Server API Java 저장소의 스크린샷이 있습니다.

이 페이지에서, 당신은 우리의 문서에 대한 링크를 찾고, 풀 리퀘스트를 제출하고, 라이브러리를 사용하는 방법의 예를 찾을 수 있습니다.

곧 App Store Server 라이브러리 BETA를 다운로드하고 App Store Server API 채택 계획을 시작할 수 있습니다.

우리는 당신의 피드백과 기능 요청을 기대합니다.

피드백 어시스턴트와 Github로 연락주세요.

고마워.

♪ ♪