10159

♪ ♪

해리: 안녕하세요, 저는 SwiftUI 팀의 엔지니어인 해리입니다.

SwiftUI에서 스크롤 뷰의 새로운 개선 사항에 대해 이야기할 Beyond Scroll Views에 오신 것을 환영합니다.

우리 장치가 하고 싶은 일은 고정된 화면 크기에 거의 포함될 수 없다.

그들이 이 복잡성을 다루는 한 가지 방법은 스크롤을 도입하는 것이다.

이것은 그들이 우리에게 화면에 맞지 않는 모든 것을 보여줄 수 있게 해준다.

SwiftUI는 스크롤을 자신의 앱에 통합할 수 있는 몇 가지 다른 구성 요소를 제공합니다.

오늘, 나는 그 구성 요소들 중 하나에 대해 이야기할 것이다.

스크롤뷰.

ScrollView는 콘텐츠를 스크롤할 수 있는 빌딩 블록입니다.

스크롤 뷰에는 스크롤할 수 있는 방향을 정의하는 축이 있습니다.

스크롤 보기에는 내용이 있다.

그 콘텐츠가 ScrollView의 크기를 초과하면, 그 콘텐츠 중 일부는 잘릴 것이며, 사람들은 그것을 드러내기 위해 스크롤해야 할 것이다.

스크롤 뷰는 안전 영역을 콘텐츠의 여백으로 해결하여 콘텐츠가 안전 영역 내에 배치되도록 합니다.

ScrollView는 기본적으로 콘텐츠를 열심히 평가합니다.

게으른 스택을 사용하여 이 동작을 변경할 수 있습니다.

콘텐츠 내에서 ScrollView가 스크롤되는 정확한 위치를 콘텐츠 오프셋이라고 합니다.

SwiftUI는 콘텐츠 오프셋을 제어하는 방법으로 ScrollViewReader API를 제공했다.

올해 SwiftUI는 ScrollView에서 관리하는 콘텐츠 오프셋에 영향을 미치고 반응하는 더 많은 방법을 도입하고 있다.

이 강연에서, 저는 ScrollView의 마진에 영향을 미치는 방법과 그들이 안전한 지역과 어떤 관련이 있는지 논의하는 것으로 시작하겠습니다.

그런 다음 스크롤 대상과 스크롤 위치를 통해 ScrollView의 콘텐츠 오프셋을 관리하는 것에 대해 이야기하겠습니다.

마지막으로, 스크롤 전환으로 앱에 진정한 감각을 더할 수 있는 방법을 보여드리겠습니다.

내가 컬러 앱을 만들기 시작한 이후로, 내 사용자들은 나에게 그들이 가장 좋아하는 색상 조합을 보여주는 것을 정말 좋아했다.

다른 사람들이 즐길 수 있도록 이 조합 중 일부를 소개하고 싶습니다.

이를 위해, 저는 색상 앱에 갤러리 기능을 추가하는 작업을 하고 있습니다.

나는 이미 내 갤러리를 구현하는 데 약간의 진전을 이루었다.

이 강연을 통해 나는 내 갤러리의 특집 섹션의 헤더와 내용을 모두 연마할 것이다.

내 갤러리에는 게으른 스택을 감싸는 수평 스크롤뷰가 있다.

나는 먼저 약간의 여백으로 이 뷰를 좀 더 멋지게 보이게 할 것이다.

당신의 첫 번째 본능은 ScrollView에 패딩을 추가하는 것일 수 있으며, 이것은 ScrollView를 삽입할 것이지만, 스크롤할 때 콘텐츠가 잘리는 것을 주목하세요.

ScrollView 자체를 설정하는 대신, ScrollView의 콘텐츠 여백을 확장하고 싶습니다.

나는 새로운 안전 구역 패딩 수정기로 그것을 할 수 있다.

이것은 일반 패딩 수정자처럼 작동하지만, 콘텐츠를 패딩하는 대신 안전한 영역에 패딩을 추가합니다.

이제 내 ScrollView는 전체 너비를 확장하여 다음 항목을 엿볼 수 있습니다.

더 나아가기 전에, 나는 ScrollView와 관련된 안전한 영역에 대해 조금 이야기할 것이다.

안전한 영역은 가장 일반적으로 앱이 실행 중인 장치에서 나옵니다.

또한 안전 영역 패딩이나 안전 영역 삽입 수정자와 같은 API에서 나올 수 있습니다.

ScrollView는 안전 영역을 콘텐츠에 적용되는 여백으로 해결합니다.

여기에는 당신이 책임지는 콘텐츠뿐만 아니라 스크롤 표시기처럼 ScrollView가 책임지는 추가 콘텐츠도 포함됩니다.

이것은 안전 영역을 수정하여 다른 종류의 콘텐츠에 대해 다른 삽입물을 구성할 수 없다는 것을 의미합니다.

다른 삽입을 적용하려면, 새로운 contentMargins API를 사용할 수 있습니다.

이 API를 사용하면 스크롤 표시기와 별도로 ScrollView의 내용을 삽입할 수 있습니다.

또는 내용과 별도로 지표를 삽입하세요.

갤러리로 돌아가서, 콘텐츠 마진 API를 사용하기 위해 안전 영역 패딩 수정자를 업데이트할 것입니다.

이제 내 견해에 약간의 여백이 적용되어 있기 때문에, 내가 하고 싶은 일 중 하나는 누군가가 손가락을 떼면 ScrollView가 스크롤할 콘텐츠 오프셋을 제어하는 것이다.

기본적으로 ScrollView는 스크롤의 속도와 함께 표준 감속 속도를 사용하여 스크롤이 끝나야 하는 대상 콘텐츠 오프셋을 계산합니다.

그것은 ScrollView의 크기나 그 내용과 같은 것들을 고려하지 않는다.

하지만 가끔 그런 것들이 중요해.

SwiftUI의 새로운 기능, ScrollView가 scrollTargetBehavior 수정자로 이 대상 콘텐츠 오프셋을 계산하는 방법을 변경할 수 있습니다.

이 수정자는 scrollTargetBehavior 프로토콜을 준수하는 유형을 취한다.

여기서 나는 페이징 행동을 명시했다.

이제 내 ScrollView는 한 번에 한 페이지를 스와이프한다.

페이징 행동은 특별하다.

사용자 지정 감속 속도가 있으며 ScrollView 자체의 포함 크기에 따라 스크롤할 위치를 선택합니다.

이것은 iOS에서 잘 작동하지만, iPadOS의 더 큰 화면에서 조금 더 많이 된다.

ScrollView의 포함 크기에 정렬하는 대신, 개별 보기에 정렬하고 싶습니다.

보기 정렬 동작은 ScrollView를 보기에 정렬하므로 ScrollView는 정렬을 위해 어떤 보기를 고려해야 하는지 알아야 합니다.

이러한 뷰를 스크롤 대상이라고 하며, 어떤 뷰가 스크롤 대상인지 지정할 수 있는 새로운 수정자 제품군이 있습니다.

여기서 나는 스크롤 대상 레이아웃 수정자를 사용하여 게으른 스택의 각 영웅 보기를 스크롤 대상으로 간주할 것이다.

스크롤 대상 수정자를 사용하여 개별 뷰를 대상으로 표시할 수도 있습니다.

하지만 게으른 스택을 사용할 때, 스크롤 대상 레이아웃 수정자를 사용하는 것이 중요합니다.

보이는 지역 밖의 전망은 아직 만들어지지 않았다.

하지만 레이아웃은 어떤 뷰를 만들 것인지 알고 있으므로 ScrollView가 올바른 위치로 스크롤되도록 할 수 있습니다.

이제 내 ScrollView는 iPad에서 훨씬 더 좋아 보인다.

페이징 및 보기 정렬 동작은 새로운 ScrollTargetBehavior 프로토콜을 기반으로 합니다.

SwiftUI는 이러한 일반적인 동작을 제공하지만, 이전에 도입된 레이아웃 프로토콜을 채택하는 것처럼 자신의 유형을 이 프로토콜에 적용하고 사용자 지정 동작을 구현할 수 있습니다.

필요한 한 가지 방법을 구현하여 ScrollTargetBehavior에 자신만의 유형을 적용하세요: updateTarget.

SwiftUI는 스크롤이 끝나야 하는 곳을 계산할 때뿐만 아니라 ScrollView가 크기를 변경할 때와 같은 다른 컨텍스트에서도 이 방법을 호출합니다.

행동을 맞춤화하는 것은 쉽다.

여기서 대상이 ScrollView의 상단에 가깝고 스크롤이 위로 튕겨졌다면, 제공된 대상을 수정하여 ScrollView의 정확한 상단으로 스크롤하는 것을 선호합니다.

이로 인해 ScrollView는 스크롤의 끝점으로 다른 콘텐츠 오프셋을 선택합니다.

그리고 그것이 ScrollView가 스크롤을 선택하는 곳에 영향을 미치기 위해 나만의 사용자 지정 코드를 삽입하는 데 필요한 전부입니다.

내 갤러리 뷰로 돌아가자.

레이아웃에 대해 이야기하고 싶어요.

내 영웅 보기가 장치의 전체 너비와 관련하여 크기가 조정되었다는 것을 주목하세요.

그리고 우리가 아이패드를 보면, 두 개의 보기가 장치의 너비에 고르게 들어맞는다.

이전에는 이것을 달성하기 위해 GeometryReader를 사용해야 했지만, 올해 SwiftUI는 containerRelativeFrame 수정자라는 새로운 API로 이것을 훨씬 쉽게 만듭니다.

내 영웅 보기가 이 API를 어떻게 사용하는지 보여줄게.

고정 높이를 지정하는 프레임 수정자와 함께 색상 보기 스택으로 시작하겠습니다.

내 보기에 containerRelativeFrame 수정자를 추가할 것이다.

여기서 나는 보기가 컨테이너의 너비를 차지할 수 있는 수평 축을 지정한다.

제 경우에는 컨테이너가 주변 ScrollView가 될 것이지만, 내비게이션 분할 보기의 가장 가까운 열이나 앱의 창일 수도 있습니다.

내 컨테이너의 너비가 바뀌면, 내 뷰의 크기가 자동으로 업데이트됩니다.

카운트와 간격을 제공하여 이러한 뷰의 그리드와 같은 레이아웃을 만들 수 있습니다.

iPad에 두 개의 열과 전화에 한 열을 갖도록 수평 sizeClass에 따라 카운트를 조건화할 수 있습니다.

더 좋은 점은 이제 모든 플랫폼에서 수평 sizeClass 환경 속성을 사용할 수 있기 때문에 OS 조건을 제거할 수 있다는 것입니다.

마지막으로, 나는 고정 높이를 하드코딩하는 대신 너비에 상대적인 높이를 갖기 위해 aspectRatio 수정자를 사용할 것이다.

그래서 나는 내 갤러리의 레이아웃과 스크롤 동작을 끝냈다.

내가 하고 싶은 변화가 좀 더 있어.

당신이 알아차릴 한 가지는 스크롤 표시기입니다.

나는 그것들을 제거하고 싶어.

나는 이것을 달성하기 위해 기존 scrollIndicators API를 사용할 수 있다.

이것은 iPad에서 손가락을 스와이프할 때 멋져 보이지만, 나는 종종 Mac에서 갤러리를 사용한다.

그리고 Mac에서는 마우스나 다른 입력 장치를 사용할 때와 같이 수평 스와이프 제스처를 쉽게 수행하지 못할 수도 있습니다.

그리고 마우스를 연결할 때, 내가 숨겨달라고 요청했음에도 불구하고, 표시기가 보인다.

마우스를 사용하면 스크롤 표시기 없이는 스크롤이 어렵거나 불가능할 수 있습니다.

이러한 이유로, scrollIndicators 수정자의 기본 동작은 트랙패드와 같은 더 유연한 입력 장치를 사용할 때 표시기를 숨기는 것이지만, 마우스가 연결되어 있을 때 표시기를 표시할 수 있도록 하는 것입니다.

입력 장치에 관계없이 항상 지표를 숨기기 위해 scrollIndicators 수정자에 never의 값을 제공할 수 있습니다.

하지만 내 앱은 여전히 마우스를 사용하는 사람들을 지원해야 한다.

그래서 나는 그들을 위해 내 갤러리를 스크롤할 수 있는 다른 수단을 제공해야 할 것이다.

스크롤 표시기 대신, 사용자가 클릭 한 번으로 이전 또는 다음 보기로 스크롤할 수 있는 몇 가지 보기를 렌더링할 것입니다.

그것을 만들기 시작하려면, 내 ScrollView를 조금 정리해 봅시다.

내 ScrollView를 내 헤더 보기로 VStack으로 옮길 거야.

이제 나는 헤더 보기에 집중할 것이다.

헤더 뷰에 사용자 지정 패들 뷰를 추가하겠습니다.

이전 버전의 SwiftUI에서, 나는 내 패들로 전달하고 적절한 보기로 스크롤하기 위해 ScrollViewReader에 도달했을 것이다.

하지만 SwiftUI의 새로운 것은 scrollPosition 수정자이다.

이 수정자는 식별자를 감싸는 상태에 바인딩을 연관시킨다.

나는 그것을 ScrollView가 내 헤더 보기에서 읽을 내 scrollPosition 수정자에게 전달할 것이다.

내 헤더 뷰의 패들에서, 나는 다른 상태처럼 바인딩에 쓸 수 있다.

바인딩이 기록되면, ScrollView는 해당 ID로 보기로 스크롤됩니다.

ScrollTargetBehavior를 정렬한 것과 마찬가지로, 스크롤 위치 수정자는 스크롤 대상 레이아웃 수정자를 사용하여 신원 값을 쿼리하기 위해 고려해야 할 뷰를 알 수 있습니다.

스크롤 위치 수정자는 또한 현재 스크롤된 뷰의 신원을 알 수 있게 해준다.

그래서 나는 현재 스크롤된 영웅 이미지의 가치를 보여주는 텍스트를 헤더 보기에 추가할 수 있다.

내 ScrollView에서 가장 선두적인 보기가 바뀌면, 바인딩이 자동으로 업데이트됩니다.

이제 내 마우스 사용자는 내 갤러리를 스크롤할 수 있다.

이 견해에 마지막으로 추가하고 싶은 폴란드어가 하나 있습니다.

현재 어떤 보기가 스크롤되어 있는지 아는 것이 유용한 것처럼, 때때로 나는 ScrollView 내의 위치에 따라 보기를 시각적으로 변경하고 싶다.

SwiftUI에는 이것을 정말 쉽게 만드는 ScrollTransitions라는 새로운 API가 있습니다.

스크롤 전환은 정상적인 전환과 매우 비슷하다.

전환은 뷰가 나타나거나 사라질 때 겪어야 하는 변화를 설명한다.

뷰가 나타나면, 사용자 지정을 적용해서는 안 되는 정체성 단계에 있다.

ScrollTransition은 비슷한 변경 집합을 전환으로 설명하지만 대신 보기가 ScrollView의 보이는 영역에 들어간 다음 보이는 영역을 떠날 때 적용합니다.

기본적으로, 뷰가 보이는 영역의 중앙에 있을 때, 그것은 ScrollTransition의 정체성 단계에 있다.

내 영웅적 관점의 맥락에서 이것을 살펴봅시다.

나는 ScrollTransitions에 집중하기 위해 이것을 조금 정리할 것이다.

보기가 ScrollView의 가장자리에 가까워짐에 따라, 크기를 조금 축소하고 싶습니다.

스크롤 전환 수정자를 추가하는 것으로 시작하겠습니다.

이 API는 콘텐츠와 단계를 취하고 단계에 따라 콘텐츠에 대한 시각적 변경 사항을 지정할 수 있습니다.

여기서 나는 뷰가 정체성 단계에 있지 않을 때 규모 감소를 명시할 것이다.

그거 멋지다!

ScrollTransitions는 VisualEffect라는 새로운 프로토콜과 함께 작동합니다.

이 프로토콜은 ScrollView의 콘텐츠 오프셋과 같은 레이아웃 기능으로 안전하게 사용할 수 있는 보기 콘텐츠에 대한 사용자 지정 세트를 제공합니다.

그들 중 많은 사람들이 당신에게 친숙해 보일 수도 있습니다.

당신은 이미 스케일 효과에 대해 알고 있습니다.

또한 보기 수정자와 마찬가지로 회전이나 오프셋을 사용자 정의할 수 있습니다.

그러나, 모든 보기 수정자를 스크롤 전환 내에서 안전하게 사용할 수 있는 것은 아니다.

예를 들어, 글꼴 사용자 지정은 지원되지 않으며 빌드되지 않습니다.

ScrollView의 전체 콘텐츠 크기를 변경하는 것은 scrollTransition 수정자 내에서 사용할 수 없습니다.

와, 우리는 많은 것을 다뤘으니 빠른 검토를 해보자.

우리는 안전 영역과 contentMargins의 차이점과 ScrollViews와의 관계에 대해 이야기했습니다.

페이징 및 보기 정렬된 scrollTargetBehaviors를 사용하여 ScrollView가 작동하는 방식과 scrollTargetBehavior 프로토콜에 대한 자신의 적합성을 어떻게 작성할 수 있는지 보여주었습니다.

containerRelativeFrame 수정자를 사용하여 컨테이너에 대한 레이아웃을 만드는 것이 얼마나 쉬운지 배웠습니다.

저는 scrollPosition 수정자를 사용하여 ScrollView의 상태에 연결하여 프로그래밍 방식으로 스크롤하고 현재 어떤 보기가 스크롤되어 있는지 알 수 있습니다.

그리고 마지막으로, 저는 scrollTransition API로 ScrollView의 콘텐츠 오프셋을 기반으로 시각 효과를 만들었습니다.

ScrollViews의 이러한 개선 사항에 대해 배우는 것을 즐겼기를 바랍니다.

고마워, 그리고 멋진 WWDC 보내.

♪ ♪