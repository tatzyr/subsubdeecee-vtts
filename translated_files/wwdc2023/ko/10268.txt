10268

♪ ♪

신디: 안녕하세요, 저는 신디이고, 언어 및 런타임 팀의 컴파일러 엔지니어입니다.

이 세션에서, 우리는 Mergeable Libraries를 만나고 있다.

이것은 정적 링커로 구동되는 라이브러리를 구축하고 배포하기 위한 새로운 모델이다.

병합 가능한 라이브러리가 어떻게 작동하여 앱을 더 빠르게 빌드하고 실행할 수 있는지 공유하겠습니다.

그런 다음, Xcode 15에서 병합 가능한 라이브러리를 활성화하는 방법을 보여드리겠습니다.

그리고 마지막으로, 병합 가능한 라이브러리를 사용할 때 고려해야 할 사항과 권장 사항을 다루겠습니다.

우리가 뛰어들기 전에, 나는 정적 및 동적 도서관에 대한 간략한 개요를 제공할 것이다.

이것은 병합 가능한 것들의 이점을 강조할 것이다.

정적 라이브러리는 객체 파일의 모음이다.

빌드 시, 정적 링커는 해당 라이브러리에서 사용할 API를 찾고 해당 코드를 앱 바이너리로 복사합니다.

그리고 그것이 복사되었기 때문에, 도서관은 건축 후에 필요하지 않다.

정적 라이브러리의 코드가 변경되거나 더 많은 라이브러리가 사용되는 경우, 빌드 시간 둔화를 초래합니다.

이것은 그들이 앱에 보관되고 연결되는 방식의 결과이며, 반복적인 구축과 디버깅을 느리게 만든다.

대신, 동적 라이브러리는 이것을 방지하기 위해 사용될 수 있다.

동적 라이브러리는 일반적으로 딜립스라고 불린다.

그것들은 Xcode의 프레임워크 대상을 위한 이진 파일 유형이다.

프레임워크의 코드는 실행 파일로 복사되지 않습니다.

오히려, 정적 링커는 나중에 라이브러리의 설치된 경로를 앱 바이너리에 기록한다.

Apple SDK에 없는 모든 프레임워크는 앱 번들에 포함되어야 합니다.

주요 차이점은 동적 라이브러리가 추가되거나 업데이트될 때, 정적 링커는 코드를 복사할 필요가 없다는 것이다.

이것은 더 빠른 빌드를 초래한다.

그러나, 그것은 런타임에 앱을 사용할 때 복잡성을 더한다.

이것은 동적 링커가 필요한 곳이다.

앱이 실행되면, dyld라는 이름의 동적 링커는 프레임워크 종속성을 찾아 로드해야 합니다.

여기에는 프레임워크가 의존하는 라이브러리가 포함된다.

더 많이 사용됨에 따라, 이로 인해 메모리 소비와 앱 출시 시간이 꾸준히 증가한다.

그리고 Apple SDK의 종속성을 고려할 때, 앱은 종종 수백 개의 프레임워크를 로드할 수 있습니다.

우리 플랫폼은 이를 설명하기 위해 크게 최적화된 시스템 라이브러리를 가지고 있다.

하지만 이것은 앱에 포함된 프레임워크에는 적용되지 않습니다.

요약하자면, 정적 라이브러리와 동적 라이브러리를 사용할 때 몇 가지 절충안이 있다.

동적 라이브러리는 빌드 시간에 거의 영향을 미치지 않지만 눈에 띄는 시작 시간 결과이지만, 정적 라이브러리는 최소한의 시작 시간 영향을 제공하지만 빌드 시간에 비용이 많이 든다.

이로 인해, 우리는 역사적으로 당신의 앱에 가장 적합한 것을 측정하는 것을 권장해 왔다.

병합 가능한 라이브러리를 사용하면, 이것은 더 이상 필요하지 않습니다.

병합 가능한 라이브러리는 두 가지 연결 전략의 최고를 잠금 해제합니다.

병합 가능한 라이브러리가 성능과 개발을 위해 어떻게 최적화할 수 있는지 설명하겠습니다.

실행 파일과 같은 이진 이미지를 고려하세요.

이 바이너리가 의존하는 프레임워크는 정적 링커에 주어진다.

이러한 종속성은 병합 가능한 라이브러리가 될 수 있다.

그리고 연결된 출력은 병합된 바이너리가 될 수 있다.

하지만 무엇이 이러한 의존성을 병합 가능하게 만드나요?

이것은 그들이 어떻게 만들어졌는지에 의해 설명될 수 있다.

모든 동적 라이브러리는 병합 가능한 것으로 구축될 수 있다.

정적 링커가 라이브러리를 만들 때, 메타데이터도 생성합니다.

메타데이터는 바이너리 내에 있어, 전체 크기가 증가한다.

링커는 링크 종속성으로 사용될 때 라이브러리를 정적 라이브러리와 유사하게 취급할 수 있다.

메타데이터를 통해 라이브러리 사용자는 일반 동적 라이브러리로 정적으로 연결하거나 병합하도록 선택할 수 있습니다.

병합된 이진 출력은 앱과 같은 실행 파일이나 프레임워크와 같은 다른 동적 라이브러리가 될 수 있다.

병합은 정적 라이브러리가 연결되는 방식과 비슷하다.

결국, 당신은 라이브러리의 세그먼트를 포함하는 바이너리를 남게 됩니다.

그리고 그 출력 바이너리는 같은 파일 유형으로 남아 있다.

Xcode 15에서 병합은 완전히 새로운 것이다.

새로 구현된 정적 링커가 이것을 가능하게 하는 것이다.

그것은 새로운 링커 옵션을 사용하여 작동합니다.

먼저, 병합할 라이브러리는 -make_mergeable 옵션으로 구축됩니다.

이것은 링커에게 메타데이터를 기록하라고 말한다.

다음으로, 병합된 바이너리의 경우, 링커는 라이브러리와 함께 해당 메타데이터를 사용하여 -merge_library 또는 -merge_framework 옵션으로 최종 출력을 생성합니다.

Xcode는 당신을 위해 이러한 세부 사항을 처리합니다.

그러나, 빌드 로그를 검사할 때 이러한 옵션이 적용되는 것을 볼 수 있습니다.

하지만 그냥 연결하는 것보다 병합하는 것이 어떻게 더 나은가요?

음, 병합 후 크기를 고려해 봅시다.

첫째, 라이브러리와 메타데이터는 필요하지 않으며 병합된 후에 제거할 수 있습니다.

그래서 유일한 초점은 병합된 바이너리의 크기이다.

병합할 때, 링커는 모든 라이브러리에서 문자열과 같은 콘텐츠의 중복을 제거할 수 있다.

예를 들어, 중복 기호 참조, Objective-C 선택기 및 objc_msgsend 스텁을 제거합니다.

이로 인해 전반적인 앱 번들이 더 작아진다.

최종 바이너리의 이미지 유형도 동일하게 유지됩니다.

그것은 이미 지원되는 링커 최적화가 적용될 수 있다는 것을 의미합니다.

이것은 또한 앱 출시에 긍정적인 영향을 미친다.

더 적은 수의 프레임워크가 로드되면, 앱을 시작할 때 해야 할 작업과 커널이 줄어들고, 메모리 사용량을 줄여 사용자를 행복하게 유지합니다.

하지만 우리는 코드를 라이브러리로 분리하는 것이 효과적인 개발과 유지 보수에 필수적이라는 것을 알고 있다.

병합 가능한 라이브러리를 사용하면 둘 다 가질 수 있습니다.

병합 가능한 라이브러리는 최소한의 코드와 구성 변경으로 이것을 가능하게 한다.

그리고 이것은 당신이 새로운 프레임워크를 채택할 때 멋지게 확장됩니다.

동적 연결에 대한 이전 다이어그램을 다시 살펴봅시다.

이러한 모든 임베디드 프레임워크는 링커가 메타데이터를 생성할 수 있기 때문에 병합할 수 있다.

우리는 다른 라이브러리의 내용을 병합하는 프레임워크를 만들 수 있다.

그래서 당신은 하나의 프레임워크만 삽입하게 됩니다.

Dyld는 임베디드 프레임워크의 모든 세그먼트를 포함하는 하나의 라이브러리만 로드하면 됩니다.

이런 식으로 병합은 큰 종속성 체인을 크게 단순화할 수 있다.

그것이 병합 가능한 도서관이 달성할 수 있는 것이다.

그것들을 가능하게 하는 방법에 대해 이야기해 봅시다.

Xcode에서 라이브러리 병합을 활성화하는 두 가지 방법이 있습니다.

나는 가장 간단한 자동 병합으로 시작할 것이다.

그런 다음, 당신이 병합할 수 있어야 하는 것을 통제하고 싶을 때마다 수동 병합에 들어갈 것입니다.

디버그 모드에서 병합 가능한 라이브러리가 어떻게 최적의 빌드 시간을 제공할 수 있는지 설명하겠습니다.

그리고 그 후, 병합 가능한 라이브러리를 디버깅하고 상징화해야 할 때 무엇을 기대해야 하는지 공유하겠습니다.

자동 병합은 빌드 시스템에 임베디드 프레임워크 대상인 모든 직접 종속성을 병합하도록 알립니다.

그것은 앱 타겟에서 특히 유용하다.

내가 보여줄게.

저는 스위프트와 C++ 포레스트 프로젝트를 예로 사용하고 있습니다.

네 개의 프레임워크에 연결되는 앱 타겟이 있다.

Apple SDK에서 나온 SwiftUI가 있습니다.

다른 세 곳, ForestBuilder, ForestUI, Forest는 그 프로젝트에 건설되었다.

자동 병합이 활성화되면, 세 개의 포리스트 프레임워크를 병합할 수 있게 될 것이다.

SwiftUI는 시스템 라이브러리이기 때문에 그대로 남아 있다.

앱을 연결하는 동안, 이 프레임워크는 앱 바이너리에 직접 병합될 것이다.

그것은 이러한 프레임워크가 출시 시 필요하지 않으며 디스크에서 제거할 수 있다는 것을 의미합니다.

Xcode에서 이것을 켜는 방법을 봅시다.

프로젝트 내에서, 저는 이미 Swift와 C++ 앱 대상을 클릭했고 빌드 설정 탭 안에 있습니다.

MERGED_BINARY_TYPE 빌드 설정을 업데이트해야 합니다.

필터 텍스트 상자를 사용하여 검색할 수 있습니다.

"Create Merged Binary"는 정확히 내가 업데이트하고 싶은 것이다.

MERGED_BINARY_TYPE 설정에 매핑된 옵션입니다.

설정을 클릭하고 값을 자동으로 업데이트하겠습니다.

그리고 그게 다야!

병합 가능한 라이브러리 설정은 일반 연결 옵션 아래에 있습니다.

그것들은 "연결 - 병합 가능한 라이브러리"라는 이름의 자체 섹션에 편리하게 표시됩니다.

앱이 라이브러리 병합을 위해 활성화되면, 라이브러리의 세그먼트는 앱 바이너리에 직접 연결됩니다.

이것은 정적 라이브러리와 비슷한 성능을 초래한다.

하지만 병합 가능한 라이브러리의 내보내는 앱에 보존되어 있다.

앱이 기호를 내보내는 것은 종종 적용되지 않으며 크기와 빌드 시간에 부정적인 영향을 미칩니다.

이를 방지하려면, 링커 옵션 -no_exported_symbols를 사용하세요.

이것은 다른 링커 플래그를 "-Wl, -no_exported_symbols"로 업데이트하여 Xcode에 적용할 수 있습니다.

앱에 앱 확장을 위한 진입점이 필요한 경우, 기호를 나열하는 내보내기 목록을 사용하여 이를 엄격하게 제어하십시오.

이것은 내보낸 기호 파일을 사용하여 동일한 일반 연결 옵션으로 설정할 수 있습니다.

이것은 정적 링커가 데드 코드 스트리핑과 같은 크기 최적화에 가장 효과적일 수 있게 해준다.

그것은 자동 병합이었지만, 일부 프레임워크만 함께 병합되어야 할 때가 있을 수 있습니다.

Xcode는 수동 병합을 통해 이를 지원합니다.

수동 병합은 병합할 라이브러리를 지정하는 세밀한 접근 방식이다.

이것은 일부 종속성이 앱 번들에 남아 있어야 할 때 유용합니다.

나는 나중에 고려 사항을 논의할 때 이것을 확장할 것이다.

가장 중요한 대상에서 MERGED_BINARY_TYPE = 수동을 설정하여 활성화됩니다.

최종 병합된 제품을 구성해야 하는 라이브러리는 MERGEABLE_LIBRARY를 YES로 설정하여 인식됩니다.

그리고 디스크에 남아 있어야 하는 라이브러리의 경우, MERGEABLE_LIBRARY의 기본 설정을 NO로 유지하세요.

Swift와 C++ Forest 프로젝트로 돌아가서 시연해 봅시다.

우리는 자동 병합과 관련된 변경 없이 새롭게 시작하고 있습니다.

여전히 앱 대상과 그것이 연결하는 네 개의 프레임워크가 있다.

하지만 지금은 시험도 고려하고 있어.

프로젝트에는 XCTest 목표와 지원 프레임워크가 있습니다.

테스트는 또한 숲 프레임워크에 의존한다.

프로젝트의 프레임워크 사이에서, 종속성은 모두 얽혀 있다.

이 예에서는 XCTest 대상이 있지만, 프로젝트에서 비슷한 모양의 종속성 그래프를 만드는 앱 확장과 같은 대상이 있을 수 있습니다.

병합 가능한 라이브러리를 활용하기 위해, 나는 세 개의 포리스트 프레임워크에 대한 앱 종속성을 분리할 것이다.

앱에 필요한 라이브러리를 병합하지만 테스트 의존성을 만족시키는 프레임워크인 ForestKit을 만들 것입니다.

ForestKit은 내 앱과 테스트 모두에 의존하는 병합 가능한 라이브러리를 캡슐화하기 때문에 그룹 라이브러리로 간주됩니다.

수동 모드를 활성화할 때, 어떤 프레임워크를 병합할 수 있는지 명시적으로 설정할 것입니다.

이 경우, 그것은 ForestBuilder, ForestUI, 그리고 Forest이다.

이러한 종속성은 ForestKit에 병합될 것이다.

라이브러리를 로드하는 것을 줄임으로써, 내 앱은 출시 시간과 번들 크기가 개선되었다.

Xcode에서 이것을 켜 봅시다.

프로젝트를 다시 시작하고 자동 병합에 사용되는 모든 설정을 제거했습니다.

나는 다른 프레임워크를 병합할 프레임워크 목표를 만드는 것으로 시작할 것이다.

이건 내 그룹 도서관, ForestKit이야.

타겟 섹션 하단을 클릭하여 이것을 할 수 있습니다.

저는 템플릿 팝업의 macOS 탭에 있으며, 필터 텍스트 상자를 사용하여 프레임워크 템플릿을 찾을 수 있습니다.

제품 이름을 ForestKit으로 설정하고 Finish를 클릭할 것입니다.

이 프레임워크에서, 저는 포레스트 테스트 지원 프레임워크를 제외한 모든 라이브러리를 병합하고 싶습니다.

하지만 내 의존성이 얽혀 있기 때문에, 나는 당분간 그들 모두에 대해 연결할 것이다.

이를 위해, 나는 더하기 기호를 사용하여 프레임워크를 추가하기 위해 "링크 바이너리와 라이브러리" 빌드 단계를 업데이트할 것이다.

라이브러리 팝업이 나타나면, 포레스트 프레임워크를 클릭하고 SHIFT와 DOWN을 눌러 Xcode 프로젝트의 다른 프레임워크를 강조할 것입니다.

다음으로, 이 대상에서 수동 병합을 활성화해야 합니다.

빌드 설정 탭으로 가서 "병합된 바이너리 만들기"를 다시 찾아 이것을 할 것입니다.

필터 텍스트 상자를 사용하고 "MERGE"를 입력하겠습니다.

이번에는 매뉴얼을 값으로 선택할 것이다.

그게 내가 그룹 도서관 목표를 설정하는 데 필요한 전부야.

각 프레임워크 대상의 빌드 설정으로 이동하여 병합할 라이브러리를 선택할 수 있습니다.

목표 섹션을 탐색하면서, 나는 숲 프레임워크부터 시작할 것이다.

저는 빌드 설정 탭에 있으며 병합 가능한 라이브러리 빌드를 클릭할 수 있습니다.

이 옵션은 빌드 설정 MERGEABLE_LIBRARY에 매핑되며, 이 값을 예로 업데이트하겠습니다.

나는 ForestUI와 Forest Builder를 위해 똑같이 해야 한다.

저는 병합된 ForestKit 프레임워크를 만드는 것을 마쳤습니다.

하지만 나는 몇 가지 종속성을 업데이트해야 해.

대부분의 동적 라이브러리를 캡슐화하는 프레임워크를 만들었기 때문에, 다른 라이브러리가 아닌 ForestKit에 대한 앱과 테스트 링크를 확인해야 합니다.

스위프트와 C++ 앱 타겟을 클릭하여 먼저 앱을 고칠 것입니다.

나는 빌드 단계 탭으로 돌아가서 "라이브러리와 바이너리 연결"으로 내려갈 것이다.

여기서 불필요한 프레임워크를 제거할 것이다.

Forest를 선택하고 SHIFT와 UP을 눌러 ForestUI와 ForestBuilder를 수집하여 삭제합니다.

마지막 단계는 시험이다.

XCTest 대상을 클릭하고 "라이브러리와 바이너리 연결" 아래의 빌드 단계 탭으로 이동합니다.

표의 이름을 클릭하고 삭제하여 포레스트 프레임워크를 제거할 것입니다.

그런 다음 더하기 기호를 사용하여 ForestKit을 추가할 것입니다.

팝업이 나타나면, ForestKit을 두 번 클릭하겠습니다.

그리고 이것이 수동 병합을 구성하는 방법입니다.

스위프트와 C++ 포레스트 프로젝트를 위해, 저는 릴리스 모드에서 일하고 있습니다.

이것은 라이브러리가 병합된 다음 디스크에서 제거될 때이다.

그러나, 정적 라이브러리의 빌드 시간 동작과 유사하게, 개발에 비용이 많이 들 수 있는 병합에 대한 빌드 시간 오버헤드가 있다.

Xcode에서 반복 개발을 지원하기 위해, 링커는 디버그 모드에서 병합되지 않습니다.

빌드 시스템은 링커에게 대신 라이브러리를 다시 내보내라고 말한다.

재내보내기는 코드 구현이 하나의 동적 라이브러리에 있을 수 있지만 다른 라이브러리에서 구현된 것처럼 표시되는 링커 옵션입니다.

즉, 이것은 앱 확장이나 테스트와 같이 병합된 대상에 따라 모든 라이브러리의 API에 연결할 수 있다는 것을 의미합니다.

이것은 동적 라이브러리와 비슷한 빌드 시간 이점을 초래한다.

출시 시, dyld는 병합된 바이너리에서 직접 올 것으로 예상하는 대신 재수출된 라이브러리에 대한 참조를 리디렉션합니다.

그것은 디버그의 경우 병합 가능한 라이브러리가 디스크에 남아 있다는 것을 의미한다.

디버깅에 대해 말하자면, 병합 가능한 라이브러리에 있을 수 있는 기호를 살펴봅시다.

나는 정수를 받아들이고 제곱 결과를 반환하는 함수를 가지고 있다.

이것은 구축되는 코드입니다.

그러나, 우리는 이것이 기계가 실행하는 코드가 아니라는 것을 알고 있다.

대신, 이 코드는 많은 변화를 거친다.

우리가 그 코드에서 버그를 조사해야 할 때까지 이것은 모두 괜찮습니다.

이것이 Xcode가 상징을 지원하는 이유이다.

상징화는 이러한 기계 지침을 원래 소스 코드와 다시 연관시키는 과정이다.

이것은 충돌 로그를 이해하거나 코드를 프로파일링하고 디버깅하는 데 유용합니다.

이것은 병합된 바이너리에서 어떻게 작동하나요?

병합을 활성화하면, 소스 위치 정보는 여전히 원본 라이브러리에서 보존됩니다.

그것은 당신의 디버깅 경험이 동일하게 유지된다는 것을 의미합니다.

하지만 스택 추적과 같이 라이브러리 정보가 표시되면 병합된 바이너리의 경로를 보여줄 것이라는 점을 명심하세요.

이 정보는 충돌 로그, 인스트루먼트 내부 및 디버거에 표시됩니다.

당신의 프로젝트가 병합 가능한 라이브러리를 어떻게 채택할 수 있는지 고려해야 할 때입니다.

많은 경우, 그것들을 활성화하려면 몇 가지 Xcode 설정이 필요합니다.

하지만 주목할 만한 몇 가지 요인들이 있다.

나는 생각해야 할 중요한 다섯 가지 주제를 다룰 것이다.

병합 가능한 라이브러리에 대한 기존 종속성을 어떻게 처리해야 하는지부터 시작하겠습니다.

그런 다음, 자동 링크가 무엇이며 병합 가능한 라이브러리에서 어떻게 작동하는지에 대해 알아볼 것입니다.

그리고 dlopen이나 번들 인터페이스와 같은 런타임 조회 API를 사용하면 몇 가지 제한이 있습니다.

병합은 Xcode 15의 정적 링커에 의해 구동되기 때문에, 나는 그것과 이전 버전 사이의 중요한 차이점을 언급할 것이다.

그리고 마지막 고려 사항은 프레임워크를 다른 개발자들에게 배송하는 데 관심이 있는 사람들을 위한 것이다.

라이브러리 의존성을 위해, 딜드의 작업을 보여주는 다이어그램으로 돌아가자.

병합되지 않은 병합 가능한 라이브러리의 종속성이 있는 경우 - 예를 들어, 다른 실행 파일 - 병합 가능한 라이브러리가 디스크에서 제거되기 때문에 병합된 프레임워크에 의존하도록 업데이트해야 합니다.

이것이 나올 수 있는 또 다른 방법은 앱이 자동 연결에 의존할 때이다.

자동 연결은 기본적으로 켜져 있는 컴파일러 옵션입니다.

컴파일러가 소스 코드에서 모듈 가져오기를 찾으면, 프레임워크 종속성을 감지하여 링커로 전달합니다.

따라서 병합 가능한 라이브러리에서 모듈을 가져오는 경우, 동적 연결 문제가 발생할 수 있습니다.

하지만, 자동 연결을 비활성화할 필요는 없습니다.

여기서의 해결책은 이전과 동일합니다: 병합된 프레임워크에 대한 링크.

이를 수행하는 가장 일반적인 방법은 "리 라이브러리와 바이너리 연결" 빌드 단계에 병합된 프레임워크를 추가하고 이미 있다면 병합 가능한 프레임워크를 제거하는 것입니다.

그렇지 않으면, dyld는 당신의 앱에 적합한 프레임워크를 로드할 수 없을 것입니다.

대부분의 개발자들은 dlopen과 같은 동적 연결 API를 사용할 필요가 없습니다.

하지만 그렇게 한다면, 그 입력 경로는 병합된 프레임워크 목표를 가리켜야 할 것이다.

마찬가지로, 리소스 조회는 라이브러리 병합의 영향을 받을 수 있다.

이것은 런타임이 기대하는 것 때문이다.

스위프트에서 번들은 런타임이 프레임워크의 번들을 로드하는 API이다.

Objective-C의 동등한 API는 NSBundle의 bundleForClass이다.

이러한 API는 번들의 구조를 고려하지 않고도 프레임워크의 리소스로 작업하는 데 사용됩니다.

iOS 12까지 런타임은 번들을 발견하기 위해 프레임워크의 바이너리가 필요했지만, 병합 가능한 프레임워크는 프로세스가 실행될 때까지 바이너리가 없을 것이다.

좋은 소식이야!

iOS 12에서, 이 시나리오에 대한 조회를 가능하게 하기 위해 훅이 추가되었습니다.

즉, 번들 조회 지원에 의존하는 경우, 병합 가능한 라이브러리를 사용하려면 최소 배포 버전을 iOS 12 이상으로 업데이트해야 합니다.

하지만 이러한 API에 의존하지 않는다면, 새로운 링커 옵션 -no_merged_libraries_hook으로 이 지원을 비활성화할 수 있습니다.

그러면 앱의 배포 버전을 업데이트할 필요가 없습니다.

번들 리소스를 포함하지 않는 프레임워크를 병합하는 경우, 번들 훅이 필요하지 않을 수도 있습니다.

만약 그렇다면, 당신은 어쨌든 출시 시간 성능을 개선하기 위해 이 옵션을 추가하는 것을 고려해야 합니다.

이 강연을 통해, 나는 몇 가지 새로운 링커 옵션을 언급했다.

이 옵션들은 새로 구현된 링커에서만 작동합니다.

하지만 툴체인 내부를 들여다보면, 두 개의 정적 링커가 있다는 것을 알 수 있습니다.

구형 링커는 여전히 이전 버전과의 호환성을 위해 지원됩니다.

특히, 그 링커는 여전히 armv7k를 위해 만들 수 있지만, 새로운 링커는 그렇지 않다.

Armv7k 아키텍처를 지원하는 마지막 플랫폼은 watchOS 8이었다.

watchOS 8 또는 이전 버전에 배포할 필요가 없다면, 새로운 링커를 사용하려면 배포 버전을 watchOS 9로 업그레이드하십시오.

앱에서 병합 가능한 라이브러리를 구축하고 사용하는 방법을 설명했지만, 다른 사람들이 사용할 수 있도록 병합 가능한 라이브러리를 배송하려면 어떻게 해야 하나요?

Swift Package Manager 또는 Xcode에서 XCFramework를 만들어 이를 수행할 수 있습니다.

이를 통해 배포를 위한 메타데이터를 포함한 프레임워크를 구축할 수 있습니다.

다른 개발자들이 프레임워크를 사용할 때, 그들은 병합을 활성화할지 여부를 결정할 수 있다.

병합 가능한 메타데이터는 딜립의 크기를 대략 두 배로 늘린다.

앱을 빌드한 후 메타데이터가 병합 가능한 라이브러리와 함께 삭제되기 때문에 이것은 앱의 크기에 영향을 미치지 않습니다.

그렇지 않으면, 그 메타데이터는 앱에 포함할 때 부풀어 오르는 것을 방지하기 위해 제거된다.

나는 병합 가능한 라이브러리에 대한 몇 가지 뉘앙스를 설명했다.

이제 나는 우리의 추천을 공유할 것이다.

병합된 바이너리에 대한 종속성을 설정하는 것은 원활한 채택의 핵심이다.

이것은 모든 링크 종속성에 필요하다.

스크립트 단계에서 바이너리를 기대하는 도구에 라이브러리를 공급하는 경우 특히 중요합니다.

정적 링커는 직접적인 종속성만 병합한다.

따라서, 더 많은 병합 가능한 라이브러리를 포함하려면, 명시적인 링크 종속성으로 설정해야 합니다.

병합 설정은 Xcode 빌드 시스템에 디스크에서 프레임워크의 바이너리를 제거하도록 지시합니다.

이것은 의도적이지 않다면 부작용을 일으킬 것이므로, Xcode 목표 수준에서 활성화하는 것이 좋습니다.

그리고 마지막으로, 성능을 최적화하면서 생산성에서 가장 큰 이점을 얻으려면, 동적으로 병합할 수 있는 정적 라이브러리를 업데이트하는 것을 고려하십시오.

병합 가능한 도서관은 편리함과 유연성을 제공한다.

자동 및 수동 워크플로우 사이에서, 여가 시간에 병합 가능한 라이브러리를 재구성하고 추가하고 필요한 라이브러리를 디스크에 남길 수 있습니다.

이 유연성은 점진적으로 채택하거나 프로파일링할 때 도움이 된다.

병합 가능한 라이브러리는 프레임워크 및 실행 대상에 적용될 때 크기, 빌드 및 런타임 개선을 제공합니다.

자동 구성을 사용하여 빌드 시스템이 모든 직접 프레임워크 종속성을 병합하도록 할 수 있습니다.

하지만 병합할 종속성을 선택하고 선택해야 할 때, 이것은 수동 모드로 수행할 수 있습니다.

그리고 마지막으로, 병합 가능한 라이브러리를 사용하도록 프로젝트를 업데이트할 때, 해당 라이브러리의 모든 종속성이 제거되는 라이브러리 대신 병합된 바이너리에 의존하고 있는지 확인하십시오.

병합 가능한 라이브러리에 대한 문서는 "병합 가능한 라이브러리를 사용하도록 프로젝트 구성"을 검토하십시오.

그리고 정적 및 동적 연결에 대해 자세히 알아보려면, "빠른 링크: 빌드 및 실행 시간 개선" 세션을 확인하세요.

우리는 당신의 프로젝트에서 병합 가능한 라이브러리가 어떻게 사용될지 알게 되어 기쁩니다.

나와 함께 해줘서 고마워.