10167

♪ ♪

베카: 안녕하세요, 저는 스위프트 팀의 베카입니다.

오늘 우리는 당신의 필요에 따라 스위프트 언어를 사용자 정의할 수 있는 흥미진진한 새로운 기능인 스위프트 매크로에 대해 이야기할 것입니다.

우리는 매크로가 무엇을 위한 것인지에 대해 이야기하는 것으로 시작할 것이다.

그런 다음, 우리는 스위프트 매크로를 설계할 때 명심했던 몇 가지 원칙에 대해 이야기할 것입니다.

그런 다음 스위프트 매크로의 작동 방식과 프로젝트의 다른 코드와 상호 작용할 수 있는 구체적인 방법을 다룰 것입니다.

그 후, 우리는 매크로를 구현하는 방법에 대해 이야기하고 매크로가 올바르게 작동하는지 확인하는 방법을 논의하여 마무리할 것입니다.

그래서 스위프트가 매크로를 지원하는 이유에 대해 이야기하는 것으로 시작합시다.

스위프트는 사용자가 표현적인 코드와 API를 작성하도록 하는 것을 좋아한다.

그것이 사용자가 반복적인 상용구를 작성하는 것을 피하는 데 도움이 되는 파생된 적합성 및 결과 빌더와 같은 기능을 제공하는 이유입니다.

이 기능들은 모두 기본적으로 같은 방식으로 작동한다.

예를 들어, 구성원에 대한 구현을 제공하지 않고 Codable을 준수할 때, Swift는 프로그램에 삽입하는 일련의 구성원으로 적합성을 자동으로 확장합니다.

나는 회색 상자에서 적합성에 대한 확장을 보여주었다.

이 코드를 만들면 어떻게 작동하는지 정확히 알 필요 없이 Codable을 사용할 수 있으므로 Codable 지원을 추가하는 것이 화면으로 가득 찬 코드를 작성할 가치가 있는지 결정할 필요가 없습니다.

스위프트는 이런 식으로 작동하는 많은 기능을 가지고 있다.

간단한 구문을 작성하고, 컴파일러는 자동으로 더 복잡한 코드로 확장합니다.

하지만 기존 기능이 당신이 원하는 것을 할 수 없다면 어떨까요?

음, 오픈 소스이기 때문에 스위프트 컴파일러에 기능을 추가할 수 있습니다.

하지만 그것은 말 그대로 개인적으로 화상 회의에 참여하고 다른 스위프트 프로젝트 리더들과 당신의 기능에 대해 논의하는 것과 관련이 있으므로, 그것은 정확히 확장되는 과정이 아닙니다.

그것이 우리가 매크로를 도입하는 이유이다.

컴파일러를 수정하지 않고도 Swift 패키지로 배포할 수 있는 방식으로 지루함과 상용구를 제거하여 Swift에 자신만의 언어 기능을 Swift에 추가할 수 있습니다.

여러분 중 몇몇은 다른 언어로 매크로를 사용하지 않았습니다.

하지만 당신이 가지고 있다면, 당신은 그들에 대해 엇갈린 감정을 가질 수 있습니다.

그것은 부분적으로 많은 Swift 개발자들이 Objective-C 또는 C 전처리기를 사용하는 다른 언어에 익숙하고 C 매크로의 한계와 함정에 대해 알고 있기 때문이다.

하지만 스위프트 매크로는 많은 문제를 피하는 면에서 매우 다르다.

우리는 네 가지 목표를 염두에 두고 그것들을 설계했다.

첫 번째 목표는 매크로를 사용할 때 꽤 분명해야 한다는 것이다.

두 종류의 매크로가 있습니다: 독립형 매크로는 코드의 다른 것을 대신합니다.

그들은 항상 파운드(#) 기호로 시작한다.

그리고 첨부된 매크로는 코드의 선언에 대한 속성으로 사용됩니다.

그들은 항상 (@) 기호로 시작한다.

스위프트는 이미 특별한 컴파일러 동작을 나타내기 위해 파운드 (#)와 (@) 기호를 사용한다.

매크로는 그것을 확장 가능하게 만든다.

그리고 #이나 @가 보이지 않는다면, 관련된 매크로가 없다는 것을 확신할 수 있습니다.

두 번째 목표는 매크로로 전달된 코드와 다시 전송된 코드가 모두 완료되고 실수가 있는지 확인해야 한다는 것이다.

인수는 완전한 표현식이어야 하기 때문에 매크로에 "1 +"를 전달할 수 없습니다.

매크로 인수와 결과가 함수 인수와 마찬가지로 유형 검사되기 때문에 잘못된 유형으로 인수를 전달할 수 없습니다.

그리고 매크로의 구현은 입력을 검증하고 무언가 잘못되면 컴파일러 경고나 오류를 방출할 수 있으므로 매크로를 올바르게 사용하고 있는지 확인하는 것이 더 쉽습니다.

세 번째 목표는 매크로 확장이 예측 가능하고 부가적인 방식으로 프로그램에 통합되어야 한다는 것이다.

매크로는 프로그램에서 보이는 코드에만 추가할 수 있습니다.

그것은 그것을 제거하거나 바꿀 수 없다.

따라서 "someUnknownMacro"가 무엇을 하는지 전혀 모르더라도, "finishDoingThingy"에 대한 호출을 삭제하거나 새로운 기능으로 옮기지 않는다는 것을 확신할 수 있습니다.

그것은 매크로를 사용하는 코드를 훨씬 쉽게 읽을 수 있게 해준다.

그리고 최종 목표는 매크로가 꿰뚫을 수 없는 마법이 되어서는 안 된다는 것이다.

매크로는 프로그램에 더 많은 코드를 추가하기만 하면 Xcode에서 바로 볼 수 있습니다.

매크로의 사용 사이트를 마우스 오른쪽 버튼으로 클릭하고 무엇이 확장되는지 물어볼 수 있습니다.

확장에서 중단점을 설정하거나 디버거로 들어갈 수 있습니다.

매크로 확장 내부의 코드가 컴파일되지 않으면, 확장에서 오류가 어디에 있는지, 그리고 그 확장이 소스 코드에서 어디로 가는지 둘 다 볼 수 있습니다.

그리고 이 모든 도구는 매크로가 폐쇄 소스 라이브러리에 의해 제공되더라도 작동합니다.

매크로 저자는 예상대로 작동하는지 확인하기 위해 매크로에 대한 단위 테스트를 작성할 수도 있습니다. 우리는 그들이 하는 것을 강력히 권장합니다.

우리는 이러한 목표가 개발자들이 Swift 매크로를 쉽게 이해하고 유지할 수 있게 해준다고 생각합니다.

이제 우리는 스위프트 매크로가 무엇을 달성하려고 하는지 이해했으니, 그들이 어떻게 하는지에 대해 이야기해 봅시다.

세부 사항에서 길을 잃기 전에, 기본 개념을 내려놓자.

Swift가 Xcode 매크로 패키지 템플릿의 "stringify" 매크로와 같은 코드에서 매크로를 호출하는 것을 볼 때, 코드에서 사용하는 매크로를 추출하여 해당 매크로의 구현을 포함하는 특수 컴파일러 플러그인으로 보냅니다.

플러그인은 보안 샌드박스에서 별도의 프로세스로 실행되며, 매크로 작성자가 작성한 사용자 지정 스위프트 코드가 포함되어 있습니다.

그것은 매크로 사용을 처리하고 매크로에 의해 생성된 새로운 코드 조각인 "확장"을 반환합니다.

그런 다음 스위프트 컴파일러는 그 확장을 프로그램에 추가하고 코드와 확장을 함께 컴파일합니다.

그래서 프로그램을 실행할 때, 매크로를 호출하는 대신 확장을 직접 작성한 것처럼 작동합니다.

이제, 내가 여기서 간과한 중요한 점이 있다.

스위프트는 "스트링화" 매크로가 존재한다는 것을 어떻게 알았나요?

그리고 답은, 그것은 매크로 선언에서 나온다는 것이다.

매크로 선언은 매크로를 위한 API를 제공한다.

자신의 모듈에서 바로 선언을 작성하거나, 라이브러리나 프레임워크에서 가져올 수 있습니다.

매크로의 이름과 서명, 매개 변수 수, 레이블 및 유형, 매크로에 하나 있는 경우 결과 유형을 함수 선언과 같이 지정합니다.

그리고 그것은 또한 매크로의 역할을 지정하는 하나 이상의 속성을 가지고 있다.

매크로의 역할이 무엇인지 생각하지 않고 매크로를 쓰는 것은 불가능하다.

그래서 역할이 무엇인지, 그리고 어떻게 다른 역할을 사용하여 다른 종류의 매크로를 작성할 수 있는지에 대해 이야기해 봅시다.

역할은 매크로에 대한 일련의 규칙이다.

그것은 매크로를 적용하는 장소와 방법, 어떤 종류의 코드로 확장되는지, 그리고 그 확장이 코드에 삽입되는 위치를 제어합니다.

궁극적으로, 예측 가능하고 부가적인 방식으로 확장을 삽입하는 우리의 목표를 달성하는 것은 매크로 역할이다.

독립형 매크로를 만드는 두 가지 역할이 있다: 표현과 선언.

그리고 첨부된 매크로를 만드는 다섯 가지 역할이 있습니다: 피어, 접근자, 멤버 속성, 멤버 및 적합성.

이 역할들과 당신이 그것들을 언제 사용할 수 있을지 살펴봅시다.

우리는 "독립적인 표현" 역할로 시작할 것이다.

"표현"이라는 용어가 종을 울리지 않는다면, 표현은 우리가 실행하고 결과를 생성하는 코드 단위라고 부르는 것이다.

이 "let" 문에서, 등호 뒤의 산술은 표현이다.

하지만 표현은 재귀 구조를 가지고 있다-- 그들은 종종 더 작은 표현으로 구성되어 있다.

그래서 "x + 너비"만으로도 표현이다.

그리고 "폭"이라는 단어도 마찬가지야.

"독립형 표현식" 매크로는 표현식으로 확장되는 매크로이다.

당신은 하나를 어떻게 사용할 건가요?

옵션을 강제로 풀 필요가 있다고 상상해 보세요.

스위프트는 포스 언랩 오퍼레이터를 제공하지만, 일부 팀은 안전에 대해 생각하지 않고 포스 언랩을 던지는 것이 너무 쉽다고 느끼기 때문에, 그들의 스타일 가이드는 개발자들에게 값이 절대 0이 되어서는 안 되는 이유를 나타내는 더 복잡한 것을 작성하라고 말한다.

하지만 "guard let"를 사용하고 "else" 지점에서 "preconditionFailure"라고 부르는 것과 같은 이러한 대안의 대부분은 너무 많은 의식이다.

이러한 극단 사이에서 더 나은 균형을 이루는 매크로를 설계해 봅시다.

우리는 이 매크로가 값을 계산하고 반환하기를 원하기 때문에, 우리는 그것을 "독립형(표현식)" 매크로로 만든다.

우리는 "unwrap"이라는 이름과 전달된 값이 선택 사항인 일반 유형을 제공하지만, 반환된 값은 선택 사항이 아닙니다.

그리고 우리는 또한 언랩이 실패하면 인쇄된 메시지의 일부인 문자열을 전달합니다.

그래서 우리는 함수처럼 부르는 매크로로 끝나지만, 그것은 클로저에 싸인 "guard let"를 포함하는 표현으로 확장된다.

오류 메시지에는 일반 기능으로는 불가능한 변수 이름도 포함되어 있습니다.

이제 독립형 표현 역할을 보았으니, 독립형 선언 역할을 살펴봅시다.

그것은 함수, 변수 또는 유형과 같은 하나 이상의 선언으로 확장된다.

당신은 그것을 무엇을 위해 사용할 수 있나요?

2D 배열 유형이 필요한 일종의 통계 분석을 작성하고 있다고 상상해 보세요.

당신은 배열의 모든 행이 같은 수의 열을 갖기를 원하므로, 배열 배열을 원하지 않습니다.

대신, 요소를 평평한 1차원 배열에 저장한 다음, 개발자가 전달한 2차원 인덱스에서 1차원 인덱스를 계산하고 싶습니다.

그렇게 하기 위해, 당신은 이와 같은 유형을 쓸 수 있습니다.

"makeIndex" 함수는 2D 인덱스에 필요한 두 개의 정수를 가져간 다음, 그것들을 1D 인덱스로 바꾸기 위해 약간의 산술을 한다.

하지만 프로그램의 다른 부분에서는 3차원 배열이 필요하다는 것을 알게 됩니다.

그것은 2D 배열과 거의 정확히 같다.

몇 가지 인덱스가 더 있고, 계산은 조금 더 복잡하다.

그런 다음 4D 어레이와 5D 어레이가 필요하며, 곧 거의 동일하지만 제네릭, 프로토콜 확장, 하위 클래스 또는 스위프트가 이러한 종류의 것을 위해 제공하는 다른 기능을 사용할 수 있을 만큼 가깝지 않은 배열 유형으로 수영할 것입니다.

다행히도, 이 구조체들 각각은 선언이므로, 우리는 선언 매크로를 사용하여 그것들을 만들 수 있다.

N차원 배열 유형을 만들 것이기 때문에 "makeArrayND"라는 이름의 독립형 선언 매크로를 선언합시다.

우리는 차원 수를 Int 매개 변수로 전달할 것이며, 이 매크로는 다른 코드에서 사용되는 결과를 계산하는 것이 아니라 프로그램에 선언을 추가하기 때문에 결과 유형을 선언하지 않을 것입니다.

이제 우리는 2차원, 3차원, 4차원, 5차원으로 매크로를 네 번 호출할 수 있으며, 각 호출은 올바른 수의 인수와 그 크기에 대한 올바른 계산으로 전체 다차원 배열 유형으로 확장될 것이다.

지금까지, 우리는 독립형 매크로만 보았다.

이제 첨부된 매크로의 역할로 넘어가자.

첨부된 매크로는 이름에서 알 수 있듯이 특정 선언에 첨부되어 있습니다.

그것은 그들이 일할 더 많은 정보를 가지고 있다는 것을 의미한다.

독립형 매크로는 전달된 인수만 주어지지만, 첨부된 매크로는 첨부된 선언에 액세스할 수도 있습니다.

그들은 종종 그 선언을 검사하고 내부에서 이름, 유형 및 기타 정보를 꺼낸다.

우리는 첨부된 동료 역할로 시작할 것이다.

피어 매크로는 변수, 함수, 유형뿐만 아니라 가져오기 및 연산자 선언과 같은 모든 선언에 첨부할 수 있으며, 그 옆에 새로운 선언을 삽입할 수 있습니다.

따라서 메서드나 속성에서 사용하면 유형의 멤버를 생성하게 되지만, 최상위 함수나 유형에서 사용하면 새로운 최상위 선언을 생성하게 됩니다.

그것은 그들을 엄청나게 유연하게 만든다.

여기 당신이 그것들을 사용할 수 있는 한 가지 방법이 있습니다.

스위프트 동시성을 사용하는 라이브러리를 작성하고 있지만, 일부 클라이언트가 여전히 오래된 동시성 기술을 사용하고 있다는 것을 알고 있으므로, 완료 핸들러를 사용하는 API 버전을 제공하고자 한다고 가정해 봅시다.

이 방법들을 쓰는 것은 어렵지 않다.

"비동기" 키워드를 제거하고, 완료 핸들러 매개 변수를 추가하고, 결과 유형을 매개 변수 목록으로 이동하고, 분리된 작업에서 비동기 버전을 호출하기만 하면 됩니다.

하지만 당신은 이것을 많이 하고 있고, 손으로 쓰고 싶지 않습니다.

그것은 첨부된 동료 매크로에게 훌륭한 일이다.

우리는 "AddCompletionHandler"라는 것을 선언하고 완료 핸들러의 인수 라벨에 대한 매개 변수를 부여한 다음, 그 매크로를 메서드의 비동기 버전에 첨부할 것입니다.

매크로는 원본과 동등한 완료 핸들러 기반 서명을 만들고, 메소드 본문을 작성하고, 완료 핸들러에 대한 추가 텍스트와 함께 문서 주석을 첨부합니다.

꽤 멋져.

다음으로, 첨부된 접근자 역할을 살펴봅시다.

이것들은 변수와 첨자에 첨부될 수 있으며, "get", "set", "willSet" 또는 "didSet"과 같은 접근자를 설치할 수 있습니다.

그래서 그게 어떻게 유용할 수 있을까?

기본적으로 사전을 감싸고 속성으로 콘텐츠에 액세스할 수 있는 많은 유형이 있다고 가정해 봅시다.

예를 들어, 이 "Person" 구조체는 "name", "height" 및 "birth_date" 필드에 액세스할 수 있지만, 그 세 가지 필드 외에 사전에 다른 정보가 있다면, 그것은 당신의 프로그램에 의해 보존되고 무시될 것입니다.

이 세 가지 속성은 계산된 게터와 세터가 필요하지만, 손으로 작성하는 것은 지루하며, 속성 래퍼가 사용되는 유형의 다른 저장된 속성에 액세스할 수 없기 때문에 속성 래퍼를 사용할 수 없습니다.

그래서 이것에 도움이 될 수 있는 첨부된 접근자 매크로를 작성해 봅시다.

우리는 그것을 "DictionaryStorage"라고 부를 것이다.

사전이 밑줄로 "birth_date"를 철자하기 때문에 "key" 매개 변수를 줄 것이지만, 키를 빼면 기본값은 nil이 되어 매크로가 속성의 이름을 키로 사용할 수 있습니다.

그래서 이제, 그 큰 접근자 블록을 쓰는 대신, 각 속성 앞에 "@DictionaryStorage"를 넣으면 매크로가 당신을 위해 접근자를 생성할 것입니다.

그것은 좋은 개선이지만, 여기에 여전히 몇 가지 상용구가 있습니다: 동일한 "DictionaryStorage" 속성.

그것들은 더 적은 상용구이지만, 여전히 상용구이다.

일부 내장 속성을 사용하면 전체 유형이나 확장에 적용하여 이러한 종류의 상황을 처리할 수 있습니다.

"첨부된 멤버 속성" 역할은 매크로도 그렇게 작동하게 할 수 있습니다.

매크로는 유형이나 확장에 첨부되며, 첨부된 모든 구성원에 속성을 추가할 수 있습니다.

그게 어떻게 되는지 보자.

우리는 여기서 조금 다른 것을 할 거야.

새로운 매크로를 선언하는 대신, 우리는 이미 가지고 있는 "첨부된 접근자" 역할과 함께 "DictionaryStorage" 매크로에 또 다른 역할 속성을 추가할 것입니다.

이것은 매크로를 만드는 데 정말 유용한 기술이다.

스위프트가 어느 것을 사용해야 할지 모르는 곳이 있기 때문에 두 개의 독립형 역할을 제외한 모든 역할 조합을 구성할 수 있습니다.

스위프트는 당신이 어디에 적용하든 의미가 있는 모든 역할을 확장할 것이지만, 적어도 역할 중 하나는 그곳에서 일해야 합니다.

따라서 유형에 "DictionaryStorage"를 첨부하면, Swift는 "회원 속성" 역할을 확장할 것입니다.

속성에 첨부하면, 스위프트는 "액세서" 역할을 확장할 것이다.

하지만 함수에 연결하면 "DictionaryStorage"에는 함수에 연결할 수 있는 역할이 없기 때문에 컴파일 오류가 발생합니다.

이 두 번째 역할을 "DictionaryStorage"에 추가하면 모든 속성에 별도로 첨부하는 대신 전체 유형에 첨부할 수 있습니다.

매크로는 이니셜라이저, "dictionary" 속성 및 이미 "DictionaryStorage" 속성이 있는 "birth_date"와 같은 속성과 같은 특정 구성원을 건너뛰는 논리를 가질 것이다.

하지만 그것은 다른 저장된 속성에 "DictionaryStorage" 속성을 추가할 것이고, 그 속성들은 우리가 이미 본 접근자로 확장될 것이다.

그것은 좋은 개선이지만, 우리가 제거할 수 있는 더 많은 상용구가 있습니다: 이니셜라이저와 저장된 속성.

이것들은 "DictionaryRepresentable" 프로토콜에 의해 요구되며, 속성은 접근자에 의해 사용되지만, DictionaryStorage를 사용하는 모든 유형에서 정확히 동일합니다.

DictionaryStorage 매크로가 자동으로 추가되도록 합시다. 그래서 우리는 그것들을 손으로 쓸 필요가 없습니다.

우리는 "부속 멤버" 역할을 사용하여 그것을 할 수 있다.

멤버 속성 매크로와 마찬가지로, 이러한 매크로를 유형과 확장에 적용할 수 있지만, 기존 멤버에 속성을 추가하는 대신 완전히 새로운 멤버를 추가합니다.

따라서 메소드, 속성, 이니셜라이저 등 추가할 수 있습니다.

클래스와 구조체에 저장된 속성을 추가하거나 열거형에 케이스를 추가할 수도 있습니다.

다시 한번, 우리는 DictionaryStorage 매크로에 새로운 "첨부된 멤버" 역할을 추가하고, 다른 두 가지와 함께 구성할 것입니다.

이 새로운 역할은 이니셜라이저와 "사전"이라는 속성을 추가할 것이다.

두 개의 다른 매크로가 같은 코드에 적용될 때, 어느 것이 먼저 확장되는지 궁금할 것입니다.

그렇다면 대답은, 그것은 별로 중요하지 않다는 것이다.

각각은 다른 사람들이 제공한 확장 없이 선언의 원본 버전을 보게 될 것이다.

그래서 당신은 주문에 대해 걱정할 필요가 없습니다.

컴파일러가 매크로를 확장하더라도 같은 것을 보게 될 것입니다.

첨부된 멤버 역할이 추가되면서, 우리는 더 이상 그 두 멤버를 쓸 필요조차 없다.

유형에 DictionaryStorage를 사용하면 자동으로 추가됩니다.

그리고 나서 다른 역할은 속성에 DictionaryStorage 속성을 추가할 것이며, 그 속성은 접근자로 확장될 것이다.

하지만 여전히 제거해야 할 마지막 상용구가 있습니다: DictionaryRepresentable 프로토콜에 대한 적합성.

"첨부된 적합성" 역할은 이것에 완벽하다.

그것은 유형이나 확장에 적합성을 추가할 수 있다.

우리는 "DictionaryStorage" 매크로에 마지막 "첨부된 적합성" 역할을 추가하고, 다른 세 가지와 함께 구성할 것이다.

이 새로운 역할은 "DictionaryRepresentation"에 적합성을 추가할 것이다.

그래서 이제 우리는 적합성을 수동으로 작성할 필요가 없습니다.

우리가 이미 접근자와 생성된 구성원을 위해 추가한 DictionaryStorage 속성은 이제 이미 하고 있던 다른 모든 것들과 함께 적합성을 자동으로 추가할 것입니다.

우리가 출발점을 본 지 오랜 시간이 지났기 때문에, 당신에게 상기시키기 위해, 우리는 반복적인 코드로 가득 찬 크고 제멋대로인 유형을 가져갔고 그 코드의 대부분을 초강력 매크로의 여러 역할로 옮겼습니다. 그래서 남은 것은 이 특정 유형에 대해 특별한 것만 간결하게 명시했습니다.

DictionaryStorage를 사용할 수 있는 10개 또는 20개의 유형이 있다고 상상해 보세요.

그들 모두와 함께 일하는 것이 얼마나 더 쉬울까요?

우리는 이제 선언과 역할에 대해 이야기하는 데 많은 시간을 보냈지만, 지금까지 그들이 확장하는 코드는 마법처럼 나타나는 것처럼 보였다.

이제 그 격차를 메우고 매크로를 구현하는 방법에 대해 이야기해 봅시다.

내가 지금까지 당신에게 매크로 선언을 보여줬을 때, 나는 매우 중요한 것을 빠뜨렸다: 구현.

그것은 등호 뒤에 있고, 항상 또 다른 매크로이다.

때때로 그것은 당신이 작성한 또 다른 매크로이며, 매개 변수가 재배열되거나 리터럴로 지정된 추가 매개 변수가 있습니다.

하지만 보통, 당신은 외부 매크로를 사용할 것입니다.

외부 매크로는 컴파일러 플러그인에 의해 구현되는 것이다.

당신은 내가 이전에 컴파일러 플러그인에 대해 이야기했다는 것을 기억할 것입니다.

나는 컴파일러가 매크로가 사용되는 것을 볼 때, 별도의 프로세스에서 플러그인을 시작하고 매크로를 확장하도록 요청한다고 말했다.

"#externalMacro"는 그 관계를 정의하는 것이다.

컴파일러가 실행해야 하는 플러그인과 플러그인 내부의 유형 이름을 지정합니다.

그래서 스위프트가 이 매크로를 확장하면, "MyLibMacros"라는 플러그인을 실행하고 "StringifyMacro"라는 유형을 확장하도록 요청할 것이다.

따라서 매크로 선언은 다른 API와 함께 일반 라이브러리에 들어가지만, 매크로 구현은 별도의 컴파일러 플러그인 모듈에 들어갑니다.

그리고 "#externalMacro"는 선언과 그것을 구현하는 유형 사이의 링크를 만든다.

매크로 구현은 어떻게 생겼나요?

음, DictionaryStorage가 어떻게 구현될 수 있는지 살펴봅시다.

기억한다면, 우리의 "DictionaryStorage" 매크로는 저장된 속성과 이니셜라이저를 유형에 추가하는 "첨부된 멤버" 역할을 가지고 있었습니다.

여기 그 역할의 간단한 구현이 있습니다.

우리는 한 번에 한 단계씩 걸어가서 그것이 어떻게 작동하는지 배울 것이다.

맨 위에서, 우리는 SwiftSyntax라는 라이브러리를 가져오는 것으로 시작합니다.

SwiftSyntax는 Swift 소스 코드를 구문 분석, 검사, 조작 및 생성하는 데 도움이 되는 Swift 프로젝트에서 유지 관리하는 패키지입니다.

Swift 기여자는 언어가 발전함에 따라 SwiftSyntax를 최신 상태로 유지하므로 Swift 컴파일러가 수행하는 모든 기능을 지원합니다.

SwiftSyntax는 소스 코드를 특별한 트리 구조로 나타낸다.

예를 들어, 이 코드 샘플의 "Person" 구조체는 "StructDeclSyntax"라는 유형의 인스턴스로 표시됩니다.

하지만 그 인스턴스에는 속성이 있으며, 각 속성은 구조체 선언의 일부를 나타냅니다.

속성 목록은 "속성" 속성에 있습니다.

실제 키워드 "struct"는 "structKeyword" 속성에 있습니다.

구조체의 이름은 "식별자" 속성에 있다.

그리고 중괄호와 구조체의 멤버가 있는 몸은 "memberBlock" 속성에 있다.

일부 구조체 선언이 가지고 있는 것을 나타내는 "수정자"와 같은 속성도 있다.

하지만 이건 그렇지 않아. 이것들은 0이야.

이 속성의 구문 노드 중 일부는 "토큰"이라고 불린다.

이것들은 이름이나 키워드 또는 약간의 구두점과 같은 소스 파일의 특정 텍스트를 나타내며, 그 텍스트와 공백과 주석과 같은 주변 퀴즈를 포함합니다.

구문 트리를 충분히 깊이 파고들면, 소스 파일의 모든 바이트를 포함하는 토큰 노드를 찾을 수 있습니다.

하지만 "속성" 속성의 "AttributeListSyntax" 노드와 "memberBlock" 속성의 "MemberDeclBlockSyntax" 노드와 같은 노드 중 일부는 토큰이 아닙니다.

이것들은 그들 자신의 속성에 자식 노드를 가지고 있다.

예를 들어, "memberBlock" 속성을 살펴보면, 여는 중괄호에 대한 토큰, 회원 목록에 대한 "MemberDeclListSyntax" 노드, 닫는 중괄호에 대한 토큰을 찾을 수 있습니다.

그리고 "MemberDeclListSyntax" 노드의 내용을 계속 탐색하면, 결국 각 속성에 대한 노드를 찾을 수 있습니다.

SwiftSyntax로 작업하는 것은 그 자체로 큰 주제이므로, 이 비디오를 두 배로 길게 만드는 대신, 두 가지 다른 리소스를 참조할 것입니다.

하나는 특정 소스 코드가 구문 트리로 어떻게 표현되는지 알아내기 위한 실용적인 팁이 포함된 동반자 "Write Swift Macros" 세션입니다.

다른 하나는 SwiftSyntax 패키지의 문서이다.

온라인에서 찾을 수 있거나, 매크로 패키지에서 Xcode의 빌드 문서 명령을 사용하는 경우, SwiftSyntax 문서가 개발자 문서 창에 나타납니다.

주요 SwiftSyntax 라이브러리 외에도, 우리는 두 개의 다른 모듈도 가져옵니다.

하나는 매크로를 작성하는 데 필요한 프로토콜과 유형을 제공하는 "SwiftSyntaxMacros"이다.

다른 하나는 "SwiftSyntaxBuilder"라고 불린다.

이 라이브러리는 새로 생성된 코드를 나타내는 구문 트리를 구성하기 위한 편리한 API를 제공합니다.

매크로를 사용하지 않고도 작성할 수 있지만, 믿을 수 없을 정도로 편리하며, 이를 활용하는 것이 좋습니다.

이제 이러한 라이브러리를 가져왔으므로, 플러그인이 제공해야 하는 "DictionaryStorageMacro" 유형을 실제로 작성하기 시작할 것입니다.

그것이 "MemberMacro"라는 프로토콜을 준수한다는 것을 주목하세요.

각 역할에는 해당 프로토콜이 있으며, 구현은 매크로가 제공하는 각 역할에 대한 프로토콜을 준수해야 합니다.

"DictionaryStorage" 매크로에는 이러한 네 가지 역할이 있으므로 "DictionaryStorageMacro" 유형은 네 가지 해당 프로토콜을 준수해야 합니다.

하지만 상황을 단순하게 유지하기 위해, 우리는 현재 "MemberMacro" 적합성에 대해 걱정하고 있습니다.

이 유형의 본문으로 넘어가면, 우리는 "expansion of, providingMembersOf, in"이라는 방법을 본다.

이 방법은 MemberMacro 프로토콜에 필요하며, 매크로를 사용할 때 스위프트 컴파일러가 멤버 역할을 확장하기 위해 호출하는 것입니다.

우리는 아직 논쟁을 사용하지 않고 있지만, 나중에 그것에 대해 이야기할 것이다.

현재로서는, 그것이 정적인 방법이라는 것을 주목하세요.

모든 확장 방법은 정적이므로, Swift는 실제로 DictionaryStorageMacro 유형의 인스턴스를 만들지 않습니다.

그것은 단지 그것을 방법의 컨테이너로 사용한다.

각 확장 방법은 소스 코드에 삽입된 SwiftSyntax 노드를 반환합니다.

멤버 매크로는 유형에 멤버로 추가하기 위해 선언 목록으로 확장되므로, 멤버 매크로의 확장 방법은 "DeclSyntax" 노드의 배열을 반환합니다.

우리가 몸 안을 들여다보면, 그 배열이 만들어지는 것을 볼 수 있다.

이 매크로가 추가하기를 원하는 이니셜라이저와 저장된 속성이 있습니다.

이제, 여기의 "var 사전" 비트는 평범한 문자열처럼 보이지만, 실제로는 그렇지 않다.

이 문자열 리터럴은 DeclSyntax가 예상되는 곳에서 작성되고 있으므로, Swift는 실제로 그것을 소스 코드의 조각으로 취급하고 Swift 파서에게 DeclSyntax 노드로 바꾸도록 요청합니다.

이것은 SwiftSyntaxBuilder 라이브러리가 제공하는 편의 시설 중 하나입니다.

우리가 그것을 더 일찍 수입해서 다행이야.

그래서 그것과 다른 세 가지 역할에 대한 프로토콜을 준수함으로써, 우리는 DictionaryStorage 매크로의 작업 구현을 갖게 될 것이다.

하지만 이 매크로는 이제 올바르게 사용할 때 작동하지만, 잘못 사용하면 어떻게 되나요?

예를 들어, 구조체 대신 열거형에 적용하려고 하면 어떨까요?

음, "부속 멤버" 역할은 저장된 "사전" 속성을 추가하려고 시도할 것이다.

하지만 열거형은 저장된 속성을 가질 수 없으므로, Swift는 "Enums는 저장된 속성을 포함해서는 안 된다"라는 오류를 생성할 것이다.

스위프트가 이 코드가 컴파일되는 것을 멈추는 것은 좋지만, 오류 메시지는 약간 혼란스럽지 않나요?

DictionaryStorage 매크로가 왜 저장된 속성을 만들려고 했는지 또는 당신이 다르게 했어야 했던 것은 명확하지 않습니다.

나는 이전에 스위프트의 목표 중 하나가 매크로가 입력의 실수를 감지하고 사용자 지정 오류를 발생하도록 허용하는 것이라고 말했다.

따라서 매크로의 구현을 수정하여 훨씬 더 명확한 오류 메시지를 생성해 봅시다: "@DictionaryStorage는 구조체에만 적용될 수 있습니다."

그것은 개발자들에게 그들이 무엇을 잘못했는지에 대한 더 나은 아이디어를 줄 것이다.

이것을 하는 열쇠는 우리가 지금까지 무시한 확장 방법의 매개 변수가 될 것이다.

정확한 주장은 역할에 따라 약간 다르지만, 멤버 매크로의 경우 세 가지가 있다.

첫 번째는 "속성"이라고 불리며, 그 유형은 AttributeSyntax이다.

이것은 개발자가 매크로를 사용하기 위해 작성한 실제 DictionaryStorage 속성입니다.

두 번째 인수는 "선언"이라고 불리며 "DeclGroupSyntax"를 준수하는 유형이다.

DeclGroupSyntax는 구조체, 열거형, 클래스, 액터, 프로토콜 및 확장을 위한 노드가 모두 준수하는 프로토콜이다.

그래서 이 매개 변수는 개발자가 속성을 첨부한 선언을 제공합니다.

그리고 최종 매개 변수는 "context"라고 불리며 "MacroExpansionContext"를 준수하는 유형입니다.

컨텍스트 객체는 매크로 구현이 컴파일러와 통신하고자 할 때 사용됩니다.

그것은 오류와 경고를 포함하여 몇 가지 다른 일을 할 수 있다.

우리는 이 세 가지 매개 변수를 모두 사용하여 오류를 방출할 것이다.

그게 어떻게 되는지 보자.

먼저, 우리는 그 문제를 감지해야 한다.

우리는 "선언" 매개 변수의 유형을 확인함으로써 그것을 할 것이다.

각 종류의 선언은 다른 유형을 가지고 있으므로, 구조체라면 그 유형은 "StructDeclSyntax"가 될 것이고, 열거형이라면 "EnumDeclSyntax"가 될 것이다.

그래서 우리는 "claration" 매개 변수의 "is" 메서드를 호출하고 "StructDeclSyntax"를 전달하는 guard-else를 작성할 것입니다.

선언이 구조체가 아니라면, 우리는 "else" 블록으로 끝날 것이다.

현재로서는, 우리는 빈 배열을 반환할 것이므로, 매크로는 프로젝트에 코드를 추가하지 않지만, 우리가 정말로 하고 싶은 것은 오류를 방출하는 것입니다.

이제, 그것을 하는 쉬운 방법은 일반적인 스위프트 오류를 던지는 것이지만, 그것은 당신에게 출력에 대한 많은 통제권을 주지 않는다.

그래서 대신, 더 정교한 오류를 만들 수 있는 더 복잡한 방법을 보여드리겠습니다.

첫 번째 단계는 "진단"이라는 유형의 인스턴스를 만드는 것이다.

이것은 약간의 컴파일러 전문 용어이다.

부러진 다리의 엑스레이를 보는 의사가 골절을 진단하는 것처럼, 깨진 코드의 구문 트리를 보는 컴파일러 또는 매크로는 오류나 경고를 진단합니다.

그래서 우리는 오류를 나타내는 인스턴스를 "진단"이라고 부른다.

진단에는 적어도 두 가지 정보가 포함되어 있다.

첫 번째는 오류가 발생한 구문 노드이므로, 컴파일러는 어떤 줄을 잘못된 것으로 표시할지 알고 있다.

여기서, 우리는 사용자가 작성한 DictionaryStorage 속성을 가리키고 싶습니다. DictionaryStorage 속성은, 다행히도 메서드가 전달된 "속성" 매개 변수에 의해 제공됩니다.

두 번째는 컴파일러가 생성하기를 원하는 실제 메시지입니다.

사용자 지정 유형을 만든 다음 인스턴스를 전달하여 이를 제공합니다.

그걸 빨리 살펴보자.

"MyLibDiagnostic" 유형은 이 모듈이 생성할 수 있는 모든 진단을 정의합니다.

우리는 열거형을 사용하고 각 진단에 대한 사례를 제공하기로 선택했지만, 원한다면 다른 종류의 유형을 사용할 수 있습니다.

이 유형은 던질 수 있는 스위프트 오류처럼 작동한다.

그것은 "진단 메시지" 프로토콜을 준수하며, 진단에 대한 정보를 제공하는 많은 속성을 가지고 있다.

가장 중요한 것 중 하나는 "심각한" 속성이다.

진단이 오류인지 경고인지를 명시한다.

그런 다음 실제 오류 메시지를 생성하는 "메시지" 속성과 "진단 ID" 속성이 있습니다.

도메인에는 플러그인의 모듈 이름을 사용하고 ID에는 일종의 고유한 문자열을 사용해야 합니다.

나는 이 열거형에 문자열 원시 값을 사용하기로 선택했지만, 그것은 단지 편리함일 뿐이다.

그래서 메시지를 가지고, 당신은 진단을 만들 수 있습니다.

그런 다음 당신은 그것을 진단하기 위해 맥락을 말하고, 당신은 끝났습니다.

그것은 꽤 기본적인 진단이지만, 당신이 원한다면, 당신은 그들과 함께 더 많은 팬을 얻을 수 있습니다.

예를 들어, Xcode Fix 버튼에 의해 자동으로 적용되는 진단에 Fix-Its를 추가할 수 있습니다.

하이라이트를 추가하고 코드의 다른 위치를 가리키는 메모를 첨부할 수도 있습니다.

그래서 당신은 정말로 당신의 개발자들에게 일류 오류 경험을 제공할 수 있습니다.

하지만 매크로가 올바르게 적용되고 있는지 확인한 후에는 실제로 확장을 만들어야 합니다.

SwiftSyntax는 당신에게 그것을 할 수 있는 몇 가지 다른 도구를 제공합니다.

구문 노드는 변경할 수 없지만, 새 노드를 만들거나 기존 노드의 수정된 버전을 반환하는 많은 API가 있습니다.

SwiftSyntaxBuilder 라이브러리는 일부 자식 노드가 후행 클로저로 지정된 SwiftUI 스타일 구문 빌더를 추가합니다.

예를 들어, 다차원 배열 매크로는 구문 빌더를 사용하여 생성되는 유형에 적합한 매개 변수 수를 생성할 수 있습니다.

그리고 DictionaryStorage 속성과 이니셜라이저를 만드는 데 사용한 문자열 리터럴 기능도 보간을 지원합니다.

이 모든 기능은 다양한 상황에서 유용하며, 특히 복잡한 매크로에서 몇 가지를 결합할 수 있을 것입니다.

하지만 문자열 리터럴 기능은 특히 많은 양의 코드에 대한 구문 트리를 생성하는 데 능숙하며, 보간 기능에 대해 배울 것이 조금 있습니다.

그래서 코드를 생성하기 위해 그것들을 어떻게 사용할 수 있는지 살펴봅시다.

이전에, 우리는 "포지 언랩" 매크로에 대해 이야기했다.

그것은 선택적 값과 메시지 문자열을 취하고 클로저로 래핑된 "guard let"로 확장됩니다.

이 코드의 일반적인 모양은 항상 동일하지만, 많은 콘텐츠는 특정 사용 사이트에 맞게 사용자 정의됩니다.

"Guard let" 문에 집중하고 그 문만을 생성하는 함수를 어떻게 작성할 수 있는지 봅시다.

우선, 우리는 방금 본 정확한 코드 샘플을 받아 문 구문 노드를 반환하는 "makeGuardStatement"라는 도우미 메소드에 넣을 것입니다.

그런 다음 우리는 사용 위치에 따라 달라야 하는 모든 것을 대체하기 위해 천천히 보간을 추가할 것입니다.

우리가 가장 먼저 할 일은 올바른 메시지 문자열을 추가하는 것이다.

메시지 문자열은 임의의 표현식이므로, ExprSyntax 노드로 전달한 다음 보간할 것입니다.

이와 같은 일반적인 보간은 코드에 구문 노드를 추가할 수 있지만, 일반 문자열을 추가할 수는 없습니다.

그것은 당신이 실수로 잘못된 코드를 삽입하지 않도록 하는 안전 기능입니다.

Guard-let 조건은 변수 이름일 뿐이라는 점을 제외하고는 비슷하므로 표현식이 아니라 토큰입니다.

상관없이, 우리는 표현식을 보간한 것처럼 TokenSyntax 매개 변수를 추가하고 보간합니다.

오류 메시지에 포장되지 않은 표현을 추가할 때 더 까다로운 경우가 있습니다.

매크로의 특징 중 하나는 실패하면 풀려고 했던 코드를 출력한다는 것입니다.

그것은 우리가 구문 노드의 문자열화된 버전을 포함하는 문자열 리터럴을 만들어야 한다는 것을 의미합니다.

문 구문 리터럴에서 접두사를 꺼내서 그냥 평범한 문자열인 변수로 시작하는 것부터 시작합시다.

우리는 그 문자열을 보간할 것이지만, "문자 그대로:"로 시작하는 특별한 보간을 사용할 것이다.

이렇게 하면, SwiftSyntax는 문자열의 내용을 문자열 리터럴로 추가합니다.

이것은 또한 매크로, 숫자, 부울, 배열, 사전, 심지어 선택 사항으로 계산된 다른 종류의 정보에서 리터럴을 만드는 데에도 효과가 있다.

이제 변수에 문자열을 만들고 있으므로, 메시지에 올바른 코드를 갖도록 변경할 수 있습니다.

원래 표현식에 대한 매개 변수를 추가하고, "설명" 속성을 문자열에 보간하세요.

당신은 그것을 피하기 위해 특별한 것을 할 필요가 없습니다.

" 리터럴:" 보간은 문자열에 특수 문자가 포함되어 있는지 자동으로 감지하고 이스케이프를 추가하거나 원시 리터럴로 전환하여 코드가 유효한지 확인합니다.

그래서 "문자 그대로:" 보간은 옳은 일을 하는 것을 매우 쉽게 만든다.

마지막으로 처리해야 할 것은 파일과 줄 번호이다.

컴파일러가 매크로에 확장 중인 소스 위치를 알려주지 않기 때문에 이것들은 조금 까다롭다.

그러나 매크로 확장 컨텍스트에는 컴파일러가 소스 위치 정보와 함께 리터럴로 바꿀 특수 구문 노드를 생성하는 데 사용할 수 있는 API가 있습니다.

그래서 그게 어떻게 끝났는지 보자.

우리는 매크로 확장 컨텍스트에 대한 또 다른 인수를 추가한 다음, "위치" 방법을 사용할 것입니다.

이것은 당신이 제공하는 노드의 위치에 대한 구문 노드를 생성할 수 있는 객체를 반환합니다.

노드가 컴파일러가 당신에게 전달한 것이 아니라 매크로가 만든 노드라면 nil을 반환하지만, 우리는 "originalWrapped"가 사용자가 작성한 인수 중 하나라는 것을 알고 있으므로 그 위치는 결코 nil이 되지 않을 것이며, 우리는 안전하게 결과를 강제로 언포장할 수 있습니다.

이제 파일과 줄 번호에 대한 구문 노드를 보간하기만 하면 됩니다.

우리는 지금 올바른 "가드" 성명을 작성하고 있다.

지금까지, 우리는 매크로를 작동시키는 방법에 대해 논의했다.

하지만 계속 진행해서 그들이 잘 작동하도록 하는 방법에 대해 이야기해 봅시다.

그리고 우리는 이름 충돌에 대해 이야기하는 것으로 시작할 것이다.

우리가 전에 "unwrap" 매크로를 보았을 때, 우리는 간단한 변수 이름을 풀었던 예를 보았다.

하지만 우리가 더 복잡한 표현을 풀려고 한다면, 매크로는 다르게 확장해야 한다.

그것은 표현식의 결과를 "wrappedValue"라는 변수로 캡처하는 코드를 생성한 다음, 그것을 풀다.

하지만 메시지에서 "wrappedValue"라는 변수를 사용하려고 하면 어떻게 되나요?

컴파일러가 "wrappedValue"를 찾으러 갈 때, 그것은 결국 더 가까운 것을 찾게 될 것이므로, 당신이 실제로 의미했던 것 대신에 그것을 사용할 것입니다.

사용자가 우연히 사용하지 않을 것이라고 생각하는 이름을 선택하여 이 문제를 해결하려고 시도할 수 있지만, 이것을 불가능하게 만드는 것이 더 낫지 않을까요?

그것이 매크로 확장 컨텍스트의 "makeUniqueName" 메소드가 하는 일이다.

사용자 코드나 다른 매크로 확장에서 사용되지 않도록 보장된 변수 이름을 반환하므로 메시지 문자열이 실수로 참조되지 않도록 할 수 있습니다.

여러분 중 몇몇은 궁금해할 것입니다. 왜 스위프트는 그 일이 일어나는 것을 자동으로 막지 않나요?

일부 언어에는 소위 "위생적인" 매크로 시스템이 있는데, 매크로 내부의 이름은 외부의 이름과 구별되기 때문에 서로 충돌할 수 없다.

스위프트는 많은 매크로가 외부의 이름을 사용해야 한다는 것을 발견했기 때문에 그렇지 않다.

유형에 "dictionary" 속성을 사용하는 DictionaryStorage 매크로를 생각해 보세요.

매크로 내부의 "사전"이 외부의 "사전"과 다른 것을 의미한다면, 그 일을 하는 것은 꽤 어려울 것이다.

그리고 때때로, 당신은 매크로가 아닌 코드가 접근할 수 있는 완전히 새로운 이름을 소개하고 싶을 수도 있습니다.

피어 매크로, 멤버 매크로 및 선언 매크로는 기본적으로 이것을 하기 위해 전적으로 존재한다.

하지만 그들이 할 때, 그들은 그들이 추가하고 있는 이름을 선언해야 하므로, 컴파일러는 그들에 대해 알고 있다.

그리고 그들은 그들의 역할 속성 안에서 그것을 한다.

당신은 전에 그것을 눈치채지 못했을 수도 있지만, 우리는 실제로 이 선언들을 계속 보았습니다.

DictionaryStorage 매크로의 "회원" 역할에는 "dictionary"와 "init"라는 이름을 지정하는 "names:" 매개 변수가 있었다.

그리고 사실, 우리가 이 세션에서 살펴본 대부분의 매크로는 "이름" 인수와 함께 적어도 하나의 역할을 가지고 있다.

사용할 수 있는 다섯 가지 이름 지정자가 있습니다: "Overloaded"는 매크로가 매크로가 첨부된 것과 정확히 동일한 기본 이름으로 선언을 추가한다는 것을 의미합니다.

"접두사"는 매크로가 지정된 접두사가 추가된 것을 제외하고 동일한 기본 이름으로 선언을 추가한다는 것을 의미합니다.

"접미사"는 접두사 대신 접미사를 제외하고는 같은 것이다.

"명명"은 매크로가 특정 고정 기본 이름으로 선언을 추가한다는 것을 의미합니다.

그리고 "임의"는 매크로가 이러한 규칙을 사용하여 설명할 수 없는 다른 이름으로 선언을 추가한다는 것을 의미합니다.

"임의"를 사용하는 것은 정말 일반적이다.

예를 들어, 우리의 다차원 배열 매크로는 매개 변수 중 하나에서 계산된 이름을 가진 유형을 선언하므로 "임의"를 지정해야 합니다.

하지만 다른 지정자 중 하나를 사용할 수 있을 때, 그렇게 하세요.

그것은 컴파일러와 코드 완성과 같은 다른 도구를 더 빠르게 만들 것이다.

이제, 세션의 이 시점에서, 나는 너희 모두가 첫 번째 매크로를 쓰고 싶어하는 것 같아.

그리고 시작하는 방법에 대한 좋은 아이디어가 있을 수 있습니다: 확장된 날짜와 시간을 삽입하는 매크로를 작성하기만 하면 됩니다.

좋은 생각이야, 그렇지?

틀렸어.

알고 보니, 당신은 이 매크로를 써서는 안 됩니다.

이유를 설명해줄게.

매크로는 컴파일러가 제공하는 정보만 사용해야 한다.

컴파일러는 매크로 구현이 순수한 함수이며, 제공된 데이터가 변경되지 않았다면 확장도 변경할 수 없다고 가정합니다.

만약 당신이 그것을 우회한다면, 당신은 일관성 없는 행동을 볼 수 있습니다.

이제, 매크로 시스템은 이 규칙을 위반할 수 있는 어떤 종류의 행동을 방지하도록 설계되었다.

컴파일러 플러그인은 매크로 구현이 디스크의 파일을 읽거나 네트워크에 액세스하는 것을 막는 샌드박스에서 실행됩니다.

하지만 샌드박스가 모든 나쁜 행동을 막지는 않는다.

API를 사용하여 날짜나 난수와 같은 정보를 얻거나, 글로벌 변수의 한 확장에서 정보를 저장하고 다른 확장에 사용할 수 있습니다.

하지만 당신이 이런 일을 한다면, 당신의 매크로가 잘못 행동할 수 있습니다.

그러니까 그러지 마.

마지막으로, 하지만 무엇보다도, 테스트에 대해 이야기해 봅시다.

매크로 플러그인은 일반 스위프트 모듈일 뿐이며, 이는 일반 단위 테스트를 작성할 수 있고 반드시 작성해야 한다는 것을 의미합니다.

테스트 기반 개발은 스위프트 매크로 개발에 매우 효과적인 접근 방식이다.

SwiftSyntaxMacrosTestSupport의 "assertMacroExpansion" 도우미는 매크로가 올바른 확장을 생성하는지 확인합니다.

매크로와 확장해야 하는 코드의 예를 들어 보세요, 그러면 그것들이 일치하는지 확인할 것입니다.

그래서 우리는 오늘 스위프트 매크로에 대해 많은 것을 배웠다.

매크로를 사용하면 작은 사용 사이트를 더 복잡한 코드로 "확장"하는 새로운 언어 기능을 설계하여 상용구를 줄일 수 있습니다.

일반적으로 라이브러리에서 다른 API와 함께 매크로를 선언하지만, 실제로 안전한 샌드박스에서 스위프트 코드를 실행하는 별도의 플러그인에서 구현합니다.

매크로의 역할은 당신이 그것을 사용할 수 있는 곳과 그 확장이 프로그램의 나머지 부분에 어떻게 통합되는지를 표현합니다.

그리고 당신은 매크로가 예상대로 작동하는지 확인하기 위해 매크로에 대한 단위 테스트를 작성할 수 있고, 확실히 해야 합니다.

아직 보지 않았다면, "Write Swift Macros" 세션이 다음 정류장이 되어야 합니다.

Xcode의 매크로 개발 도구와 매크로 패키지 템플릿으로 작업하는 방법, SwiftSyntax 트리를 검사하고 정보를 가져오는 방법, 단위 테스트를 중심으로 매크로 개발 워크플로우를 구축하는 방법을 보여줍니다.

그래서 봐줘서 고마워, 그리고 행복한 코딩.

♪ ♪