10172

♪ ♪

조이: 안녕하세요, 저는 여기 애플의 컴파일러 팀의 엔지니어인 조이입니다.

오늘, 저는 Swift와 C++를 함께 사용할 수 있는 Xcode 15의 새로운 기능인 Swift와 C++ 상호 운용성을 소개할 것입니다.

이 이야기는 두 부분으로 나눌 것이다.

먼저, 나는 상호 운용성의 기초를 설명할 것이다.

그런 다음 Swift에서 C++ API를 자연스럽고 안전하게 만드는 방법을 보여드리겠습니다.

스위프트는 Objective-C로 작성된 많은 큰 앱과 코드베이스가 있는 세계로 진출했다.

스위프트가 이 기존 코드를 활용하고 이러한 코드베이스에 점진적으로 채택될 수 있는 것이 필수적이었다.

오늘날, 스위프트는 이 상호 운용성을 한 단계 끌어올리면 더 많은 곳에서 스위프트를 채택할 수 있습니다.

대규모 C++ 코드베이스가 있다면, 이제 양방향 상호 운용성을 활용하여 Swift를 점진적으로 채택할 수 있습니다.

그리고 앱의 C++ 라이브러리에 액세스해야 하는 경우, 더 이상 Objective-C 브리징 레이어를 작성할 필요가 없습니다.

샘플 앱을 보고 C++ 코드베이스에서 Swift를 채택하는 것이 얼마나 쉬운지 봅시다.

나는 사진 편집 앱 작업을 하고 있어.

카메라 롤에서 사진을 선택하고, 색상을 반전하고, 밝기를 변경할 수 있습니다.

코드에 들어가기 전에, 내 앱의 구조를 살펴봅시다.

이 앱은 이미지 처리 프레임워크와 사용자 인터페이스 코드의 두 부분으로 나눌 수 있습니다.

내 앱이 기반으로 하는 이미지 처리 프레임워크는 C++로 작성되었다.

사용자 인터페이스 레이어가 C++ 프레임워크와 쉽게 대화할 수 있기를 원했기 때문에 Objective-C++를 사용하여 ViewController와 같은 대부분의 사용자 인터페이스를 구현했습니다.

이제, 저는 제 앱 사용자가 카메라 롤에서 몇 장의 사진을 골라 편집할 수 있기를 바랍니다.

SwiftUI가 이것을 쉽게 만드는 새로운 PhotoPicker 보기를 가지고 있다고 들었기 때문에, 제 앱에서 Swift를 채택하고 싶습니다.

운 좋게도, Xcode 15부터, 저는 Objective-C++ 코드베이스에서 Swift를 쉽게 채택할 수 있으며 여전히 모든 C++ API에 액세스할 수 있습니다.

그래서 프로젝트에 스위프트 파일을 추가하는 것으로 시작합시다.

C++ 프레임워크를 사용하고 있기 때문에 Xcode는 C++ API를 자동으로 가져오므로 브리징 헤더가 필요하지 않습니다.

그런 다음, 프로젝트 빌드 설정에서 C++ 상호 운용성을 활성화해야 합니다.

아시다시피, Swift는 이미 C 및 Objective-C API를 호출할 수 있으므로, 빌드 설정은 현재 C 및 Objective-C 모드로 설정되어 있습니다.

하지만 난 이걸 C++로 바꿀 수 있어.

이제 설정이 C++와 Objective-C++를 읽으므로, C++ 이미지 키트 프레임워크에서 API를 직접 호출할 수 있습니다.

스위프트 파일로 돌아가서, 다른 스위프트 모듈과 마찬가지로 프레임워크를 가져올 수 있으며, 모듈 이름을 클릭하여 내용을 볼 수 있습니다.

이제, 이것들은 스위프트 API처럼 보일지 모르지만, 실제로는 내 C++ ImageKit 라이브러리에서 가져온 것이다; 이것이 바로 스위프트 컴파일러가 그것들을 보는 방식이다.

제가 오늘 사용할 API 몇 개를 살펴봅시다.

하단부터 CxxImageEngine 유형의 정적 멤버를 볼 수 있습니다.

이것은 현재 안전하지 않은 포인터로 수입되지만, 우리는 나중에 그것에 더 들어갈 것이다.

CxxImageEngine에는 몇 가지 다른 멤버, 즉 loadImage와 getImages가 있으며, 곧 사용할 것입니다.

이제 나는 C++와 대화하는 두 가지 방법에 집중할 수 있도록 사진 선택기를 위한 모든 UI를 넣을 것이다.

공유된 CxxImageEngine을 잡고 선택한 각 이미지에서 loadImage를 호출하여 엔진에 로드할 수 있습니다.

와, 스위프트에서 C++ 메소드를 호출하는 것은 매우 쉽다.

이제 SwiftUI 보기가 완료되었습니다. Objective-C++ ViewController에서 사용하고 싶습니다.

이렇게 하려면, Objective-C++ 코드에서 액세스할 수 있도록 구조를 공개해야 합니다.

좋아! 내 모든 스위프트 코드는 성공적으로 만들어졌다.

이제 ViewController 파일로 가서 Swift가 생성한 헤더를 가져올 수 있습니다.

이 헤더에는 모든 공용 Swift API가 포함되어 있습니다.

이제 생성된 헤더를 가져왔으니, C++로 Swift 코드를 호출할 수 있습니다.

먼저, 나는 SwiftUI 뷰를 구성할 것이다.

그러면, 나는 현재 방법을 부를 수 있다.

그리고 Xcode는 코드 완성에 도움을 준다.

이것을 온디바이스에서 테스트해 봅시다.

앱을 빌드하고 실행한 후, Objective-C++ 앱으로 직접 가져온 새로운 SwiftUI 뷰를 볼 수 있습니다.

이것은 진정한 양방향 상호 운용성의 예였다.

나는 Swift에서 C++ 유형과 함수를 원활하게 사용할 수 있었고 그 반대도 마찬가지였다.

C++에서, 나는 뷰의 본문이 내 C++ 프레임워크로 다시 호출되는 SwiftUI 뷰를 구성하고 사용할 수 있었다.

모든 통합은 스위프트 컴파일러에 의해 자동으로 수행되므로, 브리지 레이어를 작성할 필요가 없었다.

그리고 모든 API는 직접적이고 네이티브이므로, 상호 운용되는 대부분의 다른 언어와 달리, Swift 또는 그 반대로 C++ API를 호출할 때 오버헤드가 없습니다.

나는 오늘 꽤 작은 앱으로 작업했지만, 스위프트 컴파일러는 크고 복잡한 코드베이스에서 상호 운용성을 지원할 수 있다.

스위프트는 표준 라이브러리와 다른 곳에서 대부분의 C++ 컬렉션을 가져올 수 있다.

스위프트는 함수 템플릿과 클래스 템플릿 전문 분야를 처리할 수 있다.

그리고 공유 포인터와 유사한 사용자 정의 유형을 사용하여 메모리 관리를 지원합니다.

스위프트는 이러한 가져온 API를 높은 수준에서 이해할 수 있다.

예를 들어, 공유 포인터의 유지 및 해제 작업에 대해 알고 있으며, 이 높은 수준의 지식을 사용하여 강력한 최적화 제품군을 적용할 수 있습니다.

다른 방향으로, 구조체, 클래스, 메서드 및 기타 멤버와 같은 대부분의 Swift API를 C++에 노출할 수 있습니다.

시간이 지남에 따라 진화하는 배열과 탄력적인 유형과 같은 일반적인 유형을 노출할 수도 있습니다.

그리고 C++ 상호 운용성은 Xcode에서 완벽하게 지원되므로, 두 언어 모두에서 코드 완성, 정의로 이동 및 디버거 지원을 받을 수 있습니다.

이것들은 C++ 상호 운용성에서 지원되는 API 중 일부에 불과합니다.

스위프트 컴파일러는 이러한 모든 API 등을 사용하는 대규모 코드베이스 간의 상호 운용성을 지원하여 언어 전반에 걸쳐 응집력 있는 경험을 촉진하고 더 많은 곳에서 스위프트를 채택할 수 있도록 합니다.

이제 상호 운용성의 기초를 다루었으니, 이 기능에 대해 더 자세히 알아보고, Swift에서 C++ API를 자연스럽고 안전하게 느낄 수 있는 몇 가지 방법을 탐구해 봅시다.

스위프트 컴파일러는 대부분의 C++ API를 자동으로 가져오고 안전한 스위프트 API로 나타낼 수 있다.

예를 들어, 기본적으로 C++ 유형은 Swift 구조체로 가져오고, C++ 연산자는 유사한 Swift 연산자에 매핑되며, 컨테이너는 자동으로 컬렉션으로 가져옵니다.

하지만 컴파일러를 사용하면 API를 가져오는 방법을 미세 조정하고 훨씬 더 자연스럽게 느껴지는 API를 노출할 수 있습니다.

주석을 사용하여 컴파일러에 API에 대한 더 많은 정보를 제공하여 이를 수행할 수 있습니다.

예를 들어, 함수나 메서드는 스위프트에서 자연스럽게 느껴지지 않는 C++ 명명 규칙을 사용할 수 있다.

이러한 경우, 주석을 사용하여 가져온 함수의 이름을 바꾸거나, 인수 라벨을 추가하거나, 게터와 세터를 계산된 속성으로 가져올 수 있습니다.

주석은 또한 참조 의미론과 같은 높은 수준의 패턴을 설명하는 데 도움이 될 수 있으며 일부 유형을 Swift 클래스로 가져올 수 있습니다.

또는 실제로 괜찮을 때 API가 안전하지 않다고 생각한다면 Swift를 수정하세요.

이러한 주석은 스위프트가 가져오는 API에 대한 정보를 전달하는 강력한 방법입니다.

샘플 앱에서 사용하는 몇 가지 다른 API를 식별하고 이러한 주석을 사용하여 Swift가 안전하고 직관적인 방식으로 API를 가져올 수 있는 방법을 살펴봅시다.

이제 사진 선택기를 완료했으므로, 편집된 사진을 사진 라이브러리에 다시 저장하기 위해 저장 버튼을 추가하고 싶습니다.

스위프트로 돌아가서, 내가 가져온 모든 API를 다시 볼 수 있다.

먼저, 나는 저장할 사진을 모아야 할 것이다.

그리고 나는 getImages 기능을 사용하여 그것을 할 수 있다.

getImages 함수는 C++ 벡터를 반환합니다.

이 방법을 부르기 전에, 스위프트에서 벡터가 어떻게 작동하는지에 대한 세부 사항을 이해합시다.

스위프트 유형은 두 가지 범주로 나뉩니다: 값 유형과 참조 유형.

스위프트에서 구조체는 값 유형을 나타내고 클래스는 참조 유형을 나타낸다.

기본적으로, C++ 유형은 Swift에서 값 유형으로 가져올 것이다.

그래서 스위프트는 스위프트 구조체처럼 작동하는 값 유형으로 벡터를 가져올 것이다.

벡터와 다른 스위프트 구조체의 유일한 차이점은 스위프트가 수명 관리를 위해 복사 생성자와 같은 유형의 특수 멤버를 사용한다는 것이다.

이 복사 생성자들은 종종 딥 카피를 수행한다.

따라서 수정될 때만 복사되는 스위프트 어레이와 달리, 스위프트가 벡터를 복사할 때 모든 요소를 복사합니다.

이제 이미지 벡터가 있으므로, for-loop에서 벡터를 반복하여 각 이미지를 가져오고, 이미지를 uiImage로 다시 변환하고, 이미지를 사진 라이브러리에 저장할 수 있습니다.

이 for-loop는 벡터가 시작 및 종료 방법이 있기 때문에 작동하므로 Swift는 자동으로 컬렉션으로 가져옵니다.

컬렉션에 대한 이 자동 적합성을 통해 벡터를 스위프트 어레이로 쉽게 변환할 수 있으며 지도 및 필터와 같은 방법에 대한 액세스를 제공합니다.

안전을 위해, 스위프트의 안전 모델에 맞지 않는 C++ 반복기 API보다는 이러한 스위프트 컬렉션 API를 사용하는 것이 중요합니다.

이러한 C++ 반복자를 사용하면 평생 문제나 잘못된 메모리 액세스와 같은 버그를 쉽게 도입할 수 있습니다.

반면에, 스위프트 컬렉션 API는 C++ 컬렉션에서 작동하더라도 완전히 안전합니다.

스위프트 컴파일러는 안전하지 않은 C++ API를 사용할 수 없는 것으로 표시하고 더 안전한 대안을 제안함으로써 이러한 더 안전한 API로 안내하는 데 도움이 될 것입니다.

내 스위프트 앱으로 돌아가자.

나를 괴롭히는 무언가가 있어.

C++ImageEngine을 사용할 때마다, 나는 그것이 안전하지 않은 포인터라는 것을 상기시킨다.

그리고 사실, 그 유형은 항상 스위프트와 C++ 모두에서 포인터로 사용된다.

이것은 그 유형이 "참조 의미론"이라고 불리는 것을 가지고 있기 때문이다.

이것은 유형이 객체 정체성을 갖기 위한 것이며, 복사본은 별개의 값이 아니라 동일한 메모리에 대한 공유 참조가 될 것이라는 것을 의미합니다.

앞서 언급했듯이, 스위프트 유형은 두 가지 범주로 나뉩니다: 값 유형과 참조 유형.

Objective-C는 또한 값 유형과 참조 유형을 명확하게 구분하여 Objective-C 유형을 구조체와 클래스에 쉽게 매핑할 수 있습니다.

C++의 경우, Swift와 Objective-C와 달리 C++는 값 유형과 참조 유형을 크게 구분하지 않기 때문에 어떤 유형이 어떤 범주에 속하는지 명확하지 않다.

따라서 기본적으로 컴파일러는 모든 것을 값 유형으로 가져올 것이다.

하지만 스위프트는 또한 C++ 코드에 주석을 추가하여 참조 또는 클래스 유형으로 가져올 수 있는 옵션을 제공합니다.

SWIFT_SHARED_REFERENCE 속성을 사용하여 CxxImageEngine을 Swift 클래스에 매핑할 수 있습니다.

이 속성은 스위프트가 유형이 항상 포인터 또는 참조로 전달되고 스위프트에서 안전하지 않은 포인터가 아닌 단순히 유형으로 이 간접을 나타낸다는 것을 의미합니다.

코드를 안전하게 만들기 위해, 스위프트는 필요에 따라 참조를 유지하고 해제하여 참조의 수명을 자동으로 관리합니다.

이러한 종류의 참조 계산을 활성화하려면, Swift에 이러한 유지 및 해제 기능을 모두 제공해야 합니다.

C++ ImageKit 헤더로 들어가 봅시다.

SWIFT_SHARED_REFERENCE와 같은 주석에 액세스하기 위해 swift/bridging을 가져올 수 있습니다.

이제 Swift가 호출할 수 있는 유지 및 릴리스 기능을 모두 지정하여 이 주석을 유형에 적용할 수 있습니다.

좋아!

이제 더 이상 포인터를 역참조할 필요가 없다는 몇 가지 스위프트 컴파일러 오류가 있습니다.

이 C++ API가 스위프트에서 집처럼 느껴지도록 하기 위해 내가 할 수 있는 마지막 일이 하나 있다.

여기 for-loop에서, 나는 getImages에 전화하고 있다.

이와 같이 게터와 세터를 정의하는 것은 C++에서 상당히 일반적인 패턴이지만, 스위프트에서는 그다지 자연스럽지 않다.

이것이 스위프트에서 좀 더 네이티브라고 느끼게 하기 위해, 나는 스위프트/브리징의 또 다른 주석을 사용할 수 있다.

SWIFT_COMPUTED_PROPERTY 속성은 게터와 세터에 적용하여 쌍을 스위프트 계산 속성에 매핑할 수 있습니다.

이 주석을 적용하기 위해 C++ 헤더로 다시 이동합시다.

이제 정의를 보조 클릭하고 Swift 호출자를 선택하여 getImages 메소드의 호출자를 찾을 수 있으며, 이제 이름을 단순히 "이미지"로 바꿀 수 있습니다.

아름다워!

이제 마지막으로 앱을 테스트해 봅시다.

나는 몇 장의 사진을 선택하고 내 카메라 롤에 다시 저장할 수 있다.

좋아!

이 강연에서, 나는 API를 가져오는 방식을 개선하기 위해 두 개의 주석만 사용했다.

하지만 C++ 헤더에서 사용할 수 있는 다른 많은 주석이 있습니다.

그들에게 접근하기 위해 당신이 해야 할 일은 스위프트/브리징을 가져오는 것뿐입니다.

Xcode 15에서 C++ 상호 운용성을 활성화하려면 C++ 및 Objective-C 상호 운용성 모드를 C 및 Objective-C에서 C++ 및 Objective-C++로 변경하십시오.

그리고 스위프트와 C++ 상호 운용성은 리눅스와 윈도우뿐만 아니라 모든 애플 플랫폼에서 지원됩니다.

C++는 크고 복잡한 언어이며, 우리는 C++ API를 가져오고 당신의 피드백과 함께 Swift API를 노출하는 방식을 개선하고 싶습니다.

C++ API를 가져오는 방식을 바꾸면, 새로운 버전의 상호 운용성을 만들 것입니다.

즉, 이러한 새로운 기능을 사용할 때 선택할 수 있으며, 오늘 개발에서 C++ API를 자신 있게 사용할 수 있습니다.

만약 당신이 어떤 문제를 발견하거나 어떤 제안이 있다면, 우리는 당신의 의견을 듣고 싶습니다.

피드백 어시스턴트를 사용하여 저희에게 알려주세요.

C++ 상호 운용성은 전적으로 오픈 소스에서 스위프트 컴파일러 작업 그룹에 의해 설계되었다.

작업 그룹은 12개 이상의 회사와 학교의 엔지니어와 학생들로 구성되어 있다.

작업 그룹은 스위프트와 C++ 상호 운용성의 미래에 대한 비전을 정의하고 시간이 지남에 따라 이 기능의 진화를 안내할 두 개의 문서를 개발했다.

작업 그룹에 가입하고 포럼에 참여할 수 있습니다.

그냥 swift.org로 가세요.

Swift 5.9에서는 오버헤드 없이 C++ API를 자동으로 안전하게 사용할 수 있습니다.

새로운 스위프트 코드를 C++에 다시 노출하여 스위프트를 점진적으로 채택할 수 있습니다.

그리고 컴파일러에 더 많은 정보를 제공하여 가져온 API를 개선하고 미세 조정할 수 있습니다.

시청해 주셔서 감사드리며, 모든 C++ 코드베이스에서 스위프트를 채택하는 것을 즐기세요.