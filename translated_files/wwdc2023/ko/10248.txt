10248

♪ ♪

Joachim Kurz: "Analyze Hangs with Instruments"에 오신 것을 환영합니다.

제 이름은 요아킴이고, 저는 인스트루먼트 팀에서 일하는 엔지니어입니다.

오늘, 우리는 Hangs를 더 자세히 살펴보고 싶다.

먼저, 나는 너에게 교수형이 무엇인지에 대한 개요를 줄 것이고, 그렇게 하기 위해, 우리는 인간의 인식에 대해 이야기해야 할 것이다.

그런 다음, 중단이 어떻게 발생하는지 이해하는 기초를 형성하기 때문에 이벤트 처리 및 렌더링 루프에 대해 간략하게 이야기하겠습니다.

이 이론적 지식으로 무장한 우리는 악기에 뛰어들어 세 가지 다른 행 예제를 살펴볼 것입니다: 바쁜 메인 스레드 행, 비동기 행, 그리고 차단된 메인 스레드 행.

이들 각각에 대해, 나는 그것들을 인식하는 방법, 그것들을 분석할 때 무엇을 찾아야 하는지, 그리고 더 많은 것을 배우기 위해 문서에 다른 도구를 추가할 때를 아는 방법을 보여줄 것이다.

시작하기 전에: 이 세션의 일부에서는 악기에 다소 익숙해지는 것이 도움이 됩니다.

악기로 응용 프로그램을 프로파일링한 적이 있다면, 갈 수 있어야 합니다.

그렇지 않으면, 2019년 세션인 "악기 시작하기"를 확인하세요. 교수형을 다룰 때: 보통 세 단계가 있다.

당신은 중단을 찾은 다음, 그것이 어떻게 일어나는지 이해하기 위해 중단을 분석한 다음, 그것을 고치고, (그리고 그것이 실제로 고쳐졌는지 확인합니다).

오늘 우리는 당신이 이미 문제를 발견하고 분석 부분에 집중하고 몇 가지 수정 사항을 논의했다고 가정할 것입니다.

중단을 찾는 것에 대해 더 알고 싶다면, WWDC22의 "Track down hangs with Xcode and on-device detection" 세션을 살펴보세요.

iOS 개발자 설정에서 활성화할 수 있는 Instruments, On-device Hang Detection 및 Xcode Organizer를 포함하여 중단을 찾기 위한 모든 도구를 다룹니다.

오늘, 우리는 이미 찾은 행을 분석하기 위해 도구를 사용할 것이다.

교수형을 더 잘 이해하기 위해, 인간의 인식에 대해 이야기하고 불을 켜 봅시다.

우리는 전구와 케이블이 필요해.

아, 훨씬 나아.

램프가 그래야 하는 것처럼, 내가 케이블을 꽂았을 때 켜졌다.

그리고 내가 그것을 다시 꺼내면, 그것은 꺼진다. 즉시.

하지만 지연이 있었다면 어땠을까?

내가 꽂았어.

그리고 여기서 켜는 데 시간이 좀 걸렸다.

더 이상하게도, 내가 케이블을 다시 꺼낼 때도 같은 일이 일어난다.

케이블이 꽂혀 있는 것과 불이 켜지는 것 사이의 지연은 500밀리초에 불과했다.

하지만 그것은 이미 이 상자 안에서 무슨 일이 일어나고 있는지 궁금하게 만든다.

램프가 직접 켜지고 꺼지지 않는 것은 옳지 않다고 느낀다.

하지만, 다른 상황에서는, 500밀리초의 지연이 괜찮을 수도 있다.

어떤 종류의 지연이 허용되는지는 상황에 따라 다르다.

당신이 다음과 같은 대화를 엿들었다고 가정해 봅시다: "거북은 어떻게 소통하나요?"

"쉘폰."

여기서, 우리는 질문과 답변 사이에 1초의 지연이 있었다.

그리고 그건 완전히 자연스럽게 느껴졌어.

하지만 이건 아니야: 왜 그래?

거북이와 유니콘 사이의 대화는 요청-반응 스타일의 상호 작용이지만, 램프를 꽂는 것은 실제 물체를 직접 조작하는 것이다.

실제 물체는 즉시 반응한다.

우리가 진짜를 시뮬레이션한다면, 그것은 또한 즉시 반응해야 한다.

그렇지 않으면, 그것은 환상을 깨뜨린다.

당신은 케이블이 꽂혀 있는 것과 불이 켜지는 사이에 지연이 없었을 때 내가 여기에 실제 램프를 가지고 있다고 주장하는 데 아무런 문제가 없었습니다.

하지만 상당한 지연이 있을 때, 당신의 뇌는 갑자기 "잠시만요, 그것은 이 물건이 작동하는 방식이 아닙니다."라고 말합니다.

하지만 인스턴트는 얼마나 빠른가요?

우리가 눈치채지 못할 만큼 작은 지연은 무엇인가요?

여기 지연 없이 우리의 기준이 있습니다.

100ms는 어때?

나에게, 나는 그것을 켤 때 약간의 지연을 알아차린 것처럼 느껴졌지만, 그것을 끌 때가 아니라, 내가 자세히 볼 때만.

네 경험은 다를 수도 있어.

100ms는 다소 임계값이다.

상당히 작은 지연은 더 이상 인지할 수 없다.

250ms를 시도해 보자.

250ms는 더 이상 즉각적으로 느껴지지 않는다.

느리지는 않지만, 지연은 확실히 눈에 띄다.

이러한 종류의 인식 임계값은 또한 우리의 교수형 보고를 알려준다.

버튼을 누르는 것과 같은 개별적인 상호 작용에 대해 약 100ms 미만의 지연은 보통 즉각적으로 느껴질 것이다.

당신이 그 아래로 가고 싶을 수도 있는 몇 가지 특별한 경우가 있지만, 그것은 목표로 삼기에 좋은 목표입니다.

그 위에, 그것은 상황에 달려 있다.

250ms까지, 당신은 그것에서 벗어날 수 있습니다.

그것보다 더 길면 적어도 무의식적으로 눈에 띄게 된다.

그것은 지속적인 스케일이지만, 250ms 이상으로, 확실히 더 이상 즉각적으로 느껴지지 않는다.

그래서 우리의 대부분의 도구는 기본적으로 250ms부터 시작하여 중단을 보고하기 시작하지만, 우리는 무시하기 쉽기 때문에 이것을 "마이크로 중단"이라고 부릅니다.

문맥에 따라, 그것들은 괜찮을 수도 있지만, 종종 그렇지 않다.

500ms 이상의 모든 것은 적절한 교수형이라고 생각한다.

이를 바탕으로, 우리는 대략 이러한 임계값을 사용할 수 있습니다: 즉각적인 느낌을 원한다면, 100ms 이하의 지연을 목표로 하세요.

요청-응답 스타일의 상호 작용이 있다면, 추가 피드백 없이 500ms가 괜찮을 수 있습니다.

하지만 사실, 우리는 종종 둘 다 상호 작용한다.

예를 들어 봅시다.

저는 방금 이 세션을 준비하는 데 도움을 준 모든 동료들에게 이 이메일을 작성했고 그것을 보낼 준비가 되었습니다.

나는 마우스를 보내기 버튼으로 옮기고 그것을 클릭하고 잠시 후, 이메일 창이 전송되고 있음을 나타내기 위해 애니메이션으로 나타난다.

여기서 일어난 일은 당신이 실제로 두 가지 일이 일어나는 것을 보았다는 것입니다.

먼저, 버튼이 강조 표시되었고, 그 다음에는 500ms의 작은 지연이 있었고, 그 다음에는 이메일 창이 활성화되었다.

하지만 버튼 강조 표시로 인해 요청이 접수되었다는 것을 이미 알고 있었기 때문에 이 지연은 괜찮다고 느꼈다.

우리는 버튼을 "실제"로 취급하며 "실제" 시간에 즉시 업데이트될 것으로 기대합니다.

그래서 인터페이스의 실제 UI 요소의 경우, 우리는 보통 이 "즉시" 업데이트를 목표로 하고 싶습니다.

UI 요소가 "즉시" 반응할 수 있도록 하려면 메인 스레드를 UI가 아닌 작업에서 벗어나게 하는 것이 중요합니다.

그 이유를 알아보기 위해, 이벤트 처리 및 렌더링 루프를 자세히 살펴보고 Apple 플랫폼에서 이벤트가 어떻게 처리되는지, 그리고 사용자 입력이 어떻게 화면 업데이트로 이어지는지 봅시다.

어느 시점에서, 누군가는 장치와 상호 작용할 것이다.

우리는 그것이 언제 일어날지 통제할 수 없다.

첫째, 보통 마우스나 터치스크린과 같은 일부 하드웨어가 관련되어 있다.

그것은 상호 작용을 감지하고, 이벤트를 만들고, 운영 체제로 보냅니다.

운영 체제는 이벤트를 처리해야 하는 프로세스를 파악하고 예를 들어 앱과 같은 해당 프로세스로 전달합니다.

앱에서, 이벤트를 처리하는 것은 앱의 메인 스레드의 책임이다.

이것은 대부분의 UI 코드가 실행되는 곳입니다.

그것은 UI를 업데이트하는 방법을 결정한다.

그런 다음 이 UI 업데이트는 개별 UI 레이어를 합성하고 다음 프레임을 렌더링하는 별도의 프로세스인 렌더링 서버로 전송됩니다.

마지막으로, 디스플레이 드라이버는 렌더링 서버에서 준비한 비트맵을 선택하고 그에 따라 화면의 픽셀을 업데이트합니다.

이것이 어떻게 작동하는지에 대해 더 알고 싶다면, 우리는 "앱 반응성 개선" 아래의 문서에서 이것을 다룹니다. 우리에게, 이 대략적인 개요는 무슨 일이 일어나고 있는지 이해하기에 충분하다.

이제, 이 시간 동안 다른 이벤트가 들어오면, 보통 병렬로 처리될 수 있다.

하지만, 단일 이벤트가 파이프라인을 통해 어떻게 이동하는지 살펴본다면, 우리는 여전히 모든 단계를 순서대로 살펴볼 필요가 있다.

메인 스레드에 도달하기 전의 이벤트 처리 단계와 렌더링 및 업데이트 표시 단계는 일반적으로 기간에서 상당히 예측 가능합니다.

상호 작용에서 상당한 지연이 발생할 때, 그것은 거의 항상 메인 스레드의 부분이 너무 오래 걸렸거나 이벤트가 들어올 때 다른 것이 여전히 메인 스레드에서 실행되고 있기 때문에 이벤트가 처리되기 전에 완료될 때까지 기다려야 합니다.

UI 요소에 대한 모든 업데이트는 메인 스레드에서 약간의 시간이 필요하다는 점을 감안할 때, 우리는 이러한 업데이트가 100ms 이내에 실제처럼 느껴지기를 원하며, 이상적으로는 메인 스레드에서 100ms 이상의 작업이 걸리지 않아야 합니다.

네가 더 빨라질 수 있다면, 더 나아질 수 있어.

메인 스레드에서 장기간 실행되는 작업도 히치를 유발할 수 있으며, 히치를 피하기 위해 더 낮은 임계값이 적용됩니다.

테크 토크 "UI 애니메이션 히치 및 렌더링 루프 탐색"과 "앱 반응성 향상"에 대한 문서에서 히치에 대한 자세한 내용을 찾을 수 있습니다.

오늘, 우리는 교수형에 집중한다.

내 동료 중 한 명이 새로운 기능을 작업하는 동안 우리 앱 중 하나인 Backyard Birds에서 매달려 있는 것을 발견했다.

인스트루먼트로 앱을 프로파일링해 봅시다.

여기에 앱이 있는 Xcode 프로젝트가 있습니다.

인스트루먼트에서 앱을 프로파일링하기 위해 해야 할 일은 제품 메뉴를 클릭한 다음 프로필을 클릭한 다음 Xcode가 앱을 빌드하고 장치에 설치하지만 실행하지는 않습니다.

Xcode는 또한 Instruments를 열고 Xcode에서 구성된 동일한 앱과 장치를 대상으로 구성합니다.

인스트루먼트의 템플릿 선택기에서, 저는 타임 프로파일러 템플릿을 선택할 것입니다. 이는 당신이 무엇을 찾고 있는지 아직 모르고 앱이 무엇을 하고 있는지 더 잘 이해하고 싶다면 종종 좋은 출발점이 됩니다.

이것은 타임 프로파일러 템플릿에서 새로운 악기 문서를 만듭니다.

무엇보다도, 이 새로운 문서에는 Time Profiler 도구와 Hangs 도구가 포함되어 있으며, 둘 다 우리의 분석에 유용할 것이다.

도구 모음의 왼쪽 상단에 있는 녹음 버튼을 클릭하여 녹음을 시작합니다.

악기는 구성된 애플리케이션을 실행하고 데이터 캡처를 시작합니다.

그래서 여기 뒷마당 새 앱이 있어.

나는 세부 보기로 가기 위해 첫 번째 정원을 탭한다.

잠시 후에 "배경 선택" 버튼을 탭하면, 하단 시트가 나타나서 선택할 수 있는 배경 사진을 보여줘야 합니다.

내가 지금 그걸 하게 해줘.

버튼을 눌렀지만 막힌 것 같다.

시트가 나타나는 데 꽤 오랜 시간이 걸렸다.

심각한 교수형.

악기는 이 모든 것을 기록하고 있다.

도구 모음에서 중지 버튼을 클릭하여 녹음을 중지할 것입니다.

악기도 교수형을 감지했다.

그것은 중단 기간을 측정하고 심각도에 따라 해당 간격에 라벨을 붙입니다.

이 경우, 악기는 우리에게 "심각한 행"이 일어났다는 것을 보여준다.

이것은 우리가 앱을 사용하는 동안 경험하고 있는 것에도 맞습니다.

악기는 반응하지 않는 메인 스레드를 감지하고 해당 간격을 잠재적인 중단으로 표시합니다.

우리의 경우, 실제로 교수형 사건이 발생했다.

반응하지 않는 메인 스레드에는 두 가지 주요 사례가 있다.

가장 간단한 경우는 메인 스레드가 여전히 다른 일을 하느라 바쁘다는 것이다.

이 경우, 메인 스레드는 많은 CPU 활동을 보여줄 것이다.

다른 경우는 메인 스레드가 차단되었다는 것이다.

이것은 보통 메인 스레드가 다른 곳에서 다른 작업이 완료되기를 기다리고 있기 때문이다.

스레드가 차단되면 메인 스레드에서 CPU 활동이 거의 또는 전혀 없을 것이다.

어떤 경우에 무슨 일이 일어나고 있는지 결정하기 위해 다음에 어떤 단계를 취해야 하는지 결정합니다.

악기로 돌아가서, 우리는 메인 스레드를 찾아야 할 것이다.

문서의 마지막 트랙은 우리의 목표 프로세스에 대한 트랙을 보여준다.

서브트랙이 있다는 것을 나타내기 위해 왼쪽에 작은 공개 지표가 있다.

나는 그 과정에서 각 스레드에 대한 별도의 트랙을 표시하기 위해 그것을 클릭한다.

그런 다음, 여기서 메인 스레드 트랙을 선택하겠습니다.

이것은 또한 프로필 보기를 보여주기 위해 세부 영역을 업데이트하며, 이는 전체 녹음 시간 동안 메인 스레드에서 실행된 모든 함수의 호출 트리를 보여줍니다.

하지만 우리는 중단 중에 일어난 일에만 관심이 있기 때문에, 컨텍스트 메뉴를 표시하기 위해 타임라인에서 중단 간격을 보조로 클릭합니다.

여기서 검사 범위 설정을 선택할 수 있지만, 대신 검사 범위 설정과 줌을 얻기 위해 옵션 키도 길게 누를 것입니다.

이것은 간격의 범위를 확대하고 세부 정보 보기에 표시된 데이터를 선택한 시간 범위로 필터링합니다.

CPU 사용량은 전체 중단 간격 동안 100%는 아니지만, 여전히 상당히 높으며, 대부분의 경우 60%에서 90%의 CPU 사용량이다.

이것은 분명히 바쁜 메인 스레드의 경우이다.

이 모든 CPU 작업이 무엇인지 알아봅시다.

우리는 지금 콜 트리의 모든 다른 노드를 자세히 살펴볼 수 있다.

하지만 오른쪽에는 훌륭한 요약이 있습니다: 가장 무거운 스택 추적 보기.

가장 무거운 스택 추적 보기에서 프레임을 클릭하면, 호출 트리 보기가 업데이트되어 이 노드를 공개합니다.

이것은 또한 이 메소드 호출이 이미 호출 트리에 꽤 깊이 있다는 것을 보여준다.

기본적으로 가장 무거운 스택 추적은 소스 코드에서 유래하지 않은 후속 함수 호출을 숨겨 소스 코드가 어디에 관련되어 있는지 더 쉽게 볼 수 있도록 합니다.

하단 막대의 통화 트리 버튼을 클릭하고 시스템 라이브러리 숨기기 확인란을 활성화하여 통화 트리 보기에 유사한 필터를 적용할 수 있습니다.

이것은 시스템 라이브러리에서 모든 기능을 걸러내고 코드에 더 쉽게 집중할 수 있게 해준다.

콜 트리 뷰는 거의 모든 백트랙이 "BackgroundThumbnailView.body.getter" 호출을 포함하고 있음을 보여줍니다.

우리가 우리 몸을 더 빨리 만들어야 하는 것 같아, 그렇지?

그렇지 않아!

그래서 우리는 바쁜 메인 스레드 케이스가 있다는 것을 알고 있습니다. 즉, CPU가 많은 일을 하고 있다는 것을 의미합니다.

우리는 또한 많은 CPU 시간을 소비하는 방법을 찾았다.

하지만 지금은 두 가지 다른 사례가 있다.

우리는 이 방법 자체가 오랫동안 실행되기 때문에 이 방법에 많은 CPU 시간을 할애할 수 있다.

하지만 그것은 또한 그것이 여러 번 불릴 수도 있고, 그것이 여기에 나타나는 이유이다.

메인 스레드에 대한 작업을 어떻게 줄여야 하는지는 우리가 어떤 경우를 가지고 있는지에 달려 있다.

전형적인 콜 스택은 이렇게 구성되어 있다.

일부 UI 프레임워크와 다른 많은 것들을 호출하는 메인 함수의 호출이 있으며, 어느 시점에서 코드가 호출됩니다.

이 함수가 한 번만 호출되고 하나의 호출이 여기에 있는 터틀 함수처럼 시간이 오래 걸린다면, 우리는 그것이 무엇을 호출하는지 보고 싶습니다.

아마 그건 많은 일을 할 거야. 그러면 우리는 아마 그걸 덜 할 수 있을 거야.

하지만 우리가 조사하고 있는 방법은 여기 유니콘처럼 자주 불릴 수도 있다.

그리고 나서, 물론, 그것이 하는 일은 계속해서 반복된다.

이것은 보통 함수인 유니콘을 호출하는 발신자가 많기 때문입니다. 예를 들어 루프에서.

집중된 기능인 유니콘이 하는 일을 최적화하는 것보다, 우리가 어떻게 그것을 덜 자주 부를 수 있는지 조사하는 것이 더 유익할 수 있다.

그것은 우리가 다음에 봐야 할 방향이 우리가 가지고 있는 경우에 달려 있다는 것을 의미한다.

우리의 터틀 케이스와 같은 장기 실행 기능을 위해, 우리는 그것의 구현과 발신자를 살펴보고 싶다.

우리는 더 아래를 봐야 해.

그러나, 유니콘처럼 함수가 많이 호출된다면, 그것을 부르는 것을 살펴보고 우리가 그렇게 덜 자주 할 수 있는지 결정하는 것이 더 유익하다.

우리는 더 멀리 봐야 해.

하지만 타임 프로파일러는 우리가 어떤 경우를 가지고 있는지 말해줄 수 없다.

유니콘과 거북이에 대한 전화가 바로 다음에 일어났다고 가정해 봅시다.

시간 프로파일러는 정기적으로 CPU에서 실행 중인 것을 확인하여 데이터를 수집합니다.

그리고 각 샘플에 대해, 현재 CPU에서 어떤 기능이 실행되고 있는지 확인합니다.

이 예에서, 우리는 거북이와 유니콘을 네 번 얻을 것이다.

하지만 이것은 매우 빠른 거북이일 수도 있고, 유니콘은 훨씬 더 오래 걸리거나 다른 조합이 될 수도 있다.

이 모든 시나리오는 타임 프로파일러에서 동일한 데이터를 생성할 것이다.

특정 함수의 실행 시간을 측정하려면, os_signposts를 사용하세요.

우리는 2019년 세션인 "도그루먼트 시작하기"에서 그렇게 하는 방법에 대해 이야기했습니다.

무슨 일이 일어나고 있는지 정확하게 알려줄 수 있는 다양한 기술을 위한 전문 도구도 있습니다.

그 중 하나는 SwiftUI View 바디 악기이다.

SwiftUI 바디 악기를 추가하려면, 도구 모음의 오른쪽 상단에 있는 더하기 버튼을 클릭합니다.

이것은 악기 라이브러리를 보여준다.

이것은 악기 응용 프로그램이 제공해야 하는 모든 악기의 목록입니다.

많이 있어.

당신은 심지어 당신만의 맞춤 악기를 쓸 수도 있습니다.

필터 필드에 "SwiftUI"를 입력하면 두 개의 악기가 나타납니다.

"바디 보기" 도구를 선택하고 문서 창으로 드래그하여 추가하겠습니다.

이제, 이 악기는 우리가 마지막으로 기록했을 때 문서에 없었기 때문에, 표시할 데이터가 없습니다.

하지만 문제 없어. 우리는 그냥 다시 녹음할 거야.

시간을 절약하기 위해, 나는 이미 그것을 했다.

문서에서 SwiftUI View Body 악기로 기록한 후, View Body 트랙도 이제 일부 데이터를 보여줍니다.

SwiftUI 뷰 바디 트랙에는 많은 간격이 있다.

조금 비좁아서, Ctrl+Plus를 눌러 높이를 늘린다.

SwiftUI View Body 트랙은 구현된 라이브러리에 따라 간격을 그룹화합니다.

각 간격은 하나의 뷰 본문 실행이다.

우리 행을 다시 확대하자.

두 번째 차선에는 "BackgroundThumbnailView"라고 표시된 많은 주황색 간격이 있습니다.

이것은 우리에게 얼마나 많은 신체 처형이 있었는지 그리고 각각 얼마나 오래 걸렸는지 정확히 말해준다.

주황색은 특정 본문 실행의 런타임이 우리가 SwiftUI로 목표로 하는 것보다 조금 더 오래 걸렸다는 것을 나타냅니다.

하지만 더 큰 문제는 간격이 얼마나 많은 것 같다.

세부 보기에는 모든 신체 간격에 대한 요약이 있습니다.

Backyard Birds 옆에 있는 공개 표시기를 클릭하면 Backyard Birds의 개별 보기 유형을 표시할 수 있습니다.

이것은 BackgroundThumbnailView의 본문이 약 50밀리초의 평균 지속 시간으로 70번 실행되어 총 3초가 넘는 것으로 이어진다는 것을 보여준다.

이것은 우리의 거의 모든 중단 기간을 설명한다.

하지만 우리가 앞에 여섯 개의 이미지만 보여줄 필요가 있을 때 70번은 과도해 보인다.

이것은 몸을 덜 자주 불러야 하는 경우이기 때문에, 우리는 왜 이렇게 자주 불리는지 알아내기 위해 우리 몸의 발신자를 살펴보고 그것을 줄이는 방법을 살펴볼 필요가 있다.

관련 코드로 쉽게 이동하려면, 메인 스레드 트랙을 다시 선택하고, 호출 트리에서 BackgroundThumbnailView.body.getter 노드를 보조로 클릭하여 상황에 맞는 메뉴를 표시하고, "Xcode에서 표시"를 선택합니다.

이것은 Xcode에서 바로 우리의 신체 구현을 엽니다.

유형을 보조로 클릭하고 "찾기", "작업 공간에서 선택한 기호 찾기"를 선택하여 이 보기가 어떻게 사용되는지 알아봅시다.

탐색기 찾기의 첫 번째 결과는 이미 우리가 찾고 있는 것이다.

여기서, 우리의 "BackgroundThumbnailView"는 그리드 내부의 다른 ForEach 내부의 GridRow 내부의 ForEach 내부에서 사용됩니다.

그리드는 생성될 때 전체 콘텐츠를 열심히 계산하므로, 처음 몇 개만 필요하더라도 모든 배경 썸네일을 계산할 것이다.

하지만 대안이 있다: LazyVGrid.

그것은 하나의 화면을 채우는 데 필요한 만큼의 보기만 계산한다.

SwiftUI의 많은 뷰에는 필요한 만큼의 뷰만 계산하는 게으른 변형이 있으며, 이는 종종 작업을 덜 할 수 있는 쉬운 방법이 될 수 있습니다.

그러나, 열망하는 변형은 동일한 내용을 렌더링해야 할 때 훨씬 적은 메모리를 사용한다.

기본적으로 정기적인 열성적인 변형을 사용하고 너무 많은 작업을 미리 하는 것과 관련된 성능 문제를 발견하면 게으른 변형으로 전환하십시오.

"SwiftUI의 스택, 그리드 및 개요"에 대한 WWDC 2020의 WWDC 세션은 이러한 게으른 변형을 소개하고 더 자세히 설명합니다.

이 업데이트된 코드를 프로파일링해 봅시다.

배경 선택 버튼을 다시 탭하여 재생을 녹음하고 재현합니다.

이제, 이게 훨씬 나아.

여전히 약간의 지연이 있었지만, 이전만큼 나쁘지는 않았다.

악기는 이것을 확인한다.

우리가 기록한 행은 이제 400밀리초도 채 걸리지 않았다.

그건 마이크로 행이야.

"View Body" 트랙은 또한 우리가 이제 우리의 기대에 맞는 8개의 BackgroundThumbnail 바디 실행만 얻었다는 것을 보여준다.

아마 이거면 충분할 거야.

마이크로행은 그다지 눈에 띄지 않는다.

iPad에서 Backyard Birds를 프로파일링하여 다른 장치 유형에서도 잘 작동하는지 확인해 봅시다.

여기, 나는 아이패드로 뒷마당 새들을 운영하고 있어.

난 이미 디테일 뷰에 있어.

"배경 선택" 버튼을 누르면 시트가 나타나는 데 오랜 시간이 걸립니다.

일단 그것이 나타나면, 우리는 이유를 알 수 있다.

화면이 더 크고 공간이 더 많기 때문에 이제 더 많은 썸네일이 있습니다.

악기들도 이 교수형을 녹음했다.

검사 범위를 중단 간격에 집중하면, 더 많은 BackgroundThumbnailView 바디를 다시 볼 수 있습니다.

말이 되네.

이제 우리는 화면에 더 많이 맞는 전체 화면을 위해 약 40개를 렌더링해야 합니다.

그래서 같은 코드는 iPhone에서 대부분 잘 수행되었지만 iPad에서는 화면이 더 컸기 때문에 느렸다.

이것이 당신이 마이크로 행을 고쳐야 하는 이유 중 하나입니다.

책상에서 테스트하는 동안 마이크로 행으로 볼 수 있는 것은 다른 조건에서 일부 사용자에게 주요 행이 될 수 있습니다.

우리는 이제 화면을 채우는 데 필요한 만큼의 뷰만 렌더링하기 때문에, 이것을 덜 자주 호출하는 측면에서 최적화 잠재력을 소진했습니다.

각 개별 실행을 더 빠르게 하기 위해 우리가 무엇을 할 수 있는지 알아봅시다.

검사 범위를 단일 BackgroundThumbnailView 간격으로 설정하고 "메인 스레드" 트랙으로 다시 전환하겠습니다.

악기는 가장 무거운 백트레이스 뷰에서 우리의 뷰 바디 게터를 보여주고 그것이 "BackyardBackground.thumbnail" 속성 게터라고 부르는 것을 보여준다.

이것은 우리의 보기에 표시할 썸네일 이미지를 제공하는 모델 개체입니다.

이 썸네일 거터는 "UIImage imageByPreparingThumbnailOfSize:"라고 부릅니다.

그래서 우리는 여기서 즉석에서 썸네일을 계산하는 것 같다.

그건 시간이 좀 걸릴 수 있어. 이 경우, 약 150밀리초.

이것은 우리가 백그라운드에서 해야 하고 메인 스레드를 바쁘게 하지 말아야 할 일이다.

우리가 어떤 변화를 만들 수 있는지 더 잘 이해하기 위해, 나는 썸네일 게터가 어떻게 불리는지 맥락을 보고 싶다.

가장 무거운 스택 추적 보기에서 "BackgroundThumbnailView.body.getter" 프레임을 클릭하고 "소스 뷰어에서 열기"를 선택합니다.

이것은 호출 트리 뷰를 우리 바디 게터의 구현을 보여주는 소스 뷰어로 대체하고 시간 프로파일러 샘플로 구현 라인에 주석을 달고 코드가 얼마나 많은 시간을 보냈는지 보여줍니다.

우리의 신체 구현은 여기서 정말 간단합니다; 그것은 배경에 의해 반환된 썸네일로 새로운 이미지 뷰를 만듭니다.

하지만 이 썸네일 통화는 시간이 오래 걸린다.

나는 그것을 다르게 쓰는 방법을 알고 있다.

Xcode로 이동하려면, 오른쪽 상단의 메뉴 버튼을 클릭하고 "Xcode에서 파일 열기"를 선택합니다.

이전과 마찬가지로, 이것은 변경할 준비가 된 Xcode의 소스 코드를 보여줍니다.

내가 지금 하고 싶은 것은 백그라운드에서 썸네일을 로드하는 것이고, 로딩이 진행되는 동안 진행률 표시기를 표시하는 것이다.

먼저, 로드된 썸네일을 유지하기 위해 상태 변수가 필요합니다.

그런 다음, 본문에서, 이미 로드된 이미지가 있다면, 이미지 보기에서 사용할 것입니다.

그렇지 않으면, 우리는 진행 상황을 보여준다.

이제 남은 것은 실제 썸네일을 로드하는 것뿐입니다.

우리는 우리의 견해가 나타나면 그것을 로딩하기 시작하고 싶다.

그것이 ".task" 수정자를 위한 것이다.

나타나면, SwiftUI는 "썸네일" 게터를 호출하고 결과를 "이미지"에 할당하여 보기를 업데이트하는 작업을 시작할 것입니다.

한 번 해보자!

그래서 여기, 악기 녹음과 함께, "배경 선택" 버튼을 누르면 시트가 바로 나옵니다!

좋아!

우리는 진행 지표를 보았고, 몇 초 후, 썸네일이 표시되었다.

이건 효과가 있었어. 좋아!

하지만 잠깐만, 악기는 여전히 거의 2초의 걸림을 보여주고 있어.

여기서 일어난 일은 그 행이 지금 약간 늦게 일어난다는 것이다.

뒷마당 새 앱에서 어디서 일어나는지 보여줄게.

난 이미 디테일 뷰에 있어.

잠시 후, "배경 선택" 버튼을 다시 탭한 다음 완료 버튼을 눌러 시트를 바로 닫으려고 시도하겠습니다.

좋아요, "배경 선택"과 "완료"

나는 여러 번 탭했지만, 로딩이 진행되는 동안, 내 탭은 무시되었다.

이것은 악기가 우리에게 말한 교수형이다.

그것은 시트가 표시된 후에 일어난다.

이것은 약간 다른 유형의 교수형이다.

우리는 이미 메인 스레드가 바쁘거나 차단되는 것의 차이점에 대해 이야기했다.

교수형을 보는 또 다른 방법이 있다; 그것들이 무엇에 의해 발생하고 언제 발생하는지.

우리는 이것을 동기식 및 비동기식 중단이라고 부른다.

여기, 우리는 몇 가지 일을 하는 주요 스레드가 있다.

만약, 이벤트가 들어올 때, 그 이벤트를 처리하는 데 오랜 시간이 걸린다면, 그것은 중단이다.

우리가 그것을 통제하고 우리의 사건이 빨리 처리되도록 한다고 가정해 봅시다.

하지만 우리는 나중에 메인 스레드에서 해야 할 작업을 연기했거나, 다른 메인 스레드 작업이 발생하고 이벤트가 들어올 수도 있습니다.

그러면 그 행사는 처리되기 전에 이전 작업이 완료될 때까지 기다려야 한다.

그러면 각 개별 이벤트 처리에 대한 코드가 빠르게 완료되더라도, 이것은 여전히 중단을 일으킨다.

우리 플랫폼에서 행 감지가 작동하는 방식은 메인 스레드의 모든 작업 항목을 보고 너무 긴지 확인하는 것입니다.

만약 그렇다면, 그것은 그들을 잠재적인 교수형으로 표시한다.

그리고 사용자 입력이 있었는지 여부에 관계없이 그렇게 합니다. 왜냐하면 사용자 입력은 언제든지 들어올 수 있고 우리는 실제 중단을 가질 수 있기 때문입니다.

이것은 중단 감지가 이러한 비동기 또는 지연된 경우를 감지한다는 것을 의미하지만, 실제로 경험한 지연이 아닌 잠재적인 지연만 측정합니다.

우리는 비동기 행을 비동기라고 부릅니다. 왜냐하면 그것들은 종종 메인 큐에서 "dispatch_async" 작업이나 메인 액터에서 비동기적으로 실행되는 Swift Concurrency 작업에 의해 발생하기 때문입니다.

하지만 그것들은 메인 스레드에서 작업을 유발하는 모든 것에 의해 발생할 수 있다.

우리가 처음 본 행은 동기식 행이었다.

우리는 버튼을 탭했고, 그 버튼을 탭하면 장기 실행 작업이 발생하므로 결과가 늦게 표시됩니다.

이 가장 최근의 행은 비동기적이거나 지연된 행이다.

완료 버튼을 탭하는 것은 실제로 그 자체로 비용이 많이 드는 작업을 일으키지 않습니다.

하지만 탭이 처리되는 것을 막는 메인 스레드에 대한 작업이 여전히 있었다.

따라서 앱을 사용하는 누군가가 이 시간 동안 앱과 상호 작용하지 않는지 알아차리지 못할 수도 있지만, 우리는 여전히 이러한 경우를 수정해야 합니다.

지금 그렇게 하자.

그래서 저는 악기로 돌아왔고 이미 선택 범위를 비동기 행으로 설정하고 확대했습니다.

뷰 바디 트랙의 요약 보기에서, 악기는 이제 BackgroundThumbnailView의 바디 게터에 75번의 호출이 있었다는 것을 보여준다.

이것은 대부분의 썸네일 바디 게터가 두 번 실행되기 때문이다.

SwiftUI는 그리드를 채우기 위해 진행 지표로 40개의 뷰를 만듭니다.

하지만 실제로 35개만 표시되고, 그 35개에 대해, 우리는 이미지를 로드하기 시작하고, 이미지가 로드되면, 보기가 업데이트되고 바디가 다시 호출되어 총 75개의 바디 게터 실행을 제공합니다.

심지어 총 75명의 바디 게터도 1밀리초도 채 걸리지 않았다.

그래서 우리 몸은 지금 빠르다. 그 부분은 효과가 있었어.

하지만 우리는 여전히 매달려 있어.

나는 "메인 스레드" 트랙을 다시 선택할 것이고 가장 무거운 스택트레이스 보기에서 인스트루먼트는 여전히 메인 스레드에서 오랜 시간이 걸리는 썸네일 게터라는 것을 보여준다.

이번에는 바디 게터가 아닌 "BackgroundThumbnailView.body.getter" 내부의 폐쇄로 불립니다.

나는 그것을 두 번 클릭하는데, 이는 소스 뷰어를 여는 바로 가기이다.

이제 이것은 정확히 작업 수정자 폐쇄로 인해 백그라운드에서 실행할 것으로 예상했던 코드입니다.

이 코드는 이 시간에 실행되어야 하지만, 메인 스레드에서 실행되어서는 안 됩니다.

Swift Concurrency 작업이 예상대로 실행되지 않는 이와 같은 문제에 대해, 우리는 또 다른 유용한 도구인 Swift Concurrency Tasks 도구를 가지고 있습니다.

나는 이미 Swift Concurrency 작업 도구가 추가된 것과 같은 동작을 기록했다.

Swift Tasks 도구는 문서에 요약 트랙을 추가하지만 우리의 경우에 더 흥미로운 것은 각 스레드 트랙에 기여하는 데이터입니다.

여기, 메인 스레드 트랙에는 스위프트 태스크 악기의 새로운 그래프가 있습니다.

하나의 트랙은 여러 그래프를 보여줄 수 있다.

스레드 트랙 헤더의 작은 아래쪽 화살표를 클릭하면 표시할 그래프를 구성할 수 있습니다.

타임 프로파일러의 CPU 사용량 그래프와 같은 다른 그래프를 선택하거나 Command 키를 누른 상태에서 클릭하여 여러 개를 선택할 수 있습니다.

그래서 이제 인스트루먼트는 이 스레드의 CPU 사용량과 스위프트 작업 그래프를 함께 보여주고 있다.

나는 우리의 행 간격을 다시 확대할 거야.

"Swift Tasks" 레인은 이제 메인 스레드에 많은 작업 실행이 있음을 명확하게 보여줍니다.

검사 범위를 그 중 하나로 설정하고 프로필 보기에서 가장 무거운 스택 추적을 확인하면 이 작업이 썸네일 계산 작업을 마무리하고 있음을 확인합니다.

그래서 이 작업은 우리가 원했던 작업으로 올바르게 포장되어 있다.

하지만 그 작업은 예상치 못한 메인 스레드에서 실행되고 있다.

여기서 무슨 일이 일어나고 있는지 설명하겠습니다.

먼저, 바디 게터는 SwiftUI의 뷰 프로토콜에서 @MainActor 주석을 상속합니다.

"Body"는 "View" 프로토콜에서 "@MainActor"로 주석이 달렸기 때문에, 우리가 그것을 구현할 때, 바디 게터는 @MainActor로 암시적으로 주석을 달았다.

둘째, ".task" 수정자의 폐쇄는 주변 컨텍스트의 액터 격리를 상속하기 위해 주석이 달린다.

그래서 바디 게터가 MainActor에 고립되어 있기 때문에, 작업도 마찬가지로 종료될 것이다.

따라서 이 클로저에서 실행되는 모든 코드는 기본적으로 메인 액터에서 실행되며, "썸네일" 게터는 동기적이기 때문에 이제 메인 스레드에서 동기적으로 실행됩니다.

스위프트 동시성 작업은 기본적으로 주변 컨텍스트의 액터 격리를 상속합니다.

SwiftUI의 .task 수정자에도 동일한 동작이 적용된다.

주연 배우에서 벗어나는 방법은 두 가지가 있다.

메인 액터에 바인딩되지 않은 함수를 비동기적으로 호출하면 작업이 메인 액터에서 벗어날 수 있습니다.

이것이 실현 가능하지 않은 경우가 있을 수 있다.

그런 다음, "Task.detached"를 사용하여 주변 배우 컨텍스트에서 작업을 명시적으로 분리할 수 있지만, 이는 무거운 접근 방식이며 별도의 작업을 만드는 것은 단순히 기존 작업을 일시 중지하는 것보다 더 비쌉니다.

SwiftUI는 또한 해당 보기가 사라질 때 작업 수정자를 통해 생성된 작업을 자동으로 취소하지만, 이 취소는 Task.detached와 같은 새로운 비정형 작업으로 전파되지 않습니다.

자세한 내용은 WWDC22의 "스위프트 동시성 시각화 및 최적화"와 앱 반응성 개선에 대한 문서를 확인하세요.

우리의 경우 우리는 이미 비동기 컨텍스트에 있고, 썸네일 함수를 분리되지 않고 비동기적으로 만드는 것이 쉽기 때문에, 우리는 옵션 하나를 선택할 것입니다.

여기 썸네일 로딩 코드가 있습니다.

문제는 이 작업이 바디 게터의 주요 배우 격리를 상속하기 때문에 주요 배우에게 실행될 것이며, 썸네일 게터가 동기적이기 때문에, 그것은 또한 주요 배우에 머무를 것이라는 것이다.

수정은 간단하다.

우리는 썸네일 거터의 정의로 이동하고, 거터를 비동기적으로 만든 다음, 보기 구조체로 돌아갑니다...

그리고 우리의 게터는 이제 비동기이기 때문에, 우리는 그 앞에 대기를 추가해야 한다.

이를 통해 "썸네일" 게터는 메인 스레드 대신 Swift Concurrency의 동시 스레드 풀에서 실행할 수 있습니다.

한 번 해보자.

저는 다시 세부 보기에 있고, "배경 선택"을 탭합니다.

와우. 그건 빨랐어!

매달리지 않았을 뿐만 아니라, 전반적인 로딩이 더 빠른 것처럼 보였다.

나는 진행 상황을 거의 보지 못했다.

악기는 지금 매달려 있지 않다는 것을 확인한다.

여기에 높은 CPU 사용량이 있다.

내가 그걸 확대해볼게.

여기가 지금 썸네일 로딩이 일어나는 곳이다.

메인 스레드를 확인하면, 메인 스레드의 모든 작업 간격이 이제 매우 짧다는 것을 확인할 수 있습니다.

다른 스레드 트랙으로 스크롤하면 스위프트 작업이 이제 순차적으로 실행되는 대신 다른 스레드에서 병렬로 실행되어 멀티코어 CPU를 훨씬 더 잘 사용할 수 있습니다.

이것은 우리가 거의 1.5초가 아닌 수백 밀리초 안에 모든 썸네일을 계산할 수 있게 해준다.

그리고 이 모든 시간 동안, 메인 스레드는 여전히 반응하기 때문에, 우리는 지금 이것을 영원히 수정했습니다.

우리는 이제 메인 스레드가 바빠서 발생하는 응답하지 않는 메인 스레드를 조사하고 수정했으며, 중단 중에 많은 CPU를 사용하여 메인 스레드로 식별할 수 있습니다.

우리는 또한 사용자 상호 작용 또는 비동기의 일부로 직접 발생할 때 중단이 어떻게 동기적일 수 있는지, 이전에 메인 스레드에서 예정된 작업으로 인해 들어오는 이벤트가 늦게 처리되고 Instruments가 두 경우를 모두 감지할 수 있는 방법을 경험했습니다.

그리고 우리는 일을 덜 하고 다른 일을 함으로써 백그라운드에서 덜 할 수 없고 UI를 업데이트하기 위해 메인 스레드로 돌아와서 중단을 해결했습니다.

하지만 우리가 아직 보지 않은 한 가지 사례가 있는데, 차단된 메인 스레드, 이 경우 메인 스레드는 CPU를 거의 사용하지 않을 것이다.

다른 치수는 차단된 메인 스레드에 같은 방식으로 적용되지만, 그러한 경우를 분석하기 위해서는 다른 도구가 필요하다.

이제 예를 들어 봅시다.

여기 다른 행의 추적 파일이 있습니다.

나는 이미 행을 확대했다. 그건 긴 거야; 몇 초.

"메인 스레드" 트랙에서 CPU 사용량 그래프는 초기 CPU 사용량이 있지만 아무것도 없다는 것을 보여줍니다.

이것은 차단된 메인 스레드의 명백한 경우이다.

우리는 Time Profiler가 CPU에서 실행되는 것을 샘플링하여 데이터를 수집하는 방법에 대해 이야기했습니다.

우리가 확대할 때, CPU 사용량 그래프는 심지어 개별 샘플을 보여준다.

그래서 여기 있는 각 마커는 타임 프로파일러가 찍은 샘플이다.

오른쪽에 샘플이 몇 개 더 있지만, 아무것도 없다.

하지만 샘플이 없는 시간 범위를 선택할 때, 시간 프로파일러는 이 시간 동안 어떤 데이터도 기록하지 않았기 때문에 무슨 일이 일어나고 있는지 말할 수 없습니다.

그래서 우리는 다른 도구가 필요하다: 스레드 스테이트 도구.

이전의 다른 악기와 마찬가지로, 악기 라이브러리에서 추가할 수 있습니다.

나는 이미 같은 행을 다시 녹음했는데, 이번에는 "스레드 상태 추적" 악기가 추가되었다.

이제 이 악기를 위한 새로운 트랙이 있다.

하지만 "Swift Concurrency" 악기처럼, 우리에게 흥미로운 데이터는 실제로 "스레드" 트랙에 있다.

그래서 여기 메인 스레드에는 6초가 넘는 정말 긴 "차단된" 간격이 있으며, 이는 대부분의 중단 시간을 설명합니다.

중간에 클릭하면, 악기의 시간 커서가 그곳으로 이동하며, 이 차단된 상태에 대한 항목을 보여주기 위해 세부 영역의 내러티브 보기를 업데이트합니다.

내러티브 뷰는 우리에게 스레드의 이야기를 들려준다; 그것이 무엇을 하고 있었는지, 언제, 그리고 왜.

선택한 시간 동안, 스레드가 6.64초 동안 차단되었고 syscall인 mach_msg2_trap을 호출했기 때문에 차단되었다고 알려줍니다.

오른쪽에, 다시 뒷모습이 있다.

하지만 이 뒷추적은 가장 무거운 뒷추적이 아니다-- 그것은 어떤 집단이 아니다.

스레드가 차단된 것은 mach_msg2_trap syscall의 정확한 역추적이다.

함수 호출은 하단의 리프 노드로 표시되고 호출 스택은 위에 표시됩니다.

콜 스택은 syscall이 MLModel을 할당한 결과로 발생했으며, 이는 차례로 "ColorizingService" 유형의 객체를 할당하여 발생했으며, 이는 컬러화 서비스에서 "공유"라는 싱글톤 속성의 일부로 호출되었으며, 이는 차례로 바디 게터의 폐쇄에 의해 호출되었습니다.

그 클로저를 두 번 클릭하면, 소스 뷰어로 다시 이동하고 이것이 호출된 코드를 찾을 수 있습니다.

이 라인은 무해해 보여, 그렇지?

좀 더 자세히 살펴보자.

우리는 ColorizingService의 공유 자산에 액세스하여 로컬 변수에 저장하고 있습니다.

공유 속성이 처음 액세스할 때 공유 ColorizingService 인스턴스를 만들고 차례로 스레드를 차단하는 전체 모델 로딩 기계를 시작하기 때문에 무해하지 않습니다.

그래서 당신은 "'기다림' 후에 이것을 비동기 부분 안으로 옮기자"라고 말하고 싶은 유혹을 받을 수 있습니다.

그러나, 반직관적으로, 이것은 문제를 해결하지 못한다.

"Await" 키워드는 후속 코드의 비동기 함수 호출에만 적용됩니다.

우리의 예에서 "컬러화" 함수는 "비동기"이다.

하지만 "공유" 재산은 그렇지 않다.

정적 let 속성이기 때문에, 처음 액세스할 때 게으르게 초기화되며 동시에 발생합니다.

Await 키워드는 그것을 바꾸지 않으므로, 동기 호출은 여전히 메인 스레드에서 발생할 것이다.

우리는 주요 배우에서 벗어나기 위해 공유 속성을 "비동기"로 만들어 이전 예에서 했던 것과 같은 방식으로 이것을 고칠 수 있습니다.

이것은 일반적으로 진행이 이루어지는 다른 곳에서 스레드를 대신하여 작업을 기다릴 때 괜찮습니다.

그러나, 막힌 스레드의 또 다른 일반적인 이유는 자물쇠나 세마포이다.

명심해야 할 모범 사례와 Swift concurrency와 함께 잠금과 세마포를 사용할 때 피해야 할 것은 WWDC 21의 "Swift concurrency: Behind the scenes" 세션을 시청하세요.

마무리하기 전에, 차단된 메인 스레드와 관련된 다른 사례에 대해 이야기하고 싶습니다.

여기 우리가 조금 전에 살펴본 흔적이 있습니다.

오른쪽은 우리가 막힌 메인 스레드로 방금 조사한 걸림이다.

하지만 왼쪽에는 메인 스레드가 몇 초 동안 차단되는 다른 경우가 있지만, Instruments는 이것을 잠재적인 중단으로 표시하지 않습니다.

여기서, 메인 스레드는 사용자 입력이 없었기 때문에 그냥 잠들어 있다.

운영 체제의 관점에서 볼 때, 그것은 차단되었지만, 할 일이 없을 때 실행하지 않음으로써 자원을 절약하는 것이다.

입력이 들어오자마자, 그것은 깨어나서 처리할 것이다.

따라서 차단된 스레드가 반응성 문제인지 아닌지 확인하려면, 스레드 상태 기기가 아닌 행스 기기를 보세요.

따라서 차단된 메인 스레드는 응답하지 않는 메인 스레드를 의미하지 않는다.

마찬가지로, 높은 CPU 사용량은 메인 스레드가 응답하지 않는다는 것을 의미하지 않는다.

하지만 메인 스레드가 응답하지 않는다면, 그것은 차단되었거나 메인 스레드가 바쁘다는 것을 의미합니다.

우리의 중단 감지는 이러한 모든 세부 사항을 고려하고 메인 스레드가 실제로 반응하지 않는 간격에만 라벨을 붙이고 잠재적인 중단으로 보여줄 것입니다.

이 세션에서 한 가지만 기억한다면, 다음과 같이 하십시오: 메인 스레드에서 어떤 작업을 하든, 이벤트 처리를 위해 메인 스레드를 다시 해제하려면 100밀리초 이내에 완료되어야 합니다.

짧을수록 좋다.

자세히 분석하기 위해, 악기는 당신의 가장 친한 친구입니다.

바쁜 메인 스레드와 차단된 메인 스레드의 차이를 기억하고 메인 스레드의 비동기 작업으로 인해 중단이 발생할 수 있다는 것을 기억하십시오.

중단을 고치기 위해, 당신은 일을 덜 하거나 작업을 배경으로 옮기고 싶습니다.

가끔, 심지어 둘 다.

그리고 일을 적게 하는 것은 그 일에 적합한 API를 사용하는 것을 의미한다.

일반적으로, 먼저 측정하고 최적화하기 전에 실제로 중단이 있는지 확인하세요.

확실히 몇 가지 모범 사례가 있지만, 동시 및 비동기 코드도 디버깅하기가 훨씬 더 어렵다.

당신은 종종 실제로 매우 빠르고 실제로 느려지는 모든 것에 놀랄 것입니다.

모든 걸림을 찾고, 분석하고, 고치는 것을 즐기세요.

봐줘서 고마워.

♪ ♪