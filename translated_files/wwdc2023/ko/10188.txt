10188

♪ ♪

팀: 안녕하세요, 저는 팀입니다, 저는 CloudKit 팀의 엔지니어입니다.

제 동료 Aamer와 저는 CKSyncEngine이라는 새로운 CloudKit API에 대해 이야기하기 위해 왔습니다.

CKSyncEngine은 장치와 클라우드 간에 데이터를 동기화할 수 있도록 설계되었습니다.

먼저, Apple 플랫폼에서 CloudKit과 동기화하는 상태에 대해 이야기하겠습니다.

다음으로, CKSyncEngine이 무엇이며 어떻게 작동하는지에 대한 개요를 제공하겠습니다.

그런 다음, 자신의 프로젝트에서 CKSyncEngine을 시작하는 방법에 대해 배우게 될 것입니다.

설정이 완료되면, 동기화 엔진을 사용하여 장치 간에 데이터를 동기화하는 방법을 배우게 될 것입니다.

마지막으로, CKSyncEngine과의 통합을 테스트하고 디버깅하기 위한 모범 사례에 대해 배우게 될 것입니다.

먼저, CloudKit과 동기화하는 상태.

새로운 앱을 만들 때, 사람들은 데이터가 동기화되기를 기대합니다.

그들은 아이폰으로 무언가를 만들고, 맥을 열면, 그것도 거기에 있을 것으로 예상한다.

외부에서 보면, 이것은 마법처럼 보인다.

그들의 데이터는 한 곳에 있고, 어디에나 있다.

너와 나에게는 그렇게 쉽지 않아.

CloudKit 자체는 그렇게 복잡하지 않지만, 일반적으로 동기화는 어렵다.

시나리오에 여러 장치를 가져올 때, 잘못될 수 있는 것이 많다.

그래서 동기화 코드를 더 간단하게 만들수록 더 좋습니다.

그리고 동기화 코드를 단순화하는 가장 좋은 방법은 가능한 한 적게 작성하는 것입니다.

고맙게도, 당신은 CloudKit과 동기화하기 위한 몇 가지 훌륭한 API 선택이 있으며, 이 API는 당신을 위해 많은 힘든 일을 합니다.

로컬 지속성을 포함하는 풀스택 솔루션을 원한다면, NSPersistentCloudKitContainer를 사용할 수 있습니다.

자신만의 로컬 지속성을 가져오고 싶다면, 새로운 CKSyncEngine API를 사용할 수 있습니다.

여전히 더 세밀한 제어가 필요하다고 생각한다면, CKDatabase와 CKOperations를 사용할 수 있습니다.

하지만 CloudKit과 동기화하고 NSPersistentCloudKitContainer를 사용하지 않는다면, CKSyncEngine을 사용해야 합니다.

동기화는 많은 움직이는 부분을 포함하며, CKSyncEngine과 같은 더 높은 수준의 API를 사용하면 복잡성을 줄이고 앱의 동기화 경험을 개선하는 데 도움이 될 수 있습니다.

핵심적으로, 동기화는 대부분 한 장치에서 변경 사항을 보내고 다른 장치에서 가져오고, 필요할 때 CloudKit 레코드로 변환하는 것입니다.

그것은 스스로 하는 것은 꽤 쉽지만, 그 이상의 것이 있다.

모든 다른 작업과 오류에 대해 배우고, 시스템 상태를 모니터링하고, 계정 변경 사항을 듣고, 푸시 알림을 처리하고, 구독을 관리하고, 많은 상태를 추적해야 합니다.

CKSyncEngine을 사용하면 작성해야 하는 동기화 코드의 양이 훨씬 작아지고 집중됩니다.

앱에 특정한 것들만 처리하면 되며, 동기화 엔진이 나머지를 처리합니다.

적절한 동기화 엔진을 작성하려면, 아마도 수천 줄의 코드가 필요할 것이며, 테스트에서 그 양을 두 배로 늘려야 할 것입니다.

나는 실제로 NSPersistentCloudKitContainer가 70,000개 이상의 테스트 라인으로 뒷받침된다는 소문을 들었다.

CKSyncEngine은 또한 꽤 많은 테스트를 가지고 있으며, 그것은 당신을 위해 많은 것들을 처리하기 때문입니다.

그래서 이 새로운 CKSyncEngine API는 무엇인가요?

CKSyncEngine은 CloudKit 데이터베이스와 동기화하기 위한 공통 논리를 캡슐화합니다.

그것은 편리한 API를 제공하는 동시에 필요할 때 유연성을 제공하는 것을 목표로 한다.

그렇지 않으면 자체 사용자 지정 동기화 엔진을 작성할 대부분의 앱의 요구를 충족하도록 설계되었습니다.

일반적으로, 앱의 개인 또는 공유 데이터를 동기화하려는 경우, CKSyncEngine이 좋은 선택입니다.

동기화 엔진과 함께 사용하는 데이터 모델은 나머지 CloudKit에서 사용되는 것과 동일한 유형의 데이터인 레코드와 영역으로 구성됩니다.

기존 CloudKit API를 사용하여 이 데이터에 액세스할 수 있습니다.

이 때문에, 이미 기존 CloudKit 동기화 구현이 있다면, CKSyncEngine도 그것과 동기화할 수 있습니다.

동기화 엔진은 Freeform 앱을 포함하여 시스템 전체의 여러 앱과 서비스에서 사용되고 있다.

또 다른 예는 동기화 엔진 위에 다시 작성된 NSUbiquitousKeyValueStore이다.

이것은 이전 버전과 호환되는 사용 사례의 좋은 예이다.

최신 OS에서는 동기화 엔진을 사용하지만, 여전히 이전 버전과 동기화됩니다.

따라서 이미 사용자 지정 CloudKit 동기화 구현이 있다면, CKSyncEngine으로 전환할 수 있는 옵션이 있습니다.

혜택이 충분히 매력적으로 들린다면, 전환을 고려해야 하지만, 필수는 아닙니다.

가끔, 유지해야 할 코드가 적은 것이 좋다.

당신은 또한 CKSyncEngine이 새로운 향상을 받을 때마다 혜택을 받을 수 있습니다.

플랫폼이 발전함에 따라 동기화 엔진도 진화하여 시간이 지남에 따라 더 쉽고 효율적으로 동기화할 수 있습니다.

당신은 또한 CKSyncEngine의 더 작은 API 표면의 이점을 누릴 수 있습니다.

이를 통해 앱의 특정 데이터 모델과 사용 사례에 집중할 수 있습니다.

CKSyncEngine을 사용하는 것을 고려하고 있지만, 지원하지 않는 몇 가지 특정 요구 사항이 있다면, 원한다면 언제든지 자신만의 것을 만들 수 있습니다.

그러나, CKSyncEngine의 새로운 기능으로 당신의 요구가 충족될 수 있다고 생각한다면, 사용 사례에 대한 피드백을 제출하는 것을 고려하십시오.

결국, 동기화 엔진에 대한 최고의 아이디어 중 일부는 당신과 같은 개발자들로부터 왔습니다.

그래서 동기화 엔진은 실제로 어떻게 작동하나요?

일반적으로, 동기화 엔진은 앱과 CloudKit 서버 사이의 데이터 도관 역할을 합니다.

당신의 앱은 기록과 영역 측면에서 동기화 엔진과 통신합니다.

저장해야 할 변경 사항이 있을 때, 앱은 그것들을 동기화 엔진에 제공합니다.

다른 장치에서 이러한 변경 사항을 가져오면, 앱에 제공합니다.

즉, 동기화 엔진이 해야 할 일이 있을 때, 항상 즉시 하는 것은 아니다.

서버와 통신해야 하는 경우, 먼저 시스템 작업 스케줄러와 상의할 것입니다.

이것은 백그라운드 작업 관리를 위해 OS에서 사용되는 것과 동일한 스케줄러이며, 장치가 동기화할 준비가 되었는지 확인합니다.

장치가 준비되면, 스케줄러는 작업을 실행하고, 동기화 엔진은 서버와 통신한다.

이것은 동기화 엔진의 기본 작동 흐름이다.

더 구체적으로, 동기화 엔진이 서버에 변경 사항을 보낼 때 어떻게 생겼나요?

먼저, 누군가가 데이터를 수정한다.

아마도 그들은 무언가를 입력하거나 스위치를 뒤집거나 물건을 삭제했을 것이다.

그런 다음, 앱은 동기화 엔진에 서버로 보낼 보류 중인 변경 사항이 있음을 알려줍니다.

이것은 동기화 엔진이 할 일이 있다는 것을 알 수 있게 해준다.

다음으로, 동기화 엔진은 스케줄러에 작업을 제출합니다.

장치가 준비되면, 스케줄러가 작업을 실행한다.

작업이 실행되면, 동기화 엔진은 서버에 변경 사항을 보내는 과정을 시작합니다.

그렇게 하기 위해, 그것은 당신의 앱에 보낼 다음 변경 사항을 요청합니다.

누군가가 한 번의 수정을 했다면, 보류 중인 변경 사항이 하나만 있을 수 있습니다.

그러나, 누군가가 새로운 데이터의 거대한 데이터베이스를 가져오면, 수백 또는 수천 개의 변경 사항이 있을 수 있습니다.

단일 요청으로 서버로 보낼 수 있는 양에 제한이 있기 때문에, 동기화 엔진은 이러한 변경 사항을 일괄적으로 요청합니다.

이것은 또한 실제로 필요할 때까지 어떤 기록도 메모리로 가져오지 않음으로써 메모리 오버헤드를 줄이는 데 도움이 된다.

다음 배치를 제공한 후, 동기화 엔진은 그것을 서버로 보냅니다.

서버는 이러한 변경의 성공 또는 실패에 대한 정보를 포함하여 작업 결과에 응답합니다.

요청이 완료되면, 동기화 엔진은 결과와 함께 앱으로 다시 호출됩니다.

이것은 수술의 성공 또는 실패에 대응할 수 있는 기회입니다.

보류 중인 변경 사항이 더 있다면, 동기화 엔진은 보낼 것이 남지 않을 때까지 배치를 계속 요청할 것입니다.

이제 한 장치가 서버에 일부 데이터를 보냈으니, 다른 장치는 그 데이터를 가져올 것이다.

서버가 새로운 변경 사항을 받으면, 해당 데이터에 액세스할 수 있는 다른 장치에 푸시 알림을 보냅니다.

CKSyncEngine은 앱에서 이러한 푸시 알림을 자동으로 수신합니다.

알림을 받으면, 스케줄러에 작업을 제출합니다.

스케줄러 작업이 실행되면, 동기화 엔진은 서버에서 가져옵니다.

새로운 변경 사항을 가져오면, 앱에 제공합니다.

이것은 이러한 변경 사항을 로컬에서 지속하고 UI에 표시할 수 있는 기회입니다.

그리고 그것은 동기화 엔진을 사용할 때의 기본적인 작업 흐름이다.

이 모든 흐름의 공통점 중 하나는 시스템 스케줄러이다.

일반적으로, CKSyncEngine은 무언가를 하기 전에 스케줄러와 상의할 것이다.

이것이 당신을 대신하여 자동으로 동기화할 수 있는 방법입니다.

스케줄러는 네트워크 연결, 배터리 수준, 리소스 사용 등과 같은 시스템 상태를 모니터링합니다.

동기화를 시도하기 전에 장치가 전제 조건을 충족했는지 확인합니다.

스케줄러를 존중함으로써, 동기화 엔진은 사용자 경험과 장치 리소스 간의 적절한 균형을 보장할 수 있다.

정상적인 조건에서, 동기화는 보통 몇 초 정도 안에 꽤 빠를 것이다.

그러나, 네트워크 연결이 없거나 장치의 배터리가 부족하면 동기화가 지연되거나 지연될 수 있습니다.

장치가 무거운 부하를 받고 있다면, 동기화 메커니즘이 앱의 다른 더 긴급한 작업을 방해하는 것을 원하지 않습니다.

동기화 엔진의 자동 스케줄링에 의존함으로써, 당신은 하지 말아야 할 때가 아니라 해야 할 때 동기화할 것이라고 확신할 수 있습니다.

그것은 더 효율적일 뿐만 아니라, 사용하기도 더 쉽다.

언제 동기화해야 할지 걱정할 필요가 없다면, 다른 모든 것에 집중할 수 있습니다.

즉, 수동으로 동기화를 수행하기 위한 합법적인 사용 사례가 있다.

즉시 가져오는 Pull-to-refresh UI가 있을 수 있습니다.

또는 보류 중인 변경 사항을 서버에 즉시 보내는 백업 버튼이 있을 수 있습니다.

수동 동기화는 자동화된 테스트를 작성할 때도 유용할 수 있다.

이벤트 순서를 제어해야 하는 여러 장치에서 특정 동기화 시나리오를 시뮬레이션하는 데 도움이 될 수 있습니다.

일반적으로, 자동 동기화 스케줄링에 의존하는 것이 좋습니다.

하지만, 우리는 수동 동기화를 위한 유효한 사용 사례가 있다는 것을 알고 있으며, 동기화 엔진에는 필요할 때 그렇게 할 수 있는 API가 있습니다.

그리고 이제, Aamer는 CKSyncEngine을 사용하는 방법에 대해 이야기할 것이다.

아머: 소개해줘서 고마워, 팀.

제 이름은 아머입니다.

저는 CloudKit 클라이언트 팀의 엔지니어입니다.

이제 CKSyncEngine을 시작하는 것을 다루겠습니다.

CKSyncEngine을 사용하기 전에, 프로젝트를 설정하기 위해 해야 할 몇 가지 일이 있습니다.

이러한 요구 사항은 CKSyncEngine을 사용하든 사용자 지정 CloudKit 구현을 구축하든 동일합니다.

먼저, CloudKit의 기본 데이터 유형인 CKRecord 및 CKRecordZone에 대한 기본 지식이 필요합니다.

동기화 엔진 API는 기록과 구역 측면에서 많이 다루므로, 뛰어들기 전에 그것이 무엇인지 이해해야 합니다.

다음으로, Xcode에서 프로젝트에 대한 CloudKit 기능을 활성화해야 합니다.

마지막으로, 동기화 엔진은 최신 상태로 유지하기 위해 푸시 알림에 의존하기 때문에, 원격 알림 기능도 활성화해야 합니다.

그 모든 것을 갖게 되면, 동기화 엔진을 초기화할 준비가 된 것입니다.

앱이 실행된 직후에 CKSyncEngine을 초기화해야 합니다.

동기화 엔진을 초기화하면 백그라운드에서 푸시 알림과 스케줄러 작업을 자동으로 듣기 시작합니다.

이러한 알림과 작업은 언제든지 발생할 수 있으며, 이를 처리하려면 동기화 엔진을 초기화해야 합니다.

앱과 CKSyncEngine 간의 주요 통신 수단은 CKSyncEngineDelegate라는 프로토콜을 통해 이루어집니다.

동기화 엔진을 초기화할 때, 이 프로토콜을 준수하는 객체를 제공해야 합니다.

적절하고 효율적으로 작동하기 위해, 동기화 엔진은 일부 내부 상태를 추적한다.

또한 동기화 엔진 상태의 마지막으로 알려진 버전을 제공해야 합니다.

동기화 작업을 수행하는 동안, 때때로 당신의 대리인에게 상태 업데이트 이벤트의 형태로 이 상태의 업데이트된 버전을 제공할 것입니다.

동기화 엔진이 새로운 상태 직렬화를 제공할 때마다, 로컬에서 유지해야 합니다.

이렇게 하면 다음에 프로세스가 시작되고 동기화 엔진을 초기화할 때 제공할 수 있습니다.

이것을 이해하는 데 도움을 주기 위해, 몇 가지 코드 예제를 사용하여 설명하겠습니다.

동기화 엔진을 초기화하려면, 구성 객체를 통과해야 합니다.

구성에서 동기화하려는 데이터베이스, 동기화 엔진 상태의 마지막으로 알려진 버전 및 대리인을 제공해야 합니다.

위임 프로토콜의 기능 중 하나는 핸들 이벤트 기능이다.

이 기능은 동기화 엔진이 정상적인 동기화 작동 중에 발생하는 다양한 이벤트에 대해 앱에 알리는 방법입니다.

예를 들어, 서버에서 새 데이터를 가져오거나 계정이 변경될 때 이벤트를 게시할 것입니다.

이 이벤트들 중 하나는 상태 업데이트 이벤트이다.

동기화 엔진이 내부 상태를 업데이트하거나 상태를 직접 업데이트할 때, 동기화 엔진은 상태 업데이트 이벤트를 게시합니다.

이 사건에 대응하여, 당신은 이 새로운 직렬화된 버전의 상태를 로컬로 유지해야 합니다.

이 예에서, 다음에 동기화 엔진을 초기화할 때 이 상태 직렬화를 사용할 것입니다.

이제 기초가 설정되었고, 나는 동기화 엔진과의 동기화를 다룰 것이다.

서버에 변경 사항을 보낼 수 있는 몇 가지 간단한 단계가 있습니다.

먼저, 보류 중인 레코드 영역 변경 사항과 보류 중인 데이터베이스 변경 사항을 동기화 엔진 상태에 추가하십시오.

이것은 동기화 엔진에 동기화를 예약해야 한다고 경고할 것이다.

동기화 엔진은 일관성을 보장하고 이러한 변경 사항을 중복 제거할 것이다.

다음으로, 위임 방법 nextRecordZoneChangeBatch를 구현하세요.

동기화 엔진은 서버로 보낼 레코드 영역 변경의 다음 배치를 얻기 위해 이것을 호출할 것이다.

마지막으로, sentDatabaseChanges와 sentRecordZoneChanges 이벤트를 처리하세요.

이러한 이벤트는 변경 사항이 서버로 전송되면 게시됩니다.

다음은 서버에 변경 사항을 보내는 예입니다.

이 응용 프로그램은 데이터를 편집하고 새로운 레코드 변경 사항을 동기화하려고 합니다.

이렇게 하려면, 동기화 엔진 상태에 보류 중인 레코드 영역 변경을 추가하여 해당 레코드를 저장해야 한다고 동기화 엔진에 알릴 것입니다.

동기화 엔진이 레코드를 동기화할 준비가 되면, 위임 방법 nextRecordZoneChangeBatch를 호출합니다.

여기서 당신은 서버로 보낼 다음 변경 사항을 반환할 것입니다.

보류 중인 변경 사항 목록과 레코드 공급자를 제공하여 RecordZoneChangeBatch를 초기화합니다.

보류 중인 변경 목록에는 저장하거나 삭제할 레코드 ID와 실제 동기화가 발생할 때 해당 ID를 레코드에 매핑할 레코드 공급자가 포함되어 있습니다.

애플리케이션이 서버에서 변경 사항을 가져올 수 있는 방법은 다음과 같습니다.

동기화 엔진은 서버에서 자동으로 변경 사항을 가져옵니다.

그렇게 되면, fetchedDatabaseChanges와 fetchedRecordZoneChanges 이벤트를 게시할 것이다.

사용 사례에 따라 willFetchChanges와 didFetchChanges 이벤트를 듣고 싶을 수도 있습니다.

예를 들어, 변경 사항을 가져오기 전이나 후에 설정 또는 정리 작업을 수행하려는 경우 이러한 이벤트를 처리하는 것이 유용할 수 있습니다.

다음은 앱이 서버에서 변경 사항을 가져오는 예입니다.

동기화 엔진이 레코드 영역 내에서 변경 사항을 가져오면 fetchedRecordZoneChanges 이벤트를 게시합니다.

이 이벤트에는 다른 장치에서 수행한 수정 및 삭제가 포함되어 있습니다.

이것을 들을 때, 가져온 수정 사항과 가져온 삭제를 확인해야 합니다.

수정을 받으면, 데이터를 로컬로 유지해야 합니다.

삭제를 받으면, 데이터를 로컬로 삭제해야 합니다.

데이터베이스 변경 사항을 가져오는 것은 매우 유사하게 작동하며 동일한 접근 방식으로 처리할 수 있습니다.

오류를 처리하는 것은 까다로울 수 있다.

동기화 엔진은 이것에도 도움이 된다.

동기화 엔진은 네트워크 문제, 제한 및 계정 문제와 같은 일시적인 오류를 자동으로 처리합니다.

동기화 엔진은 이러한 오류의 영향을 받는 작업을 자동으로 재시도할 것이다.

다른 오류의 경우, 당신의 앱은 그것들을 처리해야 할 것입니다.

이러한 오류를 해결하면, 필요한 경우 작업 일정을 다시 잡아야 합니다.

이것은 기록 영역 변경을 보낼 때 전달 오류의 예입니다.

sentRecordZoneChanges 이벤트가 게시되면, failedRecordSaves를 확인하여 저장에 실패한 레코드가 있는지 확인해야 합니다.

serverRecordChanged는 서버에서 레코드가 변경되었음을 나타냅니다.

이것은 다른 장치가 응용 프로그램이 아직 가져오지 않은 새 버전을 저장했다는 것을 의미합니다.

당신은 갈등을 해결하고 작업 일정을 다시 잡아야 합니다.

zoneNotFound는 해당 영역이 아직 서버에 존재하지 않음을 나타냅니다.

이 문제를 해결하려면, 구역을 만들고 작업 일정을 다시 잡아야 할 수도 있습니다.

동기화 엔진은 항상 영역을 먼저 저장한 다음 기록하려고 시도할 것이다.

networkFailure, networkUnavailable, serviceUnavailable 및 requestRateLimited는 동기화 엔진이 처리할 일시적인 오류의 예입니다.

당신은 여전히 당신의 인식을 위해 이러한 오류를 받게 될 것이지만, 그에 대응하여 조치를 취할 필요는 없습니다.

동기화 엔진은 시스템 조건이 허락할 때 이러한 오류에 대해 자동으로 재시도할 것이다.

동기화 엔진이 도움이 되는 또 다른 것은 계정 변경이다.

iCloud 계정 변경은 장치에서 언제든지 발생할 수 있습니다.

동기화 엔진은 당신이 이것들을 관리하고 반응할 수 있도록 도와줍니다.

동기화 엔진은 변경 사항을 수신하고 accountChange 이벤트를 사용하여 로그인, 로그아웃 또는 계정이 전환되었음을 나타냅니다.

당신의 지원서는 유형에 따라 변경을 준비해야 합니다.

동기화 엔진은 장치에 계정이 있을 때까지 iCloud와 동기화를 시작하지 않습니다.

언제든지 동기화 엔진을 초기화할 수 있으며, 계정 변경이 있을 때 자동으로 업데이트됩니다.

다른 사용자와 데이터를 공유하는 것은 CloudKit의 핵심 부분이다.

동기화 엔진은 여기서도 삶을 더 쉽게 만든다.

동기화 엔진은 CloudKit 공유 데이터베이스와 함께 작동합니다.

애플리케이션이 작업할 데이터베이스당 동기화 엔진을 만들기만 하면 됩니다.

예를 들어, 개인 데이터베이스의 동기화 엔진과 공유 데이터베이스의 다른 동기화 엔진을 만들 수 있습니다.

CloudKit으로 공유하는 것에 대해 자세히 알아보려면, "CloudKit 공유를 최대한 활용하세요" 테크 토크를 확인하세요.

그것은 CKSyncEngine 사용을 다룹니다.

이제 나는 그것을 사용할 때 테스트하는 방법을 다룰 것이다.

자동화된 테스트는 빠르게 개발하는 동안 코드베이스의 안정성을 보장하는 가장 좋은 방법입니다.

동기화 엔진을 사용하면 여러 CKSyncEngine 인스턴스를 사용하여 장치 간 사용자 흐름을 시뮬레이션할 수 있습니다.

앱이 발생할 수 있는 엣지 케이스를 시뮬레이션해야 합니다.

이렇게 하려면, automaticallySync를 false로 설정하여 동기화 엔진 흐름에 개입할 수 있습니다.

다음은 두 장치와 서버 간의 데이터 충돌을 시뮬레이션하는 테스트 사례입니다.

이 테스트의 목적은 사용자가 여러 장치로 작업할 때 취할 전체 흐름을 시뮬레이션하는 것입니다.

그것은 또한 갈등 해결을 검증한다.

먼저, MySyncManager를 사용하여 두 개의 장치를 시뮬레이션하세요.

이 예에서, MySyncManager는 로컬 데이터베이스와 동기화 엔진을 만듭니다.

장치 A는 값을 A로 설정하고 변경 사항을 서버로 보냅니다.

장치 B가 서버에서 변경 사항을 가져오기 전에 서버로 변경 사항을 보내도록 요청할 것입니다.

장치 A가 먼저 서버에 저장되었기 때문에, 장치 B의 저장은 실패할 것으로 예상된다.

이로 인해 서버 레코드 변경 오류가 발생하여 로컬 충돌 해결 코드를 실행할 것입니다.

이 샘플은 충돌 해결이 서버의 데이터를 선호할 것으로 예상하므로, 장치 B의 새로운 값은 장치 A에서 가장 최근에 서버로 전송된 값이 될 것입니다.

다음은 테스트와 디버깅 속도를 높이는 데 도움이 될 수 있는 몇 가지 핵심 포인트입니다.

각 장치의 이벤트 순서를 이해하면 애플리케이션이 문제가 있을 수 있는 곳을 정확히 찾아내는 데 도움이 될 것입니다.

개발할 때 가능한 한 많이 로깅하는 것은 이러한 흐름을 추적하고 여러 장치에서 로그를 비교하는 데 도움이 될 것이다.

CloudKit은 당신이 받는 각 이벤트를 기록하지만, 애플리케이션에서 그들을 둘러싼 작업도 기록해야 합니다.

기록 ID와 영역 ID를 기록하면 동기화 엔진, 서버 및 동기화할 수 있는 다른 장치 간에 흐르는 데이터를 디버깅하는 데 도움이 될 수 있습니다.

각 사용자 흐름을 시뮬레이션하는 테스트를 작성하면 코드베이스를 성장시키면서 안정성을 유지하는 데 도움이 될 것입니다.

퍼즐을 조립할 때 타임스탬프를 보세요.

당신은 몇 가지 동기화 작업만 할 수도 있고, 짧은 시간에 많은 작업을 할 수도 있습니다.

올바른 것을 추적하고 있다는 것을 보장하는 것은 여러 장치 간의 디버깅의 핵심입니다.

이 단계들은 CKSyncEngine을 사용하여 신뢰할 수 있고 오래 지속되는 애플리케이션을 만들고 유지하는 데 도움이 될 것이다.

이것으로 CKSyncEngine에 대한 우리의 이야기를 마칩니다.

앱에서 전체 작동 예제를 보려면 동기화 엔진 샘플 코드를 살펴보세요.

더 깊이 들어가려면, CKSyncEngine 문서를 확인하세요.

동기화 엔진을 개선하기 위한 제안이 있다면, CloudKit 팀에 피드백을 제출하십시오.

우리는 당신이 그것으로 무엇을 만드는지 보게 되어 기쁩니다.

봐줘서 고마워. 멋진 WWDC 되세요!

♪ ♪