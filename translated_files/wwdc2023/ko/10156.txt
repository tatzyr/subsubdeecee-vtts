10156

♪ ♪

카일: 안녕하세요, 저는 스위프트UI 팀의 일원인 카일입니다.

애니메이션은 현대 앱 디자인의 핵심 구성 요소이다.

세련되게 적용하면, 그것은 당신의 UI에 선명도와 생명을 모두 가져올 수 있습니다.

앱에 애니메이션을 간단하게 추가하는 것은 SwiftUI를 개발하기 시작했을 때 우리의 핵심 동기 중 하나였습니다.

그것이 SwiftUI가 있는 그대로 형성되는 큰 이유이다.

이 세션은 SwiftUI의 강력한 애니메이션 기능과 인상적인 시각 효과를 생성하기 위해 함께 작동하는 방법에 대한 개요입니다.

SwiftUI가 뷰의 렌더링을 새로 고치고, Animatable을 사용하여 애니메이션을 결정할 것을 결정하고, 애니메이션을 사용하여 시간이 지남에 따라 값을 보간하고, 트랜잭션을 사용하여 현재 업데이트에 대한 컨텍스트를 전파하는 방법을 다룰 것입니다.

최근 몇 년 동안, 내 동료들 사이에서 누가 최고의 털복숭이를 만드는지 아닌지에 대한 논쟁이 있었다.

우리는 합의에 도달 할 수 있을지 궁금했고, 그래서 우리는 여론 조사를 하기 위한 앱을 만들었다.

각 애완동물에게 투표할 수 있는 버튼이 있습니다.

탭하면, 투표 수가 바뀌고, 아바타는 현재 순위를 반영하기 위해 미끄러진다.

지난 여론조사에서, 적절한 바와 같이, 고양이는 1위를 차지했지만, 좁게만 차지했다.

다음 여론조사를 순전히 우연에 맡기기에는 지분이 너무 높기 때문에, 나는 새로운 기능을 추가하고 있다.

탭에서, 내가 선택한 아바타는 사람들이 적절한 애완동물에 투표하도록 유도하기 위해 확장될 것이다.

그리고 나는 그것을 축소하기 위해 다시 탭할 수 있다.

이것은 이미 꽤 잘 작동하고 있지만, 애니메이션을 사용하면 훨씬 더 좋을 것이다.

그것을 추가하기 전에, 나는 SwiftUI가 뷰 업데이트의 해부학을 더 잘 이해할 수 있도록 뷰의 렌더링을 어떻게 새로 고치는지 추적할 것이다.

이 연습을 위해, 나는 고립된 애완 동물 아바타 보기에 집중할 것이다.

SwiftUI는 선택한 상태 변수와 같은 뷰의 종속성을 추적합니다.

탭과 같은 이벤트가 들어오면, 업데이트 거래가 열립니다.

종속성이 변경되면, 뷰는 무효화되고, 거래가 끝날 때, 프레임워크는 렌더링을 새로 고치기 위해 새로운 값을 생성하기 위해 본문을 호출합니다.

이 뷰의 몸은 탭 제스처, 스케일 효과 및 이미지로 구성되어 있다.

무대 뒤에서, SwiftUI는 뷰와 데이터의 수명을 관리하는 수명이 긴 종속성 그래프를 유지한다.

속성이라고 불리는 이 그래프의 각 노드는 UI의 미세한 부분에 매핑됩니다.

선택된 상태가 true로 바뀌었을 때, 이러한 각 다운스트림 속성의 값은 오래되었다.

그들은 새로운 뷰 값을 한 번에 한 레이어씩 풀어서 새로 고쳐진다.

해당 그래프 속성이 업데이트되면, 뷰의 본문 값은 폐기됩니다.

마지막으로, 그래프는 렌더링을 업데이트하기 위해 당신을 대신하여 그리기 명령을 방출합니다.

속성의 수명을 시각화하기 위해 그래프만 확대할 것이다.

속성은 초기 가치를 가지고 태어난다.

이벤트가 들어오고, 업데이트 거래가 열립니다.

업스트림 의존성이 바뀐다.

그 틀은 몸을 부른다.

속성의 값이 업데이트됩니다.

거래가 종료됩니다.

그리고 이런 식으로, 그래프의 각 속성의 현재 가치는 시간이 지남에 따라 진화한다.

그래서 그것은 뷰 업데이트의 해부학이다.

이제 내가 애니메이션을 추가할게.

내 상태 변경을 애니메이션으로 감싸면, 탭 제스처 폐쇄가 실행되면, 애니메이션은 거래를 위해 설정됩니다.

그런 다음 선택이 토글되고, 다운스트림 속성은 무효화됩니다.

이전과 마찬가지로, 본문은 새로운 속성 값을 제공하기 위해 호출된다.

그리고 여기가 흥미로워지는 곳이야.

scaleEffect는 특별한 속성, "애니메이션 가능한 속성"이다.

애니메이션 속성의 값이 변경되면, 거래에 대한 애니메이션이 설정되어 있는지 확인합니다.

그렇다면, 그것은 복사본을 만들고 시간이 지남에 따라 애니메이션을 사용하여 이전 값에서 새 값으로 보간합니다.

나는 이것이 어떻게 진행되는지 조사하기 위해 scaleEffect 애니메이션 속성을 확대할 것이다.

가장 먼저 주목해야 할 것은 애니메이션 가능한 속성이 개념적으로 모델과 프레젠테이션 가치를 모두 가지고 있다는 것이다.

지금 그들은 똑같아.

그런 다음 이벤트가 들어오고, 이번에는 애니메이션과 함께 거래가 열립니다.

상태가 변경되고, 오래된 속성 값을 새로 고치기 위해 본문이 호출됩니다.

값이 변경되었기 때문에, 속성은 현재 프레젠테이션 값을 계산하기 위해 애니메이션의 로컬 복사본을 만든다.

SwiftUI는 속성 그래프에 실행 중인 애니메이션이 언제 포함되어 있는지 알고 있으며 다음 프레임을 생성하기 위해 적절한 애니메이션 속성을 호출할 것이다.

scaleEffect와 같은 내장된 애니메이션 속성의 경우, SwiftUI는 매우 효율적이다.

뷰 코드를 호출하지 않고도 메인 스레드에서 이 작업을 수행할 수 있습니다.

여기 작동 중인 애니메이션이 있습니다.

좋아.

누군가가 "애니메이션"이라는 단어를 사용할 때, 그들은 아마도 시간이 지남에 따라 시야가 변하는 방식의 전반적인 시각적 경험을 언급하고 있을 것이다.

내가 지금까지 다룬 것은 SwiftUI에는 전반적인 시각적 경험에 기여하는 두 가지 직교 측면이 있다는 것이다.

scaleEffect와 같은 애니메이션 가능한 속성은 애니메이션되는 데이터를 결정하는 반면, 애니메이션은 시간이 지남에 따라 데이터가 어떻게 변하는지 결정합니다.

나는 애니메이션을 결정하는 Animatable부터 시작하여 이것들 각각에 대해 더 깊이 파고들 것이다.

SwiftUI는 Animatable 프로토콜을 준수하는 모든 보기에 대해 animatable 속성을 구축합니다.

유일한 요구 사항은 뷰가 애니메이션화하려는 데이터의 읽기 쓰기 벡터를 정의하는 것이다.

데이터는 VectorArithmetic을 준수해야 합니다.

VectorArithmetic은 수학 수업에서 벡터의 교과서 정의와 일치합니다.

그것은 벡터 덧셈과 스칼라 곱셈을 지원합니다.

만약 당신이 녹슬거나 벡터에 익숙하지 않다면, 낙담하지 마세요.

벡터는 기본적으로 고정 길이의 숫자 목록일 뿐이며, SwiftUI 애니메이션의 경우, 벡터를 다루는 목적은 대부분 그 목록의 길이를 추상화하는 것이다.

예를 들어, CGFloat와 Double은 1차원 벡터이며, CGPoint와 CGSize는 2차원 벡터를 정의하고, CGRect는 4차원 벡터를 정의한다.

벡터를 처리함으로써, SwiftUI는 단일 일반 구현으로 이러한 모든 유형 등을 애니메이션화할 수 있다.

지금까지, 단순함을 위해, 나는 그것이 1차원 스케일 요소인 것처럼 scaleEffect를 표현했다.

1차원 스케일 효과에 대한 애니메이션 적합성은 간단할 것이다.

그것의 애니메이션 가능한 데이터는 그냥 CGFloat가 될 것이다.

실제로, scaleEffect를 사용하면 변환의 너비, 높이 및 상대 앵커 포인트를 독립적으로 구성할 수 있습니다.

따라서 scaleEffect는 실제로 애니메이션 가능한 데이터에 대한 4차원 벡터, 너비와 높이 척도에 대한 CGSize를 상대 앵커에 대한 UnitPoint와 짝을 이룬다.

AnimatablePair는 두 벡터를 하나의 더 큰 벡터로 융합한다.

그것은 공개 유형이며, 당신도 그것을 사용할 수 있습니다.

Animatable에 자신의 견해 중 하나를 준수한다면 유용할 수 있습니다.

scaleEffect는 SwiftUI에 내장된 많은 애니메이션 가능한 시각 효과 중 하나일 뿐이므로, 대부분의 경우 Animatable은 직접 사용해야 하는 API가 아닙니다.

하지만 드문 경우지만, 고급 사용 사례는 Animatable에 대한 자신의 견해 중 하나를 준수해야 할 수 있습니다.

사용자 지정 RadialLayout을 사용하여 원의 호를 따라 하위 뷰를 배포하는 애완 동물 Podium 뷰를 고려하십시오.

기본적으로, 애니메이션 내에서 오프셋 각도를 변경하면 애완 동물 아바타를 직선을 따라 새로운 위치로 애니메이션화합니다.

애완동물이 어떻게 지름길을 택하고 원 내부를 침범하고 있는지 알아챘나요?

그건 내가 원하는 게 아니야.

대신, 나는 내 아바타가 원의 둘레를 따라 움직이기를 원한다.

Podium을 애니메이션에 적합하고 오프셋 각도를 애니메이션 데이터로 사용하여 이 효과를 얻을 수 있습니다.

왜 이것이 그렇게 다른 효과를 가져오나요?

설명하기 위해, 나는 직선을 따라 아바타를 움직이는 기본 동작부터 시작하여 포디움 뷰의 각 버전에 대한 애니메이션 업데이트를 진행할 것이다.

연단의 몸은 RadialLayout과 세 개의 아바타로 구성되어 있다.

거래가 열리면, 오프셋 각도가 변경되면, 본문은 오래된 다운스트림 속성 값을 새로 고치기 위해 호출됩니다.

그런 다음 레이아웃이 실행되어 각 하위 뷰의 위치를 업데이트합니다.

그래서 이것이 기본 버전의 애니메이션 업데이트와 같다.

활성 애니메이션 데이터는 데카르트 좌표 공간에서 보간하는 뷰 위치 CGPoint이며, 이는 각 아바타가 직선을 따라 움직인다는 것을 의미합니다.

사용자 지정 버전에서, 내가 Podium을 Animatable에 준수할 때, 변경 사항은 그 몸체가 오프셋 각도를 animatable 데이터로 사용하는 활성 animatable 속성이 된다는 것이다.

각 아바타가 호를 따라 움직이는 것은 어떤 결과인가요?

이 사용자 지정 버전에서, 애니메이션의 모든 프레임에 대해, 본문은 새로운 오프셋 각도로 SwiftUI에 의해 호출될 것이며, 레이아웃은 다시 실행될 것이다.

이것은 매우 강력하며, 때로는 사용자 지정 레이아웃이나 그리기 코드를 애니메이션화할 때와 같이, 원하는 효과를 얻을 수 있는 유일한 방법일 수 있습니다.

사용자 지정 애니메이터블 적합성은 애니메이션의 모든 프레임에 대해 바디를 실행하기 때문에 내장 효과보다 애니메이션하는 데 훨씬 더 비쌀 수 있다는 것을 명심하세요.

따라서 내장 효과를 사용할 수 없는 효과를 얻을 수 없는 경우에만 이 도구를 사용하세요.

다음으로, 시간이 지남에 따라 애니메이션 데이터를 보간하는 일반적인 알고리즘인 애니메이션을 다루겠습니다.

이전에, 나는 withAnimation에서 상태 변경을 래핑하여 애완 동물 아바타 보기에 애니메이션을 추가했다.

탄력 있는 스프링과 같은 노골적인 애니메이션을 전달하여 이것을 사용자 정의할 수 있습니다.

SwiftUI에는 수많은 강력한 애니메이션이 내장되어 있습니다.

그것들은 대략 세 가지 버킷으로 분류될 수 있다: 타이밍 곡선 애니메이션, 스프링 애니메이션, 그리고 기본 애니메이션을 수정하는 고차 애니메이션.

타이밍 곡선 애니메이션은 당신이 가장 익숙한 애니메이션의 범주일 가능성이 높습니다.

예를 들어, easeInOut은 타이밍 곡선 애니메이션이다.

모든 타이밍 곡선 애니메이션은 애니메이션의 속도와 지속 시간을 정의하는 곡선을 취한다.

베지어 제어점을 사용하여 타이밍 곡선을 만들 수 있다.

시작 및 끝 제어점을 조정함으로써, 애니메이션의 초기 및 최종 속도를 변경할 수 있습니다.

UnitCurve 유형은 0과 1 사이의 상대 지점에서 값과 속도를 계산하기 위해 독립형으로 사용할 수 있습니다.

SwiftUI에는 선형, easeIn, easeOut 및 easeInOut과 같은 다양한 타이밍 곡선 프리셋이 내장되어 있습니다.

모든 타이밍 곡선 애니메이션은 사용자 지정 기간을 지정할 수도 있습니다.

애니메이션의 다음 범주인 스프링은 스프링 시뮬레이션을 실행하여 주어진 시점에서 값을 결정합니다.

예를 들어, 질량, 강성 및 댐핑과 같은 스프링을 지정하는 전통적인 방법에 익숙할 수 있습니다.

하지만 우리는 이러한 방법들이 특히 직관적인 것을 찾지 못했기 때문에, 우리는 새로운 방법을 발명했다.

애니메이션의 인지된 지속 시간과 봄이 얼마나 탄력 있기를 원하는지 지정하기만 하면 됩니다.

그건 훨씬 더 접근하기 쉬운 거야.

UnitCurve와 마찬가지로, 스프링 유형은 주어진 시간에 스프링의 값과 속도를 계산하기 위해 독립형으로 사용할 수 있습니다.

SwiftUI는 세 가지 스프링 프리셋과 함께 제공됩니다: 바운스가 없는 스무스, 소량의 바운스가 있는 스프, 더 많은 양의 바운스가 있는 바운스.

봄 애니메이션을 매개 변수화하는 것이 불편하다면, 이 프리셋은 기분이 좋은 것을 얻을 수 있는 신뢰할 수 있는 방법입니다.

각 프리셋은 또한 지속 시간을 조정하거나 탄력을 조정하기 위해 조정할 수 있습니다.

속도를 보존하고 자연스럽게 휴식을 취함으로써 UI에 유기적인 느낌을 주기 때문에 봄 애니메이션을 사용하는 것이 좋습니다.

사실, 우리는 봄 애니메이션의 이점에 대해 매우 강하게 느끼기 때문에 iOS 17과 정렬된 릴리스에서 bare withAnimation을 사용할 때 부드러운 봄을 새로운 기본값으로 만들었습니다.

애니메이션의 마지막 범주인 더 높은 순서는 기본 애니메이션을 수정합니다.

그들은 속도를 늦추거나 속도를 높일 수 있다.

그들은 기본 애니메이션이 시작되기 전에 지연을 추가할 수 있다.

그리고 그들은 기본 애니메이션을 여러 번 반복할 수 있으며, 선택적으로 포워드 플레이와 리버스 플레이 사이를 전환할 수 있다.

그리고 이제 우리는 완전히 새로운 카테고리의 애니메이션을 소개하고 있습니다: 커스텀 애니메이션.

CustomAnimation 프로토콜을 사용하면 SwiftUI에 내장된 모든 애니메이션을 구현하는 데 사용하는 것과 동일한 저수준 일반 진입점에 액세스할 수 있습니다.

CustomAnimation 프로토콜에는 세 가지 요구 사항이 있습니다: 애니메이션, shouldMerge 및 속도.

애니메이션에 집중하는 것으로 시작하겠습니다.

shouldMerge와 속도는 선택적 요구 사항이다.

나중에 그들에게 다시 연락할게.

애니메이션은 애니메이션이 시작된 이후 경과한 시간, 그리고 추가 애니메이션 상태를 포함하는 컨텍스트를 애니메이션하기 위해 벡터를 전달한다.

Animate는 애니메이션의 현재 값을 반환하거나, 애니메이션이 완료되면 nil을 반환합니다.

이 값 벡터는 어디에서 왔나요?

그것은 뷰의 애니메이션 가능한 데이터에서 나온다.

애완동물 아바타 보기에서, 그것은 스케일 효과이다.

scaleEffect의 애니메이션 가능한 데이터는 2차원 너비와 높이 스케일을 포함한 4차원 벡터라는 것을 기억하세요.

아바타가 선택되면, 1 x 1의 배율에서 1.5 x 1.5의 배율로 애니메이션됩니다.

벡터 덧셈과 스칼라 곱셈 연산을 통해 SwiftUI는 이 두 벡터를 서로 빼서 그들 사이의 델타를 계산할 수 있다.

이 델타는 실제로 움직이는 것이다.

이것은 실제로 scaleEffect animatable 속성에서 실행되는 애니메이션이 1에서 1.5로 보간하는 것이 아니라 0에서 0.5로 보간된다는 것을 의미합니다.

무엇보다도, 이것은 애니메이션 방법을 구현하는 것을 더 편리하게 만든다.

내가 보여줄게.

나는 보간하기 위해 지속 시간으로 구성된 선형 타이밍 곡선 애니메이션을 구현할 것이다.

애니메이션이 델타 벡터를 전달하여 애니메이션을 향해 전달되었다는 것을 기억하세요.

스칼라 곱셈을 사용하여 경과한 기간의 비율로 벡터를 스케일링할 수 있습니다.

그리고 전체 기간이 경과하면, 애니메이션이 완료되어 제거할 수 있음을 나타내기 위해 nil을 반환할 것입니다.

그게 다야.

그리고 이 구현은 일반적이기 때문에, 모든 차원의 애니메이션 데이터로 작동합니다.

그래서 그것이 애니메이터블과 애니메이션이 함께 작동하여 UI에 나타나는 인상적인 시각 효과를 생성하는 방법입니다.

다음으로, CustomAnimation의 두 가지 선택적 요구 사항으로 돌아가겠습니다: shouldMerge와 velocity.

그것들은 무엇을 위한 거야?

당신이 scaleEffect 애니메이션 속성이라고 잠시 상상해 보세요.

사용자가 탭하고, 거래가 열리고, 값이 변경되고, 애니메이션의 로컬 복사본을 만들고, 델타 벡터를 행복하게 애니메이션화하기 시작합니다.

모든 게 잘 되고 있어.

즉, 애니메이션이 끝나기 전에 성가신 사용자가 다시 탭할 때까지.

무슨 일을 하세요?

새로운 애니메이션을 설정하고, shouldMerge를 호출합니다.

기본 구현은 false를 반환합니다. 이것이 타이밍 곡선 애니메이션이 하는 일입니다. 이 경우 두 애니메이션이 함께 실행되고 결과는 시스템에 의해 결합됩니다.

이것이 SwiftUI 애니메이션이 델타 벡터 측면에서 다루는 또 다른 이유이다.

여러 애니메이션이 실행 중일 때 올바른 결합된 프레젠테이션 값을 쉽게 계산할 수 있습니다.

하지만 타이밍 커브 애니메이션이 아닌 봄 애니메이션을 선택했다면 어땠을까?

봄 애니메이션은 shouldMerge를 재정의하여 true를 반환하고 이전 애니메이션의 상태를 통합합니다.

이를 통해 속도를 보존하고 타이밍 곡선 애니메이션과 같이 부가적으로 결합하는 것보다 더 자연스럽게 느껴질 수 있는 새로운 값으로 리타겟팅할 수 있다.

그리고 그것이 이 최종 속도 요구 사항의 것이다.

그것을 구현하면 실행 중인 애니메이션이 새 애니메이션과 병합될 때 속도를 유지할 수 있습니다.

그래서 나는 속도에 대한 구현을 추가하여 선형 타이밍 곡선 애니메이션을 끝낼 것이다.

나는 UI에 대한 주어진 업데이트를 위해 수행된 작업 세트를 언급하기 위해 이 강연 내내 "거래"라는 용어를 사용했다.

SwiftUI 코드에서 트랜잭션은 또한 관련 있고 강력한 데이터 흐름 구성과 API 제품군을 가리킨다.

당신은 이미 환경과 환경 설정에 익숙할 수 있습니다. 사전 SwiftUI는 각각 뷰 계층 구조를 암시적으로 전달하고 위로 전달합니다.

거래는 비슷해.

SwiftUI가 현재 업데이트, 특히 애니메이션에 대한 모든 컨텍스트를 암시적으로 전파하는 데 사용하는 사전입니다.

애니메이션 가능한 속성이 현재 애니메이션을 어떻게 읽는지에 대한 나의 설명은 조금 모호했다.

그래서 나는 아바타 뷰의 또 다른 애니메이션 업데이트를 추적할 것이다.

이번에는, 내가 더 구체적으로 할게.

탭 제스처 클로저가 실행되면, withAnimation은 루트 트랜잭션 사전에서 애니메이션을 설정합니다.

본문은 속성 값을 업데이트하기 위해 호출됩니다.

거래 사전은 속성 그래프를 통해 전파된다.

애니메이션 가능한 속성에 도달하면, 속성은 애니메이션이 설정되어 있는지 확인합니다.

그리고 만약 그렇다면, 그것은 프레젠테이션 가치를 높이기 위해 복사본을 만든다.

거래는 특정 업데이트와만 관련이 있으므로, 오래된 속성이 새로 고쳐지면 폐기됩니다.

트랜잭션 사전 내의 뷰 계층 구조 아래로 애니메이션을 흐르면 애니메이션이 뷰에 언제 어떻게 적용되는지 제어할 수 있는 많은 강력한 API가 가능합니다.

현재, 애완동물 아바타 보기는 탭을 통해서만 선택할 수 있습니다.

선택한 상태 변수를 바인딩으로 변경하겠습니다.

그렇게 하면, 그것은 또한 프로그래밍 방식으로 선택될 수 있다.

하지만 보기 속성에 대한 프로그래밍 방식의 변화를 어떻게 애니메이션화하나요?

트랜잭션 수정자를 사용하여 트랜잭션 사전 내부의 뷰 계층 구조를 따라 흐르면서 애니메이션에 액세스할 수 있습니다.

이 수정자 내에서 애니메이션을 설정하면, 본문이 호출될 때마다 트랜잭션에 애니메이션이나 다른 애니메이션이 없더라도 속성은 애니메이션을 재정의합니다.

그리고 스케일 효과에 도달하면, 이 애니메이션은 스케일 요소를 보간하는 데 사용될 것이다.

꽤 멋져.

하지만 이 패턴에는 문제가 있다.

SwiftUI가 보기를 새로 고칠 때마다 모든 후손에 대한 애니메이션을 무차별적으로 재정의하면 우발적인 애니메이션으로 이어질 수 있습니다.

대신, 이와 같은 사용 사례의 경우, SwiftUI는 애니메이션 보기 수정자를 제공합니다.

효과를 훨씬 더 정확하게 확장할 수 있는 추가 가치 인수가 필요합니다.

값이 변경된 경우에만 거래에 애니메이션을 쓸 것이다.

이제 그것이 연결되었고, 이 withAnimation은 아무것도 성취하지 못하므로, 우리는 그것을 제거할 수 있다.

애니메이션 뷰 수정자는 또한 뷰의 다른 부분에 다른 애니메이션을 적용하려는 상황을 위한 강력한 도구입니다.

예를 들어, 애완 동물 아바타에는 그림자가 있는데, 나는 단순함을 위해 지금까지 예시에서 생략했다.

아바타가 배경 위에 올려져 있다는 환상을 강조하기 위해 선택될 때 그림자 반경이 증가한다.

그것을 가지고 놀고 난 후, 나는 그림자의 애니메이션이 스케일 효과보다 더 차분해지기를 원한다고 결정했다.

이를 달성하기 위해, 스케일 이펙트와 그림자 사이에 다른 애니메이션 보기 수정자를 삽입할 수 있습니다.

이제 거래는 스케일 효과를 애니메이션화하기 위해 탄력 있는 스프링을 선택한다.

그리고 그것은 그림자 반경을 애니메이션화하기 위해 더 미묘한 부드러운 스프링을 포착한다.

애니메이션 수정자는 값이 변경되었을 때만 활성화되기 때문에, 우발적인 애니메이션의 확률은 크게 감소한다.

하지만 아바타의 이미지가 선택한 것과 같은 거래에서 바뀌었다면, 콘텐츠 전환을 위해 그림자의 부드러운 봄 애니메이션을 물려받았을 것이다.

이것은 머무를 가치가 있는 요점이다.

이 애니메이션 뷰 수정자는 전체 하위 계층이 제어하에 있는 리프 구성 요소에서 잘 작동합니다.

그러나 임의의 자식 콘텐츠를 포함하는 잎이 아닌 구성 요소의 경우, 우발적인 애니메이션이 발생할 가능성이 훨씬 더 높다.

예를 들어, 애완동물과 관련이 없는 다른 앱에서 아바타를 재사용하고 싶다면, 임의의 어린이 콘텐츠를 받아들임으로써 더 일반적으로 만들 수 있습니다.

이 시나리오에서, 나는 선택한 변경 사항, 하위 콘텐츠도 변경되지 않을 것이라는 보장이 적다.

이것은 우발적인 애니메이션을 초래할 수 있다.

이런.

좋은 소식이야.

우리는 이와 같은 사용 사례를 위해 특별히 설계된 새로운 버전의 애니메이션 보기 수정자를 가지고 있습니다.

그것은 본문 폐쇄에 지정된 애니메이션 가능한 속성으로 애니메이션을 좁게 확장한다.

이게 작동하는 방식이야.

거래에 애니메이션이 없다고 상상해 보세요.

거래가 애니메이션 뷰 수정자의 속성에 도달하면, 지정된 애니메이션으로 채워진 복사본이 만들어집니다.

그 사본은 다운스트림으로 전파되지만, 범위가 있는 애니메이션 속성에만 전파된다.

일단 작업이 완료되면, 사본은 폐기되고, 원래 거래는 중단된 곳에서 다시 이루어진다.

따라서 거래가 하위 콘텐츠에 도달하면, 원래 거래가 중간 애니메이션 뷰 수정자의 영향을 받지 않기 때문에, 우발적인 애니메이션의 위험이 없습니다.

SwiftUI의 첫 번째 버전부터 제한된 거래 API 세트를 사용할 수 있었다.

이제 사용자 지정 트랜잭션 키를 정의할 수 있는 기능을 도입하므로, 트랜잭션 사전을 활용하여 자신의 업데이트별 데이터를 암시적으로 전파할 수 있습니다.

사용자 지정 환경 키를 선언한 적이 있다면, 사용자 지정 거래 키를 선언하는 것이 익숙할 것입니다.

그 패턴은 TransactionKey 프로토콜을 준수하는 고유한 유형을 만드는 것이다.

유일한 요구 사항은 기본값을 제공하는 것이다.

그런 다음 계산된 속성을 키를 사용하여 거래 사전에서 읽고 쓰는 거래의 확장으로 선언하십시오.

여기서, 저는 주어진 업데이트에 대해 아바타가 도청되었는지 여부를 추적하기 위해 부울 키를 정의했습니다.

나는 그 가치에 따라 어떤 애니메이션을 사용할지 결정할 것이다.

아바타가 대화식으로 선택되었다면, 나는 더 활기찬 봄을 사용하여 그것을 확장하거나 축소할 것이다.

하지만 아바타가 프로그래밍 방식으로 선택되었다면, 나는 더 차분한 스프링을 사용하여 크기를 조정할 것이다.

내 상태 변경을 거래로 래핑하여 주어진 업데이트에 대한 트랜잭션 사전의 값을 설정할 수 있습니다.

이건 친숙해 보일 거야.

withAnimation은 WithTransaction 주변의 얇은 포장지일 뿐이다.

withTransaction에 전달된 인수는 트랜잭션의 계산된 속성과 설정할 값의 키 경로입니다.

거래는 모든 업데이트가 끝날 때 폐기되기 때문에 SwiftUI의 암시적 데이터 흐름 구성 중에서 독특합니다.

즉, 현재 업데이트를 위해 명시적으로 설정하지 않는 한, 거래 사전의 모든 값은 키의 기본값으로 되돌아갑니다.

아바타 보기에서, 탭 제스처 폐쇄가 실행되면, avatarTapped는 현재 업데이트에 대해 true로 설정됩니다.

그 거래는 또한 애니메이션 키의 기본값을 포함하며, 이는 nil이다.

거래는 거래 수정자에 도달할 때까지 뷰 계층 구조 전반에 걸쳐 전파된다.

여기서, 아바타 뷰는 avatarTapped를 읽고, 그 가치에 따라 적절한 애니메이션을 설정합니다...

뷰 계층 구조 아래로 전파되는 것.

이것은 꽤 잘 작동하지만, 이전과 마찬가지로, 우발적인 애니메이션을 초래할 수 있다.

거래 수정에 대한 더 세밀한 제어를 제공하기 위해, 우리는 거래 수정자의 두 가지 새로운 변형을 도입하고 있습니다.

하나는 값 인수를 사용하여 범위를 지정할 수 있습니다.

그리고 다른 하나는 바디 클로저에 정의된 하위 계층으로 범위를 넓힐 수 있게 해준다.

이 변형은 앞서 다룬 범위 애니메이션 보기 수정자를 반영한다.

이 세션에서, 나는 SwiftUI의 강력한 애니메이션 프리미티브, 애니메이터블, 애니메이션 및 트랜잭션을 설명했다.

다음 단계로, 저는 두 개의 관련 세션을 확인하는 것을 추천합니다.

"Animate with springs"는 앱에서 스프링 애니메이션을 효과적으로 사용하는 이유와 방법에 대한 더 많은 지침을 제공합니다.

그리고 "SwiftUI의 고급 애니메이션을 통해 당신의 길을 안내하세요"는 다단계 애니메이션을 구성하기 위한 강력한 새로운 도구를 소개합니다.

이 콘텐츠가 SwiftUI 애니메이션이 어떻게 작동하는지 더 잘 이해하고 앱에서 애니메이션을 더 능숙하게 활용할 수 있기를 바랍니다.

고마워.

♪ ♪