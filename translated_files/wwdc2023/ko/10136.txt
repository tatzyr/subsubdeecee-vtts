10136

♪ ♪

크리스토퍼: 안녕하세요, 환영합니다!

제 이름은 크리스토퍼이고, 저는 ScreenCaptureKit 팀의 소프트웨어 엔지니어입니다.

저는 제 동료 나탈리 린제이와 합류할 것이며, 함께 애플리케이션의 화면 캡처 기능을 향상시킬 새로운 기능을 소개할 것입니다.

ScreenCaptureKit은 애플리케이션의 화면 공유 경험을 만들 수 있도록 macOS 12.3에 도입되었습니다.

ScreenCaptureKit은 애플리케이션의 요구에 맞는 컨트롤과 함께 공유하고 싶은 콘텐츠를 사용자 정의할 수 있는 API를 제공하며, 모두 스트림에 동적으로 적용할 수 있습니다.

이 프레임워크는 글로벌 보호 장치를 염두에 두고 디스플레이의 기본 해상도와 프레임 속도까지 올라가는 성능에 중점을 둔 고품질 콘텐츠를 제공합니다.

올해 ScreenCaptureKit은 새로운 macOS 기능과 통합되는 여러 개발자 API를 제공합니다.

발표자 오버레이는 사람들이 캡처된 콘텐츠에 자신을 삽입하여 화면 공유와 프레젠테이션을 더 개인적으로 만들 수 있는 기능입니다.

새로운 화면 공유 선택기를 사용하면 화면 공유에서 캡처한 것에 대한 시스템 차원의 경험을 통합할 수 있습니다.

마지막으로, 화면 캡처는 라이브 스트림만을 위한 것이 아니며, 올해는 선택한 모든 콘텐츠의 고화질 스크린샷을 캡처할 수 있는 새로운 API가 있습니다.

사람들은 전 세계에서 매일 서로 상호 작용한다.

이러한 상호 작용은 우리가 우리의 생각과 아이디어를 공유하고 중요한 문제를 해결하는 곳이다.

그들은 둘 다 전문적이고 개인적이다.

이를 위해, 당신의 앱은 발표자 오버레이라는 새로운 비디오 효과와 원활하게 작동할 수 있습니다.

콘텐츠를 공유할 때, 발표자 오버레이는 공유 콘텐츠 위에 발표자를 포함시켜 발표자의 존재를 높이고, 더 생산적인 원격 통화를 위한 개인적인 터치를 추가합니다.

작은 오버레이는 고급 세분화 알고리즘 덕분에 발표자를 움직일 수 있는 창에 배치하는 반면, 큰 오버레이는 발표자의 얼굴과 몸을 배경에서 분리한 다음 더 몰입감 있는 효과를 위해 화면 콘텐츠를 계층화합니다.

발표자 오버레이는 ScreenCaptureKit을 사용하는 모든 응용 프로그램에서 사용할 수 있습니다.

생성된 모든 SCStream에 대해 ScreenCaptureKit은 화면 공유 선택기에 알리고, 스트림 컨트롤이 있는 라이브 미리보기가 새로운 비디오 메뉴 표시줄 항목에 표시됩니다.

비디오 메뉴 표시줄은 활성 스트림이 있는 모든 응용 프로그램을 표시하고, 모든 응용 프로그램과 관련된 스트림의 라이브 미리보기를 표시합니다.

이 메뉴 표시줄에서 스트림 전체 화면 공유 선택기를 표시하여 스트림 콘텐츠를 제어할 수 있습니다.

이것은 또한 카메라 프레임을 콘텐츠 스트림에 삽입하는 발표자 오버레이가 활성화된 곳이다.

그리고 이것을 사용하여 화면 공유를 교체하거나 종료하는 것과 같이 스트림을 제어할 수도 있습니다.

카메라와 마이크 효과를 사용자 정의하기 위한 다른 유용한 기능이 있습니다.

ScreenCaptureKit과 카메라를 함께 사용하는 모든 응용 프로그램은 이러한 기능이 자동으로 작동합니다.

현재, 스트림에는 ScreenCaptureKit에서 프로세스로 전송된 콘텐츠 프레임이 있습니다.

이제, 애플리케이션이 활성 스트림 중에 카메라를 사용하기 시작하면, 프레젠테이션 오버레이는 비디오 메뉴 항목에서 사용할 수 있습니다.

활성화되면, ScreenCaptureKit은 카메라를 가져가서 응용 프로그램이 이미 실행 중인 선택한 스트림에 렌더링을 적용합니다.

활성 스트림에서 합성된 프레임을 자동으로 얻을 수 있습니다.

그래서 발표자 오버레이가 언제 적용되었는지 명확하게 알고 싶다면 어떨까요?

새로운 스트림을 만들고 자신을 대리인으로 추가하는 것부터 시작합시다.

그런 다음 SCStream, outputEffectDidStart에서 새로운 대리자 콜백을 구현할 것입니다.

이것이 발표자 오버레이가 적용되었을 때 알림을 받는 방법입니다.

알림을 받으면, 효과가 시작되었는지 멈췄는지 확인하고 싶습니다.

발표자 오버레이는 새로운 macOS 시스템 기능이며, 오버레이가 적용될 때 애플리케이션이 취할 수 있는 몇 가지 고려 사항이 있습니다.

발표자 오버레이가 켜져 있으면, AVCaptureSession은 일반적인 라이브 카메라 스트림을 보내지 않습니다.

그것은 당신의 카메라가 오버레이에서 직접 사용될 것이기 때문입니다.

이 변화를 설명하기 위해 애플리케이션 UI를 업데이트하기에 좋은 시간이 될 것이다.

예를 들어, 화상 회의 응용 프로그램은 카메라와 혼합되는 공유 콘텐츠를 고려하여 오디오 및 비디오 동기화를 조정하고자 할 수 있습니다.

더 최적화된 모습을 위해 발표자의 카메라 타일을 숨기고 싶을 수도 있습니다.

발표자 오버레이는 카메라 및 비디오 기능이므로, 애플리케이션은 더 높은 프레임 속도를 위해 최적화해야 합니다.

발표자 오버레이 외에도, 새로운 시스템 전체 화면 공유 선택기를 활용할 수 있으며, 이를 통해 애플리케이션이 사람들이 공유하고 싶은 콘텐츠를 선택하는 방법을 중심으로 한 여러 기능과 완전히 통합할 수 있습니다.

이것들은 당신이 스트림을 만드는 데 사용하는 일반적인 구성입니다.

현재, 당신은 공유할 수 있는 사용 가능한 모든 화면 콘텐츠를 얻기 위해 SCSharableContent에 전화합니다.

당신은 그것을 사용하여 SCContentFilter를 만들 것입니다.

SCContentFilter는 캡처할 것을 결정하는 데 사용할 것입니다.

현재, 당신은 SCSharableContent에서 그것을 구축하지만, 올해 새로, 당신은 선택기를 통해 콘텐츠 필터를 얻을 수 있을 것입니다.

피커가 SCContentFilters를 생성하는 두 가지 방법이 있습니다.

첫째, 원하는 콘텐츠는 시스템 선택기를 통해 공유할 수 있습니다.

둘째, 콘텐츠는 열려 있는 창에서 바로 선택할 수 있습니다.

두 경우 모두, 시스템은 당신의 애플리케이션과 SCContentFilter를 공유합니다.

하지만 새로운 콘텐츠 필터를 애플리케이션에 어떻게 넣나요?

새로운 API, SCContentSharingPicker를 사용함으로써.

SCContentSharingPicker는 애플리케이션과 OS 간의 인터페이스 역할을 하며, 새로운 스트림 요청, 새로운 콘텐츠 필터 및 현재 스트림 및 콘텐츠 필터에 대한 업데이트를 애플리케이션에 위임 콜백을 제공합니다.

SCContentSharingPicker에는 윈도우, 앱 또는 디스플레이를 기반으로 콘텐츠를 선택할 수 있는 시스템 수준의 콘텐츠 선택기가 내장되어 있습니다.

애플리케이션의 버튼, 새로운 비디오 메뉴 표시줄 또는 창에서 직접 콘텐츠 선택을 시작하든, 애플리케이션은 SCContentSharingPicker를 활용하여 진행 중인 스트림에 대한 활성 선택을 추가, 제거 또는 대체할 수 있습니다.

또한 애플리케이션이 새 스트림이 언제 요청되는지 알 수 있는 스트림 요청 콜백이 내장되어 있습니다.

그리고 마지막으로, 시스템 경험이 각 스트림에 어떻게 적용되는지 정의할 수 있는 스트림별 사용자 지정이 함께 제공됩니다.

SCStream의 필터를 얻기 위한 구조는 이제 SCSharableContent를 사용하는 것에서 SCContentSharingPicker 싱글톤과 함께 시스템 선택기 인터페이스를 사용하여 SCContentFilter를 다시 전달하는 것으로 이동합니다.

당신의 애플리케이션이 이 새로운 화면 공유 선택기를 활용하는 것이 얼마나 쉬운지 보여드리겠습니다.

SCContentSharingPicker의 공유 인스턴스로 시작하여 자신을 관찰자로 추가하여 모든 적절한 클래스 콜백을 받을 수 있습니다.

시스템이 내 피커 인스턴스를 인식하려면, 활성으로 설정하세요.

일단 활성화되면, 시스템은 당신의 선택기에 대해 알게 될 것이며, 당신의 애플리케이션은 시스템 UI에 포함될 것이며 사람들은 그것과 상호 작용할 수 있을 것입니다.

당신은 사람들이 피커를 통해 창을 선택할 수 있는 스트림을 만들고 싶기 때문에, 싱글톤 메소드 picker.present를 호출하고 nil과 당신이 제시하고 싶은 피커 스타일을 전달할 것입니다.

사람들이 UI 버튼을 누르면, 선택기가 표시되어 캡처하고 싶은 창을 선택할 수 있습니다.

그 콘텐츠가 선택된 후, 새 필터의 관찰자 콜백을 통해 알림을 받게 될 것입니다.

그리고 이제 이 필터를 사용하여 새 스트림을 만들거나 기존 스트림을 업데이트할 수 있습니다.

나머지 관찰자 콜백도 똑같이 중요하다.

피커를 활성화하고 제시하여 다시 설정하세요.

당신은 또한 당신이 그것을 제시해 달라고 요청했을 때 피커가 실패했는지 알고 싶을 것입니다.

만약 그것이 실패했다면, 당신은 사람들에게 알리기 위해 신청서에 알림을 게시하고 싶을 것입니다.

또한, 피커가 제시되었지만 취소된 경우, 콘텐츠가 선택되지 않은 경우, 그에 따라 스트림의 상태를 설정해야 합니다.

SCContentSharingPicker는 또한 시스템이 스트림별 수준에서 어떻게 동작할지 사용자 정의할 수 있는 방법을 제공합니다.

SCContentSharingPickerConfiguration은 몇 가지 사용자 지정을 허용합니다.

AllowedPickingModes는 콘텐츠 필터에 대한 창, 응용 프로그램 및 디스플레이 선택 간에 허용되는 피킹 모드 중 하나를 시스템에 알려줍니다.

그것은 또한 시스템 경험에 의해 선택될 수 없는 excludedWindowID와 bundleID의 명시적인 선언을 허용합니다.

사람들이 변경하는 것을 원하지 않는 스트림이 있다면, SCContentSharingPickerConfiguration에는 해당 기능을 적용할 수 있는 속성이 있습니다.

먼저, 당신은 공유 피커 인스턴스를 받게 될 것입니다.

자신을 관찰자로 추가하고 피커를 활성화하는 것으로 시작하세요.

이제, 적절한 구성 설정을 설정하세요.

이 스트림의 경우, 아마도 당신은 두 개의 특정 응용 프로그램의 선택을 제외하고 싶고 재선택을 허용하고 싶지 않을 것입니다.

구성이 설정되면, 선택기에서 설정 구성을 호출하여 구성 및 응용 스트림을 전달하십시오.

이제 피커는 주어진 스트림에 대해 어떻게 행동해야 하는지 정확히 알게 될 것이다.

또한 각 스트림은 애플리케이션의 요구에 가장 잘 맞는 다른 피커 구성을 가질 수 있다는 점에 유의하십시오.

요약하자면, 모든 ScreenCaptureKit 스트림은 이제 macOS 경험에 통합되어 모든 애플리케이션이 발표자 오버레이와 같은 새로운 기능을 활용할 수 있습니다.

그리고 애플리케이션을 새로운 시스템 선택기 UI에 통합하기 위한 새로운 API인 SCContentSharingPicker를 소개했습니다.

하지만 애플리케이션의 화면 캡처는 단지 라이브 스트림에 관한 것이 아니므로, 이 새로운 스크린샷 API에 대해 더 이야기하기 위해 제 동료인 나탈리에게 전달하고 싶습니다.

나탈리: 고마워, 크리스토퍼.

올해 ScreenCaptureKit에는 화면에서 바로 스틸 이미지를 쉽게 잡을 수 있도록 설계된 새로운 API가 있습니다.

새로운 스크린샷 API는 스크린샷에 ScreenCaptureKit 스트리밍의 이점을 제공합니다.

앱이나 창별 고급 필터링, 여러 픽셀 형식 및 색상 공간, 커서 가시성과 같은 기타 옵션과 같은 기능을 사용할 수 있습니다.

이제 친숙한 ScreenCaptureKit 구조를 사용하여 원하는 정확한 화면 콘텐츠의 이미지를 효율적으로 캡처할 수 있습니다.

새로운 API는 비동기식이다.

출력 이미지의 경우, CMSampleBuffer 또는 CGImage 형식 중에서 선택할 수 있습니다.

CMSampleBuffer 옵션에는 추가 픽셀 형식을 사용할 수 있으며, 특정 형식에 관심이 있다면 좋습니다.

이미 코드에서 CGImage를 사용하고 있다면, 이 형식을 사용하면 통합하기가 더 쉬울 것입니다.

어느 형식이든, 스크린샷은 ScreenCaptureKit 스트리밍과 거의 모든 구성 옵션을 사용하며 유사한 설정 흐름을 따릅니다.

CGWindowListCreateImage를 사용하는 경우, ScreenCaptureKit으로의 전환을 더 쉽게 할 수 있는 몇 가지가 있습니다.

CGWindowList API에 사용할 수 있는 모든 창 이미지 옵션은 ScreenCaptureKit의 SCStreamConfiguration 클래스에서 찾을 수 있습니다.

특정 창 ID 위의 모든 창을 얻는 것과 같은 창 목록 옵션은 SCShareableContent 내에서 제공됩니다.

그리고 CGImage 출력 작업에 익숙하다면, 새로운 스크린샷 API는 기존 코드에 쉽게 통합할 수 있는 CGImage 출력 형식을 제공합니다.

스크린샷을 찍는 것은 ScreenCaptureKit 스트리밍과 비슷한 흐름을 따르지만, SCStream을 만드는 대신 스크린샷 API를 호출할 수 있습니다.

시작하려면, 스트림을 만드는 것과 마찬가지로, SCShareableContent를 사용하여 원하는 콘텐츠를 얻고 SCContentFilter를 만드세요.

스크린샷에 원하는 모든 옵션으로 SCStreamConfiguration을 설정하는 것을 잊지 마세요.

콘텐츠 필터와 스트림 구성이 있으면, 스크린샷 API를 호출하여 전달하세요.

API는 SCScreenshotManager 클래스의 클래스 메소드이므로 스크린샷을 찍기 위해 SCScreenshotManager 객체를 만들 필요가 없습니다.

스크린샷 이미지가 준비되면, 선택한 형식으로 비동기적으로 반환됩니다.

또한 새로운 시스템 선택기를 사용하여 콘텐츠 필터를 만든 다음, 이를 사용하여 스크린샷 API를 호출할 수 있습니다.

이것은 사람들이 직관적인 방식으로 원하는 콘텐츠를 선택할 수 있는 좋은 방법이 될 것이다.

스크린샷을 찍을 때, 필요한 것에 따라 선택할 수 있는 두 가지 버전의 API가 있습니다: 하나는 CMSampleBuffer 출력 유형이고 다른 하나는 CGImage 출력 유형입니다.

그 외에, 두 버전은 같은 방식으로 작동하며 스크린샷을 비동기적으로 반환할 것입니다.

다음은 스크린샷 API를 사용하는 방법에 대한 코드 예시입니다.

SCContentFilter와 SCStreamConfiguration을 설정하는 것으로 시작하세요.

그것들을 준비하면, 스크린샷 API를 호출하고, 돌아올 때까지 기다리면, 스크린샷을 받을 수 있습니다.

그리고 그것이 ScreenCaptureKit의 새로운 모든 것입니다.

요약하자면, 시스템 레벨 UI를 사용하여 애플리케이션과 완전히 통합된 화면 공유 경험을 만드는 SCContentFilters를 만드는 새로운 API가 있습니다.

새로운 발표자 오버레이 비디오 효과는 보다 역동적인 화면 공유 경험을 제공하며, 새로운 스크린샷 API를 사용하면 ScreenCaptureKit의 힘으로 일회성 화면 캡처를 할 수 있습니다.

ScreenCaptureKit에 대한 자세한 내용은 작년의 세션인 "ScreenCaptureKit을 만나세요"와 "ScreenCaptureKit을 다음 단계로 끌어올리세요"를 확인하세요.

봐줘서 고마워.