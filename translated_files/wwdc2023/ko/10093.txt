10093

♪ 부드러운 기악 힙합 ♪

♪

크리스토퍼 피게로아: 안녕하세요, 저는 애플 ARKit 팀의 크리스토퍼 피게로아입니다.

피터 쿤: 그리고 저는 유니티의 피터 쿤입니다.

크리스토퍼: 유니티는 엔진과 XR 생태계를 이 새로운 플랫폼에 도입하여 당신과 같은 유니티 개발자가 프로젝트를 쉽게 가져올 수 있도록 만들었습니다.

피터와 나는 당신이 이미 익숙한 유니티 워크플로우를 사용하여 Rec Room과 같은 완전한 몰입형 경험을 구축하는 방법을 보여줄 것입니다.

당신은 완전한 몰입형 스타일로 몰입형 공간을 만드는 것으로 시작할 것입니다.

이를 통해 앱이 패스스루를 숨기고 누군가를 다른 세계로 옮길 수 있습니다.

완전한 몰입형 경험에서, 유니티는 컴포지터 서비스를 활용하고, 앱에 메탈 렌더링 기능의 힘을 제공합니다.

유니티는 또한 ARKit을 활용하여 골격 손 추적을 포함하여 신체 위치와 주변 환경을 인식합니다.

유니티는 유니티 엔진에서 동일한 서비스를 제공하기 위해 이러한 기술을 기반으로 한다.

유니티와 함께 이 플랫폼에서 몰입형 경험을 만들기 위한 두 가지 주요 접근 방식이 있습니다.

이 플랫폼에 완전히 몰입할 수 있는 유니티 경험을 가져올 수 있으며, 플레이어의 주변 환경을 자신만의 환경으로 대체할 수 있습니다.

또는 콘텐츠를 패스스루와 혼합하여 주변 환경과 조화를 이루는 몰입형 경험을 만들 수 있습니다.

두 번째 접근 방식에 관심이 있다면, "몰입형 유니티 앱 만들기"를 확인하는 것이 좋습니다.

이제, 피터는 이러한 새로운 애플 기술이 유니티 개발자들이 이 플랫폼에 완전히 몰입형 VR 게임을 가져오는 데 어떻게 도움이 되는지 살펴볼 것이다.

피터: 고마워, 크리스토퍼.

먼저, 저는 당신에게 Against Gravity의 Rec Room을 보여주는 것으로 시작하고 싶었습니다.

사용자가 전 세계의 다른 사람들과 게임과 경험을 만들고 플레이할 수 있는 인기 있는 VR 소셜 플랫폼입니다.

그것은 게임 개발을 위한 강력하고 유연한 플랫폼을 제공하는 유니티 게임 엔진을 기반으로 합니다.

Rec Room처럼 VR 콘텐츠를 이 새로운 플랫폼으로 더 쉽게 가져올 수 있는 몇 가지 도구와 기술을 소개하겠습니다.

유니티 콘텐츠를 이 새로운 플랫폼으로 가져올 때 명심해야 할 몇 가지 사항에 대해 말씀드리겠습니다.

먼저 유니티에서 장치로 콘텐츠를 배포하는 데 사용할 워크플로우를 다루겠습니다.

이 플랫폼의 그래픽과 관련하여 명심해야 할 몇 가지 사항이 있습니다.

그리고 마지막으로, 나는 컨트롤러 입력을 수동 입력에 적응시키는 방법과 유니티가 이 전환을 돕기 위해 제공하는 몇 가지 도구에 대해 이야기할 것이다.

시작하려면, 이미 익숙해져야 할 빌드 및 실행 워크플로우가 있습니다.

우리는 이 플랫폼에 대한 전폭적인 지원을 유니티에 구축했으므로, 몇 단계만 거치면 이 장치에서 실행되는 프로젝트를 볼 수 있습니다.

첫 번째는 이 플랫폼의 빌드 대상을 선택하는 것이다.

그런 다음, 다른 VR 플랫폼과 마찬가지로, XR 플러그인을 활성화하세요.

앱이 네이티브 플러그인에 의존한다면, 이 플랫폼을 위해 다시 컴파일해야 합니다.

반면에, 원시 소스 코드나 .mm 파일을 사용하고 있다면, 이미 갈 수 있습니다.

유니티에서 빌드하는 것은 이제 iOS, Mac 또는 Apple TV 대상과 마찬가지로 Xcode 프로젝트를 생성할 것이다.

그런 다음, Xcode 내에서 더 빠른 반복을 위해 장치 또는 장치 시뮬레이터로 빌드하고 실행할 수 있습니다.

누군가의 주변 환경을 완전히 몰입형 경험으로 바꾸는 데 사용할 그래픽 파이프라인은 당신에게도 친숙할 것입니다.

하지만 이해해야 할 몇 가지 새로운 개념이 있다.

모든 프로젝트가 처음에 바로 만드는 한 가지 선택은 어떤 렌더링 파이프라인을 사용할지이다.

유니버설 렌더 파이프라인은 이상적인 선택입니다.

그것은 Foveated Rendering이라고 불리는 이 플랫폼만의 특별한 기능을 가능하게 한다.

Foveated Rendering은 눈이 초점을 맞출 가능성이 있는 각 렌즈의 중앙에 더 많은 픽셀 밀도를 집중하고, 눈이 디테일에 덜 민감한 화면의 주변부에 대한 디테일을 줄이는 기술이다.

이것은 장치를 사용하는 사람에게 훨씬 더 높은 품질의 경험을 제공합니다.

유니버설 렌더링 파이프라인을 사용할 때, 정적 포브 렌더링은 전체 파이프라인 전체에 적용됩니다.

그리고 그것은 후처리, 카메라 스태킹, HDR 등을 포함한 모든 URP 기능과 함께 작동합니다.

Foveated Rendering의 혜택을 받을 수 있는 사용자 지정 렌더링 패스가 있다면, Unity 2022에는 이 기술을 활용할 수 있는 새로운 API가 있습니다.

렌더링은 이제 비선형 공간에서 발생하기 때문에, 재 매핑을 처리할 셰이더 매크로도 있습니다.

정적 포브 렌더링을 활용한다는 것은 중요한 픽셀에 자원을 소비하고 더 높은 품질의 시각적 경험을 생성한다는 것을 의미합니다.

이 플랫폼에서 그래픽을 최적화하는 또 다른 방법은 단일 패스 인스턴스 렌더링을 사용하는 것입니다.

유니티에서 싱글 패스 인스턴스 렌더링은 이제 메탈 그래픽 API를 지원하며, 기본적으로 활성화됩니다.

단일 패스 인스턴스 렌더링을 통해 엔진은 두 눈에 대해 한 번의 드로우 호출만 제출하고, 컬링과 그림자와 같은 렌더링 파이프라인의 특정 부분의 오버헤드를 줄입니다.

이것은 장면을 스테레오로 렌더링하는 CPU 오버헤드를 줄입니다.

좋은 소식은, 앱이 이미 싱글 패스 인스턴스 렌더링을 사용하여 다른 VR 플랫폼에서 올바르게 렌더링된다면, 셰이더 매크로는 여기에서도 작동하도록 보장합니다.

마지막으로 고려해야 할 것이 하나 있다.

앱이 모든 픽셀의 깊이 버퍼에 올바르게 기록하고 있는지 확인하세요.

시스템 컴포지터는 재프로젝션을 위해 깊이 버퍼를 사용한다.

깊이 정보가 누락된 곳마다, 시스템은 표시로 오류 색상을 렌더링할 것이다.

한 가지 예는 일반적으로 사용자로부터 무한히 멀리 떨어져 있는 스카이박스이므로, 역방향 Z로 0의 깊이를 씁니다.

이것은 장치에 나타나기 위해 수정이 필요하다.

우리는 깊이 버퍼에 올바른 값을 쓰기 위해 유니티의 모든 셰이더를 수정했지만, 사용자 지정 스카이박스 또는 물 효과 또는 투명도 효과와 같은 사용자 지정 효과가 있는 경우, 일부 값이 각 픽셀의 깊이에 기록되도록 하십시오.

이제 그래픽을 장치에 렌더링했으므로, 인터랙티브하게 만들 때입니다.

이 장치의 상호 작용은 독특하다.

사람들은 콘텐츠와 상호 작용하기 위해 손과 눈을 사용할 것이다.

이 플랫폼에서 유니티 앱에 상호 작용을 추가할 수 있는 몇 가지 방법이 있습니다.

XR 인터랙션 툴킷은 기존 프로젝트를 더 쉽게 조정할 수 있도록 손 추적을 추가합니다.

유니티 입력 시스템으로 내장된 시스템 제스처에 반응할 수도 있습니다.

그리고 유니티 핸즈 패키지와의 사용자 지정 상호 작용을 위해 원시 핸드 조인트 데이터에 액세스할 수 있습니다.

XRI라고도 알려진 XR 인터랙션 툴킷은 높은 수준의 인터랙션 시스템을 제공한다.

이 툴킷은 입력을 상호 작용으로 쉽게 변환할 수 있도록 설계되었습니다.

그것은 3D와 UI 객체 모두에서 작동한다.

XRI는 손 추적과 같은 입력 유형을 추상화하고, 그 입력을 앱이 응답할 수 있는 행동으로 변환합니다.

이것은 입력 코드가 다양한 유형의 입력을 허용하는 플랫폼에서 작동할 수 있다는 것을 의미합니다.

XRI를 사용하면 3D 공간과 3D 공간 세계의 UI 모두에서 호버, 잡기 및 선택과 같은 일반적인 상호 작용에 쉽게 대응할 수 있습니다.

툴킷에는 또한 사람들이 완전히 몰입할 수 있는 공간을 더 편안하게 여행할 수 있도록 이동 시스템이 포함되어 있다.

사람들이 당신의 세계와 상호 작용함에 따라, 시각적 피드백은 몰입에 중요합니다.

XRI를 사용하면 각 입력 제약에 대한 시각적 반응을 정의할 수 있습니다.

XRI의 핵심은 기본 상호 작용 및 인터액터 구성 요소 세트이다.

인터랙터블은 입력을 받을 수 있는 장면의 객체입니다.

사람들이 상호 작용과 상호 작용할 수 있는 방법을 지정하는 상호 작용기를 정의합니다.

상호 작용 관리자는 이러한 구성 요소를 함께 연결합니다.

첫 번째 단계는 장면에서 어떤 물체와 상호 작용할 수 있는지, 그리고 그러한 상호 작용이 발생할 때 어떻게 반응할지 결정하는 것이다.

우리는 객체에 상호 작용할 수 있는 구성 요소를 추가하여 이것을 한다.

세 가지 내장 유형이 있습니다.

심플은 물체를 상호 작용을 받는 것으로 표시한다.

이 구성 요소로 SelectEntered 또는 SelectExited와 같은 이벤트를 구독할 수 있습니다.

그랩을 사용하면, 물체가 선택되거나 잡힐 때, 인터랙터를 따라가서 방출될 때 속도를 상속할 것이다.

TeleportArea 및 TeleportAnchor와 같은 텔레포트 상호 작용 기능을 사용하면 플레이어가 순간이동할 영역이나 포인트를 정의할 수 있습니다.

그리고 당신은 자신만의 맞춤형 인터랙터블을 만들 수 있습니다.

인터랙터는 상호 작용 가능으로 태그한 개체를 선택하거나 상호 작용할 책임이 있습니다.

그들은 잠재적으로 각 프레임을 가리키거나 선택할 수 있는 상호 작용 목록을 정의한다.

인터랙터에는 여러 종류가 있다.

다이렉트 인터랙터는 그것을 만지는 인터랙터블을 선택한다.

사람의 손이 상호 작용할 수 있는 물체를 만질 때, 또는 상호 작용할 수 있는 물체에 가까이 있는지 알고 싶을 때 이것들 중 하나를 사용할 것입니다.

레이 인터랙터는 멀리서 상호 작용하는 데 사용된다.

이 인터액터는 곡선과 직선으로 고도로 구성할 수 있으며, 프로젝트의 시각적 스타일에 맞게 조정할 수 있도록 사용자 정의 가능한 시각화가 가능합니다.

사용자가 상호 작용을 시작하면, 그 상호 작용이 어떻게 작동하는지에 대한 옵션이 있습니다.

예를 들어, 잡기 상호 작용이라면, 물체를 사용자의 손으로 옮기고 싶을 수도 있습니다.

그리고 레이 인터액터는 게임플레이 요구에 맞추기 위해 자유도를 제한할 수 있게 해준다.

완전히 몰입형 경험에서 일반적인 상호 작용은 물체를 잡고 그 물체의 맥락 어딘가에 배치하는 것이다.

예를 들어, 배터리를 소켓에 넣는다.

소켓 인터액터는 플레이어에게 특정 영역이 물체를 받아들일 수 있다는 것을 보여준다.

이 인터랙터는 손에 부착되어 있지 않다.

대신 그들은 세계 어딘가에 산다.

손 추적이나 심지어 컨트롤러를 사용하면, 사용자가 자연스럽게 수행하고자 하는 일반적인 유형의 상호 작용은 찌르는 상호 작용이다.

이것은 상호 작용을 유발하기 위해 올바른 동작을 수행해야 한다는 점을 제외하고는 방향 필터링을 포함한다는 점을 제외하고는 직접 인터랙터와 유사하다.

사람들이 보면서 상호 작용하기를 원한다면, 시선 인터랙터는 시선을 좀 더 쉽게 다룰 수 있도록 레이 인터랙터에 몇 가지 확장을 제공합니다.

예를 들어, Gaze Interactors는 Interactables의 충돌기를 자동으로 더 크게 만들어 더 쉽게 선택할 수 있습니다.

이 모든 것을 하나로 모으기 위해, 상호 작용 관리자는 상호 작용자와 상호 작용 사이의 중개자 역할을 하며, 상호 작용의 교환을 촉진한다.

그것의 주요 역할은 등록된 인터랙터와 인터랙터블의 지정된 그룹 내에서 상호 작용 상태의 변화를 시작하는 것이다.

일반적으로, 모든 인터랙터가 모든 인터랙터블에 영향을 미칠 수 있도록 단일 인터랙션 관리자가 설정됩니다.

또는, 여러 보완적인 상호 작용 관리자를 활용할 수 있으며, 각각 고유한 인터랙터와 인터랙터블을 가지고 있습니다.

이러한 관리자는 특정 상호 작용 세트를 활성화하거나 비활성화하기 위해 활성화하거나 비활성화할 수 있습니다.

예를 들어, 장면마다 또는 메뉴에 다른 상호 작용 세트가 있을 수 있습니다.

마지막으로, XR 컨트롤러 구성 요소는 당신이 받게 될 입력 데이터를 이해하는 데 도움을 줍니다.

그것은 손이나 추적된 장치에서 입력 동작을 취하고 인터랙터에게 전달하여 그 입력을 기반으로 무언가를 선택하거나 활성화하기로 결정할 수 있도록 합니다.

선택과 같은 각 XR 상호 작용 상태에 대한 입력 작업 참조를 바인딩해야 합니다.

손 또는 컨트롤러당 하나의 XR 컨트롤러 구성 요소에만 국한되지 않으므로, 두 손과 컨트롤러를 독립적으로 지원할 수 있는 유연성을 제공합니다.

XRI와 함께 번들로 제공되는 샘플 코드는 당신이 이것을 어떻게 할 수 있는지 보여줍니다.

XRI의 고급 기능 외에도, 유니티 입력 시스템에서 직접 시스템 제스처 입력을 사용할 수 있는 옵션도 있습니다.

그런 다음 탭 제스처와 같은 플랫폼의 내장 상호 작용을 자신의 상호 작용 시스템에 매핑할 수 있습니다.

유니티 입력 시스템의 바인딩 경로를 사용하여 이러한 시스템 제스처에 액세스하고 응답할 수 있습니다.

예를 들어, 핀치 제스처는 위치와 회전과 함께 활성화될 때 값으로 전달된다.

이것들은 입력 행동에 묶일 수 있다.

그 사람이 초점을 지시하는 곳은 위치와 회전과 함께 핀치 제스처와 같은 프레임에서 나온다.

더 많은 유연성을 위해, 유니티 핸즈 서브시스템을 사용하여 유니티 핸즈 패키지를 통해 시스템의 모든 원시 핸드 조인트 데이터에 액세스할 수 있습니다.

유니티 핸즈 패키지는 플랫폼 전반에 걸쳐 일관된 낮은 수준의 핸드 조인트 데이터에 대한 액세스를 제공합니다.

예를 들어, 각 관절을 보고 포즈가 엄지손가락이나 가리키는 집게손가락과 같은 특정 제스처에 얼마나 가까운지 결정하는 코드를 작성하고, 그것들을 게임플레이 액션으로 번역할 수 있습니다.

이것은 강력하지만 모든 사람의 손은 크기가 다르고 사람들은 다양한 동작을 가지고 있기 때문에 올바르게 하는 것이 어려울 수 있다.

이 코드는 집게 손가락이 확장되는지 알려주는 방법을 정의합니다.

OnHandUpdate 이벤트에서 이 메소드를 호출하고 한 손으로 전달할 수 있습니다.

먼저, 집게 손가락이 뻗어 있는지 확인하기 위해 몇 가지 특정 관절을 얻으세요.

만약 그것들 중 하나라도 유효하지 않다면, 그것은 거짓으로 반환될 것이다.

모든 관절이 유효하다면, 집게손가락이 말리지 않았는지 간단하게 확인하세요.

이 논리를 다른 손가락으로 확장하여 기본적인 제스처 감지를 구현하기 시작할 수 있습니다.

원시 핸드 조인트 데이터의 또 다른 용도는 사용자 지정 핸드 메쉬 비주얼에 매핑하는 것이다.

이것은 손이 게임의 예술 스타일에 더 잘 맞도록 하는 데 도움이 될 수 있습니다.

예를 들어, Rec Room은 원시 손 조인트 데이터를 사용하여 시각적 스타일에 맞는 양식화된 손 모델을 보여주었다.

그들은 또한 더 많은 몰입을 위해 다른 플레이어 핸드 모델을 보여준다.

유니티 핸드 패키지에는 원시 핸드 조인트 액세스에 대해 더 자세히 알아보고 싶다면 시작할 수 있는 샘플 코드가 있습니다.

당신의 VR 경험이 이 새로운 플랫폼에 오는 것을 보게 되어 기쁩니다.

이 플랫폼에 대한 유니티의 지원에 대한 자세한 정보를 얻고 초기 베타 액세스에 가입하려면 unity.com/spatial을 방문하십시오.

크리스토퍼: 그것들은 당신이 이미 익숙한 유니티 워크플로우를 사용하여 이 새로운 플랫폼에 완전히 몰입형 VR 경험을 제공하는 데 사용할 수 있는 도구입니다.

피터: 요약하자면, 이 세션은 Rec Room과 마찬가지로 VR 콘텐츠를 이 새로운 플랫폼으로 더 쉽게 가져올 수 있는 몇 가지 도구와 기술을 소개했습니다.

새로운 프로젝트를 시작하는 경우, 유니티 2022 이상을 사용하세요.

기존 프로젝트가 있다면, 2022년으로 업그레이드를 시작하세요.

유니버설 렌더링 파이프라인을 채택하는 것을 고려해 보세요.

내장 그래픽 파이프라인이 지원되는 동안, 향후 모든 개선 사항은 유니버설 파이프라인에 있을 것이다.

컨트롤러 기반 상호 작용을 손에 적용하기 시작하세요.

오늘 XR 인터랙션 툴킷과 유니티 핸즈 패키지로 시작할 수 있습니다.

크리스토퍼: 그리고 마지막으로, 유니티를 사용하여 패스스루로 몰입형 경험을 만드는 방법에 대해 자세히 알아보려면, "몰입형 유니티 앱 만들기"를 추천합니다.

그리고 "공간 컴퓨팅을 위한 훌륭한 게임 만들기"를 확인하여 이 플랫폼에서 게임 개발자에게 가능한 것에 대한 개요를 얻으십시오.

피터: 우리는 당신이 플랫폼에 무엇을 가져오는지 보게 되어 기쁩니다.

크리스토퍼: 봐줘서 고마워.

♪