10854

こんにちは。私はジェリ・メイソンです。私はHomePodチームのソフトウェアエンジニアです。

そして、Cloud Extensionsを搭載したSiriKit Media Intentsを使用して、メディアサービスを家庭に持ち込むことをご案内します。

開発を始めるのに必要なものすべてから始めましょう。

まず、サービスを効果的に開発するためのいくつかの重要な前提条件について説明します。テストホームの設定方法、テスト用にHomePodを設定する方法、開発用にiOSデバイスを設定する方法、そして最後に、サービスをホームにオンボーディングするためにアプリにMediaSetupフレームワークを採用します。

これらの手順を実行したら、あなたのコンテンツを愛する人々のためにHomePodで素晴らしい再生体験を生み出すことができます。

前提条件に飛び込みましょう。

HomePodでSiriKitメディアインテントをサポートするには、サービスがすでにiOSアプリのメディアインテントをサポートしている必要があります。

Developer.apple.com/siriでプログラムに申し込む必要があります。

申請後、サービスが実装する必要があるCloud Extension API仕様へのアクセスに関する詳細が届きます。

その後、当社にサービスを登録して、開発を開始するための資格とプロファイルを取得できます。

そして最後に、HomePodがCloud Extension APIを介してサービスに手を差し伸べる前に、OAuthフローと仕様で定義された構成Webサービスを実装する必要があります。

登録についてもっと話しましょう。

サービスを登録するには、サービス名、デバイスでサービスを確認するために作成した公開署名キー、ホームのiOSデバイスからサービスのアイコンを取得するための静的URL、およびサービスを使用しているアプリのバンドルIDのリストを提供する必要があります。

この情報は、テストおよび開発デバイスにインストールできる開発プロファイルを作成するために使用されます。

プロファイルを持つデバイスのみがサービスをテストできます。

Cloud Extension APIはWeb技術を使用しているため、OAuth 2.0エンドポイントを使用した認証を採用しているため、驚くことではありません。

しかし、あなたのアプリは信頼できるクライアントの役割を担うため、クライアントの資格情報フローを実装するサービスが必要です。

ホームに追加されたサービスアカウントごとに、一意のClientIDとClientSecretが必要です。

このフローではまれですが、Authサービスに直接提供されるこれらの資格情報の一般的な再利用を避けるために、更新トークンの発行が推奨されます。

これは、更新トークンフローがなければ、ClientIDとClientSecretが長生きする可能性があるためです。

誰かが自宅からあなたのサービスを使用している限り、更新トークンまたは元の認証のいずれかをサポートする必要があります。

iOSアプリは、サービスから要求し、iOSメディアセットアップAPIに提供することで、これらの資格情報を提供できる必要があります。

HomePodは、意図を解決するためにあなたのサービスに手を差し伸べます。

iOSでは、サポートする意図の詳細は、アプリのバンドルの一部です。

クラウド拡張機能では、サポートされているエンドポイントと、それらに到達するために使用するURLを識別する1つ以上の構成リソースエンドポイントを実装する必要があります。

ここには多くの柔軟性があります。

複数の静的URLを持つか、それらを動的に作成するエンドポイントを実装することができます。これらはすべて、開発およびステージングテスト構成に役立ちます。

エンドポイントは、リクエスト承認ヘッダーをチェックして、設定を取得するアカウントを特定することもできます。

構成の本体は、JavaScriptオブジェクト署名および暗号化標準を使用してエンコードされており、デバイスがそれを受け入れるには適切に署名する必要があります。

リソースを提供する場合でも、クライアントが頻繁に取得する必要がないように、標準のHTTPキャッシュ制御ヘッダーを提供する必要があります。

アプリがホームにサービスを追加するたびに、このリソースのURLとクライアントの資格情報を提供します。

これらの前提条件が満たされて、テストホームの設定について話しましょう。

サービスの開発とテスト中に、Apple Homeアプリで専用のテストホームを持つことを強くお勧めします。

そうすれば、個人的に使用できるHomeKitホームには影響せず、テストホームのデバイスの構成を管理するだけで済みます。

また、同じホームで異なるアカウントでサービスをテストできるように、複数のテストiCloudアカウントを持つこともできます。

そして当然のことながら、HomePodとiOSテストデバイスで同じアカウントを使用していることを確認する必要があります。

ホームアプリで新しい家を作るのは簡単です。

まず、ホーム設定をタップし、ホームを追加し、ホームの名前を入力します。

これで、他のテストユーザーである人を追加できます。

わかりました。テストホームを設定したので、HomePodを追加してから設定する必要があります。 設定する必要があります。

通常、最新のtvOS Developer BetaリリースをHomePodまたはAppleが現在開発に推奨しているリリースにインストールしたいと思うでしょう。

アプリを提出する準備が整うまで、通常のtvOSリリースを使用できないことを知っておくことが重要です。

それまでは、iOSのホームアプリにサービスのためにAppleが提供する開発プロファイルをインストールする必要があります。

自宅でテストする予定のデバイスごとに、必ずこのプロセスを繰り返してください。

tvOSの新しいバージョンにアップデートすると、プロファイルを再インストールする必要があるかもしれません。

HomePodにプロファイルをインストールするには、まずホームアプリでテストホームが選択されていることを確認してください。

iOSデバイスでプロファイルを開きます。

インストールするデバイスタイプとしてHomePodを選択します。

「インストール」をタップし、パスコードを入力し、契約に同意し、「インストール」をタップしてインストールを完了します。

その後、テストホームでプロファイルをインストールするHomePodを選択できます。

それでおそれ。

テストと開発のためにiOSデバイスも設定する必要があります。

iOSデバイスで開発者ベータ版を使用する必要があります。

通常、tvOSと同時にリリースされたバージョンが必要ですが、最新の推奨バージョンについてはAppleに確認してください。

HomePodと同様に、開発プロファイルをインストールする必要があります。

電子メールまたはiMessage添付ファイルのモバイル設定バンドルをタップし、iOSデバイスにインストールすることを選択し、設定でプロファイルを受け入れてインストールするための一般的なフローに従います。

この時点で、iOSデバイスとHomePodデバイスが予想されるリリースを実行していることを確認することをお勧めします。

この設定は、必要なテストデバイスに対して繰り返すことができます。

それらはiPhoneまたはiPadデバイスにすることができます。

デバイスを設定することで、アプリでMediaSetupフレームワークを採用できるようになりました。

これは、最終的に、人々が自宅で使用するためにあなたのサービスを設定することを可能にするものです。

MediaSetupを使用するには、OAuthマテリアルを取得または作成するための機能をアプリに実装し、オンボーディングされるアカウントに適した構成リソースURLを選択し、Appleにサービスを登録した後に受け取った資格を追加する必要があります。

そうしないと、フレームワークを使用できなくなります。

MSSetupSessionを使用してアカウントのインストールフローをトリガーするために、目立つ検出可能なオンボーディングプレゼンテーションコンテキストをアプリに追加してください。

人々はホームアカウントの設定プロセスを案内されます。

セットアッププロセスは、OAuthサービスを使用してAPIトークンを取得し、構成リソースURLが適切に署名され、解析可能であることを確認します。

したがって、セットアップが成功する前に、先に述べたすべての前提条件が満たされている必要があります。

詳細については、developer.apple.comをご覧ください。

開発環境とテスト環境の準備が整ったので、テストホームのHomePodがあなたのサービスに手を差し伸べることができます。

クラウドでインテントを処理するシステムアーキテクチャを見てみましょう。

iPhone、iPad、またはApple TVでは、iOSアプリでメディアを再生するようにSiriに依頼すると、インテントを直接処理するか、アプリバンドルの拡張機能を介して処理します。

通常、誰かがSiriにアプリからコンテンツを再生するように頼むと、Siriはこのリクエストを処理し、アプリバンドルをインテントのターゲットとして識別し、インテント解決を実装するアプリ拡張機能をロードします。

拡張機能はサービスと通信することができ、インテントの処理は、アプリの起動をトリガーして再生を開始するか、変更を処理するように通知します。

Cloud Extensionを使用すると、これらのインテントを解決するプロセスは、デバイス上の拡張機能の実装からサービス上のAPIに移行し、HomePodは代わりにCloud Extension Intentエンドポイントに直接到達します。

Cloud Extension APIは、インテント処理用に設計されたWeb API仕様です。

OpenAPIスキーマを使用して、iOSですでに慣れ親しんでいるSiriKit Intent APIに密接に従ったオブジェクトを定義します。

開始時について議論した設定URLも仕様の一部であり、その内容はその中で定義されています。

各SiriKit Media Intentタイプにはプロトコルエンドポイント構成があり、実装の必要に応じて異なるURLに手を差し伸べることができます。

サポートされているプロトコルは、メディアの再生、メディアの追加、メディアのアフィニティの更新です。

iOSデバイスとは異なり、HomePodに結果を表示するコンテキストがないため、検索プロトコルがHomePodで提供されていないことに気付くかもしれません。

Siriにコンテンツを再生するように言うとどうなるか見てみましょう。

Siriに「Celesteの「Strange」を再生」と言うと、PlayMediaIntentHandlingフローがトリガーされます。

HomePodは、メディア検索オブジェクトでPlayMediaIntentの解決を開始します。

それはJSONでシリアル化され、あなたのサービスに送信されます。

メディア検索をカタログ内の適切なものに一致させると、応答オブジェクトが作成されます。

メディアアイテムには、Siriが対話を策定するために使用できる識別子、タイプ、および追加のメタデータがあり、「Celesteの「Strange」を再生中」とユーザーに伝えます。

さらに、このプロトコルには、インテントに関する他のフィールドを解決した後に呼び出されるハンドルメソッドがあります。

インテントのフィールドがすでに受け入れられる場合、最終的なハンドルメソッドの返却を遅らせる理由はありません。

だから、最初の要求への応答にそれを含めてください。

そうしないことは、不必要にあなたのサービスへの余分な往復を引き起こし、意図応答時間を遅くします。

ハンドル応答の中に、HomePodがコンテンツの再生を開始するときにサービスに返されるpersentIdentifierとuserInfoを含むUserActivityというオブジェクトを含めることができます。

あなたのサービスはこれらの結果に返信し、HomePodがこれらの結果を処理し、再生セッションを開始するときに、リクエストに基づいて再生するコンテンツのキューを形成し始める可能性があります。

さて、あなたのサービスからメディアが再生されているとき、私がSiriに「これを私のライブラリに追加してください」と言ったらどうなるか考えてみましょう。

AddMediaIntentHandlingフローは、以前と同様にメディアアイテムの解決から始まりますが、Siriがサービスから現在再生されているものを知っていることを除いて、現在再生中のコンテンツの識別子もメディア検索パラメータの一部です。

以前と同様に、サービスは再生中のコンテンツを識別し、リクエストに使用されたアカウントのライブラリに追加する必要があります。

次に、ResolveMediaItemを表すオブジェクトを作成し、この操作が成功したことを示すハンドルメソッドの結果をバンドルします。

その後、その応答をHomePodに返し、そこでSiriが結果を確認します。

そして最後に、私がSiriに「私はこれが好きです！」と言うとき

UpdateMediaAffinityIntentHandlingは、以前と同様にメディアアイテムの解決で再び開始され、サービスはコンテンツを識別し、ResolveMediaItem結果を作成し、アカウントが要求を認証するために使用したテイストプロファイルに対してこのアフィニティを登録し、前の例と同様に、ハンドルメソッドの結果を含めます。

これらのコンテキスト固有のリクエストには、リクエストが行われたときにサービスがHomePodで再生されているサービスである場合にのみ、コンテンツ識別子が含まれます。

また、リスナーは、現在再生されていないものをライブラリに追加したいと言うことができることを忘れないでください。

この場合、解決するためのメディア名とアーティスト名が提供されます。

しかし、これはあまり一般的ではないユースケースです。

プロトコルでJSONとして見えるように、基本的な再生メディア要求と応答を見てみましょう。

あなたのサービスで音楽を再生するために、私のHomePodに最も基本的な要求を尋ねると、あなたのサービス上のインテントエンドポイントへのすべての要求は、解決する最初の項目の前にセッションの説明を提供します。

仕様のほとんどのオブジェクトには、提示されるオブジェクトのCloud Extensionバージョン番号が含まれています。

サービスは、可能であれば、これらのオブジェクトの古いバージョンをサポートする必要があります。

新しいバージョンも、新しいメジャーバージョン番号まで下位互換性があるはずです。

インテント解決セッションには識別子があり、HTTPSリクエストのヘッダーにも搭載されます。

インテントインタラクションの解決中は同じままであり、このインテントを解決するために複数の要求が行われた場合、この識別子はそれらの間で一貫しています。

2つのタイムスタンプが提供されます。リクエストが準備されたUTC時間と、クライアントがリクエストをタイムアウトする締め切り時間です。

締め切りに間に合わなかった場合、Siriはサービスが意図を解決できないと説明します。

タイムリーな対応を提供することが重要です。

タイムアウトは10秒後に発生するので、サービスがHomePodからのリクエスト間の時間を利用できるように、意図結果を返して再生用のコンテンツを準備する作業を分割する方法を検討してください。

これらの制約とプレイヤーのコンテキストオブジェクトについては、後で詳しく説明します。

彼らは、リクエストが行われたときにHomePodで何が起こっているかについての重要な情報を提供します。

ほとんどのリクエストは、プロトコルのresolveMediaItemsメソッドで始まります。

このリクエストの最も重要な部分は、パラメータとインテントオブジェクトにあります。

これはPlayMediaIntentであり、すべてのPlayMediaIntentオブジェクトには、Siriが音声から解析したメディアの属性を定義するmediaSearchがあります。

意図の他のパラメータには、シャッフルまたは繰り返しコンテンツを再生するように頼んだかどうか、またはコンテンツの再生を再開するように頼んだかどうか、または今ではなく次または後で何かを再生するように言ったかどうかに関する情報が含まれます。

iOSでPlayMediaIntentsをすでに処理している場合は、このオブジェクトは身近に見えるはずです。

このリクエストから返される応答も見覚えがあるはずですが、いくつかの新しいひねりがあります。

結果の配列内では、メソッド名、結果オブジェクト、この場合は1つの項目を持つresolutionResult配列、このメソッドに適したresolutionResultクラスを提供します。この場合は、成功プロパティです。

そして、ご覧のとおり、この resolvedMediaItemは、私の好みのプロフィールに基づいたステーションであるYour Favoritesを表しています。

クラウドエクステンションの新機能をご紹介します。

処理する各メソッドは、サービスが結果を提供するのにかかった時間を秒単位で説明するメトリクスオブジェクトを返す必要があります。

Appleは、このデータを集計して、リスナーの経験を大まかに判断し、遅延がネットワーク接続によって引き起こされたときをよりよく評価する場合があります。

次の結果項目がここで休憩の周りを覗いているのを見ることができます-このプロトコルのハンドルメソッドです。

ハンドルメソッドの結果は、そのインテントに適した応答オブジェクトであり、ステータスコードとUserActivityオブジェクトの説明があります。

ユーザーアクティビティは、意図的な結果を表す記念品と考えてください。

MediaIntentの結果を再生するには、コンテンツの再生を開始または変更するときにUserActivityが使用されますが、iOSデバイスでは、UserActivityオブジェクトは起動時にアプリで利用可能になります。

HomePodでは、サービスはメディアキューブ再生用の別のCloud Extension APIでリスニング体験を定義します。

これまで、以前にiOSにSiriKit Media Intentsを実装したことがあれば、インテント処理は非常に使い慣れていたはずです。

クラウドサービスからメディアを再生することは、クラウド拡張機能の駆動機能です。

そして、この部分では、クラウドにメディアキューを実装するための概念と詳細を提供します。

人がSiriにHomePodでメディアを再生するように頼んだときに何が起こるかをもう一度見てみましょう。

リクエストはSiriによって処理され、当社のクラウドメディアサービス拡張機能は、お客様のサービスに代わって処理するために選択されます。

HomePodは、サービスによって実装されたクラウド拡張APIを使用して、意図を解決します。

意図を解決したら、Cloud Media Playerコンポーネントがサービスのキューエンドポイントに連絡し、再生するコンテンツを決定するキューエンドポイントです。

ほとんどのサービスでは、コンテンツ配信サービスは、多くの場合、再生する実際のオーディオファイルを提供します。

ここには2つのHomePodが描かれていることに気付くかもしれません。

特定の状況では、意図を解決するHomePodは、コンテンツを再生しているHomePodと同じではない場合があります。

家族が複数のHomePodを持っている場合、あなたのサービスがすでに家の中の複数の場所で再生されていて、そのセッションがキッチンで始まっていたとしても、リビングルームの誰かに最も近いHomePodは彼らの要求に応えるかもしれません。

サービスがキューを介してどのようにコンテンツを提供するかを見てみましょう。

さまざまなイディオムやさまざまなリスニング体験のユースケースなど、メディアキューの高レベルの概念をいくつか説明します。

そして、キューの管理とその寿命の詳細に飛び込みます。

そして最後に、あなたのサービスがHomePodの再生コントロールをどのように定義しているかを説明します。

さて、あなたのサービスからキューを提供することが何を意味するのかを探りましょう。

Cloud Extensionでサポートされているすべてのリスニングエクスペリエンスは、コンテンツアイテムのキューを再生することによって定義されます。

キューは、意図解決に起因するユーザーアクティビティオブジェクトをサービスに送信することによって作成または変更されます。

サービスは、コンテンツアイテムのキューを一度に返すか、おそらくセグメントで返します。

いくつかのユースケースと、それらをキューとして概念化する方法を見てみましょう。

インターネットラジオコンテンツは、多くの場合、プロモーショントラックから始まり、その後、多くの曲、多くの場合、広告、より多くの曲から始まり、リスナーが再生を停止するまで無期限に続きます。

オンデマンドの音楽リクエストは、単一のアルバムやプレイリストなどの他のコレクションに解決され、有限のキューに制限されます。

また、ライブストリーミングコンテンツは、多くの場合、ライブストリームソースを参照する1つのコンテンツを持つ最小限のキュー応答を形成する単一のコンテンツアイテムを持ちます。

キュー内のコンテンツアイテムは、識別子、URL、およびコンテンツの名前、アーティストなどのさまざまな記述属性で記述できます。

コンテンツの選択は、厳格なアルバムトラックの順序から完全に動的な選択まで、サービス内の任意の数のアルゴリズム形式を取ることができます。

キューは、これらすべてのユースケースをサポートすることを目的としています。

それでは、キュー内のコンテンツアイテムのシーケンスを慣用的に表現できるさまざまな方法について話しましょう。

私が説明するイディオムは、さまざまな目的のためにセグメントに分割されたキューを使用する際のバリエーションです。

そこで、ここでは、オブジェクトによって記述された時間の経過とともに概念的に実現されたコンテンツを持っています。

これらの4つのコンテンツは、意図的な解決の結果として表現したい完全なリスニング体験であるとします。

独自の識別子とこれらすべてのコンテンツアイテムの単純な配列を持つキューオブジェクトにそれらをパッケージ化することができます。

それはかなり基本的なキューオブジェクトです。

これは、キューに有限で不変のコンテンツリストが含まれている静的コンテンツイディオムです。

1つのキューセグメントに収まる場合と収まらない場合がありますが、概念的には、順番に再生できるコンテンツアイテムの厳格なリストです。

このイディオムのユースケースには、アルバムやプレイリストのオンデマンド音楽リクエスト、またはキューが無期限にストリーミングされる1つのコンテンツのシンプルなラッパーであるライブストリームのユースケースが含まれます。

しかし、あなたのサービスはより複雑なキューを持つことができます。

キューはセグメントに分割でき、URL参照を介して次のコンテンツと以前のコンテンツアイテムに内部的にリンクします。

HomePodは、サービスが定義するようにこれらのセグメントを取得し、特定のセグメントを動的に生成し、リスニングセッションが新しいセグメントに移動するにつれて、自然に遷移するか、コンテンツアイテムを前方または後方にスキップすることによって、異なる結果を返すことができます。

この特定の例は、サービスが一連の固定コンテンツセグメント内で広告を提供するユースケースに当てはまる可能性があります。

そして、プレイヤーがキューセグメントBに遭遇するたびに、異なる広告が再生される可能性があります。

これは、サービスキューのコンテンツが動的に取得されるため、サービスが入力された場合よりも各キューセグメントに対してより多くの要求を経験することを意味します。

あなたのサービスは、コンテンツと再生オプションを最も個別に制御したいと思うかもしれません。

また、完全に動的なイディオムでは、すべてのキューセグメントには1つのコンテンツアイテムが含まれており、リスナーがキューを進めるにつれてキューの新しいコンテンツを動的に取得できます。

これは、キューが通常無期限のサイズであるため、インターネットラジオのユースケースで人気のある慣用句です。

また、キューコンテンツ自体がリスニング動作の機能であるためです。

トラックをスキップし、Siriの意図を通じてコンテンツの親和性を提供すると、アカウントに関連付けられた味覚プロファイルが変更される可能性があるため、今後のコンテンツアイテムは異なる方法で選択される可能性があります。

当然のことながら、これはあなたのサービスで最も多くのリクエスト処理を表す慣用句でもあります。

これらのイディオムは同じキューアーキテクチャを使用するさまざまな方法であるため、サービスはこれらのイディオムの任意の組み合わせを使用してキューを提供でき、特定の種類のリクエストに対して実装する代替イディオムを選択することもできます。

それらは、複雑さと能力のトレードオフを考慮するのに役立ちます。

十分な理論。サービスがこれらのキューをどのように作成および管理するかについて話しましょう。

PlayMediaIntentHandlingリクエストがインテントエンドポイントから戻ると、サービスはキューの表現の作成を開始する必要があります。なぜなら、その後まもなく、キュー再生メディアエンドポイントでリクエストが初期または完全なキューセグメントを取得するために行われるためです。

各セグメントは、サービスが望むように次のセグメントと前のセグメントにリンクすることができ、潜在的に無限または循環的なコンテンツのセットを提供します。

通常、新しく取得したキューは、最初のコンテンツアイテムから再生を開始します。

以前のセッションからの再生の再開をサポートするために、最初のキューセグメントでplayPointerオブジェクトを提供し、提供した時間オフセットで示されたコンテンツ項目から再生が開始されます。

スムーズでギャップのない再生をサポートするために、リスニングポイントがキューセグメントの最後のコンテンツ項目の終わりに近いため、次のセグメントは設定可能なプレロール間隔で取得され、追加されます。

PlayMusicIntentを正常に処理した後、サービスと交換された実際のJSONオブジェクトを見てみましょう。

すべてのリクエストと同様に、クライアントのバージョンから始めます。

家庭には非均質なデバイスセットがあるかもしれないので、あなたのコンテンツを再生するデバイスでサポートされているバージョンは、実際には意図を解決したものよりも古いか新しいかもしれません。

PlayMediaリクエストの識別子は、インテント解決で使用される識別子を継承します。

ただし、何らかの理由で再生を再起動しなければならない場合、この識別子は新しい一意の識別子である可能性があります。

これらの識別子はデバッグに役立つかもしれませんが、ユーザーアクティビティがはるかに適切なキューとインテント結果をリンクするためにこれに頼るべきではありません。

制約オブジェクトは、デバイスでの再生の特定の制限を定義します。

インテントエンドポイントでも提供されていることを覚えているかもしれませんが、これらについては後で詳しく説明します。

最後に、インテント解決がUserActivityオブジェクトを返した場合、そのオブジェクトは、キューエンドポイントがこのセッションのコンテンツアイテムを準備する方法のコンテキストを提供するために含まれます。

サービスは、キューオブジェクトを使用してリクエストに応答します。

これには、後でレポートとコンテキストと意図のために提示される識別子があり、通常、同じキューの異なるセグメント間で同じままです。

再生するコンテンツアイテムの配列を提供できますが、この小さな例では、1つのアイテムのみが提供されます。

各コンテンツアイテムを記述する属性、カタログ全体ではないにしても、このキューに固有の各アイテムの識別子、およびコンテンツの本文へのURLがあります。

ここでは、セグメントの前と次のコンテンツリンクについて説明します。

これらのURLからの応答の本文は、これとよく似ています。

最後に、配列の最後のコンテンツ項目の再生が終了する約5秒前に5秒のプレロールを指定すると、次のコンテンツURLが取得され、キューのコンテンツを前方に拡張します。

HomePodがコンテンツの再生を開始するために必要なのはそれだけです。

さて、すでにあなたのキューを聴いている間に、誰かがSiriに次に別のトラックを再生するように頼んだらどうなりますか?

これは、再生キューの場所を次へ解決することにより、PlayMediaIntentHandlingプロトコルで示されます。

HomePodがこの例のキューで2番目のコンテンツアイテムを再生している場合、おそらくまったく新しいキューの結果を提供したくないでしょう。

この場合、文字通りこのキュー内に1つ以上のコンテンツアイテムを挿入したいと考えています。

これを行うには、PlayMediaエンドポイントからキューセグメントを提供し、現在再生されているものと同じキュー識別子と、セグメントで運ばれるコンテンツを現在のキューセグメントに挿入する場所に関するinsertPointerオブジェクトを提供します。

挿入ポイントに特定のコンテンツ識別子が提供されていない場合、アイテムは現在再生中のアイテムの後にも挿入されます。

この動作は、意図の解決とキューの更新の間の移行中の再生コンテンツとして、競合状態の影響を軽減します。

サービスが完全に動的キューのイディオムを使用している場合でも、このテクニックを使用することをお勧めします。

最後に、キュー管理のニュアンスを取り上げましょう。

サービスエンドポイントで最大数のリクエストが発生しますが、完全に動的なイディオムは、ほとんどのメディアサービスにコンテンツを提供する最も柔軟な方法を特徴とし、コンテンツが本質的に完全に静的でない場合、概念的に管理が容易です。

キュープロトコルは、キューをナビゲートするときに一連のコンテンツを提供するのに十分な柔軟性がありますが、リスナーがキュー内で後方に移動することを許可する場合は、キュー履歴の一貫性を維持することが最善です。

リピートとシャッフルの動作を実装するには、サービスはインテント処理からこれらのオプションを特定し、シャッフルされた順序でキューコンテンツを提供するか、キュー内の以前に再生されたアイテムにつながる次のコンテンツURLなどのテクニックによって無期限に繰り返す必要があります。

これらの動作は、キューの範囲を完全に知らずに実行することは不可能であるため、HomePodはそれらをネイティブにサポートしようとさえしません。

次と前のコンテンツURLをテンプレート化できるため、キューセグメントの最後のコンテンツアイテムや、現在再生中のアクティビティキューやコンテンツ識別子など、少量のコンテキストを実装に提供できます。

サービスがキュー更新ユーザーアクティビティエンドポイントを実装している場合は、イベントの報告を介して再生キューを更新することもできます。

まもなく報告について話します。

柔軟でタイムリーなコンテンツ検索と更新を提供するために、サービスが使用できる豊富なキュー管理ツールを十分に把握していることを願っています。

最後に、このセクションでは、再生を制御し、リスナーがサービスとどのようにやり取りするかを定義します。

すべての種類のキューが同じではなく、キュー内のすべてのコンテンツを同じように扱うことができるわけではありません。

たとえば、インターネットラジオのユースケースは、通常、キューを通る前方移動のみをサポートします。

さらに、広告が再生されているときは、そのコンテンツのスキップをまったくサポートしたくない場合があります。

ラジオ局のキューで先に進むことは、プレミアムサブスクリプション、フリーミアムモデル、その他のより難解な制限など、多くの変数によって制限される可能性があります。

完全にダイナミックなイディオムは、多くの場合、これらの要件をサポートする唯一の方法です。

キュー内の異なるコンテンツ間の移動は、任意に制限される場合があります。

このインタラクションをどのように定義するかについて話しましょう。

Cloud ExtensionキューAPIを使用すると、サービスはキューオブジェクトで提供するPlayMediaControlオブジェクトとの相互作用を定義できます。

各PlayMediaControlオブジェクトは、いくつかの一般的なユースケースをサポートする事前定義されたスキームを選択できます。

この定義されたインタラクションのセットは、コントロール属性を使用して各コンテンツ項目で指定できます。

広告に曲が散在するオンデマンドサービスに適したコントロール定義の例を見てみましょう。

これらの定義は、すべてのキューオブジェクトのコントロール属性内に含めます。

この例では、コンテンツ項目がコントロールを指定しない場合に使用される必須のデフォルト定義と、広告であるすべてのコンテンツ項目で指定された広告定義の2つの定義があります。

すべての制御定義にはプロトタイプスキームがあります。

デフォルトでは、キュー内のコンテンツアイテムはオンデマンドスキームになり、広告コンテンツの場合は広告スキームになります。

このスキームは、ユーザーが次のコンテンツ項目に移動するように要求したときにSiriダイアログを変更します。

その後、Siriは広告をスキップすることは許可されていないと返信するかもしれません。

このスキームでは、すべてのナビゲーションコマンドを無効にすることもデフォルト設定されていますが、選択的に再度有効にすることができます。

コマンドを有効にする例もここで提供され、通常はデフォルトで無効になっている dislikeTrackコマンドとlikeTrackコマンドがオンデマンドコンテンツによって有効になっています。

キュー内のアイテムにリンクされたコントロール定義の小さなセットを使用して、コンテンツとのインタラクションを実質的にカスタマイズする方法を確認できます。

最後に、コントロール定義では、サービスがオプションのコマンドイベント、ナビゲーション情報、コンテンツの再生ステータスを受け取る方法であるユーザーアクティビティレポートのオプションを指定することもできます。

これらはすべて私が次にカバーしようとしているトピックです。

これまでのところ、HomePodが意図を解決し、再生するコンテンツのキューを管理するためにあなたのサービスに手を差し伸べる方法を見てきました。

次に、サービスがどのように再生イベントを認識し、時間の経過とともに要求をコンテキスト化できるか、リスニングアクティビティをサービスに報告する方法、サービスからキューをすでに再生しているときに再生コンテキストがどのように提供されるか、最後に、サービスが特定の再生制約をどのように尊重する必要があるかについて話します。

では、報告から始めましょう。

リスナーアクティビティは、Cloud Extension APIのメディアキューアップデートアクティビティエンドポイントを使用して報告されます。

このエンドポイントは技術的にはオプションですが、ほとんどのサービスは、人々がコンテンツを聴くときにHomePodからステータスレポートを取得するためにそれを実装しています。

サービスは、スキップ、一時停止、再生の継続、トラック内のスクラブなどのトランジションやメディアコントロールイベントのレポートを受け取ります。

特に部分的または完全に動的なキューイディオムを実装している場合、キューのコンテンツはこれらのレポートの影響を受ける可能性があります。

サービスは、応答として新しいキューセグメントを返すことさえできます。

更新アクティビティ要求はキューのコンテンツ検索から非同期に行われるため、トラックスキップのレポートに新しいキューを返すと、キューのコンテンツがきれいに表示されず、通常のトランジションロジックと戦う可能性があるため、再生時にいくつかの可聴ジャンプが発生する可能性があります。

レポートからのキュー応答のみを使用して、再生を完全に変更したり、新しいコンテンツを挿入したりします。

コンテンツURLテンプレートを使用して、キューセグメントが取得された理由のコンテキストを取得します。

更新アクティビティエンドポイントに対して行われたリクエストの例を見てみましょう。

この例では、Siriに次のトラックにスキップするように頼みました。

これらの単純な相互作用は意図ではなく、メディアコントロールです。

JSONでは、レポートは次のようになります。

ご覧のとおり、作成されているレポートのタイプはskip_nextとしてタグ付けされています。

レポートタイプのフルセットは仕様で定義されており、トラック間の自然な遷移、トラック内のスクラブ、および新しいキューが既存のキューを置き換えるときが含まれます。

アクティビティ、キュー、contentIdentifier、現在再生されているコンテンツへのオフセットなど、nowPlayingコンテキストが提供されます。

トランジションには、以前に再生したコンテキストも提供されます。

これは、最後に再生されるコンテンツに関連付けられた識別子と、再生が移行されたときのコンテンツ内のオフセットを表します。

リスナーがすぐにスキップした場合、これを使用してリスナーの味覚プロファイルを更新することができます。

しかし、この場合、offsetInMillisの値でわかるように、私はその曲のかなりの部分を聴きました。

だから、あなたのサービスは、少なくともその相対的な評価を下げないように、私がおそらくそれを気に入ったと仮定するかもしれません。

また、キューAPIの他のエンドポイントと同様に、ユーザー情報データがサービスが状態を回復し、この情報を迅速に処理するのに役立つ場合に備えて、ユーザーアクティビティオブジェクトが完全に表示されます。

サービスが使用できるより高度な機能もあります。

たとえば、コンテンツが再生中に再生間隔レポートを要求して、特定のポイントに到達したこと、または特定の繰り返し間隔が経過するたびに知ることができます。

iOSデバイスがHomePodで再生を制御するときに、特定のMPRemoteCommandCenterコマンドのレポートを有効にして受信できます。

likeTrackと dislikeTrackのリモートコマンドは、更新メディアアフィニティインテント処理と同じではないことに注意してください。

それらは音声の意図ではなく、家のどこにでもあるiOSデバイスからの簡単なタップです。

以前、新しいキューを返すことについて説明しましたが、更新されたバージョンのオブジェクトを返すことで、再生中にユーザーアクティビティオブジェクトを更新することもできます。

これは、アクティビティ定義を含むカスタム制御スキームの先ほど見た例です。

デフォルトのコントロールには、60秒のplayElapsedIntervalが含まれています。つまり、コントロール属性を持たないコンテンツアイテムが再生されると、60秒ごとにレポートが生成されます。

しかし、広告の制御属性を持つアイテムの場合、コンテンツの5秒が経過するとすぐにレポートが生成され、10秒ごとに別のレポートが生成されます。

仕様で定義されているレポート間隔にはいくつかの制限があります。

レポートはサービスに多くのデータを提供しますが、何百万人ものリスナーが意図を処理するため、サービスでそのコンテキストを追跡することは高価になる可能性があります。

セッションコンテキストをサービスに提供して、キューの再生とインテント処理のエンドポイントコンテキストをブリッジすることができます。

セッションコンテキストは、HomePodが現在サービスからメディアを再生している場合にのみ利用できます。

特定のコンテンツが好きだとSiriに伝えると、レポートセクションで説明されているnowPlayingオブジェクトがすべてのレポートで送信されるのと同じように、インテントサービスエンドポイントはplayerContextオブジェクトを受け取ります。

プレイヤーコンテキストには、コンテンツ、キュー、ユーザーアクティビティの persistentIdentifier 値が含まれます。

これらは、私が以前に導入した3つのレベルの定義を網羅しています。潜在的に長寿命のリスニングセッションを定義するActivity persistentIdentifier、キューは、現在のリスナーの経験と、意図解決時に現在再生されている特定のコンテンツを定義します。

このアイテムはインテントメディア検索オブジェクトにも搭載されており、すでにiOSデバイスでの使用に精通している可能性があります。

更新アクティビティエンドポイントを実装する必要性を回避し、より複雑なレポートイベントを処理するために、セッションコンテキストがサービスに十分な情報であるかどうかを検討してください。

この例では、UpdateMediaAffinityIntentHandlingのリクエストでは、HomePodはすでにサービスからキューを再生していたため、playerContextオブジェクトがインテントエンドポイントに提供されます。

セッションオブジェクト内では、サービスが現在再生されていない場合は、playerContextまたはnull値が見つかります。

サービスのテイストプロファイルがメディアアフィニティと再生メディアリクエストによってのみ明示的に駆動される場合、プレーヤーコンテキストは完全なレポートを実装せずにすべての要件を処理する場合があります。

しかし、サービスがこれらのツールの味覚プロファイル情報を使用する前に、すべてのリクエストで送信された使用の制約も尊重する必要があります。

家庭では、あなたのサービスが知り、尊重しなければならない異なる種類の文脈意識があります。

各HomePodは、サービスに制約を形成する特定のオプションで設定できます。

たとえば、子供部屋のHomePodには、結果から露骨なコンテンツを除外するオプションがあるかもしれません。

このHomePodでリクエストが行われるたびに、露骨なコンテンツを返すべきではありません。

しかし、設定が有効になっていない寝室のHomePodへのリクエストは、露骨なコンテンツを返すことを許可する必要があります。

制約はオプションではありません。

あなたのサービスは、提示された制約の影響に従わなければなりません。

私の家のゲストが何らかのコンテンツを再生するように頼んだとき、彼らはあなたのサービスにリクエストすることができ、彼らは一時的に私のアカウントを使用しますが、この相互作用は私の好みのプロフィールに影響を与えるべきではありません。

Siriは私がどのように聞こえるかかなり良い考えを持っているので、私たちは要求が私によって行われたものではないことを検出し、私の味覚プロファイルを変更するためにこの要求を使用しないようにあなたのサービスに伝えます。

制約値は、サービスのアカウント設定の既存の制限をさらに制限する必要があります。

サービスに同様の制限に対するアカウント固有のコントロールがある場合は、これらを組み合わせて、リスナーがサービスに期待するものを提供する必要があります。

セッションオブジェクトと制約定義で始まるインテント要求のもう1つの例を次に示します。

それらは小さな物体ですが、あなたのサービスが家庭環境でどのように相互作用するかに大きな影響を与えます。

updateUserTasteProfileは、この意図の解決が、好き、嫌い、再生数、および私のアカウントに関連付けられているサービスの目に見えるリスニング履歴を追跡するために使用されるかどうかを示すブール制約です。

虚偽の場合、サービスは、使用されるアカウントが再生を制御または開始する人のアカウントであると仮定することはできません。

また、このHomePodは、私の声を認識しても、私のアカウントの味覚プロファイルに決して貢献しないように設定されている可能性があるため、虚偽である可能性があります。

私がファミリールームにHomePodを持っていて、定期的に小さな子供たちに代わって音楽を演奏するように頼んでいると想像してみてください。

このオプションを設定する方法がなければ、私のお気に入りの音楽ステーションは私が好きなよりもかなり折衷的かもしれません。

allowExplicitContentは、HomePodとホームアプリごとの設定を反映する別のブール制約です。

そして、あなたのサービスは、意図からの結果で明示的なコンテンツをフィルタリングするためにそれを考慮する必要があります。

実際、検索に一致する非明示的なコンテンツがないために特定のインテント要求を満たすことができない場合、ResolvedMediaItemメソッドの特定のエラー結果はSiriKit Media Intentsで提供されます。

最後に、ハードウェアにも制約があります。

キューセグメントは有限サイズのみで、その値はデバイスごとに動的です。

キューがこの値より大きい場合は、この制限に準拠するためにセグメント化されたキューイディオムを実装する必要があります。

最小サイズは、セグメントごとに100個のコンテンツアイテムです。

今日はたくさん取り上げましたが、それをすべて消化するのにしばらく時間がかかるかもしれません。

アクセスできたら、仕様をさらに詳しく調べることをお勧めします。

今日取り上げたすべてのエンドポイントについて詳しく説明します。

この仕様には、実装する必要があるサービスエンドポイントのオープンAPI定義があり、サービスを開発する際に基本的なデータモデルの解析と検証コードを生成するのに十分完全です。

それはとても役に立ちます。

Cloud Extension APIの定義は、新しいリリースごとにiOS SiriKit Media APIの変更を追跡します。

ほんの数例外を除いて、デバイス上のSiriKit Media APIを通じて利用可能なほとんどすべてのものは、Cloud Extension APIを通じて利用可能です。

また、キューAPIは、強力な再生定義、制御、レポートをサービスに直接提供します。

SiriKit Media Intentsにご関心をお寄せいただきありがとうございます。今後のSiriKit Media APIの変更については、developer.apple.com/siriで最新の情報を入手してください。