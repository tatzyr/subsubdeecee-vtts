10876

デイブ・ロバーツ:こんにちは。私はアップルのGPUソフトウェアチームのデイブ・ロバーツです。

新しいApple A15 BionicチップのGPUのアップデートを共有できることを本当に楽しみにしています。

その後、GPUソフトウェアチームの同僚であるケイトリン・ヒンソンが、GPUの新しいメタル機能についてすべてお話しします。

彼女はまた、いくつかのクールなユースケースを探索しながら、Metalアプリでこれらの機能を使用する方法を紹介します。

A15 Bionicは、CPU、GPU、ニューラルエンジン、その他のユーザーエクスペリエンス向上技術のアップデートを備えた、Metalアプリやゲームのための強力な新しいプラットフォームです。

A15 GPUは、A14 Bionicと同じタイルベースの遅延レンダラーとユニファイドメモリアーキテクチャに基づいて構築されています。

私たちはさまざまな分野で多くのマイクロアーキテクチャの改善を行いましたが、私が強調すべきパフォーマンスのためのいくつかの重要な変更があります。

A15のGPUには最大5つのシェーダーコアがあり、その5番目のコアは同じGPUコア周波数で25%のパフォーマンス向上を提供します。

シェーダーコアは、数学の多いワークロードでGPUのパフォーマンスを向上させることができるF32浮動小数点数学ユニットの2倍になりました。

A15のGPUはまた、UIをさらに反応良くし、バッテリー寿命をさらに延ばします。

そして、コードを変更することなく、これらの素晴らしい改善をすべて無料で得ることができます。

しかし、それがすべてではありません!

A15 GPUには、Metalアプリをさらに良くするために使用できる新機能が追加されました。

そして、これらの新機能はすべて、AppleGPUFamily8と呼ばれる新しいMetal機能セットに属しています。

残りの講演では、Katelynと私はこれらの新機能に焦点を当て、それらが何であるか、なぜ有用であるかを説明し、それらをサポートする新しいMetal APIとシェーディング言語の変更をカバーします。

まず、A15の新しいグラフィックス処理機能。

画像の品質への影響を最小限に抑えながら、アプリのテクスチャメモリ使用量を使用する損失圧縮。

この新しいA15機能は、ロスレス圧縮と同じテクスチャメモリ帯域幅の節約を提供します。

Metalアプリで非可逆圧縮を使用する方法を、もう少し詳しく説明します。

後で、Katelynは、A15 GPUがスパース深度とステンシルテクスチャの両方にレンダリングを含めることで、スパーステクスチャの既存のサポートをどのように拡張するかを紹介します。

Katelynは、SIMDグループシャッフルとフィルという新しいコンピューティング固有の機能もカバーします。

A15は、これらの新しい命令をGPUコア命令セットに追加します。

彼女はこの機能を説明し、画像処理などの該当するユースケースのコンピューティングカーネルの実行時間を短縮することで、アプリのパフォーマンスを向上させる方法を紹介します。

まず、非可逆圧縮を詳しく見ていきます。

損失圧縮をよりよく理解するために、損失圧縮を再検討する価値があります。

A12 Bionicは2018年に初めてロスレステクスチャ圧縮を導入し、A14 Bionicは2020年に機能にさらなる改善を加えました。

可逆テクスチャ圧縮はメモリ帯域幅を節約し、電力を節約するため、アプリは1回のバッテリー充電でさらに多くのことができます。

ロスレス圧縮は、常にテクスチャの詳細を保持することを保証します。

実際、あなたのアプリはすでにA12 Bionic以降のロスレス圧縮を利用しているかもしれません。

ロスレス圧縮の詳細については、developer.apple.comのテクニカルトーク「Discover Metal enhancements for A14 Bionic」と「Optimizing Texture Data」の記事をご覧ください。

Lossyは、A15 Bionicでテクスチャ圧縮を次のレベルに引き上げます。

ロスレス圧縮による帯域幅の節約に加えて、非可逆圧縮は非圧縮テクスチャのメモリフットプリントの半分しか使用しません。

ロッシー圧縮は、可能な限りテクスチャ品質を維持します。

そして何よりも、これをA15のレンダリングターゲットに簡単に適用して、これらのメモリ節約を最大限に活用できます。

テクスチャ記述子の新しい圧縮タイププロパティを損失設定するだけで、損失圧縮を有効にできます。

では、なぜ非可逆圧縮を使用するのですか?

さて、圧縮は、ロスレスまたはロスを使用するかどうかにかかわらず、かなりのテクスチャメモリ帯域幅を節約します。

これは、メモリに書き込まれる前にテクスチャデータを圧縮することで帯域幅を節約する圧縮ユニットです。

ロスレス圧縮を使用する場合、GPUはテクスチャの詳細を完全に保持する必要があります。

したがって、金属は圧縮の量を保証できず、完全な非圧縮テクスチャサイズをカバーするのに十分なメモリを割り当てる必要があります。

ただし、非可逆圧縮を使用する場合、テクスチャはロスレスのメモリフットプリントの半分しか使用しません。

A15 GPUが50%小さいメモリフットプリント内に収まるようにテクスチャを可逆圧縮できない場合、テクスチャの領域の忠実度が低下します。

Lossy圧縮は、ほとんどのピクセルフォーマットとテクスチャタイプをサポートしており、レンダリングターゲットで使用できます。

多くの場合、アプリをさらに変更することなく、テクスチャで有効にすることができます。

品質のトレードオフが受け入れられる場所ならどこでも、あなたのアプリが損失圧縮を有効にすることをお勧めします。

それを有効にする最も簡単な場所は、品質の低下に気付く可能性が最も低い最終的なレンダリングターゲットです。

中間レンダリングターゲットに非可逆圧縮を使用し、テクスチャ解像度の向上など、他のことにそのメモリ節約を使用することを検討してください。

また、後処理の変更を確認して、損失圧縮の恩恵を受ける可能性のあるレンダリングターゲット候補を見つけてください。

詳細なユースケースをいくつか紹介します。

最終的なレンダリングターゲットに対してのみ非可逆圧縮を有効にした場合、視覚的な違いを見てみましょう。

この分割画像は、左側の可逆と右側の可逆を比較し、違いはかなり微妙です。

彼は、ロスレス圧縮と非可逆圧縮のピクセル単位の違いを示す画像です。

黒いピクセルは違いを表しません。青と緑は小さな違いを表し、赤は最大の変化を表します。

この画像の赤と黄色のピクセルは、最終的なレンダリングで最大の違いを持ついくつかの孤立した領域を示しています。

スクーターで地域の1つにズームインすると、左の画像と右の画像の違いを見るのに苦労します。

中間レンダリングターゲットは、非可逆圧縮でもうまく機能します。

これは、可逆圧縮と非可逆圧縮を比較する水たまりの反射を並べて見ています。

ピクセルごとの差表現に再度切り替えると、非可逆圧縮反射はロスレスバージョンと最小限の違いしかありません。

さらに、テクスチャの解像度を上げて、非可逆圧縮で保存したメモリで詳細を追加できます。

たとえば、同じ量のメモリを使用しながら、ロスレスバージョンよりも詳細を示す高解像度の反射があります。

このデモの右側では、シーン内のすべてのレンダリング可能なテクスチャに非可逆圧縮を使用します。

動いているとき、シーンは非常に安定しているように見え、左側のロスレスバージョンと比較すると、違いを検出することは非常に困難です。

Metalを使用すると、アプリで非可逆圧縮を簡単に使用できます。

方法は次のとおりです。

いつものようにテクスチャ記述子を初期化することから始め、圧縮タイプのプロパティを非可逆に設定します。

次に、ストレージモードをプライベートに設定します。

最後に、テクスチャを作成します。

そして、あなたのアプリは、非可逆圧縮とそれが提供する節約を最大限に活用できるようになりました。

いくつかの例外を除いて、ほとんどの構成で非可逆圧縮用のテクスチャを作成できることに注意してください。

たとえば、2D、3D、配列、キューブなど、最も一般的なテクスチャタイプに非可逆圧縮を使用できます。

しかし、この機能は、あまり一般的ではないタイプのいくつかをサポートしていません。

同様に、非可逆圧縮は最も一般的なピクセルフォーマットをサポートしていますが、パックされたカラーチャンネルを持つフォーマットはサポートしていません。

損失圧縮は、レンダリングターゲットとして、blit操作で、およびサンプル操作と読み取り操作でそれらにアクセスするときにテクスチャをサポートします。

ただし、シェーダーの書き込み操作で非可逆テクスチャを入力することはできないことに注意してください。

損失圧縮は、プライベートストレージ内のテクスチャのみをサポートします。

共有または管理されたストレージノードは使用できません。

そして最後に、非可逆テクスチャは、MSAA、sRGB、mipmappingなどの他の一般的な機能で動作します。

非可逆圧縮サポートの詳細については、developer.apple.comのMetal機能セットテーブルをご覧ください。

したがって、要約すると、非可逆圧縮は、可逆圧縮と同じ帯域幅を節約し、テクスチャメモリの50%を節約します。

ユースケースと、アプリで損失圧縮を使用する量に応じて、かなりの量のメモリを節約できます。

損失圧縮は、テクスチャの詳細を維持することを目的としていますが、圧縮されたテクスチャデータが収まらない領域の品質をわずかに低下させるだけです。

そして最後に、非可逆圧縮は、一般的なテクスチャタイプ、一般的なピクセルフォーマット、およびシェーダー書き込み以外のすべてのGPUアクセスモードをサポートしているため、非可逆圧縮を簡単に使用できます。

聞いてくれてありがとう、今度はケイトリンに引き渡します。

ケイトリン・ヒンソン:ありがとう、デイブ。

A15 Bionicの新しいスパーステクスチャ拡張機能を紹介することに興奮しています。

スパーステクスチャは、Metalでメモリ予算を管理しながら、高解像度のテクスチャを作成するのに最適な方法です。

A13 Bionicは最初にスパーステクスチャサポートを導入し、GPUタイムライン上のテクスチャタイルをマッピングおよびアンマップできるようにしました。

アプリでスパーステクスチャを使用する方法の詳細については、2019年秋と2020年の講演を参照してください。

A15 Bionicは、深さとステンシルアタッチメントを含めることで、まばらなサポートを拡張します。

まばらなテクスチャの指針は、「使わないものを割り当てるな」です。

たとえば、このアプリはUI要素の背後にタイルをマッピングする必要はありません。

まばらな深さとステンシルテクスチャにより、このアプリは常にこれらの不明瞭なタイルを未マッピングのままにすることができます。

まばらな深さのアタッチメントでシャドウマップを最適化できます。

シャドウマッピングに精通していない場合は、この技術を使用するメタルの遅延照明サンプルをチェックしてください。

シャドウパスは光の視点からシャドウマップをレンダリングし、照明パスはそれを読み返します。

シャドウマップからサンプリングされたテクセルは、常に投影されたフルスタム内にあります。

このシナリオは、まばらなテクスチャの完璧な候補です。

照明パスはこれらのタイルをサンプリングしないため、シャドウテクスチャの大部分はマッピングする必要はありません。

これは、シャドウマッピングとそのレンダリングされたシャドウマップを使用するシーンです。

このアプリは、それらのタイルから書き戻したり読み返したりする必要がないため、ビューフスタムの外側のタイルのメモリを回復できます。

カスケードシャドウマッピングは、複数の個々のシャドウマップを使用してシーンをより効率的にカバーするシャドウのより高度な技術です。

カメラの近くに高解像度のシャドウマップを割り当て、カメラから遠く離れた低解像度のマップを割り当てます。

たとえば、このシーンは3つの重なり合うシャドウマップを使用します。

各シャドウマップは同じテクスチャ解像度を持ち、カメラから離れれば離れるほど、ますます大きな領域にマッピングされます。

シャドウマップの緑色のハイライトされた領域は、照明がサンプルを通過するテクセルを表しています。

照明は、これらのタイルから不均一にサンプルを通過します - ヒートマップとして表されます - 青いタイルはアンダーサンプリングされ、赤はオーバーサンプリングされています。

スパースタイルシャドウマップを使用して、これらのテクスチャをサンプリングレートに基づいて調整可能な解像度を持つ単一のサーフェスに置き換えることができます。

スパースタイルシャドウマップ（またはSTSM）を使用すると、単一のスパース深度サーフェスを作成します。

固定解像度のテクスチャを使用する代わりに、サーフェスはスパースミップマップチェーン全体にタイルをマッピングしました。

この手法は、目的のサンプリングレートを一致させるために必要なタイルのみをマッピングします。

これは、相対的なミップレベルの各タイルの物理的な解像度の図です。

異なるミップにまたがるタイルをマッピングすることで、シーン全体のシャドウマップの解像度を自由かつ効率的に調整できます。

STSMテクニックの主なステップは次のとおりです。

まず、サンプリングレートに基づいて密度マップを生成します。

次に、密度マップに従ってサーフェスとマップタイルを構築します。

そして、アダプティブサーフェスにレンダリングしてサンプリングします。

密度マップを生成するために、ジオメトリパスは他のパスの密度マップバッファに入力します。

最初のステップは、シャドウマップ全体でサンプリングレートを取得することです。

予想されるサンプル密度は、レンダリングされたジオメトリのシャドウ空間微分を追跡することによって計算されます。

フラグメントシェーダーは、アトミックを使用してデリバティブを2Dグリッドに格納し、shadowUV空間全体でサンプリングレートを収集します。

密度マップを取得したら、それを使用して、まばらな深度テクスチャのタイルをレイアウトし、目次バッファを生成します。

この目次バッファは、ライティングパスで使用されます。

まず、表面を反復的に分割し、下部のミップから始めて、各ミップレベルのマッピングをスケジュールすることで、深度テクスチャのタイルをマッピングします。

どのタイルをマッピングするかを把握するには、まず密度マップから現在のMIPのサンプリングレートを確認します。

この例では、密度マップは現在のミップが不十分であることを示していますが、次のミップレベルは適しています。

この場合、次のミップをマッピングし、現在のミップをアンマップすることで、タイル全体を昇格します。

これは別の、より複雑なシナリオです。

密度マップは、現在のmipが少なくとも1つの象限で満足のいくものであることを示しています。

次のmipでは、サンプルレートと密度マップは2つの象限の目標を満たし、残りの2つは目標レートを下回っています。

この場合、現在のミップでタイルをマッピングし、次のミップでタイルの半分をマッピングします。

次に、コンピューティングシェーダーは、目次またはTOCバッファに格納されるUVレベルとmipレベルの間で変換する2Dテーブルを書き込みます。

STSMからテクセルをサンプリングする前に、TOCバッファはmipを取得するためにテーブルをインデックスすることによって照明パスによって読み取られます。

シャドウマップをサンプリングすると、mipが明示的なLODパラメータとして使用されます。

次のステップは、まばらなシャドウマップをレンダリングすることです。

まず、TOCバッファを使用して影を淘汰し、間接描画コマンドをエンコードして、まばらな深度テクスチャにレンダリングします。

各ミップマップを間接コマンドバッファで個別に塗りつぶして、サーフェスをレンダリングします。

ICBは、コンピューティングパスが並列に、常駐領域に対して各シャドウジオメトリメッシュを淘汰してソートできるため、このタスクに最適です。

計算シェーダーは、タイルの境界ボリュームに対してメッシュをテストすることによって、個々のICBにドローコマンドをエンコードします。

シャドウマップ全体に伸びる大きなオブジェクトの場合、シェーダーは各mipの関連するタイルに対してオブジェクトをテストします。少なくとも1つのタイルが重なった場合、drawコマンドをmipのICBにエンコードします。

mipに重なるタイルがない場合は、そのmipのICBにオブジェクトの描画コマンドを発行しないでください。

各オブジェクトの最適化された描画コマンドセットは、並列計算スレッドですべての交差テストを実行することにより、シャドウ淘汰計算パスによってエンコードされます。

赤いメッシュはカメラに最も近いので、シャドーマップの11枚のタイルで最大の影響を与えました。

3つのタイルで最小の衝撃を持っていたカメラから最も遠いオレンジ色のメッシュと比較してください。

間接描画コマンドが完了すると、STSMはライティングパスでサンプリングされる準備が整います。

この表は、STSMとシャドウマッピングとカスケードシャドシャドマッピングを比較しています。

STSMのサンプルレートと有効品質は、単一のシャドウマップとほぼ同じですが、メモリ使用量ははるかに少ないです。

実際、同じ解像度でメモリフットプリントの1パーセント未満しか使用していません。

この深いダイビングが、まばらなタイル張りのシャドウマップを使用して、Metalアプリで効率的で高品質のシャドウを作成する方法について、いくつかのアイデアを与えてくれることを願っています。

最後に、A15のメタルコンピューティングに新しく追加されたSIMDシャッフルとフィルを紹介することに興奮しています。

現代の画像処理では、畳み込みカーネルはエッジ検出、ぼかし、シャープなどのフィルターに適用されます。

これは、現代のレンダリングデモから画像に適用された畳み込みです。

このようなワークロードは、通常、テクスチャサンプリングまたはスレッドグループメモリからの読み取りによって制限され、GPUの数学ユニットは十分に活用されていません。

Appleシリコンは、これらのワークロードを最適化するために、メタルコンピューティングシェーダーで使用できる豊富なSIMD命令セットを提供します。

SIMDグループのスレッドがロックステップで同時に実行されると、SIMDグループ関数はこのロックステップの実行を利用してスレッド間でデータを共有します。

既存のSIMD機能の詳細については、紹介されたA13 BionicとA14 Bionicの講演を参照してください。

それでは、利用可能な新しいSIMDの指示について話し合いましょう。

A15 Bionicの新機能は、SIMDとクワッドシャッフルとフィルのサポートです。

これらの指示は、以前に示したエッジ検出畳み込みのように、スライドウィンドウ画像操作を改善するように設計されています。

これらの機能は、メモリを使用せずに特定のSIMDグループ内の隣接するスレッド間でデータを共有することで、コンピューティングワークロードを最適化します。

まず、A13で最初にサポートされているクワッドシャッフルダウンの動作を見てみましょう。

データバッファには、コンテンツA、B、C、およびDがあり、クワッドのスレッドのレジスタにロードされます：0、1、2、3。

1のシフトでシャッフルダウンを適用すると、スレッド0、1、および2のレジスタデータは、スレッド1、2、3からデータを取得します。

計算されたクアッドレーンIDはラップされないため、結果のスレッド3にはシフトされていない値Dがあります。

代わりに、クワッドシャッフルとフィルダウン命令を使用すると、結果のスレッド3を更新するためのフィルバッファが提供されます。

これで、スレッドゼロの塗りつぶしデータがスレッド3の出力データにシャッフルされます。

同様に、クワッドシャッフルアップと2のシフトでフィルすると、AとBがスレッド2と3にシャッフルされ、フィルバッファからのデータが出力の下位レーンにシャッフルされます。

Appleシリコンでは、SIMDグループは32本のスレッドで構成されています。

そして、同じシャッフルとフィルの動作は、下のデルタレーンがフィルデータの上のレーンで満たされているSIMDレーン全体に適用できます。

新しいSIMDとクワッドシャッフルとフィル命令には、オプションのモジュロ引数もあります。

これにより、ユーザーが指定したベクトル幅が可能になります。

8つのモジュールの場合、SIMDグループは効果的に4つのベクトルに分割されます。

データバッファ値は最初に2つのインデックスをシャッフルし、塗りつぶしデータは8つのスレッドの各セットにシャッフルされます。

最新のレンダリング画像のエッジ検出に使用されるカーネルをSIMDシャッフルと塗りつぶしを使用して最適化できる例で、これらの新しい手順を使用しましょう。

最終結果を生成するために、5×5の畳み込みカーネルが入力画像に適用されます。

出力画像は一連のSIMDグループに分割され、各SIMDグループは4×8のチャンクで、各スレッドは単一の出力に書き込まれます。

単一のSIMDグループの出力を生成することに集中しましょう。

5×5の畳み込みでは、各スレッドは入力から5×5ピクセルを読み取る必要があります。

4×8のSIMDグループごとに、8×12の領域をコンピューティングシェーダーでサンプリングする必要があります。

この畳み込みの素朴な実装には、出力スレッドごとに25のサンプルが必要です。

これにより、SIMDグループ全体で大きな重複が生じます。

これは、シャッフルと記入の指示によって最適化され、SIMDグループ内の重複サンプルを排除し、レジスタシャッフルを通じてデータを共有できます。

なぜこれらの場所から読む必要があるのか見てみましょう。

最初にAが読み込まれます。これは、SIMDグループの各スレッドが1つのピクセルをサンプリングする4×8のウィンドウです。次に、右上のウィンドウはB、左下のウィンドウはC、最後に右下のDです。

赤いアウトラインの長方形は、出力画像のSIMDグループの宛先領域を示します。

スレッドごとに4つのサンプルを通じて、8×12の入力領域は、重複するサンプルなしでSIMDグループ全体にロードされました。

スレッドゼロの5×5の領域に再び焦点を合わせると、これらのサンプルは5×5の近傍として表すことができます。

クワッドシャッフルとフィルダウンを使用して、ネイバーの最初の行にアクセスし、最初にAのデータをシャッフルし、Bのデータで埋めることができます。

次に、前の行の32の広いベクトルが次の行にシャッフルされます。

データが全行にシャッフルされるため、32ワイドベクトルの上部レーンのCとDからサンプルをシャッフルするには、塗りつぶしベクトルが必要です。

同じアプローチを使用して、SIMDとクワッドシャッフルダウンを使用して、5×5領域の残りのサンプルを取得できます。

完全な近傍がシャッフルされると、これらのサンプルはエッジ検出アルゴリズムへの入力として使用されます。

素朴な実装は、各スレッドの完全な近隣をサンプリングしましたが、新しいSIMDとクワッドのシャッフルと塗りつぶし命令により、各SIMDグループのサンプル数が84%削減され、隣接するスレッド間で重複するサンプルが排除されます。

新しいSIMD操作を使用して、多くの一般的な画像処理と機械学習アルゴリズムは、SIMDグループ間で共有データを最適化するために同じアプローチを適用できます。

そして、それはSIMDシャッフルとフィルのためのものです。

私たちが学んだことをまとめましょう。

ロッシー圧縮は、テクスチャの品質を維持しながら、メモリフットプリントと帯域幅を節約する、簡単に有効にできる機能です。

まばらな深さとステンシルテクスチャは、効率的で高品質のシャドウマップを作成するのに役立ちます。

新しい計算命令SIMDシャッフルと塗りつぶしは、オーバーラップを減らし、機械学習と画像処理アプリケーションのスライドウィンドウ画像操作を改善します。

そして最後に、すべてのMetalアプリは、A15 Bionic GPUの全体的なアーキテクチャ改善により、パフォーマンス、応答性、省電力がさらに向上します。

ご覧いただきありがとうございます。