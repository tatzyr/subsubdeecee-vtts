606

イメージブロックとタイルシェーディングに基づいて構築されたイメージブロックサンプルカバレッジコントロールは、マルチサンプリングレンダリングパスを最適化する新しい機会を提供し、A11のGPUの強化されたマルチサンプリングハードウェア用に設計されています。

イメージブロックサンプルカバレッジは、A11の新しいメタル2機能に焦点を当てた一連のプレゼンテーションの3番目です。

Metal 2の強化されたマルチサンプリング機能に飛び込む前に、マルチサンプルアンチエイリアシングを簡単に復習しましょう。

マルチサンプルアンチエイリアシング、またはMSAAは、複数の深さと色のサンプルで各ピクセルを表現することによって、原始的なエッジの外観を改善するために使用される技術です。

まず、GPUがマルチサンプリングなしで三角形をレンダリングする方法を見てみましょう。

これは、カラーアタッチメントを表すピクセルの4×4のグリッドです。

GPUのラスタライザは、ピクセルの中心をサンプリングして、プリミティブで覆われているかどうかを判断します。

三角形を持ち込みましょう。

プリミティブで覆われているすべてのピクセルセンターは赤く着色されています。

各ピクセルが単一のサンプル位置しか持っていない場合、ピクセルはピクセル中心のみに基づいてカバーされているかカバーされていないかに分類されます。

結果の画像では、エッジエイリアシングの古典的な症状を見ることができます:ジャギーとしても知られる階段アーティファクト。

マルチサンプルアンチエイリアスでレンダリングされた同じ三角形を見てみましょう。

この例では、各ピクセルには4つの均等に分散したサンプリング位置があります。

ピクセルあたり4つのサンプルで、GPUのラスタライザはプリミティブのより細かいグレインカバレッジを決定できます。

マルチサンプリングアタッチメントが解決されると、GPUはサンプルの値を平均して、各ピクセルの最終的な色を決定します。

これにより、エッジが滑らかになり、階段効果の外観が低下します。

従来のマルチサンプリングの実装では、改善されたエッジの外観のトレードオフは、各サンプルをブレンドする計算オーバーヘッド、マルチサンプルアタッチメントテクスチャのより大きなメモリフットプリント、およびピクセルごとに複数のサンプルを保存および解決するためのより高いメモリ帯域幅です。

AppleのAシリーズGPUは、これらのトレードオフに直接対処する非常に効率的なMSAA実装を備えています。

ハードウェアは、各ピクセルにプリミティブエッジが含まれているかどうかを追跡し、ブレンドはサンプル値が異なるピクセルに対してのみサンプルごとに実行されます。

Metal on AシリーズGPUを使用すると、マルチサンプリングアタッチメントにメモリレスレンダリングターゲットを使用することで、余分なメモリストレージ要件を排除できます。

完全なサンプルデータは、タイルメモリに一時的にしか存在しません。

Metalのマルチサンプル解決ストアアクションを使用することで、タイルメモリから解決アタッチメントに直接解決することで、追加のシステムメモリ帯域幅が発生することを回避できます。

さらに、Metal 2は、サンプル位置を選択し、サンプリングパターンを制御できるように、プログラマブルサンプル位置を導入しました。

A11のMetal 2では、ブレンドでマルチサンプリングをさらに効率的にしました。

現在のAシリーズGPUは、エッジが各ピクセルと交差するかどうかをすでに追跡していますが、A11 GPUは、各ピクセル内の一意のサンプル数を追跡することで、この追跡をさらに細かい粒度に拡張します。

他のMetal 2機能を使用しなくても、既存のマルチサンプリングアプリケーションは、A11のGPUの強化されたマルチサンプリングハードウェアとより効率的に融合します。

Imageblocksやタイルシェーディングなどの他のMetal 2機能の柔軟性を活用して、Imageblock Sample Coverage Controlを使用すると、各ピクセルのサンプルカバレッジ追跡データにアクセスして、マルチサンプリングレンダリングパスをさらに制御できます。

Imageblock Sample Coverage Controlを使用すると、タイルパイプラインは、独自のカスタム解決アルゴリズムを使用して、レンダリングパスでいつでもサンプルデータを解決できます。

Imageblock Sample Coverage Controlが提供する追加の柔軟性を理解するには、まずAシリーズGPUでエッジトラッキングがどのように機能するかを理解する必要があります。

現在のAシリーズGPUはシーンをタイルでラスタライズし、各タイルにはピクセルにプリミティブエッジが含まれているかどうかを追跡するメタデータが含まれています。

この画像では、赤いピクセルには原始的なエッジが含まれていますが、白いピクセルには含まれていません。

エッジを含むピクセルの数は、シーンのジオメトリの密度に対して増加します。

ピクセルにプリミティブエッジが含まれている場合、それは複数の一意のサンプル値を持っていることを意味します。

このため、ブレンド方程式は、エッジを含むピクセルのサンプルごとに実行されます。

エッジを含まないピクセルは、一度だけブレンドする必要があります。

A11 GPUは、より細かい粒度でエッジを追跡します。

エッジを含むピクセルには、多くの場合、いくつかのユニークなサンプルしかありません。

A11 GPUの強化されたマルチサンプリングは、ユニークなサンプルのみを追跡し、ブレンドします。

メタルシェーディング言語では、これらのユニークなサンプルに名前を付けます:色。

それでは、A11 GPUがマルチサンプリングブレンド性能をどのように向上させるかを見てみましょう。

プリミティブエッジを含むピクセルの場合、A11 GPUはそのピクセル内の一意の色の数を追跡します。

プリミティブがピクセルを交差または完全に覆うと、そのピクセルに含まれる色の数が増減します。

A11 GPUはこれらのトランジションを自動的に追跡します。

右側の図では、ピクセルには4つのサンプルが含まれていますが、2色のみです。

A11 GPUが次のプリミティブをこのピクセルとブレンドする必要がある場合、ブレンドするユニークなサンプルは2つしかありません。

また、プログラム可能なブレンドを使用する高度なレンダリングアルゴリズムの場合、大幅な節約になります。

それでは、これらのカラートラッキングトランジションのいくつかを通して断片を取りましょう。

当初、各フラグメントには、すべてのサンプルを表す単一の色が含まれています。

これは、レンダリングパスが始まるときのあなたの明確な色になります。

プリミティブエッジがピクセルをカットした場合、A11 GPUは新しいユニークな色を作成し、カバーされたサンプルを新しい色に割り当てます。

この緑色の三角形で覆われた2つのサンプルは、新しい色のものに割り当てられています。

カバーされていないサンプルは、まだカラーゼロに割り当てられています。

このピクセルと交差する次のプリミティブは、赤い半透明の三角形だとしましょう。

赤い三角形は3つのサンプルをカバーしています。

現在のAシリーズGPUは、カバーされた3つのサンプルのそれぞれをブレンドします。

A11 GPUは、カバーされた2つのサンプルが同じカラーインデックスを共有しているため、2回しかブレンドしません。

この場合、カラー1は緑と赤のブレンドであり、GPUは新しいユニークな色であるため、インデックス2で新しい色を作成します。

ピクセル内のユニークな色の数は、プリミティブがピクセルをカットすると増加する可能性があります。

しかし、ハードウェアがユニークな色の数を減らす場合があります。

ここでは、不透明な非ブレンドの三角形がピクセルを完全にカバーしています。

4つのサンプルはすべて完全に青に置き換えられるため、すべての青いサンプルは再び1つの色で表すことができるため、A11 GPUは3色を1つに戻します。

A11 GPUの強化されたマルチサンプリングハードウェアは非常に強力で、Metalシェーディング言語を拡張して、Imageblock Sample Coverage Controlでサンプルカバレッジを明示的に制御できるようにしました。

この新機能により、タイルパイプラインは、ピクセルのカラーカバレッジを変更することにより、レンダリングパスの途中でサンプルデータを解決する機能を備えています。

そして、Metal Shading Languageでカーネルを書くので、独自のカスタム解決フィルタを書くことができます。

簡単な例を見てみましょう。

まず、imageblockの引数を持つカーネルがあります。

次に、画像ブロック内の指定された座標で色の数を照会します。

ピクセルあたり4つのサンプルを持つレンダリングパスの場合、返される値は、そのピクセルにあるユニークな色の数に応じて、1、2、3、または4になります。

マルチサンプリングされたイメージブロックは、サンプルまたは色ごとにイメージブロックデータを返すことができます。

この例では、カラーcのイメージブロックデータを取得します。

この例は一意の色の数をループしているため、各色でカバーされているサンプルの数も考慮する必要があります。

これを行うには、このカラーインデックスのカバレッジマスクを取得し、ポップカウントを呼び出してマスク内のセットビット数を取得します。

次に、ピクセルあたりのサンプル数で割って、解決された値を完全なサンプルマスクでイメージブロックに書き戻すことで、色の解決を終了します。

完全なサンプルマスクで単一の値を書き込むことで、A11 GPUはすべてのサンプルデータを単一の色にマージします。

これは基本的な解決の例ですが、タイルパイプラインであるため、アプリケーションに最適な方法でサンプルデータを解決するためのカーネルを書くことができます。

だから、あなたはちょうどカスタム解決フィルタを書く例を見ました。

タイルシェーディングを使用してサンプルデータを解決するもう1つの理由について話し合いましょう。

現在、一部のアプリケーションは、多くの不透明なジオメトリと粒子のような半透明のジオメトリがたくさんある複雑なシーンをレンダリングします。

A11 GPUは各ピクセルのユニークな色のみをブレンドするために最善を尽くしますが、シーンに多くのブレンドジオメトリがあり、大量のオーバードローがあることがわかっている場合は、重いブレンドフェーズの前にタイルパイプラインでサンプルデータを解決することをお勧めします。

Imageblock Sample Coverage Controlを使用すると、不透明なジオメトリをレンダリングした後、タイルパイプラインでサンプルデータを解決し、ブレンドする前にすべてのピクセルに単一の一意の色が含まれていることを確認できます。

タイルパイプラインを使用してサンプルデータのカバレッジを変更するより高度な例を見てみましょう。

タイルパイプラインは計算関数で実装できるため、単に平均値よりもはるかに多くのことを行うことができます。

当社のSurface Aggregationサンプルアプリは、マルチサンプリングシングルパス遅延シェーディングアルゴリズムから始まり、タイルベースのカーネルディスパッチを使用して、遅延パスのシェーディングサンプルの数を減らします。

このアルゴリズムの目標は、マルチサンプルアンチエイリアシングのエッジスムージングの利点を維持しながら、高価な遅延パスでより少ないサンプルをシェーディングすることです。

アルゴリズムの詳細をすべて掘り下げることはありませんので、必ずSurface Aggregationサンプルアプリをダウンロードして探索してください。

しかし、今度は、この技術がどのようにシェーディングのコストを削減するかを視覚化しましょう。

2つの画像は、gバッファ内のピクセルあたり複数のサンプルを含むピクセルを視覚化します。

左側の画像はサーフェスをマージする前のgバッファを示し、右側の画像はサーフェスをマージした後のgバッファを示しています。

表面凝集カーネルは、シェーディングする必要があるgバッファサンプルの数を減らすことができます。

右の画像でわかるように、複数のユニークなサンプルを含む唯一のピクセルは、真の折り目と深さの境界にあります。

A11 GPUのMetal 2の前に、このアルゴリズムはアルゴリズムのフェーズごとに個別のレンダリングパスを必要とし、システムメモリへの複数のラウンドトリップが発生します。

しかし、Imageblock Sample Coverage Controlを使用すると、アルゴリズムの3つのフェーズすべてを1つのレンダリングパスにマージし、アプリに大量のメモリ帯域幅を節約できます。

図でわかるように、3つのフェーズはすべてイメージブロックで動作し、すべての作業データをタイルメモリ内に保持します。

まず、gバッファをタイルメモリのイメージブロックにレンダリングします。

次に、表面集約タイルパイプラインをディスパッチして、gバッファサンプルの数をより少ない集約gバッファサンプルに減らします。

最後に、遅延シェーディングパスは、各集計サンプルのみをシェーディングします。

このテクニックについてもっと知りたい場合は、このプレゼンテーションの最後にあるリンクにアクセスして、サンプルアプリをダウンロードしてください。

要約すると、まず、A11 GPUのマルチサンプリングのハードウェア強化について話しました。

A11 GPUは、すべてのピクセルの一意のサンプル数を追跡し、ブレンドコストを削減します。

この最適化は、APIブレンドとプログラム可能なブレンドの両方に適用されます。

次に、この強力なハードウェア機能をタイルシェーディングで使用されるカーネルに公開するA11 GPUのMetal 2の機能強化について議論しました。

Imageblock Sample Coverage Controlを使用すると、独自のカスタムリゾルブカーネルを作成し、いつでもレンダリングパスでそれらをディスパッチして、強力な新しい最適化を実装できます。

一緒に、A11 GPUの強化されたマルチサンプリングとMetal 2の新しいシェーディング言語機能により、データをより長くオンチップに保つための新しい技術が可能になります。

この機能を使用して、Surface Aggregationなどのアルゴリズムを1回のレンダリングパスで実装できます。

Metal 2の詳細とサンプルコードへのリンクについては、開発者のウェブサイトdeveloper.apple.com/metalをご覧ください。

ご覧いただきありがとうございます。