602

Metal 2は、A11 GPUのアーキテクチャと新機能を活用するために、APIとシェーディング言語の変更の新しいセットを導入します。

A11のMetal 2の新機能を確認しましょう。

Appleは、GPUアーキテクチャの急速な革新を可能にするためにMetalを設計しました。

そして、AppleのGPUアーキテクチャはMetalの設計を知らせました。

ハードウェアとソフトウェアのこの深くシームレスな統合は、グラフィックス、コンピューティング、機械学習アプリ、ゲームのエキサイティングな新しい可能性を可能にします。

メタルの導入からわずか3年後、WWDC 2017で次世代のメタルであるメタル2を導入しました。

クリーンで十分なファクタリングされた設計に基づいて、Metal 2は、GPUがグラフィックスワークロードを自分自身にディスパッチし、効率をさらに向上させ、ドローコールコストを最大10倍に削減できるGPU駆動型レンダリングなど、GPUの機能にアクセスするためのさらに最先端の方法を含むように拡張します。

2015年、MetalはMacとデスクトップGPUをサポートするように拡張した。

現在、Metal 2は、基礎となるGPUアーキテクチャに関係なく、主要な機能を均一に公開するためにAPIを調整しています。

さまざまなドメインにわたる機械学習の台頭により、Metal 2は、パフォーマンスと効率を向上させるための推論操作を加速することを目的とした、より広く、より洗練された機能セットをもたらします。

Metal 2はまた、AppleプラットフォームでGPUのパワーを巧みに活用する方がはるかに簡単になる新しい最適化ツールセットも提供します。

そして今、私たちはWWDCで発表しなかったより多くのメタル2の機能を明らかにすることができます。

Metal 2には、最新のAシリーズチップであるA11でAppleが設計したGPUのユニークな機能を公開する一連の強力な新機能が含まれています。

A11 GPUアーキテクチャと機能の詳細に入る前に、古典的なGPUとタイルベースの遅延レンダリングアーキテクチャのアーキテクチャを確認しましょう。

これは、古典的なGPUアーキテクチャの簡略化された図です。

GPUは大規模に並列マシンです。

この図に示されている頂点とフラグメントの段階は何度も複製され、並行して実行されます。

また、キャッシュ階層、FIFO、初期の粗い深度テストなど、この図には示されていない多くの最適化もあります。

基本的に、古典的なアーキテクチャを持つGPUはプリミティブを取り、深さ、色、データバッファ、テクスチャを生成します。

このアーキテクチャの決定的な特徴の1つは、頂点ステージの出力がフラグメントステージに直接供給されることです。

TBDRとも呼ばれるタイルベースの遅延レンダリングアーキテクチャを見てみましょう。 タイルベースの遅延レンダリングアーキテクチャを見てみましょう。

すべてのAシリーズGPUはTBDRアーキテクチャに基づいています。

TBDRは、古典的なGPUアーキテクチャにいくつかの重要な変更を加えます。

最初の大きな違いは、頂点ステージがフラグメントステージに直接供給されないことです。

代わりに、頂点段階から出てくると、プリミティブは画面に整列した小さなタイルにビンに入れられ、メモリに保存されます。

この変更により、頂点ステージはフラグメントステージに対して非同期に実行できます。

レンダーパスのフラグメントステージを実行している間、並行して、ハードウェアは将来のレンダーパスの頂点ステージを実行します。

頂点ステージを非同期に実行すると、パフォーマンスが大幅に向上します。

頂点ステージは通常、固定機能ハードウェアを多用していますが、フラグメントステージは数学と帯域幅のヘビーユーザーです。

それらが完全に重なっているため、GPU上のすべてのハードウェアブロックを同時に使用できます。

プリミティブをタイルにビンニングすることで、タイル内のすべてのプリミティブをすべて一緒に処理できます。

それをどのように活用できるか見てみましょう。

シェーダーコアの横にあるチップにタイルサイズのフル解像度、深さ、ステンシル、フレームバッファーを置きます。

私たちはこのメモリをタイルメモリと呼んでいます。

タイルメモリには3つの重要な特徴があります。

まず、シェーダーコアとタイルメモリ間の帯域幅は、GPUと外部メモリ間の帯域幅よりも何倍も高く、シェーダーコアの数に比例してスケールします。

第二に、タイルメモリへのメモリアクセスレイテンシは、外部メモリへのアクセスのレイテンシよりも何倍も低い。

最後に、タイルメモリは外部メモリよりも大幅に低い電力を消費します。

TBDRは、この低遅延、低消費電力、高帯域幅のメモリを使用して、2つの主要な最適化を提供します。

まず、タイル深度/ステンシルメモリにより、ハードウェアはシェーディングコアが処理を開始する前に、不透明なオブジェクトの完全な深さとステンシルバッファ情報を生成できます。これにより、ハードウェアはシェーダーコアに送信する前に隠蔽されたフラグメントを完全に淘汰することができます。

後続のレンダーパスにデプスバッファが必要ない場合は、メモリレスレンダーターゲットを使用してフルサイズのデプスバッファを完全に排除し、大量のメモリ帯域幅、ストレージ、および電力を節約できます。

第二に、タイルメモリは、チップにカラーバッファを格納するために使用されます。

ブレンド操作は、外部メモリ上のフルサイズのフレームバッファにアクセスする必要がないため、高速です。

タイルメモリは、タイル全体が処理された後、一度だけ書き込まれ、電力、パフォーマンス、帯域幅を大幅に節約します。

このより高速なメモリのおかげで、より高い占有率が達成されます。

フレームバッファフェッチ機能を使用すると、カスタムブレンディングを実装し、いくつかの高度なテクニックを有効にします。

メモリレスフレームバッファと組み合わせることで、これらの技術の多くは外部メモリを消費する必要もありません。

その結果、TBDRは帯域幅が限られている場合でも優れたパフォーマンスをもたらします。

TBDRははるかに低い電力を消費しますが、これはバッテリー駆動のデバイスに不可欠です。

それでは、ギアをA11 GPUに切り替えましょう。

A11では、GPUアーキテクチャの最初の大きな変更は、フラグメント関数からタイルメモリに存在するデータを直接制御できるようにすることです。

イメージブロックは、タイルメモリに存在する画像データへの最適化されたアクセスを提供します。

アプリケーションにとって意味のある方法でピクセルをレイアウトすることができますが、それでも効率的にレンダリングすることができます。

イメージブロックは、タイルメモリ内の2Dデータ構造です。

幅、高さ、奥行き、フォーマットを指定できます。

Metal 2は、シェーディング言語にテクスチャピクセルフォーマットを追加し、パックされたデータタイプを介してピクセルレイアウトを完全に制御できるようにします。

2番目の大きなアーキテクチャの変更により、タイルメモリに同時に保存されているすべてのピクセルにアクセスできます。

タイルシェーディングは、レンダリングパス内でインラインでコンピューティング機能を提供するAppleのA11 GPUの新しいプログラム可能なステージです。

タイルシェーディングは、Metal 2のまったく新しいレベルのパフォーマンスと効率を可能にします。

レンダリングとコンピューティング操作は、より高い帯域幅、より低いレイテンシー、低消費電力のタイルメモリを介してデータを共有できるようになりました。

タイルシェーディングはイメージブロックと深く統合されています。

イメージブロックの内容を分析したり、そのコンテンツを要約したり、シーンの途中でイメージブロックを保存したり、イメージブロックのレイアウトを変更したりすることもできます。

通常のコンピューティングカーネルと同じように、スレッドグループメモリを使用することもできます。

タイルシェーダーの場合、スレッドグループメモリは永続的です。

タイルシェーダーの各連続した呼び出しは、前のタイルシェーダーから残された値から始めて、スレッドグループメモリを操作できます。

これはイメージブロックメモリにも当てはまります。

それらはタイルとフラグメントシェーダーの呼び出しの間に永続的です。

さらに、イメージブロックとタイルシェーディングをサポートするラスターオーダーグループの高度なバージョンを導入しています。

そして最後に、マルチサンプル画像ブロックのサンプルカバレッジを完全に制御するために、メタルシェーディング言語を拡張しています。

新しいアーキテクチャと新しいMetal 2の機能を最大限に活用できる一連のレンダリング技術を見てみましょう。

タイルシェーダー、イメージブロック、ラスターオーダーグループは、インターリーブ、レンダリング、計算パスを1つの結合パスにまとめるのに最適な方法です。

遅延レンダリングとタイル張りのフォワードレンダリングは、この方法で加速できます。

例として、タイル張りの前方実装を見てみましょう。

ジオメトリを渡して最初にオンチップ深度情報を作成し、次にタイルシェーダーを実行してタイルごとの最小最大深度情報を作成し、別のタイルシェーダーを実行してスレッドグループメモリに淘汰されたライトリストを作成し、マテリアルシェーダーを実行できます。

これらの操作はすべて1つの複合パスで実行でき、大量の帯域幅、ストレージ、電力を排除することでパフォーマンスが向上します。

これらの機能により、注文に依存しない透明性、多層アルファブレンド、および表面下散乱の効率的な実装も可能になります。

サンプルカバレッジコントロール、タイルシェーダー、およびイメージブロックは、カスタムMSAA解決、MSAAトーンマッピング、およびサーフェスアグリゲーションを行うはるかに効率的な方法を可能にします。

これらのユースケースの一部をどのように加速できるかを示すために、遅延レンダリング、タイルフォワード、多層アルファブレンド、および表面集約のサンプルコードをリリースしています。

A11のMetal 2は、イメージブロック、タイルシェーダー、イメージブロックサンプルカバレッジコントロール、およびラスターオーダーグループを導入することにより、TBDRアーキテクチャを進歩させます。

さらに、コンピューティングスレッドとスレッドグループ間でデータを共有するための新しく効率的なメカニズムを提供するために、新しいメタルシェーディング言語の変更を導入しました。

A11のこれらおよびその他の追加機能とパフォーマンスの向上を簡単に見てみましょう。

イメージブロックから始めましょう。

イメージブロックは、タイルメモリ内の2Dデータ構造です。

フラグメント関数は、その位置に対応する単一のピクセルにしかアクセスできませんが、カーネルはイメージブロック全体にアクセスできます。

各ピクセルは非常に複雑で、複数のコンポーネントで構成され、各コンポーネントは独自の画像面として対処できます。

イメージブロックは、GPUのフォーマット変換ハードウェアへの一括アクセスも提供します。

浮動小数点ピクセルは、デバイスメモリに保存すると、宛先テクスチャ形式に変換されます。

タイルシェーダーは、レンダリングパス内でインラインで計算機能を提供します。

タイルシェーダーはイメージブロック全体にアクセスでき、通常のコンピューティングカーネルと同様に、スレッドグループメモリをサポートしています。

コンピューティングカーネルのスレッドグループメモリとは異なり、タイルシェーダーのスレッドグループメモリは、カラーデータが描画全体で持続するように、タイルの寿命にわたって持続します。

そのため、以前はフレームバッファフェッチ機能を使用してピクセルの範囲内でドロー間で通信することに限定されていましたが、より広いタイルスコープを使用してタイルディスパッチとフラグメントドロー呼び出しの間で通信できるようになりました。

それでは、A11が前の世代よりもMSAAをどのように改善するかを見てみましょう。

AppleのAシリーズGPUは、非常に効率的なMSAA実装を備えています。

フラグメントがエッジフラグメントでない場合、ハードウェアブレンディングはサンプルごとに1回ではなく、フラグメントごとに1回実行されます。

さらに、タイルメモリから解決アタッチメントに直接解決し、追加のメモリ帯域幅の発生を避けることができます。

Metalのメモリレスレンダリングターゲット機能を使用することで、MSAAレンダリングターゲットメモリストレージを完全に排除することもできます。

A11のMetal 2で、私たちはMSAAをさらに進めました。

現在のAシリーズGPUはすでにピクセル内のエッジを追跡していますが、A11 GPUは、各ピクセル内の一意のサンプル数を追跡することで、この追跡をさらに細かい粒度に拡張します。

このハードウェアの変更により、アプリケーションを変更することなく、マルチサンプルアプリケーションが高速になります。

A11では、Metal 2は、イメージブロックサンプルカバレッジコントロールを使用して、このトラッキングメタデータを完全に制御することもできます。

この機能は、スレッドグループイメージブロックやタイルシェーダーと組み合わせて活用することもできます。

イメージブロックサンプルカバレッジコントロールを使用すると、タイルパイプラインはGPUのサンプルカバレッジ追跡データを変更できるため、独自のカスタム解決アルゴリズムを使用して、レンダリングパスでいつでもサンプルデータを解決できます。

ラスター順序グループを使用すると、送信順序で重複するフラグメント関数からメモリにアクセスし、フラグメント関数が通信できるようにします。

A11は、ラスターオーダーグループの機能を拡張します。

まず、A11はGPUの内部タイルメモリを公開します。

ラスターオーダーグループは、予測可能な順序でタイルメモリにアクセスできるようにすることで、タイルメモリをより便利にします。

第二に、他のGPUのラスターオーダーグループがピクセルあたり1つのミューテックスに制限されている場合、A11はそれよりもきめ細かくすることができ、さらに軽いタッチを可能にし、スレッドがアクセスを待っている頻度を最小限に抑えます。

それでは、Metal 2がスレッドとスレッドグループ間のデータ共有をどのように加速するかを見てみましょう。

Metal 2シェーディング言語は、メモリ順序とスコープ属性でアトミック機能を拡張します。

これらの新しい追加により、スレッド間で柔軟かつ効率的にデータを共有する新しい方法が可能になります。

Metal 2の前に、スレッドグループ間で通信するには、カーネルの実行を完了し、最初のカーネルのスレッドグループの出力を消費するために新しいカーネルを発行する必要がありました。

メタル2では、スレッドグループは互いに直接通信できます。

さらに、これらの新機能の追加により、スレッドグループ内のスレッドはバリアを使用せずに通信でき、パフォーマンスが向上します。

また、A11のMetal 2に他の重要な機能と機能を追加しました。

A11では、f16数学は、丸めの改善と最大値処理を通じて、全体的に精度が向上しています。

A11は、テクスチャキューブ配列のサポートを追加し、読み取り/書き込みテクスチャ機能を導入しています。

A11では、AシリーズのGPUに一連のサンプラーカバレッジが提供されます。

A11は、ポストデプスカバレッジ機能を追加し、コンピューティングカーネルをディスパッチするより柔軟な方法を提供します。

A11は、クアッドスコープのパーミュート操作のサポートも追加します。

これらの機能の詳細については、Metal 2のドキュメントを確認してください。

A11は、GPUに多くの大幅なパフォーマンス改善をもたらします。

コンピュータビジョン、画像処理、機械学習のタスクに関しては、最大2倍の数学パフォーマンスを備えています。

しかし、パフォーマンスの改善分野はそれだけではありません。

A11 GPUのパフォーマンスと機能の向上を見直しましょう。

A10 GPUと比較して、クロックサイクルあたりのF16数学とテクスチャフィルタリングレートを2倍にしました。

ご注意：A11では、可能であればシェーダーでF16データ型を使用すると、パフォーマンスの違いがはるかに大きくなります。

A11で最大スレッドグループサイズを512から1Kに2倍にしました。

最大複数レンダリングターゲットサイズが256ビットから512ビットに増加しました。

最大スレッドグループのメモリサイズが16Kから32Kに倍増しました。

また、フィードバック業務のパフォーマンスを大幅に改善しました。

それらはアルファテストと破棄とも呼ばれます。

Metal 2の詳細とサンプルコードへのリンクについては、開発者のウェブサイトdeveloper.apple.com/metalをご覧ください。

見てくれてありがとう!