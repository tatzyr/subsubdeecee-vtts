10856

こんにちは。私の名前はCharles Circlaeysです。この講演では、レンダリングループのコミットフェーズでアニメーションヒッチのスクロールに飛び込みます。

iOSはレンダリングループを使用してビューを表示します。

タッチイベントはアプリに送信され、ビューを変更して応答し、それらのビューはiOSによってディスプレイにレンダリングされます。

レンダリングループのコミットフェーズでアニメーションヒッチを見つけて修正することに焦点を当てます。

レンダリングループ全体とヒッチについて学ぶには、ビデオ「UIアニメーションヒッチとレンダリングループを探索する」をご覧ください。

まず、コミットトランザクションを定義するものを調べます。

楽器を使ってヒッチを見つける...

そして、コミットヒッチを回避するための推奨事項を共有します。

コミットトランザクションを定義することから始めましょう。

ここでは、現在イベントを待っているアプリビュー階層の例があります。

タッチイベントを受信すると、ビューがそれに応答し、一部のサブビューの背景色またはフレームを変更してイベントを処理します。

システムは、これらのサブビューが次のコミットトランザクション中にレイアウトまたは表示を必要とすることを記録します。

コミットトランザクション中に、表示またはレイアウトが必要なビューは、drawRectまたはlayoutSubviewsを呼び出すことで、それに応じて更新されます。

コミットトランザクション中のさまざまなフェーズを見てみましょう。 コミットトランザクション中に関連するさまざまなフェーズを見てみましょう。

レイアウトフェーズ、表示フェーズ、準備フェーズ、最後にコミットフェーズの4つのステップがあります。

レイアウトフェーズでは、レイアウトが必要なビューごとにlayoutSubviewsが呼び出されます。

ビューの位置を変更したり、ビューを追加または削除したり、ビューのsetNeedsLayoutを明示的に呼び出したりすることで、必要なレイアウトをマークできます。

表示フェーズでは、表示が必要なすべてのビューに対してdrawRectが呼び出されます。

drawRectをオーバーライドするビュー階層にビューを追加するか、setNeedsDisplayを明示的に呼び出すことで、表示が必要であることを示すことができます。

準備段階では、まだデコードされていない画像は、このステップでデコードされます。

この種の操作は、大きな画像にはかなりの時間がかかることがあります。

また、画像がGPUが直接作業できないカラー形式の場合、このステップで変換されます。

これには、画像にポインタを送信する代わりに画像をコピーする必要があり、追加の時間とメモリがかかります。

アプリ内の画像の最適化の詳細については、「画像とグラフィックスのベストプラクティス」ビデオをご覧ください。

最後に、コミットフェーズでは、ビュー階層が再帰的にパッケージ化され、レンダリングサーバーに送信されます。

ディープビュー階層はパッケージ化に時間がかかることに注意してください。

コミットトランザクションの詳細を説明したので、2番目のトピックに移りましょう。インストゥルメントでヒッチを見つける。

Xcode 12では、アプリのヒッチをプロファイリングするための新しいインストゥルメントテンプレートをリリースしました。

これは、検出されたヒッチングフレームのレンダリングループを視覚化して調査するのに役立ちます。

アプリの例でいくつかのヒッチを見てみましょう。

アプリケーションでスクロールすると、Instrumentsにトレースを記録します。

ここでは、スクロールパフォーマンスの記録があり、検出されたすべてのヒッチを見ることができます。

ヒッチ16を詳しく見てみましょう。

左側には、フレームの作成に必要なレンダリングループフェーズに対応するすべてのトラックが表示されます。

ヒッチトラックは、ヒッチとその持続時間を示しています。

ユーザーイベントトラックは、ヒッチングフレームで受信したユーザーイベントを表示します。

コミットトラックは、コミットフェーズと、このフェーズ中にコミットしたプロセスを示します。

パトリックは、「レンダリングフェーズでのヒッチを解明し、排除する」で、レンダリングとGPUトラックについて詳しく説明します。

Frame Lifetimesトラックは、ヒッチングフレームを構成するための全期間を示します。

内蔵ディスプレイトラックには、VSYNCイベントとともに表示されたすべてのフレームが表示されます。

フレームの寿命とヒッチ期間の開始を比較して、フレームが表示の準備ができているはずの予想される間隔を視覚化できます。

この間隔は許容レイテンシと呼ばれます。

その後のすべての時間はヒッチ持続時間です。

トラックの下には、ヒッチトラックが選択されているときにヒッチの詳細なメトリックを見ることができます。

私たちのデモアプリには多くのヒッチがありますが、ここではヒッチ16に焦点を当てています。

ヒッチの持続時間を見ることができます...

許容可能なレイテンシ...

そしてヒッチタイプ。

ヒッチタイプは、フレームが遅れた段階と調査を開始する場所のヒントを得るのに便利です。

この例では、選択したヒッチングフレームがコミットとGPUフェーズによって引き起こされたことがわかります。

コミットフェーズでどのコードに時間がかかりすぎているかを見つけたいのですが、ありがたいことに、アニメーションヒッチテンプレートにはタイムプロファイラが含まれているので、このヒッチが発生したときにどのコードが実行されているかを確認できます。

ここから、調査したい間隔を選択し、コミットしていたプロセスを検索できます。

このプロセスのメインスレッドを選択できます...

そして、そのコールツリーを表示します。

これで、どの通話が高価になるかを分析することができます。

このコールツリーはコミットトランザクションに由来することが確認でき、QSTEM CollectionViewCellのupdateTagsと呼ばれるメソッド内で約10ミリ秒を費やしたことを示しています。

このアプリに何が入っているか見てみましょう。

一般的なCollectionViewで構成されており、各セルにはUIImageViewを使用した写真のサムネイル、UILabelを使用したテキスト、カスタムTagLabelビューを使用したタグが表示されます。

QSTEM CollectionViewCellクラスの実装と、より具体的には、このメソッドが呼び出されている場所を見てみましょう。

ここでは、メニュー項目にプロパティオブザーバーがあることがわかります。

このプロパティオブザーバーは、2つのシナリオでupdateTagsを呼び出します。有効な menuItem が設定されたか、nil に設定されました。

最初のシナリオでは、表示したいタグの配列を解析します。

2番目のシナリオでは、空の配列を解析して、残りのタグを削除します。

では、updateTagsメソッドの実装を見てみましょう。

予想通り、空のタグ配列の場合、ビュー階層からすべてのビューを削除します。

それ以外の場合は、必要に応じてStackViewを作成します。

次に、タグごとに既存のタグラベルを作成または再利用します。

その後、このセルの以前の使用で新しいセルよりも多くのタグがあった場合に備えて、既存の未使用のタグラベルを削除します。

呼び出し範囲に戻り、物事がどのように実装されているかについてより良い知識を得た今、潜在的な問題を見てみましょう。

QSTEM CollectionViewCellは、セルが再利用のためにキューから解除されたときに呼び出されるprepareForReuseメソッドを上書きします。

そして、この方法では、menuItemをnilに設定します。

そうすると、2番目のシナリオが発生し、再利用実装ロジックを利用せずに、セルビュー階層から以前のすべてのタグラベルが削除されます。

これは、キューから外されたセルごとに、以前のラベルサブビューをすべて削除し、すべてのラベルを表示するために必要なすべてのビューを再確認することを意味します。

これは最適ではなく、ヒッチを引き起こしている可能性があります。

これに対する解決策は非常に簡単です。

menuItemをクリアする必要はなく、prepareForReuseメソッドを実装から削除するだけです。

これで、新しいセルメニューアイテムを設定すると、再利用可能なロジックを活用し、高価なビュー階層操作を回避できます。

修正後に新しいトレースを記録すると、最初のトレースと比較して検出されたヒッチの数が大幅に改善されることがわかります。

インスツルメントのタイムプロファイラは、どのコードが時間がかかりすぎてヒッチを引き起こしているかを見つけるのに非常に役立ちました。

タイムプロファイラーの詳細については、「インストゥルメントでのタイムプロファイラの使用」ビデオをご覧ください。

Instrumentsでアプリケーションをプロファイリングする方法を学んだ後、コミットフェーズでのヒッチを回避するための推奨事項について話し合いましょう。

ルール1は、ビューを軽量に保つことです。

これを行うには、GPUアクセラレーションされたCALayerで利用可能なプロパティをできるだけ活用し、CPUカスタム描画を避けるようにしてください。

それが正当化される場合は、必ずそのパフォーマンスを測定してください。

システムは余分な作業を行う必要があるため、drawRectの空の実装は避けてください。これにより、次のトランザクション中に追加の時間とメモリの使用が必要になります。

追加と削除などの高価なビュー階層操作を避けるために、ビューをできるだけ再利用するようにしてください。

ビューの削除に関連して、アニメーション中に特定のビューの表示を停止する必要がある場合は、ビュープロパティ「非表示」を利用してみてください。

これはずっと安いです。

ルール2は、高価で冗長なレイアウトを減らすことです。

レイアウトを更新する必要がある場合にのみ、setNeedsLayoutに頼るようにしてください。

layoutIfNeededは、現在のトランザクションの寿命を消費し、ヒッチを引き起こす可能性があります。

ほとんどの場合、レイアウトを更新するために次の実行ループを待つことができます。

これを解決するための複雑さを増さないように、最小数の制約を使用するようにしてください。

最後に、ビューは自分自身またはその子のみを無効にし、その兄弟またはその親ビューは無効にはなりません。

それ以外の場合、ビューのレイアウトは再び再帰的に無効になります。

パフォーマンスレイアウトと画像とグラフィックスのベストプラクティスの詳細については、以下の2つのWWDCトークを見ることをお勧めします。

コミットトランザクションパイプラインを理解したので、高価なコミットを回避できます。Instrumentsの新しいAnimation Hitchesテンプレートを使用して、ヒッチを検出して調査できます。

prepareForReuseが追加の作業を行わないようにし、ビュー階層を浅く軽量に保ち、高価で冗長なレイアウトを避けるなど、コミットヒッチを防止するためのいくつかの戦略を学びました。

また、ビデオ「レンダリングフェーズでのヒッチの謎を解除して排除する」で、レンダリングループの次のフェーズについて必ず学んでください。

ありがとうございます。