10696

こんにちは、「一様型識別子の再導入」へようこそ。

私の名前はジョナサン・グリンスパンで、アップルのアプリディスカバリーとエンゲージメントチームで働いています。

前回、統一型識別子について話したのはWWDC 2004でした。

それはずいぶん前のことですが、昨日のことのように覚えています。

Appleの2004年の製品ラインナップは、PowerBook G4の全アルミニウムデザイン、iPod Miniの目を見張るような色、iMac G5の魔法のホームシアター体験などの製品で、クラシックでクールでした。

アップルは素晴らしいままですが、2004年は本当にずっと前だったことを認めなければなりません。

そこで、今日は、Appleのオペレーティングシステムがファイルの種類をどのように決定するかから始めて、基本について説明します。

次に、知らない新しいファイルタイプと、それらを処理する方法をシステムに伝える方法を探ります。

最後に、iOS 14とmacOS Big Surで、ファイルタイプの操作を簡単にする新しいAPIを探ります。

あなたがその主題に慣れていないかどうかにかかわらず、私たちはあなたのために何かを持っているので、近くにいてください。

誰かのコンピュータにある可能性のあるファイルを見てみましょう。iPad Miniを使用している猫の写真です。

その画像をディスクに保存すると、通常のファイルと呼ばれるものが生成されます。

これは、ディスクに保存されている一連のバイトのPOSIX用語です。

後で、この写真をもう一度開きたい場合は、ダブルクリックすると、プレビューのような画像ビューアで開きます。

しかし、システムは、これがテキストファイルやMP3トラック、Pagesドキュメントではなく、JPEGとして保存された画像であることをどのように知っていますか?

ファイルはバイトのシーケンスであるため、システムがファイルの種類を知る必要があるときに、それをクラックして開き、内部のビットを読み取りてそれを把握することを期待するかもしれません。

実際、システムは非常に高価であり、ほとんどのプロセスが持っていない読み取り権限を必要とするため、システムはほとんどそれをしません。

実際、オペレーティングシステムの決定のほとんどは、ファイルのパス拡張に基づいています。

これは、空白や制御文字が含まれていない限り、最後のピリオド文字に続く大文字と小文字を正規化された部分文字列です。

Appleのプラットフォームでは、通常、認識されたパス拡張機能をユーザーに表示しませんが、まだそこにあります。

このファイルのパス拡張子を明らかにすると、J-P-E-Gであることがわかりますので、これはJPEG画像です。

.jpegはJPEG画像を意味しますよね?

はい、しかし、JPEG画像には他のパス拡張があります。

.Jpgと.jpeが最も一般的です。

しかし、ウェブ上では、それは別の話です。

Webサーバーは通常、パスの拡張子でファイルを識別しません。

代わりに、MIMEタイプまたはメディアタイプと呼ばれるものを使用します。

JPEGの場合、それはimage/jpegです。

もちろん、人生でそれほど単純なものはなく、一部のサーバーは代わりに一般的だが非標準の画像/jpg MIMEタイプを使用します。

それは5つの異なるメタデータで、すべてまったく同じものを表しています。

まあ、Appleのプラットフォームでは、このファイル形式を正規に識別するために、統一型識別子と呼ばれる単一の文字列を使用するので、それは大丈夫です。

JPEG画像の場合、一様型識別子はpublic.jpegです。

この1つの文字列は、ローカルであろうとウェブ上であろうと、すべてのJPEG画像を指します。

さて、ファイルタイプの興味深い特性は、それらが階層に存在することです。

すべてのJPEG画像は、PNG画像、TIFF画像などと同様に、より抽象的に画像です。

統一型識別子について話すとき、JPEG型はより抽象的な画像型に準拠していると言います。

この適合ツリーは暗黙的に複数の継承を可能にします。

考えてみると、これはSwiftとObjective-Cでのプロトコルの仕組みのようなものです。

具体的なクラスまたは構造体は、任意の数のプロトコルから継承できます。

私の言いたいことをお見せしましょう。

これがpublic.jpegです。

そして、これはすべての画像ファイル形式を記述する抽象タイプであるpublic.imageです。

しかし、すべての画像ファイル形式はバイトシーケンスとして表すことができます。

したがって、public.imageはpublic.dataに準拠しています。これは、保存されている場所に関係なく、ディスク上の通常のファイル、または実際には任意のバイトシーケンスを表す非常に抽象的なタイプです。

次に、public.dataは1つの最終的なタイプであるpublic.itemに準拠しています。

ファイル、フォルダ、シンボリックリンク、またはPOSIXパイプなどのより難解なものであっても、すべてのファイルシステムオブジェクトは、public.itemで表されます。

階層を上ることができるのと同じように、私たちはそれを下ることができます。

public.pngやpublic.tiffなど、JPEG以外の画像形式があり、public.imageのサブタイプでもあります。

ただし、public.jpegの適合階層の一部ではありません。

彼らはただの兄弟です。

レベルを上げてpublic.dataに焦点を当てると、コンピュータ上のほぼすべてのものがバイトシーケンスで表現できるため、それに準拠した多くのタイプがあることがわかります。

ここでは、可聴音を記述する抽象的なタイプであるpublic.audioと、読みやすいテキストを記述する抽象的なタイプであるpublic.textが表示されます。

それらはpublic.dataのサブタイプであり、public.imageの兄弟です。

しばらく前に、均一な型識別子で複数の継承が可能であると述べました。

そして、画像はデータですが、ユーザーが気にするコンテンツでもあり、ユーザーがiCloud Driveにアップロードしたり、AirDropで共有したりする可能性があるため、画像にも当てはまります。

したがって、public.imageはpublic.contentにも準拠しており、ファイルシステムでは具体的なものを表すものではありませんが、そのサブタイプをユーザーにとって重要なものとして扱う必要があることを教えてくれます。

私は、一様型識別子がファイルをどのように表すかにかなり重点を置いていました。

ユーザーに関する限り、それはおそらく彼らにとって最も一般的な用途です。

しかし、私たちは他の目的のためにも私たちのプラットフォーム全体でそれらを使用しています。

たとえば、ペーストボードコンテンツの正規タイプとしても使用します。

結局のところ、ディスクに保存できれば、コピーして貼り付けることもできます。

また、ファイルとは関係のない階層にも使用します。

これは少しAppleの秘密ですが、私たちはまた、私たちが出荷するハードウェアの異なるモデルを識別するために均一なタイプ識別子を使用しています。

たとえば、すべてのMacモデルはcom.apple.macに準拠しています。

また、仮説を立てたい場合は、一様型識別子を使用して、生命のツリーなど、コンピュータとは無関係の階層を参照することもできます。

それが、統一型識別子とは何か、そして私たちのプラットフォームでそれらをどのように使用するかです。

多くのアプリは独自のデータ形式を作成して維持しており、これらの形式は独自のタイプに値します。

新しいタイプを作成するとき、どのようにタイプ階層に追加しますか?

システムによって宣言された型を使用している場合は、多くのことをする必要はありません。

/System/Library/CoreServicesのCoreTypesと呼ばれるバンドルに多数のタイプが含まれています。

そのバンドルのInfo.plistの均一な型識別子は、追加の変更なしにアプリで参照できます。

しかし、あなたが発明したタイプや、別のアプリから借りているタイプについては、それらについてシステムに伝える必要があるかもしれません。

これを行うには、独自の統一型識別子を作成する必要があります。

独自のユニフォーム型識別子を作成するときは、従うべきいくつかの命名規則があります。

まず、一様型識別子は常に大文字と小文字を区別しないASCIIであり、com.example.fileなどのリバースDNSです。

理想的には、より説明的な識別子を使用します。

Com.example.fileは、デバッグが簡単ではありません。

Com.example.imagetemplateまたはcom.example.encrypteddatabaseまたはそのようなものが良いでしょう。

Appleは識別子にいくつかのプレフィックスまたは名前空間を留保しており、これらの名前空間を使用する独自の識別子を作成するべきではありません。

あなたがそうするなら、システムはそれらを無視するかもしれません。

1つ目は「パブリック」で、Appleが標準化されたタイプを宣言するために使用するために予約されています。

標準化されたタイプが欠落している場合は、フィードバックアシスタントでお知らせください。

Dynは、dynamicの略で、互換性のシムを生成するときにオペレーティングシステムで使用するために予約されています。

それらは通常、不透明な文字列であり、OSリリース間で変更できるので、その値をハードコードしないでください。

実際には、最近はかなりまれです。

通常、パスの拡張子が認識されないファイルに遭遇した場合にのみ、それらが表示されます。

Com.exampleは、テンプレート、例、サンプルコードなどのために予約されています。

最後に、com.appleはAppleが使用するために予約されています。

システムが認識するタイプをアプリケーションに追加する際には、幅広い手順が2つあります。

最初のステップは、タイプを宣言することです。

タイプを宣言することは、基本的にアプリが「このタイプは存在する」と言っていることを意味しますが、タイプを開くことができるという意味ではありません。

実際にタイプを開きたい場合は、タイプをサポートする必要があります。これは、「誰がタイプを宣言しても、私はそれを開くことができます」というアプリの言い方です。

この2つのステップは異なります。

タイプを宣言するときは、インポートするかエクスポートするかを決める必要があります。

他の誰かによって発明または設計されたタイプを使用している場合、または主に別のアプリケーションで使用する場合は、通常、そのタイプをインポートする必要があります。

それはシステムに「このタイプは存在します。ここにそれに関するいくつかの情報があります。

しかし、それを発明したアプリがインストールされている場合、そのアプリはより権威のある情報を提供できます。

一方、タイプを発明した場合、またはアプリで特に使用する場合は、それをエクスポートするのが適切です。

これは、「私はこのタイプに権威があります」とシステムに伝えます。

最後に、コアタイプの一部としてシステムに同梱されているタイプを使用している場合は、インポートまたはエクスポートする必要はありません。

システムはすでに宣言を提供しており、タイプのユニフォーム型識別子をすぐに使用できます。

アプリでタイプを宣言する方法と、それを開くのをサポートするシステムを表示する方法を紹介したいと思います。

それでは、私が真新しいレストランオーバーザウェブ体験に懸命に取り組んでいるXcodeを見てみましょう。

このアプリは、私たちが設計したJSONベースの形式で保存されたレストランのメニューを読む機能を備えています。

これらのメニューファイルをアプリで開けるようにしたいので、まずそれらのタイプを宣言する必要があります。

このタイプを自分で作成し、フォーマットを所有しているため、タイプをエクスポートすることは理にかなっています。

Xcodeで最初に行うことは、プロジェクト自体を選択して設定を明らかにすることです。

アプリに対応するターゲットを選択したい。

今、私はiOSアプリを見ていますが、macOSアプリで同じことをします。

次に、アプリのInfo.plistファイルの内容を表す[情報]タブに切り替えます。

エクスポートされたタイプ識別子のセクションを展開します。

セクションの下部にある[追加]ボタンをクリックして、新しいタイプを追加します。

最初に追加したいのは、私たちが思いついた統一型識別子です。

このデモでは、com.example.restaurantmenuを使用します。

com.exampleは、例やデモで使用するためにAppleによって予約されていることを忘れないでください。

通常、所有している逆DNS名を使用したいと思うでしょう。

たとえば、Claris社はcom.clarisを使用し、Beatsはcom.beatsbydreを使用します。

今、私たちは適合性について考えなければなりません。

ファイルシステム内のファイルを表すタイプは、通常のファイルの場合はpublic.data、つまりバイトシーケンス、またはオペレーティングシステムがファイルとして扱うべきディレクトリの場合はcom.apple.packageに準拠する必要があります。

このタイプは、SwiftのJSONエンコーダを使用してディスクに保存されます。つまり、バイトのシーケンスです。

それは通常のファイルを意味し、それはpublic.dataを意味します。

私たちは決断しなければならないようです。

これらのファイルにはJSONデータが含まれているため、JSONファイルを読み取ることができるものなら何でも読み取ることができます。

つまり、このタイプはpublic.jsonにも準拠できるということです。

これは、手動で編集する機能が重要ないくつかのファイルタイプにとって本当に便利なプロパティです。

しかし、他のタイプでは、実装の詳細のみです。

このタイプのpublic.jsonにコンフォーマンスを追加します。

他の開発者に頼りたくない場合や、タイプが将来変更される可能性があると予想される場合は、タイプを作成するときに、これらの種類の実装の詳細をスキップできます。

このファイルタイプは、ユーザーが直接対話する価値のある文書やコンテンツを検討するものです。

だから、私たちはまた、それがpublic.contentに準拠していることを確認します。

次に、タイプに関連付けるファイル名の拡張子を決定する必要があります。

この拡張機能は、タイプをファイルシステムに結び付け、適切な名前のファイルにこのタイプがあることをシステムが認識できるようにします。

3文字の拡張機能を使用したくなるかもしれませんが、1995年以来、主要なプラットフォームベンダーは3文字の拡張機能を必要としていません。

ここには呼吸する余地がたくさんあり、他の開発者のタイプ宣言との競合を避けることが重要です。

だから、私たちはより長い拡張、レストランメニューを使用します。

私たちはそこに点を置かなかったことに注意してください。

オペレーティングシステムは、ファイル名を作成するときに私たちのためにそれを追加することを知っています。

最後に、これはこのタイプの人間が読める名前を思いつく良い機会でもあります。

私たちのアプリは単にレストランと呼ばれ、拡張レストランメニューを選んだので、これをシンプルに保ち、レストランメニューと名付けます。

この文字列は、InfoPlist.stringsファイルでローカライズ可能です。

ローカライズするときは、入力した文字列をキーとして使用してください。

タイプを宣言したので、アプリが開くことができることをシステムに伝える必要があります。

ドキュメントタイプセクションを展開します。

セクションの下部にある[追加]ボタンをクリックして、新しいサポートされているタイプを追加します。

このセクションは、エクスポートされたタイプ識別子セクションよりも簡単です。

指定する必要があるのは、アプリがサポートする統一型識別子のリストだけです。

柔軟性を高めるために、ここで1つのエントリに複数のタイプを指定するか、エントリごとに1つずつ指定できます。

私は個人的にエントリごとに1つのタイプを持つことを好みますが、それは主にタブとスペースのような個人的な好みの問題です。

とにかく、このフィールドにユニフォームタイプ識別子を追加します。

また、このエントリのハンドラーランクをオーナーに設定する必要があります。

このステップは必須ではありませんが、システムが特定の仕事に適したアプリをインテリジェントに選択するのに役立つため、強くお勧めします。

私たちがこのタイプを発明して以来、私たちはそれを所有しています。

macOSでは、エディタまたはビューアとしてファイルを開くことができるかどうかを指定できる追加のルールフィールドがあります。

編集者は特定のタイプのファイルを開いたり保存したりできますが、視聴者はファイルしか開くことができません。

私たちのアプリはこれらのファイルを読み書きできるので、エディタを指定します。

情報セクションの編集が完了しました。

私たちのアプリは、レストランメニューファイルを開くことができるようになりました。

システムが私たちに渡したら、ドキュメントを処理するために、SwiftUI、UIkit、またはAppKitコードを書く必要があります。

Swift UIでドキュメントベースのアプリケーションを構築する方法の詳細については、WWDC20の「SwiftUIでドキュメントベースのアプリを構築する」をチェックしてください。

UIkitとAppKitを使用してドキュメントベースのアプリケーションを構築するためのドキュメントは、developer.apple.comでオンラインで入手できます。

私たちのアプリには、App Storeの競合他社であるCompy's Foodがあります。

多くのレストランオーナーがそのアプリを使用し、そのアプリが所有するファイル形式でメニューを保存しています。

また、これらのファイルの読み取りもサポートしたいと考えています。

このタイプは他の誰かによって発明され、私たちはそれを借りているだけなので、輸出するのではなく輸入する必要があります。

アプリターゲットの[情報]タブに戻り、[インポートされたタイプ識別子]を選択しましょう。

新しいSwiftUIアプリを作成したため、ここに例タイプの既存のエントリがあることに注意してください。

フォームの内容を独自のデータに置き換えることができます。そうします。

ターゲットに既存の例の型がない場合は、もちろん、下の[追加]ボタンで新しい型を追加できます。

Compy's Foodで指定された情報セクションに記入します。

もちろん、ここでの詳細は例にすぎません。

実際の競合他社のタイプのサポートを追加する場合は、Info.plistファイルに含まれているものと一致するように努力する必要があります。

このタイプはインポートされるため、Compy's Foodアプリによって生成されるファイルの種類をシステムに伝えます。

しかし、ユーザーがそのアプリをインストールしている場合、システムは宣言を好むことができ、より権威あるものとしてエクスポートする必要があります。

ユーザーがそのうちの1つを開きたいときにシステムがアプリを選択できるように、これらのファイルを開くためのサポートを追加します。

ドキュメントタイプセクションに戻ります。

Compyの食品リストに別のエントリを作成し、新しいタイプ識別子を追加します。

このエントリは、私たちがそのタイプの所有者ではないため、他のエントリとは少し異なります。

代わりに、ハンドラーランクを代替にしたい。

私たちのアプリはこれらのファイルを読むことはできますが、書き込むことはできないので、macOSでビューアの役割を指定します。

システムは現在、このファイルを開くことができることを知っていますが、そのアプリがファイルタイプの所有者であるため、ユーザーがCompy's Foodをインストールしている場合、私たちは最良の選択ではないかもしれません。

私たちはプラットフォーム上で善良な市民になりたいので、私たちのコードが競合他社のコードよりもはるかに優れていることを知っているにもかかわらず、このようにタイプの所有権を尊重することが重要です。

独自のレストランメニュータイプと同様に、アプリでこれらのファイルを実際に読み込むには、SwiftまたはObjective-Cを書く必要があります。

詳細については、developer.apple.comをチェックしてください。

だから、タイプを宣言し、それをサポートしていることをシステムに伝えたので、コードでそのタイプを操作する時が来ました。

このセクションでは、コアサービスフレームワークのユニフォームタイプ識別子のAPIに少なくとも広く精通していることを前提としています。

ここでは、ディレクトリまたはファイルURLのセットを歩く小さなプログラムがあります。

表現された各ファイルの統一型識別子を取得し、その型識別子のローカライズされた説明を出力します。

ファイルが画像の場合はどこかに描画し、オーディオクリップの場合は、ユーザーのスピーカーまたはAirPodsで再生します。

すぐに、ここに目に見えるいくつかの問題があります。

グローバルUTType関数で使用するには、文字列をCFStringsに明示的にキャストする必要があります。

また、UTTypeCopyDescriptionから取得したCFStringの寿命を手動で管理する必要があります。

しかし、これについてお話しできることを大変うれしく思いますが、iOS 14とmacOS Big Surでは、ユニフォームタイプ識別子にファーストクラスのスウィフトネスをもたらす、まったく新しいユニフォームタイプ識別子フレームワークを導入しました。

以前はCFStringsを使用して型識別子を表現していましたが、UTTypeを使用して型とそのプロパティを表現できるようになりました。

このコードを順を追って、新しいフレームワークを使用するように変換しましょう。

含まれているAPIにアクセスするためにフレームワークをインポートしました。今度は、タイプ識別子URLプロパティをcontentTypeに変更します。その値は新しい構造体UTTypeのインスタンスです。

この構造体は、一様型識別子とそれに関するメタデータをカプセル化します。

次に、この保持されていない値を修正します。

UTTypeにはローカライズされた説明プロパティがあります。

このようなプロパティは、型の属性とグローバル関数を操作するはるかに自然な方法です。

このプロパティの値は、Xcodeで入力した説明文字列に対応し、アプリをローカライズするとローカライズされます。

次に、別のグローバル関数であるUTTypeConformsToに目を向けましょう。

この関数は、明示的なキャストを必要とするCFStringを取ります。

当然のことながら、UTTypeにはconforms-to memberメソッドがあります。

しかし、これらは何ですか: .imageと.audio?

このスライドを覚えていますか？

この新しいフレームワークを設計するとき、システムによって宣言されたタイプのセットと、古いAPIで公開されているCFString定数のセットを見て、それらを名前付き定数として新しいフレームワークに持ち込みました。

新しいフレームワークでは、最も一般的に使用されるシステム定義型をカバーする120以上の定数が定義されています。

もちろん、このセッションの早い段階で、アプリでいくつかのタイプを宣言しました。

彼らも定数を公開できたらいいのではないでしょうか？

あなたはまさにそれができるので、今日は良いニュースでいっぱいです。

エクスポートする型とインポートする型の名前付き定数を宣言するためのAPIがあります。

意味論はそれぞれ少し異なります。

タイプをエクスポートするとき、あなたは「私はこのタイプを所有しています。私はそれを作りました。私のアプリはこのタイプの権限です。

そこで、私たちは先に進み、あなたがこのタイプについてすべてを知っているという知識で安全な、あなたのためにUTTypeのインスタンスを作成します。

タイプをインポートすると、「私はこのタイプについて知っていますが、他の誰かが私よりも知っているかもしれません」と言い、そのタイプの所有者はあなたとは異なるタイプを宣言するかもしれません。

その場合、最も一般的なユースケースでは、そのタイプをその場で置き換えることができます。

しかし、私たちはあなたの協力が必要です。

インポートした型を定数として宣言するのではなく、静的計算変数として宣言し、アプリのインストールによって宣言が変更された場合、更新された型を自動的に選択できるようにします。

宣言したタイプの問題を検出するためのサポートをXcodeに組み込みました。

エクスポートまたはインポートされたタイプがInfo.plistに欠落しているかどうか、または間違った定数初期化子を使用したかどうかを検出できます。

私たちは時間の経過とともにサポートの改善に取り組み、あなたの意見はここで非常に貴重になりますので、フィードバックを提供してください。

多くのフレームワークが、iOS 14とmacOS Big Surの新しいAPIをサポートしています。

Foundationには、先ほどお見せしたURLプロパティがあり、文字列またはURLとUTTypeのインスタンスに基づいて推奨されるファイル名を生成するためのユーティリティもあります。

SwiftUIはUTTypeを幅広くサポートしています。

onDropイベントハンドラなどのペーストボードおよびドラッグアンドドロップAPIは、それらを排他的に使用します。

また、ドキュメントベースのアプリに対するSwiftUIの新しいサポートは、UTTypeを使用するように設計されています。

詳細については、WWDC 20の「SwiftUIでドキュメントベースのアプリを構築する」をチェックすることをお勧めします。

AppKitを使用する場合、NSWorkspaceでは任意のUTTypeのアイコンを取得できます。

また、NSOpenPanelとNSSavePanelはUTTypesをサポートしています。

UIkitは、ドキュメントピッカーやドキュメントブラウザを提示する際のUTTypeの使用をサポートしています。

また、Core Spotlightでは、UTTypeから属性セットを作成できます。

このリリースではUTTypeをサポートしていないAPIがいくつかあり、それらと対話する必要があるかもしれません。

難しくありません。

統一型識別子をAPIに渡す必要がある場合は、UTTypeの識別子プロパティを取得し、CFStringにキャストします。

ユニフォーム型識別子をUTTypeに変換したい場合は、CFStringからStringにキャストし、その文字列でUTTypeを初期化します。

これは失敗可能な初期化子なので、ゼロをチェックすることを忘れないでください。

Objective-Cでは、それは少し冗長ですが、アイデアは同じです。

UTTypeの識別子をCFStringRefにキャストするか、CFStringをNSStringにキャストし、そこからUTTypeを作成します。

今日、システムがメタデータからファイルの型を導き出す方法と、Appleが統一型識別子を使用してその情報をカプセル化する方法を見ました。

独自の型を宣言して使用する方法と、複数のアプリケーション間で共有される可能性のある型と対話する方法を学びました。

そして、型と対話するための最新のオブジェクト指向の方法を提供する新しい統一型識別子フレームワークを導入しました。

この知識と新しいフレームワークを使用してアプリを構築する方法を楽しみにしています。

ありがとうございます。