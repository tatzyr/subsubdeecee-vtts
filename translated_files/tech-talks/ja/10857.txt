10857

こんにちは。私はアップルのOSパフォーマンスチームのパトリックです。

今日は、あなたのアプリのレンダリングヒッチの謎解きと排除に飛び込みます。

iOSはレンダリングループを使用してビューを表示し、ヒッチはレンダリングループが表示に間に合うようにフレームを完了しないときはいつでもです。

レンダリングループ全体の概要については、私の講演「UIアニメーションヒッチとレンダリングループを探索する」をチェックしてください。

ここでは、レンダリング準備とレンダリング実行フェーズの遅さによって引き起こされるヒッチであるレンダリングヒッチに焦点を当てます。

まず、これら2つのレンダリングフェーズが何であるかを見てから、InstrumentsとXcodeビューデバッガを使用してアプリでレンダリングヒッチをキャッチしてトリアージする方法を確認します。

最後に、レイヤーツリーを最適化し、ヒッチがユーザーエクスペリエンスを中断するのを止めるための推奨事項をいくつか見ていきます。

レンダリングフェーズを定義することから始めましょう。

コミットフェーズでは、アプリはUIを変更し、更新されたUIレイヤーツリーを送信して処理します。

これらの提出を「コミット」と呼び、レンダリングサーバーはすべてのフォアグラウンドプロセスのコミットをレンダリングする責任があります。

レンダリングサーバーでの作業に1フレームの持続時間が長い場合、ヒッチする可能性があります。

作業はアプリのプロセスの外で行われますが、レンダリング作業はアプリに代わって行われるため、アプリのレイヤーツリーをレンダリングするのにかかる時間はお客様の責任です。

レンダリングサーバーには、レンダリング準備とレンダリング実行の2つのフェーズがあります。

レンダリング準備フェーズは、レイヤーツリーがGPUが実行するための簡単な操作のパイプラインにコンパイルされる場所です。

いくつかのフレームで行われるアニメーションもここで処理されます。

レンダリング実行フェーズ中に、GPUはアプリのレイヤーを表示できる最終画像に描画します。

これらのフェーズのいずれも、フレームの納期が遅れる可能性があります。

これらの概念を理解するために、レンダリングの例を見てみましょう。

このフレームのレンダリングを歩きます。

影が円とバーの両方の周りにあることに注意してください。

これは後で重要になります。

アプリが左側のレンダリングサーバーに提出したレイヤーツリーから始めます。

レンダリングサーバーは、レイヤーごとにステップして、GPUがUIを背面から前面に描画できるようにする描画コマンドのパイプラインをコンパイルします。

ルートノードから始めて、レンダリングサーバーは階層内のすべてのレイヤーを持つまで、兄弟から兄弟、親から子へと歩きます。

最後に、GPUが次の実行段階で実行できるパイプライン全体があります。

GPUの仕事は、このパイプラインを取り、各ステップを中央の最終的なテクスチャに描画することです。

ディスプレイフェーズ中に画面に表示されるのは、このテクスチャです。

最初の青いレイヤーから始めて、指定された境界に色を描画します。

次に、濃い青がその境界に引き込まれ、次のレイヤーに進みます。

しかし今、GPUは影を描かなければならない。

影の形状は次の2つのレイヤーで定義されるため、GPUはどの形状で影を描くべきかわかりません。

しかし、最初に円と小節を描くと、影が黒でそれらを隠し、正しくないように見えます。

つまり、GPUが障害に当たったことを意味し、続行するには、影の形を把握するために別のテクスチャに切り替える必要があります。

最終的なテクスチャ以外の場所で描画しているため、これを「オフスクリーンレンダリング」と呼んでいます。

ここから、円とバーを描くことができます。

そして今、それはオフスクリーンテクスチャで分離された影の形を持っています。

最初にレイヤーを黒くしてからぼかして、影の形を整えるのに必要なものがすべて揃っています。

その後、そのオフスクリーンテクスチャを最終的なテクスチャにコピーすることができ、シャドウレイヤーが完了しました。

次のステップは、円を描き、次に長方形を再び描くことです。

アプリが上に描いたテキストの画像をコピーすることで終了します。

これで両方のレンダリングフェーズが完了し、フレームを表示する準備が整いました。

しかし、影をレンダリングするために特別なトリックを行なければならなかったため、レンダリングに時間がかかりました。

これはオフスクリーンパスと呼ばれます。

オフスクリーンパスは、GPUが最初に別の場所にレンダリングしてからコピーしてレイヤーをレンダリングする必要がある場合です。

影で、それは最終的な形を把握するために層を描かなければならなかった。

オフスクリーンパスは加算され、レンダリングがヒッチハイクする可能性があるため、アプリでそれらを監視して回避することが重要です。

最適化できるオフスクリーンパスには、影、マスク、丸みを帯びた長方形、視覚効果の4つの主なタイプがあります。

レンダリングの例で、オフスクリーンの影の例を見ました。

この場合、レンダラーは、最初にアタッチされたレイヤーを描画せずに影を描画するのに十分な情報を持っていません。

2番目のタイプのオフスクリーンは、レイヤーまたはレイヤーのツリーにマスキングが必要な場合です。

レンダラーはマスクされたサブツリーをレンダリングする必要があります。

しかし、それはまた、マスクされた形状の外側のピクセルを上書きすることを避ける必要があります。

したがって、マスクされた形状内のピクセルのみを最終的なテクスチャにコピーする前に、サブツリー全体をオフスクリーンにレンダリングします。

このオフスクリーンは、ユーザーが決して見ることのない多くのピクセルをレンダリングする可能性があります。

3番目のタイプはマスキングに関連しています。

レイヤーの角を丸めるには、オフスクリーンが必要になることがあります。

十分な情報が与えられていない場合、レンダラーはビュー全体を画面外に描画し、丸みを帯びた形状内のピクセルをコピーする必要があるかもしれません。

4番目のタイプは視覚効果ビューからです。

UI Kitは、鮮やかさとぼかしの2種類の視覚効果を提供します。

これらのエフェクトを適用するには、レンダラーは視覚効果ビューの下にあるものをオフスクリーンパスで別のテクスチャにコピーする必要があります。

次に、視覚効果タイプを結果に適用し、コピーします。

これは、iOS、tvOS、macOSで非常に一般的であるため、UIナビゲーションバー、UIタブバー、その他多くの標準コントロールで表示されます。

したがって、これらの4つのオフスクリーンタイプは、レンダリングを遅くし、レンダリングヒッチを引き起こす可能性があります。

レンダリングフェーズの詳細を説明し、多数のオフスクリーンパスがどのようにそれらを引き起こすかを見たので、2番目のトピックに移りましょう。Instrumentsでヒッチを見つけることです。

インスツルメンツ12では、アプリのヒッチをプロファイリングするための新しいインストゥルメントテンプレートをリリースしました。

一部のユーザーは、Meal Plannerアプリのヒッチについて文句を言っており、私は調査したいので、Instrumentから始めて、アプリでスクロールし始めます。

そして、これはアニメーションヒッチテンプレートを使用して、Meal Plannerアプリの痕跡です。

スクロール中に見たヒッチのいくつかに飛び込みたいと思っています。

ヒッチ16を見つけるために、ヒッチトラックを拡大して拡大しましょう。

各トラックは、先ほど説明したレンダリングループのステージに対応しています。

頂上に沿って最も重要なトラックがあります。ヒッチ間隔を表示します。

これは、フレームが準備できているはずの時間です。

ユーザーイベントトラックは、ヒッチングフレームに関連付けられたユーザーイベントを表示します。

コミットトラックは、そのフレーム中にレンダリングサーバーに送信されたすべてのコミットフェーズを表示します。

特にこれらのトラックの詳細については、「コミットフェーズでヒッチを見つけて修正する」を必ず見てください。

そして、これがこのビデオで私たちが焦点を当ててきたものです。

レンダリングとGPUトラックは、レンダリングサーバーによって実行された作業を表示します。

Frame Lifetimesトラックは、イベントから表示までフレームを構成するのにかかった全期間を示します。

そして最後に、内蔵ディスプレイトラックは、途中で発生したVSYNCとともに、ディスプレイに現れたすべてのフレームを表示します。

フレームの寿命とヒッチ期間の開始を比較して、フレームの構成を行うべき予想間隔を視覚化できます。

このヒッチでは、2つのフレームオーバーになり、VSYNCに従うことで、コミットフェーズとレンダリングフェーズの両方が時間の経過とともに経過したことがわかります。

この間隔は許容レイテンシと呼ばれ、その後のすべての時間はヒッチ持続時間です。

トラックの下には、ヒッチトラックが選択されたときにヒッチの詳細なメトリックが表示されます。

私たちはヒッチ16を見ていました。

ヒッチ時間と許容可能なレイテンシを見ることができます。

これは私たちがフレームを完成させなければならなかった時間です。

バッファカウントは、ヒッチ時にレンダリングサーバーが使用するバッファの数です。

デフォルト値は2ですが、レンダリングフレームが遅れ、レンダリングサーバーが追いつこうとしている場合は3になる可能性があります。

ダブルバッファリングモードでは、iPhoneには2つのフレーム、つまり33.34ミリ秒があり、これはレイテンシ列で見られるものです。

上記のHitch Durationトラックに従うことを常に忘れないでください。これは、バッファー数に関係なく、関心のある領域を常に強調表示します。

最後に、ヒッチタイプがあります。

ヒッチタイプは、ヒッチの種類を表面化し、アプリで何を掘り下げるべきかについてのコンテキストを提供するのに役立ちます。

ここでは、高価なコミットと高価なGPU時間の両方があることがわかります。これは、上記のトラックで見たものです。

拡大すると、レンダリングとGPUのトラックに焦点を当て、それらを選択して、準備と実行のフェーズに関する詳細情報を含むアナライザを見ることができます。

重要な列はレンダリングカウントで、GPUが行わなければならなかったオフスクリーンパスの数を見ることができます。

レンダリングヒッチがあったことを知っているので、これらのオフスクリーンを見て、何がそれらを引き起こしているのか、どのように修正できるのかを理解する必要があります。

レイヤーツリーを見る最善の方法は、Xcodeビューデバンカーを使用することです。

そのために、デモに行きましょう。

ここでは、Meal Plannerアプリが一時停止したビューデバッガにあります。

左側には、ビューコントローラー、ウィンドウ、制約、ビューが表示されます。

しかし、Xcode 11.2から始めて、レイヤーを表示することもできます。

エディターをクリックすると、新しいレイヤーを表示項目をクリックしましょう。

かっこいい。

ナビゲーターの左側で、任意のビューをクリックして、そのレイヤーとそのすべてのサブレイヤーを見ることができます。

レイヤーを選択すると、レイヤーの有用な特性にサービスを提供するこの真新しいレイヤーインスペクタが表示されます。

したがって、ここでは、タグビューのバッキングレイヤーがあり、背景色、不透明度、masksToBoundsを有効にしたかどうか、その他多くのプロパティを確認できます。

重要なのは、オフスクリーンのカウントを見ることができることです。

これは、このレイヤーをレンダリングするのにかかったオフスクリーンの数です。

その下には、オフスクリーンフラグと呼ばれるものがあります。

これらは、オフスクリーンの理由を説明しています。

たとえば、オフスクリーンマスクのような特定のフラグは、複数のオフスクリーンをトリガーできます。

例えば、ここには2つあります。

しかし、アプリ全体の各レイヤーを掘り下げてオフスクリーン数を確認する場合、これらのオフスクリーンパスを減らすのに十分な洞察はまだありません。

ビューとレイヤー階層のパフォーマンス最適化を特定して提案するために、Xcode 12に新しいランタイム問題タイプを追加し、最適化の機会と呼んでいます。

これらはデフォルトで有効になっていますが、最適化の機会を表示の下のエディタメニューにオプションがあります。

これらの最適化の機会は、何年もアプリのレンダリングパフォーマンスを最適化した後、Appleのパフォーマンスチームによって開発され、書かれた素晴らしいリソースです。

これらは、レイヤーの全体的な外観に影響を与えない、シンプルでありながら価値のある変更を提案することを目的としています。

ナビゲーターでは、いくつかのレイヤーで紫色のランタイム問題インジケーターを見ることができます。

ここには星の層があります。

検査官では、それが5つのオフスクリーンを取ることがわかります。

インジケーターを強調表示すると、動的な影が原因であることが明らかになります。

詳細については、ランタイムイシューナビゲーターを見てみましょう。

問題のメッセージを読むことができるのはここです。

レイヤーは、レンダリングにコストがかかる動的シャドウを使用していると書かれています。

可能であれば、shadowPathを設定するか、影を画像に事前にレンダリングしてレイヤーの下に置いてみてください。

スライドでは、このタイプのオフスクリーンについて議論します。

レンダラーには十分な情報がなく、影の形を把握するためにレイヤーを画面外に描画する必要があります。

CALayerのshadowPathプロパティを使用することで、実際にレンダラーに5つのオフスクリーンすべてを使用して排除するための正確な手順を与えることができます。

これらは本当に私たちのアプリに加算されるので、コードを見て、この変更を加えましょう。

ここでは、影を設定する星の層があります。

最適化テキストは、任意のCGPathを受け入れるshadowPathを設定するように指示しました。

すでに作成したスターパスを再利用しましょう。

そのようにして、CollectionViewCellごとに5つのオフスクリーンパスを排除しました。

それは大きな修正です。

デバッグナビゲーターに戻ると、まだ他のランタイムの問題インジケーターが表示されます。

タグビューでは、レイヤーにランタイムの問題が表示されます。

ナビゲーターでは、オフスクリーンマスクによって引き起こされる2つのオフスクリーンが表示されます。

このレイヤーは、画像ビューとラベルビューで構成されています。

赤い背景から逃げることを心配していたので、マスクレイヤーを追加しました。

ランタイムツールのヒントでは、原因が単純な背景色のマスキングであることがわかります。

イシューナビゲーターには、機会のテキストが表示されます。

このレイヤーは、背景色がマスクとして設定されたシンプルなレイヤーを使用していると書かれています。

代わりに、マスクと同じフレームとコーナー半径のコンテナレイヤーを使用し、両方のmasksToBoundsを「はい」に設定します。

オフスクリーンは、レンダラーが最初にマスクレイヤーをレンダリングする必要があることによって引き起こされ、提案はこのレイヤーを完全に排除することです。

コードで調べてみましょう。

ここにタグビューがあります。

マスクレイヤーを作成し、黒い背景色と角の半径を与えます。

このマスクレイヤーはシンプルで、単純なレイヤーは決してマスクであってはならない。

代わりに、レンダラーが描画を最適化できるように、この要求されたマスク形状を実際のレイヤーで定義する必要があります。

代わりに、好きなように角の半径を10に設定し、masksToBoundsを「True」に設定できます。

次に、マスクを完全に削除します。

しかし、それは1つのオフスクリーンを排除するだけです。

サブレイヤーがあるため、masksToBoundsは、ビューが正しくクリップされていることを確認するために、オフスクリーンパスを行う必要があります。

しかし、私たちの見解では、サブレイヤーがタグビューの境界を超えないようにしました。

実際、実際にはマスキングは全く必要ありません。

そのmasksToBoundsコールを削除しましょう。

そして今、私たちは両方のオフスクリーンを排除しました。すごい。

これまでのところ、3行のコードで、CollectionViewCellごとに7つのオフスクリーンを保存しました。

これは途方もない改善ですが、もう1つ探すべき問題があります。

ナビゲーターに戻りましょう。

画像ビューを選択しましょう。

角が丸みを帯びていることがわかります。ランタイムの問題を強調すると、「シンプルな形状のマスキング」と書かれています。

もう一度、ランタイムナビゲーターに移動して詳細を学びます。

レイヤーは、rect、roundedRect、または楕円のパスを持つCAShapeLayerによってマスクされていると書かれています。

代わりに、cornerRadiusとmasksToBoundsが設定された適切に変換されたコンテナレイヤーを使用してください。

オフスクリーンは、レンダラーが再び別のレイヤーにマスクする必要があることによって引き起こされます。

しかし、今回は単純なレイヤーではありません。

何が起こっているのかを理解するために、コードを見てみましょう。

このコードでは、画像ビューがあることがわかります。

まず、CAShapeLayerを作成し、UIBezierPath APIを使用してパスを作成し、それをマスクとして使用します。

ここで起こっていることは、有効なタイプのマスクである可能性のあるシェイプレイヤーを使用していることです。

しかし、Xcodeは複雑な形状ではなく、丸みを帯びた長方形を作成しているだけです。

このコードを書いた理由は、時々スクイクルと呼ばれる特別なタイプの丸みを帯びた長方形を作成しようとしていたからです。

このタイプの丸みを帯びた長方形は、iOSで非常に人気があります。

しかし、これはその効果を得るための最良の方法ではありません。

iOS 13以降、cornerCurveプロパティを使用して、cornerRadius効果をスクイクル形状にすることができます。

これで、shapeLayerを完全に排除し、cornerRadiusとcornerCurveを「連続」に設定するだけです。

このように、提供されたAPIを使用するだけで、さらに2つのオフスクリーンを排除しました。

そのため、オフスクリーンカウントを本当に最適化し、36からゼロに引き下げることができました。

それはすごい。

ビューデバッガに戻ると、レンダリングに関連しない他のランタイムの問題がいくつか表示されます。

それにもかかわらず、私たちは同僚のチャールズにそれらを見せて、彼がそれらを最適化できるようにしたいと思います。

以前は、チャールズが私たちと同じデバイスを持っていて、彼のアプリに接続し、ビューデバッガで一時停止する必要があります。

しかし、今ではビューデバッガの状態を保存して、電子メールで送信したり、同僚と共有したり、フィードバックレポートに添付したりすることができます。

これを行うには、ファイル、エクスポートビュー階層を選択できます。

「保存」をクリックして、ほら。

これで、すべてのビュー、レイヤー、制約、ランタイムの問題をカプセル化した送信可能なファイルがあります。

これにより、リモートでのコラボレーションがはるかに簡単になり、不要なオフスクリーンをすべて追跡しようとするときに本当に役立ちます。

Xcodeビューデバッガがアプリの画面外の問題をどのように強調表示できるかを見たので、いくつかの推奨事項をまとめてみましょう。

すべてのアプリで最も重要なことは、常に提供されたAPIを使用することです。

シャドウを設定するときは、多数のオフスクリーンパスを保存するようにshadowPathを設定してください。

長方形を丸めるときは、cornerRadiusとcornerCurveのプロパティを使用します。

丸みを帯びた長方形の形を形成するためにマスクや角の内容を使用することは避けてください。

これらは不必要なオフスクリーンを引き起こします。

ほとんどのレイヤーでは、レイヤーの境界をcornerRadiusに丸めてUIBezierPathを作成することは、良いshadowPathを設定するために必要なすべてです。

2番目のステップは、アプリ全体でマスキングを最適化することです。

masksToBoundsを使用して、長方形、丸みを帯びた長方形、または楕円にマスクします。

カスタムマスクレイヤーよりもはるかにパフォーマンスが高いです。

全体として、マスキングが実際に必要であることを確認してください。

サブツリーのコンテンツが境界を超えない場合は、masksToBoundsを完全に無効にします。

これらは推奨事項にすぎません。

Instrumentsを使用してアプリをプロファイリングし、最適化の機会を利用してレイヤーツリーを検査し、全体的なオフスクリーンカウントを減らすためのシンプルで重要なヒントを確認することが重要です。

最後に、ビュー階層の状態を保存してチームと共有したり、フィードバックレポーターアプリでフィードバックを添付したりできることを覚えておいてください。

全体として、これらのツールと推奨事項は、レンダリングのヒッチを避けるのに役立ちます。

コミットヒッチについては、「コミットフェーズでヒッチを見つけて修正する」を必ずチェックしてください。

一緒に、これらのトークは、アプリのヒッチタイム比を減らし、ユーザーのスクロールをスムーズに保つのに役立ちます。

見てくれてありがとう。