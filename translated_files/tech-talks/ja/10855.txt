10855

こんにちは、私はパトリックで、アップルのパフォーマンスチームで働いています。

今日は、アプリのスクロールとアニメーションのヒッチについて話し合い、レンダリングループを詳しく見ていきます。

まず、ヒッチとは何かを一般的に理解します。

次に、レンダリングループと、起こりうるさまざまな種類のヒッチについて説明します。

最後に、ヒッチを測定する方法について話し合います。

まず、ヒッチとは何ですか?

アプリでは、人が画面上で指をドラッグしてスクロールすることがあります。

ボタンをタップして、階層内のビュー間のフィードバックや遷移を期待するかもしれません。

これらのアニメーションは、画面上の人とコンテンツの間の視覚的なつながりの感覚を構築します。

アニメーションのヒッチは、アニメーションのジャンプを引き起こし、その接続を壊し、喜びの代わりに混乱を引き起こす可能性があります。

ヒッチとは、フレームが予想よりも遅く画面に表示される場合です。

コレクションビューをスクロールする一般的な例を見てみましょう。

ここには、お気に入りのレシピをキュレーションするのに役立つ食事プランナーアプリがあります。

ユーザーが指を画面上にドラッグすると、スクロールビューはコンテンツを上に移動することで応答します。

しかし、スクロール中に、コンテンツのジャンプに気づきます。

このフレームをフレームごとに見ると、最初の3つのフレームのコンテンツで指が動いているのが見えますが、次のフレームではコンテンツが失速しているように見えます。

それは、3番目のフレームが実際に繰り返され、別のフレームのためにディスプレイにとどまるからです。

最後に4番目のフレームが来て、それは私たちの指がある場所に前方にジャンプするように見えます。

4番目のフレームが遅れて到着し、ユーザーがヒッチを見たため、3番目のフレームが繰り返されました。

ヒッチは、レンダリングループがフレームを時間通りに終了できない場合に発生します。

では、レンダリングループを見てみましょう。

レンダリングループは、タッチイベントがアプリに渡され、UIへの変更がフレームが確定されるオペレーティングシステムに送信される継続的なプロセスです。

これはループであり、デバイスのリフレッシュレートで発生します。

iPhoneとiPadでは、これは毎秒60フレームです。つまり、16.67ミリ秒ごとに新しいフレームを表示できます。

iPad Proでは、これは毎秒120フレームです。つまり、8.33ミリ秒ごとに新しいフレームを表示できます。

フレームの先頭で、ハードウェアはVSYNCと呼ばれるイベントを発行します。

VSYNCは、新しいフレームの準備が整っている必要があるときを示します。

ディスプレイトラックでそれらを強調表示するので、締め切りを簡単に確認できます。

レンダリングループはVSYNCにタイミングが合います。

フレームを準備するには、途中でチェックポイントに当たらなければなりません。

それは3つの段階に分かれています。

最初の段階はアプリで、イベントが処理され、UIに変更が加えられます。

その作業は、次のVSYNCの前に完了する必要があるため、次の段階を開始できます。

次の段階は、レンダリングサーバーと呼ばれる別のプロセスで行われます。

これは、あなたのUIが実際にレンダリングされる場所です。

このステージは、3番目で最後のステージであるフレームを表示できるように、次のVSYNCの前に完了する必要があります。

3段階のプロセスに対する重要な注意点は、表示前にフレームが2つのフレームに対して処理されることです。

私たちはこれをダブルバッファリングと呼んでいますが、別のモードがあります。

ヒッチを避けるために、システムはトリプルバッファリングに切り替えることができ、レンダリングサーバーには作業を完了するために1つの余分なフレーム期間が与えられます。

これはフォールバックモードなので、レンダリングループのヒッチについて話しながら、ダブルバッファリングに焦点を当てます。

全体として、レンダリングループ全体は5つのフェーズで構成されています。

ループは、第1段階、イベントフェーズから始まります。

ここでは、アプリはタッチイベントを処理し、UIで変更が必要かどうかを決定します。

次はコミットフェーズです。

コミットフェーズでは、アプリはUIを更新し、レンダリングのためにレンダリングサーバーに送信します。

次のVSYNCでは、レンダリングサーバーがその送信を受け取り、レンダリング準備フェーズでGPUに描画するために準備します。

レンダリング実行フェーズでは、GPUはUIを最終的な画像に描画するので、次のVSYNCでフレームをユーザーに表示できます。

各段階は、すべてのフレーム、レンダリング作業でさえもスムーズなユーザーエクスペリエンスを持つために不可欠です。

それは別のプロセスで起こりますが、アプリに代わって機能するので、レイヤーツリーを時間内に処理して描画できるようにするのはあなたです。

これをもう少し理解するために、例を見てみましょう。

この例では、レンダリングループを通してこのフレームをたどって、途中で各フェーズを確認します。

1つ目は、アプリがイベントを受信するイベントフェーズです。

これらのイベントは、タッチ、ネットワーキングコールバック、キーボードプレス、タイマーのようなものです。

アプリは、レイヤー階層を変更することで、これらのイベントに何らかの方法で応答できます。

たとえば、アプリはレイヤーの背景色を変更したり、レイヤーのサイズや位置を変更したりできます。

しかし、アプリがレイヤーの境界を更新すると、Core AnimationはsetNeedsLayoutも呼び出します。

これはすべてのレイヤーを識別し、それに応じてレイアウトを再計算する必要があります。

システムは、これらの「必要なレイアウト」要求を合体し、重複作業を減らすためにコミットフェーズ中に順番に実行します。

レイアウトが必要な場合は、イベントフェーズが終了するとコミットフェーズが自動的に開始されます。

まず、システムはレイアウトを必要とするすべてのレイヤーを取り、親から子まで、一度に1つずつレイアウトします。

レイアウトは一般的なパフォーマンスのボトルネックなので、アプリはこの作業を完了するのに数ミリ秒しかないことを覚えておいてください。

一部のビューでは、ラベル、画像ビュー、またはdrawRectをオーバーライドするビューなど、カスタム描画も必要です。

これらのビューに視覚的な更新が必要な場合は、setNeedsDisplayを呼び出す必要があります。

レイアウトと同様に、すべてのレイアウトが完了したら、システムはこれらの要求を合体して実行します。

描画プロセス中、すべてのカスタム描画レイヤーは、描画するテクスチャに裏打ちされたCore Graphicsコンテキストを受け取ります。

コアアニメーションに関する限り、これらのレイヤーは今や単なる画像です。

そして、すべてのレイヤーがレイアウトされ、描画されたので、変更されたレイヤーツリー全体が収集され、レンダリングのためにレンダリングサーバーに送信されます。

今、私たちはレンダリングサーバーにいて、レイヤーツリーを実際の表示可能な画像に変える責任があります。

準備フェーズでは、レンダリングサーバーはアプリのレイヤーツリーを反復し、GPUが実行できる線形パイプラインを準備します。

最上層から始めて、親から子へ、兄弟から兄弟へと機能し、レイヤーが後ろから前に配置されます。

次に、この線形パイプラインはGPUを通過し、各レイヤーが最終的なテクスチャに合成されます。

一部のレイヤーはレンダリングに時間がかかることがあり、これはまもなく説明する別の一般的なパフォーマンスのボトルネックです。

すごい。

したがって、GPUが右側の画像を実行してレンダリングすると、次のVSYNCに表示する準備が整います。

レンダリングループの各フェーズはパフォーマンスに敏感で、締め切りがあります。

締め切りは次のVSYNCです。

ターゲットフレームレートを達成し、低い入力レイテンシを維持するために、このプロセス全体が実際にすべてのフレームで並行して行われています。

このようにして、パイプラインは並行し、システムが前のフレームをレンダリングしている間、アプリは新しいフレームを準備できます。

これが、締め切りを逃したことが非常に重要である理由です。

レンダーループの仕組みがわかったので、アプリで見られるヒッチの種類を掘り下げてみましょう。

アプリのプロセス内で発生するコミットヒッチと、レンダリングサーバーで発生するレンダリングヒッチの2つの主要なタイプがあります。

コミットヒッチは、アプリがイベントの処理やコミットに時間がかかりすぎる場合です。

ここでは、コミットに時間がかかりすぎて締め切りに間に合わないため、次のVSYNCでは、レンダリングサーバーは処理するものがなく、次のVSYNCがレンダリングを開始するのを待たなければなりません。

そして今、私たちはフレームの納期を1フレーム遅らせました。

ミリ秒単位で、iPhoneやiPadでは16.67ミリ秒です。

私たちはこの遅延時間を「ヒッチタイム」と呼び、ミリ秒単位で測定します。

コミット作業がさらに時間がかかり、次のVSYNCを通過した場合、フレームは2フレーム、つまり33.34ミリ秒遅れます。

ユーザーにスムーズなスクロールが表示されないのは33.34ミリ秒です。

コミットヒッチとアプリで修正する方法の詳細については、「コミットフェーズでヒッチを見つけて修正する」をチェックしてください。

2番目のタイプのヒッチはレンダーヒッチです。

これらは、レンダリングサーバーがレイヤーツリーを時間通りに準備または実行できない場合に発生します。

ここでは、レンダリング実行フェーズが時間がかかりすぎて、VSYNCの境界を越えます。

したがって、フレームは時間通りに準備ができておらず、緑色のフレームは予想よりも1フレーム遅れて表示されました。

もう一度、16ミリ秒のヒッチタイムがあります。

レンダリングヒッチとレイヤーツリーを最適化する方法の詳細については、「レンダリングフェーズでヒッチを解明して排除する」をチェックしてください。

すごい。

だから、それらは2つの主要なタイプのヒッチです。

それでは、ヒッチを測定し、定量化する方法に焦点を当てましょう。

前のスライドでヒッチタイムを見ました。

単一のヒッチについて話すときに非常に便利ですが、スクロール、アニメーション、トランジションなどの長期的なイベントについて話し合うときには扱いにくいことがあります。

まず、各スクロールやアニメーションにまったく同じ時間、したがってまったく同じ数のフレームがかからない限り、比較は困難です。

さらに悪いことに、iOSデバイスが常に画面を更新するとは限りません。

レンダリングサーバーに送信されたコミットがない場合、新しいフレームは送信されません。

これにより、テストとデバイス間でヒッチ時間を比較することがさらに難しくなります。

そのため、代わりに「ヒッチ時間比」と呼ばれるメトリックを使用します。

ヒッチ時間比は、間隔の合計ヒッチ時間をその持続時間で割った値です。

合計時間に正規化されているため、経験間で比較できます。

ヒッチミリ秒/秒で測定されるため、デバイスが毎秒ヒッチングしていたミリ秒の量を表します。

このメトリックを使用して独自のアプリのパフォーマンスを測定する方法については、「MetricKitの新機能」をチェックしてください。

テストスイートでヒッチタイム比を追跡する方法を確認するには、「XCTestでアニメーションヒッチを解消する」をチェックしてください。

最後に、ヒッチタイム比を使用できる例を見てみましょう。

ここには30フレームがあり、iPhoneでは0.5秒分の仕事です。

各フレームは締め切りに間に合い、ユーザーはヒッチを見ません。

ヒッチ時間はゼロで、ヒッチ時間比もゼロです。

しかし今、下部にバラバラな間隔でディスプレイトラックが見えます。

一部のフレームは他のフレームよりも長く画面に表示され、一部のコミットとレンダリングはヒッチを引き起こしています。

このヒッチ時間を合計すると、100.02ミリ秒になります。

半秒以上、ヒッチタイム比は毎秒200.04ミリ秒です。

これはほんの一例です。

一般的に、これらは私たちが推奨し、ここAppleのツールで使用するターゲットヒッチ比です。

この目標は毎秒ゼロヒッチミリ秒ですが、毎秒5ヒッチミリ秒未満のものは、ユーザーによっては良好であり、ほとんど目立たないと見なされます。

毎秒5〜10ヒッチミリ秒の間で、ユーザーはいくつかの中断に気づくことになり、これらを調査する必要があります。

毎秒10ミリ秒以上のヒッチは、ユーザーエクスペリエンスに大きな影響を与えており、レンダリングループを最適化する方法をすぐに調査する必要があります。

要約すると、今日はレンダリングループと、新しいフレームがユーザーにどのように表示されるかについて議論しました。

ヒッチとは何か、コミットヒッチとレンダリングヒッチの2つのタイプを調べました。

最後に、特定の期間内にユーザーが経験するヒッチングの量を測定するために、ヒッチタイム比を定義しました。

ヒッチの種類とアプリでそれらをキャッチして修正する方法の詳細については、コミットヒッチとレンダリングヒッチに関する2つの講演をご覧ください。

あなたのバターのような滑らかなアプリを見るのが待ちきれません、そして見てくれてありがとう。