605

ラスターオーダーグループはMetal 2の新機能であり、新しいA11 GPU専用にさらに拡張されています。

このビデオは、A11の新しいGPU機能を説明する5つのうちの1つです。

それを最大限に活用するには、以前にImageblocksとTile Shadersでビデオを見たことがあるでしょう。

新しいA11の新機能に移行する前に、メタル2ですでに利用可能なラスターオーダーグループの簡単なレビューから始めます。

ラスターオーダーグループは、GPUが重複する他のスレッドと順番にフラグメントシェーダースレッドの一部を実行する必要がある機能です。

この順序は、renderpass内のドローコールの送信順序と、そのドローコール内の各三角形の順序に由来します。

オーバーラップはラスタライザーによって決定されます。

2つのフラグメントスレッドは、同じフレームバッファXとYの場所、同じサンプル、同じレイヤーをターゲットにすると、重なると判断されます。

たとえば、同じ深度バッファサンプルに対して両方の深度テストを行う場合、2つのフラグメントが重なると見なされます。

これは2つの三角形の典型的なケースで、最初に青い三角形、次に緑の三角形があります。

古典的なグラフィックフレームバッファにアクセスするために、ブレンドは常にGPUが順番に実行するものです。

GPUは、フレームからフレームへのスケジュールの変動のため、緑色の三角形を突然後ろにブレンドすることはありません。

しかし、フラグメントシェーダーは同時に実行され、順不同になります。

ラスターオーダーグループがなければ、作業はフラグメントシェーディングが完了した後、ブレンドする前にのみシリアル化されます。

しかし、フレームバッファに溶け込んでいない場合はどうなりますか?

グラフィックアルゴリズムの最近の開発の多くは、フラグメントシェーダーからより興味深いデータ構造を構築しようとしています。

より良い後処理や注文に依存しない透明性のための多層エンコーディングがあります。

ボクセル化と特別な目的のブレンド機能があります。

これらはすべて、単に色を出力テクスチャにブレンドするのではなく、メモリ内のカスタムデータ構造にデータを保存するフラグメントシェーダー上に構築されています。

しかし、フラグメントシェーダーの本体からのメモリへの直接アクセスが、任意の順序で、いつでも、同時に発生する可能性がある場合、それは厳しく制限されます。

これらのデータレースに対処することで、これらのアルゴリズムの既存の実装は、そうでない場合よりもはるかに高価になりました。

私たちが本当に望んでいることは、そのブレンドのような順序付けられた動作を得ることですが、フラグメントシェーダーの終了後ではなく、その内部です。

私たちは、メモリアクセスが順番に連続して起こっているという錯覚を効果的に望んでいます。

それがラスターオーダーグループがやっていることです。

ラスターオーダーグループを使用して、メモリへのポインタに注釈を付けることができます。

これらのポインタを介したアクセスは、ピクセルごとの提出順序で行われます。

ハードウェアは、現在のスレッドが続行される前に、現在のスレッドと重なる古いフラグメントシェーダースレッドが終了するのを待ちます。

これは効果的に相互排除を与えますが、より良いです。

これは、どのスレッドが最初に重要なセクションに入り、どのスレッドが2番目に入力するかを知る、順序付けられた相互除外を提供します。

この機能は、Metal 2の紹介セッションでWWDC 2017でより詳細に提示されたので、より深く掘り下げたい場合は、そのビデオを見ることができます。

では、基本をカバーして、A11 GPUの新機能に移りましょう。

ラスターオーダーグループは、A11でより便利で、より強力で、より高いパフォーマンスを発揮します。

まず、A11はGPUの内部タイルメモリを公開します。

デバイスやテクスチャアクセスと同様に、タイルメモリは予測可能な順序でアクセスできる方がはるかに便利なので、ラスター注文グループもタイルメモリに適用できるようになりました。

第二に、他のGPUのラスター注文グループがピクセルあたり1つのミューテックスに制限されている場合、A11はそれよりもきめ細かくなり、さらに軽いタッチを可能にし、スレッドがアクセスを待っている頻度を最小限に抑えることができます。

これらの機能を使用して、いくつかの一般的なグラフィックスアルゴリズムで新しいパフォーマンスのロックを解除する方法を示す一対の例を紹介したいと思います。

最初の例は、古典的な遅延シェーディングです。

従来のGPUでは、遅延シェーディングは2回のパスで行われます。

最初にGバッファを充填して複数のテクスチャを出力し、次にそれらのテクスチャから読み取り、光量をレンダリングし、シェーディング結果を計算する2番目のレンダーパス。

しかし、遅延シェーディングは多くのメモリ帯域幅を燃やす傾向があります。

AシリーズGPUの優れた能力の1つは、チップ上でできるだけ多くの帯域幅を維持し、両方のパスを1つに合体させることでこれらの中間テクスチャを排除し、GPU内のイメージブロックで完全にタイルサイズのチャンクにG-Bufferを維持することです。

これらのタスクは両方とも、1つのレンダーパスのフェーズになります。

A11 ImageblockとTile Shadingのビデオで、これらの合体したRenderRassesを構築する方法のより深い説明を見ることができますが、このビデオは同期の側面だけに焦点を当てます。

複数のラスター注文グループを活用することで、シングルパス遅延シェーディングのパフォーマンスがさらに向上します。

それを見るために、フェーズ2の詳細のいくつかを掘り下げてみましょう:照明。

私たちの基本的な照明プロセスは、光の影響を包含するボリュームを描き、フラグメントシェーダースレッドを産卵することから始まります。

各スレッドは、1つのピクセルに1つの光を効果的に適用しています。

私たちの照明スレッドは、Gバッファフィールドを読むことから始まります。

AシリーズのGPUでは、利用可能な最速のメモリであるイメージブロックから直接これを読みたいと思うでしょう。

次に、選択したシェーディングモデルを実行します。これは通常、かなりの数学であり、実行に時間がかかる場合があります。

最後に、この光の寄与を画像ブロックに合計します。

非常に迅速なステップ。

次に、2番目のスレッドで2番目のライトが適用されます。

A11より前のシングルパス遅延シェーディングの実装では、次のようになります。

画像ブロックからの最初の読み取り時に注文が課され、これら2つのライトの実行全体が連続して実行されることがわかります。

これは、単一のラスター注文グループのみをサポートするGPUは、後のスレッドからのアクセスを開始する前に、以前のスレッドからのすべてのアクセスが完了するのを待たなければならないためです。

これは、両方のアクセスが実際に競合しない読み取りであっても適用されます。

複数のラスター注文グループに対するA11のサポートは、この過剰同期を排除します。

複数のグループでは、これらの競合しない読み取りを同時に実行し、結果を蓄積するシェーダーの非常に短い端でのみ同期することができます。

3つのGバッファフィールドが1つのグループにあり、蓄積された照明結果が2番目のグループにあると宣言することで、これを達成できます。

ハードウェアはそれらを別々に注文できるようになりました。

あるグループへの未処理の書き込みは、別のグループでの読み取りを待つ必要はありません。

1つのグループ内の複数の読者は、お互いを待つ必要はありません。

これは、より多くのスレッドがいつでも実行できることを意味し、G-Buffersを最初にオンチップに保つことで得られるものを超えて、より多くの並列性とパフォーマンスの向上を可能にします。

コードも同じようにシンプルです。

私の3つのGバッファフィールドは同時に読み込まれ、一緒に書きされるので、それらをすべて注釈してグループゼロにします。

アキュムレータは別の時間に読み書きされるので、グループ1に注釈を付けます。

養子縁組に関しては、それは本当にそれについてです。

ラスターオーダーグループは、使い始めるのが非常に簡単な機能です。

2番目の例に。

別のフェーズを追加して、遅延シェーディングの例をより複雑にします。

不透明なコンテンツの点灯バージョンを取得した後、ミックスに透明フェーズを追加し、フォワードシェーディングし、バックツーフロントのブレンド順序を近似します。

A11が本当に得意な方法の1つは、色と深さのペアの配列を格納するためにイメージブロックを宣言することです。

各フォワードシェーディングフラグメントは、オーバーフローの処理を伴うエントリをこの配列に追加します。

そして、私のタイルの最後に、保存された深さを使用して、前後に並べ替えてブレンドし、バックツーフロントのブレンドを可能にします。

したがって、これは1つのタイルの寿命とそのイメージブロックを左から右に示すタイムラインです。

私は遅延シェーディングのためにレイアウトされたA11のイメージブロックから始めて、私のシェードの不透明な色で終わります。

最後に、私は色と深さの配列を構築し、並べ替えている透明フェーズを持っています。

これらの各パス内で、ラスターオーダーグループは、フラグメントスレッド間で可能な並列性の量を制御します。

パフォーマンス上の理由から、私は本当にこれら2つの操作を1つのレンダーパスにしたいです。

後でリロードするためだけに、デバイスのメモリに何も保存したくありません。

しかし、イメージブロック宣言は、データタイプとラスター注文グループの割り当ての両方で、私のシーンの最初の部分と2番目の部分の間で大きく異なります。

A11は、あなたの側でワンステップでこの移行を行うことができます。

これらのフェーズ間のギャップを埋めるには、その間にタイルシェーダーを置く必要があります。

タイルシェーダーは、タイルメモリとイメージブロック全体にアクセスできる計算スレッドグループです。

タイルシェーダーは、ラスターオーダーグループの宣言に関係なく、以前にすべてのフラグメントシェーダースレッドが完了するまで起動しないという動作があります。

これにより、このタイルシェーディングスレッドグループがこのメモリに排他的にアクセスできることを保証できます。

タイルシェーダーを使用すると、タイル全体を読み書きし、必要に応じて再フォーマットし、特に古い発信タイプを介してイメージブロックから読み、新しいタイプを使用してイメージブロックの内容を再初期化することができます。

タイルシェーダーが実行前に完全なバリアを持っているように、実行後も完全なバリアを持っています。

後の段階でラスター注文グループをどのように設定したかに関係なく、タイルシェーダーが完全に完了するまで、後続のフラグメントシェーダースレッドはメモリにアクセスしません。

これは、透明性の作業が始まる前に、この初期化が完了することに頼ることができることを意味します。

ここでの要件はかなり簡単です。

イメージブロックの内容を並べ替えたり、ラスターオーダーグループが保護するフィールドを変更したりする場合は、中央にタイルシェーダーを配置して、その移行を整然と安全にする必要があります。

A11用に公開しているサンプルコードのいくつかは、実際にこのシーケンスを示しています。

だから、A11でラスターオーダーグループの拡張された機能を利用するのは本当にそれだけです。

ラスターオーダーグループが他のどのGPUよりもA11でさらに柔軟であるのを見てきました。

ハードウェアは複数のグループをサポートしているため、過剰同期を排除し、パフォーマンスを向上させることができます。

A11のフラグメントシェーダーのタイルメモリへのアクセスと連携し、タイルシェーダーを使用して、レンダリングパスの途中でラスターオーダーグループ設定を含むイメージブロックの文字を完全に変更できます。

すべてをまとめると、帯域幅が信じられないほど軽く、非常に優れたパフォーマンスのA11でワークロードを構築できます。

メタル2とA11の詳細、およびサンプルコードへのリンクについては、メタル開発者のウェブサイトをご覧ください。

ご覧いただきありがとうございます。