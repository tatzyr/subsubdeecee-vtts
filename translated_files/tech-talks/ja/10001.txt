10001

こんにちは、GPUソフトウェアチームのライオネル・ルマリエです。

このセッションでは、Metal Counter APIを使用して、実行時に正確なGPUタイミングを取得します。

私たちはいくつかのトピックを取り上げます。

メタルカウンターAPIの簡単なイントロから始めます。

次に、典型的なライブプロファイリングHUDの主な特徴を簡単に見ていきます。

APIを段階的に使用して、プロファイリング情報を収集します。

そして、このデータがHUDにどのように適合するかを見て締めくくります。

それでは、APIの簡単なイントロから始めましょう。

メタルカウンターAPIはiOS 14で新しく登場します。

macOS Catalinaで利用可能で、macOS Big Surで拡張されました。

Apple Siliconを搭載したiOSとmacOSでは、ステージの境界タイミングにアクセスできます。

つまり、頂点、フラグメント、計算パスの正確な開始時間と終了時間です。

インテルとAMDのGPUでは、個々のパス内でも描画境界タイミング、正確なGPUタイムスタンプを取得できます。

次に、ライブプロファイリングHUDの主な機能を簡単にまとめましょう。

ライブHUDを使用して、実行時にアプリのパフォーマンスを追跡します。

XcodeやInstrumentsでオフラインで調査する必要がある問題領域を見つけるのに役立ちます。

たとえば、デバイスごとに解像度と品質の設定を調整するためにも使用できます。

例として、典型的なライブHUDは次のようになります。

フレームタイムは、スクロール折れ線グラフとして、フレームヒッチ、メモリ使用量、解像度などに関する統計、CPUイベントのタイムラインをキャッチするのに役立ちます。

そして今日は、GPUイベントをタイムラインに追加します。

通常、CPUマーカーの場合、mach_absolute_timeを使用して最も重要な機能を計測し、開始タイムスタンプと終了タイムスタンプを取得します。

CPUマーカーの良いスタートは、コマンドバッファワークの周りにそれらを置くことです。作成時の開始マーカーとコミット時の終了マーカーです。

これにより、レンダリングのCPUコストの概要がわかります。

次に、同等のGPUマーカーを追加したい。

ここで見ているように、Metal System TraceタイムラインのGPUイベントに精通しているかもしれません。

この例のiOSでは、タイルベースの遅延レンダリングアーキテクチャのさまざまな段階を示しています。

ここでは、頂点とフラグメントの処理作業を見ることができます。

これを行うには、GPUファームウェアは頂点ステージの開始と終了を記録します。

次に、フラグメントステージの開始と終了を記録します。

そして、メタルシステムトレースはタイムラインにステージを表示します。

即時モードGPUの場合、ドローコールのグループのイベントをログに記録できます。

たとえば、すべての描画呼び出しの前にレンダリングオブジェクト1の開始を記録し、レンダリングオブジェクト2の開始を記録します。

そして最後に、オブジェクト2の終わり。

次に、GPUが各オブジェクトのレンダリングに費やした時間を正確に示すタイムラインがあります。

それでは、それを達成するためにメタルカウンターAPIを使いましょう。

まず、どのカウンターサンプリングモードが利用可能かを確認することから始めます。

先ほど見たように、GPUがステージ境界、頂点、フラグメント、または計算ステージで記録すべきかどうか、またはドロー境界で記録すべきかどうかを知る必要があります。

supportsCounterSampling APIを使用して、現在のデバイスがステージ境界、TBDR GPU、または無制限モードGPUの境界を描画しているかどうかを確認します。

次に、デバイスで利用可能なカウンターセットを確認します。

カウンターセットには、タイムスタンプ、ステージ使用率、パイプライン統計が含まれます。

GPUマーカーには、タイムスタンプを収集するカウンターセットが必要です。

したがって、デバイスで利用可能なすべてのカウンタセットを列挙し、タイムスタンプ用のものを選択します。

適切なカウンターを設定したら、一部のデバイスがタイムスタンプをサポートしていない可能性があるため、タイムスタンプがあることを確認してください。

初期設定は終わりました。

それでは、各フレームの実行時に必要なものを見てみましょう。

簡単なステップは4つだけです。

まず、サイズ、ストレージモード、先ほど調べたカウンタセットのサンプルバッファを作成します。

次に、サンプルバッファをパス記述子に追加します。

これは、パスごとに少なくとも1つのバッファが必要であることを意味することに注意してください。

次に、ドロー境界でサンプリングを使用している場合は、重要なポイントでサンプリングコマンドを追加します。

最後に、完了ハンドラでは、カウンタを解決します。

そして、必要に応じてCPUとGPUのタイムスタンプを揃えることについて話します。

各ステップを詳細に確認しましょう。

まず、記述子を使用してサンプルバッファを作成します。

適切なサイズになるように、保持できるサンプルの最大数を指定します。

ここでは6つのサンプルを使用しますが、通常はそれ以上のものを使用します。

次に、ストレージモードを設定します。

共有モードはここで素晴らしいです。

データはそれほど多くなく、カウンターへのアクセスがさらに簡単になります。

使用するカウンタセット、タイムスタンプ用のカウンタセットを指定します。

最後に、サンプルバッファを作成します。

これまでのところ、とても良いです。今、私たちは6つのサンプルのためのバッファを持っています。

例として、レンダリングエンコーダで使用しましょう。

コンピューティングエンコーダとBlitエンコーダでも同じことを行います。

このためには、レンダリングパス記述子のサンプルバッファアタッチメントを使用します。

ステージ境界を使用している場合は、ここで設定します。

頂点ステージの開始と終了を指定します。

サンプルバッファのインデックス0と1に配置しています。

それが、GPUが各サンプルをどこに書き込むか、どこから取り出すかを知る方法です。

フラグメントステージの開始と終了についても同じです。

最後に、これらのサンプルを保存するために作成したサンプルバッファを指摘しました。

ドロー境界をサンプリングするには、コマンドストリームの重要なポイントにサンプルコマンドを追加します。

これらの最初の明らかな配置は、すべてのドローコールの前と後です。

したがって、新しいエンコーダを作成したら、すぐにサンプルコマンドを追加します。

ステージ境界サンプルのために最初の4つのスロットをすでに予約しているので、インデックス4に置きます。

すべてのドローコールの後、エンコーダを終了する直前に、インデックス5にサンプルコマンドを追加します。

したがって、GPUは、そのエンコーダのすべての作業の前後にタイムスタンプを記録します。

重要なマイルストーンをマークするために、描画呼び出しのグループ間でより多くのサンプルコマンドを追加できます。

サンプルバッファが事前に十分なスペースで割り当てられていることを確認してください。

そういえば、ステージ境界とドロー境界サンプリングの両方に十分な大きさのバッファを割り当てました。

相互に排他的であるため、ステージに十分な量を割り当てたり、境界サンプリングを単独で描画したりすることで、簡単に最適化できます。

そうです。GPUは、ステージでタイムスタンプカウンタをサンプリングするか、境界を描画するように指示されています。

次に、レンダリングが完了するのを待ち、ハンドラでデータを収集します。

エンコーダごとにサンプルバッファを作成したことを忘れないでください。

したがって、一般的なバッファ補完ハンドラでは、複数のサンプルバッファを解析する必要があるかもしれません。

それぞれについて、カウンターを解決します。

これにより、さまざまな特定のデータを、解析が非常に簡単な統一された金属構造体に変換します。

単にそれを指して、CounterResult構造体を使用してください。

vertexStartはインデックスゼロであるべきだと指定したため、そこから直接読みました。

その後、他のすべてのサンプルで同じことをします。

ここではいくつかのエラーチェックが必要であることに注意してください。

GPUがサンプルバッファを埋められなかった可能性があるため、結果ステップが予想されるサンプル数を収集し、各サンプルが有効であることを確認する必要があります。

特定のタイムスタンプを取得できない場合、GPUは事前定義されたエラー値を使用します。

iOSおよびApple Siliconデバイスでは、GPUタイムスタンプはmach_absolute_timeに整列されているため、CPUタイムスタンプと直接比較できます。

インテルとAMDのGPUでは、追加のステップが必要です。

ベンダー固有のタイムドメインから翻訳する必要があります。

これは、GPUの忙しさ、消費する電力、実行中の熱さに応じて、クロック周波数が時間の経過とともに常に調整され、タイムスタンプに影響するためです。

即時モードGPUでこれに対処するには、サンプルタイムスタンプのAPIを使用して、特定の時間に一致するCPUとGPUのタイムスタンプを照会します。

漂流を避け、時間の経過とともに正確な相関関係を維持するために、一定の間隔でそれを行います。

次に、収集されたサンプルの簡単な線形補間を行います。

例として、一般的なバッファ補完ハンドラ内でサンプルタイムスタンプを呼び出すと、フレームごとに1つの相関が得られます。

CPUとGPUのタイムスタンプをt0で照会したとしましょう。

そして、次のフレームで、t1でそれらを照会します。

サンプルバッファからのすべてのGPUカウンタをスケーリングし、CPUドメインにオフセットできるようになりました。

そして、それが私たちが必要とするすべてです。それでは、それをすべて一緒に表示する方法を見てみましょう。

私たちはCPUマーカーを見ています。

私たちはmach_absolute_timeでそれらを捕獲しました。

頂点、フラグメント、計算段階がすべて重なり、CPUアクティビティと整列しています。

提示されたハンドラ内でmach_absolute_timeを収集して、すべてのマーカーを実際のガラス対ガラスフレームに整列させ、各フレーム内のすべてのイベントを正確に表示することもできます。

このHUDを使用すると、CPUまたはGPUにバインドされているかどうか、依存関係と同期ポイント、頂点、フラグメント、コンピューティング作業の内訳、およびそれらが互いにどのように影響するかを把握できます。

そのすべては、ライブ、あなたのアプリの中にあります。

気をつけられることがいくつかあります。

HUDをあまり頻繁に更新しないでください。

FPSカウンタと同様に、ライブデータが常に変化している場合、読みにくい場合があります。

フレームごとにタイムスタンプを収集できますが、たとえば、画面上のマーカーは1秒に1回しか更新できません。

従うのがかなり簡単になります。

第二に、GPUのアクティビティはクロックレートに依存します。

高いGPU占有率を見ることは、必ずしもそれが最大になるという意味ではありません。

システムは必要なだけの電力しか使わないので、電力とパフォーマンスのバランスが取れます。

その結果、HUDでGPUが80%ビジー状態になっているのがわかるかもしれません。

しかし、最大クロックレートの半分で実行されている場合、実際にはピークパフォーマンスの40%で動作し、十分なヘッドルームがあります。

そして、いつものように、エラーを処理する必要がありますが、矛盾にも注意する必要があります。

たとえば、カウンタがオーバーフローする可能性があるため、新しい値が前の値よりも小さくなり、負の期間が発生する可能性があります。

または、サンプリングカウンター中にデバイスをスリープ状態にしたり、休止状態にしたりすると、大きな外れ値が発生する可能性があります。

これらはまれなイベントであり、ディスプレイやログの不具合を避けるために、それらを優雅にスキップする必要があります。

要約すると、Metal Counter APIを使用してGPUタイムスタンプを収集する手順を実行しました。

これを行うには、デバイスサポートCounterSamplingメソッドを使用して、どのサンプリングモードがサポートされているかを調べました。

GPUのタイムスタンプでセットを見つけるためにカウンターセットを列挙しました。

記述子を使用して新しいサンプルバッファを作成し、レンダリングコマンドエンコーダで使用しました。

Blitとコンピューティングエンコーダでも同じことをしたいと思うでしょう。

すべてのドローの前後に特定のサンプルコマンドを追加しました。

描画、ディスパッチ、ブリットの間にも追加して、過去のタイミングを取得できます。

カウンタをCPUメモリに解決しました。

そして最後に、必要に応じてそれらを再調整しました。

そして、強力なライブGPUプロファイリングHUDがアプリの上に表示するために必要なすべてのデータがあります。

そして、このAPIは、GPUのタイムスタンプ以上のものへのアクセスを提供します。

ステージ情報ごとに要約できます。これは、タイムラインにイベントを描画していない場合は、より簡単に処理できます。

そして重要なことに、頂点やフラグメントシェーダーの呼び出し数やコンピューティングカーネルなど、詳細な統計を取得できることです。

Metal Counter APIには十分に探索でき、実行時にGPUのパフォーマンスをプロファイリングするための多くの情報にアクセスできます。

このセッションはこれでおそれです。

見てくれてありがとう。