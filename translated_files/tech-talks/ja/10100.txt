10100

アレハンドロ・イサザ:こんにちは。私はアレハンドロです。

今日、Davidと私は、データ操作と探索のための新しいフレームワークであるTabularDataを紹介します。

簡単な紹介から始めて、データ探索、データ変換、ベストプラクティスについて話し、要約で終わります。

飛び込みましょう。

まず、表形式データとは何ですか？

簡単に言えば、表形式のデータは、スプレッドシートと同様に、行と列に整理されたデータです。

しかし、あなたが何百もの列と数百万の行を持っていたと想像してみてください。

ここで、TabularDataフレームワークの出番です。

それで、それは何ですか?

それは私たちが取り組んできたまったく新しいフレームワークです。

macOS、iOS、tvOS、watchOSですでに利用可能です。

非構造化データを探索して操作するのに役立ちます。

「非構造化データ」とは、事前に定義された方法で配置されていないデータを意味します。

たとえば、技術仕様のないデータセットをダウンロードする場合、たとえば、気象データや人口統計などです。

そして、探検は、新しいデータセットに遭遇したときに最初に行うことです。

どのような情報があるのか知りたいです。

のようなもの、価値観は何ですか?

タイプは何ですか?データはどのように表されますか?

欠落している値はありますか?などなど。

データセットを適切に理解し、操作という次のステップに進むには、これらの質問に答えることができる必要があります。

操作は、データセットを解決しようとしている問題に最も適した形式に変換する場所です。

たとえば、日付を文字列ではなく日付型として表現したり、x座標とy座標を点型に結合したりできます。

TabularDataフレームワークは、大規模なデータセットを扱うのに最適です。

一般的なユースケースをいくつか紹介します。

いくつかの基準に従ってデータをグループ化する。例えば、年齢別に人々をグループ化する。

共通の値に関するデータセットを結合する。

たとえば、トランザクションのテーブルを購入者の情報で結合します。

データを分割またはセグメント化して段階的に処理したり、データセット全体のサブセットにフィルタリングしたりします。

そして、データパイプラインを構築する。例えば、機械学習のためのフィーチャーエンジニアリングを行うとき。

フレームワークのコンテキストでは、テーブルはDataFrameとして知られています。

DataFrameには、スプレッドシートに似た行と列が含まれています。

しかし、スプレッドシートとは異なり、すべての列には特定の種類の値のみを含めることができます。

しかし、これはまた、列が任意のタイプ、さらには独自のカスタムタイプを保持できることを意味します。

例えば、辞書、GPS座標、または生のオーディオサンプル。

DataFrameまたはDataFrameスライスを表すテーブルを表示するたびに、左側にインデックス列が含まれることを知ってください。

これは、データインデックスで行にアクセスする必要がある場合に関連しています。

フィルターなどの一部の操作では、データは変更されませんが、ソートなどの他の操作では、結果のデータフレームのインデックスが変更される場合があります。

それを分解して、列にズームインしましょう。

前述したように、列には特定の要素タイプがあります。この場合、Int。

また、データフレーム内で一意でなければならない名前もあります。

列は、配列と同じようにコレクションである列タイプで表されます。

列を名前で参照できますが、ほとんどの場合、タイプも必要です。

列の名前とタイプを保持するColumnIDと呼ばれる構造体があり、特定の列を参照するために使用できます。

可能な限り、文字列リテラルよりも定義済みのColumnIDを使用して列を参照することをお勧めします。

また、DataFrame内のすべての列が同じ数の要素を持つ必要があることに注意してください。

しかし、nil値として表される欠落している要素が常にある可能性があります。

列と同様に、行タイプがあります。

行の各要素には、列名またはインデックスでアクセスできます。

Rowはプロキシと考えることができます。

実際には行の要素は含まれていません。代わりに、DataFrameの行を指す参照です。

では、どのようにDataFrameを作成しますか?

お見せしましょう。

辞書リテラルから、または一度に1つの列を構築することで、DataFrameを作成できます。

これは、辞書リテラルから構築する例です。

辞書リテラルを使用する場合は、文字列、数値、ブール値、日付などの基本的なSwift型を使用することが制限されていることに注意してください。

また、すべての列が同じ数の要素を持たなければならないことを覚えておいてください。

DataFrameを構築するより一般的な方法は、一度に1つの列を作成し、その列をDataFrameに追加することです。

ここに例があります。

まず、空のデータフレームを作成します。

次に、列を作成します。

そして、DataFrameに列を追加します。

すべての列でプロセスを繰り返すことができますが、繰り返しますが、すべての列が同じ数の要素を持ち、列名が一意であることを確認してください。

DataFrameが何であるかがわかったので、データ探索をしましょう。

最初にしたいことは、データセットをロードすることです。

TabularDataは、カンマ区切りの値、CSV、およびJSONファイルの読み取りをサポートしています。

そして、すべてのデフォルトオプションを使用して読み込まれるファイルURLで初期化子を呼び出すのと同じくらい簡単です。

CSVを読み込むときに利用可能なオプションのいくつかを見てみましょう。

以前にCSVを使用したことがある場合は、常にカンマがあるわけではないことを知っているかもしれません。

区切り文字はタブまたはセミコロンです。

または、列名のヘッダー行があるかもしれないし、ないかもしれない。

また、特殊文字の文字列のエスケープ方法や、欠損値の表現方法のバリエーションもあります。

TabularDataはすべてのバリエーションを処理できます。

この例では、カスタムnilエンコーディングを使用し、空行を無視し、セミコロン区切り文字を使用して、ヘッダー行がないことを指定しています。

オプションのフルセットとデフォルトを確認するには、ドキュメントを参照してください。

ファイルが大きい場合は、一度に行のサブセットのみを読み込むことができます。

行オプションでこれを行うことができます。

たとえば、これは最初の100行のみをロードします。

同様に、列のサブセットを選択できます。

これを行うには、列引数を使用します。

これにより、列を再編成できることに注意してください。

CSVファイルを読み込むときに型推論がどのように機能するかについて簡単に説明しましょう。

CSVファイルはすべてテキストベースです。

しかし、すべての列を文字列型にすることはあまり便利ではありません。

したがって、CSVファイルを読み込むとき、TabularDataは文字列にデフォルト設定する前に、値を数値、ブール値、および日付に変換しようとします。

値を特定のタイプに強制したい場合、またはロードを少し高速化したい場合は、列のタイプを明示的に指定できます。

型引数でこれを行います。

この例では、id列に整数型を、name列に文字列型を指定しています。

これにより、ロードプロセスが高速化されるだけでなく、指定されたタイプに変換できない値がある場合にもエラーがスローされます。

これは、問題を早期に発見し、期待するものではないタイプの列で終わるのではなく、適切に処理できるため、良いことです。これにより、アプリの後半でクラッシュする可能性があります。

最後に、日付解析について言及させてください。

TabularDataは、デフォルトでは、ISO8601形式で日付を検出して解析します。

CSVファイルに別の形式の日付が含まれている場合は、カスタム日付解析戦略を指定する必要があります。

デイビッドにこれについて話してもらい、デモに入るときに例をお見せします。

では、ギアを切り替えて、データを書き出すことについて話しましょう。

最初で最も簡単な選択は、Swiftの印刷機能を使用することです。

これにより、ターミナルできれいに印刷されたテーブルが生成されます。

印刷された出力には、行インデックス、列名、列タイプ、データの最初の数行、行と列の数が含まれます。

また、すべての行が画面に収まるとはなく、すべての列が画面に収まるわけではないことも示しています。

この場合、表示されない列がさらに10個あります。

印刷は探索やデバッグに最適ですが、明らかにデータの保存には最適ではありません。

DataFrameをCSVファイルとして保存する場合は、writeCSVメソッドを使用します。

注意すべき重要なことの1つは、writeCSVがすべての値のデフォルトの文字列変換を使用することです。

生成されたCSVは読み戻せるものではない可能性があるため、列でカスタムタイプを使用するときは注意してください。

原則として、CSVに書き込むときは、列の基本的なSwiftタイプのみを使用します。これにより、一部の列を変換する必要がある場合があります。

writeCSVには、読み取りオプションに似たオプションがいくつかあります。

CSVデータの書き方をカスタマイズできます。

以下は、カスタムnilエンコーディングとカスタム区切り文字を使用してヘッダーを無効にしている例です。

特定の行にアクセスするには、行の下付き文字を使用するだけです。

その後、その行の特定の列にアクセスできます。

しかし、可能な限り、代わりに最初に列にアクセスし、次に行にアクセスする必要があります。

これが列にアクセスする方法です。

列に名前でアクセスする場合は、添字から列:ラベルを省略できます。

行のサブセットにアクセスすることもできます。

この場合、DataFrameスライスを取得します。

DataFrameスライスはDataFrameと非常によく似ています。

基本的には元のDataFrameへの参照です。ほとんどの場合、それが完全なDataFrameなのかスライスなのかを知る必要さえありません。

最後に、列のサブセットを選択することもできます。

これにより、これらの列のみを含む新しいDataFrameが返されます。

フィルタメソッドを使用して行のサブセットを選択することもできます。

フィルタ操作の結果は、行の範囲を選択するのと同様に、DataFrameスライスです。

しかし、行の範囲とは異なり、フィルターは不連続な行を返すことができます。

DataFrameスライスインデックスを扱うときは注意が必要です。

配列スライスと同様に、そのインデックスは元の行のインデックスを反映しています。

具体的には、最初のインデックスはゼロではなく、次のインデックスは現在のインデックスプラス1ではないかもしれません。

文字列インデックスと同様に、ゼロの代わりにstartIndex、カウントの代わりにendIndex、1つを追加する代わりにindex(after:)を使用します。

基本をカバーしたので、アプリを構築して実践してみましょう。 

サンフランシスコで駐車場を見つけるのは難しいです。

デビッドと私は、路上の近くの駐車場を表示するiPhoneアプリを作りたいです。

市が公開したデータを使用して、現在駐車が許可されている場所の近くにあるパーキングメーターを特定したいと考えています。

データセットがあることは知っていますが、何が含まれているのか正確にはわかりません。

したがって、最初のステップは、私たちが持っているものを理解するためにデータセットを探索することです。

デイビッドに渡します。

デビッド・フィンドレー:ありがとう、アレハンドロ。

こんにちは。私はフレームワークエンジニアのデビッドです。

このデモでは、TabularDataを使用してデータセットを探索する方法の例を見ていきます。

まず、駐車ポリシーのCSVファイルを調べます。

最初のステップは、データをロードすることです。これは、ファイルのURLをDataFrame初期化子に渡すことで簡単に行うことができます。

イニシャライザはスロー可能であり、潜在的な解析エラーを処理する際に有用であることに注意してください。

次に、簡単なプリントで、最初の数行と列を探索できます。

読み込みには数秒かかりました。これは、DataFrameが100万行と15列以上をメモリにロードしたためです。

初めてデータセットを探索するときは、通常、データセット全体を必要としないので、データを読み込むときに行範囲を指定して、探索を高速化します。

次に、列を見ていきます。 

画面に収まらないので、そのうちの2つが右側に隠されていることに注意してください。

書式設定オプションでそれを修正する方法をお見せしましょう。

書式設定オプションでは、データの表示方法を設定できます。

この場合、最大ライン幅を250に増やし、列の幅を15に減らし、行を5に減らして、印刷結果をスクロールするのを防ぎます。

その後、説明方法を使用して、印刷ステートメントにformattingOptionsを追加するだけです。

すごい！すべてのコラムを探索できるようになったので、興味深いコラムをいくつか選びます。

また、列を好きな順番にリストアップして再編成する良い機会です。

HourlyRate、DayOfWeek、開始時刻と終了時刻、StartDate、PostIDがあります。

次に行う必要があるのは、DataFrameを読み込むときにこれらの列をパラメータとして追加することだけです。

さて、これはすでに探索するのがとても簡単です。

文字列型を持つStartDate列を見てみましょう。

これは、ISO8601の日付のみが自動的に検出されるためです。

他の日付形式を明示的に指定する必要があります。

アレハンドロが先に説明したCSVReadingOptionsを使用して修正できます。

Foundation Date Parsing APIを使用して、日付解析戦略を追加します。

フォーマットを年、月、日、ロケールを米国英語、タイムゾーンを太平洋標準時として指定します。

次に、DataFrameを読み込むときにCSVReadingOptionsを渡します。

StartDate列が正しいタイプになったので、DataFrameを簡単にフィルタリングして、アクティブな駐車ポリシーのみを設定できます。

現在の日付を表す変数から始めて、フィルターメソッドを使用してDataFrameをフィルタリングします。

フィルタメソッドは、列名（この場合はStartDate）とタイプ（日付）を取ります。

クロージャでは、オプションの日付をアンラップし、日付値がnilのときにfalseを返して、フィルター結果に表示されないようにします。

そして最後に、現在の日付以下の開始日を保持します。

先に進んで、印刷を変更して、フィルタリングされた結果を表示します。

これからは、StartDate列は必要ないので、先に進んで削除します。

しかし、DataFrameスライスから列を削除できないので、注意する必要があります。

列を削除することは変異方法であるため、まずDataFrameに変換し、varのfilteredPoliciesを作成する必要があります。

これで、removeColumnメソッドを使用して列を削除し、削除する列としてStartDate列を指定できます。

さて、それは私が駐車ポリシーデータセットで探求したかったすべてです。

次のセクションでは、アレハンドロが表データを拡張する方法について説明します。

あなたに戻って、アレハンドロ!

アレハンドロ:ありがとう、デビッド。

今、私は今、データセットについていくつかの素晴らしい洞察を持っています。

次のステップは、私たちのニーズに合わせてそれを変革し、増強することです。

最も単純な種類の変換は、列内の値を変更することです。

これは、各値がおそらく異なるタイプの新しい値にマッピングされるマップ操作の形をとることができます。

TabularDataは、利便性としてマップのインプレースバージョンを提供します: transformColumn。

この例では、DayOfWeek列を文字列から平日を表す整数に変換しています。

コードはこんな感じになります。

各要素について、文字列をIntに変換します。

transformColumnと同様に、デコードメソッドはデータのデコードを処理します。

CSVファイルを扱う場合、JSON値としてCSVに埋め込まれた配列や辞書に遭遇する可能性があります。

TabularDataは、これに対するデコード方法を提供します。

以下は、左側のDataFrameにJSONデータブロブが埋め込まれている例です。

Decodeを使用すると、JSONDecoderを使用して列を独自のタイプに変換できます。この例では、Preferencesです。

そして、これがコードがどのように見えるかです。

PreferencesタイプはDecodableプロトコルに準拠する必要があり、列にはJSONDecoderが入力として期待するDataタイプの要素を含める必要があることに注意してください。

もう1つの有用な操作は、塗りつぶされた方法です。

列のすべての欠落値をデフォルト値に置き換えることができます。

そして、列操作のリストを完成させるために、要約について言及したいと思います。

要約は、列の内容の簡単な概要を提供します。

サマリーメソッドは、カテゴリサマリーを返します。

これには、説明にsomeCountとして表示されている要素の数、noneCountとして表示される欠落している要素の数、一意の要素の数、およびモードと呼ばれる最も頻繁な値が含まれます。

numericSummaryもあり、数値を含む列でのみ使用できます。

これには、カウントに加えて、平均、標準偏差、その他の統計も含まれます。

ここでは、要約の印刷結果を示しています。

ただし、要約構造体を直接使用して統計にアクセスすることもできます。

たとえば、スコアを75パーセンタイルのスコアにフィルタリングしたい場合。

さて、それは多くの列変換でしたが、列変換は最も面白くありません。

DataFrame変換は、本当に面白くなるところです。

列変換とは異なり、DataFrame変換は一度に複数の列を操作します。

簡単な例は並べ替えです。

私たちは皆、ソートがどのように機能するかを知っていますが、明確にするために説明させてください。

この表をスコアで並べ替えましょう。

これはすべての列に影響します。

また、ソート時に行のインデックスが変更されることに注意してください。

もう1つの興味深いDataFrame変換は、combineColumnsです。

combineColumnsメソッドを使用すると、複数の列を1つにまとめることができます。

たとえば、緯度と経度に別々の列があるが、それらをCLLocationタイプに結合したいと想像してください。

これを行う例を次に示します。

まず、結合する列を指定します。

次に、新しい列に名前を付けます。

次に、入力列と新しい列のタイプを指定し、すべてがオプションでなければならないことに注意してください。

不足している値のケースを処理し、新しい値を構築します。

列と同様に、DataFrameの要約メソッドもあります。

すべての列の要約統計を返します。

大きなDataFrameがある場合、これはコストがかかる可能性があることに注意してください。興味のある列だけを要約した方が良いかもしれません。

もう一つの興味深い方法は爆発です。

要素の配列を含む列を取り、配列内のすべての要素に対して新しい行を作成します。

この例を見てみましょう。 

今回、スコア列には、各人のスコアの埋め込み配列が含まれています。

DataFrameに爆発操作を適用すると、これらのそれぞれが新しい行になります。

私たちは、複数のスコアを持つ人々のために名前を繰り返しました。

これは、フィルタリングしたり、個々のスコアを見る必要がある他の操作を行う場合に便利です。

私たちの武器庫にあるこれらのツールで、私はそれをデビッドに戻します。デビッドは、メーターデータを必要なフォームに入れるのに役立ちます。

デビッド、私たちにいくつかのコードを見せてください。

デビッド:ありがとう、アレハンドロ。

あなたのことは知りませんが、私にとって、駐車場の最も重要な部分は場所です。

幸いなことに、私は必要なものだけを持っている別のCSVファイルを持っています。

そこに何が入っているかお見せしましょう。

以前と同様に、データの読み込みから始めますが、今回は興味のある列をすでに知っています。

POST_ID、STREET_NAME、STREET_NUM、LATITUDE、LONGITUDEがあり、前のデモと同じフォーマットオプションを使用して結果を印刷します。

私が望む最初の拡張は、緯度と経度の列をコアロケーションタイプの新しい列に組み合わせることです。

combineColumnsメソッドは、その仕事に最適です。

ここでは、緯度と経度の列を場所という名前の新しい列にまとめています。

クロージャでは、緯度と経度のパラメータタイプとコア位置の戻り値タイプを指定します。

次に、オプションの緯度と経度の値をアンラップし、どちらかがnilの場合はnilを返します。

そして最後に、緯度と経度の値をコアロケーションイニシャライザに渡します。

DataFrameの場所を使用して、アプリの最初の機能を構築し始めることができます。場所が与えられたら、最も近いパーキングメーターを検索します。

場所、DataFrame、および検索結果に含めるパーキングメーターの量を取る closestParkingという名前の関数を書きます。

ローカルコピーから始めます。

そして、アレハンドロが以前に導入したtransformColumnメソッドを使用して、場所を距離に変換します。

そしてもちろん、場所の列の名前を距離に変更します。

最後に、距離の列を昇順に並べ替え、戻るスポットの数を制限します。

楽しみのために、サンフランシスコのApple Storeでこれを試してみましょう。

Apple Mapsで見つけた座標、メーターDataFrameを接続し、検索結果を5つの駐車場に制限します。

完璧！ポストストリートのアップルストアの近くにたくさんの駐車場があるようです。

アプリの最初の機能はうまく機能していますが、最も近い駐車場がすべてすでに取得されている場合はどうなりますか?

アプリの次の機能は、駐車場が最も多い通りを見つけることです。

しかし、この機能を実装する前に、グループ化と呼ばれる新しい概念を紹介しましょう。

グループ化は、グループ化列を指定して、データをグループに分割します。

例えば、STREET_NAME列。

グループメソッドは、最初に一意の通り名の値（ポストストリート、カリフォルニアストリート、ミッションストリート）を識別し、行を対応するグループに分割します。

各グループはDataFrameスライスです。

では、コードに戻りましょう。

グループ化された方法で通りの名前でメーターをグループ化します。

その後、各ストリートグループのパーキングメーターの数を数え、結果を降順で提供できます。

駐車場が最も多い通りは結果の一番上にあり、それが私のアプリに必要なものです。

これはとても素晴らしいです!

私のアプリの2つの素晴らしい機能。

しかし、ちょっと待ってください、私はちょうど最初の機能にバグがあることに気づきました。

最も近いパーキングメーターは、メーターDataFrameのみを考慮します。

私が本当に必要としているのは、アクティブな駐車ポリシーを持つ最も近いパーキングメーターです。

その情報はデモ1のデータにあるので、これは面白くなっています。

バグを修正できるように、2つの異なるソースからデータを結合する方法をお見せしましょう。

以前にリレーショナルデータベースを使用したことがある場合は、参加に精通しているかもしれません。

キーを使用して2つのDataFrameを結合できます。

キーは、両方のデータフレームに表示される値です。

メーターとポリシーDataFramesでは、キーはパーキングメーターを一意に識別するPOST_IDです。

参加操作により、メーターからのPOST_IDがポリシーからのPOST_IDと一致する行を持つDataFrameが作成されます。

行は、左のDataFrameと右のDataFrameから一致するデータで構成されています。

列名には左または右の接頭辞があることに注意してください。

これは、列の結合のどちら側から来たかを示します。

プレフィックスは、結合結果の命名衝突を避けるのに役立ちます。

この操作は内部結合であり、これがデフォルトです。

他にも左アウター、右アウター、フルアウターの3種類があります。

ここでは詳しく説明しませんが、詳細については、ドキュメントを参照してください。 を参照してください。

さて、それは私が表形式のデータ拡張でカバーしたかったすべてです。

次のセクションでは、アレハンドロがベストプラクティスについて話します。

アレハンドロ:ありがとう、デビッド。

今、私たちは必要な形ですべてのデータを持っているので、アプリを構築する時が来ました。

生産準備をしながら、探査コードを再利用する方法について話しましょう。

CSVファイルを読み込むために始めたコードに戻りましょう。

これを行うと、列の型が不明になります。

これは、タイプを事前に知る必要があるフィルターや参加などの操作には問題があります。

ユーザーが提供したソースからデータをロードする場合、タイプについて仮定することは危険です。

アプリがクラッシュする可能性があります。

代わりに、この例のように、データをロードするときに期待するタイプを宣言する必要があります。

ここでは、気になるすべての列の列IDを定義しています。

そして、列名と列タイプの両方をCSV初期化子に提供します。

列を参照する任意のメソッドでは、文字列の代わりに列IDを使用できることを忘れないでください。

これで、無効な値がある場合は、ユーザーにエラーを提示するなど、処理できる例外が表示されます。

このようにして、あなたが期待する列と列のタイプを持っていることを確認することができます。

これは、カスタム日付形式を使用する場合に特に重要です。列が日付型であることを指定しないと、日付解析が静かに失敗し、代わりに文字列列が生成される可能性があるためです。

日付を強制すると、失敗したセルの内容を含む例外がスローされ、問題をデバッグするのに役立ちます。

エラーといえば、これらはCSVファイルを読み込むときに予想される種類のエラーです。

カスタム日付パーサーを使用すると解析に失敗し、セルが解析に失敗すると生成されます。

他のものは自明ですが、ドキュメントを参照してください。

そして最後に、パフォーマンスについて簡単に言及させてください。

ほとんどの場合、パフォーマンスを心配する必要はありませんが、大規模なデータセットで作業するときに大きな影響を与えるケースがいくつかあります。

1つ目は、CSVを読み込むときの日付解析です。

日付解析には多くの特別なケースと考慮事項があり、そのため、遅くなる傾向があります。

CSVファイルの読み込みに数秒以上かかる場合、これはあなたが改善するために検討すべき最初の場所です。

1つの選択肢は、解析を遅らせることです。

これは、すぐに日付情報を必要としない場合に特にうまく機能します。

たとえば、最初にフィルタリングまたはグループ化を実行したい。

それがオプションでない場合は、日付文字列のパフォーマンスを最適化する日付パーサーを手作りすることを検討してください。

グループ化するときは、文字列やIntなどの基本的なSwiftタイプを含む列をグループ列として常に使用してください。

これにより、グループ化のパフォーマンスが高速化されます。

複数の列でグループ化する場合は、まず列を単純なタイプの単一の列に結合してからグループ化することを検討してください。

たとえば、曜日とメータータイプでグループ化する場合は、これら2つのプロパティを文字列にまとめることを検討してください。

例えば、デイタイプ。

同様に、参加するときは、基本的なSwiftタイプを含む列で参加することを検討してください。

これで、私たちはアプリを完成させる準備が整いました。

デビッド、それをまとめましょう。

David: TabularDataのベストプラクティスを使用して、アプリの検索機能を書きます。

駐車構造体は、結合されたメーターとポリシーDataFrameを保存します。

そして、複数の方法がそれを必要とするので、私は場所ColumnIDを定義しました。

loadMetersメソッドの詳細を掘り下げてみましょう。

上部には、メーターをロードするために必要な列IDがあります。

次に、メーターをロードし、各列の予想されるタイプを指定します。

これは、提供されたCSVファイルに不一致がある場合にスローされます。

次に、解決された列が私が期待していたとおりであることを確認し、それ以外の場合はカスタムParkingErrorをスローします。

最後に、緯度、経度、および場所の列IDを使用するようにcombineColumns操作をリファクタリングしました。

それにより、アプリの検索機能は本番対応です。

TabularDataフレームワークの要約のためにアレハンドロに返します。

アレハンドロ:ありがとう、デビッド。要約しましょう。

今日は、TabularDataが未知のデータセットを探索し、操作し、アプリに持ち込む方法を紹介しました。

データセットを調査し、いくつかの列とデータ変換を調べ、エラー処理とパフォーマンスに関するいくつかのベストプラクティスを終えました。

TabularDataを使って素晴らしいアプリを作る方法を見るのが待ちきれません。

ありがとう！