604

このプレゼンテーションでは、レンダリングパス内でインラインでコンピューティング機能を提供するAppleのA11 GPUの新しいプログラム可能なステージであるタイルシェーディングに焦点を当てます。

タイルシェーディングは、Metal 2のまったく新しいレベルのパフォーマンスと効率を可能にします。

レンダリングとコンピューティング操作は、より高い帯域幅と低消費電力のタイルメモリを介してデータを共有できるようになりました。

タイルシェーディングはイメージブロックと深く統合されています。

イメージブロックのコンテンツを分析したり、そのコンテンツを要約したり、シーンの途中でイメージブロックを保存したり、イメージブロックのレイアウトを変更したりすることもできます。

タイルシェーディングもスレッドグループメモリと緊密に統合されており、後のタイルまたはフラグメントステージのタイル定数データをキャッシュするために使用できます。

タイルシェーディングの必要性を動機づけることから始めましょう。

レンダーパス間の計算の実行は、近年より一般的になっています。

たとえば、タイル繰延レンダリングおよびフォワードレンダリングアルゴリズムは、シェーディングコストを削減するために、スクリーン整列タイルに対してライトを交差させます。

これらのアルゴリズムの背後にある考え方は、すべてのライトがすべてのピクセルに影響を与えるわけではありませんが、ピクセルあたりの淘汰は高すぎる可能性があるため、タイル領域のコストを償却します。

以前はMetal for AシリーズGPUでは、コンピューティングミッドレンダリングを実行するには、コンピューティングパスがそれを消費できるように、タイルメモリにキャッシュされたレンダリングターゲットデータをデバイスメモリに保存する必要がありました。

コンピュートは、レンダリングが再開される前に、結果をデバイスのメモリに保存する必要があります。

ローカルメモリと外部メモリ間のこの繰り返されるデータ移動は、帯域幅集約的です。

Metal 2とA11 GPUを使用すると、このようなアルゴリズムは、コンピューティングパスの代わりにタイルシェーディングを使用して、露出したタイルメモリ内でのみ動作できるようになりました。

レンダリングターゲットコンテンツは、一度タイルメモリにキャッシュされるようになりました。

その後、タイルシェーディングはイメージブロックで直接動作し、その結果をスレッドグループメモリにすることもできます。これは、レンダリングによって後で使用するためにタイルメモリによってバックアップされます。

タイルシェーダーがタイルメモリ内でより頻繁に操作できるようにする方法を見たので、タイルシェーディングがドローとどのように相互作用するかを詳しく見てみましょう。

コンピューティングパス内のスレッドの起動はディスパッチと呼ばれ、Metalはレンダリングパス内のタイルシェーディング操作に同じ名前を採用します。

タイルディスパッチは、ドローと自由にインターリーブすることができ、API提出順序で実行されます。

金属は、そのディスパッチが実行されたときに、ディスパッチ前に発行されたドローの結果が見えることを保証します。

同様に、Metalは、次のドローまたはディスパッチが実行されたときに各ディスパッチの結果が表示されることを保証します。

この同期保証は、タイルメモリへのレースフリーアクセスを可能にします。

しかし、引き分けの間にはそのような保証はありません。

タイルシェーディングのもう1つの重要な概念は、スレッドがスレッドグループとグリッドにどのように編成されるかです。

従来のコンピューティングディスパッチでは、スレッドグループはぎっしり詰まったグリッドに編成されます。

ただし、レンダリングパス内では、タイルグリッドはパス全体で一定ですが、スレッドグループのサイズはディスパッチごとに異なる場合があります。

タイルを拡大すると、各スレッドを一意のピクセルにマッピングしたり、各スレッドを複数のピクセルにマッピングしたりできることがわかります。

しかし、スレッドからリソースへのマッピングは、Metalにとって特別な意味はありません。

以前に説明したライトカリングの例の場合のように、ピクセルへのマッピングがまったくないスレッドを起動できます。

その例では、スレッドグループのサイズは、交差点テストが必要なライトの数と一致する可能性があります。

タイルシェーディングスレッドグループは、存在するジオメトリに関係なく、タイルごとに起動されます。

たとえば、タイルのサブセットに影響を与える三角形は、それらのタイルによってのみ処理する必要があります。

ただし、その後のタイルディスパッチは、画面のすべてのタイルによって処理されます。

そのディスパッチは、それらのタイルに着地できる後のジオメトリのタイルメモリを初期化している可能性があるため、そうすることは重要です。

ビューポートとシザー状態は、タイルのシェーディングも制限しません。

一般に、タイルシェーディングは従来のレンダリング状態の影響を受けません。

さて、タイルシェーディングをサポートするAPIの変更に目を向けましょう。

レンダリングパスは、イメージブロックの寸法を決定する3つのタイルサイズのいずれかで設定できます。

ほとんどの場合、A11 GPUで32KBであるイメージブロックに適合する最大のタイルサイズを選択して、GPUのプリミティブ処理段階のオーバーヘッドを最小限に抑えます。

ただし、一部のアルゴリズムは、シェーダーコアのタイル並列性の量を増やすために、フラグメントまたはタイル処理が特に複雑な場合に、より小さなタイルサイズを選択することで恩恵を受ける場合があります。

すでに見たように、スレッドグループメモリもタイルメモリから供給されるため、サイズによってタイルサイズの選択が制限される可能性があります。

タイルシェーディングパイプラインの作成は、従来のパイプラインの作成に似ています。

パイプライン記述子に関数をアタッチして、パイプライン状態を作成します。

タイルシェーディングのために、Metalは新しいパイプライン記述子タイプを導入します。

既存のレンダリングパイプライン記述子に似ていますが、ブレンドなどのレンダリング状態プロパティを削除します。

また、バインドできる関数は1つしかないため、既存の計算パイプライン記述子にも似ています。

ただし、その関数は、計算カーネルまたはフラグメント関数のいずれかです。

計算カーネルは、これまでに説明したすべてのタイルシェーディングとイメージブロック機能へのアクセスを提供します。

フラグメントベースのタイルシェーディングはより限られていますが、後で説明する具体的で重要な役割を果たします。

まず、タイルパイプラインのイメージブロック機能に触れたいと思います。

タイルシェーディングはレンダリングとインラインで計算ディスパッチを実行するため、フラグメント関数と同様に、暗黙の画像ブロックと明示的な画像ブロックの両方にアクセスできます。

ただし、フラグメント関数とは異なり、カーネルベースのタイルシェーダーはイメージブロック全体にアクセスできます。

構文を見てみましょう。 

2番目のテンプレート引数を使用して、テンプレート化されたイメージブロックタイプの暗黙的な形式と明示的な形式を曖昧にします。

それぞれが異なるアクセスセマンティクスを持っているため、曖昧さを解消する必要があります。

暗黙の形式には値のセマンティクスがあります。つまり、画像ブロックのインと外にピクセルをコピーします。

明示的な形式には、前回のプレゼンテーションで説明した参照セマンティクスがあります。

レンダリングパス内のイメージブロックがタイルの存続期間中どのように持続するか、そしてこれを活用してドローとディスパッチ間で通信する方法をすでに見てきました。

冒頭の例では、スレッドグループメモリにも同じことが当てはまることにも言及しました。

永続的なスレッドグループメモリは、タイルシェーディングに固有であり、淘汰されたライトリストなど、タイル全体に一定のデータを格納するのに適しています。

これをシェーディング言語でどのように活用するかを見てみましょう。

この例では、カーネルベースのタイル関数は、そのタイル境界に対して淘汰するための完全なライトリストが提供されています。

また、以前のタイルディスパッチからのタイルの最小深さと最大深さも与えられています。

次に、淘汰された結果をスレッドグループメモリに配置し、後のフラグメントシェーダーがアクセスできるようにします。

タイルディスパッチとフラグメント描画の両方が、スレッドグループバインドポイントに一致する必要があります。

最後に、フラグメントベースのタイルパイプラインが果たす役割を考えてみましょう。

タイルシェーディングは、以前は複数のパスだったものをマージすることで、タイルメモリを活用することを奨励します。

タイルメモリは貴重なリソースであるため、より多くのデータをそのスペースにパックするには、明示的な画像ブロックが必要です。

しかし、パス全体の静的タイルメモリレイアウトはまだ適合しそうにないため、計算のさまざまな段階を移動する際に、タイルメモリレイアウトを柔軟に移行する必要があります。

フラグメントベースのタイルパイプラインは、この移行を可能にします。

先に説明したバリアセマンティクスは、移行が始まる前にすべてのタイルメモリアクセスが完了していることを保証します。

また、フラグメントシェーダーはイメージブロックとの間でデータをコピーするため、各ピクセルがアトミックに遷移されるようにすることができます。

例を見てみましょう。 例を見てみましょう。

この例では、遅延レンダリングフェーズを終了し、マルチレイヤーアルファブレンディングと呼ばれるおおよその順序に依存しない透明度技術を実装するためにイメージブロックを再構成したいと考えています。

古いレイアウトを入力として受け取り、新しいレイアウトを返すフラグメントベースのタイル関数を使用します。

また、よくあることですが、古いレイアウトのデータを使用して新しいレイアウトを初期化する必要があることがよくあります。

ここでは、繰延レンダリングフェーズから最終的な点灯値を持ち込みます。

タイルのシェーディングをよりよく理解するために、サンプルコードを必ず確認してください。

これは、1回のパスで多くのライトで効率的にシェードを前進させる方法を示しています。

タイルシェーディングは、タイルに影響を与えないライトを淘汰するために使用されます。

最後に、XcodeのGPUデバッガを使用すると、シェーダーでの使用方法に基づいてデータをフォーマットすることで、スレッドグループメモリを簡単に検査できます。

XcodeのGPUデバッガでキャプチャした後、バインドされたリソースビューのタイルセクションで各スレッドグループメモリをバッファとして見ることができます。

そこから、バッファビューアを使用して、シェーダーが使用するのと同じ方法でフォーマットされたデータを検査できます。

このプレゼンテーションでは、タイルシェーディングにより、開発者がタイルの内容全体を分析および操作し、ドロー間で通信し、さまざまな計算段階を通じてタイルメモリを再利用する方法を見ました。

まとめると、タイルシェーダーは、A11 GPUのより高い帯域幅と低電力のタイルメモリをよりよく活用するために、開発者が複数のレンダリングとコンピューティングパスをマージすることを可能にします。

メタル2の詳細とサンプルコードへのリンクについては、開発者のウェブサイト（developer.apple.com/metal）をご覧ください。

見てくれてありがとう!