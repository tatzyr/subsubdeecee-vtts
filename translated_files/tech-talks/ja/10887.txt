10887

デビッド・ウェンドランド:皆さん、こんにちは、私はApp Storeの商業技術提唱者であるデビッド・ウェンドランドです。

私は今日、バーチャルでここにいて、チーム全体が取り組んできたことを共有できることに興奮しています。

始める前に、クパチーノを拠点とする同僚に自己紹介をしてもらいたいです。

Manjeet Chawla:こんにちは、私の名前はManjeet Chawlaで、App Storeのテクニカルプログラムマネージャーです。

ジョー・マニ:こんにちは、私はジョーです。

私はApp Storeのプログラムマネージャーです。

David: 今日、私たち3人は「StoreKit 2とApp Store Server APIで顧客をサポートする」というタイトルの3部構成のシリーズを紹介します。

StoreKit 2フレームワークとApp Store Server APIの機能が、アプリ内購入、カスタマーサポート、払い戻しの処理をどのように改善できるかに焦点を当てます。

これらの3つの部分は、アプリとカスタマーエクスペリエンスの強化を計画する際に考慮すべき洞察、アプローチ、および利点を提供することを願っています。

秋の発売の概要と、クライアントからサーバー、サンドボックスまでの新機能から始めて、アプリ内購入に着手します。

そして、これらのアップデートを統合する際に、戦略を立て、ロードマップに優先順位を付けるのに役立ついくつかの実装アプローチについて説明します。

新しいことから始めましょう。 

iOS 15では、スタートに戻り、StoreKit 2でクライアントの実装を簡素化するために、まったく新しく改良されたフレームワークを作成しました。

これにより、デバイス上の機能が改善され、ステータス情報が改善され、トランザクションはセキュリティを強化するためにJWS形式が使用されるようになりました。

さらに、アプリ内で直接顧客により多くのサービスを提供するために、3つのスタンドアロン機能を導入しました。

サーバー側から、バージョン2の起動により、既存のApp Storeサーバー通知を大幅に更新しました。

これにより、サポートされている購入イベントの数が大幅に拡大し、新しいJWS形式も使用されます。

最後に、App Store Server APIで一連の機能をリリースしました。

顧客の購入履歴の取得や、加入者の現在のサブスクリプションステータスの提供など、さまざまな機能をサポートするエンドポイントの配列があります。

他の能力は、私の同僚であるManjeetとJoeがまもなくカバーするさまざまな顧客管理シナリオをカバーしています。

今年の広範なアップデートリストは、StoreKitでのアプリ内購入への継続的な投資を示しています。

全体として、これらはセキュリティを改善し、複雑さを軽減し、SandboxとXcodeでのアプリ内購入のテストを容易にします。

Touch IDやFace IDなどの機能を備えたプラットフォームを見ると、安全なバイオメトリクスと摩擦のない認証を使用して、顧客が15億台以上のデバイスで安全かつ便利に購入できるようにします。

App Storeには現在、40以上の言語で175の店舗で毎週6億人の訪問者がいます。

地域ごとに価格帯を調整でき、来年はサポートされている価格帯の数を500以上に拡大し、より多くの価格オプションを提供し、通貨と市場ごとにカスタマイズされた価格ポイントを提供します。

195の支払い方法で45の通貨がサポートされているため、お客様が好みの支払い方法とそれらを積み重ねる機能をより便利にするために取り組んでいます。

これらのプラットフォームの改善を続けていますが、StoreKit 2を掘り下げて、オリジナルのStoreKitよりもその利点と重要な機能強化を強調したいと思います。

StoreKit 2の主な機能を見ると、すべての顧客のデバイスで新しいアプリ内購入トランザクションを自動的に同期します。

これにより、アプリで一貫性のある信頼性の高いエクスペリエンスを提供できます。

このフレームワークは、デバイス上の購入検証をサポートし、以前のフレームワークと比較して合理化されているため、サーバーサイドの購入検証に完全に依存する必要はありません。

すべてのトランザクションはJWSを使用して署名されるため、各トランザクションの真正性を確認できます。

また、このフレームワークは、デバイス上でエンタイトルメントステータス情報を提供するため、複雑さが軽減され、適切なエンタイトルメントアクセスを確保できます。

そして、iOS 15の新機能はappAccountTokenで、購入を開始したアプリ内アカウントを設定し、完了したトランザクションで返品することができます。

さらに、オリジナルのStoreKitフレームワークと一緒に動作できるユニークなスタンドアロンのStoreKit 2機能がいくつかあります。

したがって、iOS 15でオリジナルのStoreKitを使用している今日のアプリは、これらの独立したStoreKit 2機能を追加して、通常はアプリの外で発生するアプリ内体験を提供することもできます。

1つ目はshowManageSubscriptionsです。

これにより、加入者はアプリを離れることなくサブスクリプションを管理できます。

次に、RefundRequestを開始し、アプリ内から払い戻しリクエストを開始できる顧客に取引を提示することができます。

そして、これにより、サンドボックスでは、保留中から承認または拒否への払い戻しをテストしてシミュレートすることができます。

また、顧客の入門オファーの適格性を簡単に確認できるようにする機能も導入しました。

無料トライアルのようなオファーをマーチャンダイジングする際に、購入が完了すると、実際にオファーが与えられることを保証したいので、これは重要です。

StoreKit 2では、このチェックはisEligibleForIntroOfferメソッドですばやく実行でき、サブスクリプショングループIDを渡すことができます。

これは、そのサブスクリプショングループ内のサブスクリプションに対して何らかの種類の入門オファーを消費したことがあるかどうかをチェックします。

さらに、StoreKitによって返品された場合にのみ、入門オファーをマーチャンダイジングする必要があります。

それはProduct.SubscriptionOfferから来ており、可能であれば紹介オファーの詳細を返します。

そうでない場合は、StoreKitによって返却されないため、利用できないオファーをマーチャンダイジングできなくなります。

したがって、これはハードコードされていないことが重要であり、代わりに、アプリはApp Store Connectで設定された開始日と終了日を使用するStoreKitを活用します。

今、私はサーバー側を移動し、顧客との相互作用なしにサーバーからサーバーへのリクエストが行われるApp Store Server APIの機能について議論したいと思います。

サブスクリプションのステータスから始めます。

これは、アプリでの顧客のサブスクリプションの状態を提供します。

また、複数のサブスクリプションサービスがある場合は、サブスクリプションごとに資格状態があり、それぞれが一意の元のトランザクションIDで表されます。

サブスクリプションステータスの大部分は、各サブスクリプションの現在のJWS署名トランザクションのみを返すため、サーバー上のロジックが顧客のトランザクション履歴を解析し、現在のトランザクションまたはどの製品に資格を与えるかを判断する必要はありません。

マルチプラットフォームサービスプロバイダーの場合、このサービスを使用して、アプリを実行せずに、サーバーからサーバー間でいつでも現在のステータスを取得できます。必要なのは、顧客の元のトランザクションIDだけです。アプリの領収書はもうありません。

推奨するベストプラクティスをいくつか紹介します。

購入またはトランザクションを復元するたびに、常に一意の元のトランザクションIDをデータベースに保存することが重要です。

この値は、最初の購入から更新、請求の問題と回復、またはアップグレードとダウングレードまでのサブスクリプションライフサイクルを追跡するために不可欠な各サブスクリプションの提供を表します。

このIDは、サーバー通知とともに、クライアントとサーバーAPIで使用されます。

最後に、サブスクリプションステータスは、セキュリティのベストプラクティスとしてサーバーからサーバーへのみ使用する必要があります。

アプリから直接ステータスを確認する必要がある場合は、StoreKit 2フレームワークに解決策があります。

サーバーAPIの次の機能は、アプリ内購入履歴です。ここでは、サーバー間、顧客の取引の完全かつ最新の履歴を取得できます。

履歴には、すべての非消耗品、非更新サブスクリプション、自動更新サブスクリプション、および未完成の消耗品購入が含まれ、すべてが安全で、JWSが署名したトランザクションになります。

現在、トランザクションの履歴とすべての元のトランザクションIDを持つことは、払い戻し要求を開始するために顧客が選択できるトランザクションを表面化する必要があるため、beginRefundRequest APIを実装する際に役立ちます。

元のStoreKitを使用したアプリでの非サブスクリプションアプリ内購入の場合、verifyReceiptから離れ、このAPIを使用して成功した購入を検証したり、停止が発生した場合に更新を確認したりできます。

ベストプラクティスとして、一部の顧客は多くの購入を行う可能性があるため、応答には一度に最大20件のトランザクションが含まれます。

追加のトランザクションがある場合は、必ずhasMoreフィールドを使用してください。

Trueの場合、その応答とその後のリクエストでリビジョントークンを使用して、トランザクションの次のページを取得します。

hasMoreフィールドがfalseを返すまで繰り返し、将来のためにそのリビジョントークンを保存します。

これにより、記録されたリビジョントークンを使用して顧客の最新のトランザクションをすばやく取得し、再びページ分割する必要はありません。

もう1つの重要なベストプラクティスは、製品やサービスが配信された後にfinishTransactionを使用することです。

未完成の取引はキューに残り、アプリが顧客に配信する必要がある購入を追跡するのに役立ちます。

これは、デバイス上で中断があった場合に重要です。

返金または取り消された取引に関する最終的な推奨事項は、これらの更新を可能な限り迅速かつ効率的に受信したい場合は、バージョン2のサーバー通知を見ることです。

これらは、当社のAPIをポーリングするよりもはるかに効率的です。

では、サーバーの通知を見てください。

これらは、主要な購入イベントとステータスの変更のために、ほぼリアルタイムでサーバーに直接送信されます。

今年は、バージョン2でこの機能を劇的に洗練し、より効果的で使いやすく、より粒度を提供します。

サポートされているイベントの数を2倍にし、その合計を28のユニークなイベントにしました!

バージョン2では、イベントごとに1つの通知のみを送信するため、受信時に特定のアクションを実行できます。

また、これらの通知は、アプリ内購入のためにファミリー共有を通じてアクセスできる家族にも適用されます。

また、通知の配信に失敗した場合は、停電を考慮して、7日間で最大5回再試行します。

そしてもちろん、バージョン2はサンドボックスで利用できるので、テスト環境で安全に開発できます。

いくつかのベストプラクティスでは、これらの通知を受信するときは、正常に受信されたときにHTTP 200応答コードで応答することが重要です。

これは、お客様が通知を受け取り、再送信する必要がないことを示しています。

サーバーがエラーを返したり、応答しない場合、App Storeは同じ通知ペイロードを再送信します。

各通知にはsignedDateがあります。元の通知がいつ送信されたかを正確に知ることができます。

また、JWSが署名したトランザクション情報を使用して、受信した通知の真正性を検証できるため、これらがApp Storeによって署名されたことを確信できます。

また、サンドボックスや本番イベントに一意のサーバーURLを提供する新しい機能を活用してください。

そして、最終的なベストプラクティスとして、通知の更新をすぐに適用します。

一部のイベントは、アップグレードや払い戻しなど、時間に敏感です。

したがって、これらをほぼリアルタイムで処理することは有益です。

そして、あなたに説明する最後のアップデートは、サンドボックスでのアプリ内購入のテストに役立つApp Store Connectのアップデートです。

これらの機能は、サンドボックステスターの下の[ユーザーとアクセス]タブでアクセスできます。

すでにご存知かもしれませんが、今日のサンドボックスでは、サブスクリプションはテストをサポートするために加速された速度で更新されます。

これで、XcodeでのStoreKitテストと同じように、Sandbox Apple IDごとに更新率を遅くまたは加速する機能を追加しました。

これは、更新の間にアクションを実行するためにより多くの時間が必要なシナリオに役立つはずです。

さまざまなストアフロントでのテストを支援するために、いつでもSandbox Apple IDのストアフロントを変更できるようになりました。

また、単一のサンドボックスApple IDの使用をさらに拡大するために、自動更新サブスクリプションと非消耗品の購入履歴を消去できるようになりました。たとえば、コンテンツを購入したり、紹介オファーを繰り返し引き換えたりすることができます。

StoreKit 2とサーバーAPIの利点とベストプラクティスのいくつかを取り上げたので、これらの機能と能力をアプリやサーバーに統合する準備をする際に考慮すべきいくつかのアプローチを確認しましょう。

アプリ内購入について考えるとき、私たちは主に顧客に購入の資格を付与し、ステータスの変更を処理することを考えます。

これを行うには、サーバーバックエンドなしですべてをローカルで行うオンデバイスアプローチを選択するか、サーバーが真実の源であるサーブツーサーバーAPIを活用するかを選択する必要があります。

デバイス上から始めましょう。

これは、StoreKit 2フレームワークがアプリにアプリ内購入を完全に管理し、サーバーを必要とせずにデバイス上のすべてのステータス変更機能を提供する場所です。

これは、中小企業や既存のサーバーバックエンドを持たない企業にとって非常に役立ちます。

これを行うには、購入フローをサポートするために、StoreKit 2のこれら3つのコア機能部分から始めます。

アプリは、製品を使用して利用可能な製品とその詳細を取得し、アプリ内のマーチャンダイジングを推進します。

これにより、常に正確で、App Storeと同期しています。

そして今、StoreKit 2では、VerificationResultとPurchaseResultがあり、これらは一緒に購入または復元されたトランザクションが成功した後にトランザクションの真正性を検証するために使用されます。

StoreKit 2フレームワークのもう1つの重要な利点は、あらゆるトランザクションでアプリを最新の状態に保つことができることです。

顧客は複数のデバイスを持っている可能性があり、Transaction.updatesを使用すると、トランザクションが開始されたデバイスに関係なく、アプリは同期されます。

currentEntitlementメソッドを使用すると、アプリは顧客の購入の即時ステータスをすばやく取得できるため、最新のトランザクションの詳細を持っているので、ログインやリストア購入の実行を必要とせずに、それらの製品を顧客にすぐに付与できます。

最後に、製品自体だけでなく、現在の加入者のステータスと今後の更新期間について、デバイス上で自動更新サブスクリプション情報を取得することがいかに重要であるかを理解しています。

そのために、Product.SubscriptionInfoがあります。

したがって、先ほど説明したこれらの6つのコア機能を使用すると、iOS 15のStoreKit 2を活用し、サーバーへの依存度を削減または排除して、最高の顧客体験を提供できます。

さて、サーバー間アーキテクチャについて考えるとき、これは顧客がサービスに確実にアクセスすることを期待するマルチプラットフォームまたはマルチアプリサービスにとって重要であり、システムはいつでもリアルタイムで購入状況を最新の状態に保つ必要があります。

通常、この設定では、サーバーを真実のソースとして、24時間365日オンラインで、いつでもApp Storeで更新を受信して確認できます。

しかし、あなたのアプリの観点からこの流れを見てみましょう。

ここでは、お客様のデバイスがあり、アプリが元のStoreKitフレームワークを使用して購入を開始し、購入検証にApp Store verifyReceiptサーバーを使用して実行されていると仮定しましょう。

これは、購入または復元イベント後に、アプリがBase64でエンコードされたアプリレシートをサーバーに送信し、verifyReceiptサーバーに送信されることを意味します。

App Storeは顧客のトランザクションで応答します。現在、サーバーはこれらのトランザクションを解析して、ステータスと、サーバー側またはアプリ内でどのようなアクションを実行する必要があるかを評価および決定する必要があります。

さて、あなたは自分自身にこの質問をしたかもしれません。

良いニュースは、App Store Server APIは、StoreKit 2フレームワーク全体を採用するアプリに依存していません。

これは、アプリがオリジナルのStoreKitを使用し続けている間、App Store Server APIで利用可能な新機能をすぐに利用できることを意味します。

これを行う方法を見ていきましょう。

同じデザインでは、2つの主要な変更を加える必要があります。

まず、元のトランザクションIDを取得するためにアプリを更新します。

次に、App Store Server APIを使用するようにサーバーを更新します。

これら2つの変更により、アプリはオリジナルのStoreKitまたはStoreKit 2を使用できるため、どのiOSバージョンでも最新のアプリバージョンを簡単にサポートできます。

最初の変更を行い、今後original_transaction_IDの使用を開始するには、Base64アプリのレシートを取得するロジックを置き換えます。

これを行うには、アプリのレシートURLメソッドを使用していた可能性があります。

さあ、自動更新サブスクリプションのためにこのプロパティに置き換えてください。

また、他のアプリ内購入タイプでは、この同様のプロパティを使用します。

それでは、App Store Server APIを使用するようにサーバーを更新しましょう。

/verifyReceiptから/Historyまたは/SubscriptionStatus URLに変更します。

リクエストは承認にJWTを使用し、今後は元のトランザクションIDを使用します。

これらの変更が完了すると、サーバーで維持するエンタイトルメントロジックがなくなり、安全なJWS署名付きトランザクションを使用でき、アプリの領収書を保存する必要がなくなりました。

したがって、アプリが古いバージョンのiOSをサポートしている場合、これはApp Store Server APIが提供するものを利用するためのパスを提供します。

先ほど、StoreKit 2とサーバーAPIがサブスクリプション状態の決定をどのように処理するかについて言及しました。

ベストプラクティスとして、アプリは常にアプリの起動時に加入者の状態を決定する必要があります。

状態が決まったら、ローカルに保存し、必要に応じて更新できます。

私たちが返すこれらの5つの州と、それぞれについて取るべき行動と、検討する機会を簡単に検討したいと思います。

さて、新しい顧客はこれらの状態のいずれかを持っていないことに留意すべきであり、それはあなたのアプリも管理する必要がある状態です。

アクティブ状態から始めて、これは、有効期限まで顧客にサービスを提供する必要があることを意味します。

複数のレベルのサービスを提供する場合、1つの機会は、プロモーションオファーを使用してアプリ内でアップグレードオファーを表示することです。

このようなオファーは、過去のサブスクリプション履歴に基づいて顧客に合わせて調整する必要があることに注意してください。

これで、サブスクリプションが完全に解約されると、期限切れの状態になります。

サービスを提供する必要はなく、現在のサブスクリプションの提供を商品化することができます。

オプションで、プロモーションオファーまたはサブスクリプションオファーコードを活用して、ウィンバックオファーを提示することができます。

有効期限から60日以内に再購読した場合、既存の未払いの有給サービス日数は85%の収益率に向けて再開されます。

次は請求の再試行期間です。

私たちは皆、時々請求の問題を経験します。クレジットカードが期限切れになるか、ストアクレジットが消費される可能性があります。

これらのサブスクリプションは自動更新されると予想されていましたが、支払い方法の問題により、請求再試行期間と呼ばれるものに陥りました。

サブスクリプションの有効期限が切れており、サービスを提供する必要はありませんが、お客様は再購読する必要はありません。請求の問題を解決するだけです。

開発者のアクションなしで、さまざまな顧客コミュニケーションを通じて、最大60日間のサブスクリプションの再試行と回復を自動的に再試行します。

しかし、アプリ内メッセージングを使用すると、顧客に請求の問題を直接警告し、顧客を支払い情報ページに深くリンクして解決できる貴重な行動を促すことができます。

次は猶予期間で、請求の再試行に関連していますが、App Store ConnectでApp Store請求猶予期間をオプトインした場合にのみ、購読者に適用されます。

この州では、猶予期間が満了するまで、中断することなくサービスを提供し続けます。

猶予期間中に加入者を回復した場合、加入者は元の請求サイクルを保持します。

したがって、サービスの中断はなく、プロバイダーは失われた請求可能な日数を回避します。

請求の再試行と同様に、同じアプリ内メッセージングも提供して、請求の問題を警告したいと考えています。

最後に、取り消された状態が表示された場合、これは家族で共有可能なサブスクリプションに適用されます。

これらの家族はもはやそのサービスやコンテンツを受ける権利がないため、アクセスを取り消すことができ、これらの顧客を再獲得するためのオファーを商品化することができます。

最後の部分では、App Storeサーバー通知を使用する際に考慮すべきいくつかの実装アプローチについて掘り下げたいと思います。

サポートされているこれらすべてのイベントを見ると、かなりの数があり、あなたのビジネスに適用される場合と適用されない場合があることがわかります。

多くはサブスクリプションライフサイクルの一部ですが、他のものはすべてのアプリ内購入タイプに適用されます。

サブスクリプションを提供していない場合は、サブスクリプションがより複雑であり、単に適用されないイベントの多くを回避できるため、実装アプローチはより簡単です。

しかし、あなたが検討するために、実装のこれらの異なる段階を見直しましょう。

私たちはそれを3つに分割しました：始めること、ライフサイクルをサポートすること、そして洞察に基づいて行動を起こすこと。

バージョン2を採用する場合、この開始段階は、ビジネスモデルに関係なく、またはバージョン1の通知を採用しているかどうかにかかわらず、すべての人に適用されます。

最初のステップは、App Store Connectでバージョン2を有効にすることです。

この機能は「App Store Server Notifications」というタイトルのApp Informationの下にあります。

そして、秋のアップデートでは、サンドボックスとプロダクション専用のURLを選択できるようになりました。

そのURLを追加して、受信するバージョンを選択できます。

また、すでにバージョン1を受け取っている場合は、本番環境で有効にする前に開発を可能にするために、サンドボックスでバージョン2のみを有効にすることをお勧めします。

バージョン2を有効にしたので、優先順位付けを見たいので、ビジネスモデルと使用状況に基づいて、最初にサポートする通知を評価します。

助けるために、あなたのビジネスとロードマップに最も当てはまる重要な大量のイベントに焦点を当てる必要があります。

すべてのアプリ内購入タイプに適用されるイベントの1つは、払い戻しです。

顧客に返金される取引ごとに、単一の払い戻し通知が届きます。

これらのイベントをどのように処理するかは、ポリシーとビジネスモデル次第です。

現在、サブスクリプションベースのビジネスの場合、これらの4つの通知は、最初の購入または再購読から更新の成功、または失敗、有効期限まで、サブスクリプションジャーニーの主要なイベントに適用されます。

これら5つの通知タイプに対して行動を起こすことを優先することで、受信できるイベントの大部分をサポートできることを意味します。

その第1段階は強固な基盤を提供し、リターンを最大化することができました。

これで、この次の段階ですべての通知タイプのサポートを完了することができます。

サブスクリプションベースの通知はいくつか残っていますが、他の通知は機能の採用に依存しています。

復習しましょう。

これら2つのタイプは、すべてのサブスクリプションベースのアプリ、DID_CHANGE_RENEWAL_STATUSとreferenceに適用されます。

これらは、サービスレベルをキャンセルまたは変更する顧客を特定するために重要です。

これらの残りのタイプを考慮すると、これらはあなたの使用状況に依存します。

したがって、App Store Connectで請求猶予期間を有効にしている場合は、GRACE_PERIOD_EXPIREDが適用されます。

RENEWAL_EXTENDEDは、App Store Server APIで加入者の更新を延長した場合に送信されます。

また、アプリ内購入でファミリー共有が有効になっている場合、REVOKEが適用されます。

OFFER REDEEMEDは、サブスクリプションオファーコードまたはプロモーションオファーを使用する場合に適用されます。

また、自動更新サブスクリプションの価格が引き上げられた場合、PRICE_INCREASEが送信されます。

そして、REFUND_DECLINEDとCONSUMPTION_REQUESTがあります。

ジョーは、払い戻しの処理に関する彼の部分でこれらを詳細にカバーします。

最後に、洞察フェーズのアクションに進むことができます。

この時点で、あなたは今、あなたのビジネスに関連するすべてのイベントを受け取り、行動を起こしています。

これにより、サービスがすべての顧客サブスクリプションの現在のステータス、または購入した消耗品、非消耗品、または非更新サブスクリプションへのアクセス変更を確実に知ることができます。

サブスクリプションでは、次の通知は非常に特定の状態の顧客を識別し、ビジネスが特定の積極的な行動を取ることができ、加入者を特定し、インテリジェントに関与し、維持し、取り戻すことができます。

ここでは、顧客と関わる機会のウィンドウで重要なイベントを特定したり、プロアクティブなアプリ内メッセージングを提供したり、カスタマイズされたサブスクリプションオファーを提示したりできる通知タイプの例をいくつか紹介します。

1つの例を見てみましょう。サブスクリプションをキャンセルする顧客です。

このシナリオでは、加入者が11月25日に毎月のサブスクリプションを購入したとしましょう。

その後、12月5日、加入者は現在の期間の残り20日でキャンセルすることを選択しました。

これは、加入者がキャンセルしてから、サブスクリプションが期限切れになり、自発的に解約されるまでの保存期間です。

そのキャンセルアクションが発生すると、自動更新状態はfalseに設定され、すぐにApp StoreがAUTO_RENEW_DISABLEDのサブタイプでDID_CHANGE_RENEWAL_STATUS通知を送信し、保存期間の開始をリアルタイムで警告します。

この機会の窓により、サービスは期限が切れる前にカスタマイズされたアプリ内メッセージングや商品保存オファーを提示することができます。

このようなオファーが調整され、各顧客コホートの適格基準を持つことが重要です。

これで私の部分が終わります。

では、同僚のマンジートを紹介したいと思います。

マンジート:ありがとう、デイブ!私の名前はManjeet Chawlaで、App Storeのテクニカルプログラムマネージャーです。

さて、Daveは、StoreKit 2とApp Store Server APIを使用してアプリ内購入を改善する方法について話しました。

では、カスタマーサポートの観点からまったく同じAPIを確認しましょう。

顧客がアプリ内購入で今日直面する一般的なサポートシナリオと、これらのAPIをこれらのシナリオに活用するためのベストプラクティスについて話します。

しかし、カスタマーサポートについて話す前に、サポートを提供することが全体的な顧客管理にどのように影響するかを理解しましょう。

買収、分析、カスタマーサポート、さまざまなマーケティングコミュニケーションチャネルなど、さまざまなCRMツールやシステムに依存している可能性があります。

また、サポートを提供することで、顧客を満足させ、製品とエンゲージメントを維持し、全体的な顧客関係と満足度を向上させます。

今、私たちは顧客があなたに助けを求めていることを知っており、App Storeはサポートを提供し、問題を効率的に解決するためのツールを作成しました。

そして今日は、検索注文IDから始めて、すべてのサポートチャネルでの問い合わせを支援する5つの新しいカスタマーサポートツールについて説明します。

今日、顧客がアプリ内購入を行うと、Apple IDに領収書が送信され、アカウント設定での購入履歴を見ることで、いつでもこの領収書にアクセスすることもできます。

そして今、顧客があなたに連絡すると、サポートチームはこの領収書の注文IDを顧客に尋ね、新しいApp Store Server APIを呼び出すために、注文IDを使用してその領収書の顧客のアプリ内購入を検索することができます。

また、このAPIを使用して、領収書の真正性を検証し、その領収書内のトランザクションを顧客に関連付けることもできます。

さらに、このAPIを使用して、購入内の問題を特定できます。

たとえば、トランザクションにApp Storeによってすでに返金または取り消された購入が含まれている場合は、応答でrevocationDateとrevocationReasonを見て、払い戻しの詳細を得ることができます。

そして、このAPIを実装すると、顧客がサポートのためにあなたに連絡したときに、注文IDの過去の購入を検索することができます。

ベストプラクティスについては、すべてのアプリ内購入のoriginal_transaction_idを顧客アカウントデータベースに保存してください。

また、顧客がサポートを求める連絡をすると、このAPIを使用して、アカウントデータベース内で顧客の購入を検索して関連付けることができます。

このAPIを電話、電子メール、ウェブなどの既存のカスタマーサポートチャネルと統合して、顧客に一貫したサポート体験を提供することもできます。

次に、払い戻しの検索について話しましょう。

WWDC20では、App Storeは、顧客がアプリ内購入の払い戻しに成功したたびにサーバーに通知する払い戻し通知を導入しました。

払い戻し検索は、顧客の返金されたすべての取引を検索できる、まったく新しいApp Store Server APIです。

このAPIを使用すると、いつでも迅速かつ簡単に払い戻しを調べることで、サーバーの停止を処理したり、メンテナンスをスケジュールしたりできます。

さらに、すべてのアプリ内購入タイプで、顧客の払い戻し履歴全体を特定できます。

また、このAPIを使用して、払い戻しや疑わしい活動の急増を監視し、払い戻しにつながる可能性のあるコンテンツ配信の問題に対応することもできます。

ベストプラクティスとして、各アプリ内購入のoriginal_transaction_idを顧客アカウントデータベースに保存している場合は、元の_transaction_idのいずれかを使用して過去の払い戻しを検索できます。

また、払い戻し検索APIを使用して、払い戻しにつながる可能性のある顧客のコンテンツ配信の問題をトラブルシューティングできます。

それでは、自動更新サブスクリプションについて具体的に話すためにギアをシフトしましょう。

たとえば、停止やイベントがキャンセルされたシナリオは、スポーツ、ライブテレビ、ビデオなどのストリーミングベースのアプリでより一般的かもしれません。

これらの停止やキャンセルされたイベントのために、どのように顧客をなだめることができますか?

新しいRenewal Extension Server APIを使用して、有料のアクティブサブスクリプションの更新日を延長し、顧客にさらに時間無料サービスを提供できるようになりました。

このAPIを使用して、一時的な停止を処理し、柔軟な対応を提供できます。たとえば、顧客がサービスで悪い経験をした場合などです。

実際のサブスクリプション期間に関係なく、顧客のサブスクリプションの更新日を1年以内に2回、毎回最大90日間延長できることに注意してください。

また、この延長期間は、85%の収益率を受け取るために必要な1年間の有料サービスにはカウントされません。

ベストプラクティスについては、original_transaction_idを保存して、更新日を延長するサブスクリプションを特定します。

ビジネスモデルに最適な延長期間を特定し、顧客のサブスクリプションを延長するときにアプリ内メッセージを表示します。

また、顧客1人あたり1年に2回しか延長できないため、延長の対象となる顧客の資格基準を維持したいと思うかもしれません。

また、常にビジネスチームやマーケティングチームと連携して、すべてのコミュニケーションチャネルで一貫したメッセージングを提供します。

それでは、サブスクリプションに1回限りの割引を提供することで、顧客に補償したい別のシナリオについて話し合いましょう。

iOS 14では、App Storeは、期間限定で割引または無料でサブスクリプションを提供することで、購読者を獲得し、維持し、獲得するのに役立つサブスクリプションオファーコードを導入しました。

オンラインまたはオフラインのチャネルを使用して、これらの1回限りの一意のコードを配布できます。

また、顧客サービスの問題については、サービス問題の補償としてこれらのワンタイムコードを提供できます。

また、これを代替サブスクリプションオプションを提案する機会として使用することもできます。たとえば、低価格でより多くの価値を提供するより長い期間のプランです。

iOS 14およびiPadOS 14以降のお客様は、1回限りのコード引き換えURLを介してApp Storeで、またはStoreKitにpresentCodeRedemptionSheet APIを実装している場合はアプリ内でオファーコードを引き換えることができます。

さて、ベストプラクティスとして、顧客が情報に基づいた決定を下すのを助けるために、カスタマイズされたアプリ内メッセージングとオファーコードの説明とともに、顧客がコードを引き換えるためのアプリ内の償還フローを提供します。

また、電話、電子メール、ウェブなどの既存のカスタマーサポートチャネル内、または顧客がライブチャットセッションでサポートチームとチャットしている場合など、アプリ内でもこれを使用します。

現在、電子メールなどのデジタルマーケティングチャネルでこれらのコードを配布する場合、各コードには、コードが事前に入力された関連する償還URLがあります。

一意のURLを使用して、電子メールからApp Storeで発生する償還フローに顧客をシームレスにディープリンクすることができます。

このURLは2つの値で構成されています。IDは、アプリケーションのIDを表すため、アプリケーションごとに静的になります。2番目の値はコードで、加入者の一意の英数字値をURLに動的に入力します。

さて、そのURLが電子メールに埋め込まれている場合、タップすると、ユーザーはApp Storeに移動してトランザクションを完了します。

注意すべき点：ここの加入者は、このフロー中にコードを見ることはなく、完了すると、顧客がアプリケーションを再度起動したときにアプリが実行する必要がある別の外部トランザクションになります。

次に、顧客がサブスクリプションを管理したいシナリオを取り上げましょう。

StoreKit 2では、既存の管理サブスクリプションをアプリ内に表示できる新しい管理サブスクリプションAPIを立ち上げました。

アプリ内でサブスクリプション管理をサポートすることは、顧客がアプリを離れることなくサブスクリプションをアップグレード、ダウングレード、またはキャンセルできることを意味します。

これはまた、一般的な加入者の問題に助けを提供し、顧客が検討するための代替オファーを提示する自然な場所を提供します。

また、この機会を利用して、サブスクリプションの管理ページが表示される前に、パーソナライズされた保存オファーを提示することができます。たとえば、エンゲージメントが低い場合などです。

または、キャンセルする場合は、出口調査を提示して、キャンセルの詳細を入手することもできます。

さて、ベストプラクティスです。

StoreKit APIを使用すると、アプリを離れることなくサブスクリプションを管理またはキャンセルするのに役立つ一貫したエクスペリエンスを提示できます。

システムが提供する管理UIを補完するために、ブランドのコンテキストエクスペリエンスを作成することを検討してください。

たとえば、顧客の好みや使用状況に基づいて、パーソナライズされた提案や代替プランを提供するために、人気のあるプレミアム層を提供することができます。

そして、すべての異なるチャネルにわたるカスタマーサポートジャーニーに関連して、全体的なサブスクリプション管理エクスペリエンスを確認します。

では、アプリのサブスクリプション管理UIのサンプルを見てみましょう。

ユーザーがサブスクリプションを管理するため。

そして、顧客がこのボタンをタップすると、App Storeには、現在アクティブなサブスクリプションと更新オプションを含む既存のサブスクリプション管理ページが表示されます。

これは、お客様がApp Storeの[アカウント設定]で[サブスクリプションの管理]にアクセスし、サブスクリプションを表示、アップグレード、ダウングレード、またはキャンセルできるときによく知っているのと同じビューです。

これで、お客様がサブスクリプションをキャンセルすることを選択した場合、キャンセルの詳細とサービスの有効期限が記載された確認画面が表示されます。

また、ユーザーがこのページで実行する可能性のあるアクションについては、App Storeサーバー通知が届き、StoreKit 2フレームワークを実装した場合、アプリに通知されます。

では、今日取り上げた新しいカスタマーサポートツールで、これらのAPIを使用してサポートを提供することの利点について話しましょう。

アプリ内でアプリ内購入のコンテキストとシームレスなサポートを提供することで、全体的な顧客体験を向上させることができます。

これにより、全体的なリテンションが向上し、顧客満足度が向上し、エンゲージメントが向上し、最終的にはアプリの肯定的な評価とレビューが向上します。

さて、同僚のジョーを招待して、払い戻しの処理について話したいと思います。

ジョー：Manjeet、発売された新しいカスタマーサポートツールのベストプラクティスとユースケースを提供してくれてありがとう。

みなさん、こんにちは。私の名前はジョー・マニで、App Storeのプログラムマネージャーです。

払い戻しはデリケートなトピックであり、App Storeは、払い戻しがアプリに与える影響と、これらのツールを活用して顧客体験を向上させる方法を理解するためのツールを作成しました。

これらのツールを使用することの利点を強調し、払い戻しの処理に関する包括的なメッセージを提供したいと思います。

昨年、私たちは払い戻しに影響を与える2つの新しいツールを立ち上げました。

まず、beginRefundRequest APIについて話し合いましょう。

App Storeは問題を報告し、Appleサポートは顧客が払い戻しを要求するためのパスを確立しました。

現在、iOS 15では、App Storeは、顧客がアプリ内購入の払い戻しをリクエストできるように、StoreKit 2フレームワークに新しい beginRefundRequest APIを導入しました。

beginRefundRequest APIを実装するには、複数の利点があります。

聴いている人のほとんどは、アプリ内購入の払い戻しをリクエストした顧客がいます。

新しい beginRefundRequest APIを使用すると、顧客をリダイレクトしたり、アプリ内で支援を提供したりすることなく、同じ機能を提供できます。

アプリ内購入の潜在的な問題を認識している場合は、このAPIを使用して、顧客が問題のトラブルシューティングを行い、より迅速な解決策を得ることができます。

iOS 15では、App Storeは特に2つの追加通知を作成しているので、払い戻しが承認されたか拒否されたかを知ることができます。

払い戻しが承認されると、アプリに通知され、サーバーはApp Storeから払い戻し通知を受け取ります。

払い戻しが拒否された場合、サーバーは新しいREFUND_DECLINED通知を受け取ります。

この機能を使用するには、iOS 15以上を使用する必要があることに注意してください。

ベストプラクティスについて話し合いましょう。

元のトランザクションIDを保存し、ほとんどの払い戻しリクエストは購入後30日以内に発生することに注意してください。

顧客がイライラし、払い戻しを要求する状況がある場合でも、カスタマイズされた顧客体験を作成するカスタムビルドのアプリ内メッセージングを提供できます。

過去の購入に関するコンテキスト情報を顧客に柔軟に表示できます。

顧客が返金するトランザクションを選択すると、顧客が理由コードのリストから選択できる払い戻しリクエストシートを表示するAPIを呼び出すことができます。これは、Appleの「問題を報告する」に表示されるものと一致します。

自動更新サブスクリプションの場合、払い戻しが成功するとサブスクリプションがキャンセルされるため、アプリ内で顧客のエンゲージメントを維持するための保持戦略を特定できます。

beginRefundRequestを見たので、その後に何が起こるか、どのようにもっと関与できるかについて話しましょう。

App Storeは、払い戻しを要求する前にアイテムを消費したかどうかなど、顧客の消耗品のアプリ内購入に関する消費情報をAppleに送信することで、払い戻しプロセスを通知し、改善する機会を提供する新しいサーバーAPIを導入しました。

高レベルでは、各払い戻し要求は、払い戻し決定システムを通過して決定を下します。

払い戻し決定システムには、問題の取引に関する情報や、お客様の購入履歴や払い戻し履歴などのその他の要因が含まれます。

Appleが決定を下す前に、App StoreはサーバーにCONSUMPTION_REQUEST通知を送信します。

サーバーは、この通知に応答して消費データをApp Storeに送り返し、払い戻しの決定に影響を与える可能性があります。

消費ペイロードは一握りのフィールドで構成されており、今日は3つの重要なフィールドについて議論したいと思います。

消費では、アプリ内購入が完全に消費されたのか、部分的に消費されたのか、まったく消費されていないのかを簡単に伝えることができます。

たとえば、アプリに物々交換がある交換プラットフォームがある場合、またはあるアカウントから別のアカウントに転送されたアプリ内がある場合、それは消費されたと見なされます。

コンテンツの配信では、停止を経験したり、アプリ内購入を配信できなかったりする可能性があり、顧客に返金したい場合があります。

今、あなたは単に配達されていないアイテムを提供することができます。

StoreKit 2で起動されるappAccountTokenでは、お客様が作成したアプリのユーザーアカウントに関連付けられた標準のUUID形式を使用しており、購入を開始し、購入用のコンテンツを消費しています。これは、再販業者を特定するのに役立ちます。

ベストプラクティスとして、ほとんどの払い戻し要求は30日以内に行われるため、それに応じて取引の消費データを保存します。

Appleがデータを要求しているトランザクションを見つけることができるように、各消耗品のアプリ内購入の元の_transaction_IDを保存します。

Appleが意思決定のためにあなたのデータを確実に組み込むために、消費要求通知を受け取ってから12時間以内に返信してください。

最初のリクエスト後に何か変更があった場合は、その12時間以内に更新されたペイロードを自由に送信してください。

要求された消費データをApp Storeに送信する前に、顧客の同意を得ていることを確認してください。

そして最後に、消費ペイロード内では、すべてのフィールドは必須ではなく、未申告のフィールドとしてマークできるAppleのドキュメントを確認してください。

今日のセッションを要約すると、重要なアクションのチェックリストを提供したいと思います。

これらの機能を採用して実装するための次のステップでは、App Store ConnectにURLを入力し、Sandboxでバージョン2を有効にすることで、サーバーがApp Storeサーバー通知を受信するための設定と有効化を開始できます。

カスタマーサポートツールについては、電話、電子メール、ウェブ、アプリ内サポートのいずれかで、既存のサポートチャネルに統合します。

アプリでは、新しいbeginRefundRequest、isEligibleforIntroOffer、およびshowManageSubcriptions APIをサポートするために必要なStoreKit 2を使用して、iOS 15のクライアントの変更を特定します。

最後に、ストアフロントの変更、購入履歴の消去、払い戻しのテスト、サブスクリプション更新率の調整など、サンドボックスのテストの更新を最大限に活用するために、サンドボックスのアップデートを活用してください。

これでプレゼンテーションは終わりです。本日はご参加いただき、StoreKit 2とApp Store Server APIでお客様をサポートすることについて詳しく学んでいただき、誠にありがとうございます。