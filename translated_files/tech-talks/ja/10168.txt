10168

こんにちは、私の名前はアリです。カスタムインテントをアプリインテントに移行する方法について話すことに興奮しています。

このビデオでは、新しいApp Intentsフレームワークを採用すべき理由、下位互換性を含む移行の仕組み、実際にApp Intentsに変換する方法について説明します。

まず、アプリインテントを採用すべき理由と、それが以前のフレームワークとどのように異なるかを取り上げましょう。

2016年にSiriKit Intentsフレームワークを導入しました。これには、メッセージング、ワークアウト、電話などの一般的なユースケースに完全なユーザーエクスペリエンスを提供する一連の目的主導のシステムインテントが付属しています。

次に、あらゆるユースケースに対して独自のインテントを定義できるカスタムインテントを導入し、アプリの機能をSiri、ショートカット、および提案にもたらしました。

また、ウィジェットの設定と予測にカスタムインテントを使用するWidgetKitを追加しました。

WWDC22では、アプリからシステムにインテントを提供する新しいSwiftネイティブフレームワークであるApp Intentsを導入しました。

App Intentsは、モダンでパワフルでユーザーにとって簡単であるため、採用するのに最適なフレームワークです。

Swift用にネイティブに設計されているため、モダンです。

最新の言語機能のおかげで、同じ機能をサポートするために劇的に少ないコードを書くことができます。

また、インテント定義ファイルを維持し、コード生成を使用する必要性を排除しました。

また、スニペットを軽量のSwiftUIビューとして提供できるようになりました。

エンティティとクエリにより深いユースケースが可能になったため、強力です。

拡張機能を提供せずに、アプリのプロセスでApp Intentsを直接実行できます。

そして、人々があなたの意図を設定して実行するときに、ユーザーエクスペリエンスをカスタマイズする新しい機会があります。

人々が使うのも簡単です。

意図は、セットアップなしですぐに使用可能なアプリショートカットとして簡単に公開できます。

さらに、Spotlightの上部とアプリに含めることができるSiriのヒントに表示されるため、ショートカットを発見するための新しい方法があります。

新しいフレームワークのすべての利点を得るには、Siri用に構築したカスタムインテントとアプリインテントへのショートカットをアップグレードする必要があります。

SiriKitの意図はまだ完全にサポートされています。

したがって、メッセージングやメディアなどのSiriドメインを構築している場合、またはWidgetKitでインテントを使用している場合は、そのままにしておく必要があります。

App Intentsフレームワークの詳細については、WWDC22のセッション「Dive into App Intents」をご覧ください。

また、SiriやSpotlightからアプリの機能を非常に簡単に使用できるApp Shortcutsの詳細については、「App IntentsでApp Shortcutsを実装する」をチェックしてください。

次に、移行を取り上げましょう。

移行では、Xcodeでワンクリックで既存のインテント定義をアプリインテントに変換できます。

同じアプリバイナリでiOS 15とiOS 16の両方をサポートできます。

また、人々の既存のショートカットを有効にして、新しいアプリインテントで作業を続けることができます。

インテント定義をアプリインテントに変換するには、インテント定義ファイルに移動し、[アプリインテントに変換]ボタンを押すだけです。

Xcodeは、古いインテント定義と同等のApp Intentsコードを生成します。

次に、古いコンテンツハンドラコードをリファクタリングすることで、コードに入力できます。

これについては、次のセクションで詳しく説明します。

アプリがApp Intentsにアップグレードしたときに人々がシームレスな体験をできるように、システムは古い意図から新しい意図へのマッピングを自動的に処理します。

それがどのように機能するかについて話しましょう。

CustomIntentMigratedAppIntentプロトコルを採用するだけで、システムは古いインテントと新しいインテントの間で変換する方法を知るのに十分な情報を持つことになります。

このプロトコルを採用すると、古いカスタムインテントに使用されたクラス名であるインテントクラス名プロパティを提供します。

ほとんどの場合、これを自分で提供する必要はありません。

[App Intentに変換]ボタンを使用すると、結果のコードはすでにこのプロトコルを採用しています。

App Intentの移行機能のため、App IntentsにアップグレードするためにアプリがiOS 16をターゲットにするまで待つ必要はありません。

実際、同じアプリバイナリで新しいオペレーティングシステムと古いオペレーティングシステムの両方を簡単にサポートできます。

これを行うには、レガシーインテントハンドラとアプリインテントの両方をアプリに含めます。

コード共有を最大化するには、両方のインテントハンドラを共通のビジネスロジックのセットに考慮します。

移行されたApp Intentプロトコルを採用すると仮定すると、アプリに両方のセットを含めると、ショートカットは自動的にインテントの重複排除になります。

したがって、iOS 15以前では、ショートカットアプリはレガシーインテントの実装のみを表示します。iOS 16以降では、アプリインテントの実装のみが表示されます。

最小展開ターゲットをiOS 16以降に切り替えると、移行したインテントのレガシーインテントハンドラと定義を安全に削除できます。

それらはもはや必要ありません。

移行時に考えるべきことの1つは、人々があなたの古い意図に依存する既存のショートカットを持っているということです。これは、ショートカットアプリで作成したか、アプリの「Siriに追加」ボタンを使用して追加した可能性があります。

良いニュースは、これらのショートカットは、移行されたApp Intentプロトコルを採用している限り、新しいApp Intentsで動作し続けることです。

人々のショートカットは、新しいアプリインテントを使用するために上書きされません。彼らは自動的に新しいインテントと古いインテントの両方で動作する共通のフォーマットを使用します。

これが機能するためには、レガシーインテントとアプリインテントのスキーマが互換性がある必要があります。

互換性があるためには、カスタムインテントとアプリインテントのパラメータが同じ名前と同等のタイプである必要があります。

スキーマの互換性を壊すことなく行うことができるいくつかの変更があります。

具体的には、パラメータを追加または削除したり、既存のパラメータを非オプションにしたりできます。

Xcodeでスキーマの互換性を確認するには、パラメータのリストがある古いインテント定義ファイルをチェックしてください。

各パラメータには名前と型があります。

インスペクタペインには、インテントのクラス名のフィールドもあります。

App Intentsコードで作業するときは、インテントクラス名がインテント定義ファイルにあったものと一致していることを確認してください。そうすれば、システムは新しいインテントが古いインテントと同等であると考えることができます。

そして、App Intentsコードのパラメータ名とタイプが互換性を維持していることを確認してください。

繰り返しになりますが、Xcodeの「App Intentsに変換」ボタンは自動的にスキーマの互換性を保証します。

したがって、このツールを使用して変更を加えなければ、良い状態になります。

次に、既存のインテントを実際にアプリインテントに変換する方法について話しましょう。

インテントを移行するには2つのステップがあります。

ステップ1はインテント定義ファイルを移行し、ステップ2はコードを移行することです。

意図の定義から始めましょう。

私はスープの大ファンで、スープを注文できるスープシェフというサンプルアプリがあります。

それは、注文するスープの数、追加するトッピング、ピックアップまたは配達場所のパラメータで注文する意図を持っています。

これをApp Intentsに変換する準備ができているので、XcodeのIntent定義ファイルに移動し、変換ボタンを押します。

次に、変換する意図を選択します。この場合のみです。

次に、新しいインテントコードを保存する場所と、それを含めるターゲットを選択します。

私が追加した場合、それは私のアプリターゲットまたはアプリインテント拡張ターゲットである可能性があります。

この場合、アプリのターゲットと時計のターゲットもチェックします。

アプリの意図をフレームワークターゲットに追加することはできません。

次に、Xcodeが生成したApp Intentsコードを見ていきます。

インテント定義ファイルに含まれていたすべてのインテント、列挙型、およびカスタムタイプを表すいくつかのファイルで分割されています。

移行された私の古い意図定義のいくつかの特定の分野に注意を喚起したいと思います。

新しいコードには、App Intentプロトコルに準拠したorderSoup構造体があります。

この構造は、iOS 16以降で利用可能としてマークされていることに注意してください。

iOS 16より前にアプリを展開する場合は、App Intentsフレームワークを使用するすべてのコードにその注釈を適用する必要があります。

私のインテント定義ファイルの各パラメータは、そのメタデータとともに、App Intent構造の@Parameter宣言に移行されました。

すべてのショートカットアプリのパラメータサマリーは、このパラメータサマリー宣言に移行されました。

以前はパラメータ関係として表現されていたものを、ParameterSummaryのSwitch、Case、またはWhenステートメントを使用して表現できるようになりました。

私のスープとトッピングのカスタムタイプは、後で記入する必要があるいくつかのToDoを含むアプリエンティティになりました。

OrderDetailsは一時的なアプリエンティティになりました。

後で検索するために使用できる一意の識別子がないため、一時的と見なされます。

そして、私のOrderTypeカスタム列挙型は、アプリ列挙型になりました。

人間が読める名前は、ケース表示表現に移行されました。

最後に、インテントレスポンスのすべてのダイアログがIntentDialogの拡張機能に移行されました。

これらのダイアログは、私の実行方法に使用できます。

移行者は必要以上に多くの文字列を生成する可能性があるので、「確認するために、あなたは\（スープ）が欲しかったですか？」のように、古いインテントハンドラで実際に使用されていないものが表示された場合は、それらを自由に削除してください。

インテント定義を移行したので、インテント処理コードを移行しましょう。

自動生成されたApp Intentには、記入する必要があることを指摘するto-doを持つperform()メソッドのプレースホルダがあることに注意してください。

それを行う方法を見てみましょう。 

古いフレームワークでは、インテント定義ファイルと一連のインテント処理コードを提供しました。

新しいフレームワークでは、すべてがコードで表されます。

古いインテント定義のパラメータはすでに新しいコードに移行されています。

古いコードの解決、確認、および処理メソッドは、インテントが実行されたときに呼び出される単一の実行メソッドに組み合わせる必要があります。

また、カスタムタイプと動的オプションをエンティティとクエリにリファクタリングする必要があります。

それでは、解決から始めて、インテント処理の各フェーズを移行する方法を見てみましょう。

解決フェーズでは、インテントハンドラーはインテントの各パラメータを検証し、必要に応じてユーザーに値を求めます。

解決方法を移行するときは、可能な限りApp Intentsの新しい自動解決動作を利用する必要があります。

それ以外の場合は、解決ロジックをperformメソッドにリファクタリングする必要があります。

いくつかの例を見てみましょう。 ではいくつかの例を見てみましょう。

これがスープパラメータの古い分解方法です。

これは、古い意図フレームワークの一般的なパターンに従います。

スープのパラメータを開封してみてください。

Nilの場合、曖昧さ回避を使用してスープを選ぶようにユーザーに求める解決結果を返します。

設定されている場合は、成功して解決結果を返し、すでに指定されているのと同じスープを返します。

自動解決のおかげで、この種の定型本はApp Intentsでは不要になりました。

以前にこの方法で解決されたパラメータがある場合、新しい機能を利用する方法は次のとおりです。

デフォルトでは、移行されたパラメータはオプションですが、タイプを非オプションに変更することで自動解決動作を取得できます。

パラメータを非オプションにすると、App Intentsは、SoupAppEntityのクエリから提案されたエンティティを使用して、空の場合、自動的にユーザーに値を尋ねます。

次に、パラメータ宣言にダイアログを追加して、解決システムが「どのスープが欲しいですか?」などの値を求めるときに、ユーザーが特定の質問をするようにします。

これを行うと、このパラメータの解決コードはもう必要ありません。

他のすべてのタイプの解決については、解決の実装をperform（）メソッドの上部に移動し、APIの使用状況を変更して、適切な新しいAPIを使用してユーザーに説明を求める必要があります。

たとえば、数量の古い解決方法が数量をアンラップし、欠落している場合はneedsValueをスローし、数量が実際に利用可能なスープの数よりも大きいかどうかを確認し、その場合はエラーを返します。

このコードをApp Intentsに移動すると、数量パラメータを非オプションにできるため、最初の部分がまったく必要なくなります。

その2番目の部分では、サポートされていない解決結果で完了ハンドラを引き起こしたコードを取り、十分なスープの在庫がないことを示すエラーをスローするコードに置き換えたいと思います。

エラーとカスタムローカライズされた文字列リソースコンバーチブルプロトコルに準拠して、エラーを列挙型として定義する必要があります。

そうすれば、このケースがヒットしたときにユーザーに話されたり表示されたりするダイアログを提供できます。

この例のように動的に返されたコードとneedsValueの結果が使われていた場合は、needsValueErrorをスローするコードに置き換えることができます。

needsValueErrorをスローすると、システムは指定したダイアログで値をユーザーに促し、最初から実行メソッドを再度実行します。

もう1つのオプションは、requestValueメソッドを使用することです。

requestValueを使用すると、ユーザーに値を要求し、最初からやり直すことなくperformingメソッドを実行し続けることができます。

requestValueメソッドに加えて、以前のAPI使用を置き換えるために使用できるrequestDisambiguationメソッドとrequestConfirmationメソッドもあります。

次は確認について話しましょう。

確認は、追加の検証を行い、システムがユーザーに続行することを確認するように依頼するための情報を提供する機会です。

検証のために、確認メソッドにあったすべての検証ロジックを実行メソッドに移動する必要があります。

ユーザーに確認を求めるために、新しいシンプルなrequestConfirmation() APIがあります。

新しいAPIは、単一のメソッド呼び出しにすぎません。

Async/awaitを使用すると、このメソッドはユーザーが確認するまで待ってから実行メソッドを続行します。

キャンセルすると、エラーがスローされ、実行メソッドの実行が停止します。

requestConfirmationメソッドには、Siriが話したり表示したりするダイアログ、スニペットに表示されるSwiftUIビュー、確認ボタンに使用されるラベル（この場合は順序）、ダイアログをプロンプトとして画面に表示するかどうかを制御するshowPrompt引数など、確認プロンプトに影響を与えるいくつかの引数が含まれています。

ダイアログとビューに互いに同じ情報が含まれている場合、これはfalseに設定する必要があります。

だから、Siriが対話を話すが、それを示さないのは理にかなっています。

次に、ハンドルを見てみましょう。

ハンドルをリファクタリングするには、コードをハンドルメソッドから実行メソッドに移動するだけです。

解決、確認、および処理がすべて1つのメソッドで行われるため、古いハンドルメソッドからいくつかの検証コードを削除できるはずです。

たとえば、ハンドルから古いコードをコピーした場合、オプションではなくなったパラメータをアンラップするためのコードになり、削除できる可能性があります。

実行メソッドの最後に、インテント結果を返す必要があります。

結果には、Siriが話すためのダイアログや表示するスニペットビューなど、さまざまなフィールドを含めることができます。

それぞれでは、ダイアログのProvidesDialogやSwiftUIスニペットビューのShowSnippetViewなど、適切なプロトコルを使用して、実行メソッドの戻り値タイプに注釈を付ける必要があります。

最後に、動的オプションの移行を見てみましょう。

パラメータの種類に応じて、クエリまたはDynamicOptionsProviderに入力する必要があります。

Xcodeは、あなたが記入する必要があるこれらの場所でToDoを提供します。

クエリの場合、識別子、検索可能な場合は文字列、およびユーザーがショートカットでそのパラメータをタップしたときに表示される提案されたエンティティのセットでエンティティを返すメソッドを実装する必要があります。

動的オプションの場合は、resultsメソッドのすべてのオプションを返すだけです。

そして、それだけです!

App Intentsへの移行が完了しました。

あなたが本当に終わる前に、私が見ることをお勧めするものがいくつかあります。

1つ目は、アプリのショートカットを採用することです。

これにより、あなたの意図を発見可能にし、Siriにいくつかの単語を言うだけで人々がそれらを使用できるようにします。

SiriのヒントをUIに追加して、アプリの機能を使うためにSiriに何を言うべきかを人々が学ぶことができます。

これらは、以前に持っていた「Siriに追加」ボタンに取って代わるはずです。

アプリの以前のバージョンでショートカットを作成し、アプリの新しいバージョンで正しく動作することをテストして、顧客のアップグレードパスをテストしてください。

また、アプリが複数のロケールで動作する場合は、ローカリゼーションについて考えてください。

アプリインテントをローカライズするには、アプリインテントに含まれるすべての文字列をローカライズされた文字列リソースとして提供する必要があり、それらの文字列を含む対応するローカライズ可能な.stringsファイルを提供することでローカライズできます。

複数形の文字列を使用する場合は、.strings dict ファイルを使用することもできます。

App Shortcutsをローカライズするときは、文字列をAppShortcuts.stringsというファイルに追加し、それらの文字列内の変数を${ }表記に置き換えます。

要約すると、iOS 16の新機能とApp Intentsの新しいよりシンプルな開発モデルのすべての利点を得るために、カスタムIntentsをApp Intentsにアップグレードすることをお勧めします。

人々がアプリの機能を簡単に発見して使用できるように、アプリのショートカットを追加してください。

また、優れたユーザーエクスペリエンスをまとめる方法の詳細については、WWDC22の「デザインアプリショートカット」セッションをご覧ください。

ありがとうございます。