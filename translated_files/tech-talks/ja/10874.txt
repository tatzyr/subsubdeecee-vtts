10874

サイモン・マニング:こんにちは、私はサイモンで、CloudKitチームのエンジニアです。

今日は、CloudKitを使用してアプリのユーザー間でデータ共有をサポートする方法を実演します。

まず、GitHubで入手可能な共有サンプルアプリを紹介します。

次に、共有の作成をサポートし、他のユーザーをアプリでそれらの共有に参加するように招待する方法を説明します。

アプリが参加ユーザーに代わって招待を共有して受け入れる方法、共有レコードを取得する方法、アプリがカスタマイズされた共有体験を提供する方法、そして最後にCloudKitで利用可能なゾーンベースの共有モデルについて説明します。

まず、共有サンプルアプリです。

リマインダーとして、CloudKitは、アプリケーションがiCloud上のデータベースにアクセスできるようにするフレームワークです。

これは、複数のCKDatabaseにアクセスできるCKContainerとしてAPIに公開されます。

各コンテナには、すべてのユーザーが潜在的にレコードを読み書きできる1つのパブリックデータベースがあります。

デバイスにiCloudアカウントがログインしている場合、アプリはそのユーザーのデータを含むプライベートデータベースにもアクセスできます。

また、アプリが共有をサポートしている場合、現在のiCloudユーザーと共有されているデータは、共有CKDatabaseでアプリで利用可能になります。

レコードを所有するユーザーから共有を開始することと、参加者として共有への招待を受け入れることを実証するために、Apple GitHubアカウントで利用可能なサンプルアプリを参照します。

共有は、連絡先アプリの最小限の例です。

ユーザーのプライベートデータベースで新しい連絡先レコードの作成、アプリの他のユーザーと個々の連絡先の共有、他のユーザーから現在のユーザーと共有されたすべての連絡先の表示をサポートします。

共有リポジトリには、Swift並行性を使用した実装と、別々のブランチで利用可能な完了ハンドラベースの実装が含まれています。

共有を開始するには、まず新しい連絡先レコードを作成し、所有者のプライベートデータベースに保存します。

addContact関数は、Sharing's Add New Contact UIによって呼び出されます。

連絡先のrecordTypeで新しいCKRecordを作成し、名前と電話番号を保存します。

その後、レコードはプライベートデータベースに保存されます。

共有アプリの他のユーザーとの連絡先レコードの共有は、共有を作成することから始まります。

CloudKitでの共有は、CKShareと呼ばれる特殊な種類のレコードに依存しています。

ユーザーが他の人とレコードを共有したい場合は、彼らに代わってCKShareを作成し、プライベートデータベースに保存します。

このユーザーは共有されているすべてのレコードを所有しているため、共有レコード自体の所有者でもあります。

この共有レコードは、どのデータが共有されているか、誰と共有されているか、参加者を共有するためにどのような許可が利用できるかについての真実の源です。

共有権限は、共有の所有者が共有レコードへのアクセスを制御する方法です。

publicPermissionプロパティは、共有へのリンクを持つすべてのユーザーの権限レベルを表します。

デフォルトでは、URLのみを持つユーザーはアクセスできません。

このプロパティをより許容値に設定すると、共有のURLを持つすべてのユーザーが参加できます。

招待された各参加者には、株式の所有者によって決定された許可レベルもあります。

参加者オブジェクトは、ユーザーの身元や招待の受け入れ状況など、特定のユーザーの共有への参加を記述します。

権限は各参加者オブジェクトに個別に設定され、各参加者はCKShareの参加者配列に追加されます。

ユーザーのプライベートデータベースからレコードの共有を開始するには、まず共有のルートレコードを決定します。

ルートレコードとそのすべての子レコードは、この共有に含まれます。

次に、CKShareレコードを作成し、ルートレコードとCKShareの両方を現在のユーザーのプライベートデータベースに保存します。

共有では、createShare関数は共有する連絡先レコードでCKShareを初期化します。

CKShareとルートレコードは所有者のプライベートデータベースに保存され、CKShareはUIに戻されて招待プロセスを開始します。

CKShareとルートレコードの両方を同じ操作で一緒に保存する必要があります。

ルートレコードがCloudKitにすでに存在していても、CKShareのみを保存するとエラーが発生します。

ルートレコードを共有すると、子レコードも共有されます。

アプリが共有を作成したので、共有に参加するためのユーザー招待状を設定して送信する方法について説明します。

サンプルアプリは、UICloudSharingControllerという名前のUIKitが提供するビューコントローラーを使用します。

このコントローラーをアプリに実装すると、ユーザーは参加者をCKShareに簡単に招待したり、権限を設定したり、参加を表示および管理したり、レコードの共有をすべて停止したりできます。

新しい連絡先レコードを共有するときに、UICloudSharingControllerが共有サンプルアプリに表示される方法は次のとおりです。

ユーザーは共有招待状の送信方法を選択でき、権限は共有オプションセクションで設定できます。

コントローラのデリゲートプロトコルを実装して、共有に関する追加情報を提供し、共有イベントやエラーに関する通知を受信します。

ここで説明する方法に加えて、共有招待状に表示するアイテムタイトル、アイテムタイプ、およびサムネイル画像を設定する方法があります。

共有の所有者が他の人に招待状を送ったので、アプリは招待された参加者に代わって共有を処理して受け入れる必要があります。

アプリのInfo.plistでCKSharingSupported booleanを有効にします。

これにより、アプリは共有をサポートしていることをシステムに知らせ、招待URLを処理し、関連するデリゲート関数を呼び出す必要があります。

共有招待が開かれ、受け入れられると、アプリはデリゲートメソッドのコールバックを通じてCKShare.Metadataオブジェクトを受け取ります。

アプリはこのメタデータを使用して、現在のユーザーがコンテナの受け入れ機能またはCKAcceptSharesOperationを通じてこの共有を受け入れ、参加していることをCloudKitに通知します。

applicationDelegateライフサイクルでは、システムはアプリを起動し、userDidAcceptCloudKitShareWith: shareMetadataデリゲートメソッドを呼び出します。

shareMetadataオブジェクトで指定された識別子を使用して、CKContainerオブジェクトを初期化します。

次に、CKContainerでacceptを呼び、shareMetadataオブジェクトを渡して、現在のユーザーが共有を受け入れたことをCloudKitに知らせます。

アプリがプライベートレコードを共有するための招待状を送信し、それらの招待状を処理して受け入れるようになったので、アプリがユーザーが参加している共有レコードを取得して変更する方法について説明します。

現在のiCloudユーザーと共有されているレコードは、アプリコンテナのsharedCloudDatabase内で利用できます。

プライベートデータベースとパブリックデータベース内のデータをフェッチ、クエリ、操作するための同じCloudKit APIは、共有データベースで使用できます。

サンプルアプリでは、共有レコードはfetchSharedContacts関数でフェッチされます。

recordZoneChanges操作を使用して、変更を徐々に取得して処理します。

この操作が完了するたびに、フェッチにさらに変更があるかどうかを表すmoreComing booleanプロパティを返します。

また、ゾーンの履歴の特定の変更へのポインタであるchangeTokenを返します。

このchangeTokenを使用して、その時点以降に発生した変更のみを取得できます。

最初のフェッチ、またはゾーンの履歴のすべての変更を再フェッチするには、changeTokenをnilに設定します。

アクティブな共有の管理は、現在のユーザーによって異なります。

共有の所有者の場合、所有者のプライベートデータベースからCKShareレコードを削除することで、共有を停止できます。

所有者は、共有ルートレコードを完全に削除することもできます。

CKShareレコードオブジェクトのremoveParticipant関数は、参加者プロパティにある個々の参加者を削除する方法を提供します。

そして最後に、UICloudSharingController UIは、所有者がすべての参加者との共有を停止することを可能にします。

共有の参加者ユーザーの場合、ユーザーの共有データベースからルートCKRecordを削除するか、UICloudSharingController UIを使用して参加を停止できます。

ユーザーの共有データベースからルートCKRecordを削除すると、共有への参加が停止されるだけであることに注意してください。元のルートレコードは、所有者のプライベートデータベースに引き続き存在します。

共有サンプルアプリはUICloudSharingControllerを使用して参加者の検索と招待を処理しますが、CloudKit APIでこの機能を実装し、共有の所有者と参加者の両方にカスタムユーザーエクスペリエンスを構築することもできます。

まず、CKShareに招待する参加者を検索するには、関連するCKContainerでCKFetchShare ParticipantsOperationまたはshareParticipants関数を使用します。

電話番号、電子メール、およびユーザーレコードIDは、パラメータとしてサポートされています。

次に、この参加の特定の権限レベルを設定し、addParticipant関数を使用して参加者をCKShareに追加します。

変更されたCKShareを常にプライベートデータベースに保存してください。

保存されたCKShareレコードには、招待された参加者に送信して受け入れて処理できるURLプロパティがあります。

招待URLを使用して、共有のCKShare.Metadataを取得し、アプリのコンテナのaccept(shareMetadata)機能を使用して参加を確認できます。

共有アプリは、単一のレコードがルートレコードとして共有され、そのレコードの子も共有される階層的な共有モデルでCloudKit共有を実証します。

iOS 15で導入された新しいモデルであるゾーン共有では、代わりにレコードのゾーン全体を共有できます。

ゾーンを共有する場合、単一のレコードの階層だけでなく、ゾーン内のすべてのレコードが共有されます。

ゾーン共有はレコードゾーン内のすべてのレコードに影響を与えるため、このタイプの共有は同じレコードゾーンの階層共有と共存することはできません。

ゾーンに1つ以上の階層的な共有、または単一のゾーン全体の共有を持つことができます。

ゾーン共有と階層共有にはそれぞれ利点があり、どちらもユースケースに応じて利用する必要があります。

共有サンプルアプリのコンテキストでは、ゾーン共有は、連絡先のグループが別々のレコードゾーンに整理されている場合に役立ちます。

ゾーン共有は、これらの連絡先グループを他のユーザーと共有するために使用できます。

ゾーン共有の詳細については、WWDC21の「CloudKitの新機能」をご覧ください。

新しいゾーン全体の共有を作成するには、共有するカスタムレコードゾーンのIDで初期化し、プライベートデータベースに保存します。

共有招待を受け入れ、共有データベースからレコードを取得するプロセスは、以前と同じです。

シェアがゾーン全体のシェアであるかどうかを判断するには、そのrecordIDのrecordNameプロパティを確認してください。

値がCKRecordNameZoneWideShareの場合、共有は共有レコードゾーンを管理しています。それ以外の場合は、共有レコード階層を管理しています。

アプリでの共有をサポートする方法がわかったので、CKShareレコードの作成を開始し、ユーザーが他のユーザーと協力できるようにします。

UICloudSharingControllerを使用して共有UIをジャンプスタートするか、ニーズに合わせてカスタム実装を構築します。

使い慣れたフェッチと変更APIを使用して、共有クラウドデータベースから共有レコードにアクセスします。

そして、ゾーン共有の実装から恩恵を受けることができる、アプリで新しい共有ユースケースの探索を始めましょう。

見てくれてありがとう!