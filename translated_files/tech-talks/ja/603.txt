603

このプレゼンテーションでは、GPUが効率的に操作できるタイルメモリ内の画像データを記述できる画像ブロックに焦点を当てます。

イメージブロックは、タイルメモリに存在する画像データへの最適化されたアクセスを提供します。

また、A11 GPUを使用すると、直接制御できます。

アプリケーションにとって意味のある方法でピクセルをレイアウトしたり、データを明示的に移動したりできます。

イメージブロックは、フラグメント処理と新しいタイルシェーディングステージと深く統合されています。

従来のコンピューティングでも利用できます。

どの段階にいても、画像ブロックは2Dデータのグリッドへのアクセスを最適化するため、画像を表現することをお勧めします。

イメージブロックは、このプレゼンテーションシリーズで説明する他のいくつかの機能の重要な構成要素です。

イメージブロックをより正確に定義することから始めましょう。

イメージブロックは、タイルメモリ内の2Dデータ構造です。

幅、高さ、ピクセル深度があります。

フラグメント関数は、その場所に対応する単一のピクセルにしかアクセスできません。

一方、計算カーネルは、イメージブロック全体にアクセスできます。

各ピクセルは非常に複雑で、複数のコンポーネントで構成され、各コンポーネントは独自の画像面として対処できます。

これにより、隣接するコンポーネントを一括操作としてデバイスメモリ内の1つ以上のテクスチャに効率的に保存できます。

イメージブロックは、GPUのフォーマット変換ハードウェアへの一括アクセスも提供します。

浮動小数点ピクセルは、デバイスメモリに保存すると、宛先テクスチャ形式に変換されます。

それでは、画像ブロックを使用して、タイルメモリから画像データの移動を加速することの利点の1つを詳しく見てみましょう。

イメージブロックの前に、おそらく一度に1ピクセルずつ操作する前に、テクスチャの一部をスレッドグループメモリに移動したでしょう。

しかし、GPUはあなたが画像データを操作していることを理解していなかったので、それらのピクセルを一度に1ピクセルずつデバイスのメモリテクスチャに保存する必要がありました。

イメージブロックを使用すると、代わりに単一の操作を使用して画像データを保存でき、はるかに効率的です。

それでは、イメージブロックのプロパティをMetalに記述する方法に目を向けましょう。

計算パスでは、ここに示されているAPIを使用して、画像ブロックの幅と高さを記述します。

ディスパッチごとに寸法が異なる場合があります。

イメージブロックのピクセル深度は、構造としてシェーディング言語で説明されています。

画像ブロック全体は、その構造体によって型がテンプレート化された引数として利用可能になります。

シェーディング言語の構文を詳しく見てみましょう。

この例では、それぞれがさまざまな数のコンポーネントを持つ3つの要素で構成されるピクセルを記述しています。

イメージブロックは、引数としてカーネルで利用可能になります。

カーネルは、その場所を引数として取り、threadgroup_imageblockと呼ばれる新しいアドレス空間へのポインタを返すデータメソッドを使用して、参照によってイメージブロック内の任意の場所にアクセスします。

特定の場所を参照して、その場所の要素を読み書きできます。

先に述べたように、イメージブロックは、デバイスのメモリテクスチャに効率的に格納できる平面に配置されています。

シェーディング言語では、スライスを一緒に格納できる隣接する平面と呼びます。

カーネルの例を見てみましょう。 

この例では、ソーステクスチャをイメージブロックにロードし、そのブロックでいくつかの画像処理を実行し、カラー要素を宛先テクスチャに保存する準備が整いました。

書き込みを実行するには、スレッドグループのスレッドが1つだけ必要なので、すべてのスレッドがイメージブロックの処理を完了していることを確認するために、まずバリアする必要があります。

Metalがバリアに新しいメモリターゲットを追加し、イメージブロックへの書き込みが完了するのを待つだけでよいと宣言していることに注意してください。

次に、スライスメソッドを使用して、イメージブロックから目的のスライスを取得します。

スライスメソッドは、スライスの一部である任意のピクセル要素への参照を取ります。

最後に、スライスを宛先のテクスチャに書き込みます。

各画像ブロックはおそらくテクスチャの領域のみを表すため、画像ブロックを書き込むテクスチャオフセットを指定します。

それでは、フラグメント関数のイメージブロックの指定方法を見てみましょう。

計算パスのイメージブロックとは異なり、レンダリングパスのイメージブロックの寸法はパス全体で一定であり、ここに示すプロパティを使用して設定されます。

イメージブロックのピクセル深度は、カーネルにすでに示したように、シェーディング言語で構造体として宣言できます。

ただし、フラグメント関数は、レンダリングパスアタッチメントを使用してピクセル深度を宣言することもサポートしています。

構文を見てみましょう。 

この例では、シェーディング言語でピクセル構造を明示的に宣言しました。

フラグメント関数はイメージブロック内の暗黙の場所にのみアクセスできるため、引数タイプは構造体自体ですが、imageblock_data属性でタグ付けされています。

また、同じ属性で戻り値にタグを付ける必要があります。

そうすることで、Metalは正しいアクセス命令を生成できます。

それでは、従来のレンダリングパスアタッチメントを使用してピクセル構造を宣言するときに、この同じ例がどのように見えるかを見てみましょう。

この形式は、あなたがすでに知っている構文と同じです。

実際、タイルメモリは常にAシリーズGPUの重要な側面であるため、レンダリングパスでは常にイメージブロックを使用してきました。

新しいのは、Metal 2がタイルメモリに一般的にアクセス可能になったことです。

このフォームは、レンダリングパスにアタッチされたテクスチャから派生した基礎となるイメージブロックストレージフォーマットを抽象化します。

テクスチャストレージタイプに関係なく、データはフラグメント関数で浮動小数点または整数として表示されます。

A11と以前のアーキテクチャのもう1つの違いは、これらの暗黙のイメージブロックフォーマット変換が発生する場所です。

A7からA10 GPUでは、ストレージフォーマットはタイルメモリの浮動小数点に拡張されました。

これが、Metalがピクセルフォーマットごとに2つのサイズを文書化する理由です。1つはデバイスメモリに保存されている場合、もう1つはレンダリングパスアタッチメントとしてタイルメモリに保存されている場合です。

A11では、フォーマット変換は各ロードで行われ、タイルメモリからシェーダーコアの一時レジスタに保存されます。

そうすることで、タイルメモリからさらに多くの使用を絞り出すことができます。

ピクセル構造を宣言する方法を選択できるようになりましたので、決定に役立つベストプラクティスを確認しましょう。

暗黙のイメージブロックは、フラグメント関数が基礎となるストレージ形式を抽象化するため、複数のレンダリングパスアタッチメントレイアウトをサポートする必要がある場合に最適です。

暗黙のイメージブロックは、構造がAPIによって知られているため、ロードおよびストアアクションとも互換性があります。

一方、明示的な画像ブロックを使用すると、より複雑なピクセル構造を表現できます。

明示的なイメージブロックもメインメモリバッキングを必要としないため、レンダリングパスの範囲内で完全に生成および消費される一時的なデータに最適です。

では、複雑なピクセル構造の意味を詳しく見てみましょう。

この例では、ピクセルごとに複数の半透明の色とその深さを保存し、後でソートして合成して、より正確な透明度効果を得ることができます。

単一のフラグメント宣言から始めて、それらの配列を宣言し、シェーダーとの間で渡すことができるトップレベルの構造体にそれをネストします。

レンダリングパスの添付ファイルを使用してこの構造を表現することは厄介であり、著者の意図を覆い隠すだろう。

もちろん、Metalでは仕事に適したツールを選択できるため、暗黙の形式と明示的な形式を選択する必要はありません。

また、ミキシングを使用すると、イメージブロックをコードベースに段階的に採用し、明示的なフォームの恩恵を受ける既存のシェーダーに新機能を簡単に統合できます。

両方のフォームを一緒に使用するのは簡単で、2つのイメージブロック引数を提供するだけです。

例を見てみましょう。 例を見てみましょう。

ご覧のとおり、入力と出力の両方として2つの画像ブロックを提供できます。

colorとimageblock_data属性は、どのスライスがレンダリングパスアタッチメントから派生し、どのスライスが派生しないかをMetalに明確にします。

入力と出力ごとに最大2つの画像ブロックを各関数で宣言できます。

明示的なイメージブロックを使用すると、パックされたタイプを使用してピクセルレイアウトを正確に制御できます。

Metalシェーディング言語は、伝統的に頂点と定数データレイアウトを記述してきたパックされた浮動小数点ベクトル型をすでに提供しています。

しかし、今は、暗黙のイメージブロックとテクスチャピクセル形式を使用して以前に記述できたものと一致するパックタイプが必要です。

メタル2は、シェーディング言語にそのようなタイプを追加します。

これらのフォーマットは、先ほど説明したロード/ストアハードウェアを使用して、浮動小数点との間で変換されます。

さらに、これらの新しいパック形式は、頂点と一定のデータレイアウトを記述するためにも使用できます。

シェーディング言語でこれらの新しいタイプを宣言する方法を見てみましょう。

この例では、画像ブロックと頂点データの両方を記述するために使用される新しいパック型のいくつかを見てみます。

これらのタイプでは、シェーダーコア内で使用されるストレージ形式とアンパック形式の両方を宣言する必要があります。

では、追加されたすべての新しいパックされたデータタイプを見てみましょう。

ご覧のとおり、メタルシェーディング言語は、1つ、2つ、4つのコンポーネント正規化タイプを追加し、それぞれが8ビットまたは16ビットコンポーネントをサポートします。

また、署名済みバリアントと未署名バリアントの両方を追加し、10a2、ミニフロート、共有指数、sRGBなどのより特殊な32ビットフォーマットのサポートも追加しました。

最後に、XcodeのGPUデバッガは、イメージブロックの視覚化と検査を直接サポートします。

各スライスは、まるでテクスチャであるかのように検査することができます。

ここでは、上部にサンプルコードのGバッファレイアウトの例があります。

そして、下部には、XcodeのGPUデバッガに同じイメージブロックショーがあります。

バインドされたリソースビューのタイルセクションは、イメージブロックスライスをテクスチャのセットとして表示します。

ここから、他のテクスチャと同じように各スライスを検査できます。

このプレゼンテーションでは、イメージブロックがタイルメモリからデバイスメモリに複数のピクセルを効率的に移動し、ストレージ密度を向上させるためにタイルメモリ内の画像データのレイアウトを正確に制御する方法を見ました。

また、A11 GPUの新しいパック/アンパックハードウェアを、イメージブロックと他のアドレス空間の両方で活用する方法も見ました。

メタル2の詳細とサンプルコードへのリンクについては、開発者のウェブサイト（developer.apple.com/metal）をご覧ください。

見てくれてありがとう!