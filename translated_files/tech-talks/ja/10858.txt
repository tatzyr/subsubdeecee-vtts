10858

A14 Bionicのメタルアップデートへようこそ。

私の名前はAnand Poovekurussiで、AppleでGPUソフトウェアで働いています。

A14 Bionicは、iPhone 12と新しいiPad Airの中心にあります。

このビデオでは、同僚のスワミと私は、A14 BionicのGPU機能とそれを可能にする新しいメタル機能を紹介します。

A14には、CPU、GPU、ニューラルエンジン、およびiOSエクスペリエンスを推進するその他のカスタム技術が大幅に更新されています。

画期的な5ナノメートルプロセス技術を使用しており、チップのほぼすべての面で新機能、パフォーマンスの向上、さらに高い電力効率をもたらします。

私たちはA14 Bionicに世界クラスのモバイルGPUを構築しました。

可能な限り低い電力で最大の持続可能なパフォーマンスを提供するために拡張された4つのコアを持っています。

さて、Metalに関しては、A14にはMetalアプリのパフォーマンスを向上させるいくつかの特定の変更があります...

GPU駆動のパイプラインから始めます。

Metalの間接コマンドバッファを使用すると、作業をGPUに移動し、GPUタイムラインでコマンドをエンコードできます。

これにより、アプリで他のタスクを実行するための貴重なCPU時間が解放されます。

A14 GPUアーキテクチャは、このような使用モデルをより効率的にします。

次に、並列コンピューティングをよりよくサポートするために、GPUスレッドグループメモリの設計のパフォーマンスを大幅に改善しました。

スレッドグループスコープアトミックなどの同期プリミティブは、これらの変更の結果として大きなパフォーマンスの利点を見ることを期待しています。

最後に、メモリ帯域幅を節約する能力は、当社のプラットフォームの重要な設計上の優位性であり続けています。

A14 GPUは、アプリにさらに多くの帯域幅を節約する新しい圧縮ハードウェアを活用しています。

フレームバッファの圧縮は平均して15%以上改善すると予想され、深度バッファは平均して40%以上の改善が見られるはずです。

A14 GPUのすべての新機能は、Apple GPUファミリー7と呼ばれる新しいMetal機能セットに属しています。

このビデオで取り上げる内容は次のとおりです。

まず、重心座標とプリミティブIDについて話します。

また、これらの機能の両方を一緒に使用して、可視性バッファなどの遅延レンダリング技術を実装する方法も紹介します。

その後、A14の新しいテクスチャアドレッシングモードをすばやく紹介します。

また、コンピューティングを行うアプリのためのまったく新しい機能もあります。

講演の2番目のセクションでは、同僚のSwamiが、アプリケーションがSIMDグループスコープで削減操作を実行するための効率的な方法を提供する新しいSIMD削減手順について説明します。

彼はまた、A14のMetalの新しいSIMDマトリックス乗算命令をカバーします。

これらの新しい命令は、機械学習と画像計算で使用される大規模な行列乗算に大きなパフォーマンス向上を提供します。

これらのそれぞれをもっと詳しく見てみましょう....

重心座標とプリミティブIDから始まります。

Apple GPUファミリー7は、バリセントリック座標とプリミティブIDへのアクセスを提供するようになりました。

バリセントリック座標は、プリミティブ内のフラグメントの正確な位置を定義します。

そして今、フラグメントシェーダーでこれらの座標にアクセスできます。

右の写真でわかるように、ポイントPのフラグメントの位置は、三角形を形成する頂点の加重和として定義され、重みの合計は1です。

メタルシェーディング言語では、フラグメントの重心座標はフロートのベクトルとして公開されます。

重心座標を使用することで恩恵を受けることができる技術を見てみましょう。

手続き生成は、モデル、アニメーション、エフェクトをアルゴリズム的に生成するために使用される技術のクラスです。

粒子システム、地形、植生など、プリミティブの表面にあらゆる種類の手続き効果をその場で行うことができます。

カスタム線を描くことは、そのような例の1つです。

バリセントリック座標をこれにどのように使用できるかを見てみましょう。

手続き型生成を使用して、三角形にカスタムの高品質のアンチエイリアス線と境界線を描きたいとしましょう。

これを行うには、プリミティブの端からのフラグメントの距離に興味深い数学関数を適用することができます。

本質的にあなたの断片のバリセントリック座標は、エッジからの距離を与えます。

上記の例は、オンザフライ効果を生成するために、フラグメントシェーダーの重心座標に適用されるいくつかの興味深い関数を示しています。

A14のMetalのもう1つの新機能は、プリミティブIDです。

プリミティブIDは、現在のフラグメントが入力ジオメトリでどのプリミティブに対応するかを示します。

右側では、フラグメントシェーダーでその三角形内のフラグメントのプリミティブIDがフェッチされたときに、三角形にリストされているIDが返されます。

これで、三角形がハードウェアによってクリップされた場合、子三角形は親のプリミティブIDを継承します。

そして、テッセレーションの存在下では、プリミティブIDは単にパッチIDに対応します。

メタルシェーディング言語では、プリミティブIDは符号なし整数です。

プリミティブIDのユースケースを見てみましょう。

一時的なアンチエイリアシングは、フレーム間の動きによって引き起こされるゴーストときらめくアーティファクトを減らす技術です。

これは、前のフレームからピクセルデータを蓄積し、それをフラグメントの現在のレンダリング結果とブレンドすることによって機能します。

プリミティブIDは、時間的アンチエイリアスで使用して、前のフレームのサンプルを検証できます。

では、実際にこれをどのように行いますか?

まず、フラグメントシェーダーで、前のフレームの結果を再投影して、ピクセル履歴を取得します。

次に、ピクセルを内省して、データが現在のフレームと一致していることを確認します。

これは、2つのサンプルのプリミティブIDを比較することで実行できます。

IDが一致する場合は、前のフレームからの貢献を蓄積することを選択できます。

ピクセル履歴は、イントロスペクション後に蓄積またはリセットして、結果を次のフレームに転送できます。

重心座標とプリミティブIDを導入したので、もっと深く掘り下げてみましょう...

遅延レンダリングから始めて、あなたがすでによく知っている可能性が高いテクニックです。

遅延レンダリングは、古典的に2つの段階で動作します。

第1段階は、Gバッファと呼ばれるサーフェス属性バッファを生成し、第2段階はGバッファを消費し、シーンに照明を適用します。

しかし、高解像度で実行している場合、またはマルチサンプリングを使用している場合、Gバッファのサイズは非常に大きくなる可能性があり、これらのバッファの読み取りと書き込みは帯域幅コストがかかる可能性があります。

この問題に対処するために、Gバッファは、サーフェス属性の最小セットを含む薄いバッファに置き換えることができます。

このバッファは可視性バッファと呼ばれます。

可視性バッファは、この段階からの出力を大幅に簡素化することで、ジオメトリ段階での作業を最小限に抑えます。

Gバッファでマテリアルプロパティを生成するために、遅延レンダリングでフラグメントシェーダーで通常実行するすべてのマテリアルロジックは、照明フェーズに移動されました。

これにより、すべての材料特性を中間バッファに保存する必要がなくなります。

材料機能がなければ、ジオメトリステージの複雑さが大幅に軽減され、頂点シェーダーとフラグメントシェーダーの間の高い充填率と最小トラフィックが可能になります。

この技術は、可視性バッファ内の最小限のデータセットから材料入力を再構築するために、照明パス中に新しい再構築ステップを追加します。

可視性バッファに何が含まれているかを見てみましょう。

可視性バッファには、ジオメトリの再構築を容易にするために2つの属性を含めるだけで済みます。

プリミティブIDを使用して、頂点バッファから頂点データを手動で取得し、遅延頂点フェッチを効果的に実行できます。

重心座標は、現在のフラグメントの頂点データを補間するために使用されます。

前述のように、A14のフラグメントシェーダーでこれらの属性にアクセスできます。

可視性バッファパイプラインの2つの段階を詳しく見てみましょう。

高いレベルでは、可視性バッファアプローチには、可視性バッファを生成するジオメトリステージと、それを消費する照明ステージの2つのステージがあります。

ジオメトリ段階では、頂点シェーダーの変換はラスタライズに必要な位置のみを生成します。

フラグメントステージは、追加のバリエーションを必要とせずに、新しいA14メタルシェーディング言語属性でプリミティブIDとバリセントリック座標を生成できます。

照明段階では、新しい再構築ステップは、プリミティブIDに基づいて遅延頂点フェッチを使用し、重心座標を使用して頂点データを補間して材料関数入力を生成します。

素材と照明シェーダーは効果的に手つかずで、延期されたレンダリングの実装と同じです。

これらのステージ間のインターフェースがどのように最小化されたかを見てみましょう。

頂点シェーダーは、ラスタライズする位置のみを必要とします。

フラグメントシェーダーは、再構築ステップに供給される可視性バッファの表面IDと重心座標を生成します。

そして、再構築ステップの後にのみ、材料モデルと照明機能で使用される大きな再構築された材料入力データをメモリに保存します。

インターフェイスを導入したので、これらの入力と出力を生成しているシェーダーを見てみましょう。

単純な頂点とフラグメントシェーダーを持つジオメトリフェースから始めましょう。

頂点シェーダーは、位置を変換して出力するだけです。

フラグメントシェーダーでは、メタルシェーディング言語で利用可能な新しいプリミティブIDとバリセントリック座標を使用します。

プリミティブIDと追加の描画インデックスをサーフェス識別子に組み合わせて、後で見るように、頂点バッファ全体でプリミティブを識別できます。

では、照明のステージを見てみましょう。

高レベルでは、照明ステージには、再構築、材料モデル、照明機能の3つのステップがあります。

再構築ステップは、表面識別子とバリセントリック座標からの材料入力を再構築します。

その後、遅延シェーダーで行うように、材料モデルステップを実行できます。

そして最後に、照明機能を適用して、最終的な照明ピクセルを書き出します。

前述のように、素材と照明のステージは古典的な延期と同じです。

では、再建のステップをもっと詳しく見てみましょう。

再構築ステップの主な目的は、着信可視性バッファフラグメントを材料入力に変換することです。

まず、サーフェス識別子に含まれるプリミティブIDとドローIDを使用して、特定のフラグメントの頂点データを生成する必要があります。

追加のインデックスは、フラグメント間で異なる頂点バッファを持つことを容易にします。

このために、ドロー識別子を使用してドローコールを参照します。

第二に、重心座標は再構築ステップの補間に使用されます。

逆参照ツリーを調べてみましょう。

ここでは、可視性バッファピクセルを元の補間頂点属性に戻すために必要な逆参照ツリーを示します。

可視性バッファには、2つの重心座標が含まれています。

3番目の座標は、3つすべての合計が1つであるため、他の2つから取得できます。

また、前述のように、ドローIDとプリミティブIDの組み合わせも含まれています。

描画IDから、描画状態を取得でき、ビュー投影行列などの描画ごとのプロパティにアクセスできます。

そこから、メッシュ状態から頂点とインデックスバッファを取得できます。

これらのインデックスは、頂点データを取得するために必要です。

また、同じパスを使用して、必要な材料固有のデータを取得することもできます。

これで、材料モデルがより複雑になった場合、特定の材料ロジックを実行するための材料関数ポインタを追加できます。

シェーダーコードで再構築がどのように見えるかを見てみましょう。

再構築関数で最初に行うことは、プリミティブIDを取得し、可視性バッファからIDとバリセントリック座標を描画することです。

その後、ドローIDを使用してドロー状態からメッシュIDを取得できます。

インデックスバッファは、プリミティブIDとメッシュIDを使用して頂点バッファ内の頂点インデックスを取得するために逆参照する必要があります。

その後、頂点バッファデータをバリセントリック座標にわたって読み取り、補間することができます。

さらに、行列やその他の描画ごとの情報を取得して、法線や接線などのジオメトリで遅延頂点変換を行うことができます。

材料入力が生成されると、前述のように、データは材料ロジックと照明機能に入力されます。

実行中の可視性バッファを見てみましょう。

これは、iPhoneで実行されている可視性バッファを使用しているモダンなレンダリングシーンです。

複数の素材と光で満たされたシーンを利用するタイル照明技術を実装しています。

通常、古典的な延期では、これは通常、アルベド、粗さなどの複数のGバッファチャネルを必要とし、かなり大きなGバッファを占めます。

しかし、可視性バッファでは、サーフェスIDと重心座標だけが必要です。

まず、生成されたサーフェス識別子を保存し、それぞれドローIDとプリミティブIDを示す明るさと色相でここに視覚化されます。

次に、ここで視覚化されたバリセントリック座標を、赤、緑、青のカラーチャンネルで保存します。

これら2つの特性は、ジオメトリを効率的に再構築し、遅延材料シェーディングと照明モデルを適用するのに十分です。

この技術により、薄い視認性バッファーを使用してA14でGバッファサイズが大幅に縮小されます。

この例では、古典的な繰延と比較して、Gバッファサイズの40%以上を節約しています。

バリセントリック座標とプリミティブIDの深い掘り下げを締めくくります。

それでは、A14の新しいテクスチャアドレッシングモードを簡単に見てみましょう。

これらのモードは、サンプリング範囲外のテクスチャ座標の処理方法を指定すると、テクスチャアトラスを使用しているときに非常に便利です。

A14用のMetalに2つの新しいアドレッシングモードを追加しました。

エッジアドレッシングモードへのミラークランプでは、範囲の範囲内のテクスチャ座標が軸全体にミラーリングされます。

そして、彼らが外に落ちるとき、彼らはクランプされます。

右側の写真でこれを見ることができます。

また、透明な黒、不透明な黒、不透明な白の間でプリセットの1つを選択できるボーダーカラークランプモードも追加しました。

使い方はかなり簡単です。

まず、サンプラー記述子オブジェクトを作成する必要があります。

次に、アドレスモードを設定することで、深さ、幅、高さの座標のクランプモードを個別に指定できます。

clampToBorderColorを使用している場合は、Metalでサポートされているプリセットの1つを設定できます。

この後、サンプラー記述子を使用してsamplerStateオブジェクトを作成できます。

それがA14の新しいグラフィック機能の概要でした。

今、私はSIMD削減から始めて、A14 GPUが可能にする新しいコンピューティング機能を説明するために、同僚のスワミにそれを手渡したいと思います。

ありがとう、アナンド。

私はスワミ・ナラヤナンで、GPUソフトウェアで働いています。

Metalは、高性能グラフィックスを可能にするだけでなく、データ並列計算を実行するように設計されており、GPUの驚異的なパワーを活用するさまざまな高度なコンピューティング機能を提供します。

A14 Bionicでは、Metalは現在、アプリが信じられないほど効率的に削減を実行する方法を提供するSIMDスコープ削減命令を提供しています。

それらがどのように機能するかを理解するために、並列削減操作を簡単に復習しましょう。

削減操作は、配列の要素を単一の結果に減らすために使用されます。

たとえば、合計削減は、配列のすべての要素を合計するために使用されます。

これは平均の計算に役立ちます。

もう1つの例は、シーンの最小値と最大値を計算することです。

これらの値は、トーンマッピングアルゴリズムで使用できます。

古典的には、これらの操作はすべてCPU上で連続して計算されました。

しかし、MetalはGPUの並列性を利用して、削減をはるかに効率的に計算することができます。

A14 GPUでは、MetalはいくつかのSIMDスコープ削減命令をサポートするようになりました。

simd_sumとsimd_productは、SIMDグループ内のすべてのスレッドで変数の合計と積を生成します。

Simd_minimumとsimd_maximumは、最小値と最大値を見つけるために使用できます。

これらの4つの命令は、浮動小数点型と整数型で動作します。

さらに、Metalは、ビット単位の演算子「and」、「or」、および「xor」を使用した削減をサポートするようになりました。

当然のことながら、これらは整数型でのみ機能します。

削減操作について詳しく説明する前に、スレッドがスレッドグループとSIMDグループにどのように編成されているかを見てみましょう。

計算ディスパッチは、グリッドとして表される個々のスレッドのセットを起動します。

このスレッドのグリッドは、スレッドグループと呼ばれる小さなサブグリッドに分かれています。

スレッドグループは、SIMDグループと呼ばれる32のスレッドのグループにさらに編成されます。

SIMDグループのスレッドは、ロックステップで同時に実行されます。

SIMDグループ関数は、このロックステップ実行を悪用して、これらのスレッド間でデータを共有します。

SIMDグループとスレッドグループがどのように構成されているかを見たので、SIMDグループでスレッドがどのように実行されるかを見てみましょう。

SIMDグループには、ここの左側に表される32の車線があります。

これらの各レーンは、コンピューティングディスパッチからスレッドを実行します。

それでは、SIMDグループ内のすべてのスレッドにレーンIDを変数Xに保存させましょう。

各レーンがXの独自の値を持っていることに注目してください。

SIMDグループ実行モデルでは、変数XをレーンIDに設定する命令は一度だけフェッチされ、32スレッドによってロックステップで同時に実行されます。

SIMDグループ関数を使用すると、これらのスレッドのそれぞれが最小限のオーバーヘッドでSIMDグループ内の他のスレッドの変数を検査して使用できます。

A14に追加された新しい指示の1つであるsimd_sumを見てみましょう。

simd_sumは、SIMDグループ内のすべてのアクティブなスレッドで変数の値を加算し、合計をすべてのスレッドにブロードキャストします。

ここでは、SIMDグループの32レーンに変数Xの値を追加します。

命令が実行されると、結果の合計は変数Fで利用可能になります。

すべてのアクティブなスレッドは、変数Fのコピーを検査して、計算された合計496を取得できることに注意してください。

非アクティブなスレッドは計算で正しくスキップされます。

彼らは最終的な金額に貢献しません。

それでは、simd_sumを使用して大きな配列の要素の追加を高速化する方法を見てみましょう。

ここでは、入力アレイはデバイスメモリにあります。

各SIMDグループは、入力配列の小領域を読み取り、simd_sum命令を使用してその合計を計算します。

この合計は、スレッドグループメモリ内の配列に書き込まれます。

すべてのSIMDグループには、スレッドグループ合計配列にインデックスを作成するために使用できる個別のIDがあります。

スレッドグループで最後に実行したSIMDグループは、simd_sum命令を再度使用して最終的な合計を取得します。

Simd_sumを使用することで、スレッドグループバリアの数とスレッドグループメモリの使用を減らしました。

simd_sum命令は、SIMDグループ内のすべてのスレッドの合計を計算するために一度だけ実行されます。

では、コンピューティングカーネルの実装に進みましょう。

ここには、simd_sumを使用して並列削減を実装するコードがあります。

SIMDグループの各スレッドは、入力配列から対応する要素を読み取ります。

次に、simd_sum命令を使用して最初のsimdgroup_sumを計算します。

この合計は、SIMDグループIDを使用してインデックス化されたスレッドグループメモリ内の配列に書き込まれます。

スレッドグループメモリ内の配列にアクセスするには、バリアが必要であることに注意してください。

各スレッドグループの最後のSIMDグループは、simd_sum命令を再度使用して最終的な合計を取得します。

A14で導入した他の削減操作を見てみましょう。

私たちはすでに、すべてのアクティブなレーンでXの値を合計するsimd_sumを見ました。

では、simd_maxを見て、それを変数Xに適用しましょう。

その後、すべてのレーンは、SIMDグループ内のすべてのスレッドで最大値（31）を取得します。

同様に、simd_minは、すべてのアクティブレーンにわたって、この場合はたまたま0であるXの最小値を格納します。

最後に、Xのすべての値を乗算するsimd_productがあります。

変数の1つがたまたま0であるため、ブロードキャストされる最終製品は0です。

これらの命令は、整数型と浮動小数点スカラーとベクトル型の両方で機能します。

削減操作は、積分型のビット単位の操作でもサポートされています。

各レーンには、ここに示すように、レーンIDを使用して製造されたビットフィールド値を持つようになりました。

その後、変数Xでsimd_or命令を使用できます。

すべてのアクティブレーンのXの値は一緒にor-edされ、変数Fにブロードキャストされます。

この最終的な値は、この例ではたまたま0x1F3です。

同様に、simd_xorはXのxor値を計算し、結果の値をブロードキャストし、0x0であることが判明します。

最後に、SIMDグループ内のすべてのスレッドでXのすべての値を合計するsimd_andがあります。

これは定数0x3であることが判明しました。

これは、A14 GPUで利用可能な新しいSIMDスコープ縮小命令の概要でした。

それでは、行列の乗算を大幅に改善する新しい一連のSIMDスコープ命令を見てみましょう。

行列乗算は、GPUコンピューティングの非常に一般的な操作であり、多くの並列コンピューティングワークロードの基本的な構成要素です。

たとえば、機械学習では、畳み込みと完全に接続されたニューロン層を計算するときに使用されます。

線形代数は、方程式のシステムを表現し、解くために使用されます。

A14は、大きな行列乗算を非常に効率的に実装することを可能にする、まったく新しい一連のSIMDスコープ命令を導入しています。

以前に見た削減操作と同様に、これらはSIMDグループスコープ操作です。

これらのビルディングブロックの上に、より大きく、より洗練された機能を簡単に構築できるようになりました。

Metalシェーディング言語では、8×8と4×4の行列を表すSIMDグループスコープデータ構造があります。

その後、SIMDグループスコープ付き行列操作のmultiplyまたはmultiply_accumulateバージョンを使用できます。

これらの関数を使用して、スレッドグループ内の2つの16×16行列を掛ける例を見てみましょう。

8×8のSIMDグループ行列演算を使用して、16×16の3番目のグループ行列乗算を構築します。

まず、結果マトリックスを4つのSIMDグループに分割します。

各SIMDグループは、結果の1つの8×8象限を計算する責任があります。

次に、最初の入力行列を分割します。

ここでは、行内の各SIMDグループが1つのブロック列を共有します。

次に、2番目の入力を分割します。

ここでは、列内の各SIMDグループが1つのブロック行を共有します。

その後、8×8の結果の最初のセットから製品を蓄積します...

そして2番目。

では、これをメタルシェーディング言語で書く方法を見てみましょう。

A14では、新しいSIMDグループ行列オブジェクトと乗算演算をMetalシェーディング言語に導入しました。

これらの新しいプリミティブは、シェーダーでの行列乗算のパフォーマンスを大幅に向上させます。

使いやすく、わずか数行のシェーダーコードで実行できます。

ここでは、32ビットの浮動小数点形式のデータで8×8の行列を表す3つのオブジェクトを定義します。

各入力のマトリックスと結果のマトリックスがあります。

次に、結果の各象限にまたがる4つのSIMDグループを分割するために必要なアドレス算術を実行します。

次に、各ソースマトリックスからいくつかの行列を蓄積し、適切な行と列を各SIMDグループにブロードキャストします。

最後に、結果を保存します。

これらの新しいプリミティブを使用して、より複雑なシェーダーを構築するのがいかに簡単かがわかります。

メタルパフォーマンスシェーダーを使用している場合は、SIMDグループスコープマトリックス乗算の恩恵を受けて、行列乗算だけでなくCNN畳み込みも加速します。

任意のサイズの行列乗算は、MPS行列乗算を使用して実行できます。

ここでは、M行とN列で結果を計算するためにカーネルをエンコードしています。

CNN畳み込みは、MPSCNNConvolutionを使用して実行できます。

ここでは、画像のバッチに畳み込みカーネルをエンコードしています。

これらのカーネルは両方とも、iOS 14で今年導入された新しいメタルパフォーマンスシェーダーグラフを使用して利用できます。

MPS Graphを使用すると、これらの基本的なカーネルを使用して複雑な機械学習ネットワークを構築できます。

例として、以前の行列乗算カーネルをグラフでどのように使用できるかを見てみましょう。

ここでは、操作用の新しいグラフを初期化します。

次に、2つの入力行列を表すノードを定義します。

次に、行列乗算操作を使用して、入力から新しい結果ノードを構築します。

最後に、グラフを実行します。

MPSカーネルとグラフ操作の使用方法の詳細については、以前に利用可能なWWDCプレゼンテーションを参照してください。

前述のように、MPSはこれらの操作に自動的にA14を利用します。

ここでは、A13に対するA14の一般的な行列乗算のスループットの向上を見ることができます。

A14では、新しいSIMDグループ行列乗算操作を使用して、平均パフォーマンスが37%向上します。

A14のCNN畳み込みは、A13から平均36%の改善を示しています。

そして、Inception V3のような完全な機械学習ネットワークのトレーニングを見ると、A14は22%向上します。

これにより、SIMDグループスコープ行列の乗算が終了します。

A14の新しいメタル機能を要約しましょう。

バリセントリック座標とプリミティブIDは、可視性バッファレンダリングを含む新しい遅延レンダリング技術を可能にします。

テクスチャアトラスを使用する際に便利な新しいテクスチャアドレッシングモード。

スレッド間のより良いコミュニケーションを可能にするSIMDグループスコープ縮小命令。

また、SIMDグループスコープ行列乗算命令を使用して、コンピューティングと機械学習のパフォーマンスを改善しました。

そして最後に、A14上のMetalは、多くのアーキテクチャの改善を活用し、改善されたロスレス圧縮、より速く、より効率的なローカルメモリ、より良いGPU駆動パイプラインで帯域幅を節約します。

ご覧いただきありがとうございます。