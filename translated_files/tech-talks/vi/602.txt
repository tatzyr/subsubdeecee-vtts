602

Metal 2 giới thiệu một bộ API mới và thay đổi ngôn ngữ đổ bóng để tận dụng kiến trúc và các tính năng mới của GPU A11.

Hãy để chúng tôi xem lại những gì mới với Metal 2 trên A11.

Apple đã thiết kế Metal để cho phép đổi mới nhanh chóng trong kiến trúc GPU.

Và đến lượt nó, kiến trúc GPU của Apple đã thông báo cho thiết kế của Metal.

Sự tích hợp sâu sắc và liền mạch của phần cứng và phần mềm này cho phép những khả năng mới thú vị cho đồ họa, máy tính, ứng dụng học máy và trò chơi của bạn.

Chỉ ba năm sau khi giới thiệu Metal, chúng tôi đã giới thiệu Metal 2, thế hệ tiếp theo của Metal, tại WWDC 2017.

Dựa trên một thiết kế sạch sẽ và được cấu trúc tốt, Metal 2 mở rộng để bao gồm nhiều cách tiên tiến hơn để truy cập các khả năng của GPU, chẳng hạn như kết xuất dựa trên GPU, cho phép GPU gửi khối lượng công việc đồ họa đến chính nó, tăng hiệu quả hơn nữa và giảm chi phí cuộc gọi rút thăm lên đến 10 lần.

Vào năm 2015, Metal đã mở rộng để hỗ trợ Mac và GPU máy tính để bàn.

Giờ đây, Metal 2 căn chỉnh API để hiển thị các tính năng chính một cách thống nhất, bất kể kiến trúc GPU cơ bản.

Với sự phát triển của học máy trên nhiều lĩnh vực khác nhau, Metal 2 mang đến một bộ chức năng rộng hơn và phức tạp hơn nhằm tăng tốc các hoạt động suy luận để cải thiện hiệu suất và hiệu quả.

Metal 2 cũng mang đến một bộ công cụ tối ưu hóa mới giúp bạn dễ dàng khai thác một cách chuyên nghiệp sức mạnh của GPU trên nền tảng Apple.

Và bây giờ, chúng tôi có thể tiết lộ nhiều khả năng Metal 2 hơn mà chúng tôi đã không công bố tại WWDC.

Metal 2 bao gồm một tập hợp các tính năng mới mạnh mẽ thể hiện khả năng độc đáo của GPU do Apple thiết kế trong chip dòng A mới nhất của chúng tôi, A11.

Trước khi chúng ta đi vào chi tiết về kiến trúc và tính năng GPU A11, chúng ta hãy xem lại kiến trúc của GPU cổ điển và kiến trúc kết xuất hoãn lại dựa trên ô.

Đây là một sơ đồ đơn giản hóa của kiến trúc GPU cổ điển.

GPU là những cỗ máy song song ồ ạt.

Các giai đoạn đỉnh và đoạn được thể hiện trong sơ đồ này được sao chép nhiều lần và chúng chạy song song.

Ngoài ra còn có nhiều tối ưu hóa như phân cấp bộ nhớ cache, FIFO, kiểm tra độ sâu thô ban đầu, v.v., không được hiển thị trong sơ đồ này.

Về cơ bản, GPU với kiến trúc cổ điển lấy nguyên thủy và tạo ra chiều sâu, màu sắc, bộ đệm dữ liệu và kết cấu.

Một trong những đặc điểm xác định của kiến trúc này là đầu ra của giai đoạn đỉnh cung cấp trực tiếp vào giai đoạn phân đoạn.

Chúng ta hãy xem xét kiến trúc kết xuất hoãn lại dựa trên ô, còn được gọi là TBDR.

Tất cả các GPU dòng A đều dựa trên kiến trúc TBDR.

TBDR thực hiện một số thay đổi đáng kể đối với kiến trúc GPU cổ điển.

Sự khác biệt lớn đầu tiên là giai đoạn đỉnh không được đưa trực tiếp vào giai đoạn phân đoạn.

Thay vào đó, khi chúng ra khỏi giai đoạn đỉnh, các nguyên thủy được binned vào các ô nhỏ được căn chỉnh trên màn hình và được lưu trữ vào bộ nhớ.

Sự thay đổi này cho phép giai đoạn đỉnh chạy không đồng bộ so với giai đoạn phân đoạn.

Trong khi chạy giai đoạn phân đoạn của đường kết xuất, song song, phần cứng thực hiện giai đoạn đỉnh của đường kết xuất trong tương lai.

Chạy giai đoạn đỉnh không đồng bộ cung cấp những cải tiến hiệu suất đáng kể.

Giai đoạn đỉnh thường sử dụng nhiều phần cứng chức năng cố định, trong khi giai đoạn phân đoạn là người sử dụng nhiều toán học và băng thông.

Hoàn toàn chồng chéo chúng cho phép chúng tôi sử dụng tất cả các khối phần cứng trên GPU cùng một lúc.

Việc các nguyên thủy được đóng thùng vào các ô cho phép chúng ta xử lý tất cả các nguyên thủy trong một ô cùng nhau.

Hãy để chúng tôi xem làm thế nào chúng tôi có thể tận dụng điều đó.

Chúng tôi đặt các bộ đệm có kích thước gạch, độ phân giải đầy đủ, độ sâu, khuôn tô và khung trên chip bên cạnh lõi đổ bóng của chúng tôi.

Chúng tôi gọi đây là bộ nhớ gạch bộ nhớ.

Có ba đặc điểm quan trọng của bộ nhớ lát gạch.

Đầu tiên, băng thông giữa lõi đổ bóng và bộ nhớ gạch cao hơn nhiều lần so với băng thông giữa GPU và bộ nhớ ngoài, và tỷ lệ thuận với số lượng lõi đổ bóng.

Thứ hai, độ trễ truy cập bộ nhớ vào bộ nhớ gạch thấp hơn nhiều lần so với độ trễ truy cập vào bộ nhớ ngoài.

Cuối cùng, bộ nhớ gạch tiêu thụ năng lượng thấp hơn đáng kể so với bộ nhớ ngoài.

TBDR sử dụng bộ nhớ có độ trễ thấp, tiêu thụ năng lượng thấp, băng thông cao này cho hai tối ưu hóa chính.

Đầu tiên, bộ nhớ độ sâu/stencil của gạch cho phép phần cứng tạo ra thông tin bộ đệm chiều sâu và stprint đầy đủ cho các đối tượng mờ đục trước khi lõi che bóng bắt đầu xử lý chúng, điều này cho phép phần cứng loại bỏ hoàn hảo các mảnh vỡ bị che khuất trước khi gửi đến lõi đổ bóng.

Nếu bộ đệm độ sâu không cần thiết cho các lần kết xuất tiếp theo, bộ đệm độ sâu kích thước đầy đủ có thể được loại bỏ hoàn toàn thông qua việc sử dụng các mục tiêu kết xuất không bộ nhớ, tiết kiệm một lượng lớn băng thông bộ nhớ, dung lượng lưu trữ và năng lượng.

Thứ hai, bộ nhớ gạch được sử dụng để lưu trữ bộ đệm màu trên chip.

Các hoạt động pha trộn rất nhanh vì chúng không cần truy cập vào bộ đệm khung có kích thước đầy đủ trên bộ nhớ ngoài.

Bộ nhớ ô chỉ được ghi một lần, sau khi toàn bộ ô được xử lý và tiết kiệm một lượng đáng kể năng lượng, hiệu suất và băng thông.

Công suất phòng cao hơn đạt được nhờ bộ nhớ nhanh hơn này.

Tính năng tìm nạp bộ đệm khung cho phép bạn thực hiện pha trộn tùy chỉnh và cho phép một số kỹ thuật nâng cao.

Kết hợp với bộ đệm khung không bộ nhớ, nhiều kỹ thuật trong số này cũng không cần sử dụng bộ nhớ ngoài.

Kết quả là, TBDR mang lại hiệu suất tuyệt vời ngay cả khi băng thông bị hạn chế.

TBDR tiêu thụ năng lượng thấp hơn nhiều, điều này rất cần thiết cho các thiết bị chạy bằng pin.

Bây giờ chúng ta hãy chuyển bánh răng sang GPU A11.

Trên A11, thay đổi lớn đầu tiên mà chúng tôi thực hiện đối với kiến trúc GPU là cung cấp cho bạn quyền kiểm soát trực tiếp dữ liệu nằm trong bộ nhớ gạch từ các chức năng phân đoạn của bạn.

Các khối hình ảnh cung cấp quyền truy cập được tối ưu hóa vào dữ liệu hình ảnh nằm trong bộ nhớ ô.

Bạn sẽ có thể bố trí các điểm ảnh theo cách có ý nghĩa với ứng dụng của mình, nhưng vẫn có thể được hiển thị một cách hiệu quả.

Khối hình ảnh là cấu trúc dữ liệu 2D trong bộ nhớ ô.

Bạn có thể chỉ định chiều rộng, chiều cao, chiều sâu và định dạng của nó.

Metal 2 thêm các định dạng pixel kết cấu vào ngôn ngữ đổ bóng để cung cấp cho bạn toàn quyền kiểm soát bố cục pixel thông qua các loại dữ liệu được đóng gói.

Thay đổi kiến trúc lớn thứ hai cho phép bạn truy cập vào tất cả các điểm ảnh được lưu trữ trong bộ nhớ gạch cùng một lúc.

Ngói bóng là giai đoạn lập trình mới trong GPU A11 của Apple cung cấp khả năng tính toán nội tuyến trong các đường kết xuất.

Bóng gạch cho phép một cấp độ hiệu suất và hiệu quả hoàn toàn mới trong Metal 2.

Các hoạt động kết xuất và tính toán hiện có thể chia sẻ dữ liệu thông qua băng thông cao hơn, độ trễ thấp hơn và bộ nhớ gạch công suất thấp hơn.

Bóng gạch được tích hợp sâu với các khối hình ảnh.

Bạn sẽ có thể phân tích nội dung khối hình ảnh, tóm tắt nội dung đó, lưu trữ khối hình ảnh giữa cảnh và thậm chí thay đổi bố cục khối hình ảnh.

Bạn cũng có thể sử dụng bộ nhớ nhóm luồng giống như một hạt nhân tính toán thông thường.

Đối với bộ đổ bóng gạch, bộ nhớ nhóm luồng là liên tục.

Mỗi lần gọi liên tiếp của bộ đổ bóng ô có thể hoạt động trên bộ nhớ nhóm luồng, bắt đầu với các giá trị còn lại từ bộ đổ bóng ô trước đó.

Điều này cũng đúng với bộ nhớ imageblock.

Chúng liên tục giữa các lần gọi của gạch và các bộ đổ bóng mảnh.

Ngoài ra, chúng tôi đang giới thiệu một phiên bản nâng cao của các nhóm thứ tự raster hỗ trợ imageblock và đổ bóng gạch.

Và cuối cùng, chúng tôi đang mở rộng ngôn ngữ đổ bóng kim loại để cung cấp cho bạn toàn quyền kiểm soát phạm vi bao phủ mẫu cho các khối hình ảnh đa mẫu.

Hãy để chúng tôi xem một bộ kỹ thuật kết xuất có thể tận dụng tối đa kiến trúc mới và các tính năng Metal 2 mới.

Bộ đổ bóng ô, khối hình ảnh và nhóm thứ tự raster là một cách tuyệt vời để kết hợp các đường chuyền xen kẽ, kết xuất và tính toán thành một đường chuyền kết hợp duy nhất.

Kết xuất hoãn lại và kết xuất chuyển tiếp lát gạch có thể được tăng tốc theo cách này.

Hãy để chúng tôi xem xét việc triển khai chuyển tiếp lát gạch làm ví dụ.

Bạn có thể vượt qua hình học để tạo thông tin độ sâu trên chip trước, sau đó chạy bộ đổ bóng gạch để tạo thông tin độ sâu tối thiểu tối đa cho mỗi ô, chạy bộ đổ bóng gạch khác để tạo danh sách ánh sáng bị loại bỏ trong bộ nhớ nhóm luồng và sau đó chạy bộ đổ bóng vật liệu của bạn.

Tất cả các hoạt động này có thể được thực hiện trong một lần kết hợp, tăng hiệu suất bằng cách loại bỏ một lượng lớn băng thông, dung lượng lưu trữ và năng lượng.

Các tính năng này cũng cho phép triển khai hiệu quả độ trong suốt độc lập với thứ tự, pha trộn alpha nhiều lớp và tán xạ dưới bề mặt.

Kiểm soát vùng phủ sóng mẫu, đổ bóng gạch và khối hình ảnh cho phép các cách hiệu quả hơn nhiều để thực hiện các giải quyết MSAA tùy chỉnh, ánh xạ tông màu MSAA và tổng hợp bề mặt.

Để cho thấy một số trường hợp sử dụng này có thể được tăng tốc như thế nào, chúng tôi đang phát hành mã mẫu để kết xuất hoãn lại, lát gạch về phía trước, pha trộn alpha nhiều lớp và tổng hợp bề mặt.

Metal 2 trên A11 nâng cao kiến trúc TBDR bằng cách giới thiệu các khối hình ảnh, bộ đổ bóng gạch, kiểm soát vùng phủ sóng mẫu khối hình ảnh và các nhóm thứ tự raster.

Ngoài ra, chúng tôi đã giới thiệu các thay đổi ngôn ngữ đổ bóng kim loại mới để cung cấp cho bạn các cơ chế mới và hiệu quả để chia sẻ dữ liệu giữa các luồng tính toán và nhóm luồng của bạn.

Hãy để chúng tôi xem xét ngắn gọn những điều này và các tính năng bổ sung khác và cải tiến hiệu suất trên A11.

Hãy để chúng tôi bắt đầu với các khối hình ảnh.

Khối hình ảnh là cấu trúc dữ liệu 2D trong bộ nhớ ô.

Các chức năng phân mảnh chỉ có thể truy cập một pixel duy nhất tương ứng với vị trí của nó, trong khi hạt nhân có thể truy cập toàn bộ khối hình ảnh.

Mỗi điểm ảnh có thể khá phức tạp, bao gồm nhiều thành phần và mỗi thành phần có thể được giải quyết dưới dạng mặt phẳng hình ảnh riêng của nó.

Imageblocks cũng cung cấp quyền truy cập hàng loạt vào phần cứng chuyển đổi định dạng của GPU.

Các điểm ảnh dấu phẩy động sẽ được chuyển đổi sang định dạng kết cấu đích khi được lưu trữ vào bộ nhớ thiết bị.

Bộ đổ bóng ô cung cấp khả năng tính toán nội tuyến trong các lần kết xuất.

Bộ đổ bóng ô có thể truy cập toàn bộ khối hình ảnh và giống như các hạt nhân tính toán thông thường, chúng có hỗ trợ bộ nhớ nhóm luồng.

Không giống như bộ nhớ nhóm luồng của hạt nhân tính toán, bộ nhớ nhóm luồng của bộ đổ bóng ô tồn tại trong suốt vòng đời của ô, giống như dữ liệu màu vẫn tồn tại qua các lần vẽ.

Vì vậy, trước đây bạn bị giới hạn trong việc giao tiếp giữa các lần vẽ trong phạm vi pixel bằng cách sử dụng tính năng tìm nạp bộ đệm khung, giờ đây bạn có thể giao tiếp giữa các công văn gạch và các cuộc gọi vẽ phân đoạn bằng cách sử dụng phạm vi ô rộng hơn.

Bây giờ chúng ta hãy xem xét cách A11 cải thiện MSAA so với các thế hệ trước.

GPU dòng A của Apple có triển khai MSAA rất hiệu quả.

Khi đoạn không phải là một đoạn cạnh, việc pha trộn phần cứng sẽ thực hiện một lần trên mỗi đoạn, không phải một lần trên mỗi mẫu.

Ngoài ra, bạn có thể giải quyết trực tiếp từ bộ nhớ gạch đến tệp đính kèm giải quyết và tránh phát sinh băng thông bộ nhớ bổ sung.

Thông qua việc sử dụng tính năng mục tiêu kết xuất không bộ nhớ của Metal, bạn cũng có thể loại bỏ hoàn toàn bộ nhớ mục tiêu kết xuất MSAA.

Với Metal 2 trên A11, chúng tôi đã đưa MSAA đi xa hơn nữa.

Trong khi các GPU dòng A hiện tại của chúng tôi đã theo dõi các cạnh trong một pixel, GPU A11 mở rộng theo dõi này đến độ chi tiết thậm chí còn mịn hơn bằng cách theo dõi số lượng mẫu duy nhất trong mỗi pixel.

Sự thay đổi phần cứng này làm cho các ứng dụng đa mẫu của bạn nhanh hơn mà không yêu cầu bất kỳ thay đổi nào đối với ứng dụng của bạn.

Với A11, Metal 2 cũng cung cấp cho bạn toàn quyền kiểm soát siêu dữ liệu theo dõi này với kiểm soát vùng phủ sóng mẫu imageblock.

Bạn cũng có thể tận dụng tính năng này kết hợp với khối hình ảnh nhóm chủ đề và đổ bóng gạch.

Với kiểm soát vùng phủ sóng mẫu imageblock, đường ống gạch của bạn có thể sửa đổi dữ liệu theo dõi vùng phủ sóng mẫu của GPU, cho phép bạn giải quyết dữ liệu mẫu bất cứ lúc nào trong quá trình kết xuất với thuật toán giải quyết tùy chỉnh của riêng bạn.

Các nhóm thứ tự Raster cho phép bạn truy cập bộ nhớ từ các hàm phân đoạn chồng chéo theo thứ tự gửi và cho phép các hàm phân đoạn giao tiếp.

A11 mở rộng chức năng của các nhóm thứ tự raster.

Đầu tiên, A11 hiển thị bộ nhớ lát gạch bên trong của GPU.

Các nhóm thứ tự Raster làm cho bộ nhớ gạch hữu ích hơn bằng cách cấp cho bạn quyền truy cập vào nó theo thứ tự có thể dự đoán được.

Thứ hai, khi các nhóm thứ tự raster trên các GPU khác chỉ giới hạn ở một mutex trên mỗi pixel, A11 có thể chi tiết hơn thế, cho phép chạm nhẹ hơn và giảm thiểu tần suất các luồng của bạn đang chờ truy cập.

Bây giờ chúng ta hãy xem Metal 2 tăng tốc độ chia sẻ dữ liệu giữa các luồng và nhóm luồng.

Ngôn ngữ đổ bóng Metal 2 mở rộng các hàm nguyên tử với thứ tự bộ nhớ và thuộc tính phạm vi.

Những bổ sung mới này cho phép những cách mới để chia sẻ dữ liệu linh hoạt và hiệu quả giữa các luồng.

Trước Metal 2, để giao tiếp giữa các nhóm luồng yêu cầu hoàn thành việc thực thi hạt nhân và phát hành một hạt nhân mới để tiêu thụ đầu ra của các nhóm luồng của hạt nhân đầu tiên.

Trên Metal 2, các nhóm chủ đề có thể giao tiếp trực tiếp với nhau.

Ngoài ra, với việc bổ sung các tính năng mới này, các luồng trong một nhóm luồng có thể giao tiếp mà không cần sử dụng rào cản dẫn đến hiệu suất được cải thiện.

Chúng tôi cũng đã thêm một số tính năng và khả năng quan trọng khác vào Metal 2 trên A11.

Trên A11, toán học f16 có độ chính xác tổng thể tốt hơn thông qua các cải tiến để làm tròn và xử lý giá trị tối đa.

A11 bổ sung hỗ trợ cho các mảng khối kết cấu và giới thiệu chức năng kết cấu đọc-ghi.

Với A11, một loạt các vùng phủ sóng lấy mẫu đến với GPU dòng A.

A11 bổ sung tính năng bảo hiểm sau độ sâu và cung cấp một cách linh hoạt hơn để gửi hạt nhân tính toán.

A11 cũng bổ sung hỗ trợ cho các hoạt động permute có phạm vi bốn.

Để biết thêm chi tiết về các tính năng này, vui lòng kiểm tra tài liệu Metal 2.

A11 thực hiện nhiều cải tiến hiệu suất đáng kể cho GPU.

Nó có hiệu suất toán học lên đến 2X khi nói đến các nhiệm vụ cho thị giác máy tính, xử lý hình ảnh và học máy.

Nhưng đó không phải là lĩnh vực cải tiến duy nhất cho hiệu suất.

Hãy để chúng tôi xem xét hiệu suất và khả năng được cải thiện của GPU A11.

Chúng tôi đã tăng gấp đôi tốc độ lọc toán học và kết cấu F16 trên mỗi chu kỳ xung nhịp khi so sánh với GPU A10.

Xin lưu ý: Trên A11, việc sử dụng các kiểu dữ liệu F16 trong bộ đổ bóng của bạn khi có thể tạo ra sự khác biệt hiệu suất lớn hơn nhiều.

Chúng tôi đã tăng gấp đôi kích thước nhóm luồng tối đa từ 512 lên 1K trên A11.

Kích thước mục tiêu nhiều kết xuất tối đa tăng từ 256 bit lên 512 bit.

Kích thước bộ nhớ nhóm luồng tối đa tăng gấp đôi từ 16K lên 32K.

Chúng tôi cũng đã cải thiện đáng kể hiệu suất của các hoạt động phản hồi.

Chúng còn được gọi là kiểm tra alpha và loại bỏ.

Để biết thêm thông tin về Metal 2 và các liên kết đến mã mẫu, vui lòng truy cập trang web của nhà phát triển tại developer.apple.com/metal.

Cảm ơn bạn đã xem!