608

Jaap van Muijden: Chào mừng đến với Metal Enhancements cho A13 Bionic.

Tên tôi là Jaap van Muijden, từ nhóm Phần mềm GPU tại Apple.

Hôm nay tôi sẽ giới thiệu cho bạn GPU mới nhất do Apple thiết kế trong A13 Bionic và các tính năng Metal mới mà nó cho phép.

Sau đó tôi sẽ chỉ cho bạn cách sử dụng các tính năng đó để giảm mức sử dụng bộ nhớ của ứng dụng và tối ưu hóa hiệu suất thời gian chạy của nó.

A13 Bionic mới tiếp tục sự phát triển nhanh chóng của GPU do Apple thiết kế bằng cách tập trung vào ba lĩnh vực chính: hiệu suất chung, cải tiến kiến trúc đáp ứng tốt hơn nhu cầu phát triển của các ứng dụng hiện đại và các tính năng Metal tiên tiến.

Hãy cùng xem qua từng cái.

GPU trong A13 Bionic nhanh hơn gần ba lần so với A10 Fusion về hiệu suất chung và được xây dựng dựa trên những cải tiến hiệu suất tuyệt vời của GPU A11 và A12 Bionic.

Các ứng dụng hiện tại chạy nhanh hơn trên A13 và có thể hoàn thành từng khung hình trong thời gian ngắn hơn, từ đó dẫn đến tiết kiệm năng lượng và sử dụng ứng dụng mở rộng.

Kiến trúc GPU do Apple thiết kế đã nhanh chóng phát triển để đáp ứng tốt hơn nhu cầu của các ứng dụng hiện đại.

Bắt đầu với A11, tốc độ dấu phẩy động và kết cấu 16 bit đã được tăng lên để giảm bớt các tắc nghẽn phổ biến trong trò chơi và độ chính xác số của các hoạt động dấu phẩy động 32 bit đã được cải thiện để xử lý tốt hơn khối lượng công việc tính toán nâng cao.

GPU A12 cải thiện đáng kể băng thông bộ nhớ bằng cách nén và giải nén nội dung kết cấu đến và đi từ bộ nhớ một cách không mất dữ liệu.

Nó cũng bổ sung phần cứng chuyên dụng để hỗ trợ giao diện người dùng, đảm bảo thời gian phản hồi nhanh hơn, nhưng cũng giảm tác động của các yếu tố giao diện người dùng đối với các ứng dụng tiền cảnh.

Và A12 và các GPU mới hơn nâng cao trải nghiệm iPad bằng cách chia sẻ tài nguyên của nó giữa các ứng dụng hiệu quả hơn.

Và bây giờ chúng ta có GPU A13.

Kiến trúc GPU A13 cải thiện đáng kể việc xử lý nội dung dải động cao trên GPU, bằng cách tăng gấp đôi tốc độ hoạt động của dấu phẩy động 16 bit và thêm hỗ trợ cho các số nhỏ 16 bit để duy trì mức độ đen tốt hơn.

GPU A13 cũng cung cấp hỗ trợ tốt hơn đáng kể cho công việc tính toán độc lập thực hiện đồng thời với khối lượng công việc kết xuất.

Các GPU do Apple thiết kế đã hỗ trợ khả năng tính toán không đồng bộ này kể từ A9, nhưng GPU A13 đưa nó lên một tầm cao mới bằng cách thêm nhiều kênh phần cứng hơn và giảm thiểu tác động đến các tác vụ kết xuất nhạy cảm hơn về thời hạn.

Bây giờ trước khi chúng tôi mô tả các tính năng Metal mới của A13, chúng ta cũng hãy nhanh chóng tóm tắt lại một số tính năng chính của Metal được giới thiệu trên GPU A11 và A12.

Hãy bắt đầu với A11.

Bóng gạch, khối hình ảnh và bộ nhớ nhóm luồng liên tục đều là các tính năng được thiết kế để tận dụng rõ ràng kiến trúc kết xuất hoãn dựa trên ô của Apple và làm việc cùng nhau để tối ưu hóa việc sử dụng băng thông của nhiều kỹ thuật kết xuất hiện đại.

Các nhóm thứ tự Rasterization cho phép bạn quản lý các cấu trúc dữ liệu phức tạp, trên mỗi pixel trên GPU và điều khiển tốc độ màu tối ưu hóa việc sử dụng khử răng cưa đa mẫu trong các thuật toán kết xuất nâng cao.

Và bây giờ đến A12.

Kết xuất theo lớp cho phép mỗi nguyên thủy được kết xuất nhắm mục tiêu một lát cắt duy nhất của mảng kết cấu 2D, trong khi kết xuất đa cổng xem cho phép mỗi nguyên thủy làm tương tự cho tối đa 16 khung nhìn và hình chữ nhật cắt kéo.

Phản hồi Stencil cho phép mỗi đoạn thiết lập một giá trị tham chiếu stprint duy nhất cho các hiệu ứng nâng cao trên mỗi pixel, trong khi độ phân giải stprint cho phép tái sử dụng bộ đệm stprint trên các đường truyền MSAA và không phải MSAA.

Và mặc dù nén không mất dữ liệu được bật theo mặc định bất cứ khi nào có thể, Metal cũng cung cấp quyền kiểm soát trực tiếp đối với nén tại chỗ và giải nén kết cấu chế độ lưu trữ được chia sẻ khi cần đọc lại tối ưu.

Vì vậy, bây giờ hãy giới thiệu Apple GPU Family 6 mới hỗ trợ GPU A13.

Kết cấu thưa thớt cho phép phát trực tuyến kết cấu chất lượng cao hơn cho các trò chơi thế giới mở với ngân sách bộ nhớ cố định, bằng cách theo dõi các khu vực quan trọng nhất của mỗi kết cấu và sau đó chỉ ánh xạ các khu vực đó vào bộ nhớ.

Bản đồ tốc độ rasterization tập trung rasterization và đổ bóng chất lượng cao vào các khu vực hình ảnh quan trọng nhất, đồng thời giảm tốc độ ở nơi khác, tiết kiệm cả bộ nhớ và hiệu suất.

Sự khuếch đại đỉnh loại bỏ quá trình xử lý đỉnh dư thừa mà nếu không sẽ xảy ra với các kết xuất nhiều lớp chia sẻ hình học.

Các đường ống do GPU điều khiển cho phép bạn vẽ các cảnh lớn hơn và nhập vai hơn, và với bộ đệm đối số cấp 2, các ứng dụng có thể thực hiện khối lượng công việc do GPU điều khiển linh hoạt hơn bao giờ hết.

Hướng dẫn nhóm SIMD tối ưu hóa việc chia sẻ và đồng bộ hóa giữa các luồng của nhóm SIMD trong quá trình đổ bóng.

Và ASTC HDR mang lại khả năng nén mất dữ liệu chất lượng cao cho các kết cấu dải động cao, tiết kiệm bộ nhớ và băng thông đáng kể.

Hãy xem xét từng thứ này chi tiết hơn, bắt đầu với kết cấu thưa thớt.

Kết cấu thưa thớt là một tính năng hoàn toàn mới được giới thiệu trên GPU A13 cho phép bạn kiểm soát việc lưu trữ và cư trú của kết cấu Kim loại ở độ chi tiết tốt.

Kết cấu thưa thớt không hoàn toàn cư trú trong bộ nhớ.

Nhưng thay vào đó, bạn có thể phân bổ các phần của chúng trên một đống bộ nhớ đặc biệt được gọi là đống thưa thớt.

Ở đây bạn có thể thấy hai kết cấu thưa thớt có các phần dữ liệu của chúng được phân bổ trong một đống thưa thớt như vậy.

Một đống duy nhất có thể cung cấp dung lượng lưu trữ cho nhiều kết cấu thưa thớt, tất cả đều chia sẻ một nhóm bộ nhớ được phân bổ trước duy nhất.

Tất cả các kết cấu thưa thớt được chia thành các đơn vị được gọi là gạch thưa thớt, có cùng dấu chân bộ nhớ độc lập với độ phân giải kết cấu hoặc định dạng pixel.

Vậy các ứng dụng của tính năng này là gì?

Một trong số đó là phát trực tuyến kết cấu.

Phát trực tuyến kết cấu cho phép bạn hiển thị các cảnh cực kỳ lớn với dấu chân bộ nhớ cố định bằng cách chỉ tải các mipmap kết cấu cần thiết cho chế độ xem hiện tại.

Với phát trực tuyến kết cấu truyền thống, các mipmap riêng lẻ được tải khi được yêu cầu và bị loại bỏ khi không còn cần thiết hoặc khi các kết cấu quan trọng hơn cần bộ nhớ.

Phát trực tuyến kết cấu theo truyền thống quản lý cư trú kết cấu ở độ chi tiết mipmap.

Các cấp thấp nhất của kim tự tháp mipmap được giữ thường trú trong trường hợp yêu cầu mipmap chất lượng cao hơn, nhưng chưa được phát trực tuyến.

Nó có thể chưa khả dụng vì hoạt động tải chưa hoàn tất hoặc không đủ bộ nhớ phát trực tuyến được phân bổ.

Có sẵn mipmap cấp thấp nhất đảm bảo rằng luôn có một số dữ liệu hợp lệ để lấy mẫu, mặc dù nó có độ phân giải thấp hơn.

Tính năng kết cấu thưa thớt của Metal cải thiện mô hình phát trực tuyến kết cấu này theo hai cách.

Đầu tiên, kết cấu thưa thớt cung cấp bộ đếm truy cập kết cấu mà bạn có thể sử dụng để xác định tần suất truy cập từng vùng của kết cấu thưa thớt.

Điều này cho phép bạn ưu tiên tải kết cấu, vì các khu vực được trình kết xuất truy cập thường xuyên hơn thường hiển thị rõ hơn trong chế độ xem hiện tại.

Thứ hai, cư trú có thể được quản lý ở độ chi tiết gạch thưa thớt thay vì độ chi tiết mipmap.

Điều này cho phép bạn thậm chí còn hiệu quả hơn với bộ nhớ kết cấu của mình và cho phép chi tiết kết cấu dễ nhìn thấy hơn ở nơi nó được tính.

Kết hợp với nhau, kết cấu thưa thớt cho phép bạn phát trực tuyến chi tiết rõ ràng hơn với cùng ngân sách bộ nhớ, cải thiện chất lượng.

Bây giờ hãy xem cách bạn tạo và sử dụng các kết cấu thưa thớt trong Metal.

Để bắt đầu sử dụng kết cấu thưa thớt, trước tiên bạn tạo một đống thưa thớt và sau đó phân bổ một hoặc nhiều kết cấu từ nó.

Các kết cấu thưa thớt mới được tạo ra ban đầu mà không có bất kỳ ô thưa thớt nào được ánh xạ.

Bạn cần yêu cầu ánh xạ bộ nhớ từ đống bằng GPU.

Bộ nhớ được ánh xạ theo các đơn vị có kích thước ô được gọi là ô thưa thớt, tương tự như các trang bộ nhớ ảo.

Tương tự như vậy, bạn cần yêu cầu GPU hủy ánh xạ các ô khi chúng không còn cần thiết nữa.

Lấy mẫu một kết cấu thưa thớt hoạt động giống như một kết cấu thông thường và lấy mẫu các vùng chưa được ánh xạ trả về số không.

Cuối cùng, các bộ đếm truy cập kết cấu có thể được đọc lại từ một kết cấu thưa thớt, để ước tính tần suất mỗi ô được truy cập, để bạn có thể kiểm soát và ưu tiên chính xác khi bạn ánh xạ các ô cho kết cấu của mình.

Hãy xem xét từng bước này chi tiết hơn.

Ở đây chúng tôi có một số mã Kim loại tạo ra một đống kết cấu thưa thớt với kích thước bộ nhớ nhất định.

Đầu tiên chúng tôi tính toán kích thước của đống của mình và đảm bảo rằng nó là bội số của kích thước gạch thưa thớt.

Ở đây chúng tôi sử dụng chức năng trợ giúp cục bộ để làm tròn kích thước dữ liệu của chúng tôi đến bội số gần nhất của kích thước ô thưa thớt.

Sau đó, chúng tôi có thể tạo mô tả đống thưa thớt; chúng tôi đặt loại đống thành thưa thớt và chỉ định kích thước đống của chúng tôi tính bằng byte.

Sau đó, chúng tôi tạo ra đống thưa thớt bằng cách sử dụng đối tượng MTLDevice của chúng tôi.

Tạo ra một kết cấu thưa thớt rất dễ dàng.

Đầu tiên, chúng tôi tạo một bộ mô tả kết cấu như bình thường, và sau đó chúng tôi tạo kết cấu bằng cách sử dụng đối tượng đống thưa thớt.

Bây giờ chúng ta đã thấy cách bạn có thể tạo ra kết cấu thưa thớt, chúng ta hãy xem cách ánh xạ các vùng vào bộ nhớ.

Việc ánh xạ và hủy ánh xạ các vùng của một kết cấu được thực hiện bằng cách mã hóa các lệnh bản đồ và hủy ánh xạ trong bộ mã hóa lệnh trạng thái tài nguyên.

Bộ mã hóa này có thể được sử dụng để lên lịch các hoạt động bản đồ và hủy bản đồ trên dòng thời gian GPU, tương tự như mã hóa các lệnh kết xuất khác trong Metal.

Hãy xem cái này trông như thế nào trong mã.

Đầu tiên chúng ta tạo ra bộ mã hóa.

Và sau đó chúng tôi chỉ cần mã hóa một thao tác bản đồ; chúng tôi chỉ định kết cấu và vùng, lát cắt và mức mip nào của kết cấu mà chúng tôi muốn ánh xạ.

Khu vực hiện đã được ánh xạ và bạn có thể bật hoặc tạo dữ liệu kết cấu của mình vào bộ nhớ được ánh xạ.

Để hủy ánh xạ một phần, chúng tôi làm theo cùng một quy trình; sự khác biệt duy nhất là chế độ cập nhật mà chúng tôi mã hóa.

Bây giờ bạn đã tạo và ánh xạ dữ liệu kết cấu của chúng tôi, hãy chuyển sang lấy mẫu kết cấu thưa thớt.

Lấy mẫu từ một kết cấu thưa thớt không khác gì lấy mẫu từ một kết cấu bình thường.

Có hành vi được xác định rõ ràng trong trường hợp một phần chưa được ánh xạ được truy cập.

Lấy mẫu một vùng chưa được ánh xạ trả về một vectơ gồm các số 0 và mọi lần ghi đều bị loại bỏ.

Ngoài các chức năng lấy mẫu tiêu chuẩn, Metal cung cấp một hàm mẫu thưa thớt có thể được sử dụng trong các bộ đổ bóng để kiểm tra các vùng chưa được ánh xạ.

Bây giờ bạn đã thấy cách tạo, lập bản đồ và lấy mẫu kết cấu thưa thớt, hãy xem xét một cách triển khai đơn giản.

Một cách để lấy mẫu hiệu quả các kết cấu thưa thớt là thực hiện lấy mẫu dự phòng.

Trong bộ đổ bóng của bạn, trước tiên bạn có thể thử tìm nạp texels bằng phương thức sparse_sample và nếu không thành công, bạn có thể quay lại mipmap cấp thấp hơn.

Bằng cách luôn giữ cho mipmap thấp hơn được tải, bạn được đảm bảo tìm thấy một mẫu hợp lệ.

Và để hỗ trợ lấy mẫu dự phòng tốt hơn, ngôn ngữ đổ bóng kim loại cũng hỗ trợ một lập luận mới về các phương pháp kết cấu được gọi là kẹp LOD tối thiểu.

Kẹp LOD tối thiểu cho phép bạn đặt mipmap cao nhất trong chuỗi có thể truy cập được.

Điều này cho phép bạn đảm bảo một mẫu hợp lệ bằng cách chỉ định mipmap cao nhất mà bạn biết bạn có dữ liệu.

Hãy xem xét điều đó trong mã.

Ở đây chúng tôi có một bộ đổ bóng mảnh lấy mẫu từ một kết cấu thưa thớt.

Bạn bắt đầu lấy mẫu kết cấu thưa thớt của mình bằng cách sử dụng phương thức thưa_mẫu, phương thức này trả về một đối tượng màu thưa thớt.

Sau đó, bạn có thể gọi phương thức cư trú trên đối tượng được trả về để xác định xem GPU có lấy mẫu dữ liệu được ánh xạ hay không.

Nếu có, bạn lấy lại giá trị mẫu và trả lại.

Nếu không, bạn sẽ lấy mẫu lại kết cấu thưa thớt, nhưng lần này bằng kẹp LOD để buộc bộ lấy mẫu bỏ qua các mipmap cao hơn.

Vì bạn đảm bảo rằng mipmap này và mipmap thấp hơn có dữ liệu, cuộc gọi lấy mẫu thứ hai được thực hiện bằng phương pháp mẫu thông thường.

Bây giờ bạn đã thấy các chức năng để lập bản đồ và lấy mẫu dữ liệu kết cấu thưa thớt, hãy nói một chút về cách quyết định khi nào nên lập bản đồ hoặc các ô kết cấu thưa thớt miễn phí.

Các hệ thống phát trực tuyến kết cấu truyền thống thu thập thủ công số liệu thống kê cấp ứng dụng để giúp ưu tiên cư trú kết cấu.

Những phương pháp này thường thô ở mipmap hoặc độ chi tiết lưới để giúp quản lý chi phí.

Thay vào đó, kim loại hỗ trợ một giải pháp hạt mịn được gọi là bộ đếm truy cập kết cấu.

Các bộ đếm này theo dõi chính xác tần suất truy cập các ô thưa thớt bởi GPU với chi phí rất thấp.

Bộ đếm truy cập kết cấu được truy vấn từ GPU.

Hãy xem cái này hoạt động như thế nào.

Ví dụ Metal này sẽ thu thập các bộ đếm truy cập kết cấu từ GPU.

Bạn bắt đầu bằng cách tạo một bộ đệm để chứa các bộ đếm được lấy mẫu.

Và sau đó bạn mã hóa một blit để sao chép các bộ đếm từ kết cấu thưa thớt của chúng tôi sang bộ đệm của chúng tôi, chỉ định mức mip, lát cắt và khu vực bạn quan tâm.

Các kỹ thuật phát trực tuyến kết cấu truyền thống đã phục vụ chúng tôi rất tốt trong những năm qua và với ngân sách bộ nhớ cố định, chúng tôi có thể phát trực tuyến ở mức mip cho các kết cấu mà người dùng nhìn thấy.

Khi ngân sách kết cấu cạn kiệt, chúng ta không còn có thể phát trực tuyến ở mức mip có độ phân giải cao hơn và chúng ta bắt đầu thấy các kết cấu mờ đồng đều.

Nhưng với kết cấu thưa thớt, giờ đây bạn có thể sử dụng trí nhớ của mình tốt hơn.

Bạn có thể lập bản đồ bộ nhớ để nhường chỗ cho các ô kết cấu riêng lẻ mà người dùng nhìn thấy, ở mức chất lượng phù hợp nhất cho từng ô kết cấu trong một mức mip nhất định.

Điều này cho phép bạn phân phối bộ nhớ kết cấu cho các ô tạo ra tác động trực quan nhất.

Ngoài ra, tính năng này tiết kiệm băng thông khi phát trực tuyến kết cấu, vì API kết cấu thưa thớt cho phép bạn ánh xạ và hủy ánh xạ các ô riêng lẻ thay vì phải sao chép và sắp xếp lại toàn bộ chuỗi mipmap trong bộ nhớ trong khi phát trực tuyến.

Đó là nó cho kết cấu thưa thớt, một tối ưu hóa bộ nhớ thực sự quan trọng cũng sẽ cải thiện chất lượng phát trực tuyến kết cấu.

Bây giờ hãy chuyển sang kỹ thuật tối ưu hóa thời gian chạy được gọi là bản đồ tốc độ rasterization.

Bản đồ tốc độ Rasterization cho phép bạn sử dụng tốt hơn màn hình Retina bằng cách rasterizing và tô bóng các khu vực hình ảnh quan trọng nhất ở độ phân giải cao nhất, đồng thời giảm chất lượng ở những nơi không được cảm nhận.

Bản đồ tốc độ Rasterization cho phép bạn rasterize và tô bóng ở nhiều độ phân giải bằng cách xác định cả không gian màn hình và kích thước mục tiêu hiển thị vật lý và ánh xạ không đồng nhất giữa hai không gian, để kiểm soát chất lượng của từng khu vực.

Độ phân giải vật lý nhỏ hơn không gian màn hình, tiết kiệm băng thông và giảm dung lượng bộ nhớ.

Và ánh xạ không đồng nhất dẫn đến hình ảnh chất lượng cao hơn so với bản đồ cao cấp đồng nhất thường được sử dụng trong các trò chơi với một phần nhỏ chi phí hiển thị toàn bộ màn hình ở độ phân giải gốc.

Chúng ta hãy xem xét kỹ hơn cách thức hoạt động của nó.

Đây là ảnh chụp màn hình của một lớp khuếch tán từ bộ đệm g của trình kết xuất mẫu.

Kết xuất truyền thống vẽ hình học bằng cách tính toán tọa độ không gian màn hình của mỗi đỉnh, và sau đó rasterizing các nguyên thủy kết quả trong không gian màn hình để tạo ra các mảnh vỡ.

Các tọa độ không gian màn hình này có ánh xạ 1-1 đến tọa độ của mục tiêu kết xuất vật lý trong quá trình rasterization.

Với bản đồ tốc độ rasterization, bạn có thể định cấu hình rasterizer để ánh xạ tọa độ không gian màn hình không đồng đều khi tạo các đoạn, do đó giảm số lượng tổng số đoạn được tạo ra và đồng thời hiển thị đến mục tiêu kết xuất nhỏ hơn.

Trong cả hai hình ảnh, lưới trắng tương ứng với lưới cách đều nhau trong không gian màn hình ảo.

Nhưng như bạn có thể thấy ở đây, nó được phân bố không đồng đều trong không gian vật lý.

Trong ví dụ này, chúng tôi đã sử dụng bản đồ tốc độ rasterization để giữ độ phân giải màn hình ở giữa màn hình, nhưng giảm nó về phía các cạnh của màn hình.

Để thấy điều này rõ ràng hơn, hãy phóng to một trong những ô trung tâm.

Độ phân giải của ô vật lý này khớp với độ phân giải của cùng một vùng trong bộ đệm g.

Nhưng khi bạn di chuyển về phía cạnh của màn hình, chất lượng sẽ giảm đi bằng cách giảm hiệu quả không gian vật lý dành riêng cho ô đó.

Điều này dẫn đến một hình ảnh bị bóp méo trong hình ảnh vật lý của bạn, nhưng chúng tôi sẽ chỉ ra rằng ánh xạ này có thể được đảo ngược để tạo ra một hình ảnh cuối cùng không bị bóp méo.

Nhưng trước tiên, chúng ta hãy xem cách các ánh xạ được xác định.

Ánh xạ được định nghĩa là hai hàm 1D trong trục X và Y của không gian màn hình.

Bạn mô tả các chức năng này trong Metal bằng cách sử dụng một loạt các điểm kiểm soát xác định các yêu cầu chất lượng.

Trong hình ảnh này, chúng ta có thể thấy tốc độ rasterization hiệu quả trên màn hình, với hai hàm 1D của chúng ta dọc theo trục.

Mức chất lượng của một có nghĩa là bộ đổ bóng phân đoạn được gọi cho mọi điểm ảnh không gian màn hình dọc theo trục.

Và mức chất lượng .5 có nghĩa là đối với ít nhất 50 phần trăm các điểm ảnh, một bộ đổ bóng phân đoạn được gọi dọc theo một trục nhất định.

Mức chất lượng bằng không có nghĩa là mỗi bộ đổ bóng phân đoạn sẽ được gọi ở tốc độ tối thiểu được hỗ trợ bởi Metal.

Metal sẽ mẫu lại các điểm kiểm soát này để tạo bản đồ tỷ lệ cuối cùng.

Mặc dù bạn không kiểm soát trực tiếp bản đồ cuối cùng, Metal đảm bảo rằng chất lượng tối thiểu của bạn được giữ nguyên.

Bây giờ hãy tạo bản đồ này với Metal.

Đây là mã Kim loại xây dựng bản đồ tỷ lệ rasterization mà bạn vừa thấy.

Đầu tiên, bạn xác định hàm rasterization.

Trong ví dụ này, chúng tôi sẽ sử dụng năm giá trị mà chúng tôi đã hiển thị trước đây cho cả trục ngang và dọc của bản đồ của chúng tôi.

Sau đó, bạn điền vào bộ mô tả lớp để mô tả chất lượng trên bản đồ tỷ lệ rasterization của chúng tôi.

Sau đó, bạn tạo một cái bằng cách cung cấp các chức năng chất lượng ngang và dọc.

Với chất lượng của bạn được xác định, bây giờ bạn tạo một bộ mô tả bản đồ tốc độ rasterization Metal từ bộ mô tả lớp và độ phân giải không gian màn hình cuối cùng của chúng tôi.

Cuối cùng, bạn sử dụng thiết bị Metal của mình để khởi tạo đối tượng bản đồ tốc độ rasterization bằng cách sử dụng bộ mô tả đó.

Tiếp theo chúng ta cần tạo mục tiêu kết xuất vật lý cho bản đồ này.

Bởi vì tốc độ bản đồ tỷ lệ rasterization thực tế phụ thuộc vào việc triển khai, trước tiên bạn cần truy vấn kích thước vật lý của tài nguyên từ bản đồ.

Sau đó, bạn tạo mục tiêu kết xuất vật lý như bình thường: chỉ định các thuộc tính lưu trữ và sử dụng chính xác và khởi tạo kết cấu bằng đối tượng thiết bị Kim loại của bạn.

Cuối cùng, bạn kết hợp kết cấu đã tạo và bản đồ rasterization để thiết lập đường chuyền kết xuất và kết xuất như bình thường.

Và với điều đó, bạn đã rasterized bộ đệm g của mình một cách không đồng đều.

Nhưng còn việc tô bóng bộ đệm g trong các đường chuyền sau thì sao?

Với đường ống tạo bóng hoãn truyền thống, bạn có thể tiếp tục chiếu sáng với cùng một bản đồ tốc độ rasterization vì hình học ánh sáng của bạn sẽ được rasterized chính xác trong cùng một không gian màn hình với bộ đệm g của bạn.

Với trình kết xuất hoãn lát gạch, bạn sẽ cần phải làm thêm một chút công việc.

Nếu bạn chưa quen thuộc với kết xuất hoãn lát gạch, vui lòng xem buổi nói chuyện Kết xuất hiện đại với kim loại của chúng tôi tại WWDC 2019.

Với gạch bị trì hoãn, không gian vật lý của mục tiêu kết xuất của bạn được chia thành các khối pixel có kích thước bằng nhau và mỗi khối thực hiện loại bỏ và tô bóng gạch nhẹ.

Trong hình ảnh được trình bày, mã mẫu của chúng tôi hiển thị bản đồ nhiệt cho số lượng đèn trên mỗi khối là 32 x 32 pixel.

Bởi vì không gian màn hình không còn tương ứng với không gian vật lý, việc tích hợp bản đồ tốc độ rasterization với các trình kết xuất hoãn lát gạch yêu cầu một bước bổ sung.

Bộ đổ bóng ánh sáng sẽ cần chuyển đổi tọa độ điểm ảnh trong không gian vật lý thành không gian màn hình ảo.

Đây là ánh xạ ngược được sử dụng trong quá trình rasterization.

Hãy xem cách bạn có thể thực hiện ánh xạ ngược này trong bộ đổ bóng của mình.

Trước tiên, bạn phải làm cho các thông số bản đồ tốc độ rasterization có thể truy cập được đối với bộ đổ bóng.

Để làm điều này, trước tiên bạn tạo một MTLBuffer có thể giữ các tham số.

Sau đó bạn sao chép dữ liệu tham số vào MTLBuffer.

Và cuối cùng, liên kết MTLBuffer với shader của bạn.

Bây giờ bản đồ đã bị ràng buộc, hãy sử dụng nó.

Trong bộ đổ bóng, bây giờ bạn có quyền truy cập vào đối tượng rasterization_rate_map_data tại điểm liên kết bộ đệm tương ứng.

Bạn có thể sử dụng đối tượng đó để khởi tạo một đối tượng rasterization_rate_map _decoder.

Và sau đó sử dụng bộ giải mã để chuyển đổi giữa tọa độ vật lý và tọa độ màn hình.

Quay trở lại trình kết xuất hoãn lát gạch của chúng tôi, chúng tôi sử dụng bộ giải mã để thực hiện loại bỏ ô trong không gian màn hình ảo.

Điều chỉnh việc loại bỏ ánh sáng của bạn thành không gian màn hình ảo có nghĩa là các ô của bạn không còn vuông nữa, nhưng bây giờ hãy đi theo đúng khu vực trong không gian màn hình.

Hãy so sánh bản đồ nhiệt này với kết xuất độ phân giải đầy đủ, đồng đều.

Và quay lại phiên bản bản đồ tỷ lệ rasterization.

Như bạn có thể thấy, với bản đồ tốc độ rasterization, chúng tôi đã giảm đáng kể số lượng ô được tô bóng trên màn hình của mình.

Cuối cùng, hãy xem xét cách các bản đồ tỷ lệ rasterization được chuẩn bị cho việc tổng hợp và trình bày cuối cùng.

Trước khi hiển thị hình ảnh cuối cùng lên màn hình, bạn cần mở gói nó bằng cách sử dụng đường chuyền toàn màn hình để biến kết cấu không gian vật lý thành bề mặt có độ phân giải cao bằng cách sử dụng ánh xạ đổ bóng vừa được mô tả.

Như bạn có thể thấy, rất khó để nhận thấy sự đánh đổi chất lượng bất chấp sự sụt giảm mạnh mẽ đã được chọn cho mẫu này.

Chúng tôi hy vọng các bản đồ tỷ lệ rasterization sẽ được kết hợp với các kỹ thuật khác, chẳng hạn như độ sâu trường ảnh, để che giấu sự đánh đổi chất lượng.

Đó là nó cho bản đồ tỷ lệ rasterization.

Hãy chuyển sang khuếch đại đỉnh.

Bộ khuếch đại đỉnh cho phép bạn giảm xử lý hình học trong các trường hợp kết xuất đa chế độ xem.

Kết xuất nhiều lớp và đa cổng xem làm giảm số lượng cuộc gọi vẽ cần thiết để nhắm mục tiêu mỗi chế độ xem bằng cách sử dụng instancing.

Nhưng điều đó không loại bỏ chi phí GPU xử lý từng trường hợp này.

Nhiều kỹ thuật kết xuất đa lớp và đa khung nhìn chia sẻ hình học giữa các chế độ xem.

Ví dụ, giữa các tầng của bản đồ bóng tối hoặc các cạnh của bản đồ môi trường.

Mỗi trường hợp đó thường biến đổi hình học đó theo cách gần như giống nhau.

Vì vậy, mặc dù vị trí là duy nhất cho mỗi chế độ xem, các thuộc tính như chuẩn, tiếp tuyến và tọa độ kết cấu giống hệt nhau.

Bộ khuếch đại đỉnh cho phép bạn xử lý các thuộc tính được chia sẻ đó chỉ một lần, tăng hiệu quả của việc tô bóng đỉnh của bạn.

Hãy xem xét trường hợp sử dụng bản đồ bóng đổ xuống chi tiết hơn.

Tùy thuộc vào khoảng cách xem, trình kết xuất có thể chia bản đồ bóng của nó thành một, hai hoặc ba hoặc nhiều tầng bóng chồng chéo lên nhau.

Khi chúng tôi tăng số lượng thác, chúng tôi cũng tăng kích thước của thế giới ảo mà mỗi tầng bao phủ.

Điều này làm cho các thác lớn hơn, xa hơn tích lũy nhiều hình học hơn trong đó, so với các tầng gần hơn.

Và với nhiều tầng hơn, số lượng đối tượng hiển thị thành nhiều hơn một tầng tăng lên.

Bây giờ chúng ta hãy xem xét cách các bản đồ bóng đổ theo tầng được hiển thị theo truyền thống và các chi phí liên quan.

Trước khi kết xuất nhiều chế độ xem, bạn chỉ cần vẽ vào từng tầng riêng biệt.

Điều này làm tăng cả GPU và CPU trên cao.

Mỗi đỉnh phải được tìm nạp và tô bóng nhiều lần, và mỗi đỉnh cũng được xuất ra nhiều lần.

Kết xuất phiên bản đa chế độ xem sử dụng ID phiên bản để ánh xạ từng nguyên thủy đến chế độ xem đích của nó.

Nó loại bỏ chi phí CPU của nhiều lần gọi rút thăm, nhưng chi phí GPU vẫn giữ nguyên.

Sử dụng instancing để kết xuất theo lớp cũng làm phức tạp việc kết xuất hình học thể hiện thực tế, vì ID phiên bản hiện phải mã hóa cả ID phiên bản thực tế và lớp đích.

Sự khuếch đại đỉnh giúp loại bỏ việc tìm nạp, đổ bóng và đầu ra trùng lặp.

Nó cũng cung cấp một ID khuếch đại riêng biệt.

Chúng ta hãy xem xét sự khuếch đại đỉnh đang hoạt động.

Các hàm đỉnh hiện có có thể dễ dàng thích nghi với khuếch đại đỉnh.

Trong ví dụ này, chúng ta sẽ tính toán một vị trí duy nhất trên mỗi lần khuếch đại, nhưng chia sẻ tính toán màu sắc trên tất cả các khuếch đại.

Chúng tôi bắt đầu bằng cách khai báo VertexOutput của mình với hai thuộc tính.

Trình biên dịch thường có thể suy ra nếu một thuộc tính là duy nhất hoặc được chia sẻ, nhưng đối với các trình đổ bóng phức tạp, bạn cũng có thể rõ ràng về thuộc tính nào được chia sẻ.

Trình biên dịch sẽ báo cáo lỗi khi các phép tính thuộc tính được chia sẻ phụ thuộc vào ID khuếch đại.

Tiếp theo chúng tôi khai báo một đối số hàm giữ ID khuếch đại.

Bất kỳ tính toán nào liên quan đến ID này đều được khuếch đại cho mỗi lần gọi đổ bóng.

Thuộc tính màu sắc không được liên kết với ID đó nên nó sẽ chỉ được thực thi một lần.

Nhưng vị trí phụ thuộc vào ID để tra cứu ma trận chiếu chế độ xem chính xác, và do đó toàn bộ biểu thức được khuếch đại.

Đó là nó cho mã đổ bóng.

Bây giờ hãy xem cách chúng tôi thiết lập các cuộc gọi rút thăm khuếch đại.

Hãy bắt đầu bằng cách tạo một đối tượng trạng thái đường ống cho phép khuếch đại.

Hệ số khuếch đại tối đa được hỗ trợ bởi Metal có thể được truy vấn từ thiết bị.

Trong trường hợp này, giả sử bạn muốn có hệ số khuếch đại là hai.

Nếu được hỗ trợ, bạn đặt thành hệ số khuếch đại tối đa cho đường ống.

Nếu không được hỗ trợ, bạn có thể quay lại chế độ xem đa dạng truyền thống thông qua việc tham gia hoặc dựa vào việc thực hiện nhiều cuộc gọi rút thăm.

Cuối cùng, bạn tạo ra đường ống.

Khi đường ống được tạo và giả sử rằng khuếch đại được hỗ trợ, bạn có thể bắt đầu mã hóa các lần rút thăm của mình.

Vẽ với khuếch đại yêu cầu thiết lập số lượng khuếch đại và liên kết viewMappings.

viewMappings mô tả cách ánh xạ ID khuếch đại đến lớp đích hoặc khung nhìn.

Nếu trình đổ bóng đỉnh cũng xuất mục tiêu kết xuất hoặc chỉ mục mảng khung nhìn, chỉ mục đó sẽ đóng vai trò là phần bù cơ sở vào mảng viewMappings.

Bây giờ bạn có thể thiết lập khuếch đại mong muốn và mã hóa các lần rút thăm.

Chúng ta hãy xem xét kỹ hơn trình gỡ lỗi khung kim loại.

Trong kết xuất mẫu này, chúng tôi sử dụng VertexAmplification để khuếch đại tất cả các bản vẽ được kết xuất cho cả tầng 2 và 3.

Ở đây chúng ta thấy rằng cuộc gọi vẽ này được hiển thị với ViewMapping chỉ định hai mục tiêu kết xuất.

Lưới được hiển thị đồng thời thành tầng thứ hai được hiển thị ở bên trái và tầng thứ ba, được hiển thị cả ở bên phải và trong trình xem hình học.

Đó là nó để khuếch đại đỉnh.

Hãy chuyển sang bộ đệm đối số và cách chúng được mở rộng cho A13.

Chúng tôi đã giới thiệu bộ đệm đối số với Metal 2.

Bộ đệm đối số cho phép bạn mã hóa hằng số, kết cấu, bộ lấy mẫu và đối số bộ đệm vào MTLBuffers.

Bằng cách mã hóa tất cả các đối số vẽ của bạn thành một bộ đệm đối số Kim loại duy nhất, bạn có thể hiển thị các cảnh phức tạp với chi phí CPU tối thiểu.

Sau khi được mã hóa, bạn có thể sử dụng lại bộ đệm đối số để tránh liên kết tài nguyên dư thừa lặp đi lặp lại.

Bộ đệm đối số cũng cần thiết để kích hoạt các đường ống do GPU điều khiển, bằng cách cung cấp quyền truy cập vào toàn bộ đối số vẽ của cảnh trên GPU.

Sau đó, bạn có thể sửa đổi bộ đệm đối số trong các hàm tính toán để tự động định cấu hình cảnh của mình, đúng lúc.

Bộ đệm đối số cấp 2 tăng cường đáng kể khả năng của bộ đệm đối số.

Với A13, các hàm Metal của bạn có thể lấy mẫu hoặc ghi vào bất kỳ kết cấu nào trong bộ đệm đối số.

Bạn cũng có thể truy cập số lượng kết cấu hầu như không giới hạn và nhiều bộ lấy mẫu.

Và bộ đệm đối số bây giờ cũng có thể tham chiếu đến các bộ đệm đối số khác với nhiều cấp độ gián tiếp.

Điều này mở ra khả năng mã hóa một bộ đệm đối số duy nhất cho tất cả dữ liệu cảnh của bạn và truy cập nó trong bản vẽ của bạn mà không cần phải lắp ráp bộ đệm đối số trước thời hạn trên GPU hoặc CPU.

Hãy xem xét một ví dụ.

Đây là một hệ thống phân cấp mô hình đối tượng cảnh ví dụ.

Chúng tôi đã đưa ra một ví dụ tương tự tại buổi nói chuyện về Kết xuất Hiện đại với Kim loại của chúng tôi tại WWDC 2019.

Hệ thống phân cấp mô tả tất cả dữ liệu hình học, vật liệu và dữ liệu mô hình của bạn.

Với bộ đệm đối số, chúng ta có thể mã hóa trực tiếp mô hình đối tượng này.

Nhưng với sự hỗ trợ Cấp 2, chúng tôi cũng có thể sử dụng hệ thống phân cấp trực tiếp trong quá trình kết xuất.

Hãy cùng xem một ví dụ về shader.

Để bắt đầu, hãy nhớ lại rằng bộ đệm đối số của chúng tôi được khai báo trong ngôn ngữ đổ bóng kim loại dưới dạng cấu trúc của hằng số, kết cấu, bộ lấy mẫu và bộ đệm.

Những khai báo này phản ánh trực tiếp hệ thống phân cấp đối tượng ví dụ vừa được mô tả.

Đầu tiên là đại diện vật chất của chúng tôi, và thứ hai là cảnh của chúng tôi tham chiếu đến tập hợp các mắt lưới, vật liệu và mô hình.

Được rồi, vậy bây giờ chúng ta hãy xem xét một chức năng phân đoạn có thể tô màu trực tiếp bằng cách sử dụng cảnh của chúng ta.

Tham số hàm đầu tiên là bộ đệm đối số cảnh của chúng tôi.

Tham số hàm thứ hai là hằng số trên mỗi lần vẽ của chúng tôi.

Trong ví dụ này, nó mã hóa ID mô hình cho lần rút thăm này, cũng như mức độ chi tiết rời rạc, cả hai đều được chọn trong một đường chuyền tính toán trước đó.

Sau đó, chúng tôi sử dụng các ID này để lấy tài liệu của mình từ hiện trường bằng cách sử dụng các ID được tính toán trước đó.

Và chúng tôi tính toán màu phân đoạn bằng cách sử dụng kết cấu, hằng số và bộ lấy mẫu từ bộ đệm đối số lồng nhau.

Và thế là xong!

Không còn phải vượt qua tính toán can thiệp để thu thập các tham số vật liệu vào bộ đệm đối số trên mỗi lần vẽ.

Bộ đổ bóng phân đoạn chỉ sử dụng bộ đệm đối số cảnh trực tiếp.

Tuy nhiên, trước khi chúng ta tiếp tục, tôi muốn làm nổi bật sự hỗ trợ công cụ mạnh mẽ cho bộ đệm đối số.

Với bộ đệm đối số và đường ống điều khiển GPU, thiết lập cảnh của bạn chuyển sang GPU và bất kỳ việc gỡ lỗi nào cũng vậy.

Trình gỡ lỗi khung kim loại cho phép bạn dễ dàng gỡ lỗi và kiểm tra cả bộ đệm đối số và bộ đổ bóng sử dụng chúng.

Bạn có thể sử dụng trình xem bộ đệm để kiểm tra tất cả các tài nguyên trong bộ đệm đối số của mình và nhanh chóng chuyển đến các tài nguyên này để kiểm tra thêm.

Bạn cũng có thể sử dụng trình gỡ lỗi đổ bóng để hiểu cách trình đổ bóng của bạn đang truy cập hoặc xây dựng bộ đệm đối số.

Điều này đặc biệt quan trọng khi tính toán các chỉ số bộ đệm đối số hoặc sửa đổi bộ đệm đối số trên GPU.

Đó là nó cho bộ đệm đối số Cấp 2.

Bây giờ hãy chuyển sang một lớp kỹ thuật tối ưu hóa đổ bóng mới.

Các chức năng nhóm SIMD là một công cụ mạnh mẽ để tối ưu hóa các chức năng tính toán và đồ họa.

Chúng cho phép khối lượng công việc GPU chia sẻ dữ liệu và kiểm soát thông tin luồng bằng cách tận dụng kiến trúc của GPU.

Hãy giải nén điều đó bằng cách nhanh chóng xem lại mô hình thực thi SIMD trong Metal.

Metal luôn tổ chức các luồng thành các nhóm SIMD để khai thác Hướng dẫn duy nhất, nhiều bản chất dữ liệu của GPU.

Bạn có thể đã tận dụng các nhóm SIMD trong các chức năng tính toán Metal để giảm chi phí đồng bộ hóa toàn bộ nhóm luồng bằng cách sử dụng các rào cản nhóm SIMD thay thế.

Các luồng của một nhóm SIMD thực thi theo từng bước khóa, vì vậy không cần các rào cản thực thi.

Do đó, rào cản nhóm SIMD chỉ đồng bộ hóa các hoạt động của bộ nhớ.

Các chức năng của nhóm SIMD khai thác việc thực thi bước khóa này để chia sẻ dữ liệu giữa các luồng của nó bằng cách sử dụng thanh ghi thay vì bộ nhớ nhóm luồng và có thể cải thiện đáng kể hiệu suất khi bộ nhớ nhóm luồng bị ràng buộc.

Chúng cũng có sẵn cho cả chức năng tính toán và kết xuất.

Và như chúng ta sẽ thấy một chút, điều này cho phép một kỹ thuật tối ưu hóa kết xuất rất thú vị.

Trước tiên hãy bắt đầu bằng cách xây dựng một trực giác tốt hơn để thực thi SIMD với một ví dụ.

Ở phía bên trái, chúng tôi đại diện cho một nhóm SIMD là 32 làn xe bắt đầu bằng Làn đường 0.

Làn đường là một luồng duy nhất trong nhóm SIMD.

Bây giờ hãy làm cho nhóm SIMD này thực hiện một số công việc.

Đầu tiên chúng ta có tất cả các làn đường lập chỉ mục một mảng, A, theo laneID của nó và lưu trữ kết quả trong một biến X.

Lưu ý cách mỗi làn đường có giá trị X riêng.

Trong mô hình thực thi này, hướng dẫn tải dữ liệu từ A chỉ được tìm nạp một lần và được thực thi đồng thời bởi 32 luồng có chỉ mục riêng.

Bây giờ chúng ta đọc một mảng thứ hai, B, được lập chỉ mục bởi laneID và lưu trữ kết quả trong Y.

Cuối cùng chúng tôi lưu trữ kết quả nhân X và Y trong mảng thứ ba, C.

Vì lệnh được thực thi chỉ được tìm nạp một lần cho toàn bộ nhóm, tất cả các luồng nhóm SIMD thực thi theo bước khóa.

Các chức năng của nhóm SIMD cho phép mỗi luồng trong nhóm kiểm tra các giá trị đăng ký của toàn bộ nhóm SIMD với chi phí tối thiểu.

Khả năng này cho phép một số chức năng thú vị.

Đầu tiên hãy giới thiệu simd_max và áp dụng nó cho biến Y.

Mỗi luồng nhận được một giá trị Z với giá trị lớn nhất từ Y, như được thấy bởi bất kỳ luồng nào trong nhóm SIMD.

Tiếp theo chúng tôi đã phát sóng và áp dụng nó cho X.

Trong ví dụ này, chúng tôi phát sóng giá trị của Làn đường 0 cho tất cả các làn đường khác trong một thao tác duy nhất.

Metal cho A13 hỗ trợ nhiều chức năng SIMD hoạt động tương tự khác như xáo trộn, uốn và xoay trên tất cả các làn đường.

Đối với ví dụ cuối cùng của chúng tôi, chúng tôi sẽ xem xét simd_all, cho mỗi làn đường biết liệu một biểu thức có đánh giá giống nhau cho tất cả các làn đường hay không.

Trong ví dụ này, biến Z thực sự là chín cho tất cả các làn đường, và do đó chúng tôi trả về true.

Tương tự như vậy, simd_any cho biết liệu một biểu thức có đánh giá là đúng với bất kỳ làn đường nào hay không.

Bạn có thể sử dụng simd_all để giảm sự phân kỳ trong bộ đổ bóng của mình bằng cách chọn đi theo con đường tối ưu hơn khi tất cả các luồng đều có cùng nhu cầu.

Hãy xem xét một ví dụ.

Đây là trình đổ bóng phân đoạn của chúng tôi từ trước đó với một số tối ưu hóa sử dụng các chức năng của nhóm SIMD.

Tóm lại, hàm này lấy làm đầu vào cảnh được mã hóa dưới dạng bộ đệm đối số, đồng phục và đỉnh stage_in.

Thông thường, các chức năng chiếu sáng đánh giá các thành phần khác nhau của màu cuối cùng khác nhau đối với các mảnh trong suốt và do đó yêu cầu luồng điều khiển động tại các điểm khác nhau.

Bây giờ, thay vì đánh giá độ mờ đục cho mọi đoạn, ở đây chúng tôi sử dụng simd_all để kiểm tra động xem tất cả các luồng trong nhóm SIMD có đang tính toán ánh sáng cho các đoạn mờ đục hay không.

Nếu có, chúng ta sẽ đi theo một con đường tối ưu chỉ giả định các vật thể mờ đục.

Và nếu không, chúng ta quay trở lại con đường trước đó có thể thắp sáng cả những mảnh vỡ mờ đục và trong suốt.

Đó là nó cho các chức năng nhóm SIMD trên A13.

Hãy chuyển số và xem xét một số bổ sung thú vị cho ASTC trên A13.

Như đã đề cập trước đó trong video, GPU A13 tăng gấp đôi tốc độ hoạt động dấu phẩy động 16 bit và bổ sung hỗ trợ cho các số nhỏ 16 bit để xử lý xử lý HDR tốt hơn.

Các ứng dụng tận dụng những cải tiến này mà không cần bất kỳ sửa đổi nào; Xử lý HDR trên GPU chỉ trở nên nhanh hơn và chính xác hơn.

Apple Family 6 cũng bổ sung hỗ trợ cho một bộ định dạng pixel mới hỗ trợ lưu trữ và lấy mẫu dữ liệu HDR hiệu quả được gọi là ASTC HDR.

ASTC là một công nghệ nén kết cấu được hỗ trợ trên nhiều nền tảng, cung cấp chất lượng hình ảnh kết cấu cao ở một phần nhỏ băng thông và bộ nhớ.

Nó làm như vậy bằng cách hỗ trợ nhiều tốc độ bit và định dạng đầu vào.

Cấu hình dải động thấp ASTC đã được hỗ trợ kể từ Apple GPU Family 2 và thích hợp để nén các giá trị trong phạm vi từ 0 đến một.

Nếu ứng dụng của bạn chưa sử dụng ASTC để tiết kiệm bộ nhớ và băng thông, chúng tôi thực sự khuyến khích bạn làm như vậy.

Cấu hình dải động cao là cần thiết để mã hóa các giá trị độ sáng lớn hơn được tìm thấy trong hình ảnh HDR.

Không có ASTC HDR, những hình ảnh như vậy thường được lưu trữ ở định dạng pixel dấu phẩy động 16 bit với chi phí bộ nhớ cao hơn nhiều.

Vậy ASTC HDR có thể tiết kiệm được bao nhiêu dung lượng lưu trữ?

Rất nhiều.

Hãy xem xét một ví dụ.

Các trò chơi HDR thường sử dụng kết cấu bản đồ khối lập phương có độ phân giải thấp để thể hiện các bản đồ môi trường dải động cao để chiếu sáng cảnh của chúng và thường đặt nhiều đầu dò như vậy trên khắp thế giới hoặc cấp độ trò chơi.

Nếu không có ASTC HDR, mỗi đầu dò có thể tiêu thụ một lượng bộ nhớ đáng kể và tất cả các đầu dò như vậy có thể dễ dàng tiêu thụ một phần lớn ngân sách bộ nhớ trò chơi của bạn.

Trong ví dụ này, chỉ riêng bản đồ khối thăm dò 256 x 256 tiêu thụ 3MB.

Với ASTC HDR, cùng một đầu dò sẽ tiêu thụ ít bộ nhớ hơn nhiều lần.

Bạn thậm chí có thể thay đổi tốc độ bit để thực sự giảm dấu chân.

Tạo ra một kết cấu HDR đơn giản như một kết cấu tương đương LDR.

Trong ví dụ này, chúng tôi đang tạo ra một kết cấu ASTC LDR bốn x bốn.

Có định dạng HDR phù hợp cho mọi định dạng LDR nên việc chuyển đổi định dạng này thành kết cấu HDR chỉ yêu cầu thay đổi định dạng pixel.

Được rồi, điều đó kết thúc các tính năng Metal mới cho GPU A13.

Hãy tóm tắt lại những gì chúng ta đã học được.

Nó cho phép phát trực tuyến kết cấu chất lượng cao hơn với kết cấu thưa thớt.

Nó cho phép bạn tập trung đổ bóng đắt tiền vào nơi cần thiết với bản đồ tốc độ rasterization và loại bỏ xử lý đỉnh dư thừa bằng khuếch đại đỉnh.

Nó cũng cho phép các đường ống dựa trên GPU linh hoạt hơn với bộ đệm đối số Cấp 2 và chia sẻ nhóm SIMD với hướng dẫn xáo trộn và bỏ phiếu.

Và cuối cùng, Metal bây giờ cho phép bạn lưu bộ nhớ trong các đường ống HDR với ASTC.

Để biết thêm thông tin về Metal, GPU A13 và để tìm mã mẫu mới nhất của chúng tôi, vui lòng truy cập developer.apple.com.

Cảm ơn bạn.