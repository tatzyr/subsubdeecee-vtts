10100

Alejandro Isaza: Xin chào. Tôi là Alejandro.

Hôm nay David và tôi sẽ giới thiệu TabularData, một khuôn khổ mới để thao tác và khám phá dữ liệu.

Tôi sẽ bắt đầu với phần giới thiệu nhanh và sau đó chúng ta sẽ nói về khám phá dữ liệu, chuyển đổi dữ liệu, các phương pháp hay nhất và kết thúc bằng bản tóm tắt.

Hãy nhảy vào.

Đầu tiên hãy để tôi nói về, dữ liệu dạng bảng là gì?

Nói một cách đơn giản nhất, dữ liệu dạng bảng là dữ liệu được sắp xếp theo hàng và cột, tương tự như bảng tính.

Nhưng hãy tưởng tượng bạn có hàng trăm cột và hàng triệu hàng.

Đây là nơi khung TabularData xuất hiện.

Vậy nó là gì?

Đó là một khuôn khổ hoàn toàn mới mà chúng tôi đang làm việc.

Nó đã có sẵn trong macOS, iOS, tvOS và watchOS.

Nó sẽ giúp bạn khám phá và thao tác dữ liệu phi cấu trúc.

Khi tôi nói "dữ liệu phi cấu trúc", ý tôi là dữ liệu chưa được sắp xếp theo cách được xác định trước.

Ví dụ, khi bạn tải xuống một tập dữ liệu không có thông số kỹ thuật; giả sử, dữ liệu thời tiết hoặc thống kê dân số.

Và khám phá là điều đầu tiên bạn làm khi gặp một tập dữ liệu mới.

Bạn muốn biết loại thông tin nào ở đó.

Những thứ như, những giá trị là gì?

Các loại là gì? Dữ liệu được thể hiện như thế nào?

Có thiếu giá trị không? Và cứ thế.

Bạn cần có khả năng trả lời những câu hỏi này để hiểu đúng tập dữ liệu và có thể chuyển sang bước tiếp theo, đó là thao tác.

Thao tác là nơi bạn chuyển đổi tập dữ liệu thành một biểu mẫu phù hợp nhất với vấn đề bạn đang cố gắng giải quyết.

Ví dụ, bạn có thể muốn biểu diễn ngày như một loại ngày thay vì một chuỗi, hoặc bạn có thể muốn kết hợp tọa độ x và y thành một loại điểm, v.v.

Khung TabularData rất phù hợp để xử lý các bộ dữ liệu lớn.

Đây là một số trường hợp sử dụng phổ biến.

Nhóm dữ liệu theo một số tiêu chí; ví dụ, nhóm người theo độ tuổi.

Tham gia các bộ dữ liệu trên các giá trị chung.

Ví dụ, tham gia bảng giao dịch với thông tin của người mua.

Tách hoặc phân đoạn dữ liệu để xử lý từng bước hoặc lọc thành một tập hợp con của toàn bộ tập dữ liệu.

Và xây dựng đường ống dữ liệu; ví dụ, khi thực hiện kỹ thuật tính năng cho học máy.

Trong bối cảnh của khuôn khổ, một bảng được gọi là DataFrame.

Khung dữ liệu chứa các hàng và cột, tương tự như bảng tính.

Nhưng không giống như bảng tính, mỗi cột chỉ có thể chứa một loại giá trị cụ thể.

Nhưng điều này cũng có nghĩa là các cột có thể chứa bất kỳ loại nào, ngay cả các loại tùy chỉnh của riêng bạn.

Ví dụ, từ điển, tọa độ GPS hoặc mẫu âm thanh thô.

Biết rằng bất cứ khi nào chúng tôi hiển thị một bảng đại diện cho một DataFrame hoặc một lát DataFrame, chúng tôi bao gồm một cột chỉ mục ở bên trái.

Điều này có liên quan khi bạn cần truy cập các hàng theo chỉ mục dữ liệu.

Một số thao tác như bộ lọc, dữ liệu không thay đổi, trong khi các thao tác khác như sắp xếp có thể thay đổi các chỉ số trên khung dữ liệu kết quả.

Hãy chia nhỏ nó và phóng to một cột.

Như tôi đã đề cập, một cột có một loại phần tử cụ thể; trong trường hợp này, Int.

Nó cũng có một cái tên phải là duy nhất trong khung dữ liệu.

Một cột được biểu diễn bằng loại Cột, là một tập hợp, giống như mảng.

Bạn có thể tham khảo một cột theo tên nhưng trong hầu hết các trường hợp, bạn cũng cần loại đó.

Có một cấu trúc được gọi là ColumnID chứa tên và loại của một cột, và có thể được sử dụng để chỉ một cột cụ thể.

Bất cứ khi nào có thể, tôi khuyên bạn nên sử dụng ColumnID được xác định trước thay vì các ký tự chuỗi để tham chiếu đến các cột.

Cũng lưu ý rằng tất cả các cột trong Khung dữ liệu phải có cùng số phần tử.

Nhưng luôn có thể có các phần tử bị thiếu, được biểu diễn dưới dạng các giá trị nil.

Tương tự như Cột, có một loại Hàng.

Bạn có thể truy cập từng phần tử của một hàng theo tên cột hoặc theo chỉ mục.

Bạn có thể nghĩ về Row như một proxy.

Nó không thực sự chứa các phần tử trong hàng; thay vào đó, nó là một tham chiếu trỏ trở lại một hàng trong DataFrame.

Vậy làm thế nào để bạn tạo một DataFrame?

Để tôi chỉ cho bạn.

Bạn có thể tạo một DataFrame từ một từ điển theo nghĩa đen hoặc bằng cách xây dựng từng cột một.

Đây là một ví dụ về việc xây dựng từ một từ điển theo nghĩa đen.

Lưu ý rằng khi sử dụng từ điển theo nghĩa đen, bạn bị hạn chế sử dụng các loại Swift cơ bản như chuỗi, số, giá trị boolean và ngày tháng.

Cũng nên nhớ rằng mỗi cột phải có cùng số phần tử.

Một cách tổng quát hơn để xây dựng DataFrame là xây dựng từng cột một và sau đó thêm các cột vào DataFrame.

Đây là một ví dụ.

Đầu tiên, tôi tạo một DataFrame trống.

Sau đó tôi tạo một Cột.

Và sau đó tôi thêm cột vào DataFrame.

Tôi có thể lặp lại quy trình cho tất cả các cột, nhưng một lần nữa, hãy đảm bảo rằng mọi cột đều có cùng số phần tử và tên cột đó là duy nhất.

Bây giờ bạn đã biết DataFrame là gì, hãy thực hiện một số khám phá dữ liệu.

Điều đầu tiên bạn muốn làm là tải một tập dữ liệu.

TabularData hỗ trợ đọc các giá trị được phân tách bằng dấu phẩy, tệp CSV và JSON.

Và nó đơn giản như gọi trình khởi tạo bằng URL tệp, tệp này sẽ tải bằng tất cả các tùy chọn mặc định.

Hãy cùng khám phá một số tùy chọn có sẵn khi tải CSV.

Nếu bạn đã sử dụng CSV trước đây, bạn có thể biết rằng không phải lúc nào cũng có dấu phẩy.

Dấu phân cách có thể là một tab hoặc dấu chấm phẩy.

Hoặc có thể có hoặc không có một hàng tiêu đề với tên cột.

Ngoài ra còn có các biến thể về cách thoát chuỗi cho các ký tự đặc biệt và cách biểu diễn các giá trị bị thiếu.

TabularData có thể xử lý tất cả các biến thể.

Trong ví dụ này, tôi đang chỉ định rằng không có hàng tiêu đề, sử dụng mã hóa nil tùy chỉnh, bỏ qua các dòng trống và sử dụng dấu phân cách dấu chấm phẩy.

Vui lòng tham khảo tài liệu để xem toàn bộ tùy chọn cũng như mặc định.

Nếu bạn có một tệp lớn hơn, bạn có thể chỉ muốn tải một tập hợp con các hàng tại một thời điểm.

Bạn có thể làm điều này với tùy chọn hàng.

Ví dụ, điều này sẽ chỉ tải 100 hàng đầu tiên.

Tương tự, bạn có thể chọn một tập hợp con của các cột.

Để làm điều này, hãy sử dụng đối số cột.

Lưu ý rằng điều này cũng sẽ cho phép bạn sắp xếp lại các cột.

Hãy để tôi nói ngắn gọn về cách suy luận kiểu hoạt động khi tải tệp CSV.

Tất cả các tệp CSV đều dựa trên văn bản.

Nhưng việc mọi cột thuộc loại chuỗi không thuận tiện lắm.

Vì vậy, khi tải tệp CSV, TabularData sẽ cố gắng chuyển đổi các giá trị thành số, giá trị boolean và ngày tháng trước khi mặc định thành chuỗi.

Nếu bạn muốn buộc các giá trị cho một loại cụ thể hoặc muốn tăng tốc độ tải lên một chút, bạn có thể chỉ định rõ ràng loại cột.

Bạn làm điều này với đối số kiểu.

Trong ví dụ này, chúng tôi đang chỉ định loại số nguyên cho cột id và loại chuỗi cho cột tên.

Điều này sẽ không chỉ đẩy nhanh quá trình tải mà còn gây ra lỗi nếu có giá trị không thể chuyển đổi sang loại được chỉ định.

Điều này tốt vì nó cho phép bạn phát hiện sớm các vấn đề và xử lý chúng một cách thích hợp thay vì kết thúc bằng một cột thuộc loại không phải là những gì bạn mong đợi, điều này có thể dẫn đến sự cố sau này trong ứng dụng của bạn.

Cuối cùng, hãy để tôi đề cập đến việc phân tích cú pháp ngày tháng.

TabularData, theo mặc định, sẽ phát hiện và phân tích ngày tháng ở định dạng ISO8601.

Nếu tệp CSV của bạn chứa ngày ở định dạng khác, bạn sẽ cần chỉ định chiến lược phân tích cú pháp ngày tùy chỉnh.

Tôi sẽ để David nói về điều này và cho bạn xem một ví dụ khi chúng ta đi vào bản demo.

Bây giờ chúng ta hãy chuyển bánh răng và nói về việc viết dữ liệu ra.

Lựa chọn đầu tiên và đơn giản nhất là sử dụng chức năng in của Swift.

Điều này sẽ tạo ra một bảng được in đẹp mắt trong Terminal.

Đầu ra được in bao gồm chỉ mục hàng, tên cột, các loại cột, một vài hàng dữ liệu đầu tiên và số lượng hàng và cột.

Nó cũng chỉ ra rằng không phải tất cả các hàng đều vừa trên màn hình và không phải tất cả các cột đều vừa trên màn hình.

Trong trường hợp này, có thêm 10 cột không được hiển thị.

In ấn rất tốt để khám phá và gỡ lỗi, nhưng rõ ràng là không tuyệt vời để lưu trữ dữ liệu.

Nếu bạn muốn lưu DataFrame dưới dạng tệp CSV, hãy sử dụng phương thức writeCSV.

Một điều quan trọng cần lưu ý là writeCSV sẽ sử dụng chuyển đổi chuỗi mặc định của mọi giá trị.

Hãy cẩn thận khi sử dụng các loại tùy chỉnh trong các cột của bạn, bởi vì CSV được tạo có thể không phải là thứ mà bạn có thể đọc lại.

Theo nguyên tắc chung, chỉ sử dụng các loại Swift cơ bản trong các cột của bạn khi ghi vào CSV, điều này có thể yêu cầu chuyển đổi một số cột của bạn.

writeCSV có một số tùy chọn tương tự như các tùy chọn đọc.

Họ cho phép bạn tùy chỉnh cách dữ liệu CSV được viết.

Đây là một ví dụ mà tôi đang vô hiệu hóa các tiêu đề bằng cách sử dụng mã hóa nil tùy chỉnh và sử dụng dấu phân cách tùy chỉnh.

Để truy cập một hàng cụ thể, bạn chỉ có thể sử dụng chỉ số hàng con.

Sau đó, bạn có thể truy cập một cột cụ thể của hàng đó.

Nhưng bất cứ khi nào có thể, thay vào đó bạn nên truy cập cột trước và sau đó là hàng.

Đây là cách bạn truy cập một cột.

Trong trường hợp truy cập một cột theo tên, bạn có thể bỏ qua nhãn cột: khỏi chỉ số phụ.

Bạn cũng có thể truy cập một tập hợp con các hàng.

Trong trường hợp này, bạn nhận được một lát DataFrame.

Một lát DataFrame rất giống với một DataFrame.

Về cơ bản, nó là một tham chiếu đến DataFrame ban đầu Trong hầu hết các tình huống, bạn thậm chí không cần phải biết đó là một DataFrame đầy đủ hay một lát cắt.

Và cuối cùng, bạn cũng có thể chọn một tập hợp con của các cột.

Điều này sẽ trả về một DataFrame mới chỉ bao gồm các cột đó.

Bạn cũng có thể chọn một tập hợp con của các hàng bằng phương pháp lọc.

Kết quả của thao tác lọc là một lát DataFrame, tương tự như chọn một loạt các hàng.

Nhưng không giống như một loạt các hàng, bộ lọc có thể trả về các hàng không liền kề.

Bạn cần phải cẩn thận khi xử lý các chỉ số lát cắt DataFrame.

Tương tự như các lát mảng, các chỉ số của chúng phản ánh các chỉ số của các hàng ban đầu.

Cụ thể, chỉ số đầu tiên có thể không bằng 0 và chỉ số tiếp theo có thể không phải là chỉ số hiện tại cộng với một.

Như với các chỉ mục chuỗi, bạn muốn sử dụng startIndex thay vì zero, endIndex thay vì count và index(after:) thay vì thêm một.

Bây giờ tôi đã đề cập đến những điều cơ bản, hãy áp dụng nó vào thực tế bằng cách xây dựng một ứng dụng.

Tìm chỗ đậu xe ở San Francisco thật khó.

David và tôi muốn xây dựng một ứng dụng iPhone hiển thị các điểm đỗ xe gần đó trên đường phố.

Chúng tôi muốn sử dụng dữ liệu do thành phố công bố để xác định đồng hồ đỗ xe gần nơi bãi đậu xe hiện được cho phép.

Chúng tôi biết có một tập dữ liệu nhưng chúng tôi không biết chính xác nó chứa những gì.

Vì vậy, bước đầu tiên sẽ là khám phá tập dữ liệu để hiểu những gì chúng ta có.

Tôi sẽ giao nó cho David.

David Findlay: Cảm ơn, Alejandro.

Xin chào. Tôi là David, một kỹ sư khung.

Trong bản demo này, tôi sẽ xem qua một ví dụ về cách bạn có thể sử dụng TabularData để khám phá một tập dữ liệu.

Tôi sẽ bắt đầu bằng cách khám phá tệp CSV về các chính sách đỗ xe.

Bước đầu tiên là tải dữ liệu, điều mà tôi có thể làm dễ dàng bằng cách chuyển url tệp vào trình khởi tạo DataFrame.

Lưu ý rằng trình khởi tạo có thể ném được, điều mà tôi thấy hữu ích khi xử lý các lỗi phân tích cú pháp tiềm ẩn.

Tiếp theo, với một bản in đơn giản, tôi có thể khám phá một vài hàng và cột đầu tiên.

Quá trình tải mất vài giây và đó là vì DataFrame đã tải hơn một triệu hàng và 15 cột vào bộ nhớ.

Khi tôi khám phá một tập dữ liệu lần đầu tiên, tôi thường không cần toàn bộ tập dữ liệu, vì vậy tôi sẽ chỉ định một phạm vi hàng khi tải dữ liệu để tăng tốc độ khám phá của mình.

Tiếp theo, tôi sẽ xem xét các cột.

Lưu ý rằng hai trong số chúng được ẩn ở bên phải, vì chúng sẽ không vừa với màn hình.

Hãy để tôi chỉ cho bạn cách khắc phục điều đó với các tùy chọn định dạng.

Các tùy chọn định dạng cho phép tôi định cấu hình cách dữ liệu được trình bày.

Trong trường hợp này, tôi sẽ tăng chiều rộng dòng tối đa của mình lên 250, giảm chiều rộng cột xuống còn 15 và giảm các hàng xuống còn năm để tránh cuộn qua kết quả đã in.

Sau đó, tôi có thể chỉ cần thêm Tùy chọn định dạng vào câu lệnh in của mình bằng phương pháp mô tả.

Tuyệt vời! Bây giờ tôi có thể khám phá tất cả các cột của mình, tôi sẽ chọn một vài cột thú vị để giữ lại.

Đây cũng là một cơ hội tốt để sắp xếp lại các cột bằng cách liệt kê chúng theo thứ tự mà tôi muốn.

Tôi có HourlyRate, DayOfWeek, thời gian bắt đầu và kết thúc, StartDate và PostID.

Tất cả những gì tôi cần làm tiếp theo là thêm các cột này làm tham số khi tải DataFrame của mình.

Được rồi, điều này đã dễ dàng hơn rất nhiều để khám phá.

Hãy nhìn vào cột StartDate, có một loại chuỗi.

Đó là bởi vì chỉ có ngày ISO8601 được phát hiện tự động.

Tôi sẽ cần chỉ định rõ ràng bất kỳ định dạng ngày nào khác.

Tôi có thể khắc phục điều đó bằng cách sử dụng CSVReadingOptions mà Alejandro đã giải thích trước đó.

Sử dụng API phân tích cú pháp ngày nền tảng, tôi sẽ thêm chiến lược phân tích cú pháp ngày.

Tôi sẽ chỉ định định dạng là năm, tháng, ngày; ngôn ngữ là tiếng Anh Mỹ; và múi giờ là Giờ chuẩn Thái Bình Dương.

Sau đó, tôi sẽ vượt qua CSVReadingOptions khi tải DataFrame của mình.

Bây giờ cột StartDate có loại phù hợp, tôi có thể dễ dàng lọc DataFrame để tôi chỉ có các chính sách đỗ xe đang hoạt động.

Bắt đầu với biến để biểu diễn ngày hiện tại, sau đó tôi sẽ lọc DataFrame bằng phương pháp lọc.

Phương thức lọc lấy tên cột - trong trường hợp này là StartDate - và một loại - Date.

Trong phần đóng, tôi mở gói ngày tùy chọn, trả về sai khi giá trị ngày bằng không để nó không xuất hiện trong kết quả bộ lọc của tôi.

Và cuối cùng, tôi giữ ngày bắt đầu nhỏ hơn hoặc bằng ngày hiện tại của tôi.

Tôi sẽ tiếp tục và thay đổi bản in của mình để hiển thị cho bạn kết quả đã lọc.

Từ bây giờ, tôi sẽ không cần cột StartDate, vì vậy tôi sẽ tiếp tục và xóa nó.

Nhưng tôi cần phải cẩn thận, vì tôi không thể xóa một cột khỏi lát DataFrame.

Trước tiên tôi sẽ phải chuyển đổi sang DataFrame và tạo filteredPolicies của var, vì việc xóa một cột là một phương pháp đột biến.

Bây giờ tôi có thể xóa cột bằng cách sử dụng phương thức removeColumn và chỉ định cột StartDate làm cột cần xóa.

Được rồi, đó là tất cả những gì tôi muốn khám phá trong tập dữ liệu chính sách đỗ xe.

Trong phần tiếp theo, Alejandro sẽ thảo luận về các cách mà bạn có thể tăng cường dữ liệu dạng bảng của mình.

Quay lại với bạn, Alejandro!

Alejandro: Cảm ơn, David.

Bây giờ tôi có một số thông tin chi tiết tuyệt vời về tập dữ liệu.

Bước tiếp theo sẽ là chuyển đổi và tăng cường nó để phù hợp với nhu cầu của chúng tôi.

Loại chuyển đổi đơn giản nhất là thay đổi các giá trị trong một cột.

Điều này có thể ở dạng một thao tác bản đồ trong đó mỗi giá trị được ánh xạ đến một giá trị mới, có thể thuộc một loại khác nhau.

TabularData cung cấp một phiên bản bản đồ tại chỗ để thuận tiện: transformColumn.

Trong ví dụ này, tôi đang chuyển đổi cột DayOfWeek từ một chuỗi thành một số nguyên đại diện cho ngày trong tuần.

Đây là mã sẽ trông như thế nào.

Đối với mỗi phần tử, chúng tôi chuyển đổi chuỗi thành một Int.

Tương tự như transformColumn, phương pháp giải mã xử lý việc giải mã dữ liệu.

Khi xử lý các tệp CSV, bạn có thể gặp các mảng hoặc từ điển được nhúng trong CSV dưới dạng các giá trị JSON.

TabularData cung cấp một phương pháp giải mã cho việc này.

Đây là một ví dụ trong đó DataFrame ở bên trái có một đốm màu dữ liệu JSON được nhúng.

Giải mã cho phép bạn sử dụng JSONDecoder để chuyển đổi cột thành loại của riêng bạn; trong ví dụ này, Tùy chọn.

Và đây là mã sẽ trông như thế nào.

Hãy nhớ rằng loại Tùy chọn cần phải phù hợp với giao thức Giải mã và cột cần chứa các phần tử của loại Dữ liệu, đó là những gì JSONDecoder mong đợi làm đầu vào.

Một thao tác hữu ích khác là phương pháp điền.

Nó cho phép bạn thay thế tất cả các giá trị bị thiếu trong một cột bằng một giá trị mặc định.

Và để hoàn thành danh sách các hoạt động của cột, tôi muốn đề cập đến bản tóm tắt.

Tóm tắt cung cấp cho bạn cái nhìn tổng quan nhanh về nội dung của một cột.

Phương pháp tóm tắt trả về một bản tóm tắt phân loại.

Nó bao gồm số lượng các phần tử, được hiển thị trong phần mô tả là someCount; số lượng các phần tử bị thiếu, được hiển thị là noneCount; số lượng các phần tử duy nhất; và các giá trị thường xuyên nhất, được gọi là chế độ.

Ngoài ra còn có numericSummary, chỉ có sẵn cho các cột chứa các giá trị số.

Nó cũng bao gồm số lượng, cộng với giá trị trung bình, độ lệch chuẩn và các số liệu thống kê khác.

Ở đây, tôi đang hiển thị kết quả in của bản tóm tắt.

Nhưng bạn cũng có thể sử dụng cấu trúc tóm tắt trực tiếp để truy cập số liệu thống kê.

Ví dụ, nếu bạn muốn lọc điểm số thành những điểm trong phân vị thứ 75.

Được rồi, đó là rất nhiều phép biến đổi cột, nhưng phép biến đổi cột không phải là thú vị nhất.

Chuyển đổi DataFrame là nơi nó thực sự trở nên thú vị.

Không giống như các phép biến đổi cột, các phép biến đổi DataFrame thao tác nhiều cột cùng một lúc.

Một ví dụ đơn giản là sắp xếp.

Tất cả chúng ta đều biết cách phân loại hoạt động, nhưng hãy để tôi minh họa cho rõ ràng.

Hãy sắp xếp bảng này theo điểm số.

Điều này ảnh hưởng đến tất cả các cột.

Cũng lưu ý rằng các chỉ số hàng thay đổi khi sắp xếp.

Một chuyển đổi DataFrame thú vị khác là combineColumns.

Phương pháp combineColumns cho phép bạn kết hợp nhiều cột thành một.

Ví dụ, hãy tưởng tượng rằng bạn có các cột riêng biệt cho vĩ độ và kinh độ, nhưng bạn muốn kết hợp chúng thành một loại CLLocation.

Đây là một ví dụ về việc làm điều này.

Đầu tiên, tôi chỉ định các cột mà tôi muốn kết hợp.

Sau đó tôi đặt tên cho cột mới.

Sau đó, tôi chỉ định các loại cột đầu vào và cột mới, và lưu ý rằng mọi thứ phải là tùy chọn.

Tôi xử lý trường hợp giá trị bị thiếu và tôi xây dựng giá trị mới.

Tương tự như cột, cũng có một phương pháp tóm tắt cho DataFrame.

Nó trả về số liệu thống kê tóm tắt cho mọi cột.

Lưu ý rằng điều này có thể tốn kém nếu bạn có Khung dữ liệu lớn; tốt hơn là chỉ tóm tắt các cột mà bạn quan tâm.

Một phương pháp thú vị khác là bùng nổ.

Nó cần một cột chứa một mảng các phần tử và tạo ra một hàng mới cho mọi phần tử trong mảng.

Hãy nhìn vào ví dụ này.

Lần này, cột điểm chứa một mảng điểm được nhúng cho mỗi người.

Nếu tôi áp dụng thao tác bùng nổ cho DataFrame, mỗi thứ này sẽ trở thành một hàng mới.

Chúng tôi đã lặp lại tên cho những người có nhiều điểm.

Điều này rất hữu ích khi lọc hoặc thực hiện các thao tác khác yêu cầu xem xét từng điểm số riêng lẻ.

Với những công cụ này trong kho vũ khí của chúng tôi, tôi sẽ chuyển nó lại cho David, người sẽ giúp chúng tôi đưa dữ liệu đồng hồ vào dạng mà chúng tôi cần.

David, cho chúng tôi xem một số mã.

David: Cảm ơn, Alejandro.

Tôi không biết bạn thế nào, nhưng đối với tôi, phần quan trọng nhất về bãi đậu xe là vị trí.

May mắn thay, tôi có một tệp CSV khác có những gì tôi cần.

Để tôi chỉ cho bạn những gì trong đó.

Tương tự như trước đây, tôi sẽ bắt đầu bằng cách tải dữ liệu, nhưng lần này, tôi đã biết các cột mà tôi quan tâm.

Tôi có POST_ID, STREET_NAME, STREET_NUM, LATITUDE và LONGITUDE, và tôi sẽ in kết quả bằng cách sử dụng cùng một tùy chọn định dạng từ bản demo trước đó.

Lần tăng cường đầu tiên tôi muốn là kết hợp các cột vĩ độ và kinh độ thành một cột mới với loại vị trí cốt lõi.

Phương pháp combineColumns hoàn hảo cho công việc.

Ở đây, tôi đang kết hợp các cột vĩ độ và kinh độ thành một cột mới có tên là location.

Trong phần đóng, tôi chỉ định các loại tham số vĩ độ và kinh độ và loại trả về vị trí cốt lõi.

Tiếp theo, tôi mở gói các giá trị vĩ độ và kinh độ tùy chọn, trả về số không trong trường hợp một trong hai giá trị là số không.

Và cuối cùng, chuyển các giá trị vĩ độ và kinh độ sang trình khởi tạo vị trí cốt lõi.

Với vị trí trong DataFrame của mình, tôi có thể bắt đầu xây dựng tính năng đầu tiên cho ứng dụng của mình: đưa ra một vị trí, tìm kiếm đồng hồ đỗ xe gần nhất.

Tôi sẽ viết một hàm có tên closestParking lấy vị trí, DataFrame và số lượng đồng hồ đỗ xe để đưa vào kết quả tìm kiếm.

Tôi sẽ bắt đầu với một bản sao địa phương.

Và sau đó sử dụng phương pháp transformColumn mà Alejandro đã giới thiệu trước đó, tôi sẽ chuyển đổi vị trí thành khoảng cách.

Và sau đó, tất nhiên, tôi sẽ đổi tên cột vị trí thành khoảng cách.

Cuối cùng, tôi sẽ sắp xếp cột khoảng cách theo thứ tự tăng dần và giới hạn số lượng điểm quay trở lại.

Chỉ để cho vui thôi, hãy thử nghiệm điều này bằng cách sử dụng Apple Store ở San Francisco.

Tôi sẽ cắm tọa độ mà tôi tìm thấy trên Apple Maps, đồng hồ đo DataFrame và giới hạn kết quả tìm kiếm ở năm điểm đỗ xe.

Hoàn hảo! Có vẻ như có rất nhiều bãi đậu xe gần Apple Store trên Phố Bưu điện.

Tính năng đầu tiên của ứng dụng đang hoạt động tốt, nhưng nếu tất cả các bãi đậu xe gần nhất đã được sử dụng thì sao?

Tính năng tiếp theo của ứng dụng là tìm những con phố có nhiều chỗ đậu xe nhất.

Nhưng trước khi tôi triển khai tính năng này, hãy để tôi giới thiệu một khái niệm mới gọi là nhóm.

Nhóm chia dữ liệu của bạn thành các nhóm, đưa ra một cột nhóm.

Ví dụ, cột STREET_NAME.

Phương pháp nhóm trước tiên xác định các giá trị tên đường duy nhất - Phố Bưu điện, Phố California và Phố Mission - và sau đó chia các hàng thành các nhóm tương ứng.

Mỗi nhóm là một lát DataFrame.

Bây giờ, hãy quay trở lại mã.

Tôi sẽ nhóm đồng hồ theo tên đường bằng cách sử dụng phương pháp được nhóm lại.

Sau đó, tôi có thể đếm xem mỗi nhóm đường phố có bao nhiêu đồng hồ đỗ xe và phục vụ kết quả theo thứ tự giảm dần.

Những con phố có nhiều chỗ đậu xe nhất nằm ở đầu kết quả, đó là những gì tôi cần cho ứng dụng của mình.

Điều này thật tuyệt vời!

Hai tính năng tuyệt vời cho ứng dụng của tôi.

Nhưng đợi một chút, tôi vừa nhận ra có một lỗi trong tính năng đầu tiên.

Đồng hồ đỗ xe gần nhất chỉ xem xét đồng hồ đo DataFrame.

Những gì tôi thực sự cần là đồng hồ đỗ xe gần nhất với các chính sách đỗ xe đang hoạt động.

Điều này đang trở nên thú vị, vì thông tin đó nằm trong dữ liệu từ bản demo một.

Hãy để tôi chỉ cho bạn cách nối dữ liệu từ hai nguồn khác nhau để tôi có thể sửa lỗi.

Bạn có thể quen thuộc với việc tham gia nếu bạn đã từng sử dụng cơ sở dữ liệu quan hệ trước đây.

Nó cho phép bạn kết hợp hai DataFrames với nhau bằng cách sử dụng một khóa.

Chìa khóa là một giá trị xuất hiện trong cả hai DataFrames.

Trong đồng hồ đo và chính sách DataFrames, chìa khóa là POST_ID, xác định duy nhất đồng hồ đo đỗ xe.

Thao tác tham gia dẫn đến một DataFrame với các hàng trong đó POST_ID từ mét khớp với POST_ID từ các chính sách.

Các hàng bao gồm dữ liệu phù hợp từ Khung dữ liệu bên trái và Khung dữ liệu bên phải.

Lưu ý rằng tên cột có tiền tố trái hoặc phải.

Điều này cho biết cạnh nào của cột nối đến từ đâu.

Các tiền tố giúp tránh va chạm đặt tên trong kết quả tham gia.

Thao tác này là một sự kết hợp bên trong, đó là mặc định.

Có ba loại tham gia khác: bên ngoài bên trái, bên ngoài bên phải và bên ngoài đầy đủ.

Tôi sẽ không đi vào chi tiết ở đây, nhưng vui lòng tham khảo tài liệu để tìm hiểu thêm.

Được rồi, đó là tất cả những gì tôi muốn đề cập đến trong việc tăng cường dữ liệu dạng bảng.

Trong phần tiếp theo, Alejandro sẽ nói về các phương pháp hay nhất.

Alejandro: Cảm ơn, David.

Bây giờ chúng tôi đã có tất cả dữ liệu trong biểu mẫu mà chúng tôi cần, đã đến lúc xây dựng ứng dụng của chúng tôi.

Hãy để tôi nói về cách bạn có thể sử dụng lại mã khám phá của mình trong khi làm cho nó sẵn sàng sản xuất.

Hãy để tôi quay lại mã mà chúng tôi đã bắt đầu để tải tệp CSV.

Nếu bạn làm điều này, các cột sẽ có các loại không xác định.

Đây là vấn đề đối với các hoạt động như lọc hoặc tham gia nơi bạn cần biết trước loại.

Nếu bạn đang tải dữ liệu từ nguồn do người dùng cung cấp, việc đưa ra các giả định về loại này là rủi ro.

Nó có thể dẫn đến ứng dụng của bạn gặp sự cố.

Thay vào đó, bạn nên khai báo các loại mà bạn mong đợi khi tải dữ liệu, như trong ví dụ này.

Ở đây, tôi đang xác định ID cột cho mọi cột mà tôi quan tâm.

Và sau đó tôi đang cung cấp cả tên cột và loại cột cho trình khởi tạo CSV.

Hãy nhớ rằng bạn có thể sử dụng ID cột thay vì một chuỗi trong bất kỳ phương thức nào đề cập đến một cột.

Bây giờ, nếu có các giá trị không hợp lệ, bạn sẽ nhận được một ngoại lệ mà bạn có thể xử lý, ví dụ, bằng cách trình bày lỗi cho người dùng.

Bằng cách này bạn có thể đảm bảo bạn có các cột và loại cột mà bạn mong đợi.

Điều này đặc biệt quan trọng khi sử dụng các định dạng ngày tùy chỉnh bởi vì nếu bạn không chỉ định rằng cột của bạn thuộc loại ngày, việc phân tích cú pháp ngày có thể thất bại âm thầm và thay vào đó tạo ra một cột chuỗi.

Buộc nó là một ngày sẽ ném một ngoại lệ bao gồm nội dung của ô không thành công, điều này sẽ giúp bạn gỡ lỗi sự cố.

Nói về lỗi, đây là loại lỗi bạn nên mong đợi khi tải tệp CSV.

Phân tích cú pháp không thành công sẽ được tạo khi sử dụng trình phân tích cú pháp ngày tùy chỉnh và một ô không thể phân tích cú pháp.

Những cái khác tự giải thích, nhưng vui lòng tham khảo tài liệu.

Và để kết thúc, hãy để tôi đề cập ngắn gọn đến hiệu suất.

Hầu hết thời gian, bạn không cần phải lo lắng về hiệu suất, nhưng có một vài trường hợp bạn sẽ thấy tác động lớn khi làm việc với các bộ dữ liệu lớn.

Cái đầu tiên là phân tích cú pháp ngày khi tải CSV.

Phân tích cú pháp ngày có rất nhiều trường hợp và cân nhắc đặc biệt và do đó, nó có xu hướng chậm.

Nếu tệp CSV của bạn mất hơn vài giây để tải, đây là nơi đầu tiên bạn nên tìm kiếm để cải thiện.

Một lựa chọn là trì hoãn việc phân tích cú pháp.

Điều này hoạt động đặc biệt tốt khi bạn không cần thông tin ngày ngay lập tức.

Ví dụ, bạn muốn thực hiện lọc hoặc nhóm trước.

Nếu đó không phải là một lựa chọn, hãy cân nhắc thủ công trình phân tích cú pháp ngày để tối ưu hóa hiệu suất cho chuỗi ngày của bạn.

Khi nhóm, luôn sử dụng một cột chứa một loại Swift cơ bản làm cột nhóm, chẳng hạn như chuỗi hoặc Int.

Điều này sẽ tăng tốc hiệu suất nhóm.

Nếu bạn đang nhóm theo nhiều hơn một cột, trước tiên hãy cân nhắc kết hợp các cột thành một cột duy nhất thuộc loại đơn giản trước và sau đó nhóm lại.

Ví dụ, nếu bạn muốn nhóm theo ngày trong tuần và loại đồng hồ, hãy cân nhắc kết hợp hai thuộc tính đó thành một chuỗi.

Ví dụ, kiểu ngày.

Tương tự, khi tham gia, hãy cân nhắc tham gia vào một cột chứa một loại Swift cơ bản.

Với điều này, chúng tôi đã sẵn sàng để hoàn thành ứng dụng.

David, hãy kết thúc nó.

David: Sử dụng các phương pháp hay nhất của TabularData, tôi sẽ viết chức năng tìm kiếm của ứng dụng.

Cấu trúc Bãi đậu xe sẽ lưu trữ các đồng hồ đo và chính sách DataFrame được nối.

Và tôi đã xác định một ColumnID vị trí, vì nhiều phương pháp cần nó.

Hãy đi sâu vào các chi tiết trong phương pháp loadMeters.

Ở trên cùng, tôi có ID Cột mà tôi cần để tải đồng hồ.

Sau đó, tôi tải đồng hồ và chỉ định các loại dự kiến của mỗi cột.

Điều này sẽ xảy ra nếu có bất kỳ sự không phù hợp nào trong tệp CSV được cung cấp.

Tiếp theo, tôi xác minh các cột đã giải quyết chính xác như những gì tôi mong đợi và nếu không tôi sẽ ném một ParkingError tùy chỉnh.

Cuối cùng, tôi đã tái cấu trúc hoạt động combineColumns để sử dụng ID cột vĩ độ, kinh độ và vị trí.

Cùng với đó, chức năng tìm kiếm của ứng dụng đã sẵn sàng sản xuất.

Tôi sẽ đưa nó lại cho Alejandro để tóm tắt lại khung TabularData.

Alejandro: Cảm ơn, David. Hãy tóm tắt lại.

Hôm nay chúng tôi đã chỉ cho bạn cách TabularData cho phép bạn khám phá một tập dữ liệu không xác định, thao tác nó và đưa nó vào ứng dụng của bạn.

Chúng tôi đã khám phá một tập dữ liệu, xem xét một số chuyển đổi cột và dữ liệu, và chúng tôi đã hoàn thành một số phương pháp hay nhất xung quanh việc xử lý lỗi và hiệu suất.

Tôi nóng lòng muốn xem cách bạn sử dụng TabularData để tạo ra các ứng dụng tuyệt vời.

Cảm ơn bạn!