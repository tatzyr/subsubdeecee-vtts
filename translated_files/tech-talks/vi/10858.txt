10858

Chào mừng bạn đến với các bản cập nhật Metal cho A14 Bionic.

Tên tôi là Anand Poovekurussi, và tôi làm việc trong phần mềm GPU tại Apple.

A14 Bionic là trung tâm của iPhone 12 và iPad Air mới.

Trong video này, đồng nghiệp Swami của tôi và tôi sẽ giới thiệu cho bạn các khả năng GPU của A14 Bionic và các tính năng Metal mới mà nó cho phép.

A14 có các bản cập nhật lớn cho CPU, GPU, công cụ thần kinh và các công nghệ tùy chỉnh khác thúc đẩy trải nghiệm iOS của chúng tôi.

Nó sử dụng công nghệ xử lý 5 nanomet đột phá, mang lại các tính năng mới, tăng hiệu suất và thậm chí hiệu suất năng lượng cao hơn trong hầu hết mọi khía cạnh của chip.

Chúng tôi đã xây dựng một GPU di động đẳng cấp thế giới vào A14 Bionic.

Nó có bốn lõi được thu nhỏ để mang lại hiệu suất bền vững tối đa với công suất thấp nhất có thể.

Bây giờ, về mặt Metal, có một số thay đổi cụ thể trong A14 sẽ cải thiện hiệu suất của các ứng dụng Metal của bạn...

Bắt đầu với các đường ống điều khiển bằng GPU.

Bộ đệm lệnh gián tiếp trong Metal cho phép bạn chuyển công việc sang GPU và cho phép bạn mã hóa các lệnh trên dòng thời gian GPU.

Điều này giải phóng thời gian CPU quý giá để bạn thực hiện các tác vụ khác trong ứng dụng của mình.

Kiến trúc GPU A14 làm cho các mô hình sử dụng như vậy hiệu quả hơn.

Tiếp theo, chúng tôi đã thực hiện những cải tiến đáng kể về hiệu suất đối với thiết kế bộ nhớ nhóm luồng GPU để hỗ trợ tính toán song song tốt hơn.

Chúng tôi mong đợi các nguyên thủy đồng bộ hóa như nguyên tử có phạm vi nhóm luồng sẽ thấy những lợi ích hiệu suất tuyệt vời do những thay đổi này.

Cuối cùng, khả năng bảo tồn băng thông bộ nhớ tiếp tục là một lợi thế thiết kế đáng kể của các nền tảng của chúng tôi.

GPU A14 tận dụng phần cứng nén hoàn toàn mới giúp tiết kiệm băng thông hơn cho các ứng dụng của bạn.

Nén bộ đệm khung dự kiến sẽ cải thiện trung bình 15% trở lên và bộ đệm độ sâu sẽ được cải thiện trung bình từ 40% trở lên.

Tất cả các khả năng mới của GPU A14 thuộc về một bộ tính năng Metal mới được gọi là Apple GPU family 7.

Đây là những gì chúng tôi sẽ đề cập trong video này.

Đầu tiên, tôi sẽ nói về tọa độ barycentric và ID nguyên thủy.

Tôi cũng sẽ chỉ cho bạn cách cả hai tính năng này có thể được sử dụng cùng nhau để thực hiện các kỹ thuật kết xuất hoãn lại như bộ đệm khả năng hiển thị.

Sau đó, tôi sẽ nhanh chóng giới thiệu các chế độ địa chỉ kết cấu mới trong A14.

Chúng tôi cũng có các tính năng hoàn toàn mới cho các ứng dụng làm tính toán.

Trong phần thứ hai của buổi nói chuyện, đồng nghiệp Swami của tôi sẽ nói về các hướng dẫn giảm SIMD mới cung cấp một cách hiệu quả để các ứng dụng thực hiện các hoạt động giảm tại phạm vi nhóm SIMD.

Anh ấy cũng sẽ đề cập đến các hướng dẫn nhân ma trận SIMD mới trong Metal trên A14.

Những hướng dẫn mới này cung cấp tăng hiệu suất đáng kể cho các hệ số nhân ma trận lớn được sử dụng trong học máy và tính toán hình ảnh.

Hãy xem xét từng thứ này chi tiết hơn...

Bắt đầu với tọa độ barycentric và ID nguyên thủy.

Apple GPU family 7 hiện cung cấp quyền truy cập vào tọa độ barycentric và ID nguyên thủy.

Tọa độ trung tâm xác định vị trí chính xác của một đoạn trong một nguyên thủy.

Và bây giờ, bạn có thể truy cập các tọa độ này ngay trong bộ đổ bóng phân đoạn của mình.

Như bạn có thể thấy trong hình bên phải, vị trí của mảnh vỡ tại điểm P được định nghĩa là tổng trọng số của các đỉnh tạo thành tam giác, trong đó tổng trọng số là 1.

Trong ngôn ngữ đổ bóng kim loại, tọa độ barycentric của mảnh vỡ được phơi bày dưới dạng vectơ của phao.

Chúng ta hãy xem xét một kỹ thuật có thể được hưởng lợi từ việc sử dụng tọa độ barycentric.

Tạo thủ tục là một lớp kỹ thuật được sử dụng để tạo ra các mô hình, hoạt ảnh và hiệu ứng theo thuật toán.

Bạn có thể thực hiện tất cả các loại hiệu ứng thủ tục trên bề mặt của các nguyên thủy, chẳng hạn như hệ thống hạt, địa hình hoặc thảm thực vật một cách nhanh chóng.

Vẽ các đường tùy chỉnh là một ví dụ như vậy.

Chúng ta hãy xem tọa độ barycentric có thể được sử dụng như thế nào cho việc này.

Giả sử bạn muốn sử dụng tạo thủ tục để vẽ các đường và đường viền chống răng cưa chất lượng cao tùy chỉnh trên các hình tam giác.

Để làm điều này, bạn có thể áp dụng các hàm toán học thú vị vào khoảng cách của đoạn từ các cạnh của nguyên thủy của bạn.

Tọa độ trung tâm của mảnh vỡ của bạn về bản chất cung cấp cho bạn khoảng cách từ các cạnh.

Các ví dụ trên cho thấy một số chức năng thú vị được áp dụng trên tọa độ barycentric trong bộ đổ bóng phân đoạn của bạn để tạo ra các hiệu ứng nhanh chóng.

Một tính năng mới khác của Metal trên A14 là ID nguyên thủy.

ID nguyên thủy cho bạn biết đoạn hiện tại nguyên thủy nào tương ứng với trong hình học đầu vào.

Ở bên phải, các ID được liệt kê trên các hình tam giác sẽ được trả về khi ID nguyên thủy được tìm nạp cho bất kỳ đoạn nào trong tam giác đó trong bộ đổ bóng phân đoạn của bạn.

Bây giờ nếu tam giác bị cắt bởi phần cứng, một tam giác con kế thừa ID nguyên thủy của cha mẹ nó.

Và với sự hiện diện của tessellation, ID nguyên thủy chỉ đơn giản tương ứng với ID bản vá.

Trong ngôn ngữ đổ bóng kim loại, ID nguyên thủy là một số nguyên không dấu.

Chúng ta hãy xem xét một trường hợp sử dụng cho ID nguyên thủy.

Khử răng cưa tạm thời là một kỹ thuật làm giảm bóng ma và các hiện vật lung linh do chuyển động giữa các khung hình gây ra.

Nó hoạt động bằng cách tích lũy dữ liệu pixel từ khung trước đó và trộn nó với kết quả kết xuất hiện tại cho đoạn.

ID nguyên thủy có thể được sử dụng với khử răng cưa thời gian để xác thực mẫu từ khung trước đó.

Vậy bạn sẽ thực sự làm điều này như thế nào trong thực tế?

Đầu tiên, trong trình đổ bóng phân đoạn của bạn, bạn chiếu lại kết quả từ khung trước đó để tìm nạp lịch sử điểm ảnh.

Sau đó, bạn xem xét nội tâm pixel để đảm bảo rằng dữ liệu phù hợp với khung hình hiện tại.

Điều này có thể được thực hiện bằng cách so sánh ID nguyên thủy của hai mẫu.

Nếu ID khớp, bạn có thể chọn tích lũy đóng góp từ khung trước đó.

Lịch sử điểm ảnh có thể được tích lũy hoặc đặt lại sau khi xem xét, chuyển tiếp kết quả sang khung tiếp theo.

Bây giờ chúng ta đã giới thiệu tọa độ barycentric và ID nguyên thủy, chúng ta hãy đi sâu hơn...

Bắt đầu với kết xuất hoãn lại, một kỹ thuật mà bạn có thể đã quen thuộc.

Kết xuất hoãn lại hoạt động cổ điển trong hai giai đoạn.

Giai đoạn đầu tiên, tạo ra bộ đệm thuộc tính bề mặt, được gọi là bộ đệm G và giai đoạn thứ hai, tiêu thụ bộ đệm G và áp dụng ánh sáng trên cảnh.

Nhưng nếu bạn đang chạy ở độ phân giải cao hoặc sử dụng đa mẫu, kích thước của bộ đệm G có thể khá lớn và việc đọc và ghi các bộ đệm này có thể có chi phí băng thông cao.

Để giải quyết vấn đề này, bộ đệm G có thể được thay thế bằng một bộ đệm mỏng, chứa tập hợp các thuộc tính bề mặt tối thiểu.

Bộ đệm này được gọi là bộ đệm hiển thị.

Bộ đệm hiển thị giảm thiểu công việc trong giai đoạn hình học bằng cách đơn giản hóa đáng kể đầu ra từ giai đoạn này.

Tất cả logic vật liệu mà bạn thường thực hiện trong bộ đổ bóng đoạn trong kết xuất hoãn lại để tạo ra các thuộc tính vật liệu trong bộ đệm G hiện đã được chuyển sang pha chiếu sáng.

Bằng cách này, chúng ta không còn phải lưu trữ tất cả các thuộc tính vật liệu trong bộ đệm trung gian.

Nếu không có chức năng vật liệu, độ phức tạp của giai đoạn hình học sẽ giảm đáng kể, cho phép tỷ lệ lấp đầy cao và lưu lượng tối thiểu giữa bộ đổ bóng đỉnh và bộ đổ bóng phân đoạn.

Kỹ thuật này bổ sung một bước tái tạo mới trong quá trình chiếu sáng để tái tạo lại các đầu vào vật liệu từ tập dữ liệu tối thiểu bên trong bộ đệm khả năng hiển thị.

Chúng ta hãy xem bộ đệm hiển thị sẽ chứa những gì.

Bộ đệm khả năng hiển thị chỉ cần chứa hai thuộc tính để tạo điều kiện tái tạo hình học.

ID nguyên thủy có thể được sử dụng để truy xuất dữ liệu đỉnh theo cách thủ công từ bộ đệm đỉnh, thực hiện tìm nạp đỉnh bị trì hoãn một cách hiệu quả.

Tọa độ trung tâm được sử dụng để nội suy dữ liệu đỉnh cho đoạn hiện tại.

Như đã đề cập trước đó, bạn có thể truy cập các thuộc tính này trong bộ đổ bóng phân đoạn của mình trên A14.

Chúng ta hãy xem xét kỹ hơn hai giai đoạn của đường ống đệm tầm nhìn.

Ở mức cao, cách tiếp cận bộ đệm khả năng hiển thị có hai giai đoạn: giai đoạn hình học, tạo ra bộ đệm khả năng hiển thị và giai đoạn ánh sáng tiêu thụ nó.

Trong giai đoạn hình học, sự biến đổi của bộ đổ bóng đỉnh chỉ tạo ra vị trí cần thiết cho rasterization.

Giai đoạn phân đoạn có thể tạo ra ID nguyên thủy và tọa độ barycentric với các thuộc tính ngôn ngữ đổ bóng A14 Metal mới mà không cần bất kỳ sự thay đổi bổ sung nào.

Trong giai đoạn chiếu sáng, một bước tái tạo mới sẽ sử dụng tìm nạp đỉnh hoãn lại dựa trên ID nguyên thủy và nội suy dữ liệu đỉnh bằng cách sử dụng tọa độ barycentric để tạo ra các đầu vào hàm vật liệu.

Các bộ đổ bóng vật liệu và ánh sáng không bị ảnh hưởng một cách hiệu quả và giống hệt với việc triển khai kết xuất hoãn lại.

Chúng ta hãy xem các giao diện giữa các giai đoạn này đã được thu nhỏ như thế nào.

Bộ đổ bóng đỉnh chỉ yêu cầu vị trí để rasterize.

Bộ đổ bóng phân đoạn tạo ra ID bề mặt và tọa độ barycentric cho bộ đệm khả năng hiển thị được đưa vào bước tái tạo.

Và chỉ sau bước tái thiết, chúng ta mới có dữ liệu đầu vào vật liệu được tái tạo lớn trong bộ nhớ, được sử dụng bởi mô hình vật liệu và các chức năng chiếu sáng.

Bây giờ chúng ta đã giới thiệu các giao diện, chúng ta hãy xem các bộ đổ bóng đang tạo ra các đầu vào và đầu ra này.

Hãy bắt đầu với mặt hình học, có một đỉnh đơn giản và đổ bóng đoạn.

Bộ đổ bóng đỉnh chỉ cần biến đổi và xuất ra vị trí.

Trong bộ đổ bóng phân đoạn, chúng tôi sử dụng ID nguyên thủy mới và tọa độ barycentric có sẵn trong ngôn ngữ đổ bóng kim loại.

Chúng tôi kết hợp ID nguyên thủy và chỉ mục vẽ bổ sung vào mã định danh bề mặt của mình để chúng tôi có thể xác định các nguyên thủy trên các bộ đệm đỉnh, như chúng ta sẽ thấy sau.

Bây giờ chúng ta hãy nhìn vào sân khấu chiếu sáng.

Ở mức độ cao, giai đoạn chiếu sáng có ba bước: tái tạo, mô hình vật liệu và chức năng chiếu sáng.

Bước tái thiết sẽ tái tạo lại đầu vào vật liệu từ mã định danh bề mặt và tọa độ barycentric của chúng tôi.

Sau đó, chúng tôi có thể thực hiện các bước mô hình vật liệu của mình, như chúng tôi làm trong bộ đổ bóng hoãn lại của mình.

Và cuối cùng chúng tôi áp dụng chức năng chiếu sáng của mình để viết ra điểm ảnh sáng cuối cùng.

Như đã đề cập trước đó, vật liệu và các giai đoạn chiếu sáng giống hệt với trì hoãn cổ điển.

Vì vậy, chúng ta hãy xem xét bước tái thiết chi tiết hơn.

Mục đích chính của bước tái thiết là chuyển đổi đoạn đệm khả năng hiển thị đến thành đầu vào vật liệu.

Đầu tiên, điều này yêu cầu tạo dữ liệu đỉnh cho một đoạn nhất định bằng cách sử dụng ID nguyên thủy và ID vẽ có trong mã định danh bề mặt.

Một chỉ mục bổ sung tạo điều kiện cho việc có các bộ đệm đỉnh khác nhau trên các đoạn.

Đối với điều này, chúng tôi sử dụng mã định danh rút thăm để tham chiếu lệnh gọi rút thăm.

Thứ hai, tọa độ barycentric được sử dụng để nội suy trong bước tái tạo.

Hãy kiểm tra cây hủy tham chiếu.

Ở đây chúng tôi hiển thị cây hủy tham chiếu cần thiết để giải quyết pixel bộ đệm khả năng hiển thị trở lại các thuộc tính đỉnh nội suy ban đầu.

Bộ đệm hiển thị chứa hai tọa độ barycentric.

Tọa độ thứ ba có thể được lấy từ hai tọa độ còn lại vì tổng của cả ba là sự thống nhất.

Nó cũng chứa sự kết hợp giữa ID vẽ và ID nguyên thủy, như đã đề cập trước đó.

Từ ID vẽ, trạng thái vẽ có thể được truy xuất, cho phép truy cập vào các thuộc tính trên mỗi bản vẽ như ma trận chiếu chế độ xem.

Từ đó, chúng ta có thể truy xuất đỉnh và bộ đệm chỉ mục từ trạng thái lưới.

Các chỉ số này là cần thiết để tìm nạp dữ liệu đỉnh.

Và chúng ta cũng có thể sử dụng cùng một đường dẫn để truy xuất dữ liệu vật liệu cụ thể mà chúng ta cần.

Bây giờ nếu mô hình vật liệu của chúng ta trở nên phức tạp hơn, chúng ta có thể thêm một con trỏ hàm vật liệu để thực hiện logic vật liệu cụ thể.

Chúng ta hãy xem việc tái tạo trông như thế nào trong mã đổ bóng.

Điều đầu tiên cần làm trong chức năng tái tạo của bạn là truy xuất ID nguyên thủy, vẽ ID và tọa độ barycentric từ bộ đệm hiển thị.

Sau đó, bạn có thể tiến hành truy xuất ID lưới từ trạng thái vẽ bằng cách sử dụng ID vẽ.

Bộ đệm chỉ mục cần được hủy tham chiếu để truy xuất các chỉ số đỉnh trong bộ đệm đỉnh bằng cách sử dụng ID nguyên thủy và ID lưới.

Sau đó, dữ liệu bộ đệm đỉnh có thể được đọc và nội suy trên các tọa độ barycentric.

Ngoài ra, ma trận và thông tin mỗi lần vẽ khác có thể được truy xuất để thực hiện các phép biến đổi đỉnh hoãn lại trên các hình học như chuẩn và tiếp tuyến.

Khi đầu vào vật liệu đã được tạo ra, dữ liệu được đưa vào logic vật liệu và các chức năng chiếu sáng, như đã thảo luận trước đó.

Chúng ta hãy xem xét bộ đệm khả năng hiển thị đang hoạt động.

Đây là một cảnh kết xuất hiện đại đang sử dụng bộ đệm hiển thị đang chạy trên iPhone.

Nó đang thực hiện một kỹ thuật chiếu sáng gạch sử dụng nhiều vật liệu và một cảnh chứa đầy ánh sáng.

Thông thường, trong sự trì hoãn cổ điển, điều này sẽ yêu cầu nhiều kênh đệm G như bình thường, suất phản chiếu, độ nhám, v.v., chiếm một bộ đệm G khá lớn.

Nhưng với bộ đệm hiển thị, chúng ta chỉ cần ID bề mặt và tọa độ barycentric.

Đầu tiên, chúng tôi lưu trữ mã định danh bề mặt được tạo, được hiển thị ở đây với độ sáng và màu sắc hiển thị ID vẽ và ID nguyên thủy tương ứng.

Thứ hai, chúng tôi lưu trữ các tọa độ barycentric, được hình dung ở đây, với các kênh màu đỏ, xanh lá cây và xanh dương.

Hai tính chất này đủ để tái tạo lại hình học một cách hiệu quả và áp dụng các mô hình chiếu sáng và che bóng vật liệu bị trì hoãn.

Với kỹ thuật này, kích thước bộ đệm G được giảm đáng kể trên A14 bằng cách sử dụng bộ đệm tầm nhìn mỏng.

Trong ví dụ của chúng tôi, chúng tôi tiết kiệm hơn 40% kích thước bộ đệm G so với cổ điển bị trì hoãn.

Vì vậy, điều đó kết thúc việc lặn sâu của chúng tôi vào tọa độ barycentric và ID nguyên thủy.

Bây giờ chúng ta hãy xem nhanh các chế độ địa chỉ kết cấu mới trong A14.

Các chế độ này chỉ định cách xử lý tọa độ kết cấu nằm ngoài phạm vi lấy mẫu và khá tiện dụng khi bạn đang sử dụng tập bản đồ kết cấu.

Chúng tôi đã thêm hai chế độ địa chỉ mới trong Metal cho A14.

Với kẹp gương đến chế độ địa chỉ cạnh, tọa độ kết cấu trong phạm vi phạm vi của các phạm vi được phản chiếu trên trục.

Và khi chúng rơi ra ngoài, chúng bị kẹp chặt.

Bạn có thể thấy điều này trong bức tranh bên phải.

Chúng tôi cũng đã thêm chế độ kẹp màu viền, nơi bạn có thể chọn một trong các cài đặt trước giữa đen trong suốt, đen đục và trắng đục.

Cách sử dụng khá đơn giản.

Đầu tiên, bạn cần tạo một đối tượng mô tả mẫu.

Sau đó, bạn có thể chỉ định các chế độ kẹp cho tọa độ chiều sâu, chiều rộng và chiều cao một cách độc lập bằng cách đặt các chế độ địa chỉ.

Nếu bạn đang sử dụng clampToBorderColor, bạn có thể đặt một trong các cài đặt trước được hỗ trợ trong Metal.

Sau đó, bạn có thể tạo đối tượng samplerState với bộ mô tả bộ lấy mẫu.

Vì vậy, đó là tổng quan về các tính năng đồ họa mới trong A14.

Bây giờ tôi muốn trao nó cho đồng nghiệp Swami của tôi để mô tả các tính năng tính toán mới mà GPU A14 cho phép, bắt đầu với việc giảm SIMD.

Cảm ơn bạn, Anand.

Tôi là Swami Narayanan, và tôi làm việc với phần mềm GPU.

Metal được thiết kế để cho phép đồ họa hiệu suất cao cũng như thực hiện các phép tính song song dữ liệu và nó cung cấp nhiều tính năng tính toán nâng cao tận dụng sức mạnh to lớn của GPU.

Trên A14 Bionic, Metal hiện cung cấp các hướng dẫn giảm phạm vi SIMD, cung cấp một cách để các ứng dụng thực hiện giảm cực kỳ hiệu quả.

Để hiểu cách chúng hoạt động, hãy xem xét ngắn gọn các hoạt động giảm song song.

Các hoạt động giảm được sử dụng để giảm các phần tử của một mảng xuống một kết quả duy nhất.

Ví dụ, giảm tổng được sử dụng để cộng tất cả các phần tử của một mảng.

Điều này có thể hữu ích cho việc tính toán mức trung bình.

Một ví dụ khác là tính toán các giá trị tối thiểu và tối đa của một cảnh.

Những giá trị đó sau đó có thể được sử dụng trong các thuật toán ánh xạ âm.

Về mặt cổ điển, tất cả các hoạt động này được tính toán nối tiếp trên CPU.

Tuy nhiên, Metal có thể tận dụng bản chất song song của GPU để tính toán mức giảm hiệu quả hơn nhiều.

Trên GPU A14, Metal hiện hỗ trợ một số hướng dẫn giảm phạm vi SIMD.

Simd_sum và simd_product tạo ra tổng và tích của một biến trên tất cả các luồng trong một nhóm SIMD.

Simd_minimum và simd_maximum có thể được sử dụng để tìm các giá trị tối thiểu và tối đa.

Bốn hướng dẫn này hoạt động trên các loại dấu phẩy động và số nguyên.

Ngoài ra, Metal hiện hỗ trợ giảm bằng cách sử dụng các toán tử bit-wise "và," "hoặc" và "xor."

Đương nhiên, chúng chỉ hoạt động trên các loại số nguyên.

Trước khi xem xét các hoạt động giảm chi tiết hơn, hãy xem cách các luồng được tổ chức thành các nhóm luồng và nhóm SIMD.

Công văn tính toán khởi chạy một tập hợp các luồng riêng lẻ được biểu diễn dưới dạng lưới.

Lưới các luồng này được chia thành các lưới con nhỏ hơn được gọi là các nhóm luồng.

Các nhóm chủ đề được tổ chức thêm thành các nhóm gồm 32 chủ đề được gọi là nhóm SIMD.

Các luồng của một nhóm SIMD chạy đồng thời theo bước khóa.

Các chức năng của nhóm SIMD khai thác việc thực thi bước khóa này để chia sẻ dữ liệu giữa các luồng này.

Bây giờ chúng ta đã thấy cách các nhóm SIMD và nhóm luồng được tổ chức, chúng ta hãy xem cách các luồng được thực thi trong các nhóm SIMD.

Một nhóm SIMD có 32 làn đường được đại diện ở phía bên trái ở đây.

Mỗi làn đường này sẽ chạy một luồng từ công văn tính toán.

Bây giờ hãy để tất cả các luồng trong nhóm SIMD lưu trữ ID làn đường của chúng vào biến X.

Chú ý cách mỗi làn đường có giá trị X riêng.

Trong mô hình thực thi nhóm SIMD, lệnh đặt biến X thành ID làn đường chỉ được tìm nạp một lần và sau đó được thực thi đồng thời theo bước khóa bởi 32 luồng.

Các chức năng của nhóm SIMD cho phép mỗi luồng này kiểm tra và sử dụng các biến của các luồng khác trong nhóm SIMD với chi phí tối thiểu.

Hãy cùng xem simd_sum, một trong những hướng dẫn mới được thêm vào trong A14.

Simd_sum cộng các giá trị của một biến trên tất cả các luồng đang hoạt động trong nhóm SIMD và phát lại tổng cho tất cả các luồng.

Ở đây chúng tôi đang thêm các giá trị của biến X trên 32 làn của nhóm SIMD.

Khi lệnh được thực thi, tổng kết quả sẽ có sẵn trong biến F.

Lưu ý rằng tất cả các luồng đang hoạt động có thể kiểm tra bản sao của biến F để có được tổng tính toán là 496.

Các luồng không hoạt động bị bỏ qua trong tính toán một cách chính xác.

Họ không đóng góp vào số tiền cuối cùng.

Bây giờ chúng ta hãy xem cách chúng ta có thể sử dụng simd_sum để tăng tốc độ thêm các phần tử của một mảng lớn.

Ở đây mảng đầu vào nằm trong bộ nhớ thiết bị.

Mỗi nhóm SIMD đọc một tiểu vùng của mảng đầu vào và tính tổng của nó bằng cách sử dụng lệnh simd_sum.

Tổng này sau đó được ghi vào một mảng trong bộ nhớ nhóm luồng.

Mỗi nhóm SIMD có một ID riêng biệt mà nó có thể sử dụng để lập chỉ mục vào mảng tổng nhóm luồng.

Nhóm SIMD thực thi cuối cùng trong nhóm luồng sử dụng lại lệnh simd_sum để lấy tổng cuối cùng.

Bằng cách sử dụng simd_sum, chúng tôi đã giảm số lượng rào cản nhóm luồng và việc sử dụng bộ nhớ nhóm luồng.

Lệnh simd_sum cũng chỉ được thực thi một lần để tính tổng của tất cả các luồng trong nhóm SIMD.

Bây giờ chúng ta hãy đi đến việc triển khai hạt nhân tính toán.

Ở đây chúng tôi có mã thực hiện giảm song song bằng cách sử dụng simd_sum.

Mỗi luồng trong nhóm SIMD đọc phần tử tương ứng của nó từ mảng đầu vào.

Sau đó, nó tính toán simdgroup_sum đầu tiên bằng cách sử dụng lệnh simd_sum.

Tổng này sau đó được ghi vào một mảng trong bộ nhớ nhóm luồng được lập chỉ mục bằng ID nhóm SIMD.

Lưu ý rằng chúng ta cần một rào cản trước khi chúng ta có thể truy cập mảng trong bộ nhớ nhóm luồng.

Nhóm SIMD cuối cùng trong mỗi nhóm luồng sau đó sử dụng lại lệnh simd_sum để lấy tổng cuối cùng.

Chúng ta hãy xem xét các hoạt động giảm khác mà chúng tôi đã giới thiệu trong A14.

Chúng tôi đã thấy simd_sum, cộng các giá trị của X trên tất cả các làn đường đang hoạt động.

Bây giờ hãy nhìn vào simd_max và áp dụng nó vào biến X.

Mỗi làn đường sau đó nhận được giá trị tối đa, là 31, trên tất cả các luồng trong nhóm SIMD.

Tương tự, simd_min lưu trữ giá trị tối thiểu của X, tình cờ là 0 trong trường hợp này, trên tất cả các làn đường đang hoạt động.

Cuối cùng, chúng ta có simd_product, nhân tất cả các giá trị của X.

Vì một trong những biến số xảy ra là 0, sản phẩm cuối cùng được phát sóng là 0.

Những hướng dẫn này hoạt động trên cả loại vô hướng và vô hướng dấu phẩy động và loại vectơ.

Các hoạt động giảm cũng được hỗ trợ cho các hoạt động bitwise trên các loại tích phân.

Mỗi làn đường hiện có một giá trị trường bit được tạo ra bằng cách sử dụng ID làn đường như được hiển thị ở đây.

Sau đó chúng ta có thể sử dụng simd_hoặc hướng dẫn trên biến X.

Các giá trị của X trên tất cả các làn đường đang hoạt động được hoặc kết hợp với nhau và được phát trở lại biến F.

Giá trị cuối cùng này xảy ra là 0x1F3 trong ví dụ của chúng tôi.

Tương tự, simd_xor tính toán các giá trị xor của X và phát lại giá trị kết quả, hóa ra là 0x0.

Cuối cùng, chúng ta có simd_and, cộng tất cả các giá trị của X trên tất cả các luồng trong nhóm SIMD.

Đây hóa ra là hằng số 0x3.

Đó là tổng quan về các hướng dẫn giảm phạm vi SIMD mới có sẵn trong GPU A14.

Bây giờ chúng ta hãy xem xét một bộ hướng dẫn phạm vi SIMD mới giúp cải thiện đáng kể phép nhân ma trận.

Phép nhân ma trận là một hoạt động rất phổ biến đối với tính toán GPU và là khối xây dựng cơ bản cho nhiều khối lượng công việc tính toán song song.

Ví dụ, trong học máy, nó được sử dụng khi tính toán tích chập và các lớp nơ-ron được kết nối đầy đủ.

Đại số tuyến tính được sử dụng để biểu diễn và giải các hệ phương trình.

A14 giới thiệu một bộ hướng dẫn phạm vi SIMD hoàn toàn mới cho phép bạn triển khai nhân ma trận lớn rất hiệu quả.

Giống như các hoạt động giảm mà chúng ta đã thấy trước đây, đây là các hoạt động phạm vi nhóm SIMD.

Bây giờ bạn có thể dễ dàng xây dựng các chức năng lớn hơn, phức tạp hơn trên các khối xây dựng này.

Trong ngôn ngữ đổ bóng kim loại, bây giờ chúng ta có cấu trúc dữ liệu phạm vi nhóm SIMD để biểu diễn ma trận 8 x 8 và 4 x 4.

Sau đó, bạn có thể sử dụng các phiên bản nhân hoặc nhân_tích lũy của các hoạt động ma trận có phạm vi nhóm SIMD.

Hãy xem xét một ví dụ về việc nhân hai ma trận 16 với 16 trong một nhóm luồng bằng cách sử dụng các hàm này.

Chúng ta sẽ sử dụng phép toán ma trận nhóm SIMD 8 x 8 để xây dựng phép nhân ma trận nhóm thứ ba 16 x 16.

Đầu tiên chúng ta phân vùng ma trận kết quả trên bốn nhóm SIMD.

Mỗi nhóm SIMD sẽ chịu trách nhiệm tính toán một góc phần tư 8 x 8 của kết quả.

Tiếp theo, chúng tôi phân vùng ma trận đầu vào đầu tiên.

Ở đây, mỗi nhóm SIMD liên tiếp chia sẻ một cột khối duy nhất.

Sau đó chúng tôi phân vùng đầu vào thứ hai.

Ở đây mỗi nhóm SIMD trong một cột chia sẻ một hàng khối duy nhất.

Sau đó, chúng tôi sẽ tích lũy các sản phẩm từ bộ đầu tiên gồm 8 x 8 kết quả...

Và thứ hai.

Bây giờ chúng ta hãy xem cách viết cái này bằng ngôn ngữ đổ bóng kim loại.

Với A14, chúng tôi đã giới thiệu các đối tượng ma trận nhóm SIMD mới và các hoạt động nhân vào ngôn ngữ đổ bóng kim loại.

Những nguyên thủy mới này sẽ cải thiện đáng kể hiệu suất của phép nhân ma trận trong đổ bóng của bạn.

Nó rất dễ sử dụng và có thể được thực hiện chỉ với một vài dòng mã đổ bóng.

Ở đây chúng tôi xác định ba đối tượng để biểu diễn ma trận 8 x 8 với dữ liệu ở định dạng dấu phẩy động 32 bit.

Chúng tôi có một ma trận cho mỗi đầu vào của chúng tôi và một cho kết quả của chúng tôi.

Tiếp theo, chúng tôi thực hiện số học địa chỉ cần thiết để phân vùng bốn nhóm SIMD của chúng tôi trên mỗi góc phần tư của kết quả.

Sau đó, chúng tôi tích lũy một số ma trận từ mỗi ma trận nguồn, phát sóng hàng và cột thích hợp đến mỗi nhóm SIMD.

Cuối cùng, chúng tôi lưu trữ kết quả.

Bạn có thể thấy việc xây dựng các bộ đổ bóng phức tạp hơn dễ dàng như thế nào bằng cách sử dụng các nguyên thủy mới này.

Nếu bạn đang sử dụng bộ đổ bóng hiệu suất Metal, bạn sẽ được hưởng lợi từ phép nhân ma trận phạm vi nhóm SIMD để tăng tốc không chỉ phép nhân ma trận mà còn cả tích chập CNN.

Phép nhân ma trận cho các kích thước tùy ý có thể được thực hiện bằng cách sử dụng phép nhân ma trận MPS.

Ở đây chúng tôi đang mã hóa một hạt nhân để tính toán kết quả với các hàng M và N cột.

Tích chập CNN có thể được thực hiện bằng MPSCNNConvolution.

Ở đây chúng tôi đang mã hóa một hạt nhân tích chập trên một loạt các hình ảnh.

Cả hai hạt nhân này đều có sẵn bằng cách sử dụng biểu đồ Metal Performance Shaders mới được giới thiệu trong năm nay với iOS 14.

MPS Graph cho phép bạn lấy các hạt nhân cơ bản này và xây dựng các mạng học máy phức tạp với chúng.

Ví dụ, hãy xem hạt nhân ma trận từ trước đó có thể được sử dụng như thế nào trong biểu đồ.

Ở đây chúng tôi sẽ khởi tạo một biểu đồ mới cho hoạt động của chúng tôi.

Sau đó, chúng tôi xác định các nút để đại diện cho hai ma trận đầu vào của chúng tôi.

Sau đó, chúng tôi xây dựng một nút kết quả mới từ đầu vào của mình bằng cách sử dụng thao tác nhân ma trận.

Cuối cùng, chúng tôi thực hiện biểu đồ.

Để biết thêm chi tiết về cách sử dụng hạt nhân MPS và các hoạt động biểu đồ, vui lòng tham khảo các bài thuyết trình WWDC có sẵn trước đó.

Như đã đề cập trước đó, MPS sẽ tự động tận dụng lợi thế của A14 cho các hoạt động này.

Ở đây chúng ta có thể thấy thông lượng được cải thiện của phép nhân ma trận chung trên A14 so với A13.

Trên A14, sử dụng các hoạt động nhân ma trận nhóm SIMD mới, hiệu suất trung bình được cải thiện 37%.

Các tích chập của CNN trên A14 cho thấy sự cải thiện trung bình 36% so với A13.

Và khi chúng ta xem xét việc đào tạo một mạng lưới học máy đầy đủ như Inception V3, A14 cải thiện 22%.

Điều đó kết thúc phép nhân ma trận phạm vi nhóm SIMD.

Hãy tóm tắt lại các tính năng Metal mới cho A14.

Tọa độ Barycentric và ID nguyên thủy cho phép các kỹ thuật kết xuất hoãn lại mới bao gồm kết xuất bộ đệm khả năng hiển thị.

Các chế độ địa chỉ kết cấu mới, rất hữu ích khi sử dụng tập bản đồ kết cấu.

Hướng dẫn giảm phạm vi nhóm SIMD cho phép giao tiếp tốt hơn giữa các luồng.

Chúng tôi cũng đã cải thiện hiệu suất tính toán và học máy với các hướng dẫn nhân ma trận phạm vi nhóm SIMD.

Và cuối cùng, Metal trên A14 tận dụng một loạt các cải tiến kiến trúc, tiết kiệm băng thông với khả năng nén không mất dữ liệu được cải thiện, bộ nhớ cục bộ nhanh hơn và hiệu quả hơn và các đường ống điều khiển bằng GPU tốt hơn.

Cảm ơn bạn đã xem.