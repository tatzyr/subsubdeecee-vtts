10100

알레한드로 이사자: 안녕. 난 알레한드로야.

오늘 데이비드와 나는 데이터 조작과 탐사를 위한 새로운 프레임워크인 TabularData를 소개할 것이다.

빠른 소개로 시작한 다음 데이터 탐색, 데이터 변환, 모범 사례에 대해 이야기하고 요약으로 마무리하겠습니다.

뛰어들자.

먼저 제가 이야기해 드리겠습니다, 표 데이터가 무엇인가요?

가장 간단한 용어로, 표 데이터는 스프레드시트와 유사한 행과 열로 구성된 데이터이다.

하지만 수백 개의 열과 수백만 개의 행이 있다고 상상해 보세요.

이것이 TabularData 프레임워크가 들어오는 곳이다.

그래서 그게 뭐야?

그것은 우리가 작업해온 새로운 프레임워크이다.

그것은 이미 macOS, iOS, tvOS 및 watchOS에서 사용할 수 있습니다.

그것은 당신이 구조화되지 않은 데이터를 탐색하고 조작하는 데 도움이 될 것입니다.

내가 "구조화되지 않은 데이터"라고 말할 때, 나는 미리 정의된 방식으로 배열되지 않은 데이터를 의미한다.

예를 들어, 기술 사양이 없는 데이터 세트를 다운로드할 때; 예를 들어, 날씨 데이터나 인구 통계.

그리고 탐험은 새로운 데이터 세트를 만났을 때 가장 먼저 하는 일입니다.

당신은 거기에 어떤 종류의 정보가 있는지 알고 싶어합니다.

같은 것들, 가치는 무엇인가요?

어떤 종류들이야? 데이터는 어떻게 표현되나요?

누락된 값이 있나요? 그리고 계속.

데이터 세트를 제대로 이해하고 다음 단계인 조작으로 이동할 수 있으려면 이러한 질문에 답할 수 있어야 합니다.

조작은 데이터 세트를 해결하려는 문제에 가장 적합한 형태로 변환하는 곳입니다.

예를 들어, 날짜를 문자열 대신 날짜 유형으로 나타내거나, x와 y 좌표를 점 유형으로 결합할 수 있습니다.

TabularData 프레임워크는 대규모 데이터 세트를 다루는 데 적합합니다.

다음은 몇 가지 일반적인 사용 사례입니다.

몇 가지 기준에 따라 데이터를 그룹화하는 것; 예를 들어, 연령별로 사람들을 그룹화하는 것.

공통 가치에 대한 데이터 세트 결합하기.

예를 들어, 구매자의 정보와 거래 테이블을 결합하는 것.

점진적으로 처리하거나 전체 데이터 세트의 하위 집합으로 필터링하기 위해 데이터를 분할하거나 분할합니다.

그리고 데이터 파이프라인 구축; 예를 들어, 기계 학습을 위한 기능 엔지니어링을 할 때.

프레임워크의 맥락에서, 테이블은 DataFrame으로 알려져 있다.

DataFrame에는 스프레드시트와 유사한 행과 열이 포함되어 있습니다.

하지만 스프레드시트와 달리, 모든 열은 특정 유형의 값만 포함할 수 있다.

하지만 이것은 또한 열이 모든 유형, 심지어 자신의 사용자 지정 유형을 보유할 수 있다는 것을 의미합니다.

예를 들어, 사전, GPS 좌표 또는 원시 오디오 샘플.

DataFrame 또는 DataFrame 슬라이스를 나타내는 테이블을 표시할 때마다 왼쪽에 인덱스 열을 포함한다는 것을 알아두세요.

이것은 데이터 인덱스로 행에 액세스해야 할 때와 관련이 있습니다.

필터와 같은 일부 작업은 데이터가 변경되지 않는 반면, 정렬과 같은 다른 작업은 결과 데이터 프레임의 인덱스를 변경할 수 있습니다.

그것을 분해하고 열을 확대해 봅시다.

내가 언급했듯이, 열에는 특정 요소 유형이 있다; 이 경우, Int.

그것은 또한 데이터 프레임에서 고유해야 하는 이름을 가지고 있다.

열은 배열과 마찬가지로 컬렉션인 열 유형으로 표시됩니다.

이름으로 열을 참조할 수 있지만, 대부분의 경우 유형도 필요합니다.

열의 이름과 유형을 보유하고 있으며 특정 열을 참조하는 데 사용할 수 있는 ColumnID라는 구조체가 있습니다.

가능하다면, 열을 참조하기 위해 문자열 리터럴보다 미리 정의된 ColumnID를 사용하는 것이 좋습니다.

또한 DataFrame의 모든 열에는 동일한 수의 요소가 있어야 합니다.

하지만 nil 값으로 표현되는 누락된 요소가 항상 있을 수 있다.

기둥과 비슷하게, 행 유형이 있다.

열 이름이나 인덱스로 행의 각 요소에 접근할 수 있습니다.

당신은 로우를 프록시로 생각할 수 있습니다.

그것은 실제로 행의 요소를 포함하지 않습니다; 대신, DataFrame의 행을 가리키는 참조입니다.

그래서 DataFrame은 어떻게 만드나요?

내가 보여줄게.

사전 리터럴에서 DataFrame을 만들거나 한 번에 하나의 열을 만들 수 있습니다.

이것은 사전 문자 그대로의 건축의 예이다.

사전 리터럴을 사용할 때, 문자열, 숫자, 부울 값 및 날짜와 같은 기본 스위프트 유형을 사용해야 합니다.

또한 모든 열에는 같은 수의 요소가 있어야 한다는 것을 명심하세요.

DataFrame을 구축하는 더 일반적인 방법은 한 번에 하나의 열을 만든 다음 DataFrame에 열을 추가하는 것입니다.

여기 예시가 있어.

먼저, 나는 빈 데이터프레임을 만든다.

그리고 나서 나는 기둥을 만든다.

그리고 나서 DataFrame에 열을 추가합니다.

모든 열에 대한 프로세스를 반복할 수 있지만, 다시 말하지만, 모든 열에 동일한 수의 요소가 있고 열 이름이 고유한지 확인하십시오.

이제 DataFrame이 무엇인지 알았으니, 데이터 탐색을 좀 해봅시다.

가장 먼저 하고 싶은 일은 데이터 세트를 로드하는 것입니다.

TabularData는 쉼표로 구분된 값, CSV 및 JSON 파일 읽기를 지원합니다.

그리고 모든 기본 옵션을 사용하여 로드되는 파일 URL로 이니셜라이저를 호출하는 것만큼 간단합니다.

CSV를 로드할 때 사용할 수 있는 몇 가지 옵션을 살펴봅시다.

이전에 CSV를 사용한 적이 있다면, 항상 쉼표가 있는 것은 아니라는 것을 알 수 있습니다.

구분 기호는 탭이나 세미콜론일 수 있다.

또는 열 이름이 있는 헤더 행이 있을 수도 있고 없을 수도 있습니다.

또한 문자열이 특수 문자에 대해 이스케이프되는 방법과 누락된 값이 어떻게 표현되는지에 대한 변형이 있다.

TabularData는 모든 변형을 처리할 수 있다.

이 예에서는 사용자 지정 nil 인코딩을 사용하고, 빈 줄을 무시하고, 세미콜론 구분 기호를 사용하여 헤더 행이 없다는 것을 지정하고 있습니다.

전체 옵션 세트와 기본값을 보려면 문서를 참조하십시오.

더 큰 파일이 있다면, 한 번에 행의 하위 집합만 로드할 수 있습니다.

행 옵션으로 이것을 할 수 있습니다.

예를 들어, 이것은 처음 100개의 행만 로드할 것이다.

마찬가지로, 열의 하위 집합을 선택할 수 있습니다.

이렇게 하려면, 열 인수를 사용하세요.

이것은 또한 당신이 열을 재구성할 수 있게 해준다는 점에 유의하세요.

CSV 파일을 로드할 때 유형 추론이 어떻게 작동하는지 간략하게 이야기하겠습니다.

CSV 파일은 모두 텍스트 기반입니다.

하지만 모든 열을 문자열 유형으로 하는 것은 그다지 편리하지 않다.

따라서 CSV 파일을 로드할 때, TabularData는 문자열로 기본 설정하기 전에 값을 숫자, 부울 값 및 날짜로 변환하려고 시도합니다.

값을 특정 유형으로 강제하거나 로딩 속도를 조금 높이고 싶다면, 열의 유형을 명시적으로 지정할 수 있습니다.

당신은 유형 논쟁으로 이것을 합니다.

이 예에서, 우리는 id 열의 정수 유형과 이름 열의 문자열 유형을 지정하고 있습니다.

이것은 로딩 프로세스의 속도를 높일 뿐만 아니라, 지정된 유형으로 변환할 수 없는 값이 있는 경우 오류가 발생합니다.

이것은 당신이 기대하는 것과 다른 유형의 열로 끝나는 대신 문제를 일찍 파악하고 적절하게 처리할 수 있기 때문에 좋습니다. 이로 인해 나중에 앱에서 충돌이 발생할 수 있습니다.

마지막으로, 날짜 구문 분석에 대해 언급하겠습니다.

TabularData는 기본적으로 ISO8601 형식으로 날짜를 감지하고 구문 분석합니다.

CSV 파일에 다른 형식의 날짜가 포함되어 있다면, 사용자 지정 날짜 구문 분석 전략을 지정해야 합니다.

데이비드가 이것에 대해 이야기하게 하고 우리가 데모에 들어갈 때 너에게 예시를 보여줄게.

이제 기어를 바꾸고 데이터를 작성하는 것에 대해 이야기해 봅시다.

처음이자 가장 간단한 선택은 스위프트의 인쇄 기능을 사용하는 것이다.

이것은 터미널에서 멋지게 인쇄된 테이블을 생성할 것이다.

인쇄된 출력에는 행 인덱스, 열 이름, 열 유형, 처음 몇 줄의 데이터, 행과 열 수가 포함됩니다.

그것은 또한 모든 행이 화면에 맞지 않으며 모든 열이 화면에 맞지 않는다는 것을 나타냅니다.

이 경우, 표시되지 않는 열이 10개 더 있습니다.

인쇄는 탐색과 디버깅에 좋지만, 분명히 데이터 저장에는 좋지 않다.

DataFrame을 CSV 파일로 저장하려면, writeCSV 방법을 사용하세요.

주목해야 할 한 가지 중요한 점은 writeCSV가 모든 값의 기본 문자열 변환을 사용한다는 것입니다.

생성된 CSV는 다시 읽을 수 있는 것이 아닐 수 있으므로 열에서 사용자 지정 유형을 사용할 때 주의하십시오.

일반적으로 CSV로 쓸 때 열의 기본 스위프트 유형만 사용하며, 일부 열을 변환해야 할 수 있습니다.

writeCSV에는 읽기 옵션과 비슷한 몇 가지 옵션이 있습니다.

CSV 데이터가 작성되는 방식을 사용자 정의할 수 있습니다.

다음은 사용자 지정 nil 인코딩과 사용자 지정 구분 기호를 사용하여 헤더를 비활성화하는 예입니다.

특정 행에 접근하려면, 행 첨자를 사용할 수 있습니다.

그러면 그 행의 특정 열에 접근할 수 있습니다.

하지만 가능할 때마다, 대신 먼저 열에 접근한 다음 행에 접근해야 합니다.

이것이 당신이 칼럼에 접근하는 방법입니다.

이름으로 열에 접근하는 경우, 첨자에서 열: 라벨을 생략할 수 있습니다.

행의 하위 집합에 접근할 수도 있습니다.

이 경우, DataFrame 슬라이스를 얻을 수 있습니다.

DataFrame 슬라이스는 DataFrame과 매우 유사하다.

그것은 기본적으로 원래 DataFrame에 대한 참조입니다. 대부분의 상황에서, 당신은 그것이 전체 DataFrame인지 슬라이스인지 알 필요조차 없습니다.

그리고 마지막으로, 열의 하위 집합을 선택할 수도 있습니다.

이것은 그 열만 포함하는 새로운 DataFrame을 반환할 것이다.

필터 방법으로 행의 하위 집합을 선택할 수도 있습니다.

필터 작업의 결과는 행 범위를 선택하는 것과 유사한 DataFrame 슬라이스입니다.

하지만 다양한 행과 달리, 필터는 인접하지 않은 행을 반환할 수 있다.

DataFrame 슬라이스 인덱스를 다룰 때 조심해야 합니다.

배열 슬라이스와 마찬가지로, 그들의 인덱스는 원래 행의 인덱스를 반영한다.

특히, 첫 번째 인덱스는 0이 아닐 수도 있고, 다음 인덱스는 현재 인덱스 플러스 1이 아닐 수도 있다.

문자열 인덱스와 마찬가지로, 0 대신 startIndex, count 대신 endIndex, 하나를 추가하는 대신 index(after:)를 사용하고 싶습니다.

이제 기본 사항을 다뤘으니, 앱을 만들어 실행에 옮기자.

샌프란시스코에서 주차장을 찾는 것은 어렵다.

데이비드와 나는 거리의 인근 주차 공간을 보여주는 아이폰 앱을 만들고 싶다.

우리는 현재 주차가 허용되는 곳 근처에 있는 주차 미터기를 식별하기 위해 도시에서 발표한 데이터를 사용하고 싶습니다.

우리는 데이터 세트가 있다는 것을 알고 있지만 그것이 무엇을 포함하고 있는지 정확히 알지 못한다.

그래서 첫 번째 단계는 우리가 가진 것을 이해하기 위해 데이터 세트를 탐구하는 것이다.

내가 그걸 데이비드에게 넘겨줄게.

데이비드 핀들레이: 고마워, 알레한드로.

안녕. 저는 프레임워크 엔지니어인 데이비드입니다.

이 데모에서는 TabularData를 사용하여 데이터 세트를 탐색하는 방법의 예를 살펴보겠습니다.

주차 정책의 CSV 파일을 살펴보는 것으로 시작하겠습니다.

첫 번째 단계는 데이터 URL을 DataFrame 이니셜라이저에 전달하여 쉽게 할 수 있는 데이터를 로드하는 것입니다.

이니셜라이저는 던질 수 있으며, 잠재적인 구문 분석 오류를 처리할 때 유용하다고 생각합니다.

다음으로, 간단한 인쇄로 처음 몇 개의 행과 열을 탐색할 수 있습니다.

로드하는 데 몇 초가 걸렸고, 이는 DataFrame이 백만 개 이상의 행과 15개의 열을 메모리에 로드했기 때문입니다.

처음으로 데이터 세트를 탐색할 때, 나는 보통 전체 데이터 세트가 필요하지 않으므로, 탐색 속도를 높이기 위해 데이터를 로드할 때 행 범위를 지정할 것이다.

다음으로, 나는 칼럼을 살펴볼 것이다.

그들 중 두 개는 화면에 맞지 않기 때문에 오른쪽에 숨겨져 있다는 것을 주목하세요.

포맷 옵션으로 그것을 고치는 방법을 보여드리겠습니다.

포맷 옵션을 사용하면 데이터가 표시되는 방식을 구성할 수 있습니다.

이 경우, 나는 최대 LineWidth를 250으로 늘리고, 열 너비를 15로 줄이고, 인쇄된 결과를 스크롤하는 것을 방지하기 위해 행을 5로 줄일 것이다.

그런 다음 설명 방법을 사용하여 인쇄 문에 서식 옵션을 간단히 추가할 수 있습니다.

좋아! 이제 내 모든 칼럼을 살펴볼 수 있으니, 나는 보관할 몇 가지 흥미로운 칼럼을 고를 것이다.

또한 내가 원하는 순서대로 나열하여 칼럼을 재구성할 수 있는 좋은 기회이다.

저는 Hourly Rate, DayOfWeek, 시작 및 종료 시간, 시작 날짜 및 PostID가 있습니다.

다음으로 해야 할 일은 DataFrame을 로드할 때 이 열을 매개 변수로 추가하는 것입니다.

좋아, 이건 이미 탐험하기가 훨씬 쉬워.

문자열 유형이 있는 StartDate 열을 살펴보세요.

그것은 ISO8601 날짜만 자동으로 감지되기 때문이다.

다른 날짜 형식을 명시적으로 지정해야 합니다.

나는 알레한드로가 이전에 설명한 CSVReadingOptions를 사용하여 그것을 고칠 수 있다.

파운데이션 날짜 구문 분석 API를 사용하여 날짜 구문 분석 전략을 추가할 것입니다.

나는 형식을 년, 월, 일로, 로케일을 미국 영어로, 그리고 시간대를 태평양 표준시로 지정할 것이다.

그런 다음 DataFrame을 로드할 때 CSVReadingOptions를 전달할 것입니다.

이제 StartDate 열에 올바른 유형이 있으므로, 활성 주차 정책만 가질 수 있도록 DataFrame을 쉽게 필터링할 수 있습니다.

현재 날짜를 나타내는 변수로 시작한 다음, 필터 방법을 사용하여 DataFrame을 필터링할 것입니다.

필터 메서드는 열 이름 -- 이 경우, StartDate -- 및 유형 -- Date를 사용합니다.

클로저에서, 선택적 날짜를 풀고, 날짜 값이 nil일 때 false를 반환하여 필터 결과에 나타나지 않습니다.

그리고 마지막으로, 나는 현재 날짜보다 작거나 같은 시작 날짜를 유지한다.

필터링된 결과를 보여주기 위해 인쇄물을 변경하겠습니다.

이제부터, 나는 StartDate 열이 필요하지 않을 것이므로, 계속해서 제거할 것이다.

하지만 DataFrame 슬라이스에서 열을 제거할 수 없기 때문에 조심해야 합니다.

열을 제거하는 것은 돌연변이 방법이기 때문에 먼저 DataFrame으로 변환하고 var의 필터링된 정책을 만들어야 합니다.

이제 removeColumn 방법을 사용하여 열을 제거하고 StartDate 열을 제거할 열로 지정할 수 있습니다.

좋아, 그게 내가 주차 정책 데이터 세트에서 탐구하고 싶었던 전부야.

다음 섹션에서, 알레한드로는 표 데이터를 보강할 수 있는 방법에 대해 논의할 것입니다.

너에게 돌아가, 알레한드로!

알레한드로: 고마워, 데이비드.

이제 나는 데이터 세트에 대한 훌륭한 통찰력을 가지고 있다.

다음 단계는 우리의 필요에 맞게 그것을 변형하고 보강하는 것이다.

가장 간단한 종류의 변환은 열 내의 값을 바꾸는 것이다.

이것은 각 값이 다른 유형의 새로운 값으로 매핑되는 지도 작업의 형태를 취할 수 있다.

TabularData는 편의를 위해 지도의 현장 버전을 제공합니다: transformColumn.

이 예에서, 저는 DayOfWeek 열을 문자열에서 평일을 나타내는 정수로 변환하고 있습니다.

이것이 코드의 모습일 것이다.

각 요소에 대해, 우리는 문자열을 Int로 변환합니다.

transformColumn과 마찬가지로, 디코딩 방법은 데이터 디코딩을 처리합니다.

CSV 파일을 다룰 때, CSV에 JSON 값으로 포함된 배열이나 사전이 발생할 수 있습니다.

TabularData는 이를 위한 디코딩 방법을 제공한다.

다음은 왼쪽의 DataFrame에 JSON 데이터 BLOB이 포함된 예입니다.

디코드를 사용하면 JSONDecoder를 사용하여 열을 자신만의 유형으로 변환할 수 있습니다. 이 예에서는 환경 설정입니다.

그리고 이것이 코드가 어떻게 생겼는지이다.

환경 설정 유형은 Decodable 프로토콜을 준수해야 하며, 열은 JSONDecoder가 입력으로 기대하는 데이터 유형의 요소를 포함해야 한다는 것을 명심하십시오.

또 다른 유용한 작업은 채워진 방법이다.

열의 모든 누락된 값을 기본값으로 바꿀 수 있습니다.

그리고 열 작업 목록을 끝내기 위해, 나는 요약을 언급하고 싶다.

요약은 열의 내용에 대한 간략한 개요를 제공합니다.

요약 방법은 범주형 요약을 반환합니다.

그것은 설명에 someCount로 표시된 요소의 수, noneCount로 표시된 누락된 요소의 수, 고유한 요소의 수, 그리고 모드로 알려진 가장 빈번한 값을 포함합니다.

숫자 값이 포함된 열에서만 사용할 수 있는 숫자 요약도 있습니다.

여기에는 카운트, 평균, 표준 편차 및 기타 통계도 포함됩니다.

여기, 저는 요약의 인쇄 결과를 보여주고 있습니다.

하지만 요약 구조를 직접 사용하여 통계에 접근할 수도 있습니다.

예를 들어, 75번째 백분위수로 점수를 필터링하고 싶다면.

좋아, 그건 많은 열 변환이었지만, 열 변환은 가장 흥미롭지 않아.

데이터프레임 변환은 정말 흥미로워지는 곳이다.

열 변환과 달리, DataFrame 변환은 한 번에 여러 열을 조작합니다.

간단한 예는 정렬이다.

우리 모두는 정렬이 어떻게 작동하는지 알고 있지만, 명확하게 설명하겠습니다.

이 표를 점수로 분류해 봅시다.

이것은 모든 열에 영향을 미친다.

또한 정렬할 때 행 인덱스가 바뀐다는 점에 유의하세요.

또 다른 흥미로운 DataFrame 변환은 combineColumns이다.

combineColumns 방법을 사용하면 여러 열을 하나로 결합할 수 있습니다.

예를 들어, 위도와 경도에 대해 별도의 열이 있지만 CLLocation 유형으로 결합하고 싶다고 상상해 보세요.

여기 이것을 하는 예가 있습니다.

먼저, 나는 결합하고 싶은 열을 지정한다.

그리고 나서 나는 새 칼럼에 이름을 붙인다.

그런 다음 입력 열과 새 열의 유형을 지정하고, 모든 것이 선택 사항이어야 한다는 점에 유의합니다.

나는 누락된 가치 사례를 처리하고, 새로운 가치를 구축한다.

열과 마찬가지로, DataFrame에 대한 요약 방법도 있다.

그것은 모든 열에 대한 요약 통계를 반환합니다.

큰 DataFrame이 있는 경우 비용이 많이 들 수 있습니다. 관심 있는 열만 요약하는 것이 더 나을 수 있습니다.

또 다른 흥미로운 방법은 폭발이다.

요소 배열을 포함하는 열을 취하고 배열의 모든 요소에 대해 새 행을 만듭니다.

이 예시를 살펴봅시다.

이번에는 점수 열에 각 사람에 대한 점수 배열이 포함되어 있습니다.

폭발 작업을 DataFrame에 적용하면, 이들 각각은 새로운 행이 된다.

우리는 여러 점수를 가진 사람들을 위해 이름을 반복했다.

이것은 각 개별 점수를 살펴야 하는 다른 작업을 필터링하거나 수행할 때 유용합니다.

우리의 무기고에 있는 이 도구들로 나는 그것을 데이비드에게 돌려줄 것이다. 데이비드는 우리가 미터 데이터를 필요한 형태로 얻는 데 도움을 줄 것이다.

데이비드, 우리에게 코드를 좀 보여줘.

데이비드: 고마워, 알레한드로.

나는 너에 대해 모르지만, 나에게 주차에 대한 가장 중요한 부분은 위치야.

운 좋게도, 나는 내가 필요한 것을 가지고 있는 또 다른 CSV 파일을 가지고 있다.

그 안에 뭐가 있는지 보여줄게.

이전과 마찬가지로, 나는 데이터를 로드하는 것으로 시작할 것이지만, 이번에는 내가 관심 있는 열을 이미 알고 있다.

저는 POST_ID, STREET_NAME, STREET_NUM, LATITUDE 및 LONGITUDE를 가지고 있으며, 이전 데모와 동일한 서식 옵션을 사용하여 결과를 인쇄할 것입니다.

내가 원하는 첫 번째 보강은 위도와 경도 열을 핵심 위치 유형이 있는 새로운 열로 결합하는 것이다.

combineColumns 방법은 그 작업에 완벽하다.

여기서, 저는 위도와 경도 열을 위치라는 새로운 열로 결합하고 있습니다.

클로저에서, 저는 위도와 경도 매개 변수 유형과 핵심 위치 반환 유형을 지정합니다.

다음으로, 선택적 위도와 경도 값을 풀고, 둘 중 하나가 nil인 경우 nil을 반환합니다.

그리고 마지막으로, 위도와 경도 값을 핵심 위치 이니셜라이저로 전달합니다.

내 DataFrame의 위치로, 나는 내 앱의 첫 번째 기능을 구축하기 시작할 수 있다: 위치가 주어지면, 가장 가까운 주차 미터를 검색한다.

위치, DataFrame 및 검색 결과에 포함할 주차 미터의 양을 차지하는 closestParking이라는 함수를 작성할 것입니다.

로컬 카피로 시작하겠습니다.

그리고 나서 알레한드로가 이전에 도입한 transformColumn 방법을 사용하여, 나는 위치를 거리로 바꿀 것이다.

그리고 나서, 물론, 나는 위치 열의 이름을 거리로 바꿀 것이다.

마지막으로, 거리 열을 오름차순으로 정렬하고 반환할 지점의 수를 제한하겠습니다.

그냥 재미로, 샌프란시스코에 있는 애플 스토어를 사용하여 이것을 테스트해 봅시다.

Apple Maps, 미터 DataFrame에서 찾은 좌표를 연결하고 검색 결과를 5개의 주차 공간으로 제한하겠습니다.

완벽해! 포스트 스트리트에 있는 애플 스토어 근처에 주차장이 많은 것 같다.

앱의 첫 번째 기능은 잘 작동하지만, 가장 가까운 주차장이 모두 이미 이용되었다면 어떨까요?

이 앱의 다음 기능은 주차 공간이 가장 많은 거리를 찾는 것이다.

하지만 이 기능을 구현하기 전에, 그룹화라는 새로운 개념을 소개하겠습니다.

그룹화하면 그룹화 열이 주어지면 데이터를 그룹으로 나눕니다.

예를 들어, STREET_NAME 열.

그룹 방법은 먼저 포스트 스트리트, 캘리포니아 스트리트, 미션 스트리트와 같은 고유한 거리 이름 값을 식별한 다음 행을 해당 그룹으로 나눕니다.

각 그룹은 DataFrame 슬라이스이다.

이제, 코드로 다시 들어가 봅시다.

나는 그룹화된 방법을 사용하여 거리 이름으로 미터를 그룹화할 것이다.

그러면 나는 각 거리 그룹이 얼마나 많은 주차 미터를 가지고 있는지 세고 결과를 내림차순으로 제공할 수 있다.

주차 공간이 가장 많은 거리는 결과의 맨 위에 있으며, 이것이 내 앱에 필요한 것이다.

이건 정말 멋져!

내 앱을 위한 두 가지 훌륭한 기능.

하지만 잠시만요, 저는 방금 첫 번째 기능에 버그가 있다는 것을 깨달았습니다.

가장 가까운 주차 미터는 미터 데이터 프레임만 고려합니다.

내가 정말로 필요한 것은 활성 주차 정책이 있는 가장 가까운 주차 미터기이다.

그 정보가 데모의 데이터에 있기 때문에, 이것은 점점 흥미로워지고 있다.

버그를 고칠 수 있도록 두 개의 다른 소스의 데이터를 결합하는 방법을 보여드리겠습니다.

이전에 관계형 데이터베이스를 사용한 적이 있다면 가입에 익숙할 수 있습니다.

키를 사용하여 두 개의 데이터프레임을 함께 결합할 수 있습니다.

키는 두 데이터프레임 모두에 나타나는 값이다.

미터와 정책 데이터프레임에서, 열쇠는 주차 미터를 고유하게 식별하는 POST_ID이다.

조인 작업은 미터의 POST_ID가 정책의 POST_ID와 일치하는 행이 있는 DataFrame을 생성합니다.

행은 왼쪽 DataFrame과 오른쪽 DataFrame의 일치하는 데이터로 구성되어 있습니다.

열 이름에는 왼쪽 또는 오른쪽 접두사가 있습니다.

이것은 열의 조인 중 어느 쪽에서 왔는지를 나타낸다.

접두사는 조인 결과에서 명명 충돌을 피하는 데 도움이 된다.

이 작업은 기본값인 내부 조인이었다.

다른 세 가지 결합 종류가 있습니다: 왼쪽 바깥쪽, 오른쪽 바깥쪽, 그리고 전체 바깥쪽.

여기서 자세한 내용은 다루지 않겠지만, 자세한 내용은 문서를 참조하십시오.

좋아, 그게 내가 표 데이터 증강에서 다루고 싶었던 전부야.

다음 섹션에서, 알레한드로는 모범 사례에 대해 이야기할 것이다.

알레한드로: 고마워, 데이비드.

이제 우리가 필요한 형태로 모든 데이터를 가졌으니, 앱을 구축할 때입니다.

프로덕션을 준비하면서 탐색 코드를 재사용할 수 있는 방법에 대해 이야기하겠습니다.

CSV 파일을 로드하기 위해 우리가 시작한 코드로 돌아가겠습니다.

이렇게 하면, 열에는 알 수 없는 유형이 있을 것이다.

이것은 필터나 미리 유형을 알아야 하는 조인과 같은 작업에 문제가 있습니다.

사용자가 제공한 소스에서 데이터를 로드하는 경우, 유형에 대한 가정은 위험합니다.

앱 충돌로 이어질 수 있습니다.

대신, 이 예와 같이 데이터를 로드할 때 예상되는 유형을 선언해야 합니다.

여기서, 나는 내가 신경 쓰는 모든 열에 대한 열 ID를 정의하고 있다.

그리고 나서 나는 CSV 이니셜라이저에 열 이름과 열 유형을 모두 제공하고 있다.

열을 참조하는 모든 방법에서 문자열 대신 열 ID를 사용할 수 있다는 것을 기억하세요.

이제, 유효하지 않은 값이 있는 경우, 예를 들어 사용자에게 오류를 표시하여 처리할 수 있는 예외가 발생합니다.

이렇게 하면 당신이 기대하는 열과 열 유형을 가질 수 있습니다.

이것은 사용자 지정 날짜 형식을 사용할 때 특히 중요합니다. 열이 날짜 유형이라고 지정하지 않으면 날짜 구문 분석이 자동으로 실패하고 대신 문자열 열을 생성할 수 있기 때문입니다.

날짜를 강제로 사용하면 실패한 셀의 내용을 포함하는 예외가 발생하여 문제를 디버깅하는 데 도움이 될 것입니다.

오류에 대해 말하자면, 이것들은 CSV 파일을 로드할 때 예상해야 하는 일종의 오류입니다.

사용자 지정 날짜 파서를 사용하고 셀이 구문 분석에 실패할 때 구문 분석에 실패하면 생성됩니다.

다른 것들은 자명하지만, 문서를 참조하십시오.

그리고 끝내기 위해, 공연에 대해 간단히 언급하겠습니다.

대부분의 경우 성능에 대해 걱정할 필요가 없지만, 대규모 데이터 세트로 작업할 때 큰 영향을 미칠 수 있는 몇 가지 경우가 있습니다.

첫 번째는 CSV를 로드할 때 날짜 구문 분석이다.

날짜 구문 분석에는 많은 특별한 사례와 고려 사항이 있으며, 따라서 느린 경향이 있다.

CSV 파일을 로드하는 데 몇 초 이상 걸린다면, 이것은 당신이 개선해야 할 첫 번째 장소입니다.

한 가지 옵션은 구문 분석을 지연시키는 것이다.

이것은 날짜 정보가 즉시 필요하지 않을 때 특히 잘 작동합니다.

예를 들어, 먼저 필터링이나 그룹화 작업을 수행하고 싶습니다.

그것이 옵션이 아니라면, 날짜 문자열의 성능을 최적화하는 날짜 파서를 손으로 만드는 것을 고려해 보세요.

그룹화할 때, 항상 문자열이나 Int와 같은 기본 Swift 유형을 그룹 열로 포함하는 열을 사용하세요.

이것은 그룹화 성능을 가속화할 것이다.

하나 이상의 열로 그룹화하는 경우, 먼저 열을 간단한 유형의 단일 열로 결합한 다음 그룹화하는 것을 고려하십시오.

예를 들어, 요일과 미터 유형별로 그룹화하려면, 이 두 속성을 문자열로 결합하는 것을 고려해 보세요.

예를 들어, 데이 타입.

마찬가지로, 가입할 때, 기본 스위프트 유형이 포함된 열에 가입하는 것을 고려해 보세요.

이것으로, 우리는 앱을 끝낼 준비가 되었습니다.

데이비드, 마무리하자.

데이비드: TabularData 모범 사례를 사용하여 앱의 검색 기능을 작성하겠습니다.

주차 구조체는 결합된 미터와 정책 DataFrame을 저장할 것이다.

그리고 나는 여러 방법이 필요하기 때문에 위치 ColumnID를 정의했다.

loadMeters 방법의 세부 사항에 대해 자세히 알아봅시다.

맨 위에는 미터기를 적재하는 데 필요한 열 ID가 있습니다.

그런 다음, 나는 미터를 로드하고 각 열의 예상 유형을 지정한다.

제공된 CSV 파일에 불일치가 있으면 던져질 것이다.

다음으로 나는 해결된 열이 정확히 내가 예상했던 것인지 확인하고, 그렇지 않으면 사용자 지정 ParkingError를 던질 것이다.

마지막으로, 위도, 경도 및 위치 열 ID를 사용하기 위해 combineColumns 작업을 리팩토링했습니다.

그것으로, 앱의 검색 기능은 생산 준비가 되어 있다.

TabularData 프레임워크의 요약을 위해 알레한드로에게 돌려줄게.

알레한드로: 고마워, 데이비드. 요약하자.

오늘 우리는 TabularData를 통해 알 수 없는 데이터 세트를 탐색하고, 조작하고, 앱으로 가져올 수 있는 방법을 보여주었습니다.

우리는 데이터 세트를 탐구하고, 일부 열과 데이터 변환을 살펴보고, 오류 처리 및 성능에 대한 몇 가지 모범 사례로 마무리했습니다.

나는 네가 훌륭한 앱을 만들기 위해 TabularData를 어떻게 사용하는지 빨리 보고 싶어.

고마워!