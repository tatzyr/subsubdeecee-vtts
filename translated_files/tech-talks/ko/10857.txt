10857

안녕. 저는 애플의 OS 성능 팀의 패트릭입니다.

오늘 우리는 당신의 앱에서 렌더링 걸쇠를 신비화하고 제거하는 데 뛰어들 것입니다.

iOS는 렌더링 루프를 사용하여 뷰를 표시하며, 히치는 렌더링 루프가 디스플레이를 위해 제 시간에 프레임을 완료하지 않을 때마다입니다.

전체 렌더링 루프에 대한 개요를 보려면, 제 강연 "UI 애니메이션 히치와 렌더링 루프 탐색"을 확인하세요.

여기서 우리는 렌더링 준비 및 렌더링 실행 단계의 느림으로 인한 히치인 렌더링 히치에 초점을 맞출 것입니다.

먼저, 이 두 렌더링 단계가 무엇인지 살펴본 다음, 인스트루먼트와 Xcode 뷰 디버거를 사용하여 앱에서 렌더링 히치를 잡고 분류하는 방법을 살펴보겠습니다.

마지막으로, 우리는 레이어 트리를 최적화하고 히치가 사용자 경험을 방해하는 것을 막기 위한 몇 가지 권장 사항을 살펴볼 것입니다.

렌더링 단계를 정의하는 것부터 시작합시다.

커밋 단계에서, 앱은 UI를 수정하고 처리를 위해 업데이트된 UI 레이어 트리를 제출합니다.

우리는 이러한 제출을 "커밋"이라고 부르며, 렌더링 서버는 모든 포그라운드 프로세스에 대한 커밋을 렌더링할 책임이 있습니다.

렌더링 서버의 작업이 한 프레임 시간보다 오래 걸린다면, 충돌할 수 있다.

작업은 앱의 프로세스 외부에서 발생하지만, 렌더링 작업은 앱을 대신하여 수행되므로 앱의 레이어 트리를 렌더링하는 데 걸리는 시간을 책임집니다.

렌더링 서버에는 두 단계가 있습니다: 렌더링 준비와 렌더링 실행.

렌더링 준비 단계는 레이어 트리가 GPU가 실행할 수 있는 간단한 작업의 파이프라인으로 컴파일되는 곳입니다.

몇 프레임으로 이루어지는 애니메이션도 여기에서 처리됩니다.

렌더링 실행 단계에서, GPU는 앱의 레이어를 표시할 준비가 된 최종 이미지로 그립니다.

이 단계들 중 어느 쪽이든 프레임의 배달 시간을 지연시킬 수 있다.

이러한 개념을 이해하는 데 도움이 되도록, 예제 렌더링을 살펴봅시다.

우리는 이 프레임의 렌더링을 살펴볼 것이다.

그림자가 원과 바 둘 다 주변에 있다는 것을 주목하세요.

이것은 나중에 중요해질 것이다.

우리는 앱이 왼쪽의 렌더링 서버에 제출한 레이어 트리로 시작합니다.

렌더링 서버는 레이어별로 단계별로 GPU가 UI를 앞뒤로 그릴 수 있는 드로잉 명령 파이프라인을 컴파일합니다.

루트 노드에서 시작하여, 렌더링 서버는 계층 구조의 모든 레이어를 가질 때까지 형제에서 형제로, 부모에서 자식으로 걸어간다.

마지막으로, GPU가 다음 실행 단계에서 실행할 수 있는 전체 파이프라인이 있습니다.

GPU의 임무는 이 파이프라인을 타고 각 단계를 중앙의 최종 텍스처로 그리는 것이다.

디스플레이 단계에서 화면에 표시되는 것은 이 텍스처입니다.

첫 번째 파란색 레이어부터 시작하여, 지정된 경계에서 색상을 그립니다.

다음으로, 더 어두운 파란색이 그 경계로 그려지고, 우리는 다음 층으로 넘어간다.

하지만 이제, GPU는 그림자를 그려야 한다.

그림자 모양은 다음 두 층으로 정의되므로, GPU는 어떤 모양으로 그림자를 그릴지 모른다.

하지만 우리가 원과 막대를 먼저 그린다면, 그림자는 그것들을 검은색으로 가리고 잘못 보일 것이다.

그것은 GPU가 장애물에 부딪혔다는 것을 의미하며, 계속하려면 그림자의 모양을 파악하기 위해 다른 텍스처로 전환해야 합니다.

우리는 이것을 "오프스크린 렌더링"이라고 부른다. 왜냐하면 우리는 최종 텍스처가 아닌 다른 곳을 그리고 있기 때문이다.

여기서부터, 그것은 원과 막대를 그릴 수 있다.

그리고 이제 그것은 오프스크린 텍스처에 고립된 그림자 모양을 가지고 있다.

그것은 먼저 레이어를 검은색으로 만든 다음 흐리게 하여 그림자 모양을 만드는 데 필요한 모든 것을 갖추고 있다.

그런 다음 오프스크린 텍스처를 최종 텍스처로 복사할 수 있으며, 그림자 레이어가 완료되었습니다.

다음 단계는 원과 직사각형을 다시 그리는 것이다.

그것은 앱이 맨 위에 그린 텍스트의 이미지를 복사하여 끝날 것이다.

우리는 이제 두 렌더링 단계를 모두 완료했으며, 프레임을 표시할 준비가 되었습니다.

하지만 우리는 그림자를 렌더링하기 위해 특별한 트릭을 해야 했고, 이로 인해 렌더링이 더 오래 걸렸습니다.

이것은 오프스크린 패스라고 불린다.

오프스크린 패스는 GPU가 먼저 다른 곳으로 렌더링한 다음 복사하여 레이어를 렌더링해야 하는 경우입니다.

그림자와 함께, 그것은 최종 모양을 알아내기 위해 층을 그려야 했다.

오프스크린 패스는 추가되어 렌더링을 유발할 수 있으므로 앱에서 모니터링하고 피하는 것이 중요합니다.

최적화할 수 있는 네 가지 주요 유형의 오프스크린 패스가 있습니다: 그림자, 마스크, 둥근 직사각형 및 시각 효과.

우리는 예제 렌더링에서 그림자 오프스크린의 예를 보았다.

이 경우, 렌더러는 먼저 첨부된 레이어를 그리지 않고 그림자를 그릴 수 있는 충분한 정보가 없다.

오프스크린의 두 번째 유형은 레이어나 트리의 레이어가 마스킹이 필요할 때이다.

렌더러는 마스크된 하위 트리를 렌더링해야 한다.

하지만 그것은 또한 마스크된 모양 외부의 픽셀을 덮어쓰는 것을 피해야 한다.

따라서 마스크된 모양 내의 픽셀만 최종 텍스처로 복사하기 전에 전체 하위 트리를 오프스크린으로 렌더링합니다.

이 오프스크린은 사용자가 절대 볼 수 없는 많은 픽셀을 렌더링할 수 있다.

세 번째 유형은 마싱과 관련이 있다.

레이어의 모서리를 둥글게 하는 것은 때때로 오프스크린이 필요할 수 있다.

충분한 정보가 제공되지 않으면, 렌더러는 전체 뷰를 오프스크린으로 그린 다음 둥근 모양 내부의 픽셀을 다시 복사해야 할 수도 있습니다.

네 번째 유형은 시각 효과 보기에서 나온 것이다.

UI 키트는 두 가지 시각 효과 유형을 제공합니다: 활기와 흐림.

이러한 효과를 적용하려면, 렌더러는 시각적 효과 보기 아래에 있는 것을 오프스크린 패스가 있는 다른 텍스처로 복사해야 합니다.

그런 다음 시각 효과 유형을 결과에 적용하고 다시 복사합니다.

iOS, tvOS 및 macOS에서 매우 일반적이기 때문에 UI 탐색 모음, UI 탭 바 및 기타 많은 표준 컨트롤에서 이것을 볼 수 있습니다.

따라서 이 네 가지 오프스크린 유형은 렌더링 속도를 늦추고 렌더링 히치를 일으킬 수 있습니다.

이제 렌더링 단계의 세부 사항을 설명하고 많은 수의 오프스크린 패스가 어떻게 발생할 수 있는지 보았으니, 두 번째 주제로 넘어가자: 악기로 히치 찾기.

인스트루먼트 12에서, 우리는 당신의 앱에서 히치를 프로파일링하기 위한 새로운 인스트루먼트 템플릿을 출시했습니다.

일부 사용자는 Meal Planner 앱의 히치에 대해 불평했고, 저는 조사하고 싶습니다. 그래서 저는 Instrument에서 시작하고 앱에서 스크롤을 시작합니다.

그리고 여기 애니메이션 히치 템플릿을 사용하는 Meal Planner 앱의 흔적이 있습니다.

나는 스크롤하는 동안 본 몇 가지 히치에 뛰어들고 싶다.

히치 16을 찾기 위해 히치 트랙을 확대하고 확장합시다.

각 트랙은 우리가 이전에 이야기했던 렌더 루프의 단계에 해당한다.

정상을 따라 가장 중요한 트랙이 있다. 그것은 히치 간격을 보여준다.

이것은 프레임이 준비되어야 했던 이후의 시간이다.

사용자 이벤트 트랙은 히칭 프레임과 관련된 사용자 이벤트를 보여줍니다.

커밋 트랙은 해당 프레임 동안 렌더링 서버로 전송된 모든 커밋 단계를 보여줍니다.

특히 이 트랙에 대한 자세한 내용은 "Commit Phase에서 Find and Fix Hitches"를 시청하세요.

그리고 여기 우리가 이 비디오에서 집중했던 것이 있습니다.

렌더링과 GPU 트랙은 렌더링 서버가 수행한 작업을 보여줍니다.

Frame Lifetimes 트랙은 이벤트에서 디스플레이까지 프레임을 구성하는 데 걸린 전체 기간을 보여줍니다.

그리고 마지막으로, 내장 디스플레이 트랙은 도중에 일어난 VSYNC와 함께 디스플레이에 나타난 모든 프레임을 보여줍니다.

프레임 수명을 히치 기간의 시작과 비교하여 프레임 구성이 완료되어야 하는 예상 간격을 시각화할 수 있습니다.

이 히치에서, 우리는 두 프레임이 끝났고, VSYNC를 따르는 것에서, 우리는 커밋과 렌더링 단계가 시간이 지남에 따라 갔다는 것을 알 수 있다.

이 간격은 허용 가능한 대기 시간이라고 불리며, 그 이후의 모든 시간은 히치 기간이다.

트랙 아래에서, 우리는 히치 트랙이 선택될 때 히치의 상세한 메트릭을 볼 수 있습니다.

우리는 히치 16을 보고 있었어.

우리는 히치 시간과 허용 가능한 대기 시간을 볼 수 있다.

이것이 우리가 프레임을 완성해야 했던 시간이다.

버퍼 수는 히치 시 렌더링 서버가 사용하는 버퍼 수입니다.

기본값은 2이지만, 렌더링 프레임이 지연되고 렌더링 서버가 따라잡으려고 할 때 3이 될 수 있습니다.

이중 버퍼링 모드에서는 iPhone에 두 개의 프레임 또는 33.34밀리초가 있으며, 이는 대기 시간 열에서 볼 수 있는 것입니다.

버퍼 수에 상관없이 항상 관심 영역을 강조하는 위의 히치 기간 트랙을 따르는 것을 항상 잊지 마세요.

마지막으로, 히치 유형이 있다.

히치 유형은 히치 유형을 표면화하며 앱에서 무엇을 할 것인지에 대한 맥락을 제공하는 데 도움이 됩니다.

여기서, 우리는 값비싼 커밋과 값비싼 GPU 시간을 모두 가지고 있다는 것을 알 수 있으며, 이는 우리가 위의 트랙에서 본 것이다.

확장하여, 우리는 렌더링 및 GPU 트랙에 집중하고 준비 및 실행 단계에 대한 더 많은 정보가 있는 분석기를 볼 수 있습니다.

중요한 열은 GPU가 만들어야 했던 오프스크린 패스의 수를 볼 수 있는 렌더링 카운트이다.

우리는 렌더링에 문제가 있다는 것을 알고 있기 때문에, 우리는 이러한 오프스크린을 살펴보고 무엇이 그들을 일으키는지 그리고 어떻게 고칠 수 있는지 이해해야 한다.

레이어 트리를 보는 가장 좋은 방법은 Xcode 뷰 디버커를 사용하는 것입니다.

그래서 그것을 위해, 데모로 가자.

여기 우리는 식사 플래너 앱이 일시 중지된 뷰 디버거에 있습니다.

왼쪽에는 뷰 컨트롤러, 창, 제약 조건 및 뷰가 있습니다.

하지만 Xcode 11.2부터 시작하여 레이어를 보여줄 수도 있습니다.

편집기를 클릭하면, 새로운 레이어 표시 항목을 클릭해 봅시다.

멋지다.

이제 네비게이터의 왼쪽에서 우리는 모든 뷰를 클릭하고 레이어와 모든 하위 레이어를 볼 수 있습니다.

레이어를 선택하면, 레이어의 유용한 속성을 제공하는 이 새로운 레이어 인스펙터가 표시됩니다.

그래서 우리는 여기서 태그 뷰 백업 레이어가 있다는 것을 볼 수 있으며, 배경색, 불투명도, masksToBounds 및 기타 많은 속성을 활성화했는지 여부를 볼 수 있습니다.

중요한 것은, 우리는 오프스크린 수를 볼 수 있다는 것이다.

이것은 이 레이어를 렌더링하는 데 걸린 오프스크린의 수이다.

그 아래는 우리가 오프스크린 플래그라고 부르는 것이다.

이것들은 오프스크린의 이유를 설명한다.

예를 들어, 오프스크린 마스크와 같은 주어진 플래그는 여러 수의 오프스크린을 트리거할 수 있다.

예를 들어, 여기 두 개가 있습니다.

하지만 우리가 전체 앱의 각 레이어를 파헤쳐 오프스크린 수를 확인한다면, 우리는 여전히 이러한 오프스크린 패스를 줄일 수 있는 충분한 통찰력을 갖지 못할 것이다.

뷰와 레이어 계층 구조에서 성능 최적화를 식별하고 제안하기 위해, 우리는 최적화 기회라고 부르는 Xcode 12에 새로운 런타임 문제 유형을 추가했습니다.

이것들은 기본적으로 활성화되어 있지만, 최적화 기회 보기 아래의 편집기 메뉴에서 옵션을 찾을 수 있습니다.

이러한 최적화 기회는 수년간 앱의 렌더링 성능을 최적화한 후 Apple의 성능 팀이 개발하고 작성한 놀라운 자원입니다.

이것들은 레이어의 전반적인 모양에 영향을 미치지 않는 간단하면서도 가치 있는 변화를 제안하기 위한 것입니다.

네비게이터에서, 우리는 일부 레이어에서 보라색 런타임 문제 표시기를 볼 수 있습니다.

여기 우리의 스타 레이어가 있습니다.

우리는 검사관에서 그것이 다섯 개의 오프스크린을 찍는 것을 본다.

지표를 강조하면 그 원인은 역동적인 그림자 때문이라는 것을 알 수 있다.

자세한 내용을 보려면 런타임 이슈 네비게이터로 가자.

우리가 그 문제에 대한 메시지를 읽을 수 있는 것은 바로 여기에 있다.

그것은 레이어가 렌더링 비용이 많이 드는 동적 그림자를 사용하고 있다고 말한다.

가능하다면, shadowPath를 설정하거나 그림자를 이미지로 미리 렌더링하여 레이어 아래에 넣으세요.

우리는 슬라이드에서 이러한 유형의 오프스크린에 대해 논의한다.

렌더러는 충분한 정보가 없으며 그림자의 모양을 파악하기 위해 오프스크린 레이어를 그려야 합니다.

CALayer의 shadowPath 속성을 사용함으로써, 우리는 실제로 렌더러에게 다섯 개의 오프스크린을 모두 사용하고 제거하는 정확한 단계를 제공할 수 있습니다.

이것들은 정말 우리 앱에 추가되므로, 코드를 살펴보고 이 변경을 합시다.

여기 우리는 그림자를 설정한 별 층과 함께 있다.

최적화 텍스트는 우리에게 CGPath를 허용하는 shadowPath를 설정하라고 말했다.

우리가 이미 만든 별 경로를 재사용합시다.

그렇게, 우리는 CollectionViewCell당 다섯 개의 오프스크린 패스를 제거했습니다.

그건 큰 해결책이야.

이제 디버그 네비게이터로 돌아가서, 우리는 여전히 다른 런타임 문제 지표를 볼 수 있습니다.

태그 보기에서, 우리는 레이어에서 런타임 문제를 본다.

네비게이터에서, 우리는 오프스크린 마스크로 인한 두 개의 오프스크린을 본다.

이 레이어는 이미지 뷰와 라벨 뷰로 구성되어 있다.

우리는 빨간색 배경을 벗어나는 것에 대해 걱정했기 때문에, 마스크 레이어를 추가했다.

런타임 도구 팁에서, 우리는 그 원인이 단순한 배경색 마스킹이라는 것을 알 수 있다.

이슈 네비게이터에서, 우리는 기회 텍스트를 본다.

이 레이어는 배경색이 마스크로 설정된 간단한 레이어를 사용하고 있다고 말한다.

대신, 마스크와 같은 프레임과 코너 반경의 컨테이너 레이어를 사용하세요. 두 masksToBounds 모두 "예"로 설정되어 있습니다.

오프스크린은 마스크 레이어를 먼저 렌더링해야 하는 렌더러로 인해 발생하며, 제안은 이 레이어를 완전히 제거하는 것입니다.

코드로 확인해 봅시다.

여기 우리의 태그 보기가 있습니다.

우리는 마스크 레이어를 만들고 검은색 배경색과 모서리 반경을 제공합니다.

이 마스크 레이어는 간단하며, 간단한 레이어는 절대 마스크가 되어서는 안 됩니다.

대신, 렌더러가 도면을 최적화할 수 있도록 실제 레이어에서 요청된 마스크 모양을 정의해야 합니다.

대신 우리가 원하는 대로 코너 반경을 10으로 설정한 다음, masksToBounds를 "True"로 설정할 수 있습니다.

그런 다음 마스크를 완전히 삭제하세요.

하지만 그것은 화면 밖에서 하나만 제거한다.

하위 레이어가 있기 때문에, masksToBounds는 뷰가 올바르게 잘렸는지 확인하기 위해 오프스크린 패스를 해야 합니다.

하지만 우리의 관점에서, 우리는 하위 레이어가 태그 뷰의 경계를 초과할 수 없도록 보장했습니다.

그래서 사실 우리는 실제로 마스킹이 전혀 필요하지 않다.

그 masksToBounds 호출을 삭제합시다.

그리고 이제 우리는 두 오프스크린을 모두 제거했다. 굉장해.

지금까지 세 줄의 코드로, 우리는 CollectionViewCell 당 7개의 오프스크린을 저장했습니다.

이것은 엄청난 개선이지만, 우리는 탐구해야 할 문제가 하나 더 있다.

내비게이션으로 돌아가자.

이미지 보기를 선택합시다.

우리는 모서리가 둥근 것을 보고, 런타임 문제를 강조할 때, "간단한 모양 마스킹"이라고 말하는 것을 볼 수 있다.

다시 한번, 우리는 더 많은 것을 배우기 위해 런타임 네비게이터로 갈 것이다.

그것은 레이어가 rect, roundedRect 또는 ellipse인 경로를 가진 CAShapeLayer에 의해 가려져 있다고 말한다.

대신, cornerRadius와 masksToBounds 세트로 적절하게 변형된 컨테이너 레이어를 사용하세요.

오프스크린은 렌더러가 다른 레이어로 다시 마스킹해야 하기 때문에 발생한다.

하지만 이번에는 단순한 층이 아니다.

무슨 일이 일어나고 있는지 이해하기 위해 코드를 살펴봅시다.

여기 코드에서, 우리는 우리의 이미지 뷰를 가지고 있다.

먼저, 우리는 CAShapeLayer를 만들고 UIBezierPath API를 사용하여 경로를 만든 다음 그것을 마스크로 사용합니다.

여기서 일어나고 있는 일은 우리가 유효한 유형의 마스크가 될 수 있는 모양 레이어를 사용하고 있다는 것이다.

하지만 Xcode는 복잡한 모양이 아니라 그것을 감지할 수 있으며, 우리는 단지 둥근 직사각형을 만들고 있습니다.

우리가 이 코드를 쓴 이유는 때때로 다람쥐라고 불리는 특별한 유형의 둥근 직사각형을 만들려고 했기 때문이다.

이러한 유형의 둥근 직사각형은 iOS에서 매우 인기가 있다.

하지만 이것은 그 효과를 얻는 가장 좋은 방법이 아니다.

iOS 13부터, 우리는 cornerCurve 속성을 사용하여 cornerRadius 효과를 다람쥐 모양으로 만들 수 있습니다.

이제 우리는 shapeLayer를 완전히 제거하고 cornerRadius와 cornerCurve를 "연속"으로 설정할 수 있습니다.

그렇게, 우리는 제공된 API를 사용하여 두 개의 오프스크린을 더 제거했습니다.

그래서 우리는 오프스크린 카운트를 정말 최적화하고 36에서 0으로 낮출 수 있었다.

그거 놀랍다.

뷰 디버거로 돌아가서, 우리는 렌더링과 관련이 없는 다른 런타임 문제를 볼 수 있다.

그럼에도 불구하고 우리는 동료 찰스가 그것들을 시도하고 최적화할 수 있도록 그것들을 보여주고 싶습니다.

이전에는 찰스가 우리와 같은 장치를 가지고 그의 앱에 연결하고 뷰 디버거에서 일시 중지해야 했다.

하지만 이제 우리는 뷰 디버거의 상태를 저장하여 이메일로 보내거나, 동료들과 공유하거나, 피드백 보고서에 첨부할 수 있습니다.

이렇게 하려면, 파일, 보기 계층 내보내기를 선택할 수 있습니다...

"저장"을 클릭하고 voilà.

이제 모든 뷰, 레이어, 제약 조건 및 런타임 문제를 캡슐화하는 전송 가능한 파일이 있습니다.

이렇게 하면 원격으로 훨씬 쉽게 협업할 수 있으며 불필요한 오프스크린을 모두 추적할 때 정말 도움이 될 것입니다.

이제 Xcode 뷰 디버거가 앱에서 오프스크린 문제를 어떻게 강조할 수 있는지 보았으므로, 몇 가지 권장 사항을 요약해 봅시다.

모든 앱에서 해야 할 가장 중요한 일은 항상 제공된 API를 사용하는 것이다.

그림자를 설정할 때, 많은 수의 오프스크린 패스를 저장하기 위해 shadowPath를 설정해야 합니다.

직사각형을 돌릴 때, cornerRadius와 cornerCurve 속성을 사용하세요.

둥근 직사각형 모양을 만들기 위해 마스크나 모서리 내용물을 사용하지 마세요.

이것들은 불필요한 오프스크린을 일으킨다.

대부분의 레이어의 경우, 레이어의 경계를 cornerRadius로 반올림하여 UIBezierPath를 만드는 것이 좋은 shadowPath를 설정하는 데 필요한 전부입니다.

두 번째 단계는 앱 전체에서 마스킹을 최적화하는 것입니다.

masksToBounds를 사용하여 직사각형, 둥근 직사각형 또는 타원으로 가리세요.

그것은 커스텀 마스크 레이어보다 훨씬 더 성능이 뛰어나다.

전반적으로, 마스킹이 실제로 필요한지 확인하세요.

하위 트리의 콘텐츠가 경계를 초과하지 않으면, masksToBounds를 완전히 비활성화하십시오.

이것들은 단지 추천일 뿐이다.

Instruments를 사용하여 앱을 프로파일링하고 최적화 기회를 사용하여 레이어 트리를 검사하여 전체 오프스크린 수를 낮추기 위한 간단하면서도 중요한 팁을 확인하는 것이 중요합니다.

마지막으로, 보기 계층 구조의 상태를 저장하여 팀과 공유하거나 피드백 리포터 앱에 피드백을 첨부할 수 있다는 것을 기억하십시오.

전반적으로, 이러한 도구와 권장 사항은 렌더링 히치를 피하는 데 도움이 될 것입니다.

커밋 히치의 경우, "커밋 단계에서 히치 찾기 및 수정"을 확인하세요.

함께, 이 회담은 앱의 히치 시간 비율을 줄이고 사용자가 원활하게 스크롤할 수 있도록 도울 것입니다.

봐줘서 고마워.