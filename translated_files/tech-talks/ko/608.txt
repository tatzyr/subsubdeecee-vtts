608

Jaap van Muijden: A13 바이오닉을 위한 금속 향상에 오신 것을 환영합니다.

제 이름은 Apple의 GPU 소프트웨어 팀의 Jaap van Muijden입니다.

오늘 저는 A13 바이오닉의 최신 애플이 디자인한 GPU와 그것이 가능하게 하는 새로운 메탈 기능을 소개할 것입니다.

그런 다음 이러한 기능을 사용하여 앱의 메모리 사용량을 줄이고 런타임 성능을 최적화하는 방법을 보여 드리겠습니다.

새로운 A13 Bionic은 일반적인 성능, 현대 앱의 진화하는 요구를 더 잘 충족시키는 아키텍처 개선 및 고급 금속 기능의 세 가지 주요 영역에 초점을 맞춰 Apple이 설계한 GPU의 급속한 진화를 계속하고 있습니다.

각각을 살펴봅시다.

A13 바이오닉의 GPU는 일반적인 성능에서 A10 퓨전보다 거의 3배 빠르며, A11 및 A12 바이오닉 GPU의 뛰어난 성능 향상을 기반으로 합니다.

기존 앱은 A13에서 더 빠르게 실행되며 더 짧은 시간에 각 프레임을 완료할 수 있으며, 이는 전력 절약과 확장된 앱 사용으로 이어집니다.

애플이 설계한 GPU 아키텍처는 현대 앱의 요구를 더 잘 충족시키기 위해 빠르게 발전했다.

A11을 시작으로, 16비트 부동 소수점과 텍스처링 속도는 게임의 일반적인 병목 현상을 완화하기 위해 증가했으며, 고급 컴퓨팅 워크로드를 더 잘 처리하기 위해 32비트 부동 소수점 작업의 수치 정확도가 향상되었습니다.

A12 GPU는 메모리에서 텍스처 콘텐츠를 무손실로 압축하고 압축 해제하여 메모리 대역폭을 크게 향상시킵니다.

또한 사용자 인터페이스를 지원하는 전용 하드웨어를 추가하여 더 빠른 응답 시간을 보장할 뿐만 아니라 포그라운드 앱에 대한 UI 요소의 영향을 줄입니다.

그리고 A12 이상 GPU는 앱 간에 자원을 더 효율적으로 공유함으로써 iPad 경험을 향상시킵니다.

그리고 이제 우리는 A13 GPU를 가지고 있다.

A13 GPU 아키텍처는 16비트 부동 소수점 연산 속도를 두 배로 늘리고 블랙 레벨을 더 잘 보존하는 작은 16비트 숫자에 대한 지원을 추가하여 GPU에서 높은 다이내믹 레인지 콘텐츠 처리를 크게 향상시킵니다.

A13 GPU는 또한 렌더링 워크로드와 동시에 실행되는 독립적인 컴퓨팅 작업에 대해 훨씬 더 나은 지원을 제공합니다.

Apple이 설계한 GPU는 A9 이후 이 비동기 컴퓨팅 기능을 지원했지만, A13 GPU는 더 많은 하드웨어 채널을 추가하고 마감일에 민감한 렌더링 작업에 미치는 영향을 최소화함으로써 다음 단계로 끌어올립니다.

이제 A13의 새로운 금속 기능을 설명하기 전에, A11과 A12 GPU에 도입된 주요 금속 기능 중 일부를 빠르게 요약해 봅시다.

A11부터 시작합시다.

타일 셰이딩, 이미지 블록 및 영구 스레드 그룹 메모리는 모두 Apple의 타일 기반 지연 렌더링 아키텍처를 명시적으로 활용하고 많은 최신 렌더링 기술의 대역폭 사용을 최적화하기 위해 함께 작동하도록 설계된 기능입니다.

래스터화 주문 그룹을 사용하면 GPU에서 복잡한 픽셀당 데이터 구조를 관리할 수 있으며, 색상 속도 제어는 고급 렌더링 알고리즘에서 다중 샘플 안티 앨리어싱의 사용을 최적화합니다.

그리고 이제 A12로.

계층 렌더링을 통해 각 렌더링된 기본 대상은 2D 텍스처 배열의 고유한 슬라이스를 만들 수 있으며, 다중 뷰포트 렌더링은 각 기본을 최대 16개의 뷰포트와 가위 직사각형에 대해 동일한 작업을 수행할 수 있습니다.

스텐실 피드백을 통해 각 조각은 고급 픽셀당 효과에 대한 고유한 스텐실 참조 값을 설정할 수 있으며, 스텐실 확인은 MSAA 및 비MSAA 패스에서 스텐실 버퍼를 재사용할 수 있습니다.

그리고 가능한 한 무손실 압축이 기본적으로 활성화되어 있지만, 메탈은 또한 최적의 리백이 필요할 때 공유 저장 모드 텍스처의 현장 압축 및 압축 해제에 대한 직접적인 제어를 제공합니다.

이제 A13 GPU를 지원하는 새로운 Apple GPU 제품군 6을 소개합시다.

스파스 텍스처는 각 텍스처의 가장 중요한 영역을 추적한 다음 해당 영역만 메모리에 매핑하여 고정 메모리 예산으로 오픈 월드 게임을 위한 고품질 텍스처 스트리밍을 가능하게 합니다.

래스터화 속도 지도는 가장 중요한 이미지 영역에 고품질 래스터화와 음영에 초점을 맞추고, 다른 곳에서 속도를 줄여 메모리와 성능을 모두 절약합니다.

정점 증폭은 지오메트리를 공유하는 계층화된 렌더링에서 발생할 수 있는 중복 정점 처리를 제거합니다.

GPU 기반 파이프라인을 사용하면 더 크고 몰입감 있는 장면을 그릴 수 있으며, 인수 버퍼 계층 2를 통해 앱은 GPU 기반 워크로드를 그 어느 때보다 유연하게 실행할 수 있습니다.

SIMD 그룹 지침은 셰이딩하는 동안 SIMD 그룹의 스레드 간의 공유 및 동기화를 최적화합니다.

그리고 ASTC HDR은 높은 동적 범위 텍스처에 고품질 손실 압축을 제공하여 상당한 메모리와 대역폭을 절약합니다.

희박한 질감부터 시작하여 이들 각각을 더 자세히 살펴봅시다.

스파스 텍스처는 A13 GPU에 도입된 새로운 기능으로, 금속 텍스처의 저장 및 레지던시를 미세한 세분화로 제어할 수 있습니다.

희박한 텍스처는 메모리에 완전히 상주하지 않는다.

하지만 대신, 스파스 힙이라고 불리는 특별한 메모리 힙에 섹션을 할당할 수 있습니다.

여기서 당신은 그러한 희박한 힙에 할당된 데이터의 일부가 있는 두 개의 희박한 텍스처를 볼 수 있습니다.

단일 힙은 많은 희소한 텍스처에 대한 저장 공간을 제공할 수 있으며, 모두 사전 할당된 단일 메모리 풀을 공유합니다.

모든 스파스 텍스처는 텍스처 해상도나 픽셀 형식에 관계없이 동일한 메모리 풋프린트를 갖는 스파스 타일이라는 단위로 분할됩니다.

그래서 이 기능의 적용은 무엇인가요?

그 중 하나는 텍스처 스트리밍이다.

텍스처 스트리밍을 사용하면 현재 보기에 필요한 텍스처 렙맵만 로드하여 고정된 메모리 풋프린트로 믿을 수 없을 정도로 큰 장면을 렌더링할 수 있습니다.

전통적인 텍스처 스트리밍을 통해 개별 렙맵은 필요할 때 로드되고 더 이상 필요하지 않을 때 또는 더 중요한 텍스처에 메모리가 필요할 때 제거됩니다.

텍스처 스트리밍은 전통적으로 렙맵 세분화에서 텍스처 레지던시를 관리합니다.

더 높은 품질의 mipmap이 요청되었지만 아직 스트리밍되지 않은 경우 mipmap 피라미드의 가장 낮은 수준은 거주자로 유지됩니다.

로딩 작업이 완료되지 않았거나 할당된 스트리밍 메모리가 부족하기 때문에 아직 사용할 수 없을 수도 있습니다.

가장 낮은 수준의 mipmaps를 사용하면 해상도가 낮더라도 항상 샘플링할 수 있는 유효한 데이터가 있습니다.

금속의 희박한 텍스처 기능은 두 가지 방법으로 이 텍스처 스트리밍 모델을 개선한다.

첫째, 스파스 텍스처는 스파스 텍스처의 각 영역에 얼마나 자주 접근하는지 결정하는 데 사용할 수 있는 텍스처 액세스 카운터를 제공합니다.

렌더러가 더 자주 액세스하는 영역이 일반적으로 현재 보기에서 더 잘 보이기 때문에 텍스처 로딩의 우선 순위를 지정할 수 있습니다.

둘째, 거주지는 mipmap 입도 대신 희소한 타일 입도에서 관리할 수 있다.

이를 통해 텍스처 메모리를 더욱 효율적으로 사용할 수 있으며, 중요한 곳에서 더 눈에 띄는 텍스처 디테일을 볼 수 있습니다.

함께, 희소한 텍스처를 사용하면 동일한 메모리 예산으로 더 눈에 띄는 디테일을 스트리밍하여 품질을 향상시킬 수 있습니다.

이제 금속에서 희박한 질감을 어떻게 만들고 사용하는지 살펴봅시다.

스파스 텍스처를 사용하기 시작하려면, 먼저 스파스 힙을 만든 다음 하나 이상의 텍스처를 할당합니다.

새로운 희박한 텍스처는 처음에 매핑된 희박한 타일 없이 만들어진다.

GPU를 사용하여 힙에서 메모리 매핑을 요청해야 합니다.

메모리는 가상 메모리 페이지와 유사하게 스파스 타일이라고 불리는 타일 크기의 단위로 매핑된다.

마찬가지로, 더 이상 필요하지 않을 때 GPU가 타일의 매핑을 해제하도록 요청해야 합니다.

희박한 텍스처를 샘플링하는 것은 일반 텍스처처럼 작동하며, 매핑되지 않은 영역을 샘플링하면 0을 반환합니다.

마지막으로, 텍스처 액세스 카운터는 희박한 텍스처에서 다시 읽을 수 있으며, 각 타일에 얼마나 자주 액세스되는지에 대한 추정치를 얻을 수 있으므로 텍스처에 대한 타일을 매핑할 때 정확하게 제어하고 우선 순위를 지정할 수 있습니다.

이 각 단계를 더 자세히 살펴봅시다.

여기에 주어진 메모리 크기로 희소한 텍스처 힙을 만드는 금속 코드가 있습니다.

우리는 먼저 힙의 크기를 계산하고, 그것이 희소 타일 크기의 배수인지 확인합니다.

여기서 우리는 로컬 도우미 함수를 사용하여 데이터 크기를 희소 타일 크기의 가장 가까운 배수로 반올림합니다.

그런 다음 스파스 힙 설명자를 생성할 수 있습니다. 힙 유형을 스파스로 설정하고 힙의 크기를 바이트로 지정합니다.

그런 다음 MTLDevice 객체를 사용하여 스파스 힙을 만듭니다.

희박한 질감을 만드는 것은 매우 쉽다.

먼저, 우리는 정상적으로 텍스처 설명자를 만든 다음, 스파스 힙 객체를 사용하여 텍스처를 만듭니다.

이제 스파스 텍스처를 만드는 방법을 보았으니, 영역을 메모리에 매핑하는 방법을 살펴봅시다.

텍스처 영역의 매핑 및 매핑 해제는 리소스 상태 명령 인코더에서 맵 및 매핑 해제 명령을 인코딩하여 수행됩니다.

이 인코더는 Metal의 다른 렌더링 명령을 인코딩하는 것과 유사하게 GPU 타임라인에서 지도 및 매핑 해제 작업을 예약하는 데 사용할 수 있습니다.

이것이 코드에서 어떻게 보이는지 봅시다.

먼저 우리는 인코더를 만든다.

그런 다음 우리는 단순히 지도 작업을 인코딩합니다; 우리는 텍스처와 우리가 매핑하고 싶은 텍스처의 영역, 슬라이스 및 mip 수준을 지정합니다.

이제 지역이 매핑되었으며, 매핑된 메모리에 텍스처 데이터를 블릿하거나 만들 수 있습니다.

섹션의 매핑을 해제하기 위해, 우리는 같은 절차를 따릅니다; 유일한 차이점은 우리가 인코딩하는 업데이트 모드입니다.

이제 텍스처 데이터를 만들고 매핑했으니, 희박한 텍스처 샘플링으로 넘어갑시다.

희박한 질감의 샘플링은 일반 질감의 샘플링과 다르지 않다.

매핑되지 않은 섹션에 접근할 경우 잘 정의된 행동이 있다.

매핑되지 않은 영역을 샘플링하면 0의 벡터가 반환되며, 모든 쓰기는 폐기됩니다.

표준 샘플링 기능 외에도, 메탈은 매핑되지 않은 영역을 테스트하기 위해 셰이더에서 사용할 수 있는 sparse_sample 기능을 제공합니다.

이제 희소 텍스처를 만들고, 매핑하고, 샘플링하는 방법을 보았으니, 간단한 구현을 살펴봅시다.

희소한 텍스처를 효율적으로 샘플링하는 한 가지 방법은 대체 샘플링을 수행하는 것이다.

셰이더에서 먼저 sparse_sample 메서드를 사용하여 texels를 가져올 수 있으며, 실패하면 하위 레벨 mipmap으로 돌아갈 수 있습니다.

항상 낮은 mipmap을 로드하면 유효한 샘플을 찾을 수 있습니다.

그리고 대체 샘플링을 더 잘 지원하기 위해, 메탈 셰이딩 언어는 또한 최소 LOD 클램프라고 불리는 텍스처 방법에 대한 새로운 주장을 지원합니다.

최소 LOD 클램프를 사용하면 액세스할 수 있는 체인에서 가장 높은 mipmap을 설정할 수 있습니다.

이를 통해 데이터가 있는 가장 높은 mipmap을 지정하여 유효한 샘플을 보장할 수 있습니다.

그걸 코드로 보자.

여기에 희박한 질감에서 샘플링하는 조각 셰이더가 있습니다.

Sparse_color 객체를 반환하는 sparse_sample 메소드를 사용하여 스파스 텍스처 샘플링을 시작합니다.

그런 다음 반환된 객체의 상주 메서드를 호출하여 GPU가 매핑된 데이터를 샘플링했는지 확인할 수 있습니다.

만약 그랬다면, 당신은 샘플링된 값을 검색하고 반환합니다.

그렇지 않으면 스파스 텍스처를 다시 샘플링하지만, 이번에는 LOD 클램프를 사용하여 샘플러가 더 높은 mipmap을 우회하도록 합니다.

이 mipmap과 더 낮은 mipmaps에 데이터가 있다는 것을 보장했기 때문에, 두 번째 샘플링 호출은 일반 샘플 방법을 사용하여 이루어집니다.

이제 스파스 텍스처 데이터를 매핑하고 샘플링하는 기능을 보았으니, 스파스 텍스처 타일을 매핑하거나 해제할 시기를 결정하는 방법에 대해 조금 이야기해 봅시다.

전통적인 텍스처 스트리밍 시스템은 텍스처 레지던시의 우선 순위를 정하는 데 도움이 되도록 앱 수준의 통계를 수동으로 수집합니다.

이러한 방법은 종종 오버헤드를 관리하는 데 도움이 되는 뮴맵 또는 메쉬 입도에서 거칠다.

금속은 대신 텍스처 액세스 카운터라고 불리는 미세한 솔루션을 지원합니다.

이 카운터는 매우 낮은 오버헤드로 GPU가 스파스 타일에 얼마나 자주 접근하는지 정확하게 추적합니다.

텍스처 액세스 카운터는 GPU에서 쿼리됩니다.

이것이 어떻게 작동하는지 봅시다.

이 금속 예제는 GPU에서 텍스처 액세스 카운터를 수집할 것이다.

샘플링된 카운터를 포함할 버퍼를 만드는 것으로 시작합니다.

그런 다음 blit를 인코딩하여 희소 텍스처에서 버퍼로 카운터를 복사하여 관심 있는 mip 레벨, 슬라이스 및 영역을 지정합니다.

전통적인 텍스처 스트리밍 기술은 수년 동안 우리에게 매우 도움이 되었으며, 고정된 메모리 예산을 감안할 때, 우리는 사용자가 보는 텍스처에 대한 mip 레벨에서 스트리밍할 수 있습니다.

텍스처 예산이 소진되면, 우리는 더 이상 고해상도의 mip 레벨로 스트리밍할 수 없으며 균일하게 흐릿한 텍스처를 보기 시작합니다.

하지만 희박한 질감으로, 당신은 이제 당신의 기억을 더 잘 사용할 수 있습니다.

주어진 렙 레벨 내의 각 텍스처 타일에 가장 적합한 품질 수준에서 사용자가 보는 개별 텍스처 타일을 위한 공간을 만들기 위해 메모리를 매핑할 수 있습니다.

이를 통해 가장 시각적인 영향을 미치는 타일에 대한 텍스처 메모리를 배포할 수 있습니다.

또한, 이 기능은 텍스처를 스트리밍할 때 대역폭을 절약합니다. 스파스 텍스처 API를 사용하면 스트리밍 중에 메모리에서 전체 mipmap 체인을 복사하고 재배열하는 대신 개별 타일을 매핑하고 매핑할 수 있습니다.

그것은 희박한 텍스처를 위한 것이며, 텍스처 스트리밍 품질을 향상시킬 정말 중요한 메모리 최적화입니다.

이제 래스터화 속도 맵이라고 불리는 런타임 최적화 기술로 넘어가자.

래스터화 속도 맵을 사용하면 인식되지 않는 곳에서 품질을 낮추면서 가장 높은 해상도에서 가장 중요한 이미지 영역을 래스터화하고 음영하여 레티나 디스플레이를 더 잘 활용할 수 있습니다.

래스터화 속도 맵을 사용하면 화면 공간과 물리적 렌더링 대상 크기, 두 공간 간의 균일하지 않은 매핑을 모두 정의하여 여러 해상도로 래스터화하고 음영 처리하여 각 영역의 품질을 제어할 수 있습니다.

물리적 해상도는 화면 공간보다 작아서 대역폭을 절약하고 메모리 공간을 줄입니다.

그리고 균일하지 않은 매핑은 전체 화면을 기본 해상도로 렌더링하는 비용의 일부만으로 게임에서 자주 사용되는 균일한 고급보다 더 높은 품질의 비주얼을 초래합니다.

이것이 어떻게 작동하는지 자세히 살펴봅시다.

여기 샘플 렌더러의 g-버퍼의 확산 레이어 스크린샷이 있습니다.

전통적인 렌더링은 각 정점의 화면 공간 좌표를 계산한 다음 화면 공간에서 결과 프리미티브를 래스터화하여 조각을 생성하여 기하학을 그립니다.

이 화면 공간 좌표는 래스터화 중에 물리적 렌더링 대상의 좌표에 일대일 매핑이 있습니다.

래스터화 속도 맵을 사용하면 조각을 만들 때 화면 공간 좌표를 고르지 않게 매핑하도록 래스터라이저를 구성하여 생성된 총 조각의 수를 줄이고 동시에 더 작은 렌더링 대상으로 렌더링할 수 있습니다.

두 이미지 모두에서, 흰색 격자는 가상 화면 공간의 균등하게 간격을 둔 격자에 해당한다.

하지만 여기서 볼 수 있듯이, 그것은 물리적 공간에 고르지 않게 분포되어 있다.

이 예에서, 우리는 화면 중앙에 화면 해상도를 유지하기 위해 래스터화 속도 맵을 사용했지만, 화면 가장자리로 줄였습니다.

이것을 더 명확하게 보려면, 중앙 타일 중 하나를 확대해 봅시다.

이 물리적 타일의 해상도는 g-버퍼 내의 동일한 영역의 해상도와 일치한다.

하지만 화면 가장자리로 이동하면, 그 타일 전용 물리적 공간을 효과적으로 줄임으로써 품질이 저하됩니다.

이것은 당신의 물리적 이미지에서 왜곡된 이미지로 이어지지만, 우리는 이 매핑을 반전시켜 왜곡되지 않은 최종 이미지를 만들 수 있다는 것을 보여줄 것입니다.

하지만 먼저, 매핑이 어떻게 정의되는지 살펴봅시다.

매핑은 화면 공간의 X축과 Y축에서 두 개의 1D 함수로 정의된다.

당신은 품질 요구 사항을 정의하는 일련의 제어 지점을 사용하여 금속에서 이러한 기능을 설명합니다.

이 이미지에서, 우리는 축을 따라 두 개의 1D 기능을 감안할 때 화면에서 효과적인 래스터화 속도를 볼 수 있습니다.

하나의 품질 수준은 축을 따라 모든 화면 공간 픽셀에 대해 조각 셰이더가 호출된다는 것을 의미합니다.

그리고 .5의 품질 수준은 픽셀의 최소 50%에 대해 주어진 축을 따라 조각 셰이더가 호출된다는 것을 의미합니다.

0의 품질 수준은 각 조각 셰이더가 Metal이 지원하는 최소 속도로 호출된다는 것을 의미합니다.

금속은 최종 요금 지도를 만들기 위해 이러한 제어 지점을 리샘플링할 것이다.

최종 매핑을 직접 제어하지는 않지만, 금속은 최소한의 품질이 보존되도록 보장합니다.

이제 금속으로 이 매핑을 만들어 봅시다.

여기 당신이 방금 본 래스터화 속도 맵을 만드는 금속 코드가 있습니다.

먼저, 래스터화 함수를 정의합니다.

이 예에서 우리는 지도의 수평축과 수직축 모두에 대해 이전에 보여준 다섯 가지 값을 사용할 것이다.

그런 다음 래스터화 속도 맵에서 품질을 설명하기 위해 레이어 설명자를 채웁니다.

그런 다음 수평 및 수직 품질 기능을 제공하여 하나를 만듭니다.

품질이 정의되면, 이제 레이어 설명자와 최종 화면 공간 해상도에서 금속 래스터화 속도 맵 설명자를 만들 수 있습니다.

마지막으로, 금속 장치를 사용하여 해당 설명자를 사용하여 래스터화 속도 맵 객체를 인스턴스화합니다.

다음으로 우리는 이 지도의 물리적 렌더링 대상을 만들어야 합니다.

실제 래스터화 속도 지도 속도는 구현에 따라 다르기 때문에, 먼저 지도에서 자원의 물리적 크기를 쿼리해야 합니다.

그런 다음 평소와 같이 물리적 렌더링 대상을 만듭니다: 올바른 사용 및 저장 속성을 지정하고 Metal 장치 객체를 사용하여 텍스처를 인스턴스화하십시오.

마지막으로, 생성된 텍스처와 래스터화 맵을 결합하여 렌더링 패스를 설정하고 평소와 같이 렌더링합니다.

그리고 그것으로, 당신은 당신의 g-버퍼를 균일하지 않게 래스터화했습니다.

하지만 나중에 g-버퍼를 음영으로 하는 건 어때?

전통적인 지연 음영 파이프라인을 사용하면 광 형상이 g-버퍼와 동일한 화면 공간에서 올바르게 래스터화되기 때문에 동일한 래스터화 속도 맵으로 조명을 계속할 수 있습니다.

타일로 된 지연된 렌더러를 사용하면, 조금 더 많은 작업을 해야 합니다.

타일 지연 렌더링에 아직 익숙하지 않다면, WWDC 2019에서 Modern Rendering with Metal talk를 참조하십시오.

타일 지연으로, 렌더링 대상의 물리적 공간은 동등한 크기의 픽셀 블록으로 나뉘며 각 블록은 가벼운 타일 컬링과 셰이딩을 수행합니다.

제시된 이미지에서, 우리의 샘플 코드는 32 x 32 픽셀의 블록당 조명 수에 대한 히트 맵을 보여줍니다.

화면 공간이 더 이상 물리적 공간에 해당하지 않기 때문에, 래스터화 속도 맵을 타일 지연 렌더러와 통합하려면 한 가지 추가 단계가 필요합니다.

조명 셰이더는 물리적 공간의 픽셀 좌표를 가상 화면 공간으로 변환해야 합니다.

이것은 래스터화 중에 사용되는 리버스 매핑이다.

셰이더에서 이 리버스 매핑을 어떻게 수행할 수 있는지 살펴봅시다.

먼저 래스터화 속도 맵 매개 변수가 셰이더에 접근할 수 있도록 해야 합니다.

이렇게 하려면, 먼저 매개 변수를 저장할 수 있는 MTLBuffer를 만드세요.

그런 다음 매개 변수 데이터를 MTLBuffer에 복사합니다.

그리고 마지막으로, MTLBuffer를 셰이더에 바인딩하세요.

이제 지도가 묶여 있으니, 그것을 사용합시다.

셰이더에서, 이제 해당 버퍼 바인딩 지점에서 rasterization_rate_map_data 객체에 액세스할 수 있습니다.

그 객체를 사용하여 rasterization_rate_map _decoder 객체를 인스턴스화할 수 있습니다.

그런 다음 디코더를 사용하여 물리적 좌표와 화면 좌표 사이를 변환하세요.

타일 지연 렌더러로 돌아가서, 우리는 디코더를 사용하여 가상 화면 공간에서 타일 컬링을 수행합니다.

라이트 컬링을 가상 화면 공간에 적응시키는 것은 타일이 더 이상 정사각형이 아니라 이제 화면 공간의 올바른 영역을 따른다는 것을 의미합니다.

이 히트 맵을 완전하고 균일한 해상도 렌더링과 비교해 봅시다.

그리고 래스터화 속도 맵 버전으로 돌아갑니다.

보시다시피, 래스터화 속도 지도를 통해, 우리는 화면에 음영 처리된 타일의 양을 크게 줄였습니다.

마지막으로, 라스터화 속도 지도가 합성과 최종 프레젠테이션을 위해 어떻게 준비되는지 생각해 봅시다.

최종 이미지를 화면에 표시하기 전에, 방금 설명한 셰이더 매핑을 사용하여 물리적 공간 텍스처를 고해상도 표면으로 변환하는 전체 화면 패스를 사용하여 포장을 풀어야 합니다.

보시다시피, 이 샘플을 위해 선택된 공격적인 낙진에도 불구하고 품질 절충을 알아차리는 것은 매우 어렵습니다.

우리는 품질 절충을 숨기기 위해 래스터화 속도 맵이 피사계 심도와 같은 다른 기술과 결합될 것으로 예상합니다.

그것은 래스터화 속도 지도를 위한 것이다.

정점 증폭으로 넘어갑시다.

정점 증폭을 사용하면 다중 뷰 렌더링 사례에서 형상 처리를 줄일 수 있습니다.

다중 레이어 및 다중 뷰포트 렌더링은 인스탠싱을 사용하여 각 뷰를 타겟팅하는 데 필요한 드로우 호출 수를 줄입니다.

하지만 그것은 이러한 각 인스턴스를 처리하는 GPU 비용을 제거하지 않는다.

많은 다층 및 다중 뷰포트 렌더링 기술은 뷰 간에 기하학을 공유한다.

예를 들어, 그림자 지도의 폭포나 환경 지도의 측면 사이.

각 사례는 일반적으로 그 기하학을 거의 같은 방식으로 변형시킨다.

따라서 위치가 보기마다 고유하지만, 법선, 탄젠트 및 텍스처 좌표와 같은 속성은 동일합니다.

정점 증폭을 사용하면 공유 속성을 한 번만 처리하여 정점 셰이딩의 효율성을 높일 수 있습니다.

캐스케이드 섀도우 맵의 사용 사례를 더 자세히 생각해 봅시다.

보기 거리에 따라, 렌더러는 그림자 지도를 하나, 둘 또는 세 개 이상의 겹치는 그림자 캐스케이드로 나눌 수 있다.

우리가 캐스케이드의 수를 늘리면서, 우리는 또한 각 캐스케이드가 덮는 가상 세계의 크기를 늘린다.

이것은 더 크고 더 먼 캐스케이드가 더 가까운 캐스케이드에 비해 더 많은 기하학을 축적하게 한다.

그리고 더 많은 캐스케이드와 함께, 하나 이상의 캐스케이드로 렌더링되는 물체의 수가 증가한다.

이제 캐스케이드 섀도우 맵이 전통적으로 렌더링되는 방법과 관련 비용을 고려해 봅시다.

멀티뷰 렌더링 전에, 당신은 단순히 각 캐스케이드를 별도로 그릴 것입니다.

이것은 GPU와 CPU 오버헤드를 모두 증가시켰다.

각 정점은 여러 번 가져오고 음영 처리해야 하며, 각 정점은 여러 번 출력됩니다.

멀티뷰 인스턴스 렌더링은 인스턴스 ID를 사용하여 각 프리미티브를 대상 보기에 매핑합니다.

그것은 다중 드로우 호출의 CPU 비용을 제거하지만, GPU 비용은 동일하게 유지됩니다.

계층화된 렌더링을 위해 인스턴스를 사용하면 인스턴스 ID가 이제 실제 인스턴스 ID와 대상 레이어를 모두 인코딩해야 하기 때문에 실제 인스턴스 지오메트리의 렌더링이 복잡해 되기도 합니다.

정점 증폭은 중복 가져오기, 음영 및 출력을 제거합니다.

그것은 또한 별도의 증폭 ID를 제공한다.

작동 중인 정점 증폭을 살펴봅시다.

기존의 정점 함수는 정점 증폭에 쉽게 적응할 수 있다.

이 예에서, 우리는 증폭당 고유한 위치를 계산할 것이지만, 모든 증폭에 대한 색상 계산을 공유할 것이다.

우리는 두 가지 속성으로 VertexOutput을 선언하는 것으로 시작합니다.

컴파일러는 일반적으로 속성이 고유하거나 공유되는지 추론할 수 있지만, 복잡한 셰이더의 경우 어떤 속성이 공유되는지 명시할 수도 있습니다.

컴파일러는 공유 속성 계산이 증폭 ID에 의존할 때 오류를 보고할 것이다.

다음으로 우리는 증폭 ID를 가진 함수 인수를 선언합니다.

이 ID와 관련된 모든 계산은 셰이더 호출마다 증폭됩니다.

색상 속성은 해당 ID와 관련이 없으므로 한 번만 실행됩니다.

하지만 위치는 올바른 뷰 프로젝션 매트릭스를 찾기 위해 ID에 따라 다르므로 전체 표현식이 증폭됩니다.

그게 셰이더 코드를 위한 거야.

이제 증폭된 무승부 호출을 어떻게 설정했는지 봅시다.

증폭을 가능하게 하는 파이프라인 상태 객체를 만드는 것으로 시작합시다.

금속이 지원하는 최대 증폭 계수는 장치에서 쿼리할 수 있습니다.

이 경우, 당신이 두 개의 증폭 계수를 원한다고 가정해 봅시다.

지원되는 경우, 파이프라인의 최대 증폭 계수로 설정합니다.

지원되지 않는 경우, 인스타싱을 통해 전통적인 멀티 뷰로 돌아가거나 여러 번의 드로우 호출에 의존할 수 있습니다.

마지막으로, 당신은 파이프라인을 만듭니다.

파이프라인이 생성되고 증폭이 지원된다고 가정하면, 그리기를 인코딩하기 시작할 수 있습니다.

증폭으로 그리기 위해서는 증폭 수를 설정하고 뷰 매핑을 바인딩해야 합니다.

뷰매핑은 증폭 ID를 대상 레이어 또는 뷰포트에 매핑하는 방법을 설명합니다.

버텍스 셰이더가 렌더링 대상 또는 뷰포트 배열 인덱스를 내보내면, 그 인덱스는 viewMappings 배열의 기본 오프셋 역할을 할 것이다.

이제 원하는 증폭을 설정하고 그림을 인코딩할 수 있습니다.

메탈 프레임 디버거를 자세히 살펴봅시다.

이 샘플 렌더링에서, 우리는 VertexAmplification을 사용하여 캐스케이드 2와 3 모두에 렌더링되는 모든 그림을 증폭합니다.

여기서 우리는 이 그리기 호출이 두 개의 렌더링 대상을 지정하는 ViewMapping으로 렌더링된다는 것을 알 수 있습니다.

메쉬는 왼쪽에 표시된 두 번째 캐스케이드와 오른쪽과 지오메트리 뷰어에 표시된 세 번째 캐스케이드로 동시에 렌더링됩니다.

그게 정점 증폭을 위한 거야.

논쟁 버퍼와 그들이 A13을 위해 어떻게 확장되었는지에 대해 넘어갑시다.

우리는 Metal 2로 논쟁 버퍼를 도입했다.

인수 버퍼를 사용하면 상수, 텍스처, 샘플러 및 버퍼 인수를 MTLBuffers로 인코딩할 수 있습니다.

모든 드로우 인수를 단일 메탈 인수 버퍼로 인코딩하면 CPU 오버헤드를 최소화하면서 복잡한 장면을 렌더링할 수 있습니다.

인코딩되면, 반복되는 중복 리소스 바인딩을 피하기 위해 인수 버퍼를 재사용할 수 있습니다.

인수 버퍼는 또한 GPU에서 전체 장면의 그리기 인수에 대한 액세스를 제공하여 GPU 기반 파이프라인을 활성화하는 데 필요합니다.

그런 다음 계산 함수에서 인수 버퍼를 수정하여 제 시간에 장면을 동적으로 구성할 수 있습니다.

계층 2 인수 버퍼는 인수 버퍼의 기능을 극적으로 향상시킵니다.

A13을 사용하면, 금속 함수는 인수 버퍼의 모든 텍스처를 샘플링하거나 쓸 수 있습니다.

당신은 또한 사실상 무제한의 텍스처와 많은 샘플러에 접근할 수 있습니다.

그리고 인수 버퍼는 이제 여러 수준의 간접적인 다른 인수 버퍼를 참조할 수 있다.

이렇게 하면 모든 장면 데이터에 대한 단일 인수 버퍼를 인코딩하고 GPU 또는 CPU에서 미리 인수 버퍼를 조립할 필요 없이 드로우에서 액세스할 수 있습니다.

예를 들어 봅시다.

다음은 장면 객체 모델 계층 구조의 예입니다.

우리는 WWDC 2019에서 Modern Rendering with Metal 토크에서 비슷한 예를 보여주었다.

계층 구조는 모든 기하학 데이터, 재료 및 모델 데이터를 설명합니다.

인수 버퍼를 사용하면 이 객체 모델을 직접 인코딩할 수 있습니다.

하지만 Tier 2 지원을 통해 렌더링 중에 계층 구조를 직접 사용할 수도 있습니다.

셰이더 예시를 살펴봅시다.

우선, 우리의 인수 버퍼는 메탈 셰이딩 언어에서 상수, 텍스처, 샘플러 및 버퍼의 구조로 선언된다는 것을 기억하세요.

이 선언들은 방금 설명한 예시 객체 계층 구조를 직접 반영한다.

첫 번째는 우리의 물질적 표현이고, 두 번째는 메쉬, 재료 및 모델 세트를 참조하는 장면이다.

좋아, 이제 우리 장면을 직접 사용하여 음영을 드리는 조각 기능을 살펴봅시다.

첫 번째 함수 매개 변수는 장면 인수 버퍼입니다.

두 번째 함수 매개 변수는 우리의 당 상수이다.

이 예에서는 이 드로우의 모델 ID와 이산 수준의 세부 사항을 인코딩하며, 둘 다 이전 컴퓨팅 패스에서 선택되었습니다.

그런 다음 이 ID를 사용하여 이전에 계산된 ID를 사용하여 현장에서 자료를 가져옵니다.

그리고 우리는 중첩된 인수 버퍼의 텍스처, 상수 및 샘플러를 사용하여 조각 색상을 계산합니다.

그리고 그게 다야!

재료 매개 변수를 그리기당 인수 버퍼로 수집하기 위해 더 이상 개입하는 컴퓨팅 패스가 없습니다.

조각 셰이더는 장면 인수 버퍼를 직접 사용합니다.

하지만 우리가 계속하기 전에, 저는 인수 버퍼에 대한 강력한 도구 지원을 강조하고 싶습니다.

인수 버퍼와 GPU 기반 파이프라인을 사용하면 장면 설정이 GPU로 이동하고 디버깅도 마찬가지입니다.

메탈 프레임 디버거를 사용하면 인수 버퍼와 이를 사용하는 셰이더를 쉽게 디버깅하고 검사할 수 있습니다.

버퍼 뷰어를 사용하여 인수 버퍼의 모든 리소스를 검사하고 추가 검사를 위해 이러한 리소스로 빠르게 이동할 수 있습니다.

또한 셰이더 디버거를 사용하여 셰이더가 인수 버퍼에 액세스하거나 구축하는 방법을 이해할 수 있습니다.

이것은 인수 버퍼 인덱스를 계산하거나 GPU에서 인수 버퍼를 수정할 때 특히 중요합니다.

그게 티어 2 인수 버퍼를 위한 거야.

이제 새로운 종류의 셰이더 최적화 기술로 넘어가자.

SIMD 그룹 기능은 컴퓨팅 및 그래픽 기능을 최적화하기 위한 강력한 도구입니다.

그들은 GPU 워크로드가 GPU의 아키텍처를 활용하여 데이터를 공유하고 흐름 정보를 제어할 수 있게 해준다.

메탈에서 SIMD 실행 모델을 빠르게 검토하여 포장을 풀어봅시다.

메탈은 항상 단일 명령, GPU의 다중 데이터 특성을 활용하기 위해 스레드를 SIMD 그룹으로 구성해 왔다.

대신 SIMD 그룹 장벽을 사용하여 전체 스레드 그룹을 동기화하는 비용을 줄이기 위해 Metal 컴퓨팅 함수에서 SIMD 그룹을 활용했을 수 있습니다.

SIMD 그룹의 스레드는 잠금 단계에서 실행되므로 실행 장벽이 필요하지 않습니다.

따라서 SIMD 그룹 장벽은 메모리 작업만 동기화합니다.

SIMD 그룹 함수는 이 락스텝 실행을 악용하여 스레드 그룹 메모리 대신 레지스터를 사용하여 스레드 간에 데이터를 공유하며, 스레드 그룹 메모리가 바인딩될 때 성능을 크게 향상시킬 수 있습니다.

그것들은 또한 컴퓨팅과 렌더링 기능 모두에서 사용할 수 있다.

그리고 우리가 조금 후에 볼 수 있듯이, 이것은 매우 흥미로운 렌더링 최적화 기술을 가능하게 한다.

먼저 예를 들어 SIMD 실행에 대한 더 나은 직관을 구축하는 것으로 시작합시다.

왼쪽 아래로 우리는 레인 0으로 시작하는 32개의 차선으로 SIMD 그룹을 나타냅니다.

차선은 SIMD 그룹의 단일 스레드이다.

이제 이 SIMD 그룹이 몇 가지 작업을 수행하도록 합시다.

먼저 우리는 모든 차선이 배열 A를 laneID로 인덱싱하고 결과를 변수 X에 저장합니다.

각 차선이 어떻게 X의 고유한 가치를 갖는지 주목하세요.

이 실행 모델에서, A에서 데이터를 로드하는 명령은 한 번만 가져오고 자체 인덱스가 있는 32개의 스레드에 의해 동시에 실행됩니다.

이제 우리는 laneID에 의해 인덱싱된 두 번째 배열인 B를 읽고 결과를 Y에 저장합니다.

마지막으로 우리는 X와 Y를 세 번째 배열인 C에 곱한 결과를 저장합니다.

실행된 명령은 전체 그룹에 대해 한 번만 가져오기 때문에, 모든 SIMD 그룹 스레드는 lockstep에서 실행됩니다.

SIMD 그룹 기능을 사용하면 그룹의 각 스레드가 최소한의 오버헤드로 전체 SIMD 그룹의 레지스터 값을 검사할 수 있습니다.

이 능력은 몇 가지 흥미로운 기능을 가능하게 한다.

먼저 simd_max를 소개하고 변수 Y에 적용해 봅시다.

각 스레드는 SIMD 그룹의 모든 스레드에서 볼 수 있듯이 Y에서 가장 큰 값을 가진 Z 값을 얻습니다.

다음으로 우리는 그것을 방송하고 X에 적용했다.

이 예에서, 우리는 단일 작업에서 다른 모든 차선에 레인 0의 값을 방송합니다.

A13용 금속은 모든 차선에서 셔플, 퍼뮤트 및 회전과 같은 다른 유사한 작동 SIMD 기능을 지원합니다.

마지막 예시를 위해 우리는 표현식이 모든 차선에 대해 동일하게 평가되는지 여부를 각 차선에 알려주는 simd_all을 살펴볼 것이다.

이 예에서 Z 변수는 실제로 모든 차선에 대해 9이며, 따라서 우리는 true를 반환합니다.

마찬가지로, simd_any는 표현식이 어떤 차선에 대해 true로 평가되는지 여부를 알려줍니다.

Simd_all을 사용하여 모든 스레드가 동일한 필요가 있을 때 더 최적의 경로를 선택함으로써 셰이더의 발산을 줄일 수 있습니다.

예를 들어 봅시다.

다음은 SIMD 그룹 함수를 사용한 몇 가지 최적화와 함께 이전의 프래그먼트 셰이더입니다.

요약하자면, 이 함수는 인수 버퍼, 유니폼 및 정점 stage_in으로 인코딩된 장면을 입력으로 사용합니다.

일반적으로 조명 기능은 투명한 조각에 대해 최종 색상의 다양한 구성 요소를 다르게 평가하므로 다양한 지점에서 동적 제어 흐름이 필요합니다.

이제, 모든 조각의 불투명도를 평가하는 대신, 여기서 우리는 simd_all을 사용하여 SIMD 그룹의 모든 스레드가 불투명 조각의 조명을 계산하고 있는지 동적으로 확인합니다.

만약 그렇다면, 우리는 불투명한 물체만을 가정하는 최적의 경로를 택한다.

그리고 그렇지 않다면, 우리는 불투명하고 투명한 조각을 모두 밝힐 수 있는 이전 경로로 되돌아간다.

그것은 A13의 SIMD 그룹 기능을 위한 것이다.

기어를 바꾸고 A13에서 ASTC에 추가된 몇 가지 흥미로운 것들을 살펴봅시다.

비디오에서 앞서 언급했듯이, A13 GPU는 16비트 부동 소수점 연산 속도를 두 배로 늘리고 HDR 처리를 더 잘 처리하기 위해 작은 16비트 숫자에 대한 지원을 추가합니다.

앱은 수정 없이 이러한 개선 사항을 활용합니다. GPU의 HDR 처리가 더 빠르고 정확해집니다.

Apple Family 6는 또한 ASTC HDR이라는 HDR 데이터의 효율적인 저장 및 샘플링을 지원하는 새로운 픽셀 형식 세트에 대한 지원을 추가합니다.

ASTC는 많은 플랫폼에서 지원되는 텍스처 압축 기술로, 대역폭과 메모리의 일부분으로 높은 텍스처 이미지 품질을 제공합니다.

그것은 여러 비트 전송률과 입력 형식을 지원함으로써 그렇게 한다.

ASTC 로우 다이내믹 레인지 프로파일은 Apple GPU 제품군 2부터 지원되었으며 0에서 1 범위의 값을 압축하는 데 적합합니다.

앱이 이미 ASTC를 사용하여 메모리와 대역폭을 저장하지 않는다면, 그렇게 하는 것이 좋습니다.

HDR 이미지에서 발견되는 더 큰 밝기 값을 인코딩하려면 높은 다이내믹 레인지 프로필이 필요합니다.

ASTC HDR이 없으면, 이러한 이미지는 일반적으로 훨씬 더 높은 메모리 비용으로 16비트 부동 소수점 픽셀 형식으로 저장됩니다.

그래서 ASTC HDR은 얼마나 많은 저장 공간을 절약할 수 있나요?

많이.

예를 들어 봅시다.

HDR 게임은 종종 저해상도 큐브 맵 텍스처를 사용하여 높은 다이내믹 레인지 환경 지도를 나타내며, 일반적으로 게임 세계나 레벨에 많은 프로브를 배치합니다.

ASTC HDR이 없으면, 각 프로브는 상당한 양의 메모리를 소비할 수 있으며, 이러한 모든 프로브는 게임 메모리 예산의 많은 부분을 쉽게 소비할 수 있습니다.

이 예에서, 256 x 256 프로브 큐브 맵만으로도 3MB를 소비한다.

ASTC HDR을 사용하면, 동일한 프로브는 몇 배 더 적은 메모리를 소비할 것이다.

발자국을 줄이기 위해 비트 전송률을 변경할 수도 있습니다.

HDR 텍스처를 만드는 것은 LDR만큼 간단하다.

이 예에서, 우리는 4x4 ASTC LDR 텍스처를 만들고 있습니다.

모든 LDR 형식에 일치하는 HDR 형식이 있으므로 이를 HDR 텍스처로 변환하려면 픽셀 형식을 변경하기만 하면 됩니다.

좋아요, 그것은 A13 GPU의 새로운 금속 기능을 마무리합니다.

우리가 배운 것을 요약해 봅시다.

그것은 희박한 질감으로 더 높은 품질의 질감을 스트리밍할 수 있다.

래스터화 속도 맵으로 필요한 곳에 값비싼 셰이딩을 집중하고, 정점 증폭으로 중복 정점 처리를 제거할 수 있습니다.

또한 인수 버퍼 Tier 2와 셔플 및 투표 지침으로 SIMD 그룹 공유를 통해 보다 유연한 GPU 기반 파이프라인을 가능하게 합니다.

그리고 마지막으로, 메탈은 이제 ASTC로 HDR 파이프라인에 메모리를 저장할 수 있습니다.

Metal, A13 GPU에 대한 자세한 정보와 최신 샘플 코드를 찾으려면 developer.apple.com을 방문하십시오.

고마워.