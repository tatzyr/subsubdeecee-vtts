10887

David Wendland: 안녕하세요 여러분, 저는 App Store의 상업 기술 옹호자인 David Wendland입니다.

오늘 가상으로 여기 와서 우리 팀 전체가 작업하고 있는 것을 공유하게 되어 기쁩니다.

시작하기 전에, 쿠퍼티노에 기반을 둔 동료들이 자신을 소개하고 싶습니다.

Manjeet Chawla: 안녕하세요, 제 이름은 Manjeet Chawla이고, 저는 App Store의 기술 프로그램 관리자입니다.

조 마니: 안녕하세요, 저는 조입니다.

저는 App Store의 프로그램 관리자입니다.

데이비드: 오늘 우리 셋은 "StoreKit 2와 App Store Server API로 고객 지원"이라는 제목의 3부작 시리즈를 소개합니다.

우리는 StoreKit 2 프레임워크와 App Store Server API의 기능이 인앱 구매, 고객 지원 및 환불 처리를 어떻게 개선할 수 있는지에 초점을 맞출 것입니다.

이 세 부분은 앱과 고객 경험 향상을 계획할 때 고려해야 할 통찰력, 접근 방식 및 이점을 제공하기를 바랍니다.

가을 출시에 대한 개요와 클라이언트에서 서버, 샌드박스에 이르기까지 새로운 기능부터 시작하여 인앱 구매를 시작할 것입니다.

그런 다음 이러한 업데이트를 통합할 때 로드맵을 전략화하고 우선 순위를 정하는 데 도움이 되는 몇 가지 구현 접근 방식을 다룰 것입니다.

새로운 것부터 시작합시다.

iOS 15로, 우리는 시작으로 돌아가서 StoreKit 2로 클라이언트 구현을 단순화하기 위해 완전히 새롭고 개선된 프레임워크를 만들었습니다.

이것은 더 많은 온디바이스 기능, 향상된 상태 정보를 가져왔고, 이제 거래는 보안을 강화하기 위해 JWS 형식을 사용합니다.

또한, 우리는 앱 내에서 직접 고객에게 더 많은 서비스를 제공하기 위해 세 가지 독립형 기능을 도입했습니다.

서버 측에서, 우리는 버전 2의 출시와 함께 기존 App Store 서버 알림을 크게 업데이트했습니다.

이것은 지원되는 구매 이벤트의 수를 크게 확장시켰고 또한 새로운 JWS 형식을 사용한다.

마지막으로, 우리는 App Store Server API로 일련의 기능을 출시했습니다.

고객의 구매 내역을 검색하거나 구독자의 현재 구독 상태를 제공하는 등 다양한 기능을 지원하는 다양한 엔드포인트가 있습니다.

다른 능력은 내 동료인 Manjeet과 Joe가 곧 다룰 다양한 고객 관리 시나리오를 다룬다.

올해의 광범위한 업데이트 목록은 StoreKit을 통한 인앱 구매에 대한 지속적인 투자를 보여줍니다.

전반적으로, 이것들은 보안을 개선하고, 복잡성을 줄이며, 샌드박스와 Xcode에서 인앱 구매를 더 쉽게 테스트할 수 있게 해준다.

Touch ID 및 Face ID와 같은 기능을 갖춘 플랫폼을 볼 때, 우리는 안전한 생체 인식과 마찰 없는 인증을 사용하여 고객이 15억 개 이상의 장치에서 안전하고 편리하게 구매할 수 있도록 합니다.

앱 스토어는 현재 175개 매장에서 40개 이상의 언어로 매주 6억 명의 방문객을 보유하고 있다.

지역별 가격 계층을 조정할 수 있으며 내년에는 지원되는 가격 계층의 수를 500개 이상으로 확장하여 더 많은 가격 옵션을 제공하고 각 통화와 시장에 대한 맞춤형 가격대를 제공할 것입니다.

195개의 결제 방법에 걸쳐 45개의 지원되는 통화를 통해, 우리는 고객이 선호하는 결제 방법과 이를 쌓을 수 있는 기능을 더 편리하게 사용할 수 있도록 노력하고 있습니다.

이러한 플랫폼 개선을 계속하는 동안, 저는 이제 StoreKit 2를 살펴보고 당신이 고려할 수 있도록 원래 StoreKit에 대한 이점과 주요 개선 사항을 강조하고 싶습니다.

StoreKit 2의 주요 기능을 살펴보면, 모든 고객의 장치에서 새로운 인앱 구매 거래를 자동으로 동기화합니다.

이를 통해 앱에서 일관되고 신뢰할 수 있는 경험을 제공할 수 있습니다.

이 프레임워크는 온디바이스 구매 검증을 지원하며 이전 프레임워크에 비해 간소화되므로 서버 측 구매 검증에 전적으로 의존할 필요가 없습니다.

모든 거래는 JWS를 사용하여 서명되므로 각 거래의 진위를 확인할 수 있습니다.

그리고 이 프레임워크는 장치에서 자격 상태 정보를 제공하여 복잡성을 줄여 적절한 자격 액세스를 보장할 수 있습니다.

그리고 iOS 15의 새로운 기능은 appAccountToken으로, 구매를 시작한 인앱 계정을 설정하고 완료된 거래로 반품할 수 있습니다.

또한, 원래 StoreKit 프레임워크와 함께 작동할 수 있는 몇 가지 독특한 독립형 StoreKit 2 기능이 있습니다.

따라서 오늘날 iOS 15와 함께 원래 StoreKit을 사용하는 앱은 이러한 독립적인 StoreKit 2 기능을 추가하여 일반적으로 앱 외부에서 발생하는 인앱 경험을 제공할 수 있습니다.

첫 번째는 showManageSubscriptions이다.

이를 통해 구독자는 앱을 떠나지 않고도 구독을 관리할 수 있습니다.

그런 다음 앱 내에서 환불 요청을 시작할 수 있는 고객에게 거래를 제시할 수 있는 시작RefundRequest가 있습니다.

그리고 이를 통해 샌드박스에서 보류 중이거나 거부된 환불을 테스트하고 시뮬레이션할 수 있습니다.

우리는 또한 고객의 입문 제안 자격을 더 쉽게 확인할 수 있는 기능을 도입했습니다.

이것은 무료 평가판과 같은 제안을 상품화할 때 구매를 완료할 때 실제로 제안을 받을 수 있도록 하기 때문에 중요합니다.

StoreKit 2를 사용하면 isEligibleForIntroOffer 방법과 구독 그룹 ID를 전달하여 이 검사를 빠르게 수행할 수 있습니다.

이것은 그들이 구독 그룹 내의 구독에 대해 어떤 유형의 입문 제안을 소비한 적이 있는지 확인합니다.

또한, StoreKit에 의해 반환된 경우에만 입문 제안을 상품화해야 합니다.

그것은 Product.SubscriptionOffer에서 나올 것이며, 가능한 경우 입문 제안 세부 사항을 반환할 것입니다.

그렇지 않다면, StoreKit에 의해 반환되지 않으므로 사용할 수 없는 제안을 상품화할 수 없습니다.

따라서 이것이 하드코딩되지 않고 대신 App Store Connect에서 구성된 시작 및 종료 날짜를 사용하는 StoreKit을 활용하는 것이 중요합니다.

이제 서버 측을 옮기고 고객 상호 작용 없이 서버 간 요청이 이루어지는 App Store Server API의 기능에 대해 논의하고 싶습니다.

우리는 구독 상태로 시작할 것입니다.

이것은 당신의 앱과 함께 고객의 구독 상태를 제공합니다.

그리고 여러 구독 오퍼링이 있는 경우, 구독당 자격 상태를 갖게 되며, 각각은 고유한 원래 거래 ID로 표시됩니다.

구독 상태의 큰 부분은 각 구독에 대해 현재 JWS 서명된 거래만 반환하므로 서버의 논리가 고객의 거래 내역을 구문 분석할 필요가 없으며, 현재 거래 또는 권한을 부여할 제품을 결정하려고 합니다.

이제 멀티 플랫폼 서비스 제공 업체인 경우, 이 서비스를 사용하여 앱을 실행하지 않고 언제든지 서버 대 서버로 현재 상태를 얻을 수 있으며, 고객의 원래 거래 ID만 있으면 됩니다. 더 이상 앱 영수증은 없습니다.

여기 우리가 추천하는 몇 가지 모범 사례가 있습니다.

구매하거나 거래를 복원할 때마다 항상 고유한 원본 거래 ID를 데이터베이스에 저장하는 것이 중요합니다.

이 값은 초기 구매에서 갱신, 청구 문제 및 복구 또는 업그레이드 및 다운그레이드에 이르기까지 구독 수명 주기를 추적하는 데 중요한 각 구독 오퍼링을 나타냅니다.

이 ID는 서버 알림과 함께 클라이언트 및 서버 API와 함께 사용됩니다.

마지막으로, 구독 상태는 보안 모범 사례로 서버 대 서버로만 사용해야 합니다.

앱에서 직접 상태를 확인해야 한다면, StoreKit 2 프레임워크에 해결책이 있습니다.

서버 API의 다음 기능은 고객의 완전하고 최신 거래 내역을 서버 대 서버로 검색할 수 있는 인앱 구매 내역입니다.

기록에는 모든 비소모품, 비갱신 구독, 자동 갱신 구독 및 미완성 소모품 구매가 포함되며, 모두 JWS가 서명한 거래가 안전할 것입니다.

이제 거래 내역과 모든 원래 거래 ID를 갖는 것은 환불 요청을 시작하기 위해 고객이 선택할 수 있는 거래를 표면화해야 하기 때문에 beginRefundRequest API를 구현할 때 도움이 될 것입니다.

원래 StoreKit을 사용하는 앱에서 비구독 인앱 구매의 경우, verifyReceipt에서 벗어나 이 API를 사용하여 성공적인 구매를 검증하거나 중단 시 업데이트를 확인할 수 있습니다.

모범 사례를 위해, 일부 고객은 많은 구매를 할 수 있으므로, 응답에는 한 번에 최대 20건의 거래가 포함될 것이다.

추가 거래가 있을 때, 반드시 hasMore 필드를 사용하세요.

사실이라면, 그 응답과 후속 요청에서 개정 토큰을 사용하여 거래의 다음 페이지를 얻으십시오.

hasMore 필드가 false를 반환할 때까지 반복하고 향후 개정 토큰을 저장하십시오.

그것은 당신이 다시 페이지를 매길 필요가 없도록 기록된 수정 토큰을 사용하여 고객의 최신 거래를 빠르게 검색하는 데 도움이 될 것입니다.

또 다른 중요한 모범 사례는 제품이나 서비스가 전달된 후 finishTransaction을 사용하는 것이다.

미완성 거래는 대기열에 남아 있으며 앱이 고객에게 전달해야 하는 구매를 추적하는 데 도움이 될 것입니다.

이것은 장치에서 중단이 있을 경우에 매우 중요하다.

환불 또는 취소된 거래에 대한 최종 권장 사항은 가능한 한 빠르고 효율적으로 이에 대한 업데이트를 받고 싶다면 버전 2 서버 알림을 살펴보는 것입니다.

이것들은 우리의 API를 폴링하는 것보다 훨씬 더 효율적이다.

이제 우리의 서버 알림을 보세요.

이것들은 주요 구매 이벤트와 상태 변경을 위해 거의 실시간으로 서버로 직접 전송됩니다.

올해 우리는 버전 2로 이 기능을 극적으로 개선하여 더 효과적이고, 사용하기 쉽고, 더 세분화를 제공합니다.

우리는 지원되는 이벤트의 수를 두 배로 늘렸고, 총 28개의 독특한 이벤트로 늘어났다!

버전 2에서는 이벤트당 하나의 알림만 보내므로, 수신 시 특정 조치를 취할 수 있습니다.

그리고 이러한 알림은 가족 공유를 통해 앱 내 구매에 액세스할 수 있는 가족 구성원에게도 적용됩니다.

그리고 실패한 알림 배달의 경우, 우리는 정전을 설명하기 위해 7일 동안 최대 5번까지 재시도할 것입니다.

그리고 물론, 버전 2는 샌드박스에서 사용할 수 있으므로, 테스트 환경에서 안전하게 개발할 수 있습니다.

일부 모범 사례의 경우, 이러한 알림을 받을 때, 성공적으로 수신되었을 때 HTTP 200 응답 코드로 응답하는 것이 중요합니다.

이것은 당신이 알림을 받았고 우리가 다시 보낼 필요가 없다는 것을 나타냅니다.

서버가 오류를 반환하거나 응답하지 않으면, App Store는 동일한 알림 페이로드를 다시 보냅니다.

각 알림에는 서명된 날짜가 있습니다; 원본 알림이 언제 전송되었는지 정확히 알 수 있습니다.

그리고 JWS가 서명한 거래 정보를 사용하여 받은 알림의 진위를 검증할 수 있으므로, 이것들이 App Store에서 서명되었다는 확신을 가질 수 있습니다.

그리고 샌드박스와 프로덕션 이벤트를 위한 고유한 서버 URL을 제공하는 새로운 기능을 활용해야 합니다.

그리고 최종 모범 사례로, 알림 업데이트를 즉시 적용하세요.

일부 이벤트는 업그레이드나 환불과 같이 시간에 민감합니다.

따라서, 이것들을 거의 실시간으로 처리하는 것이 도움이 될 수 있다.

그리고 당신에게 간략하게 설명하기 위한 마지막 업데이트는 샌드박스에서 인앱 구매를 테스트하는 데 도움이 되는 App Store Connect의 업데이트입니다.

샌드박스 테스터 아래의 사용자 및 액세스 탭에서 이러한 기능에 액세스할 수 있습니다.

이미 아시다시피, 오늘 샌드박스에서 구독은 테스트를 지원하기 위해 빠른 속도로 갱신됩니다.

이제 Xcode에서 StoreKit 테스트를 할 수 있는 것처럼 샌드박스 Apple ID당 갱신 속도를 늦추거나 가속화할 수 있는 기능을 추가했습니다.

이것은 갱신 사이에 작업을 수행하는 데 더 많은 시간이 필요할 때 시나리오에 도움이 될 것입니다.

다른 상점에서 테스트를 돕기 위해, 이제 언제든지 샌드박스 Apple ID의 상점을 변경할 수 있습니다.

그리고 단일 샌드박스 애플 ID의 사용을 더욱 확장하기 위해, 이제 자동 갱신 구독 및 비소모품의 구매 내역을 지울 수 있으며, 예를 들어 콘텐츠를 구매하거나 입문 제안을 반복적으로 사용할 수 있습니다.

이제 StoreKit 2와 Server API의 몇 가지 이점과 모범 사례를 다루었으므로, 이러한 기능과 기능을 앱이나 서버에 통합할 준비를 할 때 고려해야 할 몇 가지 접근 방식을 검토해 봅시다.

우리가 인앱 구매에 대해 생각할 때, 우리는 주로 고객에게 구매 자격을 부여하고 상태 변경을 처리하는 것에 대해 생각합니다.

이렇게 하려면, 서버 백엔드 없이 로컬에서 모든 것을 하는 온디바이스 접근 방식을 선택하거나 서버가 진실의 원천인 서버 대 서버 API를 활용해야 합니다.

온디바이스부터 시작합시다.

이것은 StoreKit 2 프레임워크가 앱에 서버 없이 모든 장치에서 앱 내 구매 및 상태 변경을 완전히 관리할 수 있는 기능을 제공하는 곳입니다.

이것은 중소기업과 기존 서버 백엔드가 없는 사람들에게 매우 도움이 될 수 있다.

이를 위해, 구매 흐름을 지원하기 위해 StoreKit 2의 세 가지 핵심 기능으로 시작합니다.

앱은 제품을 사용하여 사용 가능한 제품과 세부 사항을 검색하여 앱 내에서 머천다이징을 추진합니다.

이것은 항상 정확하고 App Store와 동기화되도록 보장합니다.

그리고 이제 StoreKit 2를 사용하면 VerificationResult와 PurchaseResult가 있으며, 이는 성공적인 구매 또는 복원된 거래 후 거래의 진위를 검증하는 데 사용됩니다.

StoreKit 2 프레임워크의 또 다른 주요 이점은 모든 거래에 대해 앱을 최신 상태로 유지할 수 있다는 것입니다.

고객은 여러 장치를 가지고 있을 수 있으며, Transaction.updates를 사용하면 거래가 시작된 장치에 관계없이 앱이 동기화됩니다.

currentEntitlement 방법을 사용하면 앱이 고객의 구매에 대한 즉각적인 상태를 빠르게 얻을 수 있으므로 최신 거래 세부 정보가 있으므로 로그인하거나 구매 복원을 수행하지 않고도 해당 제품을 고객에게 즉시 부여할 수 있습니다.

마지막으로, 우리는 제품 자체뿐만 아니라 현재 구독자의 상태와 다가오는 갱신 기간에 대해 장치에서 자동 갱신 구독 정보를 얻는 것이 얼마나 중요한지 이해합니다.

그것을 위해 우리는 Product.SubscriptionInfo가 있습니다.

그래서 제가 방금 다룬 이 여섯 가지 핵심 기능으로, iOS 15에서 StoreKit 2를 활용하고 서버에 대한 의존도를 줄이거나 제거하여 최고의 고객 경험을 제공할 수 있습니다.

이제 서버 대 서버 아키텍처에 대해 생각할 때, 이것은 고객이 서비스에 안정적으로 액세스할 것으로 기대하는 멀티플랫폼 또는 멀티앱 서비스에 매우 중요하며, 시스템은 언제든지 실시간으로 구매 상태를 업데이트해야 합니다.

일반적으로 이 설정에서, 당신은 진실의 원천으로 서버를 가지고 있으며, 언제든지 App Store에서 업데이트를 받고 확인할 수 있는 연중무휴 24시간 온라인 상태입니다.

하지만 앱의 관점에서 이 흐름을 살펴봅시다.

여기에 고객의 장치가 있으며, 앱이 원래 StoreKit 프레임워크를 사용하여 구매를 시작하고 구매 확인을 위해 App Store verifyReceipt 서버를 사용한다고 가정해 봅시다.

즉, 앱이 구매 또는 복원 이벤트 후 Base64로 인코딩된 앱 영수증을 서버로 보낸 다음 verifyReceipt 서버로 전송됩니다.

App Store는 고객의 거래로 응답할 것이며, 이제 서버는 상태를 평가하고 결정하기 위해 해당 거래를 구문 분석해야 하며 서버 측 또는 앱 내에서 어떤 조치를 취해야 하는지 확인해야 합니다.

이제, 당신은 스스로에게 이 질문을 했을 수도 있습니다.

좋은 소식은, App Store Server API는 전체 StoreKit 2 프레임워크를 채택하는 앱에 의존하지 않는다는 것입니다.

즉, 앱이 원래 StoreKit을 계속 사용하는 동안 App Store Server API에서 사용할 수 있는 새로운 기능을 즉시 활용할 수 있습니다.

네가 이걸 어떻게 할 수 있는지 살펴봅시다.

같은 디자인으로, 당신은 두 가지 주요 변경을 해야 할 것입니다.

먼저, 우리는 원래 거래 ID를 검색하기 위해 당신의 앱을 업데이트할 것입니다.

둘째, App Store Server API를 사용하도록 서버를 업데이트할 것입니다.

이 두 가지 변경 사항을 통해 앱은 원래 StoreKit 또는 StoreKit 2를 사용할 수 있어 모든 iOS 버전에서 최신 앱 버전을 쉽게 지원할 수 있습니다.

첫 번째 변경을 하고 앞으로 original_transaction_ID를 사용하기 시작하려면, Base64 앱 영수증을 검색하는 논리를 교체할 것입니다.

이렇게 하기 위해, 당신은 앱 영수증 URL 방법을 사용했을 수도 있습니다.

자동 갱신 구독을 위해 이 속성으로 교체하세요.

그리고 다른 인앱 구매 유형의 경우, 이 유사한 속성을 사용할 것입니다.

이제 App Store Server API를 사용하도록 서버를 업데이트해 봅시다.

/verifyReceipt에서 /History 또는 /SubscriptionStatus URL로 변경됩니다.

요청은 승인을 위해 JWT를 사용할 것이며, 앞으로는 원래 거래 ID를 사용할 것입니다.

이러한 변경 사항을 완료하면 더 이상 서버에서 유지할 자격 논리가 없으며 이제 안전한 JWS 서명된 거래를 사용할 수 있으며 앱 영수증을 저장할 필요가 없습니다.

따라서 앱이 이전 버전의 iOS를 지원하는 경우, App Store Server API가 제공하는 것을 활용할 수 있는 경로를 제공합니다.

앞서, 우리는 StoreKit 2와 서버 API가 구독 상태를 결정하는 방법을 언급했습니다.

이제 모범 사례로, 앱은 앱 출시 시 항상 구독자 상태를 결정해야 합니다.

상태가 결정되면, 로컬에 저장하고 필요에 따라 업데이트할 수 있습니다.

저는 우리가 돌아오는 이 다섯 가지 주와 당신이 각각에 대해 취해야 할 조치와 함께 고려해야 할 몇 가지 기회를 간략하게 검토하고 싶습니다.

이제 새로운 고객은 이러한 상태 중 어느 것도 가지고 있지 않을 것이며, 그것은 당신의 앱이 관리해야 하는 상태라는 점에 유의해야 합니다.

활성 상태로 시작해서, 이것은 만료일까지 고객에게 서비스를 제공해야 한다는 것을 의미합니다.

이제 여러 수준의 서비스를 제공한다면, 프로모션 제안을 사용하여 앱 내에서 업그레이드 제안을 표면화할 수 있는 한 가지 기회가 될 수 있습니다.

그러한 제안은 과거 구독 내역을 기반으로 고객에게 맞춤화되어야 한다는 점에 유의하십시오.

이제 구독이 완전히 이탈되면, 당신은 만료된 상태가 될 것입니다.

서비스를 제공할 필요가 없으며 현재 구독 서비스를 상품화할 수 있습니다.

선택적으로, 프로모션 제안이나 구독 제안 코드를 활용하여 윈백 제안을 제시할 수 있습니다.

만료일로부터 60일 이내에 재구독하면, 기존의 누적된 유급 서비스 일수는 85%의 수익금 비율로 재개될 것이다.

다음은 청구 재시도 기간입니다.

우리 모두는 때때로 청구 문제를 경험합니다; 신용 카드가 만료되거나 상점 크레딧이 소비될 수 있습니다.

이 구독은 자동 갱신될 것으로 예상되었지만, 결제 방법 문제로 인해 우리가 청구 재시도 기간이라고 부르는 것에 빠졌습니다.

구독이 만료되고 서비스를 제공할 필요가 없는 동안, 고객은 다시 구독할 필요가 없습니다. 그들은 단순히 청구 문제를 해결해야 합니다.

우리는 개발자 조치 없이 다양한 고객 커뮤니케이션을 통해 최대 60일 동안 구독을 재시도하고 복구하기 위해 자동으로 재시도할 것입니다.

하지만 인앱 메시징을 사용하면 고객에게 청구 문제를 직접 알리고 고객을 결제 정보 페이지에 깊이 연결하여 해결할 수 있는 귀중한 행동 촉구를 제공할 수 있습니다.

다음은 청구 재시도와 관련된 유예 기간이지만 App Store Connect에서 App Store 청구 유예 기간을 선택한 경우에만 구독자에게 적용됩니다.

이 상태의 경우, 유예 기간이 만료될 때까지 중단 없이 서비스를 계속 제공할 것입니다.

유예 기간 동안 구독자를 복구하면, 그들은 원래 청구 주기를 유지할 것이다.

따라서, 그들은 서비스에 방해가 없으며 공급자는 청구 가능한 날의 손실을 피한다.

이제 청구 재시도와 마찬가지로, 청구 문제를 알리기 위해 동일한 인앱 메시징을 제공하고 싶습니다.

마지막으로, 취소된 상태를 볼 때, 이것은 가족이 공유할 수 있는 구독에 적용됩니다.

이 가족 구성원들은 더 이상 해당 서비스나 콘텐츠를 받을 자격이 없으므로, 액세스를 취소할 수 있으며 이러한 고객을 다시 확보하기 위한 상품을 상품화할 수 있습니다.

마지막 부분에서, 저는 당신이 App Store 서버 알림을 사용할 때 고려해야 할 몇 가지 구현 접근 방식에 대해 자세히 알아보고 싶습니다.

지원되는 이 모든 이벤트를 보면, 꽤 많은 것들이 있다는 것을 알 수 있으며, 일부는 당신의 사업에 적용될 수도 있고 적용되지 않을 수도 있습니다.

많은 것들이 구독 수명 주기의 일부인 반면, 다른 것들은 모든 인앱 구매 유형에 적용됩니다.

구독을 제공하지 않는다면, 구독이 더 복잡하고 단순히 적용되지 않는 많은 이벤트를 피할 수 있기 때문에 구현 접근 방식이 더 간단합니다.

하지만 당신이 고려할 수 있도록 이러한 다양한 구현 단계를 검토해 봅시다.

우리는 그것을 세 가지로 나누었다: 시작하기, 수명 주기 지원, 통찰력에 대한 조치를 취하는 것.

버전 2를 채택할 때, 이 시작 단계는 비즈니스 모델이나 버전 1 알림을 채택했거나 아직 채택하지 않았더라도 모든 사람에게 적용됩니다.

첫 번째 단계는 App Store Connect에서 버전 2를 활성화하는 것입니다.

"앱 스토어 서버 알림"이라는 제목의 앱 정보에서 이 기능을 찾을 수 있습니다.

그리고 가을 업데이트를 통해, 이제 샌드박스와 생산을 위한 URL을 선택할 수 있습니다.

그 URL을 추가하고 받을 버전을 선택할 수 있습니다.

그리고 이미 버전 1을 받고 있다면, 프로덕션에서 활성화하기 전에 개발을 허용하기 위해 샌드박스에서 버전 2만 활성화하는 것이 좋습니다.

이제 버전 2를 활성화했으므로 우선 순위를 살펴보고 싶으므로 비즈니스 모델과 사용량에 따라 어떤 알림을 먼저 지원할지 평가하십시오.

돕기 위해, 당신은 당신의 비즈니스와 로드맵에 가장 많이 적용되는 주요 대규모 이벤트에 집중해야 합니다.

모든 인앱 구매 유형에 적용되는 한 가지 이벤트는 환불입니다.

고객에게 환불되는 각 거래에 대해 단일 환불 알림을 받습니다.

그 사건들을 어떻게 처리하는지는 당신의 정책과 비즈니스 모델에 달려 있습니다.

이제 구독 기반 비즈니스의 경우, 이 네 가지 알림은 초기 구매 또는 재구독에서 성공적인 갱신 또는 실패, 만료에 이르기까지 구독 여정의 주요 이벤트에 적용됩니다.

이 다섯 가지 알림 유형에 대한 조치를 우선시함으로써, 당신이 받을 수 있는 대부분의 이벤트에 대한 지원을 받을 수 있다는 것을 의미합니다.

그 첫 번째 단계는 견고한 기반을 제공하고 수익을 극대화할 수 있게 해준다.

이제 다음 단계에서 모든 알림 유형에 대한 지원을 완료할 수 있습니다.

구독 기반 알림이 몇 개 남아 있는 반면, 나머지는 기능 채택에 따라 다릅니다.

검토해 봅시다.

이 두 가지 유형은 모든 구독 기반 앱인 DID_CHANGE_RENEWAL_STATUS 및 선호도에 적용됩니다.

이것들은 서비스 수준을 취소하거나 변경하는 고객을 식별하는 데 매우 중요하다.

이러한 나머지 유형을 고려할 때, 이것들은 당신의 사용법에 달려 있습니다.

App Store Connect에서 청구 유예 기간을 활성화한 경우 GRACE_PERIOD_EXPIRED가 적용됩니다.

App Store Server API로 구독자의 갱신을 연장한 경우 RENEWAL_EXTENDED가 전송됩니다.

그리고 REVOKE는 제품이 인앱 구매를 위해 가족 공유를 위해 활성화된 경우 적용됩니다.

OFFER REDEEMED는 구독 제안 코드 또는 프로모션 제안을 사용할 때 적용됩니다.

그리고 자동 갱신 구독 가격이 인상되면 PRICE_INCREASE가 전송됩니다.

그리고 나서 우리는 REFUND_DECLINED와 CONSUMPTION_REQUEST가 있습니다.

조는 환불 처리에 대한 그의 부분에서 이것들을 심층적으로 다룰 것이다.

마지막으로, 우리는 통찰력 단계에 대한 행동으로 넘어갈 수 있다.

이 시점에서, 당신은 이제 당신의 사업과 관련된 모든 이벤트를 받고 조치를 취하고 있습니다.

이렇게 하면 서비스가 모든 고객 구독의 현재 상태 또는 구매한 소모품, 비소모품 또는 비갱신 구독에 대한 액세스 변경 사항을 알 수 있습니다.

구독을 통해, 다음 알림은 매우 특정 상태의 고객을 식별하므로, 귀하의 비즈니스는 구독자를 식별하고 지능적으로 참여, 유지 및 되찾을 수 있는 특정 사전 조치를 취할 수 있습니다.

다음은 고객과 소통하거나, 사전 인앱 메시징을 제공하거나, 맞춤형 구독 제안을 제시할 수 있는 기회의 창에서 주요 이벤트를 식별할 수 있는 몇 가지 예시 알림 유형입니다.

한 가지 예를 들어 봅시다: 구독을 취소하는 고객.

이 시나리오에서, 구독자가 11월 25일에 월간 구독을 구매했다고 가정해 봅시다.

그리고 12월 5일에, 구독자는 현재 기간에 20일이 남아 있는 상태에서 취소하기로 결정했습니다.

이것은 구독자가 취소한 시점부터 구독이 만료되고 자발적으로 이탈되는 시점까지 우리의 절약 기간입니다.

이제 그 취소 작업이 발생하면, 자동 갱신 상태는 false로 설정되며, 즉시 App Store가 AUTO_RENEW_DISABLED의 하위 유형과 함께 DID_CHANGE_RENEWAL_STATUS 알림을 보내 저장 기간의 시작을 실시간으로 알려줍니다.

이 기회의 창을 통해 귀하의 서비스는 만료되기 전에 맞춤형 인앱 메시징 또는 상품 저장 제안을 제시할 수 있습니다.

그러한 제안이 맞춤화되고 각 고객 집단에 대한 자격 기준을 갖는 것이 중요합니다.

이것으로 내 몫을 마칩니다.

이제 저는 제 동료인 Manjeet을 소개하고 싶습니다.

맨지트: 고마워, 데이브! 제 이름은 Manjeet Chawla이고, App Store의 기술 프로그램 관리자입니다.

이제 데이브는 StoreKit 2와 App Store Server API를 사용하여 인앱 구매를 개선하는 방법에 대해 이야기했습니다.

이제, 고객 지원 관점에서 정확히 동일한 API를 검토해 봅시다.

나는 오늘날 고객이 인앱 구매와 이러한 시나리오에 이러한 API를 활용하기 위한 모범 사례로 직면하는 몇 가지 일반적인 지원 시나리오에 대해 이야기할 것이다.

하지만 고객 지원에 대해 이야기하기 전에, 지원 제공이 전반적인 고객 관리에 어떤 영향을 미치는지 이해합시다.

인수, 분석, 고객 지원 및 다양한 마케팅 커뮤니케이션 채널과 같은 다양한 CRM 도구와 시스템에 의존할 수 있습니다.

그리고 지원을 제공하는 것은 고객을 만족시키고 제품에 참여하게 하며 전반적인 고객 관계와 만족도를 향상시킵니다.

이제 우리는 고객이 당신에게 도움을 요청하고 App Store가 지원을 제공하고 문제를 효율적으로 해결할 수 있는 도구를 만들었다는 것을 알고 있습니다.

그리고 오늘, 저는 주문 ID 찾기로 시작하는 모든 지원 채널에서 문의하는 데 도움이 되는 다섯 가지 새로운 고객 지원 도구에 대해 이야기할 것입니다.

오늘날, 고객이 인앱 구매를 할 때, 그들은 Apple ID로 전송된 영수증을 받고 계정 설정에서 구매 내역을 보고 언제든지 이 영수증에 액세스할 수 있습니다.

그리고 이제, 고객이 당신에게 연락할 때, 지원 팀은 고객에게 이 영수증의 주문 ID를 요청하고 새로운 App Store Server API에 전화하여 주문 ID를 사용하여 해당 영수증에 대한 고객의 인앱 구매를 조회할 수 있습니다.

또한 이 API를 사용하여 영수증의 진위를 검증하고 해당 영수증 내의 거래를 고객과 연결할 수 있습니다.

또한, 이 API를 사용하여 구매 내의 문제를 식별할 수 있습니다.

예를 들어, 거래에 App Store에서 이미 환불되거나 취소된 구매가 포함된 경우, 환불에 대한 자세한 내용을 얻기 위해 응답에서 revocationDate와 revocationReason을 볼 수 있습니다.

그리고 이 API를 구현하면, 고객이 지원을 위해 연락할 때 주문 ID에 대한 과거 구매를 조회할 수 있습니다.

모범 사례를 위해, 모든 인앱 구매에 대한 original_transaction_id를 고객 계정 데이터베이스에 저장하세요.

그리고 고객이 지원을 위해 연락하면, 이 API를 사용하여 계정 데이터베이스 내에서 고객의 구매를 쉽게 조회하고 연결할 수 있습니다.

이 API를 전화, 이메일 또는 웹과 같은 기존 고객 지원 채널과 통합하여 고객에게 일관된 지원 경험을 제공할 수도 있습니다.

다음으로, 환불 조회에 대해 이야기해 봅시다.

WWDC20에서 App Store는 고객이 인앱 구매에 대해 성공적으로 환불받을 때마다 서버에 알리는 환불 알림을 도입했습니다.

환불 조회는 고객의 모든 환불 거래를 조회할 수 있는 새로운 App Store Server API입니다.

이 API를 사용하면 언제든지 빠르고 쉽게 환불을 찾아 서버 중단을 처리하거나 유지 보수를 예약할 수 있습니다.

또한, 모든 인앱 구매 유형에서 고객의 전체 환불 내역을 확인할 수 있습니다.

또한 이 API를 사용하여 환불이나 의심스러운 활동의 급증을 모니터링할 수 있으며, 환불로 이어질 수 있는 콘텐츠 전송 문제에 대응할 수 있습니다.

모범 사례를 위해, 각 인앱 구매에 대한 original_transaction_id를 고객 계정 데이터베이스에 저장하는 경우, original_transaction_ids를 사용하여 과거 환불을 조회할 수 있습니다.

그리고 환불 조회 API를 사용하여 환불로 이어질 수 있는 고객의 콘텐츠 전송 문제를 해결할 수 있습니다.

이제 자동 갱신 구독에 대해 구체적으로 이야기하기 위해 기어를 바꾸자.

예를 들어, 정전이 있거나 이벤트가 취소된 시나리오는 스포츠, 라이브 TV 또는 비디오와 같은 스트리밍 기반 앱에서 더 일반적일 수 있습니다.

이러한 정전이나 취소된 이벤트의 경우, 어떻게 고객을 달래줄 수 있나요?

이제 새로운 갱신 확장 서버 API를 사용하여 유료 활성 구독의 갱신일을 연장하고 고객에게 추가 시간 동안 무료 서비스를 제공할 수 있습니다.

이 API를 사용하여 일시적인 정전을 처리하고 불만 완화를 제공할 수 있습니다. 예를 들어, 고객이 서비스에 대해 나쁜 경험을 했을 때.

실제 구독 기간에 관계없이 고객의 구독 갱신일을 1년에 두 번(매번, 최대 90일까지) 연장할 수 있습니다.

또한, 이 연장 기간은 85%의 수익금을 받는 데 필요한 1년의 유료 서비스에 포함되지 않습니다.

모범 사례를 위해, 갱신 날짜를 연장하려는 구독을 식별하기 위해 original_transaction_id를 저장하십시오.

비즈니스 모델에 가장 적합한 연장 기간을 확인하고 고객의 구독을 연장할 때 인앱 메시징을 보여주세요.

그리고 1년에 고객당 두 번의 연장만 있을 수 있기 때문에, 연장 자격이 있는 고객에 대한 자격 기준을 유지하고 싶을 수도 있습니다.

그리고 항상 비즈니스 및 마케팅 팀과 협력하여 모든 커뮤니케이션 채널에서 일관된 메시지를 제공하십시오.

이제 구독에 대한 일회성 할인을 제공하여 고객에게 보상하고 싶은 다른 시나리오에 대해 논의해 봅시다.

iOS 14에서 App Store는 제한된 시간 동안 할인 또는 무료 구독을 제공하여 구독자를 획득, 유지 및 되찾는 데 도움이 되는 구독 제안 코드를 도입했습니다.

온라인 또는 오프라인 채널을 사용하여 이러한 일회성 고유 코드를 배포할 수 있습니다.

그리고 고객 서비스 문제의 경우, 서비스 문제에 대한 보상으로 이러한 일회성 코드를 제공할 수 있습니다.

당신은 또한 이것을 대체 구독 옵션을 제안할 기회로 사용할 수 있습니다; 예를 들어, 더 낮은 가격에 더 많은 가치를 제공하는 더 긴 기간 계획.

iOS 14 및 iPadOS 14 이상의 고객은 일회성 코드 교환 URL을 통해 App Store에서 또는 StoreKit에서 presentCodeRedemptionSheet API를 구현한 경우 앱 내에서 제안 코드를 교환할 수 있습니다.

이제 모범 사례를 위해, 고객이 정보에 입각한 결정을 내릴 수 있도록 제안 코드에 대한 맞춤형 인앱 메시징 및 설명과 함께 코드를 교환할 수 있도록 앱 내에서 상환 흐름을 제공하십시오.

그리고 전화, 이메일, 웹과 같은 기존 고객 지원 채널 또는 앱 내에서, 예를 들어 고객이 라이브 채팅 세션에서 지원 팀과 채팅할 때 이것을 사용하세요.

이제, 이메일과 같은 디지털 마케팅 채널에 이러한 코드를 배포하는 경우, 각 코드에는 미리 채워진 코드와 관련된 상환 URL이 있습니다.

고유한 URL을 사용하여 이메일에서 고객을 App Store에서 발생하는 상환 흐름에 원활하게 딥 링크할 수 있습니다.

이 URL은 두 가지 값으로 구성됩니다: 애플리케이션의 ID를 나타내는 ID이므로 각 애플리케이션에 대해 정적일 것입니다. 두 번째 값은 구독자 고유 영숫자 값으로 URL을 동적으로 채우는 코드입니다.

이제, 그 URL이 이메일에 포함되어 있다면, 탭하면 사용자가 App Store로 이동하여 거래를 완료할 수 있습니다.

주의해야 할 사항: 여기 구독자는 이 흐름 중에 코드를 볼 수 없으며, 완료되면 고객이 애플리케이션을 다시 시작할 때 앱이 이행해야 하는 또 다른 외부 거래가 될 것입니다.

다음으로, 고객이 구독을 관리하고 싶어하는 시나리오를 다루겠습니다.

StoreKit 2에서, 우리는 앱 내에서 바로 기존 관리 구독을 표시할 수 있는 새로운 관리 구독 API를 출시했습니다.

앱 내 구독 관리를 지원한다는 것은 고객이 앱을 떠나지 않고도 구독을 업그레이드, 다운그레이드 또는 취소할 수 있다는 것을 의미합니다.

이것은 또한 당신에게 일반적인 구독자 문제에 대한 도움을 제공하고 고객이 고려할 수 있는 대안 제안을 제시할 수 있는 자연스러운 장소를 제공합니다.

그리고 이 기회를 사용하여 구독 관리 페이지를 보기 전에 개인화된 저장 제안을 제시할 수 있습니다. 예를 들어, 참여가 낮은 경우.

또는 취소에 대한 자세한 내용을 얻기 위해 취소하면 출구 설문조사를 제출할 수도 있습니다.

이제 모범 사례를 위해.

StoreKit API를 사용하면 앱을 떠나지 않고도 구독을 관리하거나 취소하는 데 도움이 되는 일관된 경험을 제공할 수 있습니다.

시스템 제공 관리 UI를 보완하기 위해 브랜드 문맥 경험을 만드는 것을 고려해 보세요.

예를 들어, 고객의 선호도나 사용에 따라 개인화된 제안이나 대체 계획을 제공하기 위해 인기 있는 프리미엄 계층을 제공할 수 있습니다.

그리고 모든 채널에서 고객 지원 여정과 관련된 전반적인 구독 관리 경험을 검토하십시오.

이제, 앱에서 구독 관리 UI 샘플을 살펴봅시다.

사용자가 구독을 관리할 수 있도록.

그리고 고객이 이 버튼을 탭하면, App Store는 현재 활성화된 구독과 갱신 옵션이 있는 기존 구독 관리 페이지를 표시합니다.

이것은 고객이 App Store의 계정 설정에서 구독 관리를 방문하여 구독을 확인, 업그레이드, 다운그레이드 또는 취소할 수 있는 것과 동일한 보기입니다.

이제, 고객이 구독을 취소하도록 선택하면, 취소 세부 사항과 서비스 만료일이 포함된 확인 화면이 표시됩니다.

그리고 사용자가 이 페이지에서 취할 수 있는 모든 조치에 대해, App Store 서버 알림을 받게 되며 StoreKit 2 프레임워크를 구현한 경우 앱이 알림을 받게 됩니다.

그래서 제가 오늘 다룬 새로운 고객 지원 도구로, 이러한 API를 사용하여 지원을 제공하는 이점에 대해 이야기해 봅시다.

이제 앱 내에서 앱 내 구매에 대한 상황에 맞는 원활한 지원을 제공하여 전반적인 고객 경험을 개선할 수 있습니다.

이것은 전반적인 유지율을 높이고 고객 만족도를 향상시켜 더 높은 참여로 이어지며, 궁극적으로 앱에 대한 더 긍정적인 평가와 리뷰로 이어집니다.

이제, 저는 제 동료 Joe를 초대하여 환불 처리에 대해 이야기하고 싶습니다.

Joe: Manjeet, 출시된 새로운 고객 지원 도구에 대한 모범 사례와 사용 사례를 제공해 주셔서 감사합니다.

안녕하세요, 여러분, 제 이름은 조 마니이고, 저는 앱 스토어의 프로그램 매니저입니다.

환불은 민감한 주제이며, App Store는 환불이 앱에 미치는 영향과 이러한 도구를 활용하여 고객 경험을 개선하는 방법을 이해할 수 있는 도구를 만들었습니다.

저는 이러한 도구 사용의 이점을 강조하고 환불 처리에 대한 포괄적인 메시지를 제공하고 싶습니다.

작년에, 우리는 환불에 영향을 미치는 두 가지 새로운 도구를 출시했습니다.

먼저, beginRefundRequest API에 대해 논의해 봅시다.

App Store는 문제를 보고했고 Apple Support는 고객이 환불을 요청할 수 있는 경로를 설정했습니다.

이제 iOS 15에서 App Store는 고객이 인앱 구매에 대한 환불을 요청할 수 있도록 StoreKit 2 프레임워크에 새로운 beginRefundRequest API를 도입했습니다.

beginRefundRequest API를 구현하는 데는 여러 가지 이점이 있습니다.

듣고 있는 여러분 대부분은 인앱 구매에 대한 환불을 요청한 고객이 있습니다.

새로운 beginRefundRequest API를 사용하면 고객을 리디렉션하고 앱 내에서 지원을 제공하지 않고도 동일한 기능을 제공할 수 있습니다.

인앱 구매와 관련된 잠재적인 문제를 알고 있다면, 이 API를 사용하여 고객이 문제를 해결하고 더 빠른 해결책을 얻을 수 있습니다.

iOS 15에서 App Store는 특히 두 개의 추가 알림을 생성하여 환불이 승인되었거나 거부되었는지 알 수 있습니다.

환불이 승인되면, 앱이 알림을 받고 서버는 App Store에서 환불 알림을 받습니다.

환불이 거부되면, 당신의 서버는 새로운 REFUND_DECLINED 알림을 받습니다.

이 기능을 사용하려면 고객이 iOS 15 이상을 사용해야 합니다.

모범 사례에 대해 논의해 봅시다.

원래 거래 ID를 저장하고 대부분의 환불 요청은 구매 후 30일 이내에 발생한다는 점에 유의하십시오.

고객이 좌절하고 환불을 요청하는 상황에서도 맞춤형 고객 경험을 제공하는 맞춤형 인앱 메시징을 제공할 수 있습니다.

고객에게 과거 구매에 대한 문맥 정보를 유연하게 표시할 수 있습니다.

고객이 환불할 거래를 선택하면, 고객이 Apple의 문제 보고에서 볼 수 있는 것과 일치하는 이유 코드 목록에서 선택할 수 있는 환불 요청 시트를 표시하는 API를 호출할 수 있습니다.

자동 갱신 구독의 경우, 성공적인 환불로 구독이 취소됨에 따라 앱 내에서 고객 참여를 유지하기 위한 보존 전략을 식별할 수 있습니다.

이제 beginRefundRequest를 살펴보았으니, 그 후에 일어나는 일과 당신이 어떻게 더 많이 참여할 수 있는지에 대해 이야기해 봅시다.

App Store는 환불을 요청하기 전에 품목을 소비했는지 여부와 같은 고객의 소모성 인앱 구매에 대한 소비 정보를 Apple에 전송하여 환불 프로세스를 알리고 개선할 수 있는 기회를 제공하는 새로운 서버 API를 도입했습니다.

높은 수준에서, 각 환불 요청은 결정을 내리기 위해 우리의 환불 결정 시스템을 통과할 것이다.

환불 결정 시스템에는 문제의 거래에 대한 정보와 고객의 구매 및 환불 내역과 같은 기타 요인이 포함되어 있습니다.

Apple이 결정을 내리기 전에, App Store는 서버에 CONSUMPTION_REQUEST 알림을 보낼 것입니다.

당신의 서버는 이 알림에 대한 응답으로 소비 데이터를 App Store로 다시 보내며, 이는 환불 결정에 영향을 미칠 수 있습니다.

소비 페이로드는 소수의 분야로 구성되어 있으며 저는 오늘 세 가지 주요 분야에 대해 논의하고 싶습니다.

소비를 사용하면 인앱 구매가 완전히, 부분적으로 또는 전혀 소비되지 않았는지 쉽게 알 수 있습니다.

예를 들어, 앱에 물물교환이 있는 교환 플랫폼이 있거나 한 계정에서 다른 계정으로 전송된 인앱이 있는 경우, 소비된 것으로 간주됩니다.

콘텐츠를 전달하면 중단이 발생했거나 인앱 구매를 제공하지 못할 수 있으며 고객에게 환불하고 싶을 수 있습니다.

이제 배송되지 않은 물품을 제공할 수 있습니다.

StoreKit 2에서 출시된 appAccountToken을 사용하면 구매를 시작하고 구매를 위한 콘텐츠를 소비하는 앱의 사용자 계정과 관련된 표준 UUID 형식을 사용하고 있으며, 이는 리셀러를 식별하는 데 도움이 될 수 있습니다.

모범 사례를 위해, 대부분의 환불 요청은 30일 이내에 발생하므로 그에 따라 거래에 대한 소비 데이터를 저장하십시오.

Apple이 데이터를 요청하는 거래를 찾을 수 있도록 각 소모품 인앱 구매에 대한 original_transaction_ID를 저장하세요.

Apple이 결정을 위해 귀하의 데이터를 통합할 수 있도록, 소비 요청 알림을 받은 후 12시간 이내에 응답하십시오.

초기 요청 후 변경된 사항이 있으면 12시간 이내에 업데이트된 페이로드를 자유롭게 보내주세요.

요청된 소비 데이터를 App Store로 보내기 전에 고객의 동의를 받았는지 확인하세요.

그리고 마지막으로, 소비 페이로드 내에서 모든 필드는 필수가 아니며, 신고되지 않은 것으로 표시할 수 있는 Apple 문서를 검토하십시오.

오늘의 세션을 요약하자면, 저는 주요 조치의 체크리스트를 제공하고 싶습니다.

이러한 기능을 채택하고 구현하는 다음 단계를 위해, App Store Connect에 URL을 입력하고 샌드박스에서 버전 2를 활성화하여 서버가 App Store 서버 알림을 받을 수 있도록 구성하고 활성화할 수 있습니다.

고객 지원 도구의 경우, 전화, 이메일, 웹 또는 인앱 지원 등 기존 지원 채널에 통합하십시오.

앱의 경우, 새로운 beginRefundRequest, isEligibleforIntroOffer 및 showManageSubcriptions API를 지원하는 데 필요한 StoreKit 2로 iOS 15의 클라이언트 변경 사항을 식별하십시오.

마지막으로, 샌드박스 테스트 업데이트를 활용하여 매장 변경, 구매 내역 지우기, 환불 테스트 및 구독 갱신율 조정과 같은 샌드박스 Apple ID를 최대한 활용하십시오.

이것으로 프레젠테이션을 마칩니다. 오늘 우리와 함께 StoreKit 2 및 App Store Server API로 고객을 지원하는 방법에 대해 자세히 알아봐 주셔서 감사합니다.