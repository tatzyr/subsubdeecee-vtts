603

이 프레젠테이션에서 우리는 GPU가 효율적으로 조작할 수 있는 타일 메모리의 이미지 데이터를 설명할 수 있는 이미지 블록에 초점을 맞출 것입니다.

이미지 블록은 타일 메모리에 있는 이미지 데이터에 대한 최적화된 액세스를 제공합니다.

그리고 A11 GPU를 사용하면, 우리는 당신에게 그것을 직접 제어할 수 있습니다.

애플리케이션에 의미가 있는 방식으로 픽셀을 배치할 수 있을 뿐만 아니라, 데이터를 명시적으로 이동할 수 있습니다.

이미지 블록은 조각 처리와 새로운 타일 셰이딩 단계와 깊이 통합되어 있다.

그들은 또한 전통적인 컴퓨팅에 사용할 수 있다.

어느 단계에 있든, 이미지 블록은 2D 데이터 그리드에 대한 액세스를 최적화하기 때문에 이미지를 나타내는 데 권장됩니다.

이미지 블록은 이 프레젠테이션 시리즈에서 논의할 몇 가지 다른 기능의 핵심 구성 요소입니다.

이미지 블록을 더 정확하게 정의하는 것으로 시작합시다.

이미지블록은 타일 메모리의 2D 데이터 구조이다.

그것은 너비, 높이, 그리고 픽셀 깊이를 가지고 있다.

조각 기능은 그 위치에 해당하는 단일 픽셀에만 접근할 수 있다.

반면에, 컴퓨팅 커널은 전체 이미지 블록에 접근할 수 있다.

각 픽셀은 여러 구성 요소로 구성된 매우 복잡할 수 있으며, 각 구성 요소는 자체 이미지 평면으로 처리될 수 있다.

이를 통해 인접한 구성 요소를 장치 메모리의 하나 이상의 텍스처에 대량 작업으로 효율적으로 저장할 수 있습니다.

이미지 블록은 또한 GPU의 포맷 변환 하드웨어에 대한 대량 액세스를 제공한다.

부동 소수점 픽셀은 장치 메모리에 저장될 때 대상 텍스처 형식으로 변환됩니다.

이제 타일 메모리에서 이미지 데이터 이동을 가속화하는 이미지 블록을 사용하는 것의 이점 중 하나를 자세히 살펴봅시다.

이미지 블록 이전에, 당신은 아마도 한 번에 한 픽셀씩 작동하기 전에 텍스처의 일부를 스레드 그룹 메모리로 옮겼을 것입니다.

하지만 GPU는 당신이 이미지 데이터에서 작동하고 있다는 것을 이해하지 못했기 때문에, 한 번에 한 픽셀씩 그 픽셀을 장치 메모리 텍스처에 다시 저장해야 했습니다.

이미지 블록을 사용하면 단일 작업을 사용하여 이미지 데이터를 저장할 수 있으며, 이는 훨씬 더 효율적입니다.

이제 금속에 대한 이미지 블록 속성을 설명하는 방법을 알아봅시다.

컴퓨팅 패스에서, 여기에 표시된 API를 사용하여 이미지 블록의 너비와 높이를 설명합니다.

치수는 각 파견마다 다를 수 있다.

이미지 블록의 픽셀 깊이는 셰이딩 언어로 구조로 설명된다.

전체 이미지 블록은 유형이 해당 구조체에 의해 템플릿화된 인수로 사용할 수 있습니다.

셰이딩 언어 구문을 자세히 살펴봅시다.

이 예에서, 우리는 각각 다양한 수의 구성 요소를 가진 세 가지 요소로 구성된 픽셀을 설명하고 있다.

이미지 블록은 커널에서 인수로 사용할 수 있다.

커널은 위치를 인수로 사용하고 threadgroup_imageblock이라는 새로운 주소 공간에 대한 포인터를 반환하는 데이터 메서드를 사용하여 참조하여 이미지 블록 내의 모든 위치에 액세스합니다.

특정 위치에 대한 참조로, 우리는 그 위치의 요소를 읽고 쓸 수 있다.

나는 앞서 이미지 블록이 장치 메모리 텍스처에 효율적으로 저장할 수 있는 평면에 배치된다고 언급했다.

셰이딩 언어에서, 우리는 함께 저장할 수 있는 인접한 평면을 슬라이스라고 부른다.

커널의 예를 살펴봅시다.

이 예에서, 우리는 소스 텍스처를 이미지 블록에 로드하고, 해당 블록에서 일부 이미지 처리를 수행했으며, 색상 요소를 대상 텍스처에 저장할 준비가 되었습니다.

쓰기를 수행하기 위해 스레드 그룹의 스레드가 하나만 필요하므로, 모든 스레드가 이미지 블록 처리를 완료했는지 확인하기 위해 먼저 장벽을 만들어야 합니다.

메탈은 장벽에 대한 새로운 메모리 대상을 추가하여 이미지 블록에 쓰기가 완료될 때까지 기다리기만 하면 된다고 선언합니다.

그런 다음 슬라이스 방법을 사용하여 이미지 블록에서 원하는 슬라이스를 얻습니다.

슬라이스 방법은 슬라이스의 일부인 모든 픽셀 요소를 참조합니다.

마지막으로, 우리는 목적지 텍스처에 슬라이스를 씁니다.

각 이미지 블록은 아마도 텍스처의 영역만 나타내므로, 이미지 블록을 쓸 텍스처 오프셋을 지정합니다.

이제 프래그먼트 함수의 이미지 블록이 어떻게 지정되는지 봅시다.

컴퓨팅 패스의 이미지 블록과 달리, 렌더링 패스의 이미지 블록 치수는 전체 패스에 대해 일정하며 여기에 표시된 속성을 사용하여 설정됩니다.

이미지블록 픽셀 깊이는 내가 이미 커널에 대해 보여준 것처럼 셰이딩 언어에서 구조체로 선언될 수 있다.

그러나 조각 함수는 또한 렌더링 패스 첨부 파일을 사용하여 픽셀 깊이를 선언하는 것을 지원합니다.

구문을 살펴봅시다.

이 예에서, 우리는 셰이딩 언어로 픽셀 구조를 명시적으로 선언했습니다.

프래그먼트 함수는 이미지블록 내의 암시적 위치에만 접근할 수 있기 때문에, 인수 유형은 구조체 자체이지만 imageblock_data 속성으로 태그가 지정됩니다.

우리는 또한 동일한 속성으로 반환 값을 태그해야 합니다.

그렇게 하면 금속이 올바른 접근 지침을 생성할 수 있다.

이제 전통적인 렌더링 패스 첨부 파일을 사용하여 픽셀 구조를 선언할 때 이 동일한 예가 어떻게 생겼는지 봅시다.

이 양식은 당신이 이미 알고 있는 구문과 동일합니다.

사실, 타일 메모리는 항상 A-시리즈 GPU의 핵심 측면이었기 때문에 렌더링 패스에서 항상 이미지 블록을 사용해 왔습니다.

새로운 점은 Metal 2가 이제 타일 메모리에 일반적으로 접근할 수 있게 해준다는 것이다.

이 양식은 렌더링 패스에 첨부된 텍스처에서 파생된 기본 이미지 블록 저장 형식을 추상화합니다.

텍스처 저장 유형에 관계없이, 데이터는 조각 함수에서 부동 소수점 또는 정수로 표시됩니다.

A11과 이전 아키텍처의 또 다른 차이점은 암시적 이미지 블록 형식 변환이 발생하는 곳이다.

A7에서 A10 GPU까지, 저장 형식은 타일 메모리의 부동 소수점으로 확장되었다.

이것이 Metal이 모든 픽셀 형식에 대해 두 가지 크기를 문서화하는 이유입니다: 하나는 장치 메모리에 저장될 때, 다른 하나는 타일 메모리에 렌더링 패스 첨부 파일로 저장될 때입니다.

A11에서 형식 변환은 각 로드에서 발생하며 타일 메모리에서 셰이더 코어의 임시 레지스터로 저장됩니다.

그렇게 하면 타일 메모리를 더 많이 사용할 수 있습니다.

이제 픽셀 구조를 선언하는 방법을 선택할 수 있으므로, 결정하는 데 도움이 될 수 있는 모범 사례를 검토해 봅시다.

암시적 이미지 블록은 프래그먼트 기능이 기본 저장 형식을 추상화하기 때문에 여러 렌더링 패스 첨부 레이아웃을 지원해야 할 때 좋습니다.

암시적 이미지 블록은 구조가 API에 의해 알려져 있기 때문에 로드 및 저장 작업과도 호환됩니다.

반면에 명시적인 이미지 블록은 더 복잡한 픽셀 구조를 표현할 수 있게 해준다.

명시적인 이미지 블록은 또한 메인 메모리 백업이 필요하지 않으므로, 렌더링 패스의 범위 내에서 완전히 생성되고 소비되는 임시 데이터에 매우 적합합니다.

이제 복잡한 픽셀 구조가 무엇을 의미하는지 자세히 살펴봅시다.

이 예에서, 우리는 나중에 더 정확한 투명도 효과를 위해 정렬하고 합성할 수 있도록 여러 반투명 색상과 픽셀당 깊이를 저장할 것입니다.

우리는 단일 조각 선언으로 시작하고, 배열을 선언한 다음, 셰이더로 전달할 수 있는 최상위 구조체에 중첩합니다.

렌더링 패스 첨부 파일을 사용하여 이 구조를 표현하는 것은 어색하고 저자의 의도를 모호하게 할 것이다.

물론, 금속을 사용하면 작업에 적합한 도구를 선택할 수 있기 때문에 암시적 형태와 명시적 형태 중에서 선택할 필요가 없습니다.

또한 믹싱을 사용하면 이미지 블록을 코드 베이스에 점진적으로 채택하고 명시적인 형태의 혜택을 받는 기존 셰이더에 새로운 기능을 쉽게 통합할 수 있습니다.

두 양식을 함께 사용하는 것은 쉽습니다, 두 개의 이미지 블록 인수를 제공하기만 하면 됩니다.

예를 들어 봅시다.

보시다시피, 우리는 입력과 출력으로 두 개의 이미지 블록을 제공할 수 있습니다.

색상과 imageblock_data 속성은 어떤 슬라이스가 렌더링 패스 첨부 파일에서 파생되고 어떤 슬라이스가 파생되지 않는지 금속에 명확하게 해준다.

각 함수에 대해 입력과 출력당 최대 두 개의 이미지 블록을 선언할 수 있습니다.

명시적인 이미지 블록을 사용하면 포장된 유형을 사용하여 픽셀 레이아웃을 정확하게 제어할 수 있습니다.

메탈 셰이딩 언어는 이미 전통적으로 정점과 일정한 데이터 레이아웃을 설명한 부동 소수점 벡터 유형을 제공한다.

하지만 이제 우리는 암시적 이미지 블록과 텍스처 픽셀 형식을 사용하여 이전에 설명될 수 있었던 것과 일치하는 포장된 유형이 필요합니다.

메탈 2는 음영 언어에 그러한 유형을 추가한다.

이러한 형식은 앞서 논의한 로드/저장 하드웨어를 사용하여 부동 소수점으로 변환됩니다.

게다가 이 새로운 포장된 형식은 정점과 일정한 데이터 레이아웃을 설명하는 데에도 사용될 수 있다는 것이다.

셰이딩 언어로 이러한 새로운 유형을 어떻게 선언하는지 살펴봅시다.

이 예에서 우리는 이미지 블록과 정점 데이터를 모두 설명하는 데 사용되는 몇 가지 새로운 포장 유형을 볼 수 있습니다.

이러한 유형은 셰이더 코어 내에서 사용되는 저장 형식과 압축 해제 형식을 모두 선언해야 합니다.

이제 추가된 모든 새로운 포장된 데이터 유형을 살펴봅시다.

보시다시피, 메탈 셰이딩 언어는 하나, 둘, 네 개의 구성 요소 정규화 유형을 추가하며, 각각 8비트 또는 16비트 구성 요소를 지원합니다.

우리는 또한 서명된 변형과 서명되지 않은 변형뿐만 아니라 10a2, 미니 플로트, 공유 지수 및 sRGB와 같은 보다 전문화된 32비트 형식에 대한 지원을 추가했습니다.

마지막으로, Xcode의 GPU 디버거는 이미지 블록의 시각화와 검사를 직접 지원합니다.

각 조각은 마치 질감인 것처럼 검사할 수 있다.

여기서 우리는 상단에서 샘플 코드의 G-Buffer 레이아웃 예시를 볼 수 있습니다.

그리고 하단에는 Xcode의 GPU 디버거에 동일한 이미지 블록 쇼가 있습니다.

바인딩된 리소스 보기의 타일 섹션은 이미지 블록 슬라이스를 텍스처 세트로 보여줍니다.

여기에서 다른 질감과 마찬가지로 각 조각을 검사할 수 있습니다.

이 프레젠테이션에서, 우리는 이미지 블록을 통해 타일 메모리에서 장치 메모리로 여러 픽셀을 효율적으로 이동하고 타일 메모리의 이미지 데이터 레이아웃을 정확하게 제어하여 저장 밀도를 개선하는 방법을 보았습니다.

우리는 또한 이미지 블록과 다른 주소 공간 모두에서 A11 GPU의 새로운 팩/팩 해제 하드웨어를 어떻게 활용할 수 있는지 보았습니다.

Metal 2에 대한 자세한 정보와 샘플 코드에 대한 링크는 개발자 웹사이트(developer.apple.com/metal)를 방문하십시오.

봐줘서 고마워!