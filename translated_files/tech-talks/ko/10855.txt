10855

안녕하세요, 저는 패트릭이고, 저는 애플의 공연 팀에서 일하고 있습니다.

오늘 우리는 앱의 스크롤과 애니메이션 히치에 대해 논의하고 렌더링 루프를 자세히 살펴볼 것입니다.

먼저, 우리는 무엇이 히치인지에 대한 일반적인 감각을 얻을 것이다.

그런 다음 우리는 렌더 루프와 발생할 수 있는 다양한 유형의 차질에 대해 논의할 것입니다.

마지막으로, 우리는 히치를 측정하는 방법에 대해 논의할 것이다.

그래서 먼저, 히치가 뭐야?

앱에서, 사람은 화면을 가로질러 손가락을 드래그하여 스크롤할 수 있습니다.

그들은 버튼을 누르고 계층 구조에서 보기 간의 피드백이나 전환을 기대할 수 있다.

이 애니메이션은 사람과 화면의 콘텐츠 사이의 시각적 연결 감각을 구축한다.

애니메이션 히치는 애니메이션에서 점프를 일으키고 그 연결을 끊을 수 있으며, 기쁨 대신 혼란을 일으킬 수 있다.

히치는 프레임이 예상보다 늦게 화면에 나타날 때마다이다.

컬렉션 뷰를 스크롤하는 일반적인 예를 살펴봅시다.

여기 우리가 가장 좋아하는 레시피를 큐레이팅하는 데 도움이 되는 식사 플래너 앱이 있습니다.

사용자가 손가락을 화면 위로 드래그하면, 스크롤 보기는 콘텐츠를 위로 이동하여 반응합니다.

하지만 스크롤하는 동안, 우리는 콘텐츠의 점프를 알아차린다.

이 프레임을 프레임별로 보면, 처음 세 프레임의 내용과 함께 손가락이 움직이는 것을 볼 수 있지만, 다음 프레임에서는 내용이 멈추는 것처럼 보입니다.

그것은 세 번째 프레임이 실제로 반복되어 다른 프레임을 위해 디스플레이에 남아 있기 때문이다.

마침내 네 번째 프레임이 오고, 우리의 손가락이 있는 곳으로 앞으로 점프하는 것처럼 보인다.

네 번째 프레임이 늦게 도착했기 때문에 세 번째 프레임이 반복되었고, 사용자는 차질을 보았다.

렌더 루프가 프레임을 제시간에 끝내지 못할 때 히치가 발생합니다.

그럼 렌더 루프를 살펴봅시다.

렌더링 루프는 터치 이벤트가 앱에 전달되고 UI에 대한 변경 사항이 프레임이 마무리되는 운영 체제로 전송되는 지속적인 프로세스입니다.

그것은 루프이며, 장치의 재생률에서 발생합니다.

iPhone과 iPad에서, 이것은 초당 60프레임이며, 이는 16.67밀리초마다 새로운 프레임을 표시할 수 있음을 의미합니다.

iPad Pro에서, 이것은 초당 120프레임이며, 이는 8.33밀리초마다 새로운 프레임을 표시할 수 있다는 것을 의미합니다.

프레임의 시작 부분에서, 하드웨어는 VSYNC라고 불리는 이벤트를 방출한다.

VSYNC는 새 프레임이 준비되어야 할 때를 나타낸다.

우리는 디스플레이 트랙에서 그것들을 강조하므로, 마감일을 쉽게 볼 수 있습니다.

렌더링 루프는 VSYNC에 맞춰져 있다.

프레임을 준비하려면 도중에 검문소에 도달해야 한다.

그것은 세 단계로 나뉘어져 있다.

첫 번째 단계는 이벤트가 처리되고 UI가 변경되는 앱에 있습니다.

그 작업은 다음 VSYNC 전에 완료되어야 하므로, 다음 단계를 시작할 수 있습니다.

다음 단계는 렌더링 서버라고 불리는 별도의 프로세스에서 일어난다.

여기가 당신의 UI가 실제로 렌더링되는 곳입니다.

이 단계는 또한 세 번째이자 마지막 단계인 프레임을 표시할 수 있도록 다음 VSYNC 전에 완료되어야 합니다.

3단계 프로세스에 대한 중요한 주의 사항은 프레임이 전시되기 전에 두 프레임으로 처리된다는 것이다.

우리는 이것을 이중 버퍼링이라고 부르지만, 다른 모드가 있다.

히치를 피하기 위해, 시스템은 렌더링 서버에 작업을 완료하기 위해 한 번의 추가 프레임 시간이 주어지는 트리플 버퍼링으로 전환할 수 있습니다.

이것은 대체 모드이기 때문에, 우리는 렌더링 루프의 히치에 대해 이야기하면서 이중 버퍼링에 집중할 것입니다.

전반적으로, 전체 렌더링 루프는 다섯 단계로 구성되어 있다.

루프는 첫 번째 단계인 이벤트 단계로 시작됩니다.

여기서 당신의 앱은 터치 이벤트를 처리하고 UI에서 변경이 필요한지 결정합니다.

다음은 커밋 단계입니다.

커밋 단계에서, 앱은 UI를 업데이트하고 렌더링을 위해 렌더링 서버에 제출합니다.

다음 VSYNC에서, 렌더링 서버는 그 제출을 받고, 렌더링 준비 단계에서 GPU에서 그리기 위해 준비합니다.

렌더링 실행 단계에서 GPU는 UI를 최종 이미지로 그리므로 다음 VSYNC에서 프레임을 사용자에게 표시할 수 있습니다.

각 단계는 모든 프레임, 심지어 렌더링 작업에서도 원활한 사용자 경험을 제공하는 데 매우 중요합니다.

별도의 프로세스에서 발생하지만, 앱을 대신하여 작동하므로 레이어 트리를 제 시간에 처리하고 그릴 수 있도록 하는 것은 당신에게 달려 있습니다.

이것을 조금 더 이해하기 위해, 예를 살펴봅시다.

이 예에서, 우리는 그 과정에서 각 단계를 보기 위해 렌더링 루프를 통해 이 프레임을 따라갈 것이다.

첫 번째는 앱이 이벤트를 받을 이벤트 단계입니다.

이러한 이벤트는 터치, 네트워킹 콜백, 키보드 프레스 및 타이머와 같은 것들입니다.

앱은 레이어 계층 구조를 변경하여 어떤 식으로든 이러한 이벤트에 대응할 수 있습니다.

예를 들어, 앱은 레이어의 배경색을 변경하거나 레이어의 크기와 위치를 변경할 수도 있습니다.

하지만 앱이 레이어의 경계를 업데이트할 때, 코어 애니메이션은 또한 setNeedsLayout을 호출합니다.

이것은 응답으로 레이아웃을 다시 계산해야 하는 모든 레이어를 식별합니다.

그 시스템은 이러한 "필요한 레이아웃" 요청을 통합하고 커밋 단계에서 중복 작업을 줄이기 위해 순서대로 수행할 것이다.

레이아웃이 필요한 경우, 이벤트 단계가 끝나면 커밋 단계가 자동으로 시작됩니다.

첫째, 시스템은 레이아웃이 필요한 모든 레이어를 가져와 부모에서 자녀까지 한 번에 하나씩 배치합니다.

레이아웃은 일반적인 성능 병목 현상이므로, 앱이 이 작업을 완료하는 데 몇 밀리초밖에 걸리지 않는다는 것을 명심하세요.

일부 보기는 라벨, 이미지 보기 또는 drawRect를 재정의하는 보기와 같은 사용자 지정 그리기가 필요합니다.

이러한 보기에 시각적 업데이트가 필요한 경우, setNeedsDisplay를 호출해야 합니다.

레이아웃과 마찬가지로, 시스템은 모든 레이아웃이 완료되면 이러한 요청을 병합하여 수행할 것이다.

그리기 과정에서, 모든 사용자 지정 그리기 레이어는 그들이 그릴 텍스처 기반 코어 그래픽 컨텍스트를 받게 될 것이다.

코어 애니메이션에 관한 한, 이 레이어들은 이제 이미지일 뿐이다.

그리고 이제 모든 레이어가 배치되고 그려졌으므로, 변경된 전체 레이어 트리가 수집되어 렌더링을 위해 렌더링 서버로 전송됩니다.

이제 우리는 레이어 트리를 실제 표시 가능한 이미지로 바꾸는 것을 담당하는 렌더링 서버에 있습니다.

준비 단계에서 렌더링 서버는 앱의 레이어 트리를 반복하고 GPU가 실행할 수 있는 선형 파이프라인을 준비합니다.

최상층에서 시작하여, 그것은 부모에서 자녀로, 형제자매에서 형제자매로 작동하여 레이어가 뒤에서 앞으로 배열되도록 한다.

다음으로, 이 선형 파이프라인은 GPU를 통과하여 각 레이어가 최종 텍스처로 합성됩니다.

일부 레이어는 렌더링하는 데 더 오래 걸릴 수 있으며, 이것은 우리가 곧 논의할 또 다른 일반적인 성능 병목 현상이다.

좋아.

따라서 GPU가 오른쪽의 이미지를 실행하고 렌더링하면, 다음 VSYNC에 표시할 준비가 됩니다.

렌더 루프의 각 단계는 성능에 민감하며 마감일이 있다.

마감일은 다음 VSYNC입니다.

목표 프레임 속도를 달성하고 낮은 입력 대기 시간을 유지하기 위해, 이 전체 프로세스는 실제로 모든 프레임에서 병렬로 일어나고 있다.

이렇게 하면 파이프라인이 동시에 되고, 시스템이 이전 프레임을 렌더링하는 동안 앱이 새 프레임을 준비할 수 있습니다.

이것이 마감일을 놓치는 것이 중요한 이유이다.

이제 렌더 루프가 어떻게 작동하는지 보였으니, 앱에서 어떤 유형의 히치를 볼 수 있는지 알아봅시다.

두 가지 주요 유형이 있습니다: 앱의 프로세스 내에서 발생하는 커밋 히치와 렌더링 서버에서 발생하는 렌더링 히치.

커밋 히치는 앱이 이벤트를 처리하거나 커밋하는 데 너무 오래 걸리는 경우입니다.

여기서, 커밋이 너무 오래 걸리고 마감일을 놓치므로, 다음 VSYNC에서 렌더링 서버는 처리할 것이 없으며 이제 다음 VSYNC가 렌더링을 시작할 때까지 기다려야 합니다.

그리고 이제 우리는 프레임 배달 시간을 한 프레임으로 지연시켰다.

밀리초 단위로, 그것은 아이폰이나 아이패드에서 16.67밀리초이다.

우리는 이 지연 기간을 "히치 시간"이라고 부르며, 밀리초 단위로 측정합니다.

커밋 작업이 더 오래 걸리고 다음 VSYNC를 지나갔다면, 프레임은 두 프레임 또는 33.34밀리초로 늦을 것이다.

그것은 사용자가 부드러운 스크롤을 볼 수 없는 33.34밀리초이다.

커밋 히치와 앱에서 문제를 해결하는 방법에 대해 자세히 이해하려면, "커밋 단계에서 히치 찾기 및 수정"을 확인하세요.

두 번째 유형의 히치는 렌더링 히치이다.

이것은 렌더링 서버가 제 시간에 레이어 트리를 준비하거나 실행할 수 없을 때 발생합니다.

여기서, 렌더링 실행 단계는 너무 오래 걸리고 VSYNC 경계를 넘어선다.

따라서 프레임은 제 시간에 준비되지 않았고, 녹색 프레임은 예상보다 한 프레임 늦게 표시되었다.

다시 한번, 우리는 16밀리초의 히치 타임을 가지고 있다.

렌더링 히치와 레이어 트리를 최적화하는 방법에 대해 자세히 이해하려면, "렌더 단계에서 히치 제거 및 제거"를 확인하세요.

좋아.

그래서 그것들은 두 가지 주요 유형의 히치이다.

이제 우리가 히치를 측정하고 정량화하는 방법에 초점을 맞추자.

우리는 이전 슬라이드에서 히치 타임을 보았다.

단일 히치에 대해 이야기할 때 매우 유용하지만, 스크롤, 애니메이션 또는 전환과 같은 장기적인 이벤트를 논의할 때 다루기 쉬울 수 있습니다.

첫째, 각 스크롤이나 애니메이션이 정확히 같은 시간이 걸리고, 따라서 정확히 같은 수의 프레임이 걸리지 않는 한 비교하기 어렵다.

더 나쁜 것은 iOS 기기가 항상 화면을 업데이트하지 않는다는 것이다.

렌더링 서버로 전송된 커밋이 없다면, 새 프레임이 제출되지 않습니다.

그것은 테스트와 장치에서 히치 시간을 비교하는 것을 더욱 어렵게 만든다.

그래서 대신에, 우리는 "히치 시간 비율"이라는 메트릭을 사용한다.

히치 시간 비율은 기간으로 나눈 간격의 총 히치 시간이다.

그것은 총 시간으로 정상화되었기 때문에, 우리는 그것을 경험 전반에 걸쳐 비교할 수 있다.

그것은 초당 히치 밀리초로 측정되므로, 장치가 매초마다 히치하는 밀리초의 양을 나타냅니다.

이 메트릭을 사용하여 자신의 앱 성능을 측정하는 방법에 대해 알아보려면, "MemetricKit의 새로운 기능"을 확인하세요.

테스트 스위트에서 히치 시간 비율을 추적하는 방법을 보려면, "XCTest로 애니메이션 히치 제거"를 확인하세요.

마지막으로, 히치 시간 비율을 사용할 수 있는 예를 살펴봅시다.

여기 우리는 아이폰에서 0.5초 분량의 작업인 30개의 프레임이 있다.

각 프레임은 마감일에 도달하고, 사용자는 충돌을 볼 수 없다.

히치 시간은 0이고, 히치 시간 비율도 0이다.

하지만 이제 우리는 분리된 간격이 있는 하단의 디스플레이 트랙을 본다.

일부 프레임은 다른 프레임보다 화면에 더 오래 있으며, 일부 커밋과 렌더링은 문제를 일으키고 있다.

우리가 이 히치 시간을 더하면, 우리는 100.02밀리초를 얻는다.

0.5초 이상, 우리는 초당 200.04밀리초의 히치 시간 비율을 가지고 있다.

이건 그냥 예시일 뿐이야.

일반적으로, 이것들은 우리가 여기 Apple의 도구에서 권장하고 사용하는 목표 히치 비율입니다.

이 목표는 초당 제로 히치 밀리초이지만, 초당 5 히치 밀리초 미만의 모든 것은 좋은 것으로 간주되며 사용자에 의해 대부분 눈에 띄지 않습니다.

초당 5~10 히치 밀리초 사이에서, 사용자는 약간의 중단을 알아차릴 것이며, 이것들은 조사되어야 한다.

초당 10밀리초 이상의 히치, 히치는 사용자 경험에 큰 영향을 미치고 있으며, 렌더링 루프를 최적화하는 방법을 즉시 조사해야 합니다.

요약하자면, 오늘 우리는 렌더 루프와 새 프레임이 사용자에게 표시되는 방법에 대해 논의했습니다.

우리는 히치가 무엇인지와 두 가지 유형, 커밋 히치와 렌더링 히치를 살펴보았다.

마지막으로, 우리는 주어진 기간 내에 사용자가 경험한 히치의 양을 측정하기 위해 히치 시간 비율을 정의했습니다.

히치의 유형과 앱에서 이를 포착하고 고치는 방법에 대해 자세히 알아보려면, 커밋 히치와 렌더링 히치에 대한 두 가지 회담을 확인하세요.

우리는 당신의 버터처럼 부드러운 앱을 빨리 보고 싶고, 봐주셔서 감사합니다.