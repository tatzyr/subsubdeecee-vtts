10874

사이먼 매닝: 안녕하세요, 저는 사이먼이고, CloudKit 팀의 엔지니어입니다.

오늘 저는 CloudKit을 사용하여 앱 사용자 간의 데이터 공유를 지원하는 방법을 시연할 것입니다.

GitHub에서 사용할 수 있는 공유 샘플 앱을 소개하는 것으로 시작하겠습니다.

그런 다음 공유를 만들고 다른 사용자가 앱에서 해당 공유에 참여하도록 초대하는 방법을 살펴보겠습니다.

앱이 참여 사용자를 대신하여 초대를 공유하고 수락하는 방법, 공유 레코드를 가져오는 방법, 앱이 맞춤형 공유 경험을 제공하는 방법, 그리고 마지막으로 CloudKit에서 사용할 수 있는 영역 기반 공유 모델에 대해 논의하겠습니다.

먼저, 공유 샘플 앱.

이미 잘 알고 계시겠지만, CloudKit은 애플리케이션이 iCloud의 데이터베이스에 액세스할 수 있도록 하는 프레임워크입니다.

이것은 여러 CKDatabase에 액세스할 수 있는 CKContainer로 API에 노출됩니다.

각 컨테이너에는 모든 사용자가 잠재적으로 레코드를 읽고 쓸 수 있는 하나의 공용 데이터베이스가 있습니다.

기기에 로그인한 iCloud 계정이 있는 경우, 앱은 해당 사용자의 데이터가 포함된 개인 데이터베이스에도 액세스할 수 있습니다.

그리고 앱이 공유를 지원하는 경우, 현재 iCloud 사용자와 공유되는 데이터는 공유 CKDatabase의 앱에서 사용할 수 있습니다.

기록 소유 사용자로부터 공유를 시작하고 참가자로서 공유에 대한 초대를 수락하는 것을 보여주기 위해, 저는 Apple GitHub 계정에서 사용할 수 있는 샘플 앱을 언급할 것입니다.

공유는 연락처 앱의 최소한의 예이다.

사용자의 개인 데이터베이스에서 새로운 연락처 레코드를 만들고, 앱의 다른 사용자와 개별 연락처를 공유하고, 다른 사용자의 현재 사용자와 공유된 모든 연락처를 표시하는 것을 지원합니다.

공유 저장소에는 Swift 동시성을 사용하는 구현과 별도의 브랜치에서 사용할 수 있는 완료 핸들러 기반 구현이 포함되어 있습니다.

공유를 시작하려면, 먼저 새 연락처 기록을 만들고 소유자의 개인 데이터베이스에 저장하세요.

addContact 기능은 공유의 새 연락처 추가 UI에 의해 호출됩니다.

연락처 유형 기록으로 새 CKRecord를 만들고 이름과 전화번호를 저장합니다.

그런 다음 기록은 개인 데이터베이스에 저장됩니다.

공유 앱의 다른 사용자와 연락처 기록을 공유하는 것은 공유를 만드는 것으로 시작됩니다.

CloudKit에서의 공유는 CKShare라고 불리는 특별한 종류의 레코드에 의존한다.

사용자가 다른 사람들과 기록을 공유하고 싶을 때, 그들을 대신하여 CKShare를 만들고 개인 데이터베이스에 저장하세요.

이 사용자는 공유되는 모든 레코드를 소유하고 있기 때문에, 공유 레코드 자체의 소유자이기도 합니다.

이 공유 기록은 어떤 데이터가 공유되고 있는지, 누구와 공유되고 있는지, 그리고 참가자를 공유할 수 있는 권한이 있는지에 대한 진실의 원천이다.

공유 권한은 공유 소유자가 공유 레코드에 대한 액세스를 제어할 수 있는 방법입니다.

publicPermission 속성은 공유 링크가 있는 모든 사용자의 권한 수준을 나타냅니다.

기본적으로, URL만 있는 사용자는 접근할 수 없습니다.

이 속성을 더 관대한 값으로 설정하면 공유 URL을 가진 모든 사용자가 참여할 수 있습니다.

초대된 각 참가자는 또한 주식 소유자가 결정한 허가 수준을 가지고 있다.

참가자 객체는 사용자의 신원과 초대 수락 상태를 포함하여 특정 사용자의 공유 참여를 설명합니다.

권한은 각 참가자 객체에 개별적으로 설정되며 각 참가자는 CKShare의 참가자 배열에 추가됩니다.

사용자의 개인 데이터베이스에서 레코드 공유를 시작하려면, 먼저 공유의 루트 레코드를 결정하십시오.

루트 레코드와 모든 자식 레코드는 이 공유에 포함될 것이다.

그런 다음, CKShare 레코드를 만들고 루트 레코드와 CKShare를 현재 사용자의 개인 데이터베이스에 저장하십시오.

공유에서, createShare 기능은 공유할 연락처 레코드로 CKShare를 초기화합니다.

CKShare와 루트 레코드는 소유자의 개인 데이터베이스에 저장되며, CKShare는 초대 프로세스를 시작하기 위해 UI로 반환됩니다.

CKShare와 루트 레코드는 모두 같은 작업에서 함께 저장되어야 합니다.

CKShare만 저장하면 루트 레코드가 이미 CloudKit에 존재하더라도 오류가 발생합니다.

루트 기록을 공유하는 것은 또한 자식 기록을 공유한다.

이제 앱이 공유를 만들고 있으므로, 공유에 참여하기 위해 사용자 초대장을 구성하고 보내는 방법을 다루겠습니다.

샘플 앱은 UICloudSharingController라는 UIKit에서 제공하는 뷰 컨트롤러를 사용합니다.

앱에서 이 컨트롤러를 구현하면 사용자가 참가자를 CKShare에 쉽게 초대하거나, 권한을 설정하거나, 참여를 보고 관리하거나, 레코드 공유를 모두 중단할 수 있습니다.

새로운 연락처 기록을 공유할 때 공유 샘플 앱에 UICloudSharingController가 나타나는 방법은 다음과 같습니다.

사용자는 공유 초대장을 보내는 방법을 선택할 수 있으며, 공유 옵션 섹션에서 권한을 구성할 수 있습니다.

공유에 대한 추가 정보를 제공하고 공유 이벤트 및 오류에 대한 알림을 받기 위해 컨트롤러의 위임 프로토콜을 구현하십시오.

여기에 설명된 방법 외에도, 공유 초대장에 표시할 항목 제목, 항목 유형 및 썸네일 이미지를 구성하는 방법이 있습니다.

이제 공유 소유자가 다른 사람들에게 초대장을 보냈으므로, 앱은 초대된 참가자를 대신하여 공유를 처리하고 수락해야 합니다.

앱의 Info.plist에서 CKSharingSupported 부울을 활성화하세요.

이를 통해 앱은 공유를 지원하며, 초대 URL을 처리하고 관련 대리 기능을 호출해야 합니다.

공유 초대가 열리고 수락되면, 앱은 위임 방법 콜백을 통해 CKShare.Metadata 객체를 받게 됩니다.

앱은 이 메타데이터를 사용하여 현재 사용자가 컨테이너의 수락 기능 또는 CKAcceptSharesOperation을 통해 이 공유를 수락하고 참여하고 있음을 CloudKit에 알립니다.

applicationDelegate 수명 주기를 통해 시스템은 앱을 실행하고 userDidAcceptCloudKitShareWith: shareMetadata 위임 방법을 호출합니다.

shareMetadata 객체에 제공된 식별자를 사용하여 CKContainer 객체를 초기화하세요.

그런 다음 CKContainer에서 수락을 호출하여 shareMetadata 객체를 전달하여 CloudKit에 현재 사용자가 공유를 수락했음을 알릴 수 있습니다.

이제 앱이 개인 기록을 공유하고 그 초대를 처리하고 수락하기 위한 초대장을 보내고 있으므로, 앱이 사용자가 참여하고 있는 공유 기록을 가져오고 수정할 수 있는 방법을 다루겠습니다.

현재 iCloud 사용자와 공유된 레코드는 앱 컨테이너의 sharedCloudDatabase 내에서 사용할 수 있습니다.

개인 및 공용 데이터베이스 내부의 데이터를 가져오기, 쿼리 및 조작하기 위한 동일한 CloudKit API를 공유 데이터베이스와 함께 사용할 수 있습니다.

샘플 앱에서 공유 레코드는 fetchSharedContacts 기능에서 가져옵니다.

그것은 recordZoneChanges 작업을 사용하여 점진적으로 변경 사항을 가져오고 처리합니다.

이 작업이 완료될 때마다, 가져오기에 더 많은 변경 사항이 있는지 여부를 나타내는 moreComing 부울 속성을 반환합니다.

그것은 또한 영역 역사의 특정 변화에 대한 포인터인 changeToken을 반환합니다.

이 changeToken을 사용하여 그 시점 이후에 발생하는 변경 사항만 가져올 수 있습니다.

첫 번째 가져오기 또는 영역 기록의 모든 변경 사항을 다시 가져오려면, changeToken을 nil로 설정하십시오.

활성 공유 관리는 현재 사용자에 따라 다릅니다.

공유 소유자의 경우, 소유자의 개인 데이터베이스에서 CKShare 레코드를 삭제하여 공유를 중지할 수 있습니다.

소유자는 또한 공유 루트 레코드를 완전히 삭제할 수 있다.

CKShare 레코드 객체의 removeParticipant 기능은 참가자 속성에서 찾을 수 있는 개별 참가자를 제거하는 방법을 제공합니다.

그리고 마지막으로, UICloudSharingController UI는 소유자가 모든 참가자와의 공유를 중단할 수 있게 해준다.

공유 참여 사용자의 경우, 사용자의 공유 데이터베이스에서 루트 CKRecord를 삭제하거나 UICloudSharingController UI를 사용하여 참여를 중지할 수 있습니다.

사용자의 공유 데이터베이스에서 루트 CKRecord를 삭제하면 공유 참여만 중단됩니다. 원래 루트 레코드는 여전히 소유자의 개인 데이터베이스에 존재합니다.

공유 샘플 앱은 UICloudSharingController를 사용하여 참가자 조회 및 초대를 처리하지만, CloudKit API로 이 기능을 구현하고 공유 소유자와 참가자 모두를 위한 사용자 지정 사용자 경험을 구축할 수도 있습니다.

먼저, CKShare에 초대할 참가자를 검색하려면 CKFetchShare ParticipantsOperation을 사용하거나 관련 CKContainer에서 참가자 기능을 공유하십시오.

전화번호, 이메일 및 사용자 기록 ID는 매개 변수로 지원됩니다.

다음으로, 이 참여에 대한 특정 권한 수준을 설정하고, addParticipant 기능으로 CKShare에 참가자를 추가하십시오.

항상 수정된 CKShare를 개인 데이터베이스에 다시 저장하세요.

저장된 CKShare 레코드에는 초대된 참가자에게 수락하고 처리할 수 있는 URL 속성이 있습니다.

초대 URL을 사용하여 공유의 CKShare.Metadata를 가져오고 앱 컨테이너의 accept(shareMetadata) 기능을 통해 참여를 확인할 수 있습니다.

공유 앱은 단일 레코드가 루트 레코드로 공유되고 해당 레코드의 자식도 공유되는 계층적 공유 모델로 CloudKit 공유를 보여줍니다.

iOS 15에 도입된 새로운 모델인 영역 공유를 통해 대신 전체 레코드 영역을 공유할 수 있습니다.

영역을 공유할 때, 단일 레코드의 계층 구조가 아니라 영역의 모든 레코드가 공유됩니다.

영역 공유는 레코드 영역의 모든 레코드에 영향을 미치기 때문에, 이러한 유형의 공유는 동일한 레코드 영역의 계층적 공유와 공존할 수 없습니다.

한 구역에서 하나 이상의 계층적 공유 또는 단일 구역 전체 공유를 가질 수 있습니다.

구역 공유와 계층적 공유는 각각 장점이 있으며, 둘 다 사용 사례에 따라 활용되어야 합니다.

공유 샘플 앱의 맥락에서, 연락처 그룹이 별도의 레코드 영역으로 구성된 경우 영역 공유가 유용할 수 있습니다.

영역 공유는 다른 사용자와 연락처 그룹을 공유하는 데 사용될 수 있다.

구역 공유에 대해 자세히 알아보려면, WWDC21의 "CloudKit의 새로운 기능"을 확인하세요.

새로운 영역 전체 공유를 만들려면, 공유할 사용자 지정 레코드 영역의 ID로 초기화하고 개인 데이터베이스에 저장하십시오.

공유 초대를 수락하고 공유 데이터베이스에서 레코드를 가져오는 과정은 이전과 동일합니다.

공유가 구역 전체 공유인지 확인하려면, recordID의 recordName 속성을 확인하세요.

값이 CKRecordNameZoneWideShare인 경우, 공유는 공유 레코드 영역을 관리하는 것입니다. 그렇지 않으면 공유 레코드 계층 구조를 관리하는 것입니다.

이제 앱에서 공유를 지원하는 방법을 알았으니, CKShare 레코드를 만들고 사용자가 다른 사람들과 협업할 수 있도록 하세요.

UICloudSharingController를 사용하여 공유 UI를 시작하거나 필요에 맞는 사용자 지정 구현을 구축하십시오.

친숙한 가져오기 및 수정 API를 사용하여 공유 클라우드 데이터베이스에서 공유 레코드에 액세스하십시오.

그리고 영역 공유를 구현함으로써 이익을 얻을 수 있는 앱에서 새로운 공유 사용 사례를 탐색하기 시작하세요.

봐줘서 고마워!