203

Apple Watch Series 3용 watchOS 4 앱을 업데이트하면 그 어느 때보다 쉽게 연결 상태를 유지할 수 있으며, 새로운 기압고도계를 활용할 수 있습니다.

Apple Watch는 모든 네트워킹을 위해 iPhone과의 연결에 의존하는 것으로 시작했다.

그러나, watchOS 2 이후, Apple Watch는 iPhone이 꺼져 있거나 범위를 벗어난 경우 Wi-Fi를 통해 통신할 수 있으며, iPhone이 이전에 연결한 Wi-Fi 핫스팟 범위에 있습니다.

이제 셀룰러 기능이 있는 Apple Watch Series 3를 사용하면 iPhone이 범위를 벗어나고 Wi-Fi를 사용할 수 없는 경우 앱이 셀룰러 연결을 통해 직접 통신할 수 있습니다.

앱은 어디에서나 데이터를 업데이트할 수 있을 뿐만 아니라, iPhone에서 받은 푸시 알림은 셀룰러 연결 상태일 때 Apple Watch로 자동으로 전달됩니다.

앱이 모든 연결 가능성에서 작동하도록 하기 위해, 이제 시계 앱에서 네트워킹 요청에 URLSession을 사용하는 것이 훨씬 더 중요합니다.

URLSession은 watchOS에서 네트워킹 연결을 만들고 관리하는 데 사용되는 클래스입니다.

시계 앱 코드의 URLSession을 사용하면 Apple Watch에서 직접 네트워크 요청을 시작할 수 있습니다.

iPhone이 Apple Watch 범위에 있을 때, 이러한 요청은 연결을 활용하기 위해 iPhone을 통해 무대 뒤에서 프록시됩니다.

그렇지 않으면, 요청은 Wi-Fi 핫스팟이나 셀 연결을 통해 직접 발생합니다.

Apple Watch가 셀룰러 연결에만 있는 동안 URLSession을 사용할 때, 세션은 시스템에 의해 약간 다르게 처리될 수 있다는 점에 유의하십시오.

다양한 유형의 세션과 당신이 기대할 수 있는 것을 살펴봅시다.

기본 및 임시 세션의 경우, 이러한 유형의 세션은 애플리케이션 상태가 활성화되었을 때 정상적으로 작동합니다.

공유 WKExtension 객체의 applicationState 속성을 사용하여 현재 애플리케이션 상태를 확인할 수 있습니다.

그러나, 이러한 유형의 세션은 애플리케이션 상태가 비활성 상태이거나 백그라운드인 경우 허용되지 않습니다.

앱이 현재 백그라운드 내비게이션 모드를 사용하는 경우 허용되기 때문에 한 가지 주의 사항이 있습니다.

다음으로, 배경 세션을 살펴봅시다.

백그라운드 세션의 경우, 더 작은 전송이 선호되며, 모든 전송은 시스템이 네트워크 요청을 할 수 있는 더 나은 기회가 있을 때까지 연기될 수 있습니다.

이것은 시스템 수준에서 결정되며 전력 수준, 연결 강도 및 다른 앱이 수행해야 하는 작업과 같은 많은 측면을 고려합니다.

백그라운드 세션의 경우, 요청이 이루어지고 응답이 반환되면, 앱이 frontmostapp 상태에 있는 경우, 앱이 즉시 깨어나 응답을 전달합니다.

가장 앞의 앱 상태 밖에서, 시스템은 그렇게 하기에 좋은 시기라고 결정하거나 애플리케이션 상태가 다시 활성화될 때 응답으로 앱을 깨울 것입니다.

이제 watchOS에서 네트워킹 코드를 최대한 활용할 수 있도록 몇 가지 모범 사례를 살펴봅시다.

첫 번째는 URLSessionConfiguration 객체에 새로운 waitsForConnectivity 속성을 사용하는 것입니다.

비배경 세션에서 이것을 true로 설정하면 시스템이 즉시 실패하는 대신 연결이 요청을 하기에 충분할 때까지 기다릴 수 있습니다.

연결이 언제 기다리고 있는지 알 수 있는 위임 방법이 있으므로, 상황을 처리할 수 있습니다.

우리는 즉각적인 것에 의존하지 않는 모든 요청에 이 속성을 사용하는 것을 권장합니다. 왜냐하면 연결이 가능한 한 즉시 해고될 것이기 때문입니다.

그렇지 않다면, 시스템은 연결이 재개될 때까지 요청을 기다릴 것이다.

이를 통해 접근성 코드에 집중하는 대신 앱을 훌륭하게 만드는 것에 집중할 수 있습니다.

WKExtensionDelegate 객체에서 applicationWillResignActive 메소드를 사용하면 네트워킹 요청이 진행 중일 때 애플리케이션 상태가 활성에서 비활성 또는 백그라운드로 변경될 때 발생하는 일을 최적화할 수 있습니다.

즉, 누군가가 당신의 앱을 사용하는 동안 손목을 내려놓을 때.

이 방법을 사용하면 기존 요청을 취소하거나 백그라운드 세션으로 다시 만들 수 있습니다.

마지막으로, 각 작업에 대한 세션을 만드는 대신 여러 작업에 공유 싱글톤 URLSession 객체를 사용하는 것이 가장 좋습니다.

많은 세션을 만들고 무효화하면 시스템에 불필요한 오버헤드가 발생하며, 공유 세션을 사용하거나 필요한 만큼 적게 사용하는 것이 가장 좋습니다.

시계 연결 프레임워크로 넘어갑시다.

Apple Watch가 연결성으로 더 독립적이 됨에 따라, Watch Connectivity를 사용하면 훌륭한 시계 앱 경험을 만드는 데 도움이 될 수 있는 곳을 식별하는 것이 중요합니다.

Apple Watch에서 앱을 처음 실행하려면 서비스를 인증하기 위해 토큰이 필요할 수 있습니다.

Watch Connectivity를 사용하는 것은 iPhone 앱에 이미 설정되어 있을 수 있는 이 정보를 전달하는 좋은 방법입니다.

앱이 운동을 위한 코칭 앱 또는 이와 유사한 것이라면, 누군가가 앱을 사용하기 시작하면 처음에는 더 큰 오디오 파일을 Apple Watch로 전송할 수 있습니다.

Watch Connectivity는 이러한 유형의 전송을 처리할 수 있으며, 앱 설치를 작게 유지하고 나중에 리소스로 앱을 보완하는 데 도움이 될 수 있습니다.

WCSession의 updateApplicationContext 메소드를 사용하면 iPhone이 시계 앱이 다음에 활성화할 때 액세스할 수 있는 데이터 사전을 통해 보낼 수 있습니다.

이것은 iPhone 앱이 새로운 데이터를 얻고 시계 앱이 아직 업데이트할 기회가 없었던 경우 새로운 데이터를 시계 앱으로 계속 흐르게 하는 좋은 방법입니다.

시계 앱이 실행되면, 최신 데이터에 대한 네트워크 요청을 시작하는 동안 이 새로운 데이터를 표시할 수 있습니다.

네트워크 요청으로 대체하는 능력을 구축하는 것은 매우 중요합니다.

Apple Watch가 더 독립적이기 때문에, 시계 앱이 iPhone의 최신 데이터를 가질 것이라는 보장이 줄어듭니다.

이제 누군가가 iPhone에서 떨어져 있을 때 운동 요약에 고도 상승 또는 하강을 추가할 수 있는 Apple Watch Series 3의 새로운 기압고도계에 주목합시다.

이것은 또한 HealthKit과 앱에 더 정확한 활성 에너지 연소 계산을 제공하는 데 도움이 됩니다.

코어 모션을 사용하면, 이제 앱이 업데이트를 받기 시작하는 곳에서 상대적인 고도 변화에 대한 정보를 받을 수 있습니다.

상대 고도 변화는 800미터의 고도에 서서 업데이트를 시작하고 고도에서 50미터 더 높게 이동하면 상대 고도 값이 50미터가 된다는 것을 의미합니다.

당신이 시작한 곳보다 80미터 낮게 움직이면, 상대 고도 값은 음의 80미터가 될 것입니다.

코어 모션에는 업데이트를 받는 데 사용할 CMAltimeter 클래스가 포함되어 있습니다.

CMAltimeter는 장치에 상대 고도 업데이트를 제공할 수 있는 기능이 있는지 확인하고 알려줄 수 있습니다.

코어 모션에게 상대 고도에 대해 더 묻기 전에 항상 이것을 먼저 확인해야 합니다.

watchOS 4에서 CMAltimeter는 이제 모션 및 피트니스 활동에 대한 인증 상태를 제공할 수 있습니다.

앱이 액세스할 수 있는 것에 따라, 승인이 거부되거나 제한되는 경우를 처리해야 할 수도 있습니다.

마지막으로, CMAltimeter는 상대 고도 업데이트를 시작하고 중지하는 기능을 제공합니다.

이러한 업데이트는 원시 센서 데이터에 적용하는 신호 필터링으로 인해 watchOS 4에서 2.5초 케이던스로 전달됩니다.

업데이트를 받으면, CMAltitudeData 객체를 전달하는 핸들러를 갖게 될 것입니다.

CMAltitudeData 객체는 해당 업데이트에 대한 상대적인 고도 변화 데이터를 제공합니다.

여기에는 다음과 같은 데이터가 포함됩니다: 첫 번째는 타임스탬프입니다.

이 객체는 시간 간격이며 참조 날짜 이후의 초 수로 주어진다.

이 값을 Date 객체로 변환하려면, Date 클래스에서 timeIntervalSinceReferenceDate 이니셜라이저 메소드를 쉽게 사용할 수 있습니다.

다음 재산은 상대적인 고도이다.

이것은 마지막으로 보고된 사건 이후의 고도 변화를 나타낸다.

이것은 상대적인 값이 될 것이므로, 장치가 고도가 낮거나 높아지면, 이 값은 특정 고도가 아닌 고도의 변화를 나타낼 것입니다.

이 값은 미터 단위로 주어진다.

마지막 재산은 압력이다.

온보드 고도계는 기압 고도계이기 때문에, 코어 모션은 상대 고도 변화와 함께 기록된 압력을 제공할 수 있습니다.

이 값은 킬로파스칼로 주어진다.

CMAltimeter를 사용하여 상대 고도 업데이트를 시작하는 방법과 장치 기능 및 인증 상태를 올바르게 확인하는 방법에 대한 예를 살펴보겠습니다.

이 beginAltitudeUpdates 메소드 이전에, 저는 Core Motion 프레임워크를 제 클래스로 가져오고 CMAltimeter 유형의 고도계라는 인스턴스 변수를 만들었습니다.

그것은 우리가 나중에 상대 고도 업데이트를 시작하고 멈추는 데 사용할 대상이다.

우리의 기능에서, 우리가 가장 먼저 해야 할 일은 장치에서 상대 고도를 사용할 수 있는지 확인하는 것입니다.

그렇지 않다면, 우리는 UI를 변경하여 그들이 앱을 사용할 때 이 데이터를 사용할 수 없다는 것을 알리고 싶을 수도 있습니다.

다음으로, 승인 상태가 거부되거나 제한되었는지 확인해야 합니다.

여기서, 우리는 승인 상태가 거부되거나 제한되지 않도록 하고 있습니다.

승인 상태가 승인된 경우 계속할 수 있으며, 승인 상태가 결정되지 않은 경우, 이전에 메시지가 표시되지 않은 경우 시스템에 액세스 메시지가 표시됩니다.

앱이 모션 및 피트니스 활동을 사용할 수 있도록 승인되면, 코어 모션에 상대 고도 업데이트를 시작하도록 요청할 수 있습니다.

이전에 생성된 CMAltimeter 객체에 대한 이 호출은 우리가 업데이트를 받고 싶은 작업 대기열을 통과할 뿐만 아니라 Core Motion이 새로운 데이터를 우리에게 전달할 때마다 실행할 핸들러를 제공합니다.

이 경우, 핸들러에서 UI를 업데이트할 것이기 때문에 작업 대기열을 기본 대기열로 설정했습니다.

핸들러로 이동하면, 우리가 관심 있는 값을 포함하는 CMAltitudeData 객체를 전달하거나, 업데이트에서 무언가 잘못되었을 경우 오류가 발생할 수 있습니다.

처리할 오류가 없는지 확인한 후, 우리는 단순히 CMAltitudeData 객체에서 relativeAltitude 값을 잡고, float 값을 저장하고, 그것을 사용하여 UI를 업데이트합니다.

앞서 언급했듯이, 우리는 타임스탬프나 압력 특성을 쉽게 사용할 수 있다.

더 이상 업데이트를 받을 필요가 없으면, Core Motion에 이전에 사용한 CMAltimeter 객체를 사용하여 상대 고도 업데이트를 중지하라고 말합니다.

그리고 그게 다야!

Apple Watch용 개발 및 URLSession 및 Core Motion 사용에 대한 자세한 내용은 다음 페이지의 리소스 링크를 참조하십시오.

고마워.