10858

A14 바이오닉의 금속 업데이트에 오신 것을 환영합니다.

제 이름은 아난드 푸베쿠루시이고, 애플의 GPU 소프트웨어에서 일합니다.

A14 바이오닉은 아이폰 12와 새로운 아이패드 에어의 핵심이다.

이 비디오에서, 제 동료 스와미와 저는 당신에게 A14 바이오닉의 GPU 기능과 그것이 가능하게 하는 새로운 금속 기능을 소개할 것입니다.

A14에는 CPU, GPU, 신경 엔진 및 iOS 경험을 구동하는 기타 사용자 지정 기술에 대한 큰 업데이트가 있습니다.

그것은 칩의 거의 모든 측면에서 새로운 기능, 향상된 성능 및 더 많은 전력 효율을 제공하는 획기적인 5나노미터 공정 기술을 사용합니다.

우리는 A14 바이오닉에 세계적 수준의 모바일 GPU를 구축했습니다.

그것은 가능한 가장 낮은 전력으로 최대의 지속 가능한 성능을 제공하기 위해 확장된 네 개의 코어를 가지고 있다.

이제, 메탈 측면에서, A14에는 메탈 앱의 성능을 향상시킬 몇 가지 구체적인 변화가 있습니다...

GPU 기반 파이프라인으로 시작하세요.

Metal의 간접 명령 버퍼를 사용하면 작업을 GPU로 옮기고 GPU 타임라인에서 명령을 인코딩할 수 있습니다.

이렇게 하면 앱에서 다른 작업을 수행할 수 있는 귀중한 CPU 시간을 확보할 수 있습니다.

A14 GPU 아키텍처는 그러한 사용 모델을 더 효율적으로 만든다.

다음으로, 우리는 병렬 컴퓨팅을 더 잘 지원하기 위해 GPU 스레드 그룹 메모리의 설계를 크게 개선했습니다.

우리는 스레드 그룹 범위 원자와 같은 동기화 프리미티브가 이러한 변화의 결과로 큰 성능 이점을 볼 것으로 기대합니다.

마지막으로, 메모리 대역폭을 보존하는 능력은 계속해서 우리 플랫폼의 중요한 설계 이점이다.

A14 GPU는 새로운 압축 하드웨어를 활용하여 앱에 더 많은 대역폭을 절약합니다.

프레임 버퍼 압축은 평균 15% 이상 개선될 것으로 예상되며 깊이 버퍼는 평균 40% 이상 개선되어야 합니다.

A14 GPU의 모든 새로운 기능은 Apple GPU 제품군 7이라는 새로운 금속 기능 세트에 속합니다.

여기 우리가 이 비디오에서 다룰 것이 있습니다.

먼저, 나는 무게중심 좌표와 원시 ID에 대해 이야기할 것이다.

또한 가시성 버퍼와 같은 지연 렌더링 기술을 구현하기 위해 이 두 기능을 함께 사용할 수 있는 방법을 보여드리겠습니다.

그 후, 나는 A14의 새로운 텍스처 주소 지정 모드를 빠르게 소개할 것이다.

우리는 또한 컴퓨팅을 하는 앱을 위한 새로운 기능을 가지고 있습니다.

이야기의 두 번째 섹션에서, 내 동료 Swami는 애플리케이션이 SIMD 그룹 범위에서 감소 작업을 수행할 수 있는 효율적인 방법을 제공하는 새로운 SIMD 감소 지침에 대해 이야기할 것이다.

그는 또한 A14의 금속에서 새로운 SIMD 매트릭스 곱셈 지침을 다룰 것이다.

이 새로운 지침은 기계 학습 및 이미지 컴퓨팅에 사용되는 대형 매트릭스 곱셈에 상당한 성능 향상을 제공합니다.

이것들 각각을 더 자세히 살펴봅시다...

무게 중심 좌표와 원시 ID로 시작합니다.

Apple GPU 제품군 7은 이제 바리센트릭 좌표와 기본 ID에 대한 액세스를 제공합니다.

무게중심 좌표는 원시적인 조각의 정확한 위치를 정의한다.

그리고 이제, 당신은 조각 셰이더에서 바로 이 좌표에 접근할 수 있습니다.

오른쪽 그림에서 볼 수 있듯이, P 지점에서 조각의 위치는 삼각형을 형성하는 정점의 가중치 합으로 정의되며, 여기서 가중치의 합은 1이다.

금속 음영 언어에서, 조각의 무게중심 좌표는 플로트의 벡터로 노출된다.

무게중심 좌표를 사용하여 이익을 얻을 수 있는 기술을 살펴봅시다.

절차적 생성은 알고리즘적으로 모델, 애니메이션 및 효과를 생성하는 데 사용되는 기술의 종류이다.

입자 시스템, 지형 또는 식물과 같은 원시인의 표면에 모든 종류의 절차적 효과를 즉석에서 할 수 있습니다.

사용자 지정 선을 그리는 것은 그러한 예 중 하나이다.

이를 위해 무게중심 좌표가 어떻게 사용될 수 있는지 살펴봅시다.

절차 생성을 사용하여 삼각형에 사용자 지정 고품질 안티앨리어싱 선과 테두리를 그리고 싶다고 가정해 봅시다.

이를 위해, 원시의 가장자리에서 조각의 거리에 흥미로운 수학적 함수를 적용할 수 있습니다.

본질적으로 당신의 조각의 바리센트릭 좌표는 가장자리로부터의 거리를 제공합니다.

위의 예는 즉각적인 효과를 생성하기 위해 프래그먼트 셰이더의 무게중심 좌표에 적용된 몇 가지 흥미로운 기능을 보여줍니다.

A14의 금속의 또 다른 새로운 특징은 원시 ID이다.

원시 ID는 입력 지오메트리에서 현재 조각이 어떤 원시에 해당하는지 알려줍니다.

오른쪽에, 삼각형에 나열된 ID는 조각 셰이더에서 해당 삼각형 내의 모든 조각에 대해 원시 ID를 가져올 때 반환됩니다.

이제 삼각형이 하드웨어에 의해 잘린다면, 자식 삼각형은 부모의 기본 ID를 상속한다.

그리고 테셀레이션이 있는 경우, 원시 ID는 단순히 패치 ID와 일치한다.

메탈 셰이딩 언어에서, 원시 ID는 부호 없는 정수이다.

원시 ID의 사용 사례를 살펴봅시다.

일시적인 안티앨리어싱은 프레임 사이의 움직임으로 인한 고스트와 반짝이는 아티팩트를 줄이는 기술이다.

이전 프레임의 픽셀 데이터를 축적하고 조각의 현재 렌더링 결과와 혼합하여 작동합니다.

원시 ID는 이전 프레임의 샘플을 검증하기 위해 일시적인 안티앨리어싱과 함께 사용할 수 있습니다.

그래서 당신은 실제로 이것을 실제로 어떻게 할 건가요?

먼저, 프래그먼트 셰이더에서 픽셀 기록을 가져오기 위해 이전 프레임의 결과를 다시 투사합니다.

그런 다음 데이터가 현재 프레임과 일치하는지 확인하기 위해 픽셀을 내성합니다.

이것은 두 샘플의 원시 ID를 비교함으로써 이루어질 수 있다.

ID가 일치하면, 이전 프레임에서 기여금을 축적하도록 선택할 수 있습니다.

픽셀 기록은 전후에 축적되거나 재설정되어 결과를 다음 프레임으로 전달할 수 있습니다.

이제 바리센트릭 좌표와 원시 ID를 도입했으니, 더 깊이 파고들자...

지연된 렌더링으로 시작하여, 당신이 이미 익숙할 가능성이 있는 기술입니다.

지연 렌더링은 고전적으로 두 단계로 작동한다.

G 버퍼라고 불리는 표면 속성 버퍼를 생성하는 첫 번째 단계와 G 버퍼를 소비하고 장면에 조명을 적용하는 두 번째 단계.

하지만 고해상도로 실행하거나 멀티 샘플링을 사용하는 경우, G 버퍼의 크기는 꽤 클 수 있으며, 이러한 버퍼를 읽고 쓰는 것은 엄청난 대역폭 비용을 초래할 수 있습니다.

이 문제를 해결하기 위해, G 버퍼는 최소한의 표면 속성 세트를 포함하는 얇은 버퍼로 대체될 수 있다.

이 버퍼는 가시성 버퍼라고 불린다.

가시성 버퍼는 이 단계의 출력을 크게 단순화하여 기하학 단계에서 작업을 최소화합니다.

G-버퍼에서 재료 특성을 생성하기 위해 지연 렌더링의 조각 셰이더에서 일반적으로 수행하는 모든 재료 논리는 이제 조명 단계로 이동합니다.

이렇게 함으로써, 우리는 더 이상 모든 재료 특성을 중간 버퍼에 저장할 필요가 없습니다.

재료 기능이 없으면 기하학 단계의 복잡성이 크게 감소하여 정점 셰이더와 프래그먼트 셰이더 사이의 높은 충전 속도와 최소 트래픽을 허용합니다.

이 기술은 가시성 버퍼 내부의 최소 데이터 세트에서 재료 입력을 재구성하기 위해 조명 통과 중에 새로운 재구성 단계를 추가합니다.

가시성 버퍼에 무엇이 포함될지 살펴봅시다.

가시성 버퍼는 기하학 재구성을 용이하게 하기 위해 두 가지 속성만 포함하면 됩니다.

기본 ID는 정점 버퍼에서 정점 데이터를 수동으로 검색하는 데 사용할 수 있으며, 효과적으로 지연된 정점 가져오기를 수행할 수 있습니다.

무게 중심 좌표는 현재 조각에 대한 정점 데이터를 보간하는 데 사용된다.

앞서 언급했듯이, A14의 프래그먼트 셰이더에서 이러한 속성에 액세스할 수 있습니다.

가시성 버퍼 파이프라인의 두 단계를 자세히 살펴봅시다.

높은 수준에서, 가시성 버퍼 접근 방식에는 두 단계가 있다: 가시성 버퍼를 생성하는 지오메트리 단계와 그것을 소비하는 조명 단계.

기하학 단계에서, 정점 셰이더의 변환은 래스터화에 필요한 위치만 생성합니다.

프래그먼트 단계는 추가 변화 없이 새로운 A14 메탈 셰이딩 언어 속성으로 원시 ID와 무게 중심 좌표를 생성할 수 있습니다.

조명 단계에서 새로운 재구성 단계는 기본 ID를 기반으로 지연된 정점 가져오기를 사용하고 무게 중심 좌표를 사용하여 정점 데이터를 보간하여 재료 함수 입력을 생성합니다.

재료와 조명 셰이더는 효과적으로 손대지 않았으며 지연된 렌더링 구현과 동일합니다.

이 단계들 사이의 인터페이스가 어떻게 최소화되었는지 살펴봅시다.

정점 셰이더는 래스터화할 위치만 필요합니다.

프래그먼트 셰이더는 재구성 단계에 공급되는 가시성 버퍼에 대한 표면 ID와 무게중심 좌표를 생성합니다.

그리고 재구성 단계 이후에만 우리는 재료 모델과 조명 기능에 의해 사용되는 큰 재구성된 재료 입력 데이터를 메모리에 가지고 있다.

이제 인터페이스를 도입했으므로, 이러한 입력과 출력을 생성하는 셰이더를 살펴봅시다.

간단한 정점과 조각 셰이더가 있는 기하학 면부터 시작합시다.

정점 셰이더는 위치를 변환하고 출력하기만 하면 됩니다.

프래그먼트 셰이더에서, 우리는 금속 셰이딩 언어에서 사용할 수 있는 새로운 원시 ID와 무게중심 좌표를 사용합니다.

우리는 기본 ID와 추가 그리기 인덱스를 표면 식별자에 결합하여 나중에 볼 수 있듯이 정점 버퍼에서 기본을 식별할 수 있습니다.

이제 조명 단계를 살펴봅시다.

높은 수준에서, 조명 단계에는 세 단계가 있다: 재건, 재료 모델 및 조명 기능.

재구성 단계는 표면 식별자와 무게 중심 좌표에서 재료 입력을 재구성할 것이다.

그런 다음 지연된 셰이더에서 하는 것처럼 재료 모델 단계를 실행할 수 있습니다.

그리고 마지막으로 우리는 최종 조명 픽셀을 쓰기 위해 조명 기능을 적용합니다.

앞서 언급했듯이, 재료와 조명 단계는 고전적인 연기와 동일하다.

그래서 재건 단계를 더 자세히 살펴봅시다.

재구성 단계의 주요 목적은 들어오는 가시성 버퍼 조각을 재료 입력으로 변환하는 것이다.

첫째, 이것은 표면 식별자에 포함된 기본 ID와 그리기 ID를 사용하여 주어진 조각에 대한 정점 데이터를 생성해야 합니다.

추가 인덱스는 조각 간에 다른 정점 버퍼를 갖는 것을 용이하게 한다.

이를 위해, 우리는 드로우 호출을 참조하기 위해 드로우 식별자를 사용합니다.

둘째, 무게중심 좌표는 재구성 단계에서 보간하는 데 사용된다.

역참호 트리를 살펴봅시다.

여기서 우리는 가시성 버퍼 픽셀을 원래의 보간된 정점 속성으로 다시 해결하는 데 필요한 역참조 트리를 보여줍니다.

가시성 버퍼는 두 개의 무게중심 좌표를 포함한다.

세 번째 좌표는 세 가지 모두의 합이 일치이기 때문에 다른 두 좌표에서 검색할 수 있다.

그것은 또한 앞서 언급했듯이 드로우 ID와 원시 ID의 조합을 포함한다.

드로우 ID에서 드로우 상태를 검색할 수 있으며, 뷰 프로젝션 매트릭스와 같은 드로우당 속성에 액세스할 수 있습니다.

거기에서, 우리는 메쉬 상태에서 정점과 인덱스 버퍼를 검색할 수 있습니다.

이 인덱스는 정점 데이터를 가져오는 데 필요하다.

그리고 우리는 또한 필요한 재료별 데이터를 검색하기 위해 동일한 경로를 사용할 수 있습니다.

이제 재료 모델이 더 복잡해지면, 특정 재료 논리를 실행하기 위해 재료 함수 포인터를 추가할 수 있습니다.

셰이더 코드에서 재구성이 어떻게 보이는지 살펴봅시다.

재구성 기능에서 가장 먼저 해야 할 일은 원시 ID를 검색하고, 가시성 버퍼에서 ID와 바리센트릭 좌표를 그리는 것입니다.

그 후, 그리기 ID를 사용하여 그리기 상태에서 메쉬 ID를 검색할 수 있습니다.

기본 ID와 메쉬 ID를 사용하여 정점 버퍼 내의 정점 인덱스를 검색하려면 인덱스 버퍼를 역참조해야 합니다.

그런 다음 정점 버퍼 데이터는 무게중심 좌표를 통해 읽고 보간할 수 있다.

또한, 행렬 및 기타 그리기당 정보를 검색하여 법선과 접선과 같은 기하학에서 지연된 정점 변환을 수행할 수 있습니다.

재료 입력이 생성되면, 데이터는 이전에 논의한 바와 같이 재료 논리와 조명 기능에 공급된다.

실행 중인 가시성 버퍼를 살펴봅시다.

다음은 iPhone에서 실행되는 가시성 버퍼를 사용하는 현대적인 렌더링 장면입니다.

그것은 여러 재료와 빛으로 가득 찬 장면을 사용하는 타일 조명 기술을 구현하고 있다.

일반적으로, 고전적인 연기에서, 이것은 꽤 큰 G 버퍼를 차지하는 정상, 알베도, 거칠기 등과 같은 여러 G 버퍼 채널이 필요했을 것이다.

하지만 가시성 버퍼를 사용하면 표면 ID와 무게중심 좌표만 있으면 됩니다.

먼저, 우리는 각각 그리기 ID와 원시 ID를 보여주는 밝기와 색조로 시각화된 생성된 표면 식별자를 저장합니다.

둘째, 우리는 빨간색, 녹색 및 파란색 채널과 함께 여기에서 시각화된 무게중심 좌표를 저장합니다.

이 두 가지 특성은 기하학을 효율적으로 재구성하고 지연된 재료 음영 및 조명 모델을 적용하기에 충분하다.

이 기술로, G 버퍼 크기는 얇은 가시성 버퍼를 사용하여 A14에서 크게 줄어든다.

우리의 예에서, 우리는 고전적인 연기에 비해 G 버퍼 크기의 40% 이상을 절약합니다.

그래서 그것은 무게중심 좌표와 원시 ID에 대한 우리의 깊은 다이빙을 마무리한다.

이제 A14의 새로운 텍스처 주소 지정 모드를 빠르게 살펴봅시다.

이 모드는 샘플링 범위를 벗어난 텍스처 좌표를 처리하는 방법을 지정하며 텍스처 아틀라스를 사용할 때 매우 편리합니다.

우리는 A14용 Metal에 두 가지 새로운 주소 지정 모드를 추가했습니다.

미러 클램프를 가장자리 주소 지정 모드로, 익스텐트의 범위 내의 텍스처 좌표는 축을 가로질러 미러링됩니다.

그리고 그들이 밖으로 떨어지면, 그들은 고정된다.

당신은 오른쪽 사진에서 이것을 볼 수 있습니다.

우리는 또한 투명한 검은색, 불투명한 검은색 및 불투명한 흰색 사이에서 프리셋 중 하나를 선택할 수 있는 테두리 색상 클램프 모드를 추가했습니다.

사용법은 꽤 간단하다.

먼저, 샘플러 설명자 객체를 만들어야 합니다.

그런 다음 주소 모드를 설정하여 깊이, 너비 및 높이 좌표에 대한 클램프 모드를 독립적으로 지정할 수 있습니다.

clampToBorderColor를 사용하는 경우, Metal에서 지원되는 프리셋 중 하나를 설정할 수 있습니다.

그 후, 샘플러 설명자로 samplerState 객체를 만들 수 있습니다.

그래서 그것은 A14의 새로운 그래픽 기능에 대한 개요였다.

이제 저는 SIMD 감소로 시작하여 A14 GPU가 가능하게 하는 새로운 컴퓨팅 기능을 설명하기 위해 동료 Swami에게 전달하고 싶습니다.

고마워, 아난드.

저는 스와미 나라야난이고, GPU 소프트웨어로 작업합니다.

메탈은 고성능 그래픽을 가능하게 하고 데이터 병렬 계산을 수행하도록 설계되었으며 GPU의 엄청난 힘을 활용하는 다양한 고급 컴퓨팅 기능을 제공합니다.

A14 바이오닉에서 메탈은 이제 앱이 믿을 수 없을 정도로 효율적으로 감소를 수행할 수 있는 방법을 제공하는 SIMD 범위 감소 지침을 제공합니다.

그들이 어떻게 작동하는지 이해하기 위해, 병렬 감소 작업을 간략하게 검토해 봅시다.

감소 작업은 배열의 요소를 단일 결과로 줄이는 데 사용됩니다.

예를 들어, 합계 감소는 배열의 모든 요소를 더하는 데 사용된다.

이것은 평균을 계산하는 데 유용할 수 있다.

또 다른 예는 장면의 최소값과 최대 값을 계산하는 것이다.

그런 다음 그 값들은 톤 매핑 알고리즘에 사용될 수 있다.

전통적으로, 이 모든 작업은 CPU에서 연속적으로 계산되었다.

그러나, 금속은 GPU의 병렬 특성을 활용하여 감소를 훨씬 더 효율적으로 계산할 수 있다.

A14 GPU에서 Metal은 이제 몇 가지 SIMD 범위 감소 지침을 지원합니다.

Simd_sum과 simd_product는 SIMD 그룹의 모든 스레드에서 변수의 합계와 곱을 생성합니다.

Simd_minimum과 simd_maximum은 최소값과 최대값을 찾는 데 사용할 수 있습니다.

이 네 가지 지침은 부동 소수점과 정수 유형에서 작동한다.

또한, Metal은 이제 비트 연산자 "and", "or" 및 "xor"를 사용하여 감소를 지원합니다.

당연히, 이것들은 정수 유형에서만 작동한다.

감소 작업을 더 자세히 살펴보기 전에, 스레드가 스레드 그룹과 SIMD 그룹으로 어떻게 구성되는지 살펴봅시다.

컴퓨팅 디스패치는 그리드로 표시되는 개별 스레드 세트를 시작합니다.

이 스레드 그리드는 스레드 그룹이라고 불리는 더 작은 서브그리드로 나뉩니다.

스레드 그룹은 SIMD 그룹이라고 불리는 32개의 스레드 그룹으로 더 구성됩니다.

SIMD 그룹의 스레드는 잠금 단계에서 동시에 실행된다.

SIMD 그룹 함수는 이 잠금 단계 실행을 악용하여 이러한 스레드 간에 데이터를 공유합니다.

이제 SIMD 그룹과 스레드 그룹이 어떻게 구성되는지 보았으니, SIMD 그룹에서 스레드가 어떻게 실행되는지 살펴봅시다.

SIMD 그룹은 여기 왼쪽에 표시된 32개의 차선을 가지고 있다.

각 차선은 컴퓨팅 디스패치에서 스레드를 실행할 것이다.

이제 SIMD 그룹의 모든 스레드가 차선 ID를 변수 X에 저장하도록 합시다.

각 차선이 어떻게 X의 고유한 가치를 가지고 있는지 주목하세요.

SIMD 그룹 실행 모델에서 변수 X를 차선 ID로 설정하는 명령은 한 번만 가져온 다음 32개의 스레드에 의해 잠금 단계에서 동시에 실행됩니다.

SIMD 그룹 기능을 사용하면 각 스레드가 최소한의 오버헤드로 SIMD 그룹의 다른 스레드의 변수를 검사하고 사용할 수 있습니다.

A14에 추가된 새로운 지침 중 하나인 simd_sum을 살펴봅시다.

Simd_sum은 SIMD 그룹의 모든 활성 스레드에서 변수 값을 추가하고 합계를 모든 스레드로 다시 브로드캐스트합니다.

여기서 우리는 SIMD 그룹의 32개 차선에 걸쳐 변수 X의 값을 추가하고 있습니다.

명령이 실행되면, 결과 합계는 변수 F에서 사용할 수 있습니다.

모든 활성 스레드는 496의 계산된 합계를 얻기 위해 변수 F의 복사본을 검사할 수 있습니다.

비활성 스레드는 계산에서 올바르게 건너뛰어집니다.

그들은 최종 금액에 기여하지 않는다.

이제 simd_sum을 사용하여 큰 배열의 요소를 추가하는 속도를 높이는 방법을 살펴봅시다.

여기서 입력 배열은 장치 메모리에 있다.

각 SIMD 그룹은 입력 배열의 하위 영역을 읽고 simd_sum 명령을 사용하여 합계를 계산합니다.

그런 다음 이 합계는 스레드 그룹 메모리의 배열에 기록됩니다.

모든 SIMD 그룹에는 스레드 그룹 합계 배열에 인덱싱하는 데 사용할 수 있는 고유한 ID가 있습니다.

스레드 그룹의 마지막 실행 SIMD 그룹은 최종 합계를 얻기 위해 simd_sum 명령을 다시 사용합니다.

Simd_sum을 사용함으로써, 우리는 스레드 그룹 장벽의 수와 스레드 그룹 메모리의 사용을 줄였습니다.

Simd_sum 명령은 또한 SIMD 그룹의 모든 스레드의 합계를 계산하기 위해 한 번만 실행됩니다.

이제 컴퓨팅 커널의 구현으로 가자.

여기에 simd_sum을 사용하여 병렬 감소를 구현하는 코드가 있습니다.

SIMD 그룹의 각 스레드는 입력 배열에서 해당 요소를 읽습니다.

그런 다음 simd_sum 명령을 사용하여 첫 번째 simdgroup_sum을 계산합니다.

그런 다음 이 합계는 SIMD 그룹 ID를 사용하여 인덱싱된 스레드 그룹 메모리의 배열에 기록됩니다.

스레드 그룹 메모리의 배열에 접근하기 전에 장벽이 필요하다는 점에 유의하십시오.

각 스레드 그룹의 마지막 SIMD 그룹은 simd_sum 명령을 다시 사용하여 최종 합계를 얻는다.

우리가 A14에서 도입한 다른 감축 작업을 살펴봅시다.

우리는 이미 모든 활성 차선에서 X의 값을 더하는 simd_sum을 보았다.

이제 simd_max를 살펴보고 변수 X에 적용해 봅시다.

그런 다음 모든 차선은 SIMD 그룹의 모든 스레드에서 최대 값인 31을 얻습니다.

마찬가지로, simd_min은 모든 활성 차선에 걸쳐 이 경우 0인 X의 최소 값을 저장합니다.

마지막으로, 우리는 X의 모든 값을 곱하는 simd_product를 가지고 있다.

변수 중 하나가 0이기 때문에, 방송되는 최종 제품은 0이다.

이 지침은 정수와 부동 소수점 스칼라와 벡터 유형 모두에서 작동합니다.

감소 작업은 또한 적분 유형의 비트 연산에 대해 지원됩니다.

각 차선에는 이제 여기에 표시된 것처럼 차선 ID를 사용하여 제조된 비트 필드 값이 있습니다.

그런 다음 변수 X에 대한 simd_또는 명령을 사용할 수 있습니다.

모든 활성 차선에서 X의 값은 함께 또는 함께 전송되어 변수 F로 다시 방송됩니다.

이 최종 값은 우리의 예에서 0x1F3이다.

마찬가지로, simd_xor는 X의 xor 값을 계산하고 결과 값을 다시 브로드캐스트하며, 이는 0x0으로 판명됩니다.

마지막으로, 우리는 SIMD 그룹의 모든 스레드에서 X의 모든 값을 더하는 simd_and를 가지고 있습니다.

이것은 상수 0x3로 밝혀졌다.

그것은 A14 GPU에서 사용할 수 있는 새로운 SIMD 범위 감소 지침에 대한 개요였다.

이제 매트릭스 곱셈을 크게 향상시키는 새로운 SIMD 범위 지침을 살펴봅시다.

매트릭스 곱셈은 GPU 컴퓨팅에서 매우 일반적인 작업이며 많은 병렬 컴퓨팅 워크로드의 기본 구성 요소이다.

예를 들어, 기계 학습에서는 컨벌루션과 완전히 연결된 뉴런 레이어를 계산할 때 사용됩니다.

선형 대수학은 방정식 시스템을 표현하고 푸는 데 사용된다.

A14는 대형 매트릭스 곱셈을 매우 효율적으로 구현할 수 있는 새로운 SIMD 범위 지침 세트를 소개합니다.

우리가 전에 보았던 감소 작업과 마찬가지로, 이것들은 SIMD 그룹 범위 작업이다.

이제 이러한 빌딩 블록 위에 더 크고 정교한 기능을 쉽게 구축할 수 있습니다.

금속 음영 언어에서, 우리는 이제 8 x 8과 4 x 4 행렬을 나타내는 SIMD 그룹 범위 데이터 구조를 가지고 있습니다.

그런 다음 SIMD 그룹 범위 매트릭스 작업의 multiply 또는 multiply_accumulate 버전을 사용할 수 있습니다.

이 함수를 사용하여 스레드 그룹에서 두 개의 16에 16 행렬을 곱하는 예를 살펴봅시다.

우리는 8 x 8 SIMD 그룹 매트릭스 연산을 사용하여 16 x 16 세 번째 그룹 매트릭스 곱셈을 만들 것입니다.

먼저 우리는 결과 매트릭스를 네 개의 SIMD 그룹으로 나눕니다.

각 SIMD 그룹은 결과의 8 x 8 사분면을 계산할 책임이 있다.

다음으로, 우리는 첫 번째 입력 매트릭스를 분할한다.

여기서, 행의 각 SIMD 그룹은 하나의 블록 열을 공유한다.

그런 다음 우리는 두 번째 입력을 분할한다.

여기서 열의 각 SIMD 그룹은 단일 블록 행을 공유합니다.

그런 다음 우리는 8 x 8 결과의 첫 번째 세트에서 제품을 축적할 것입니다...

그리고 두 번째.

이제 이것을 메탈 셰이딩 언어로 쓰는 방법을 살펴봅시다.

A14로, 우리는 새로운 SIMD 그룹 매트릭스 객체와 곱셈 연산을 금속 음영 언어에 도입했습니다.

이 새로운 프리미티브는 셰이더에서 행렬 곱셈의 성능을 크게 향상시킬 것입니다.

사용하기 쉽고 몇 줄의 셰이더 코드로 할 수 있습니다.

여기서 우리는 32비트 부동 소수점 형식의 데이터로 8 x 8 행렬을 나타내는 세 개의 객체를 정의합니다.

우리는 각 입력에 대한 매트릭스와 결과에 대한 매트릭스를 가지고 있다.

다음으로, 우리는 결과의 각 사분면에 걸쳐 네 개의 SIMD 그룹을 분할하는 데 필요한 주소 산술을 수행합니다.

그런 다음 각 소스 매트릭스에서 몇 가지 매트릭스를 축적하여 각 SIMD 그룹에 적절한 행과 열을 방송합니다.

마지막으로, 우리는 결과를 저장한다.

이 새로운 프리미티브를 사용하여 더 복잡한 셰이더를 만드는 것이 얼마나 쉬운지 알 수 있습니다.

금속 성능 셰이더를 사용하는 경우, SIMD 그룹 범위 매트릭스 곱셈의 이점을 통해 매트릭스 곱셈뿐만 아니라 CNN 컨벌루션도 가속화할 수 있습니다.

임의의 크기에 대한 행렬 곱셈은 MPS 행렬 곱셈을 사용하여 수행할 수 있습니다.

여기서 우리는 M 행과 N 열로 결과를 계산하기 위해 커널을 인코딩하고 있습니다.

CNN 컨볼루션은 MPSCNNConvolution을 사용하여 수행할 수 있다.

여기서 우리는 이미지 배치에 컨벌루션 커널을 인코딩하고 있습니다.

이 두 커널 모두 올해 iOS 14와 함께 도입된 새로운 금속 성능 셰이더 그래프를 사용하여 사용할 수 있습니다.

MPS 그래프를 사용하면 이러한 기본 커널을 가지고 복잡한 기계 학습 네트워크를 구축할 수 있습니다.

예를 들어, 이전의 행렬 곱셈 커널이 그래프에서 어떻게 사용될 수 있는지 살펴봅시다.

여기서 우리는 운영을 위한 새로운 그래프를 초기화할 것이다.

그런 다음 우리는 두 개의 입력 행렬을 나타내기 위해 노드를 정의합니다.

그런 다음 행렬 곱셈 연산을 사용하여 입력에서 새로운 결과 노드를 구성합니다.

마지막으로, 우리는 그래프를 실행한다.

MPS 커널과 그래프 작업을 사용하는 방법에 대한 자세한 내용은 이전에 사용 가능한 WWDC 프레젠테이션을 참조하십시오.

앞서 언급했듯이, MPS는 이러한 작업을 위해 A14를 자동으로 활용할 것이다.

여기서 우리는 A13에 비해 A14의 일반 행렬 곱셈의 향상된 처리량을 볼 수 있다.

A14에서 새로운 SIMD 그룹 매트릭스 곱셈 연산을 사용하면 평균 성능이 37% 향상됩니다.

A14의 CNN 컨볼루션은 A13에서 평균 36%의 개선을 보여준다.

그리고 인셉션 V3와 같은 완전한 기계 학습 네트워크를 교육할 때, A14는 22% 향상됩니다.

그것은 SIMD 그룹 범위 행렬 곱셈을 마무리한다.

A14의 새로운 금속 기능을 요약해 봅시다.

바리센트릭 좌표와 원시 ID는 가시성 버퍼 렌더링을 포함한 새로운 지연 렌더링 기술을 가능하게 한다.

텍스처 아틀라스를 사용할 때 유용한 새로운 텍스처 주소 지정 모드.

스레드 간의 더 나은 통신을 가능하게 하는 SIMD 그룹 범위 감소 지침.

우리는 또한 SIMD 그룹 범위 매트릭스 곱셈 지침으로 컴퓨팅 및 기계 학습 성능을 개선했습니다.

그리고 마지막으로, A14의 메탈은 다양한 아키텍처 개선을 활용하여 향상된 무손실 압축, 더 빠르고 효율적인 로컬 메모리 및 더 나은 GPU 기반 파이프라인으로 대역폭을 절약합니다.

봐줘서 고마워.