10134

♪ ♪

Xin chào, tôi là Kavon, và tôi sẽ được tham gia bởi đồng nghiệp của tôi, Joe, sau này.

Swift 5.5 giới thiệu một cách mới để viết các chương trình đồng thời, sử dụng một khái niệm gọi là đồng thời có cấu trúc.

Các ý tưởng đằng sau tính đồng thời có cấu trúc dựa trên lập trình có cấu trúc, trực quan đến mức bạn hiếm khi nghĩ về nó, nhưng suy nghĩ về nó sẽ giúp bạn hiểu tính đồng thời có cấu trúc.

Vậy chúng ta hãy đi sâu vào.

Trong những ngày đầu của máy tính, các chương trình rất khó đọc vì chúng được viết dưới dạng một chuỗi các hướng dẫn, trong đó luồng điều khiển được phép nhảy khắp nơi.

Bạn không thấy điều đó ngày nay, bởi vì các ngôn ngữ sử dụng lập trình có cấu trúc để làm cho luồng điều khiển thống nhất hơn.

Ví dụ, câu lệnh if-then sử dụng luồng điều khiển có cấu trúc.

Nó chỉ định rằng một khối mã lồng nhau chỉ được thực thi có điều kiện trong khi di chuyển từ trên xuống dưới.

Trong Swift, khối đó cũng tôn trọng phạm vi tĩnh, có nghĩa là các tên chỉ hiển thị nếu chúng được xác định trong một khối kèm theo.

Điều này cũng có nghĩa là tuổi thọ của bất kỳ biến nào được xác định trong một khối sẽ kết thúc khi rời khỏi khối.

Vì vậy, lập trình có cấu trúc với phạm vi tĩnh giúp luồng điều khiển và tuổi thọ thay đổi dễ hiểu.

Tổng quát hơn, luồng điều khiển có cấu trúc có thể được sắp xếp theo trình tự và lồng vào nhau một cách tự nhiên.

Điều này cho phép bạn đọc toàn bộ chương trình của mình từ trên xuống dưới.

Vì vậy, đó là những nguyên tắc cơ bản của lập trình có cấu trúc.

Như bạn có thể tưởng tượng, thật dễ dàng để coi là điều hiển nhiên, bởi vì nó rất trực quan đối với chúng ta ngày nay.

Nhưng các chương trình ngày nay có mã không đồng bộ và đồng thời, và chúng không thể sử dụng lập trình có cấu trúc để làm cho mã đó dễ viết hơn.

Đầu tiên, hãy xem xét cách lập trình có cấu trúc làm cho mã không đồng bộ đơn giản hơn.

Nói rằng bạn cần tìm nạp một loạt hình ảnh từ internet và thay đổi kích thước chúng thành hình thu nhỏ một cách tuần tự.

Mã này hoạt động không đồng bộ, lấy một bộ sưu tập các chuỗi xác định hình ảnh.

Bạn sẽ nhận thấy hàm này không trả về một giá trị khi được gọi.

Đó là bởi vì hàm chuyển kết quả của nó, hoặc một lỗi, cho một trình xử lý hoàn thành mà nó đã được đưa ra.

Mẫu này cho phép người gọi nhận được câu trả lời sau.

Do hậu quả của mẫu đó, chức năng này không thể sử dụng luồng điều khiển có cấu trúc để xử lý lỗi.

Đó là bởi vì nó chỉ có ý nghĩa để xử lý các lỗi được ném ra khỏi một chức năng, không phải vào một chức năng.

Ngoài ra, mẫu này ngăn bạn sử dụng một vòng lặp để xử lý từng hình thu nhỏ.

Đệ quy là bắt buộc, bởi vì mã chạy sau khi hàm hoàn thành phải được lồng trong trình xử lý.

Bây giờ, chúng ta hãy xem mã trước đó nhưng được viết lại để sử dụng cú pháp không đồng bộ/chờ mới, dựa trên lập trình có cấu trúc.

Tôi đã bỏ đối số trình xử lý hoàn thành khỏi hàm.

Thay vào đó, nó được chú thích bằng "không đồng bộ" và "ném" trong chữ ký loại của nó.

Nó cũng trả về một giá trị thay vì không có gì.

Trong phần thân của hàm, tôi sử dụng "chờ đợi" để nói rằng một hành động không đồng bộ xảy ra và không cần lồng nhau cho mã chạy sau hành động đó.

Điều này có nghĩa là bây giờ tôi có thể lặp lại các hình thu nhỏ để xử lý chúng tuần tự.

Tôi cũng có thể ném và bắt lỗi, và trình biên dịch sẽ kiểm tra xem tôi đã không quên.

Để có cái nhìn sâu sắc về async/await, hãy xem phiên "Gặp gỡ async/await trong Swift." Vì vậy, mã này rất tuyệt, nhưng nếu bạn đang tạo hình thu nhỏ cho hàng nghìn hình ảnh thì sao?

Xử lý từng hình thu nhỏ một không còn lý tưởng nữa.

Thêm vào đó, điều gì sẽ xảy ra nếu kích thước của mỗi hình thu nhỏ phải được tải xuống từ một URL khác, thay vì là một kích thước cố định?

Bây giờ có một cơ hội để thêm một số đồng thời, vì vậy nhiều lần tải xuống có thể diễn ra song song.

Bạn có thể tạo các tác vụ bổ sung để thêm tính đồng thời vào chương trình.

Nhiệm vụ là một tính năng mới trong Swift hoạt động song song với các chức năng không đồng bộ.

Một nhiệm vụ cung cấp một ngữ cảnh thực thi mới để chạy mã không đồng bộ.

Mỗi nhiệm vụ chạy đồng thời đối với các bối cảnh thực thi khác.

Chúng sẽ được tự động lên lịch để chạy song song khi an toàn và hiệu quả để làm như vậy.

Bởi vì các tác vụ được tích hợp sâu vào Swift, trình biên dịch có thể giúp ngăn chặn một số lỗi đồng thời.

Ngoài ra, hãy nhớ rằng việc gọi một hàm không đồng bộ không tạo ra một nhiệm vụ mới cho cuộc gọi.

Bạn tạo ra các nhiệm vụ một cách rõ ràng.

Có một vài hương vị khác nhau của các nhiệm vụ trong Swift, bởi vì tính đồng thời có cấu trúc là về sự cân bằng giữa tính linh hoạt và sự đơn giản.

Vì vậy, trong phần còn lại của phiên này, Joe và tôi sẽ giới thiệu và thảo luận về từng loại nhiệm vụ để giúp bạn hiểu được sự đánh đổi của họ.

Hãy bắt đầu với nhiệm vụ đơn giản nhất trong số những nhiệm vụ này, được tạo ra với một dạng cú pháp mới được gọi là ràng buộc async-let.

Để giúp bạn hiểu dạng cú pháp mới này, trước tiên tôi muốn chia nhỏ đánh giá về một ràng buộc thông thường.

Có hai phần: biểu thức khởi tạo ở phía bên phải của bằng và tên của biến ở bên trái.

Có thể có những tuyên bố khác trước hoặc sau khi cho phép, vì vậy tôi cũng sẽ bao gồm những tuyên bố đó ở đây.

Khi Swift đạt đến ràng buộc let, trình khởi tạo của nó sẽ được đánh giá để tạo ra một giá trị.

Trong ví dụ này, điều đó có nghĩa là tải xuống dữ liệu từ URL, có thể mất một lúc.

Sau khi dữ liệu đã được tải xuống, Swift sẽ liên kết giá trị đó với tên biến trước khi tiến hành các câu lệnh tiếp theo.

Lưu ý rằng chỉ có một luồng thực thi ở đây, như được theo dõi bởi các mũi tên qua mỗi bước.

Vì quá trình tải xuống có thể mất một lúc, bạn muốn chương trình bắt đầu tải xuống dữ liệu và tiếp tục thực hiện các công việc khác cho đến khi dữ liệu thực sự cần thiết.

Để đạt được điều này, bạn chỉ cần thêm từ không đồng bộ trước một ràng buộc let hiện có.

Điều này biến nó thành một ràng buộc đồng thời được gọi là async-let.

Việc đánh giá một ràng buộc đồng thời khá khác so với một liên kết tuần tự, vì vậy hãy tìm hiểu cách nó hoạt động.

Tôi sẽ bắt đầu ngay tại thời điểm trước khi gặp phải sự ràng buộc.

Để đánh giá một ràng buộc đồng thời, Swift trước tiên sẽ tạo một nhiệm vụ con mới, đây là một nhiệm vụ con của tác vụ đã tạo ra nó.

Bởi vì mọi nhiệm vụ đại diện cho một bối cảnh thực thi cho chương trình của bạn, hai mũi tên sẽ đồng thời xuất hiện từ bước này.

Mũi tên đầu tiên này dành cho tác vụ con, sẽ ngay lập tức bắt đầu tải xuống dữ liệu.

Mũi tên thứ hai dành cho tác vụ mẹ, sẽ ngay lập tức liên kết kết quả biến với giá trị giữ chỗ.

Nhiệm vụ mẹ này cũng giống như nhiệm vụ đã thực hiện các câu lệnh trước đó.

Trong khi dữ liệu đang được tải xuống đồng thời bởi đứa trẻ, tác vụ mẹ tiếp tục thực hiện các câu lệnh tuân theo ràng buộc đồng thời.

Nhưng khi đạt được một biểu thức cần giá trị thực tế của kết quả, phụ huynh sẽ chờ hoàn thành nhiệm vụ con, nhiệm vụ này sẽ hoàn thành trình giữ chỗ cho kết quả.

Trong ví dụ này, cuộc gọi của chúng tôi đến URLSession cũng có thể gây ra lỗi.

Điều này có nghĩa là việc chờ kết quả có thể khiến chúng ta gặp lỗi.

Vì vậy, tôi cần viết "cố gắng" để chăm sóc nó.

Và đừng lo lắng.

Đọc lại giá trị của kết quả sẽ không tính toán lại giá trị của nó.

Bây giờ bạn đã thấy cách hoạt động của async-let, bạn có thể sử dụng nó để thêm tính đồng thời vào mã tìm nạp hình thu nhỏ.

Tôi đã tính đến một đoạn mã trước đó để tìm nạp một hình ảnh duy nhất vào chức năng riêng của nó.

Chức năng mới này ở đây cũng đang tải xuống dữ liệu từ hai URL khác nhau: một cho chính hình ảnh có kích thước đầy đủ và một cho siêu dữ liệu, chứa kích thước hình thu nhỏ tối ưu.

Lưu ý rằng với một ràng buộc tuần tự, bạn viết "thử chờ đợi" ở phía bên phải của let, bởi vì đó là nơi sẽ quan sát thấy lỗi hoặc đình chỉ.

Để làm cho cả hai lần tải xuống diễn ra đồng thời, bạn viết "không đồng bộ" trước cả hai điều này.

Vì việc tải xuống hiện đang diễn ra trong các tác vụ con, bạn không còn viết "thử chờ đợi" ở phía bên phải của ràng buộc đồng thời.

Những hiệu ứng đó chỉ được quan sát bởi nhiệm vụ mẹ khi sử dụng các biến bị ràng buộc đồng thời.

Vì vậy, bạn viết "thử chờ đợi" trước khi biểu thức đọc siêu dữ liệu và dữ liệu hình ảnh.

Ngoài ra, lưu ý rằng việc sử dụng các biến bị ràng buộc đồng thời này không yêu cầu gọi phương thức hoặc bất kỳ thay đổi nào khác.

Những biến đó có cùng loại mà chúng đã làm trong một ràng buộc tuần tự.

Bây giờ, những nhiệm vụ con mà tôi đang nói đến thực sự là một phần của hệ thống phân cấp được gọi là cây nhiệm vụ.

Cây này không chỉ là một chi tiết triển khai.

Đó là một phần quan trọng của sự đồng thời có cấu trúc.

Nó ảnh hưởng đến các thuộc tính của các nhiệm vụ của bạn như hủy bỏ, ưu tiên và các biến cục bộ nhiệm vụ.

Bất cứ khi nào bạn thực hiện cuộc gọi từ hàm không đồng bộ này sang hàm không đồng bộ khác, nhiệm vụ tương tự sẽ được sử dụng để thực hiện cuộc gọi.

Vì vậy, hàm fetchOneThumbnail kế thừa tất cả các thuộc tính của tác vụ đó.

Khi tạo một tác vụ có cấu trúc mới như với async-let, nó sẽ trở thành con của tác vụ mà hàm hiện tại đang chạy.

Các nhiệm vụ không phải là con của một chức năng cụ thể, nhưng tuổi thọ của chúng có thể được xác định phạm vi của nó.

Cây được tạo thành từ các liên kết giữa mỗi nhiệm vụ cha mẹ và con của nó.

Một liên kết thực thi một quy tắc nói rằng một nhiệm vụ mẹ chỉ có thể hoàn thành công việc của nó nếu tất cả các nhiệm vụ con của nó đã hoàn thành.

Quy tắc này vẫn tồn tại ngay cả khi đối mặt với dòng chảy kiểm soát bất thường sẽ ngăn chặn một nhiệm vụ trẻ em được chờ đợi.

Ví dụ, trong mã này, trước tiên tôi chờ tác vụ siêu dữ liệu trước tác vụ dữ liệu hình ảnh.

Nếu tác vụ được chờ đợi đầu tiên kết thúc bằng cách ném lỗi, hàm fetchOneThumbnail phải thoát ngay lập tức bằng cách ném lỗi đó.

Nhưng điều gì sẽ xảy ra với nhiệm vụ thực hiện lần tải xuống thứ hai?

Trong quá trình thoát bất thường, Swift sẽ tự động đánh dấu tác vụ không mong đợi là đã bị hủy và sau đó đợi nó kết thúc trước khi thoát khỏi chức năng.

Đánh dấu một nhiệm vụ là đã hủy không dừng nhiệm vụ.

Nó chỉ đơn giản thông báo cho nhiệm vụ rằng kết quả của nó không còn cần thiết nữa.

Trên thực tế, khi một nhiệm vụ bị hủy bỏ, tất cả các nhiệm vụ phụ đã quá hạn của nhiệm vụ đó cũng sẽ tự động bị hủy.

Vì vậy, nếu việc triển khai URLSession tạo ra các tác vụ có cấu trúc của riêng nó để tải xuống hình ảnh, những tác vụ đó sẽ được đánh dấu để hủy bỏ.

Hàm fetchOneThumbnail cuối cùng cũng thoát ra bằng cách ném lỗi khi tất cả các tác vụ có cấu trúc mà nó tạo trực tiếp hoặc gián tiếp đã kết thúc.

Sự đảm bảo này là nền tảng cho sự đồng thời có cấu trúc.

Nó ngăn bạn vô tình rò rỉ các tác vụ bằng cách giúp bạn quản lý vòng đời của chúng, giống như cách ARC tự động quản lý vòng đời của bộ nhớ.

Cho đến nay, tôi đã cung cấp cho bạn một cái nhìn tổng quan về cách hủy bỏ lan truyền.

Nhưng khi nào nhiệm vụ cuối cùng dừng lại?

Nếu nhiệm vụ đang ở giữa một giao dịch quan trọng hoặc có kết nối mạng mở, sẽ không chính xác nếu chỉ dừng nhiệm vụ.

Đó là lý do tại sao việc hủy nhiệm vụ trong Swift là hợp tác.

Mã của bạn phải kiểm tra việc hủy bỏ một cách rõ ràng và giảm bớt việc thực thi theo bất kỳ cách nào phù hợp.

Bạn có thể kiểm tra trạng thái hủy của nhiệm vụ hiện tại từ bất kỳ chức năng nào, cho dù nó có không đồng bộ hay không.

Điều này có nghĩa là bạn nên triển khai các API của mình với mục đích hủy bỏ, đặc biệt nếu chúng liên quan đến các tính toán lâu dài.

Người dùng của bạn có thể gọi mã của bạn từ một tác vụ có thể bị hủy và họ sẽ mong đợi việc tính toán dừng lại càng sớm càng tốt.

Để xem việc sử dụng hủy hợp tác đơn giản như thế nào, chúng ta hãy quay lại ví dụ tìm nạp hình thu nhỏ.

Ở đây, tôi đã viết lại hàm ban đầu được cung cấp tất cả các hình thu nhỏ để tìm nạp để nó sử dụng hàm fetchOneThumbnail thay thế.

Nếu chức năng này được gọi trong một tác vụ đã bị hủy, chúng tôi không muốn giữ ứng dụng của mình bằng cách tạo các hình thu nhỏ vô dụng.

Vì vậy, tôi chỉ có thể thêm một cuộc gọi để kiểm tra Hủy bỏ ở đầu mỗi lần lặp vòng lặp.

Cuộc gọi này chỉ gây ra lỗi nếu nhiệm vụ hiện tại đã bị hủy.

Bạn cũng có thể lấy trạng thái hủy của nhiệm vụ hiện tại dưới dạng giá trị Boolean nếu điều đó phù hợp hơn với mã của bạn.

Lưu ý rằng trong phiên bản hàm này, tôi đang trả về một phần kết quả, một từ điển chỉ có một số hình thu nhỏ được yêu cầu.

Khi làm điều này, bạn phải đảm bảo rằng API của bạn nêu rõ rằng một phần kết quả có thể được trả về.

Nếu không, việc hủy nhiệm vụ có thể gây ra lỗi nghiêm trọng cho người dùng của bạn vì mã của họ yêu cầu kết quả hoàn chỉnh ngay cả trong quá trình hủy.

Cho đến nay, bạn đã thấy rằng async-let cung cấp một cú pháp nhẹ để thêm tính đồng thời vào chương trình của bạn trong khi nắm bắt được bản chất của lập trình có cấu trúc.

Loại nhiệm vụ tiếp theo mà tôi muốn nói với bạn được gọi là nhiệm vụ nhóm.

Chúng cung cấp tính linh hoạt hơn so với async-let mà không từ bỏ tất cả các thuộc tính tốt đẹp của đồng thời có cấu trúc.

Như chúng ta đã thấy trước đó, async-let hoạt động tốt khi có sẵn một lượng đồng thời cố định.

Hãy xem xét cả hai chức năng mà tôi đã thảo luận trước đó.

Đối với mỗi ID hình thu nhỏ trong vòng lặp, chúng tôi gọi fetchOneThumbnail để xử lý nó, tạo ra chính xác hai tác vụ con.

Ngay cả khi chúng ta nội dung của hàm đó vào vòng lặp này, số lượng đồng thời sẽ không thay đổi.

Async-let có phạm vi giống như một liên kết biến.

Điều đó có nghĩa là hai nhiệm vụ con phải hoàn thành trước khi vòng lặp tiếp theo bắt đầu.

Nhưng điều gì sẽ xảy ra nếu chúng ta muốn vòng lặp này bắt đầu các tác vụ để tìm nạp đồng thời tất cả các hình thu nhỏ?

Sau đó, số lượng đồng thời không được biết đến tĩnh vì nó phụ thuộc vào số lượng ID trong mảng.

Công cụ phù hợp cho tình huống này là một nhóm nhiệm vụ.

Nhóm nhiệm vụ là một hình thức đồng thời có cấu trúc được thiết kế để cung cấp một lượng đồng thời động.

Bạn có thể giới thiệu một nhóm tác vụ bằng cách gọi hàm withThrowingTaskGroup.

Chức năng này cung cấp cho bạn một đối tượng nhóm có phạm vi để tạo các tác vụ con được phép ném lỗi.

Các nhiệm vụ được thêm vào một nhóm không thể tồn tại lâu hơn phạm vi của khối mà nhóm được xác định.

Vì tôi đã đặt toàn bộ for-loop bên trong khối, bây giờ tôi có thể tạo một số lượng nhiệm vụ động bằng cách sử dụng nhóm.

Bạn tạo các nhiệm vụ con trong một nhóm bằng cách gọi phương thức không đồng bộ của nó.

Sau khi được thêm vào một nhóm, các nhiệm vụ con bắt đầu thực hiện ngay lập tức và theo bất kỳ thứ tự nào.

Khi đối tượng nhóm đi ra khỏi phạm vi, việc hoàn thành tất cả các nhiệm vụ bên trong nó sẽ được ngầm chờ đợi.

Đây là hệ quả của quy tắc cây nhiệm vụ mà tôi đã mô tả trước đó, bởi vì các nhiệm vụ nhóm cũng được cấu trúc.

Tại thời điểm này, chúng tôi đã đạt được sự đồng thời mà chúng tôi muốn: một nhiệm vụ cho mỗi cuộc gọi đến fetchOneThumbnail, bản thân nó sẽ tạo thêm hai tác vụ bằng cách sử dụng async-let.

Đó là một tài sản tuyệt vời khác của sự đồng thời có cấu trúc.

Bạn có thể sử dụng async-let trong các tác vụ nhóm hoặc tạo các nhóm tác vụ trong các tác vụ async-let và các mức độ đồng thời trong cây sáng tác tự nhiên.

Bây giờ, mã này chưa hoàn toàn sẵn sàng để chạy.

Nếu chúng tôi cố gắng chạy nó, trình biên dịch sẽ cảnh báo chúng tôi một cách hữu ích về vấn đề cuộc đua dữ liệu.

Vấn đề là chúng tôi đang cố gắng chèn một hình thu nhỏ vào một từ điển duy nhất từ mỗi nhiệm vụ con.

Đây là một sai lầm phổ biến khi tăng số lượng đồng thời trong chương trình của bạn.

Các cuộc đua dữ liệu vô tình được tạo ra.

Từ điển này không thể xử lý nhiều hơn một lần truy cập cùng một lúc và nếu hai tác vụ con cố gắng chèn hình thu nhỏ đồng thời, điều đó có thể gây ra sự cố hoặc hỏng dữ liệu.

Trước đây, bạn phải tự mình điều tra những lỗi đó, nhưng Swift cung cấp kiểm tra tĩnh để ngăn chặn những lỗi đó xảy ra ngay từ đầu.

Bất cứ khi nào bạn tạo một nhiệm vụ mới, công việc mà nhiệm vụ thực hiện nằm trong một loại đóng mới được gọi là đóng @Sendable.

Phần thân của đóng @Sendable bị hạn chế nắm bắt các biến có thể thay đổi trong ngữ cảnh từ vựng của nó, bởi vì các biến đó có thể được sửa đổi sau khi tác vụ được khởi chạy.

Điều này có nghĩa là các giá trị bạn nắm bắt được trong một nhiệm vụ phải an toàn để chia sẻ.

Ví dụ, bởi vì chúng là các loại giá trị, như Int và String, hoặc bởi vì chúng là các đối tượng được thiết kế để truy cập từ nhiều luồng, như các diễn viên và các lớp thực hiện đồng bộ hóa của riêng chúng.

Chúng tôi có cả một phiên dành riêng cho chủ đề này, được gọi là "Bảo vệ trạng thái có thể thay đổi với các diễn viên Swift", vì vậy tôi khuyến khích bạn kiểm tra nó.

Để tránh cuộc đua dữ liệu trong ví dụ của chúng tôi, bạn có thể yêu cầu mỗi nhiệm vụ con trả về một giá trị.

Thiết kế này giao cho nhiệm vụ cha mẹ trách nhiệm duy nhất trong việc xử lý kết quả.

Trong trường hợp này, tôi đã chỉ định rằng mỗi tác vụ con phải trả về một bộ chứa ID Chuỗi và UIImage cho hình thu nhỏ.

Sau đó, bên trong mỗi nhiệm vụ con, thay vì viết trực tiếp vào từ điển, tôi yêu cầu chúng trả về bộ giá trị khóa để cha mẹ xử lý.

Nhiệm vụ cha mẹ có thể lặp lại thông qua các kết quả từ mỗi nhiệm vụ con bằng cách sử dụng vòng lặp chờ đợi mới.

Vòng lặp chờ đợi thu được kết quả từ các nhiệm vụ con theo thứ tự hoàn thành.

Bởi vì vòng lặp này chạy tuần tự, tác vụ mẹ có thể thêm từng cặp giá trị khóa vào từ điển một cách an toàn.

Đây chỉ là một ví dụ về việc sử dụng vòng lặp for-await để truy cập một chuỗi các giá trị không đồng bộ.

Nếu loại của riêng bạn phù hợp với giao thức AsyncSequence, thì bạn cũng có thể sử dụng for-await để lặp lại chúng.

Bạn có thể tìm hiểu thêm trong phiên "Gặp gỡ AsyncSequence".

Mặc dù các nhóm nhiệm vụ là một dạng đồng thời có cấu trúc, nhưng có một sự khác biệt nhỏ trong cách thực hiện quy tắc cây nhiệm vụ cho các nhiệm vụ nhóm so với các nhiệm vụ cho thuê không đồng bộ.

Giả sử khi lặp lại kết quả của nhóm này, tôi gặp phải một nhiệm vụ con đã hoàn thành với một lỗi.

Bởi vì lỗi đó được ném ra khỏi khối của nhóm, tất cả các nhiệm vụ trong nhóm sau đó sẽ bị ngầm hủy bỏ và sau đó được chờ đợi.

Cái này hoạt động giống như async-let.

Sự khác biệt đến khi nhóm của bạn đi ra khỏi phạm vi thông qua một lối thoát bình thường từ khối.

Sau đó, việc hủy bỏ không phải là ngầm định.

Hành vi này giúp bạn dễ dàng thể hiện mô hình tham gia ngã ba bằng cách sử dụng một nhóm nhiệm vụ, bởi vì các công việc sẽ chỉ được chờ đợi, không bị hủy bỏ.

Bạn cũng có thể hủy tất cả các tác vụ theo cách thủ công trước khi thoát khỏi khối bằng phương thức cancelAll của nhóm.

Hãy nhớ rằng bất kể bạn hủy một nhiệm vụ như thế nào, việc hủy bỏ sẽ tự động lan truyền xuống cây.

Nhiệm vụ Async-let và nhóm là hai loại nhiệm vụ cung cấp các nhiệm vụ có cấu trúc có phạm vi trong Swift.

Bây giờ, tôi sẽ giao mọi thứ cho Joe, người sẽ cho bạn biết về các nhiệm vụ phi cấu trúc.

Cảm ơn, Kavon.

Xin chào. Tôi là Joe.

Kavon đã chỉ cho bạn cách đồng thời có cấu trúc đơn giản hóa việc truyền lỗi, hủy và các sổ sách kế toán khác khi bạn thêm đồng thời vào một chương trình với hệ thống phân cấp rõ ràng cho các nhiệm vụ.

Nhưng chúng tôi biết rằng bạn không phải lúc nào cũng có hệ thống phân cấp khi bạn thêm nhiệm vụ vào chương trình của mình.

Swift cũng cung cấp các API tác vụ phi cấu trúc, giúp bạn linh hoạt hơn rất nhiều với chi phí cần quản lý thủ công nhiều hơn.

Có rất nhiều tình huống mà một nhiệm vụ có thể không rơi vào một hệ thống phân cấp rõ ràng.

Rõ ràng nhất, bạn có thể không có tác vụ mẹ nếu bạn đang cố gắng khởi chạy một tác vụ để thực hiện tính toán không đồng bộ từ mã không đồng bộ.

Ngoài ra, tuổi thọ bạn muốn cho một nhiệm vụ có thể không phù hợp với giới hạn của một phạm vi duy nhất hoặc thậm chí là một chức năng duy nhất.

Ví dụ, bạn có thể muốn bắt đầu một tác vụ để phản hồi một cuộc gọi phương thức đặt một đối tượng vào trạng thái hoạt động và sau đó hủy việc thực thi nó để phản hồi một cuộc gọi phương thức khác hủy kích hoạt đối tượng.

Điều này xuất hiện rất nhiều khi triển khai các đối tượng đại diện trong AppKit và UIKit.

Công việc giao diện người dùng phải diễn ra trên chủ đề chính và như phiên diễn viên Swift thảo luận, Swift đảm bảo điều này bằng cách khai báo các lớp giao diện người dùng thuộc về diễn viên chính.

Giả sử chúng ta có chế độ xem bộ sưu tập và chúng ta chưa thể sử dụng API nguồn dữ liệu chế độ xem bộ sưu tập.

Thay vào đó, chúng tôi muốn sử dụng chức năng fetchThumbnails mà chúng tôi vừa viết để lấy hình thu nhỏ từ mạng khi các mục trong chế độ xem bộ sưu tập được hiển thị.

Tuy nhiên, phương thức đại diện không đồng bộ, vì vậy chúng ta không thể chỉ chờ đợi một cuộc gọi đến một hàm không đồng bộ.

Chúng ta cần bắt đầu một nhiệm vụ cho điều đó, nhưng nhiệm vụ đó thực sự là một phần mở rộng của công việc mà chúng ta đã bắt đầu để đáp ứng với hành động của đại biểu.

Chúng tôi muốn nhiệm vụ mới này vẫn chạy trên diễn viên chính với ưu tiên giao diện người dùng.

Chúng tôi chỉ không muốn giới hạn tuổi thọ của nhiệm vụ với phạm vi của phương pháp đại diện duy nhất này.

Đối với những tình huống như thế này, Swift cho phép chúng tôi xây dựng một nhiệm vụ phi cấu trúc.

Hãy di chuyển phần không đồng bộ của mã vào một đóng và chuyển đóng đó để xây dựng một tác vụ không đồng bộ.

Bây giờ đây là những gì xảy ra trong thời gian chạy.

Khi chúng tôi đạt đến điểm tạo nhiệm vụ, Swift sẽ lên lịch chạy trên cùng một diễn viên với phạm vi gốc, đây là diễn viên chính trong trường hợp này.

Trong khi đó, quyền kiểm soát trả lại ngay lập tức cho người gọi.

Nhiệm vụ hình thu nhỏ sẽ chạy trên luồng chính khi có một lỗ mở để làm như vậy mà không ngay lập tức chặn luồng chính trên phương thức đại diện.

Xây dựng các nhiệm vụ theo cách này cho chúng ta một điểm giữa mã có cấu trúc và không có cấu trúc.

Một nhiệm vụ được xây dựng trực tiếp vẫn kế thừa tác nhân, nếu có, của bối cảnh được khởi chạy của nó, và nó cũng kế thừa mức độ ưu tiên và các đặc điểm khác của nhiệm vụ gốc, giống như một nhiệm vụ nhóm hoặc một tác vụ không đồng bộ sẽ làm.

Tuy nhiên, nhiệm vụ mới không được bao gồm.

Tuổi thọ của nó không bị ràng buộc bởi phạm vi nơi nó được ra mắt.

Nguồn gốc thậm chí không cần phải không đồng bộ.

Chúng ta có thể tạo ra một nhiệm vụ không có phạm vi ở bất cứ đâu.

Trong giao dịch cho tất cả sự linh hoạt này, chúng ta cũng phải quản lý thủ công những thứ mà đồng thời có cấu trúc sẽ xử lý tự động.

Việc hủy bỏ và lỗi sẽ không tự động lan truyền và kết quả của nhiệm vụ sẽ không được ngầm chờ đợi trừ khi chúng tôi thực hiện hành động rõ ràng để làm như vậy.

Vì vậy, chúng tôi đã bắt đầu một nhiệm vụ để tìm nạp hình thu nhỏ khi một mục chế độ xem bộ sưu tập được hiển thị và chúng tôi cũng nên hủy nhiệm vụ đó nếu mục đó được cuộn ra khỏi tầm nhìn trước khi hình thu nhỏ sẵn sàng.

Vì chúng tôi đang làm việc với một nhiệm vụ không có phạm vi, việc hủy bỏ đó không tự động.

Hãy thực hiện nó ngay bây giờ.

Sau khi chúng ta xây dựng nhiệm vụ, hãy lưu lại giá trị mà chúng ta nhận được.

Chúng ta có thể đặt giá trị này vào một từ điển được khóa bởi chỉ mục hàng khi chúng ta tạo nhiệm vụ để chúng ta có thể sử dụng nó sau này để hủy nhiệm vụ đó.

Chúng ta cũng nên xóa nó khỏi từ điển sau khi nhiệm vụ kết thúc để chúng ta không cố gắng hủy một nhiệm vụ nếu nó đã hoàn thành.

Lưu ý ở đây rằng chúng ta có thể truy cập cùng một từ điển bên trong và bên ngoài tác vụ không đồng bộ đó mà không cần trình biên dịch gắn cờ cuộc đua dữ liệu.

Lớp đại biểu của chúng tôi bị ràng buộc với diễn viên chính và nhiệm vụ mới kế thừa điều đó, vì vậy chúng sẽ không bao giờ chạy song song với nhau.

Chúng tôi có thể truy cập an toàn các thuộc tính được lưu trữ của các lớp ràng buộc diễn viên chính bên trong nhiệm vụ này mà không phải lo lắng về các cuộc đua dữ liệu.

Trong khi đó, nếu đại diện của chúng tôi sau đó được thông báo rằng cùng một hàng bảng đã bị xóa khỏi màn hình, thì chúng tôi có thể gọi phương thức hủy trên giá trị để hủy nhiệm vụ.

Vì vậy, bây giờ chúng tôi đã thấy cách chúng tôi có thể tạo các tác vụ phi cấu trúc chạy độc lập với phạm vi trong khi vẫn kế thừa các đặc điểm từ bối cảnh gốc của nhiệm vụ đó.

Nhưng đôi khi bạn không muốn kế thừa bất cứ điều gì từ bối cảnh gốc của mình.

Để linh hoạt tối đa, Swift cung cấp các nhiệm vụ tách biệt.

Giống như tên cho thấy, các nhiệm vụ tách rời độc lập với bối cảnh của chúng.

Chúng vẫn là những nhiệm vụ phi cấu trúc.

Cuộc đời của họ không bị ràng buộc bởi phạm vi nguồn gốc của họ.

Nhưng các nhiệm vụ tách biệt cũng không chọn bất cứ thứ gì khác từ phạm vi ban đầu của chúng.

Theo mặc định, chúng không bị ràng buộc trong cùng một diễn viên và không phải chạy ở cùng mức độ ưu tiên như nơi chúng được khởi chạy.

Các tác vụ tách rời chạy độc lập với các mặc định chung cho những thứ như ưu tiên, nhưng chúng cũng có thể được khởi chạy với các tham số tùy chọn để kiểm soát cách thức và địa điểm tác vụ mới được thực hiện.

Giả sử rằng sau khi chúng tôi tìm nạp hình thu nhỏ từ máy chủ, chúng tôi muốn ghi chúng vào bộ nhớ cache đĩa cục bộ để chúng tôi không truy cập lại mạng nếu chúng tôi cố gắng tìm nạp chúng sau này.

Bộ nhớ đệm không cần phải xảy ra trên diễn viên chính và ngay cả khi chúng tôi hủy tìm nạp tất cả các hình thu nhỏ, vẫn hữu ích khi lưu trữ bất kỳ hình thu nhỏ nào mà chúng tôi đã tìm nạp.

Vì vậy, hãy bắt đầu bộ nhớ đệm bằng cách sử dụng một nhiệm vụ tách rời.

Khi chúng tôi tách ra một nhiệm vụ, chúng tôi cũng linh hoạt hơn rất nhiều trong việc thiết lập cách thực hiện nhiệm vụ mới đó.

Bộ nhớ đệm nên xảy ra ở mức ưu tiên thấp hơn mà không can thiệp vào giao diện người dùng chính và chúng tôi có thể chỉ định mức độ ưu tiên nền khi chúng tôi tách nhiệm vụ mới này.

Hãy lên kế hoạch trước một chút ngay bây giờ.

Chúng ta nên làm gì trong tương lai nếu chúng ta có nhiều nhiệm vụ nền mà chúng ta muốn thực hiện trên hình thu nhỏ của mình?

Chúng tôi có thể tách rời nhiều nhiệm vụ nền hơn, nhưng chúng tôi cũng có thể sử dụng tính đồng thời có cấu trúc bên trong nhiệm vụ tách rời của mình.

Chúng ta có thể kết hợp tất cả các loại nhiệm vụ khác nhau với nhau để khai thác từng thế mạnh của chúng.

Thay vì tách một nhiệm vụ độc lập cho mọi công việc nền tảng, chúng ta có thể thiết lập một nhóm nhiệm vụ và sinh ra từng công việc nền tảng như một nhiệm vụ con vào nhóm đó.

Có một số lợi ích của việc làm như vậy.

Nếu chúng ta cần hủy nhiệm vụ nền trong tương lai, sử dụng nhóm nhiệm vụ có nghĩa là chúng ta có thể hủy tất cả các nhiệm vụ con chỉ bằng cách hủy nhiệm vụ tách biệt cấp cao nhất đó.

Việc hủy bỏ đó sau đó sẽ tự động lan truyền đến các nhiệm vụ con và chúng tôi không cần phải theo dõi một loạt các tay cầm.

Hơn nữa, các nhiệm vụ con tự động kế thừa quyền ưu tiên của cha mẹ chúng.

Để giữ tất cả công việc này trong nền, chúng ta chỉ cần nền tảng cho nhiệm vụ tách rời và điều đó sẽ tự động lan truyền đến tất cả các tác vụ con của nó, vì vậy chúng ta không cần phải lo lắng về việc quên đặt ưu tiên nền chuyển tiếp và vô tình bỏ đói công việc giao diện người dùng.

Tại thời điểm này, chúng tôi đã thấy tất cả các hình thức nhiệm vụ chính có trong Swift.

Async-let cho phép một số lượng cố định các tác vụ con được sinh ra dưới dạng các ràng buộc biến đổi, với khả năng tự động quản lý hủy bỏ và truyền lỗi nếu ràng buộc nằm ngoài phạm vi.

Khi chúng ta cần một số lượng động các nhiệm vụ con vẫn bị giới hạn trong một phạm vi, chúng ta có thể chuyển lên các nhóm nhiệm vụ.

Nếu chúng ta cần phá vỡ một số công việc không có phạm vi tốt nhưng vẫn liên quan đến nhiệm vụ ban đầu của nó, chúng ta có thể xây dựng các nhiệm vụ phi cấu trúc, nhưng chúng ta cần quản lý chúng theo cách thủ công.

Và để linh hoạt tối đa, chúng tôi cũng có các nhiệm vụ tách rời, đó là các nhiệm vụ được quản lý thủ công mà không kế thừa bất cứ điều gì từ nguồn gốc của chúng.

Các nhiệm vụ và tính năng đồng thời có cấu trúc chỉ là một phần của bộ tính năng đồng thời mà Swift hỗ trợ.

Hãy chắc chắn kiểm tra tất cả các cuộc nói chuyện tuyệt vời khác này để xem nó phù hợp với phần còn lại của ngôn ngữ như thế nào.

"Gặp gỡ không đồng bộ/chờ đợi trong Swift" cung cấp cho bạn thêm chi tiết về các hàm không đồng bộ, điều này cung cấp cho chúng tôi cơ sở có cấu trúc để viết mã đồng thời.

Các diễn viên cung cấp cách ly dữ liệu để tạo ra các hệ thống đồng thời an toàn trước các cuộc đua dữ liệu.

Xem phiên "Bảo vệ trạng thái có thể thay đổi với các diễn viên Swift" để tìm hiểu thêm về cách thực hiện.

Chúng tôi đã thấy các vòng lặp "for await" trên các nhóm tác vụ và đó chỉ là một ví dụ về AsyncSequence, cung cấp giao diện tiêu chuẩn để làm việc với các luồng dữ liệu không đồng bộ.

Phiên "Gặp gỡ AsyncSequence" đi sâu hơn vào các API có sẵn để làm việc với các chuỗi.

Các nhiệm vụ tích hợp với hệ điều hành cốt lõi để đạt được chi phí thấp và khả năng mở rộng cao, và phiên "Swift concurrency: Behind the scenes" cung cấp thêm chi tiết kỹ thuật về cách hoàn thành điều đó.

Tất cả các tính năng này kết hợp với nhau để giúp việc viết mã đồng thời trong Swift trở nên dễ dàng và an toàn, cho phép bạn viết mã tận dụng tối đa thiết bị của mình trong khi vẫn tập trung vào các phần thú vị của ứng dụng, suy nghĩ ít hơn về cơ chế quản lý các tác vụ đồng thời hoặc lo lắng về các lỗi tiềm ẩn do đa luồng gây

Cảm ơn bạn đã xem.

Tôi hy vọng bạn thích phần còn lại của hội nghị.

[Nhạc lạc quan].