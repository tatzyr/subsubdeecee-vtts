10157

Xin chào! Tên tôi là Egor, và hôm nay, tôi muốn nói với bạn về tất cả những cải tiến và tính năng mới trong Metal Debugger.

Năm nay, chúng tôi sẽ hỗ trợ nhiều tính năng Kim loại hơn, chẳng hạn như dò tia và con trỏ chức năng.

Chúng tôi đã thêm quy trình làm việc lập hồ sơ hoàn toàn mới, như dòng thời gian GPU và trạng thái hiệu suất GPU nhất quán, để giúp bạn tận dụng tối đa GPU trên các nền tảng của Apple.

Chúng tôi đã thực hiện các cải tiến đối với quy trình gỡ lỗi khác mà bạn biết và yêu thích, bao gồm hỗ trợ rộng hơn để xác thực đổ bóng và điều khiển chụp chính xác.

Chúng tôi cũng đang giới thiệu những tiến bộ trong nén kết cấu, mà đồng nghiệp Amanda của tôi sẽ nói về sau.

Đầu tiên, hãy nói về dò tia.

Năm ngoái, chúng tôi đã giới thiệu một API theo dõi tia kim loại mới và bây giờ, trong Xcode 13, chúng tôi hỗ trợ nó trong Trình gỡ lỗi kim loại, cùng với các con trỏ chức năng và bảng chức năng, mang lại sự linh hoạt cho bộ đổ bóng của bạn.

Và các thư viện động, cung cấp cho bạn một cách để xây dựng mã thư viện đổ bóng được rút ra và có thể tái sử dụng tốt.

Ngoài ra, để dò tia, chúng tôi đang giới thiệu một công cụ hoàn toàn mới, Trình xem cấu trúc gia tốc.

Hãy xem dấu vết tia trong Trình gỡ lỗi kim loại.

Tôi đã mở một dấu vết GPU của ứng dụng mẫu ModernRenderer.

Nó đã được sửa đổi để sử dụng dấu vết tia kim loại để đạt được các hiệu ứng như bóng tối và tắc nghẽn môi trường xung quanh.

Bộ mã hóa này tạo ra một bản đồ bóng theo dấu vết tia tuyệt đẹp.

Tôi đã chọn một cuộc gọi điều phối để bạn có thể thấy cấu trúc tăng tốc trong các tài nguyên bị ràng buộc.

Từ đây, tôi sẽ mở cấu trúc gia tốc để đi đến trình xem cấu trúc gia tốc mới của chúng tôi.

Tại đây, bạn có thể thấy hình học của cảnh quán rượu quen thuộc ở bên phải và đường viền của nó ở bên trái.

Nhấp vào một ví dụ trong cảnh sẽ chọn nó trong trình xem và cả trong phác thảo cảnh.

Bạn có thể xem ma trận biến đổi và các thuộc tính phiên bản khác bằng cách mở rộng nó.

Bạn cũng có thể chọn một hình học riêng lẻ bằng cách giữ phím Tùy chọn trong khi nhấp vào trình xem cảnh.

Điều này cũng sẽ chọn nó trong phác thảo cảnh và ngược lại.

Bạn cũng có thể thấy các chức năng giao nhau có liên quan được sử dụng với cấu trúc gia tốc ngay tại đây trong trình xem.

Nhưng Trình xem Cấu trúc Gia tốc có thể làm nhiều hơn là chỉ đơn giản là hiển thị hình học.

Ở dưới cùng bên phải, bạn cũng sẽ tìm thấy một số chế độ tô sáng sẽ giúp bạn hình dung một số thuộc tính của cảnh của mình.

Ví dụ, chế độ di chuyển âm lượng giới hạn có thể giúp bạn hình dung sự phức tạp của hình học.

Màu xanh lam đậm hơn cho thấy các khu vực mà hệ thống phân cấp khối lượng giới hạn đắt hơn về mặt tính toán để đi qua so với các phần khác của nó.

Đối với tất cả các chế độ, chúng tôi có chế độ xem nhỏ này hiển thị thông tin liên quan khi bạn di chuột qua các phần khác nhau trong cảnh của mình.

Ở đây, nó hiển thị số lần đi qua hộp giới hạn và giao lộ nguyên thủy.

Để cung cấp cho bạn sự linh hoạt hơn, chúng tôi cũng bao gồm các cài đặt duyệt.

Với chúng, bạn có thể định cấu hình trình xem cấu trúc gia tốc, sử dụng các thuộc tính tương tự mà bạn có thể tìm thấy trên một đối tượng liên ngành bên trong bộ đổ bóng của mình.

Có rất nhiều điều để nói khi nói đến dò tia.

Nếu bạn muốn tìm hiểu thêm, hãy xem phiên năm nay "Khám phá kết xuất lai với truy tìm tia kim loại." Và nếu bạn muốn biết thêm về API nói chung, hãy xem bài nói chuyện năm ngoái, "Khám phá dò dò tia bằng Kim loại." Tiếp theo, hãy nói về hồ sơ.

Lập hồ sơ ứng dụng của bạn là một bước quan trọng và chúng tôi đã có rất nhiều công cụ tuyệt vời theo ý của bạn.

Ví dụ: sử dụng dấu vết hệ thống Metal trong các công cụ, bạn có thể khám phá chế độ xem dòng thời gian hiển thị thời lượng CPU và GPU cho các giai đoạn kết xuất, bộ đếm GPU và dòng thời gian đổ bóng khác nhau.

Và trong Trình gỡ lỗi kim loại, bộ đếm GPU hiển thị một bộ đo phong phú trực tiếp từ GPU, cho mỗi bộ mã hóa hoặc mỗi lần vẽ.

Cả hai đều là những công cụ tuyệt vời, cung cấp các chế độ xem bổ sung về hiệu suất ứng dụng của bạn.

Nhưng việc sắp xếp những quan điểm đó có thể cần thêm nỗ lực.

Vì vậy, đó là lý do tại sao tôi rất vui được giới thiệu cho bạn một công cụ lập hồ sơ GPU mới kết hợp dấu vết hệ thống Kim loại và bộ đếm GPU trong một trải nghiệm thống nhất.

Giới thiệu Dòng thời gian GPU trong Trình gỡ lỗi kim loại, một công cụ mới được thiết kế đặc biệt cho GPU của Apple.

Nó cung cấp cho bạn một góc nhìn khác về dữ liệu hiệu suất và nó có thể giúp bạn tìm ra các điểm tối ưu hóa tiềm năng trong ứng dụng của mình.

Hãy cùng xem qua phần bổ sung mới nhất này cho bộ công cụ lập hồ sơ của chúng tôi.

Dòng thời gian GPU có sẵn dưới bảng Hiệu suất.

Bạn có thể tìm thấy nó trong trình duyệt gỡ lỗi sau khi bạn đã chụp một khung hình từ ứng dụng của mình.

Khi bạn mở bảng Hiệu suất, bạn sẽ được chào đón bởi một tập hợp các bản nhạc khác nhau được bố trí song song.

Trước khi chúng ta tiếp tục, tôi muốn giải thích tại sao các bản nhạc bộ mã hóa lại song song.

Trên GPU của Apple, các giai đoạn đỉnh và phân đoạn của các đường kết xuất khác nhau, và cả các công văn tính toán, có thể chạy đồng thời.

Điều này được kích hoạt bởi kiến trúc GPU của Apple và sử dụng kỹ thuật kết xuất được gọi là "kết xuất hoãn dựa trên gạch". Chúng tôi nghĩ rằng điều quan trọng là bạn có thể thấy bản chất song song này của GPU Apple trong ngữ cảnh ứng dụng của bạn.

Và đó là nơi Dòng thời gian GPU có ích.

Ở trên cùng, bạn có thể thấy các mốc thời gian của bộ mã hóa Vertex, Fragment và Compute, với mỗi bộ mã hóa hiển thị các tài nguyên mà nó sử dụng trong nháy mắt.

Bên dưới các bộ mã hóa, bạn sẽ tìm thấy các bộ đếm Công suất, Băng thông và bộ giới hạn.

Chúng ta hãy xem xét kỹ hơn dòng thời gian của bộ mã hóa.

Bạn có thể mở rộng từng bản nhạc bộ mã hóa để xem dòng thời gian đổ bóng tổng hợp.

Mở rộng dòng thời gian hơn nữa sẽ hiển thị cho bạn từng bộ đổ bóng riêng lẻ theo kiểu giống như thác nước.

Thật dễ dàng để điều hướng các bộ mã hóa.

Chọn một bản nhạc bộ mã hóa để xem danh sách tất cả các bộ mã hóa ở bên phải.

Ở đó, bạn có thể sắp xếp chúng theo thời lượng trung bình của chúng.

Nhấp vào một bộ mã hóa riêng lẻ trong dòng thời gian sẽ hiển thị cho bạn thêm thông tin về nó trong thanh bên.

Ví dụ, ở đây bạn có thể thấy các tệp đính kèm cho bộ mã hóa lệnh kết xuất này.

Bạn có thể nhận thấy rằng khi bạn chọn một bộ mã hóa, phạm vi thời gian nơi nó hoạt động sẽ được tô sáng trên tất cả các bản nhạc.

Với điều này, bạn có thể dễ dàng kiểm tra xem các giai đoạn khác nhau chồng chéo như thế nào và cũng tương quan các giá trị truy cập cho bộ mã hóa.

Tránh xa chế độ xem dòng thời gian, bạn có thể truy cập bộ đếm GPU bằng cách chuyển sang tab Bộ đếm hoặc bạn chỉ cần mở menu ngữ cảnh của bộ mã hóa và hiển thị nó trong Bộ đếm từ đó.

Và đây chỉ là một cái nhìn sơ lược về Dòng thời gian GPU.

Để tìm hiểu thêm về cách sử dụng Trình gỡ lỗi kim loại để hiểu hiệu suất ứng dụng của bạn, hãy xem phiên năm nay "Tối ưu hóa các trò chơi cao cấp cho GPU của Apple". Bây giờ tôi đã chỉ cho bạn một cách mới để lập hồ sơ ứng dụng của bạn, điều quan trọng là phải hiểu rằng hiệu suất của nó phụ thuộc vào một số yếu tố.

Khi chúng ta đang nói về Metal, trạng thái hiệu suất GPU là một yếu tố rất quan trọng.

Nó được quản lý bởi hệ điều hành, điều này sẽ làm giảm hoặc tăng trạng thái tùy thuộc vào nhiệt độ thiết bị, cài đặt hệ thống, sử dụng GPU và các thông số khác.

Những thay đổi trạng thái này có thể ảnh hưởng đến kết quả hồ sơ mà bạn đang thấy.

Năm nay, chúng tôi đang giới thiệu những cách mới để bạn lập hồ sơ ứng dụng của mình với kết quả nhất quán hơn.

Chúng tôi đã thêm các cách để bạn xem và thay đổi trạng thái hiệu suất GPU trên toàn bộ bộ công cụ Metal của chúng tôi, bắt đầu với nhạc cụ và dấu vết hệ thống Metal để ghi lại hiệu suất trực tiếp, tiếp tục với Trình gỡ lỗi kim loại, để lập hồ sơ dấu vết GPU và cuối cùng là các điều kiện thiết bị trong Xcode, cho các trường hợp

Đầu tiên, hãy nói về Nhạc cụ.

Năm nay, chúng tôi đã thêm một bản nhạc cho trạng thái hiệu suất GPU vào dấu vết hệ thống Metal.

Sử dụng nó kết hợp với các bản nhạc khác để tương quan hiệu suất ứng dụng của bạn với trạng thái hiệu suất của thiết bị.

Tuy nhiên, hãy nhớ rằng việc có thể nhìn thấy trạng thái hiệu suất chỉ là một phần của phương trình.

Để có được kết quả hồ sơ nhất quán và có thể tái tạo, bạn cũng cần một cách để đặt trạng thái hiệu suất GPU trên thiết bị.

Điểm mới trong năm nay là khả năng tạo ra trạng thái hiệu suất GPU cụ thể khi bạn đang ghi lại một dấu vết trong Instruments.

Chỉ cần vào Tùy chọn ghi âm và chọn trạng thái biểu diễn trước khi bắt đầu ghi âm.

Sau đó, bạn có thể ghi lại dấu vết hiệu suất như bình thường.

Các nhạc cụ sẽ tạo ra trạng thái bạn đã chọn trong suốt thời gian theo dõi, nếu thiết bị có thể duy trì nó.

Đôi khi, bạn có thể cần kiểm tra xem bản nhạc Instruments hiện có có trạng thái hiệu suất GPU gây ra trong quá trình ghi hay không.

Bạn có thể tìm thấy thông tin này trong phần "Cài đặt ghi âm" trong cửa sổ bật lên thông tin.

Và bây giờ, bạn đã biết cách xem và tạo trạng thái hiệu suất GPU từ Instruments.

Cách thứ hai để tận dụng trạng thái hiệu suất GPU nhất quán là sử dụng Trình gỡ lỗi kim loại.

Theo mặc định, khi bạn chụp dấu vết GPU của ứng dụng của mình, Xcode sẽ lập hồ sơ dấu vết cho bạn.

Và nó sẽ làm như vậy bằng cách sử dụng cùng một trạng thái hiệu suất mà thiết bị đã ở tại thời điểm chụp.

Trạng thái đó có thể đã dao động, tùy thuộc vào các yếu tố mà chúng tôi đã đề cập trước đó.

Thay vào đó, nếu bạn muốn tự mình chọn một trạng thái hiệu suất nhất định, hãy sử dụng nút Đồng hồ bấm giờ trong thanh gỡ lỗi.

Sau khi bạn thực hiện lựa chọn, Metal Debugger sẽ lập hồ sơ lại dấu vết GPU của bạn.

Sau khi hoàn thành, nút được tô sáng để phản ánh rằng trạng thái hiệu suất nhất quán đã đạt được.

Ngoài ra, phần "Hiệu suất" trên trang tóm tắt hiện hiển thị dữ liệu hiệu suất mới trong nháy mắt, cũng như trạng thái hiệu suất đã chọn.

Hai cách tiếp cận này được gắn với bộ công cụ Kim loại.

Nhưng đôi khi, bạn có thể muốn tạo ra trạng thái hiệu suất nhất quán bên ngoài quy trình làm việc lập hồ sơ.

Cách thứ ba để thiết lập trạng thái hiệu suất GPU là thông qua các điều kiện Thiết bị.

Nếu bạn muốn kiểm tra xem ứng dụng của mình hoạt động như thế nào dưới các trạng thái hiệu suất GPU khác nhau, đây là tùy chọn dành cho bạn.

Trong Xcode 13, chúng tôi đã thêm điều kiện thiết bị trạng thái hiệu suất GPU.

Nó buộc hệ điều hành sử dụng trạng thái được chỉ định trên một thiết bị, miễn là nó có thể duy trì nó và nó vẫn được kết nối với Xcode.

Bạn có thể thêm điều kiện này từ Xcode, nếu bạn vào Window, Devices and Simulators, chọn thiết bị của bạn ở đó, sau đó cuộn đến phần "Điều kiện thiết bị" và thêm điều kiện "Trạng thái hiệu suất GPU" với mức mong muốn.

Nhấn Bắt đầu khi bạn muốn áp dụng thay đổi trạng thái hiệu suất GPU trên thiết bị.

Sau đó, khi bạn hoàn thành, nhấn Dừng lại.

Những cách mới này để xem và thay đổi trạng thái hiệu suất GPU ngay từ các công cụ của chúng tôi sẽ giúp bạn lập hồ sơ và kiểm tra các ứng dụng của mình.

Và tôi nghĩ bạn sẽ thích những bổ sung và cải tiến mới nhất của chúng tôi đối với quy trình làm việc lập hồ sơ và tôi hy vọng chúng sẽ giúp bạn làm cho ứng dụng của mình tốt hơn nữa.

Bây giờ, hãy nói về một số cải tiến khác mà chúng tôi sẽ mang đến cho Metal Debugger trong năm nay.

Đầu tiên, tôi sẽ cho bạn biết về những cải tiến đối với xác thực đổ bóng.

Sau đó, tôi sẽ chỉ cho bạn các điều khiển chụp chính xác.

Và sau đó, tôi sẽ cho bạn xem xét quy trình làm việc trạng thái đường ống mới.

Cuối cùng, tôi muốn giới thiệu hai tính năng mới liên quan đến gỡ lỗi và lập hồ sơ đổ bóng, thông tin gỡ lỗi riêng biệt và gỡ lỗi đổ bóng chọn lọc.

Năm ngoái, trong Xcode 12, chúng tôi đã giới thiệu xác thực đổ bóng, giúp bạn chẩn đoán lỗi thời gian chạy trên GPU, như truy cập ngoài giới hạn và các lỗi khác.

Hãy nhớ rằng nếu xác thực đổ bóng được bật và bộ mã hóa gây ra lỗi xác thực, bạn sẽ gặp sự cố thời gian chạy trong trình điều hướng sự cố, hiển thị cả dấu vết ngược CPU và GPU cho cuộc gọi bị lỗi.

Chúng tôi đã có một phiên đề cập đến điều này chi tiết hơn, vì vậy để tìm hiểu thêm về cách sử dụng xác thực đổ bóng, hãy xem bài nói chuyện năm ngoái, được gọi là "Gỡ lỗi phía GPU trong Metal". Năm nay, chúng tôi đang mở rộng xác thực đổ bóng để hỗ trợ nhiều trường hợp sử dụng hơn, làm cho nó có sẵn khi bạn đang sử dụng bộ đệm lệnh gián tiếp, thư viện động, con trỏ và bảng chức năng.

Điều này sẽ cho phép bạn sử dụng xác thực đổ bóng rộng rãi hơn trong toàn bộ ứng dụng của mình trong quá trình phát triển.

Tiếp theo, tôi muốn cho bạn thấy các điều khiển chụp chính xác mới của chúng tôi.

Nhưng trước tiên, hãy nhìn vào nút Chụp, bây giờ trông giống như logo Kim loại.

Nó nằm trên thanh gỡ lỗi, ở cuối cửa sổ Xcode.

Khi bạn nhấp vào nó, một menu mới sẽ xuất hiện.

Trình đơn này cho phép bạn chọn một phạm vi để chụp.

Mặc định là chụp một khung hình, nhưng bạn có thể chỉ định số lượng bạn muốn chụp, tối đa năm.

Bạn cũng có thể chọn chụp một số bộ đệm lệnh có cùng thiết bị mẹ hoặc hàng đợi lệnh, cũng như những bộ đệm trình bày một lớp Kim loại nhất định và thậm chí cả phạm vi tùy chỉnh mà bạn có thể xác định trong mã ứng dụng của mình bằng MTLCaptureScope API.

Những điều khiển mới này cung cấp cho bạn sức mạnh đáng kinh ngạc ngay lập tức trong việc quyết định cách thức và thời điểm các cuộc gọi Metal của bạn được ghi lại.

Tiếp theo, hãy nói về các thư viện Metal và các trạng thái đường ống.

Đây là những khối xây dựng thiết yếu của ứng dụng Metal của bạn.

Và trong Xcode 13, chúng tôi đã giúp việc kiểm tra tất cả các trạng thái đường ống và thư viện mà ứng dụng của bạn đang sử dụng trở nên dễ dàng hơn bao giờ hết.

Bây giờ, hãy xem nó trông như thế nào trong thực tế.

Ở đây, tôi đã ghi lại một dấu vết GPU từ một ứng dụng mẫu ModernRenderer.

Tôi muốn xem trạng thái đường ống GBuffer hoạt động như thế nào, vì vậy tôi đã chọn cuộc gọi rút thăm này.

Nếu tôi nhìn vào các tài nguyên bị ràng buộc, bây giờ tôi có thể thấy trạng thái đường ống đã được sử dụng.

Mở nó đưa tôi đến Pipeline State Viewer.

Từ đây, tôi có thể kiểm tra các chức năng và xem các thuộc tính khác mà trạng thái đường ống được tạo ra.

Hơn nữa, từ trình xem, tôi có thể kiểm tra dữ liệu hiệu suất được liên kết với trạng thái hoặc tôi có thể truy cập Trình xem bộ nhớ và hiển thị trạng thái ở đó.

Trong Xcode 13, Trình xem bộ nhớ hiện hiển thị lượng bộ nhớ mà các trạng thái đường ống đang chiếm trong ứng dụng của bạn.

Đây chỉ là một số bổ sung giúp kiểm tra trạng thái đường ống trên Trình gỡ lỗi kim loại dễ dàng hơn khi bạn đang xem dấu vết GPU của ứng dụng của mình.

Tiếp theo, hãy nói về gỡ lỗi và lập hồ sơ đổ bóng trong Trình gỡ lỗi kim loại.

Ngay bây giờ, nếu bạn muốn sử dụng các tính năng này, bạn có hai lựa chọn.

Tùy chọn đầu tiên là biên dịch thư viện của bạn từ mã nguồn khi ứng dụng đang chạy.

Một lựa chọn thứ hai, tốt hơn là xây dựng các tệp Metallib với các nguồn được nhúng ngoại tuyến và sau đó tải chúng trong thời gian chạy.

Nhưng sau đó, các quy tắc của App Store không cho phép bạn xuất bản các ứng dụng của mình với các Metallibs gỡ lỗi này.

Tất cả điều đó có nghĩa là nếu bạn biên dịch các thư viện của mình ngoại tuyến và bạn muốn có thể gỡ lỗi các trình đổ bóng của mình, bạn phải biên dịch chúng hai lần: một lần với các nguồn được nhúng, để sử dụng trong quá trình phát triển và một lần không có nguồn, để phân phối.

Năm nay, chúng tôi đang thay đổi điều đó.

Bây giờ bạn có thể tạo một tệp riêng biệt với các nguồn và thông tin gỡ lỗi khác trong khi biên dịch Metallib.

Các tệp này có phần mở rộng Metallibsym và chúng cho phép bạn gỡ lỗi và đổ bóng hồ sơ mà không cần nhúng thông tin bổ sung vào chính thư viện.

Lợi ích quan trọng nhất của việc có chúng riêng biệt, là bây giờ bạn không cần phải có hai phiên bản của cùng một Metallib.

Một lợi ích khác là với các tệp Metallibsym này, giờ đây bạn sẽ có thể gỡ lỗi các trình đổ bóng ngay cả trong các phiên bản phát hành của ứng dụng mà không cần phải xâm phạm các nguồn đổ bóng của bạn.

Tôi sẽ chỉ cho bạn một ví dụ về cách biên dịch tệp nguồn đổ bóng thành Metallib với tệp Metallibsym cùng với nó.

Tôi sẽ bắt đầu với lệnh đầu cuối xcrun biên dịch Metallib như bình thường.

Để tạo tệp Metallibsym, tôi chỉ cần thêm cờ "nguồn bản ghi" với tùy chọn "phẳng", sau đó chạy trình biên dịch.

Bây giờ, khi tôi cố gắng gỡ lỗi một bộ đổ bóng đã được biên dịch với một tệp thông tin gỡ lỗi riêng biệt, tôi sẽ được nhắc nhập nó.

Nhấp vào Nhập Nguồn sẽ mở ra một hộp thoại liệt kê tất cả các thư viện và liệu chúng có được nhập tệp nguồn hay không.

Từ đây, tôi có thể nhập bất kỳ tệp Metallibsym nào và sau khi nhập, các thư viện và nguồn của chúng sẽ được khớp tự động.

Khi tôi nhập xong, tôi có thể đóng hộp thoại, và bây giờ tôi có thể xem các nguồn cho đổ bóng và gỡ lỗi nó.

Có một cải tiến gỡ lỗi cuối cùng mà tôi muốn cho bạn thấy.

Nó được gọi là "gỡ lỗi đổ bóng chọn lọc." Nếu ứng dụng của bạn sử dụng bộ đổ bóng lớn, bạn có thể nhận thấy rằng việc gỡ lỗi bộ đổ bóng có thể mất một lúc để bắt đầu.

Để giúp đỡ trong những trường hợp như vậy, năm nay, chúng tôi đang đưa ra gỡ lỗi đổ bóng có chọn lọc.

Nó giúp bạn thu hẹp phạm vi gỡ lỗi, vì vậy bạn có thể gỡ lỗi bộ đổ bóng của mình nhanh hơn.

Hãy xem nó hoạt động với một trong những bộ đổ bóng lớn như vậy.

Tôi muốn gỡ lỗi GPU ASTCDecoder này.

Tôi biết rằng nếu tôi cố gắng gỡ lỗi toàn bộ hạt nhân này, Shader Debugger sẽ mất nhiều thời gian để bắt đầu.

Tôi không muốn đợi lâu như vậy, vì vậy thay vào đó, tôi có thể thu hẹp phạm vi gỡ lỗi xuống chỉ hàm này, decodeIntegerSequence.

Để làm như vậy, tôi có thể nhấp chuột phải vào nó và chọn Chức năng gỡ lỗi.

Điều này mở ra trình đơn "chức năng để gỡ lỗi", với phạm vi chức năng đã được chọn.

Bây giờ, trình gỡ lỗi sẽ bắt đầu gần như ngay lập tức.

Gỡ lỗi bộ đổ bóng có chọn lọc là một cách tuyệt vời để xác định lỗi trong bộ đổ bóng lớn một cách nhanh chóng.

Đây là tất cả những cải tiến công cụ kim loại mà tôi muốn cho bạn thấy hôm nay.

Và bây giờ, Amanda sẽ cho bạn biết về những tiến bộ mà chúng tôi đã đạt được trong việc nén kết cấu.

Amanda?

Cảm ơn, Egor.

Tôi sẽ hướng dẫn bạn các bản cập nhật mà chúng tôi đã thực hiện trong năm nay cho các công cụ nén kết cấu.

Trước khi đi sâu vào các công cụ, tôi sẽ thảo luận ngắn gọn về những điều cơ bản về nén kết cấu trên nền tảng Apple.

Nén kết cấu, trong trường hợp này, là nén dữ liệu kết cấu có tốc độ cố định, mất dữ liệu.

Điều này chủ yếu nhằm mục đích nén ngoại tuyến dữ liệu kết cấu tĩnh, chẳng hạn như đề can hoặc bản đồ thông thường.

Mặc dù bạn có thể nén dữ liệu kết cấu động trong thời gian chạy, nhưng đó không phải là điều tôi đề cập đến hôm nay.

Hầu hết việc nén kết cấu hoạt động bằng cách tách kết cấu thành các khối và nén từng khối dưới dạng một cặp màu.

Cặp này xác định một bảng màu được bản địa hóa, bao gồm các màu khác được nội suy từ các điểm cuối này và chỉ mục trên mỗi pixel chọn từ bảng màu này.

Mỗi định dạng có những điểm mạnh khác nhau phù hợp với các loại dữ liệu kết cấu khác nhau.

GPU của Apple cũng hỗ trợ nén bộ đệm khung không mất dữ liệu bắt đầu trong các thiết bị A12 của chúng tôi và rất phù hợp để tối ưu hóa băng thông.

Hãy xem phiên năm ngoái "Tối ưu hóa các ứng dụng và trò chơi Metal với bộ đếm GPU" để tìm hiểu thêm về cách đo băng thông bộ nhớ mà GPU đang sử dụng cho ứng dụng của bạn.

Một lựa chọn khác là thực hiện nén không mất dữ liệu các tệp kết cấu trên phần nén kết cấu GPU mà tôi đang đề cập trong bài thuyết trình này.

Điều này có thể giúp bạn giảm thêm kích thước tải xuống ứng dụng của bạn.

Bây giờ tôi đã xác định nén kết cấu cho bài nói chuyện này, tôi sẽ nói về những lợi ích mà nén kết cấu có thể mang lại cho ứng dụng của bạn.

Nén kết cấu là một bước quan trọng trong sự phát triển ứng dụng của bạn.

Nói chung, hầu hết dấu chân bộ nhớ của trò chơi bao gồm các kết cấu.

Sử dụng nén kết cấu cho phép bạn tải nhiều kết cấu hơn vào bộ nhớ và sử dụng các kết cấu chi tiết hơn để tạo ra các trò chơi trực quan hấp dẫn hơn.

Nén cũng có thể cho phép bạn giảm kích thước và dung lượng bộ nhớ của ứng dụng.

Bây giờ tôi đã đề cập đến những điều cơ bản, tôi sẽ thảo luận về tình trạng hiện tại của các công cụ nén kết cấu trên nền tảng Apple.

TextureTool hiện có trong iOS SDK có một đường ống tương đối đơn giản.

TextureTool đọc hình ảnh đầu vào, tạo mipmap nếu muốn, nén kết cấu, chặn từng khối, sau đó ghi kết quả vào tệp đầu ra mới.

Nhưng khi các thuật toán đồ họa tăng độ phức tạp, kết cấu cần xử lý nâng cao hơn.

Cốt lõi của các quy trình này là thực hiện các thao tác trong không gian màu chính xác, đồng thời giảm thiểu việc làm tròn từ các phép biến đổi giữa các độ chính xác số.

Hiểu được điều này, chúng tôi đã thiết kế một công cụ nén mới có tên là TextureConverter để xử lý sự gia tăng cần thiết trong độ tinh vi xử lý kết cấu và cung cấp cho bạn quyền truy cập vào một loạt các tùy chọn mới.

Chúng ta hãy xem xét kỹ hơn cách chúng ta đã cải tiến quy trình xử lý kết cấu trên các nền tảng của Apple.

Đường ống xử lý kết cấu đã được xây dựng lại từ đầu để cung cấp cho bạn quyền truy cập vào đường ống xử lý kết cấu đầy đủ tính năng với TextureConverter.

TextureConverter tận dụng một bộ máy nén được công nhận trong ngành để hỗ trợ một loạt các định dạng nén và cung cấp cho bạn tùy chọn để đánh đổi giữa tốc độ nén và chất lượng hình ảnh.

Bạn có thể chỉ định sử dụng máy nén nào hoặc cho phép TextureConverter chọn dựa trên định dạng nén, mức chất lượng và các tùy chọn khác.

Mỗi giai đoạn hiện có thể được bạn cấu hình đầy đủ và xử lý kết cấu nhận thức được gamma.

Để hỗ trợ tích hợp vào tất cả các đường ống nội dung của bạn, TextureConverter có sẵn cho cả macOS và Windows, và được tối ưu hóa để sử dụng với Apple Silicon.

Hãy bước qua từng giai đoạn của đường ống mở rộng, bắt đầu với gamma.

Hiệu chỉnh gamma là một hoạt động phi tuyến để mã hóa và giải mã độ sáng trong hình ảnh.

Kết cấu có thể được mã hóa trong nhiều không gian gamma.

Sự lựa chọn tốt nhất phụ thuộc vào loại dữ liệu mà kết cấu đại diện.

Hầu hết dữ liệu trực quan, chẳng hạn như đề can hoặc bản đồ ánh sáng, hoạt động tốt nhất khi được mã hóa trong không gian phi tuyến tính, như sRGB.

Dữ liệu phi trực quan, giống như bản đồ thông thường, nên được mã hóa trong không gian tuyến tính.

Sự lựa chọn này mang lại cho bạn độ chính xác cao hơn trong các vùng tối nơi cần thiết.

Dữ liệu phi trực quan, giống như bản đồ thông thường, nên được mã hóa trong không gian tuyến tính.

Việc nén nên được thực hiện trong không gian màu mục tiêu của bạn, được chỉ định bằng các tùy chọn "gamma_in" và "gamma_out".

Bạn có thể nhập giá trị float cho không gian gamma tuyến tính hoặc sử dụng chuỗi "sRGB" để chỉ định không gian màu đó.

Bạn cũng có thể linh hoạt sử dụng các tùy chọn này để chuyển đổi sang một không gian mục tiêu khác.

Các hoạt động khác, chẳng hạn như tạo mipmap, nên được thực hiện trong không gian tuyến tính.

Tôi sẽ đi qua các giai đoạn xử lý không gian tuyến tính ngay bây giờ.

Bây giờ đầu vào đã được chuyển đổi thành không gian gamma tuyến tính, các hoạt động không gian tuyến tính được thực hiện trước khi kết cấu đầu vào được chuyển đổi thành không gian gamma mục tiêu được chỉ định.

Ba giai đoạn là biến đổi vật lý, tạo mipmap và xử lý alpha, và một số trong số này có các giai đoạn con.

Tôi sẽ bắt đầu với các biến đổi vật lý.

Bằng cách xác định kích thước tối đa trong bất kỳ trục nào, bạn có thể thu nhỏ hình ảnh của mình khi bạn cần cho mipmap cấp cao nhất của mình.

Trong giai đoạn này, bạn cũng có quyền kiểm soát bộ lọc thay đổi kích thước và thay đổi kích thước chế độ làm tròn.

Các tùy chọn bộ lọc thay đổi kích thước sử dụng các thuật toán khác nhau để giúp bạn giảm độ mờ của mipmap khi chúng giảm kích thước kích thước.

Thay đổi kích thước chế độ tròn được sử dụng kết hợp với max_extent khi thay đổi kích thước hình ảnh của bạn.

Nếu vượt quá max_extent, hình ảnh nguồn sẽ được thay đổi kích thước bằng cách duy trì khía cạnh của hình ảnh gốc.

Chế độ vòng được chỉ định sẽ được sử dụng khi tìm kích thước mục tiêu.

Nếu bạn không chắc chắn nên sử dụng bộ lọc thay đổi kích thước hoặc chế độ làm tròn nào, chúng tôi đã chọn mặc định hoạt động tốt trong hầu hết các trường hợp.

Và các tùy chọn lật trong giai đoạn này cung cấp cho bạn quyền kiểm soát các phép biến đổi tuyến tính trên các trục X, Y và Z.

Sau khi biến đổi là tạo mipmap, được sử dụng trong phần lớn các tình huống xử lý kết cấu phổ biến.

Mipmaps là một chuỗi hình ảnh được tính toán trước làm giảm độ phân giải trên chuỗi, được sử dụng để tăng tốc độ kết xuất và giảm răng cưa.

Chiều cao và chiều rộng của mỗi cấp độ nhỏ hơn hai cấp độ so với cấp độ trước đó.

Khi tùy chỉnh tạo mipmap, hãy chỉ định số lượng tối đa bạn muốn và bộ lọc mip nào sẽ sử dụng.

TextureConverter mặc định là lọc Kaiser, với các tùy chọn lọc "hộp" và "tam giác".

Giai đoạn cuối cùng trong xử lý không gian tuyến tính là xử lý alpha.

Nếu alpha to coverage được bật, điều này được áp dụng trước, sử dụng giá trị tham chiếu alpha được chỉ định.

Alpha to coverage thay thế pha trộn alpha bằng mặt nạ che phủ.

Khi sử dụng kết cấu khử răng cưa hoặc bán trong suốt, điều này mang lại cho bạn độ trong suốt độc lập với thứ tự và là một công cụ đặc biệt hữu ích để hiển thị cây xanh dày đặc trong trò chơi của bạn.

Sau đó, tùy chọn loại bỏ, bảo quản hoặc nhân trước kênh alpha được trình bày.

Trong alpha nhân trước, các điểm ảnh trong suốt một phần của hình ảnh của bạn sẽ được nhân trước với màu thảm.

Vào cuối các giai đoạn xử lý không gian tuyến tính, chúng tôi đã sẵn sàng quay trở lại không gian gamma mục tiêu và nén các mức mip đã xử lý.

Bước cuối cùng trong xử lý kết cấu là nén.

Giai đoạn nén có thể được chia thành hai giai đoạn con, ánh xạ kênh và mã hóa.

Ánh xạ kênh là một kỹ thuật để tối ưu hóa các thuật toán nén kết cấu mục đích chung cho các loại dữ liệu cụ thể.

Chỉ định ánh xạ kênh trong TextureConverter là tùy chọn.

Nếu bạn muốn sử dụng nó, TextureConverter hiện hỗ trợ hai chế độ ánh xạ kênh, mã hóa RGBM và mã hóa bản đồ thông thường.

Tôi sẽ đề cập đến cả hai định dạng này sâu hơn, bắt đầu với mã hóa RGBM.

Mã hóa RGBM là một kỹ thuật để nén dữ liệu HDR ở định dạng LDR bằng cách lưu trữ hệ số nhân trong kênh alpha và chia tỷ lệ các kênh RGB bằng hệ số nhân này.

Đây là một ví dụ về hình ảnh HDR của một lớp học.

Và đây là cùng một hình ảnh lớp học một lần nữa với hệ số nhân được lưu trữ trong kênh alpha có thể nhìn thấy ở thang độ xám.

Tôi sẽ chỉ cho bạn cách tính hệ số nhân để mã hóa thành RGBM bằng một ví dụ mã.

EncodeRGBM là một hàm mã giả đơn giản mà tôi sẽ hướng dẫn bạn để giúp bạn hiểu cơ chế mã hóa thành RGBM.

Đoạn mã này bao gồm việc sử dụng RGBM_Range, tham số hoàn toàn mới để đặt phạm vi của RGBM và mặc định thành 6.0.

Để tính toán giá trị alpha RGBM, hệ số nhân, trước tiên, tôi sẽ xác định mức tối đa của các kênh màu đỏ, xanh lá cây và xanh dương của kết cấu đầu vào.

Điều này được thực hiện với chức năng max3 của Metal.

Sau đó mức tối đa này được chia cho RGBM_Range.

Để tính toán các giá trị kênh màu đỏ, xanh lá cây và xanh dương của RGBM được mã hóa, trước tiên, hệ số nhân được tính toán trước đó được nhân lại với RGBM_Range, được sử dụng để chia tỷ lệ giá trị lưu trữ trong kênh alpha.

Sau đó, kết cấu đầu vào được chia cho giá trị hệ số nhân cuối cùng.

Để giải mã RGBM trong bộ đổ bóng của bạn, bạn nhân RGB của mẫu với alpha và hệ số cố định, như tôi đã chỉ cho bạn trong hàm mã hóa.

Tôi sẽ xem qua đoạn mã DecodeRGBM để chỉ cho bạn cách thực hiện việc này.

Hệ số chia tỷ lệ được tính toán lại bằng cách nhân kênh alpha RGBM, nơi hệ số nhân được lưu trữ, với RGBM_Range.

RGB của kết cấu ban đầu được tính bằng cách nhân mẫu RGBM với hệ số nhân được tính toán.

Bây giờ tôi đã giới thiệu cho bạn mã hóa RGBM, tôi sẽ chuyển sang mã hóa bản đồ bình thường.

Trong hầu hết các trường hợp, khi đề cập đến bản đồ bình thường, chúng tôi đặc biệt đề cập đến bản đồ bình thường không gian đối tượng.

Khi mã hóa các chuẩn của chúng ta trong không gian đối tượng, chúng ta biết rằng mỗi chuẩn là một vectơ đơn vị, có lợi ích là nó có thể được biểu diễn trong hai trục với trục thứ ba có thể dẫn xuất tầm thường trong thời gian chạy.

Điều này cho phép chúng tôi ánh xạ lại hai kênh này để tận dụng tốt nhất các thuật toán nén kết cấu và đạt được chất lượng nén vượt trội so với nén XYZ dưới dạng RGB.

Cách bạn ánh xạ lại các kênh khác nhau tùy thuộc vào định dạng nén.

Tôi sẽ xem qua một ví dụ về mã hóa bình thường bằng ASTC, sử dụng biểu đồ này làm hướng dẫn.

Khi mã hóa bằng ASTC, các kênh màu đỏ, xanh lá cây và xanh dương được đặt thành thành phần X và kênh alpha được đặt thành thành phần Y.

Các màu sắc tương ứng với kênh mà các thành phần X và Y sẽ được gán lại khi lấy mẫu bình thường được mã hóa.

TextureConverter đảm nhận việc ánh xạ lại mã hóa cho bạn bằng cách tự động ánh xạ lại theo định dạng bạn đã chọn nếu bạn vượt qua tham số bản đồ bình thường.

Khi lấy mẫu bản đồ bình thường trong bộ đổ bóng của bạn, điều quan trọng là phải biết ánh xạ kênh.

Trong khi thành phần X được đọc từ kênh màu đỏ hoặc alpha, thành phần Y đến từ kênh alpha hoặc màu xanh lá cây tùy thuộc vào định dạng nén.

Quay trở lại ví dụ ASTC, để lấy mẫu kết cấu, thành phần X được lấy mẫu từ kênh màu đỏ và thành phần Y được lấy mẫu từ kênh alpha, ngược lại với cách mã hóa chuẩn.

Nếu bạn đang mã hóa thành nhiều định dạng để đạt được chất lượng tốt nhất có thể trên bất kỳ thiết bị nào, thì ánh xạ này là thứ mà bạn sẽ cần xử lý trong thời gian chạy.

Tôi sẽ xem qua một ví dụ về lấy mẫu bình thường trong thời gian chạy bằng cách sử dụng kết cấu kim loại.

Mã hóa thành nhiều định dạng có thể dẫn đến việc cần nhiều biến thể đổ bóng nếu các định dạng khác nhau sử dụng ánh xạ kênh khác nhau.

Để tránh điều này, Metal cho phép bạn áp dụng các họa tiết tùy chỉnh cho kết cấu của mình.

Swizzles cho phép bạn ánh xạ lại các thành phần X và Y sang các kênh màu đỏ và xanh lá cây để các bộ đổ bóng của bạn có thể là định dạng nén trung tính.

Đây là một ví dụ về ánh xạ lại các kênh sang màu đỏ và xanh lá cây cho một bản đồ bình thường được nén bằng ASTC, như chúng ta đã thấy trong sơ đồ trước đây.

Sau khi mô tả kết cấu được khởi tạo, kênh màu đỏ được đặt thành MTLTextureSwizzleRed và kênh màu xanh lá cây được đặt thành MTLTextureSwizzleAlpha.

Vì đây là một bản đồ bình thường, chỉ cần hai kênh để lấy mẫu.

Vì các kênh màu đỏ và màu xanh lá cây hiện được gán cho các thành phần X và Y ban đầu được mã hóa cho các kênh màu đỏ và alpha, các kênh màu xanh lam và alpha được đặt về 0.

Sau khi hoàn tất, dòng cuối cùng là lắp ráp swizzle cuối cùng với các kênh được ánh xạ lại bằng cách sử dụng MTLTextureSwizzleChannelsMake.

Khi các kênh X và Y được lấy mẫu trong bộ đổ bóng của bạn, bạn có thể tái tạo lại thành phần Z.

Tôi sẽ hướng dẫn bạn qua chức năng ReconstructNormal để chỉ cho bạn cách thực hiện.

Đầu tiên, mã định vị lại các thành phần X và Y vào phạm vi chính xác, đó là âm một đối một đối với bình thường.

Bước tiếp theo là trừ tích dấu chấm của các thành phần X và Y khỏi một, để đảm bảo kết quả của sản phẩm dấu chấm có dấu đúng.

Hàm bão hòa sau đó được sử dụng để kẹp kết quả này trong phạm vi từ 0 đến 1.

Bước cuối cùng để tính thành phần Z là lấy căn bậc hai của đầu ra của hàm bão hòa.

Bây giờ tôi đã giải thích RGBM và các tùy chọn mã hóa bản đồ thông thường có sẵn để ánh xạ kênh, tôi sẽ kết thúc cuộc thảo luận về đường ống nén kết cấu với trạng thái con nén cuối cùng, mã hóa.

Tất cả các dòng lệnh TextureConverter đều yêu cầu đặc điểm kỹ thuật của định dạng nén đích với đối số compression_format.

Bạn cũng có thể chỉ định sử dụng máy nén nào hoặc để TextureConverter thực hiện lựa chọn dựa trên định dạng nén và các tùy chọn khác mà bạn đã chọn.

Bạn cũng có thể chọn chất lượng nén từ bốn tùy chọn này.

Lưu ý rằng có sự cân bằng giữa tốc độ nén và chất lượng hình ảnh và bạn có thể muốn chọn chất lượng nén thấp hơn trong khi lặp lại trò chơi của mình, nhưng hãy sử dụng chất lượng cao nhất cho các bản dựng đã phát hành.

Bây giờ, tôi sẽ đề cập đến các định dạng nén kết cấu có sẵn để bạn lựa chọn.

Đây là tổng quan về các họ định dạng nén kết cấu được hỗ trợ trên nền tảng Apple.

Các nền tảng iOS và Apple Silicon hỗ trợ các gia đình ASTC và PVRTC, và tất cả các nền tảng macOS đều hỗ trợ các gia đình BCn.

Tôi sẽ xem xét từng gia đình định dạng này chi tiết hơn và cung cấp cho bạn một số hướng dẫn để giúp bạn chọn những định dạng tốt nhất cho nhu cầu của mình.

Tôi sẽ bắt đầu với các định dạng BCn.

BCn là một tập hợp gồm bảy định dạng mà tất cả đều hoạt động bằng cách sử dụng bốn khối pixel và sử dụng bốn hoặc tám bit trên mỗi pixel.

Mỗi định dạng nén lý tưởng cho một định dạng dữ liệu khác nhau.

BC1 và BC3 thường được sử dụng để nén RGB và RGBA, BC6 lý tưởng cho hình ảnh HDR và BC5, với các kênh độc lập kép, lý tưởng cho mã hóa bản đồ thông thường.

Tiếp theo là ASTC, một họ các định dạng RGBA trong không gian màu LDR, sRGB và HDR.

Họ định dạng ASTC cho phép chất lượng cao nhất ở mọi kích cỡ, và do đó thường được khuyến nghị hơn so với PVRTC.

Có một loạt các bit trên mỗi pixel so với chất lượng cho mỗi định dạng.

Với ASTC, kích thước byte của mỗi khối là như nhau bất kể định dạng, trong khi số lượng texels mà nó đại diện khác nhau.

Điều này cung cấp cho bạn sự liên tục giữa tốc độ nén chất lượng cao nhất nhưng tốc độ nén thấp nhất ở kích thước khối bốn x bốn so với chất lượng nén thấp nhất nhưng tốc độ nén cao nhất ở kích thước khối 12 x 12.

Các biến thể LDR, sRGB và HDR mô tả dải màu cho kết cấu ASTC nén.

LDR và sRGB đều nằm trong phạm vi không-một, trong không gian tuyến tính hoặc sRGB, trong khi biến thể HDR dành cho dữ liệu bên ngoài phạm vi không-một.

Cuối cùng, các định dạng PVRTC có sẵn ở chế độ RGB và RGBA ở chế độ 2 bit hoặc 4 bit.

Một khối dữ liệu ở định dạng này luôn chiếm tám byte, vì vậy ở chế độ 2 bit sẽ có một khối cho mỗi tám x bốn pixel và ở chế độ 4 bit, có một khối cho mỗi điểm ảnh bốn x bốn.

Bây giờ tôi đã giới thiệu các họ định dạng được hỗ trợ, tôi sẽ đưa ra một số đề xuất để chọn định dạng cho ứng dụng của bạn.

Trên các thiết bị iOS, bạn nên luôn sử dụng nén ASTC theo mặc định, với việc bổ sung nén PVRTC và làm mỏng trên mỗi thiết bị chỉ khi bạn đang hỗ trợ GPU A7 trở về trước.

Nếu bạn có bất kỳ kết cấu HDR nào, bạn có thể tận dụng ASTC HDR trên A13 và các GPU mới hơn.

Đối với macOS, BCn có sẵn trên bảng.

Trên Apple Silicon Macs, bạn cũng có tùy chọn sử dụng ASTC và bạn nên xem xét tùy chọn này nếu bạn cũng đang nhắm mục tiêu các thiết bị iOS.

Mặc dù PVRTC có sẵn trên Apple Silicon, chúng tôi không đề xuất tùy chọn này và nó chỉ dành cho hỗ trợ kế thừa iOS.

Vì có rất nhiều định dạng khác nhau trong mỗi họ định dạng nén để lựa chọn, hướng dẫn để chọn các định dạng nén kết cấu hiệu quả nhất cho ứng dụng của bạn là chọn mỗi kết cấu và mỗi mục tiêu khi có thể.

Trừ khi tất cả các kết cấu của bạn là dữ liệu RGB hoặc RGBA, bạn nên chọn định dạng nén dựa trên loại dữ liệu bạn đang nén, chẳng hạn như chọn định dạng cho phép nén dưới dạng hai kênh độc lập cho dữ liệu thông thường.

Khi nén sang định dạng ASTC, bạn có thể muốn chọn một tập hợp con của các định dạng.

Xem xét kết cấu xô bởi những kết cấu yêu cầu chất lượng cao nhất so với những kết cấu được chấp nhận ở tốc độ nén cao hơn.

Bây giờ, hãy xem lại những gì chúng tôi đã đề cập.

Chúng tôi đã làm lại hoàn toàn quy trình xử lý kết cấu từ TextureTool để cung cấp cho bạn toàn quyền kiểm soát mọi giai đoạn của đường ống với công cụ TextureConverter mới của chúng tôi.

Tôi đã đi qua từng giai đoạn của đường ống mới này và khám phá tất cả các tùy chọn có sẵn để bạn sử dụng ở từng giai đoạn và giới thiệu cho bạn các họ định dạng nén kết cấu và ánh xạ kênh được hỗ trợ trên nền tảng Apple.

Chúng tôi muốn cập nhật quy trình làm việc của bạn từ việc sử dụng TextureTool sang TextureConverter trở nên dễ dàng nhất có thể, vì vậy chúng tôi đã thêm chế độ tương thích để giúp bạn chuyển đổi các dòng lệnh của mình.

Cho dù sử dụng chế độ tương thích TextureTool hay gọi TextureConverter với các tùy chọn gốc, hãy gọi bằng xcrun TextureConverter.

Đây là một dòng lệnh ví dụ của TextureConverter được gọi với các tùy chọn TextureTool.

TextureConverter sẽ dịch các tùy chọn sang các tùy chọn TextureConverter gốc, thực hiện nén và sau đó cho bạn biết các tùy chọn gốc mới là gì, để bạn có thể cập nhật các tập lệnh xây dựng của mình một cách dễ dàng.

Đó là phần giới thiệu về TextureConverter.

Đây là cách để có được nó.

TextureConverter xuất xưởng như một phần của Xcode 13 và có sẵn để sử dụng trong hạt giống 1.

Trên Windows, TextureConverter vận chuyển như một phần của gói Công cụ phát triển kim loại cho Windows 2.0, có sẵn từ developer.apple.com.

Seed 1 hiện đã có sẵn.

Lưu ý rằng trong Windows, không có hỗ trợ nén các định dạng PVRTC, vì PVRTC có sẵn trong macOS để hỗ trợ các nền tảng iOS kế thừa.

Một phần quan trọng khác của Công cụ Nhà phát triển Kim loại cho Windows là Trình biên dịch Kim loại cho Windows.

Trình biên dịch kim loại cho Windows đã được giới thiệu vào năm ngoái, với sự hỗ trợ cho Ngôn ngữ đổ bóng kim loại phiên bản 2.3.

Các bản cập nhật trong suốt cả năm phản ánh các bản cập nhật cho trình biên dịch Metal được vận chuyển trong Xcode.

Phiên bản phát hành mới nhất là 1.2, bao gồm hỗ trợ cho Metal Shading Language trên Apple Silicon Macs.

Seed 1 của phiên bản 2.0 hiện có sẵn với sự hỗ trợ cho tất cả các tính năng mới tuyệt vời trong Metal Shading Language 2.4.

Đây là bản tóm tắt về mọi thứ chúng tôi đã đề cập hôm nay: Egor đã thảo luận về việc hỗ trợ nhiều tính năng Metal hơn, như dò tia và con trỏ chức năng.

Anh ấy đã giới thiệu quy trình làm việc lập hồ sơ hoàn toàn mới, như Dòng thời gian GPU và trạng thái hiệu suất GPU nhất quán, để giúp bạn tận dụng tối đa GPU trên tất cả các nền tảng của Apple.

Và anh ấy đã chứng minh những cải tiến đối với quy trình gỡ lỗi mà bạn đã quen thuộc để cung cấp cho bạn nhiều hỗ trợ hơn cho việc xác thực đổ bóng và điều khiển chụp chính xác.

Và tôi đã giới thiệu cho bạn TextureConverter, một công cụ mới giúp bạn tận dụng tối đa quy trình xử lý kết cấu và tất cả các định dạng nén kết cấu được hỗ trợ có sẵn trên nền tảng Apple.

Cảm ơn, và chúc bạn có một phần còn lại tuyệt vời của WWDC 2021.

[Âm nhạc].