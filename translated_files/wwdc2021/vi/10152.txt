10152

Xin chào. Tôi là Saharsh Oza.

Tôi làm việc với nhóm Kỹ sư Phần mềm GPU tại Apple.

Hôm nay đồng nghiệp của tôi, Yuliya Pylypiv, và tôi sẽ nói về những gì mới trong Metal Performance Shaders Graph.

Hãy để chúng tôi bắt đầu.

MPS là một thư viện các nguyên thủy dựa trên kim loại, hiệu suất cao, tăng tốc GPU cho các lĩnh vực khác nhau như xử lý hình ảnh, đại số tuyến tính, dò tia và học máy.

Nhóm MPS tối ưu hóa hạt nhân Metal để mang lại hiệu suất tốt nhất trên từng phần cứng trên các nền tảng khác nhau của Apple.

Năm ngoái, chúng tôi đã giới thiệu khung MPSGraph, một biểu đồ tính toán mục đích chung cho GPU.

Nó được hỗ trợ trên macOS, iOS, iPadOS và tvOS, giống như khung MPS.

Vui lòng xem phiên họp năm ngoái của chúng tôi để biết thêm chi tiết giới thiệu về MPSGraph.

Hãy cùng xem chương trình nghị sự.

Chúng tôi có rất nhiều thứ để trang trải.

Chúng ta sẽ thảo luận về suy luận ML và tăng tốc đào tạo thông qua MPSGraph.

Chúng tôi sẽ giới thiệu một số hoạt động MPSGraph mới thú vị.

Chúng tôi sẽ giới thiệu những cách mới để bạn kiểm soát việc biên dịch trong MPSGraph.

Và cuối cùng, chúng ta sẽ xem xét tất cả các khả năng điều khiển dòng chảy mới của MPSGraph.

Tôi muốn giới thiệu đồng nghiệp của tôi, Yuliya, người sẽ chia sẻ một số cập nhật thú vị để suy luận và tăng tốc đào tạo.

Cảm ơn, Saharsh.

Xin chào. Tôi là Yuliya Pylypiv.

Tôi là một phần của nhóm Phần mềm GPU tại Apple.

Hôm nay, tôi muốn chia sẻ những cải tiến mà chúng tôi đã thực hiện để tăng hiệu suất đào tạo và suy luận trên GPU.

Hãy đi sâu vào nó.

Khung MPSGraph đã được áp dụng bởi các khung học máy cấp cao hơn như Core ML và TensorFlow để tăng tốc GPU.

Năm nay, chúng tôi đã tối ưu hóa MPSGraph hơn nữa với sự kết hợp giữa cải tiến hạt nhân và áp dụng khâu.

Điều này đã chuyển thành mức tăng hiệu suất lớn cho các khuôn khổ học máy sử dụng MPS.

Chúng ta hãy xem xét kỹ hơn về Plugin kim loại mới cho TensorFlow.

TensorFlow là một nền tảng đào tạo học máy phổ biến và GPU là thiết bị tăng tốc chiếm ưu thế.

Năm nay, chúng tôi đã phát triển một Plugin kim loại mới sử dụng Giao diện thiết bị có thể cắm TensorFlow được phát hành trong TensorFlow 2.5.

Điều này mang lại sức mạnh của Metal cho TensorFlow bằng MPS và MPSGraph.

Điều này cho phép chúng tôi đào tạo bất kỳ mô hình học máy nào trên GPU nền tảng Mac mà không cần sửa đổi.

Bây giờ, hãy xem một trong những thứ này đang hoạt động.

Đối với bản demo này, tôi sẽ sử dụng môi trường Jupyter.

Trên hệ thống M1 của tôi, tôi đã cài đặt TensorFlow mới nhất có sẵn.

Khi chúng tôi liệt kê các thiết bị vật lý, bạn có thể thấy chỉ có một thiết bị CPU được đăng ký.

Ở đây tôi đang xác định một mô hình học máy phổ biến, ResNet50, được sử dụng rộng rãi để phân loại hình ảnh, học chuyển giao và hơn thế nữa.

Mô hình hiện tại sử dụng tập dữ liệu ImageNet tiêu chuẩn với kích thước hình ảnh 224 x 224.

Như bạn có thể thấy, ETA hiện tại cho kỷ nguyên đầu tiên chạy trên CPU là khoảng 20 phút.

Hãy để tôi cài đặt Plugin TensorFlow Metal mà chúng tôi đã giới thiệu trước đó và xem liệu chúng tôi có thể tăng tốc cho mạng hiện tại hay không.

Để làm như vậy, tôi sẽ sử dụng pip install tensorflow-metal...

Quay trở lại cùng một mô hình ResNet50 mà chúng tôi đã sử dụng trước đây.

Chỉ lần này, bạn mới có thể thấy có một thiết bị GPU mới được đăng ký.

Đây là thiết bị GPU mà chúng tôi đã giới thiệu như một phần của nền tảng TensorFlow sử dụng Metal Plugin.

Tất cả các cuộc gọi lại và định nghĩa mạng vẫn không thay đổi.

Khởi động mạng một lần nữa để chúng ta có thể so sánh ETAs.

Bạn có thể thấy rằng phiên bản GPU của cùng một mạng đang đào tạo nhanh hơn khoảng bốn lần bằng cách sử dụng TensorFlow Metal Plugin.

Bây giờ chúng ta hãy xem xét kỹ hơn các mạng khác.

Ở đây chúng tôi hiển thị hiệu suất trên các tiêu chuẩn đào tạo máy học chính liên quan đến CPU.

Như bạn có thể thấy, chúng tôi có tốc độ tốt trên tất cả các điểm chuẩn, nhanh hơn gấp tám lần trên M1 MacBook Pro.

Cài đặt Metal Plugin mới cho TensorFlow thật dễ dàng.

Sau khi cài đặt TensorFlow cơ sở bằng cách sử dụng pip install tensorflow-macos, bạn có thể cài đặt Metal Plugin bằng cách sử dụng pip install tensorflow-metal.

Metal Plugin sẽ có sẵn trên gói Python chính thức repo, pypi.org.

Để biết chi tiết về thiết lập và cài đặt môi trường, vui lòng tham khảo Tài nguyên Nhà phát triển Kim loại.

Đó là nó cho TensorFlow.

Tiếp theo, hãy nói về gia tốc suy luận trong Core ML.

Core ML là khung suy luận học máy của Apple.

Chúng tôi cũng đã thấy những cải tiến hiệu suất đáng kể trên Core ML với MPSGraph.

Chúng tôi chỉ ra ở đây tốc độ suy luận của các lớp chính của mạng học máy trên M1.

Chúng tôi tăng tốc gấp 2 lần trên BERT, đây là một mạng máy biến áp chuẩn được sử dụng cho các ứng dụng NLP.

ResNet50, trung tâm của các ứng dụng thị giác máy tính, đã được điều chỉnh cho các đường dẫn kết cấu trong các bản phát hành trước đó.

Đây là một cải tiến hiệu suất bổ sung 16% với phần phụ trợ bộ đệm mới của chúng tôi thông qua MPSGraph.

Những cải tiến hiệu suất này trong Core ML và TensorFlow là do những cải tiến hiệu suất trong các nguyên thủy MPS như Convolution2D.

Ở đây, chúng tôi hiển thị tốc độ của Convolution2D trên bố cục dữ liệu NHWC và NCHW được sử dụng để đào tạo và suy luận tương ứng.

Đó là nó cho những cải tiến trong suy luận và đào tạo.

Tiếp theo, hãy quay lại Saharsh để tìm hiểu thêm về các hoạt động mới trong MPSGraph.

Cảm ơn, Yuliya.

Bây giờ chúng ta sẽ xem xét tập hợp các hoạt động mới được hỗ trợ bởi MPSGraph.

Chúng tôi hỗ trợ rất nhiều thao tác trên MPSGraph, từ nhiều biến thể của tích chập và giảm đến tất cả các hoạt động toán học cơ bản mà bạn có thể cần trong biểu đồ tính toán của mình.

Năm nay, chúng tôi đã thêm các hoạt động đặc biệt để cho phép bạn làm được nhiều hơn với MPSGraph.

Chúng tôi sẽ giới thiệu ba nguyên thủy mới: kiểm soát phụ thuộc, toán tử stprint và toán tử thu thập.

Đầu tiên, chúng ta sẽ xem xét sự phụ thuộc kiểm soát.

Kiểm soát sự phụ thuộc là cần thiết để sắp xếp rõ ràng các hoạt động trong biểu đồ.

Để hiểu điều này, hãy chính thức xác định một thao tác đồ thị.

Các hoạt động trong biểu đồ kết nối với nhau thông qua ba loại cạnh: tenxơ đầu vào, đại diện cho tenxơ nào đóng vai trò là đầu vào dữ liệu cho op, tenxơ đầu ra, được tạo bởi chính op và cuối cùng, một loại cạnh đặc biệt được gọi là phụ thuộc điều khiển.

Họ phải thực hiện trước hoạt động hiện tại, ngay cả khi bản thân hoạt động hiện tại không phụ thuộc vào nó.

API này cũng cung cấp một cách thuận tiện để ngăn chặn các hoạt động được MPSGraph tối ưu hóa.

Điều này là cần thiết để thực hiện các lớp học máy như chuẩn hóa hàng loạt.

Hãy xem điều này trong thực tế.

Chuẩn hóa hàng loạt là một lớp tiêu chuẩn được sử dụng trong đào tạo ML để làm cho mạng ổn định hơn và hội tụ nhanh hơn.

Ở đây chúng ta thấy biểu đồ tính toán cho chuẩn hóa hàng loạt được sử dụng để đào tạo.

Bước đầu tiên là tính giá trị trung bình và phương sai.

Đến lượt nó, chúng được sử dụng để cập nhật giá trị trung bình chạy và phương sai chạy cần thiết cho suy luận.

Tuy nhiên, kết quả biểu đồ đào tạo không yêu cầu các biến này, vì vậy MPSGraph có thể tối ưu hóa chúng đi.

Chúng ta có thể giải quyết vấn đề này bằng cách sắp xếp chúng một cách rõ ràng trước toán tử chuẩn hóa cuối cùng bằng cách sử dụng các phụ thuộc điều khiển.

Hãy xem xét một ví dụ đơn giản với một số mã cho thấy cách bạn có thể sử dụng API này.

Biểu đồ này cho thấy một toán tử số mũ và gán.

Toán tử gán không được sử dụng bởi bất kỳ thứ gì khác trong biểu đồ.

Vì vậy, nó có thể được tối ưu hóa.

Một cách để giải quyết vấn đề này là đặt rõ ràng chỉ định làm targetOperation.

Tuy nhiên, điều này đòi hỏi nhà phát triển phải theo dõi sự phụ thuộc trên toàn cầu trên biểu đồ.

Thay vào đó, với API phụ thuộc điều khiển mới, bạn có thể làm cho thao tác số mũ phụ thuộc vào bài tập.

Điều này loại bỏ nhu cầu có targetOperation và cũng đảm bảo rằng biểu đồ không tối ưu hóa nó đi.

Tiếp theo, chúng ta sẽ thấy điều này trong mã.

Đầu tiên chúng tôi xác định toán tử mà số mũ phụ thuộc vào.

Tiếp theo, chúng tôi tạo ra một dependentBlock xác định toán tử số mũ.

Cuối cùng, chúng tôi gọi API chạy trên biểu đồ này.

Lưu ý rằng không có hoạt động mục tiêu nào cần được theo dõi trên toàn cầu.

Đó là nó cho sự phụ thuộc kiểm soát.

Bây giờ hãy nói về những người vận hành giấy nến.

Thao tác stprint là sự khái quát hóa của các toán tử cửa sổ trượt như tích chập hình ảnh.

Những toán tử này rất cần thiết trong các phương pháp phần tử hữu hạn, học máy và các ứng dụng xử lý hình ảnh.

Ở đây, chúng ta thấy một khuôn tô 2D năm điểm thường được sử dụng để thực hiện các hoạt động Laplacian.

Toán tử stprint được hiển thị ở đây cũng có thể được áp dụng cho các kích thước cao hơn, như được hiển thị với sơ đồ stprint 3D bảy điểm này.

Chúng ta hãy xem xét kỹ hơn về người vận hành.

Đối với mỗi giá trị đầu ra, nó tính toán mức giảm có trọng số trên cửa sổ stprint trên tenxơ đầu vào, như được hiển thị.

Người vận hành hỗ trợ các chế độ giảm khác nhau bao gồm argmin/argmax và các chế độ đệm khác nhau, bao gồm phản xạ và kẹpToZero.

MPSGraph cho phép ghép nối trên các hạt nhân MPS để có hiệu suất tối ưu.

Với sự hỗ trợ khâu, toán tử stprint cho phép bạn thể hiện các phép toán phức tạp trong một lần khởi chạy hạt nhân duy nhất.

Hãy để chúng tôi xem một ví dụ như vậy đang hoạt động.

Chuẩn hóa phản hồi cục bộ là một op pytorch được sử dụng để chuẩn hóa trong kích thước kênh.

Rất đơn giản để thực hiện điều này với thao tác stprint mới.

Ở đây, chúng ta thấy biểu đồ cho kỹ thuật chuẩn hóa này.

Chúng tôi thấy rằng đó chỉ là yếu tố khôn ngoan xung quanh hoạt động của khuôn tô.

Nếu không có thao tác mới, sẽ cần nhiều công văn.

Bây giờ, vì stencil op hỗ trợ khâu, toàn bộ biểu đồ này có thể được khởi chạy trong một công văn duy nhất.

Vì vậy, đó là nó cho người vận hành stprint.

Tiếp theo, chúng ta hãy xem xét những cải tiến trong hoạt động thu thập.

Năm nay, các hoạt động thu thập mới đã được thêm vào MPSGraph.

Những thứ này cho phép sao chép hiệu quả các lát cắt có kích thước tùy ý ở các vị trí bộ nhớ không liền kề.

Về mặt khái niệm, chúng tôi đang thu thập các giá trị từ các vị trí được đánh dấu màu xanh lam từ một đoạn bộ nhớ.

Các lớp tập hợp này cho phép thực hiện hiệu quả việc nhúng tra cứu và sao chép ma trận động.

GatherND là một phần mở rộng mạnh mẽ của hoạt động thu thập.

Trong khi tập hợp bình thường hỗ trợ lập chỉ mục tuyến tính, thao tác gatherND cho phép lập chỉ mục N chiều.

Điều này cho phép sao chép liền mạch dữ liệu từ mọi nơi trong đầu vào N chiều.

Đầu vào cho thao tác này là một vectơ tọa độ và mỗi tọa độ có thể lên đến thứ hạng của tenxơ đầu vào.

Bất kỳ kích thước nào không được chỉ định trong tọa độ đều dẫn đến các bản sao lát cắt.

Chúng ta có thể bước qua một ví dụ về tập hợp các lát cắt hàng từ một tenxơ 3D.

Trong ví dụ này, các chỉ số chỉ định hai tọa độ tương ứng với tọa độ ma trận và hàng.

Không có tọa độ thứ ba cho chỉ mục cột, gatherND này sẽ sao chép toàn bộ hàng.

Tenxơ kết quả là một ma trận 2D của các hàng được thu thập từ ma trận đầu vào.

GatherND có thể đại diện cho gần như bất kỳ hình thức hoạt động thu thập nào và mang lại hiệu suất tuyệt vời.

Ví dụ, hãy xem cách chúng ta có thể thực hiện tra cứu nhúng bằng cách sử dụng các hoạt động thu thập.

Tra cứu nhúng là một thao tác phổ biến được sử dụng để tìm vectơ nhúng cho một tập hợp các đối tượng đầu vào được cung cấp.

Thông thường, lớp này được sử dụng trong các mạng xử lý ngôn ngữ, trong đó một ma trận nhúng được tạo ra liên kết từng từ trong từ vựng với một vectơ nhúng.

ID của các từ trong từ vựng có thể được sử dụng làm chỉ số cho hoạt động thu thập và ma trận nhúng là tenxơ đầu vào của chúng tôi.

Chúng tôi muốn lấy các hàng tương ứng cho mỗi ID từ, mà chúng tôi có thể thực hiện dễ dàng bằng cách sử dụng một lớp tập hợp.

Chúng tôi chỉ định một tọa độ, vì vậy toàn bộ hàng sẽ được sao chép cho mỗi từ đầu vào.

Tenxơ kết quả là một ma trận 2D của vectơ nhúng của mỗi từ đầu vào dọc theo các hàng.

Đó là nó cho các hoạt động MPSGraph mới mà chúng tôi đã giới thiệu trong năm nay.

Bây giờ hãy nói về các API biên dịch.

Năm nay, chúng tôi sẽ giới thiệu MPSGraphExecutable API mới.

API biên dịch này cải thiện hiệu suất theo hai cách.

Đầu tiên, nó cho phép nhà phát triển kiểm soát thời điểm biên dịch biểu đồ.

Thứ hai, nó cho phép bạn giảm số lượng cuộc gọi biên dịch thông qua suy luận loại hoãn lại.

Bây giờ chúng ta hãy xem xét kỹ hơn từng cái.

Năm ngoái, chúng tôi đã cung cấp một API thực sự thuận tiện để xác định và thực thi MPSGraph.

Dưới mui xe, lần đầu tiên một đánh giá được yêu cầu, MPSGraph đã gọi trình biên dịch cho các loại đầu vào và tạo nội bộ một tệp thực thi.

Đối với bất kỳ lần thực thi tiếp theo nào, MPSGraph đã lưu trữ liền mạch tệp thực thi này để đảm bảo chi phí biên dịch không được thanh toán lại.

Người dùng hiện có khả năng gọi biên dịch trước thời hạn để bạn có thể chọn dòng thời gian biên dịch.

Với tệp thực thi được biên dịch, bạn có thể gọi chạy trực tiếp trên MPSGraphExecutable.

Điều này cho phép người dùng kiểm soát khi biểu đồ được biên dịch và cũng có khả năng lưu trữ tệp thực thi được biên dịch để bạn có thể đạt được hiệu suất cao hơn nữa.

Hãy xem cái này trong mã.

Ở đây, chúng ta có một biểu đồ đơn giản để thêm hai tenxơ.

Bây giờ để biên dịch, chúng tôi cung cấp các loại cho nguồn cấp dữ liệu và tenxơ mục tiêu cùng với các hoạt động.

Những gì chúng tôi nhận được là một biểu đồ được biên dịch và một tệp thực thi.

Và phương pháp đánh giá cũng đơn giản không kém.

Chúng tôi cung cấp một hàng đợi lệnh Metal và dữ liệu tensor đầu vào của chúng tôi.

Vì vậy, đó là những điều cơ bản của việc biên soạn biểu đồ MPS.

Tiếp theo, hãy nói về cách chúng ta giảm số lượng cuộc gọi biên dịch thông qua suy luận loại hoãn lại.

Suy luận kiểu là một đường biên dịch trong đó MPSGraph phải xác định các hình dạng tensor mà chúng không được người dùng chỉ định.

Trong biểu đồ này, chúng tôi đang thực hiện phép nhân ma trận của hai tenxơ 2D.

Các hình dạng của các tenxơ đầu vào được hiển thị.

Tuy nhiên, tenxơ đầu ra có hình dạng không xác định.

Khi quá trình suy luận loại hoàn tất, hình dạng tensor đầu ra được xác định dựa trên đầu vào và loại hoạt động.

Trong các mạng nơ-ron tiêu chuẩn, các đầu vào của mạng không phải lúc nào cũng có cùng kích thước.

Để xử lý ngôn ngữ tự nhiên, các câu hoặc chuỗi có thể có độ dài khác nhau.

Đối với CNNs, chúng tôi thấy các hình ảnh có kích thước khác nhau sắp được đánh giá.

Trước khi nâng cấp biên dịch của năm nay, đối với mỗi hình ảnh có kích thước mới, một bản biên dịch sẽ được gọi để suy luận kiểu cho toàn bộ biểu đồ.

Bây giờ với quyền kiểm soát biên dịch, bạn, nhà phát triển, có thể gọi biên dịch với loại suy luận đã tắt.

Điều này có thể tiết kiệm hàng chục hoặc hàng trăm giây thời gian biên dịch trên mỗi lần lặp và có được hiệu suất tốt nhất.

Thời gian chạy MPSGraph sẽ suy ra các loại đúng lúc trong quá trình mã hóa và làm cho mọi thứ hoạt động liền mạch.

Đó là sự cân bằng giữa việc tiết kiệm thời gian biên dịch so với việc có được biểu đồ tối ưu nhất.

Hãy xem điều này có thể được sử dụng như thế nào trong ví dụ mã được chia sẻ trước đây.

Có thể đạt được việc vô hiệu hóa đường chuyền suy luận kiểu bằng cách đặt bộ mô tả biên dịch như được hiển thị.

Đó là nó cho các API biên dịch.

Cuối cùng, hãy nói về các API luồng điều khiển mới của MPSGraph.

Các API này cho phép bạn tự động gửi các hoạt động dựa trên các tenxơ được đánh giá trước đó bởi biểu đồ.

Điều này phổ biến trong các ứng dụng như chuẩn hóa hàng loạt và mạng nơ-ron tái phát.

Chúng ta hãy xem cách "vòng lặp thời gian" có thể được triển khai với MPSGraph ngay hôm nay mà không cần API mới.

Đầu tiên, chúng tôi tạo ra một biểu đồ tính toán vị ngữ.

Tiếp theo, vị ngữ được đánh giá trên CPU thông qua đồng bộ hóa bộ nhớ rõ ràng.

Nếu vị ngữ là đúng, biểu đồ đã tạo trước đó sẽ được thực thi lại với các đầu vào mới.

Mặt khác, nếu vị ngữ là sai, vòng lặp sẽ kết thúc và MPSGraph thứ hai được tạo và thực thi để tiêu thụ kết quả.

Với API luồng điều khiển mới, tất cả các bước này có thể được khởi chạy như một phần của việc thực thi MPSGraph duy nhất.

Điều này thuận tiện hơn để thực hiện vì bạn không cần phải giới thiệu các nguyên thủy đồng bộ hóa bộ nhớ rõ ràng.

Bây giờ chúng ta hãy xem làm thế nào điều này có thể có khả năng hiệu quả hơn.

Ở đây chúng ta thấy dòng thời gian luồng điều khiển mà không có API mới.

Chúng tôi mã hóa hạt nhân đầu tiên trên CPU.

Khi hạt nhân hoàn tất, chúng ta phải đồng bộ hóa bộ nhớ để đọc kết quả.

Điều này có khả năng không hiệu quả, vì CPU phải đợi GPU hoàn thành việc thực thi.

Tương tự, GPU cũng phải đợi quá trình đồng bộ hóa CPU và mã hóa tiếp theo hoàn tất.

Điều này xảy ra trong mỗi lần lặp lại.

Bây giờ hãy xem những lợi ích của việc sử dụng MPSGraph API mới.

Chúng ta chỉ phải thực hiện một cuộc gọi mã hóa CPU.

Vì vị ngữ được đánh giá trên dòng thời gian GPU, không phát sinh chi phí đồng bộ hóa và hạt nhân có thể được khởi chạy mà không có bất kỳ bong bóng nào.

Bây giờ hãy xem các API mới là gì.

Chúng tôi đã thêm ba API luồng điều khiển mới: if/else, for loops, và while loops.

Hãy bắt đầu với nguyên thủy if/else.

Tất cả chúng ta đều quen thuộc với điều này.

Dựa trên một vị ngữ, các đường dẫn mã khác nhau được thực thi.

Chúng tôi được cung cấp một vị ngữ Boolean cùng với một khối mã cho các điều kiện "nếu" và "khác".

Nếu vị ngữ này là đúng, chúng tôi sẽ thực thi khối mã sau đó.

Nếu không, nếu nó sai, nhánh khác sẽ được thực thi.

Có hoạt động if/else rất hữu ích trong mạng lưới thần kinh.

Một cách sử dụng kinh điển là trong hoạt động Bình thường hóa hàng loạt, có hành vi khác nhau trong đào tạo và suy luận.

Với isTraining Boolean, chúng ta có thể có một biểu đồ duy nhất để biểu diễn cả hai biến thể của bộ chuẩn hóa.

Hãy xem cách thiết lập một nhánh if/else trong mã.

Hãy lấy một ví dụ rất đơn giản về hai tenxơ vô hướng đầu vào.

Nếu tenxơ đầu tiên nhỏ hơn tenxơ thứ hai, chúng ta sẽ trả về tổng các phép toán.

Nếu không, chúng tôi trả lại sự khác biệt.

Đầu tiên, chúng tôi tính toán vị ngữ và chuyển nó cho API.

Tiếp theo, khi vị ngữ là đúng, chúng ta tính khối then và thêm các tenxơ.

Cuối cùng, khi vị ngữ sai, chúng ta tính khối else và trừ các tenxơ.

Tiếp theo, hãy xem cách triển khai vòng lặp for.

Vòng lặp nguyên thủy for trên một tập hợp các hoạt động một số lần cố định.

Điều này là phổ biến trong các mạng thần kinh tái phát, nơi chúng ta phải lặp lại các chuỗi có độ dài khác nhau trong quá trình đào tạo.

Chúng tôi cần cung cấp số lần lặp lại của vòng lặp for.

Chỉ số được khởi tạo thành 0 và được so sánh với số lần lặp lại mỗi vòng lặp.

Nếu nó nhỏ hơn numberOfIterations, chúng tôi thực hiện phần thân của vòng lặp for và tăng chỉ mục lên 1.

Khi chỉ mục bằng hoặc lớn hơn numberOfIterations, chúng tôi kết thúc vòng lặp.

Hãy xem cách triển khai điều này trong mã.

Giả sử chúng tôi muốn thực hiện một ví dụ thực sự đơn giản.

Chúng tôi sẽ khởi tạo biến kết quả thành một số giá trị đầu vào.

Sau đó, chúng tôi lặp lại bốn lần, nhân kết quả với một giá trị đầu vào khác mỗi lần.

Đầu tiên, chúng tôi tạo ra hai tenxơ đồ thị.

Tenxơ đầu ra sẽ được khởi tạo thành input0.

Trong mỗi lần lặp lại, tenxơ này sẽ được nhân với input1.

Tiếp theo, chúng tôi đặt numberOfIterations thành 4 để chúng tôi có thể thực hiện vòng lặp bốn lần, từ chỉ mục 0 đến chỉ mục 3.

Tiếp theo, chúng tôi tạo phần thân của vòng lặp for.

Điều này được thực hiện bằng cách tạo ra một đóng cửa đại diện cho một lần lặp lại duy nhất.

Mỗi lần lặp lại được thông qua chỉ mục của lần lặp hiện tại, cũng như đầu ra của lần lặp trước đó.

Sau đó, chúng tôi sẽ cập nhật kết quả và trả lại nó, để được chuyển sang lần lặp tiếp theo.

Cuối cùng, chúng tôi chuyển tất cả các đối số này cho API vòng lặp for trong biểu đồ.

Lưu ý rằng các đối số lặp lại của cơ thể được khởi tạo thành tenxơ input0.

Đó là nó cho vòng lặp cho.

Bây giờ hãy xem xét API vòng lặp while.

Nguyên thủy này thực hiện một tập hợp các hoạt động trong khi một điều kiện được đáp ứng.

Chúng tôi cần cung cấp hai khối mã để sử dụng API này.

Trong khối đầu tiên, tình trạng được kiểm tra bằng một vị ngữ.

Khi vị ngữ là đúng, phần thân của vòng lặp while trong khối sau được thực thi.

Điều này tính toán lại vị ngữ.

MPSGraph sau đó sử dụng vị ngữ này trong lần lặp tiếp theo của khối trước.

Nếu điều kiện được đánh giá là sai, nó sẽ thoát khỏi vòng lặp.

API cũng cho phép triển khai vòng lặp do-while bằng cách hoán đổi các khối mã đánh giá nội dung và điều kiện.

Giả sử chúng tôi muốn thực hiện một ví dụ thực sự đơn giản.

Chúng tôi sẽ khởi tạo biến kết quả thành một số giá trị đầu vào.

Sau đó, chúng tôi sẽ nhân kết quả với hệ số nhân mỗi lần trong một vòng lặp cho đến khi chúng tôi vượt quá ngưỡng.

Đầu tiên, chúng tôi xác định một khối mã sẽ đánh giá vị ngữ bằng cách sử dụng kết quả của lần lặp trước đó.

Nó cũng lưu trữ kết quả của lần lặp lại trước đó trong returnTensors NSArray.

Mảng này sẽ được sử dụng làm đầu vào cho lần lặp tiếp theo khi vị ngữ là đúng và được sử dụng làm kết quả cuối cùng nếu vị ngữ sai.

Tiếp theo, chúng tôi xác định phần thân của vòng lặp while nơi các tenxơ được nhân lên.

Sản phẩm được trả lại để khối điều kiện đọc.

Cuối cùng, chúng tôi sẽ chuyển tất cả các đối số này đến API vòng lặp while như được hiển thị.

Lưu ý rằng đối số initialInputs được sử dụng trong lần lặp đầu tiên của khối trước.

Đó là nó cho các vòng lặp trong khi.

Tiếp theo, chúng ta sẽ xem điều này có thể được sử dụng như thế nào trong một ứng dụng thực tế.

Bố cục hình ảnh là một tiện ích chỉnh sửa hình ảnh phổ biến.

Ở đây, một vật thể được cấy vào một hình ảnh mục tiêu.

Chúng tôi bắt đầu với một hình ảnh nguồn và một hình nền, như được hiển thị.

Tiếp theo, chúng tôi tạo một mặt nạ trên hình ảnh nguồn.

Hãy đặt mặt nạ này của hình ảnh nguồn trực tiếp vào nền.

Điều đó trông không tuyệt vời, vì chúng ta có thể thấy rõ các cạnh của hình ảnh nguồn.

Thông qua bố cục hình ảnh, chúng tôi muốn làm mịn các cạnh này.

Ghép nối bộ lọc cạnh Laplacian với bộ giải tuyến tính lặp lại là một cách phổ biến để đạt được điều này.

Bây giờ hãy xem chi tiết.

Ở đây, chúng tôi thấy đường ống cần thiết để thực hiện bố cục hình ảnh với MPSGraph.

Chúng tôi bắt đầu với các tenxơ đầu vào, hình nền, hình ảnh nguồn và mặt nạ của đối tượng.

Tiếp theo, chúng tôi sử dụng bộ giải tuyến tính lặp lại kết hợp với máy dò cạnh Laplacian.

Đầu ra của tập hợp các thao tác này là một hình ảnh tổng hợp với các cạnh mịn.

Hãy cùng xem bộ lọc cạnh Laplacian.

Việc triển khai bộ lọc cạnh Laplacian liên quan đến việc giảm cửa sổ trên hình ảnh nguồn với một tập hợp các trọng số.

Toán tử stprint được sử dụng để thực hiện điều này như được hiển thị.

Sử dụng toán tử này, chúng ta có thể nhìn thấy các cạnh của đối tượng nguồn.

Các cạnh được tính toán ở đây sẽ được sử dụng làm đầu vào cho bộ giải tuyến tính.

Tiếp theo, chúng ta hãy nhìn vào bộ giải tuyến tính.

Chúng tôi bắt đầu với hình nền và đưa nó vào bộ giải tuyến tính.

Trình giải cập nhật hình ảnh này và kết quả sau đó được đọc lại.

Như chúng ta có thể thấy, đây là một quá trình lặp đi lặp lại.

Khi các lần lặp lại tiến triển, hình ảnh giải pháp được cải thiện cho đến khi chúng ta đạt được sự pha trộn hoàn hảo ở các cạnh.

Vòng lặp kết thúc khi lỗi nằm dưới dung sai do người dùng xác định.

Điều này đòi hỏi một vòng lặp thời gian.

Bây giờ bạn có thể sử dụng MPSGraph Control Flow API để triển khai điều này.

Bây giờ, hãy xem bản demo.

Chúng tôi đã triển khai một tiện ích bố cục hình ảnh bằng cách sử dụng MPSGraph như một ứng dụng iPad Pro.

Chúng tôi bắt đầu với một hình ảnh nguồn ở trên cùng và một hình ảnh mục tiêu bên dưới.

Chúng tôi sẽ nhân bản các đối tượng từ nguồn đến mục tiêu.

Điều đầu tiên chúng ta cần làm là vẽ một chiếc mặt nạ xung quanh con bò mà chúng ta muốn di chuyển.

Hãy xem điều này trông như thế nào với một bản sao ngây thơ.

Điều đó trông không đẹp lắm, vì chúng ta có thể thấy các cạnh thô.

Bây giờ hãy thử kỹ thuật bố cục hình ảnh mà chúng ta vừa mô tả.

Chúng tôi sẽ bắt đầu bằng cách thiết lập giải pháp ban đầu cho hình nền.

Hãy chạy cái này trong khoảng 50 lần lặp lại.

Rõ ràng, hình ảnh giải pháp vẫn chưa hội tụ.

Hãy chạy nó thêm khoảng 50 lần lặp nữa.

Điều này trông tự nhiên hơn khi các cạnh mịn ra.

Sự dễ dàng lập trình với MPSGraph giúp việc thử nghiệm các kỹ thuật khác nhau trở nên đơn giản.

Khởi tạo bộ giải với hình ảnh nhân bản thay vì hình nền có thể dẫn đến sự hội tụ nhanh hơn.

Chúng ta có thể kích hoạt chế độ khởi tạo này bằng cách chuyển đổi công tắc này.

Hãy xem điều này đang hoạt động bằng cách đặt số lần lặp lại thành 50 một lần nữa và đặt lại thành bản sao ngây thơ.

Bây giờ hãy chạy lại trình giải.

Chúng ta có thể thấy hình ảnh giải pháp sau 50 lần lặp lại trông khá tốt.

Vì chúng tôi đã bắt đầu với đối tượng nguồn, chúng tôi cũng quan sát thấy ít chảy máu hơn ở các cạnh.

Điều này thật tuyệt.

Nhưng những gì chúng tôi thực sự muốn là tự động hóa sự hội tụ dựa trên khả năng chịu lỗi.

Điều này sẽ yêu cầu một vòng lặp while mà chúng tôi sẽ kích hoạt bằng cách sử dụng công tắc này.

Chúng tôi đã triển khai điều này với MPSGraph API mới.

Khả năng chịu lỗi có thể được kiểm soát bằng thanh trượt này.

Chúng tôi đã đặt nó thành 0.1, như được hiển thị.

Hãy đặt lại cái này trở lại bản sao ngây thơ.

Bây giờ chúng ta bắt đầu giải quyết.

Với vòng lặp while này, chúng tôi hội tụ đến hình ảnh giải pháp trong khoảng 80 lần lặp mà tôi không cần phải chỉ định bất kỳ số lần lặp nào.

Bây giờ chúng ta hãy vui vẻ bằng cách nhân bản các động vật khác vào nền này.

Hãy thử chú chó con dễ thương này.

Được rồi, truy tìm xong rồi.

Tôi nghĩ nó sẽ trông tuyệt vời ở phía dưới bên phải của hình ảnh này.

Có lẽ chúng ta có thể thử một con chim tiếp theo.

Cái này sẽ trông đẹp ở trên cùng bên phải của nền.

Nền mới với tất cả những hình ảnh này trông khá gọn gàng.

Đó là nó cho bản demo.

Tóm lại, chúng tôi đã chỉ ra cách áp dụng MPSGraph dẫn đến những cải tiến hiệu suất đáng kinh ngạc cho CoreML và TensorFlow.

Suy luận bây giờ nhanh gấp đôi.

Chúng tôi đã giới thiệu các nguyên thủy tính toán mới hữu ích, bao gồm toán tử stprint sẽ cho phép một loạt các ứng dụng.

Chúng tôi đã cho thấy sự linh hoạt biên dịch mới mà MPSGraph cung cấp.

Điều này sẽ loại bỏ độ trễ khỏi các mạng suy luận.

Và cuối cùng, chúng tôi đã cho thấy tất cả các khả năng điều khiển luồng mới của MPSGraph.

API này là chìa khóa để thể hiện một số ứng dụng đại số tuyến tính ngoài mạng học máy.

Chúng tôi rất vui khi thấy bạn sẽ tận dụng những tính năng này như thế nào.

Cảm ơn bạn, và chúc bạn có một WWDC 2021 tuyệt vời.

[Nhạc lạc quan].