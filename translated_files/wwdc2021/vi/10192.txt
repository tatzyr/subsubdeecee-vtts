10192

♪ ♪

Xin chào! Tôi là Nicole, và chào mừng đến với "Có gì mới trong Swift."

Swift 5.5 là bản phát hành tốt nhất của chúng tôi!

Ngôn ngữ Swift tiếp tục phát triển với tốc độ nhanh chóng, với nhiều tính năng mới, bao gồm Swift Concurrency, một mô hình mới cho lập trình không đồng bộ và đồng thời được thiết kế để làm cho lập trình đồng thời trong Swift thuận tiện, hiệu quả và an toàn.

Ngoài ra, chúng tôi đã giúp phát triển Swift dễ dàng hơn bao giờ hết, nhờ những tiến bộ trong trải nghiệm gói, các gói thư viện tiêu chuẩn mới và các tính năng nâng cao trải nghiệm của nhà phát triển.

Quan trọng như những tiến bộ này, trọng tâm của dự án Swift không phải là mã, mà là một cộng đồng những người làm việc hướng tới các mục tiêu của dự án Swift.

Đây là lý do tại sao điều quan trọng là chúng tôi đầu tư vào cộng đồng cũng như phần mềm của mình.

Tôi muốn bắt đầu mọi thứ bằng cách nói về một sáng kiến cộng đồng Swift quan trọng.

Sự đa dạng là giá trị cốt lõi của cộng đồng Swift.

Nghiên cứu cho thấy các dự án nguồn mở đa dạng có năng suất cao hơn và đưa ra quyết định tốt hơn.

Bao gồm mọi người từ mọi nguồn gốc và với quan điểm đa dạng giúp cộng đồng phát triển.

Chúng tôi, và các thành viên khác của cộng đồng Swift, đã nhìn thấy cơ hội để khuyến khích sự tham gia tích cực vào hệ sinh thái và cộng đồng Swift từ nhiều nhà phát triển hơn với sáng kiến Đa dạng trong Swift của chúng tôi.

Nhiệm vụ của Đa dạng trong Swift là thúc đẩy một cộng đồng Swift hòa nhập bằng cách nâng cao nhiều tiếng nói khác nhau và giúp các nhà phát triển bắt đầu học hỏi hoặc đóng góp cho Swift dễ dàng hơn, bất kể nền tảng của họ.

Là một phần của sáng kiến này, chúng tôi đã mở rộng blog swift.org để bao gồm các bài đăng ghi nhận và làm nổi bật những đóng góp từ nhiều nhà phát triển trong cộng đồng của chúng tôi.

Chúng tôi cũng đã tạo ra các nhóm cộng đồng trong diễn đàn Swift để các nhà phát triển kết nối với những người khác có thể đã có trải nghiệm tương tự hoặc phải đối mặt với những rào cản tương tự.

Để tham gia vào Diversity in Swift, hoặc tìm hiểu thêm, vui lòng truy cập swift.org/diversity.

Chúng tôi cũng muốn giúp các nhà phát triển đã có trong cộng đồng phát triển và đạt được mục tiêu của họ với Swift.

Để giúp việc đóng góp cho các dự án nguồn mở Swift trở nên dễ tiếp cận hơn, gần đây chúng tôi đã công bố chương trình cố vấn Swift để giúp những người mới đến nhận được sự hỗ trợ và hướng dẫn trực tiếp từ những người đóng góp thường xuyên.

Chương trình này không giới hạn trong các dự án của Apple.

Nó cũng bao gồm toàn bộ hệ sinh thái của các gói Swift và các công cụ nguồn mở.

Tiếp theo, tôi muốn nói về các gói hàng.

Các gói là một khối xây dựng cơ bản để xây dựng phần mềm, cho phép bạn tận dụng một cách thuận tiện một mảng mã nguồn mở ngày càng phát triển.

Các thành viên của cộng đồng Swift đã đưa ra một số giải pháp tuyệt vời để giúp các nhà phát triển tìm thấy các gói, như Chỉ mục Gói Swift.

Chỉ mục gói Swift là một trang được tạo bởi cộng đồng giúp bạn tìm các gói hỗ trợ Trình quản lý gói Swift.

Bây giờ, trong Swift 5.5 và Xcode 13, chúng tôi đang cung cấp các cách bổ sung để bạn tìm và truy cập các gói, bằng cách cung cấp hỗ trợ công cụ Xcode tích hợp để giúp việc sử dụng các gói trong dự án của bạn nhanh hơn và dễ dàng hơn như một phần của quy trình phát triển của bạn.

Năm nay, chúng tôi sẽ giới thiệu Bộ sưu tập Gói Swift, danh sách các gói Swift được sắp xếp mà bạn có thể sử dụng cả từ dòng lệnh và từ Xcode 13.

Với các bộ sưu tập gói, bạn không còn cần phải tìm kiếm các gói trên Internet, hoặc sao chép và dán URL để thêm chúng.

Bây giờ bạn có thể chỉ cần duyệt qua một bộ sưu tập và thêm các gói từ màn hình tìm kiếm gói mới trong Xcode.

Bộ sưu tập gói là các tệp JSON đơn giản mà bạn có thể xuất bản ở bất cứ đâu.

Bộ sưu tập gói có nghĩa là cho phép bất kỳ ai xây dựng danh sách các gói được sắp xếp cho các trường hợp sử dụng khác nhau.

Ví dụ, một người hướng dẫn cho một lớp khoa học máy tính có thể tập hợp một tập hợp các gói giúp dạy các khái niệm của lớp đó, hoặc ai đó có thể tập hợp một bộ sưu tập các gói tốt cho một lĩnh vực hoặc nhiệm vụ cụ thể hoặc được tổ chức của họ sử dụng.

Chúng tôi rất vui khi thấy tất cả những cách khác nhau mà mọi người sẽ sử dụng các bộ sưu tập.

Chúng tôi có một bài thuyết trình tuyệt vời về các bộ sưu tập bao bì mà tôi khuyên bạn nên kiểm tra để tìm hiểu thêm.

Bộ sưu tập gói bao gồm một số hỗ trợ công cụ mạnh mẽ trong Xcode.

Bây giờ bạn chỉ cần nhập khẩu từ việc sử dụng các API yêu thích của mình.

Khi bạn cố gắng nhập một mô-đun không thể tìm thấy, Xcode sẽ kiểm tra xem có bất kỳ gói nào trong bộ sưu tập gói mà bạn đã định cấu hình cung cấp mô-đun đó không và cung cấp cho bạn cơ hội tự động bắt đầu sử dụng gói đó.

Khi bạn chọn sử dụng một gói, tất cả cấu hình sẽ được xử lý cho bạn dựa trên thông tin trong bộ sưu tập gói.

Các bộ sưu tập gói cũng có thể tìm kiếm được, giúp bạn dễ dàng tìm thấy các gói hàng để đáp ứng trường hợp sử dụng của mình.

Nếu bạn quan tâm đến việc dùng thử các bộ sưu tập gói ngay hôm nay, có một số bộ sưu tập đã có sẵn, bao gồm bộ sưu tập gói Swift mà Apple xuất bản trên GitHub.

Xcode được kết nối sẵn để sử dụng bộ sưu tập Apple.

Nếu bạn quan tâm đến việc tìm hiểu thêm về các bộ sưu tập trọn gói, bao gồm các bộ sưu tập đã có sẵn từ cộng đồng, hãy xem bài đăng trên blog swift.org mới về các bộ sưu tập trọn gói.

Nói về các API yêu thích của bạn, Apple xuất bản một nhóm các gói Swift mã nguồn mở đang phát triển.

Ngoài một số cải tiến lớn cho các gói yêu thích của bạn, năm nay, chúng tôi đã tung ra thêm bốn gói mới.

Đầu tiên, tôi muốn kể cho bạn nghe về Bộ sưu tập Swift.

Swift Collections là một gói cấu trúc dữ liệu mã nguồn mở mới bổ sung cho những cấu trúc có sẵn trong Thư viện Tiêu chuẩn Swift.

Phiên bản ban đầu của Swift Collections đi kèm với việc triển khai cho ba trong số các cấu trúc dữ liệu được yêu cầu thường xuyên nhất: Deque, OrderedSet và OrderedDictionary.

Deque giống như một Mảng, ngoại trừ việc nó hỗ trợ chèn và xóa hiệu quả ở cả hai đầu.

OrderedSet là sự kết hợp mạnh mẽ giữa Mảng và Tập hợp.

Giống như Array, OrderedSet duy trì các phần tử của nó theo thứ tự và hỗ trợ truy cập ngẫu nhiên.

Giống như một Set, OrderedSet đảm bảo mỗi phần tử chỉ xuất hiện một lần và cung cấp kiểm tra thành viên hiệu quả.

Và cuối cùng là OrderedDictionary, đây là một giải pháp thay thế hữu ích cho Từ điển khi thứ tự quan trọng hoặc chúng ta cần truy cập ngẫu nhiên vào các phần tử.

Tiếp theo, hãy nói về các thuật toán Swift.

Swift Algorithms là một gói mã nguồn mở mới của các thuật toán Trình tự và Bộ sưu tập.

Chúng tôi đã thêm hơn 40 thuật toán vào Thuật toán Swift cho những thứ như tạo ra tất cả các kết hợp hoặc hoán vị của một tập hợp các phần tử hoặc lặp lại các phần tử của một chuỗi bằng hai hoặc ba hoặc trong các nhóm được xác định bởi một vị ngữ hoặc chọn năm phần tử nhỏ nhất trong một bộ sưu tập, năm phần tử lớn nhất hoặc chỉ năm phần tử

Phải mất một chút đầu tư để học từ vựng, nhưng một khi bạn làm vậy, có thể rất ấn tượng khi khám phá ra có bao nhiêu thuật toán đang ẩn trong tầm nhìn rõ ràng.

Nếu bạn muốn tìm hiểu thêm, chúng tôi có một phiên mô tả cách các gói Thuật toán và Bộ sưu tập Swift mới có thể giúp bạn làm cho mã của mình rõ ràng hơn, nhanh hơn và chính xác hơn.

Bây giờ, hãy nói về Hệ thống Swift.

Mùa thu năm ngoái, chúng tôi đã mở Swift System, một thư viện cung cấp các giao diện thành ngữ, cấp thấp cho các cuộc gọi hệ thống.

Hệ thống có sẵn trên các nền tảng Apple, Linux và thậm chí cả Windows.

Gần đây chúng tôi đã thêm các API mới mạnh mẽ vào loại FilePath của Hệ thống để thực hiện các hoạt động thao tác đường dẫn phổ biến.

Chúng bao gồm khả năng truy vấn hoặc đặt tiện ích mở rộng, thêm và xóa các thành phần và thực hiện chuẩn hóa đường dẫn.

Một đường dẫn có thể được phân tách thành gốc và các thành phần tương đối của nó.

ComponentView của FilePath là một tập hợp các thành phần đường dẫn có cấu trúc, có nghĩa là nó đi kèm với sự hỗ trợ cho nhiều thuật toán chung của Swift ngay lập tức.

Và khi nhắm mục tiêu Windows, các đường dẫn Windows, với các thành phần gốc phức tạp của chúng, được hỗ trợ đầy đủ bởi tất cả các API FilePath mới.

Tiếp theo, hãy nói về Swift Numerics.

Swift Numerics đã nhận được một số bổ sung lớn trong năm nay.

Chúng tôi đã đưa Float16 lên iOS, tvOS và watchOS vào năm ngoái.

Năm nay, chúng tôi đã thêm hỗ trợ Float16 cho Apple Silicon Macs và khả năng tạo ra các số phức dựa trên Float16.

Một bổ sung khác trong năm nay là hỗ trợ số phức cho tất cả các hàm cơ bản, như log, sin và cosin.

Bởi vì các triển khai này được viết bằng Swift, chúng thường hiệu quả hơn thư viện C truyền thống và cho phép tối ưu hóa mà nếu không sẽ không thể thực hiện được.

Cuối cùng, hãy nói về Swift ArgumentParser.

Chúng tôi đã tiếp tục tinh chỉnh Swift ArgumentParser trong năm nay, với các cải tiến như khả năng tạo các tập lệnh hoàn thành mã cho vỏ Cá, tham gia các tùy chọn ngắn và các thông báo lỗi được cải thiện.

Chúng tôi cũng đã vượt qua một cột mốc quan trọng vào mùa xuân này khi ArgumentParser được Trình quản lý gói Swift thông qua trong Xcode 12.5.

Đúng rồi!

Nếu bạn đã sử dụng công cụ dòng lệnh Swift Package Manager gần đây, bạn đã sử dụng Swift ArgumentParser.

Tiếp theo, tôi muốn nói về một số công việc chúng tôi đã làm để hỗ trợ Swift phát triển máy chủ.

Năm ngoái, chúng tôi đã thêm hỗ trợ cho một số nền tảng, bao gồm Amazon Linux.

Năm nay, chúng tôi đã theo dõi công việc đó bằng cách đầu tư vào hiệu suất và chức năng cho các ứng dụng máy chủ Swift.

Chúng tôi bắt đầu bằng cách cho phép liên kết tĩnh trên Linux, giúp cải thiện thời gian khởi động ứng dụng, cũng như đơn giản hóa việc triển khai các ứng dụng máy chủ, hiện có thể được triển khai dưới dạng một tệp duy nhất.

Ngoài ra, trong Swift 5.5, mã hóa và giải mã JSON được sử dụng trên Linux đã được triển khai lại từ đầu, dẫn đến tăng hiệu suất cho hầu hết các trường hợp sử dụng phổ biến.

Cuối cùng, chúng tôi đã nâng cao và tối ưu hóa hiệu suất của chính thư viện thời gian chạy AWS Lambda.

Tất cả công việc này đã làm cho các chương trình Swift chạy trên AWS Lambda bắt đầu nhanh hơn 33%, cũng như thời gian gọi nhanh hơn 40% cho một lambda được định tuyến qua AWS API Gateway.

Ngoài việc tối ưu hóa hiệu suất thư viện thời gian chạy AWS, chúng tôi đã cấu trúc lại nó để sử dụng mô hình không đồng bộ/chờ đợi mới của mình thay vì đóng cửa.

Cải thiện trải nghiệm của nhà phát triển Swift là một trọng tâm quan trọng khác trong Swift 5.5.

Tôi muốn bắt đầu bằng cách nói về tài liệu.

Cung cấp tài liệu tuyệt vời là chìa khóa để tạo ra trải nghiệm mượt mà và thú vị cho người dùng khuôn khổ.

Năm nay, chúng tôi sẽ giới thiệu DocC, một trình biên dịch tài liệu được tích hợp sâu bên trong Xcode 13, để giúp bạn dạy các nhà phát triển cách sử dụng khung hoặc gói Swift của mình.

Giờ đây, việc viết và chia sẻ tài liệu tuyệt vời trở nên dễ dàng hơn bao giờ hết.

DocC được xây dựng từ đầu, sử dụng các công cụ và công nghệ mà bạn đã biết và yêu thích, chẳng hạn như nhận xét đánh dấu trong mã nguồn Swift của bạn, để bạn có thể dễ dàng viết và phân biệt tài liệu của mình.

Chúng tôi có bốn phiên tuyệt vời để hiển thị cho bạn mọi khía cạnh của tài liệu DocC trong Xcode.

Tôi thực sự khuyên bạn nên kiểm tra chúng.

Và bây giờ, tôi rất vui mừng thông báo rằng Swift DocC sẽ được mở nguồn vào cuối năm nay.

Swift DocC nguồn mở sẽ cho phép các nhà phát triển dễ dàng tạo ra tài liệu tuyệt vời hơn trên tất cả các nền tảng được hỗ trợ của Swift.

Trong Swift 5.5, chúng tôi đã đầu tư vào việc cải thiện chất lượng và hiệu suất trong trình kiểm tra loại.

Một kết quả của việc này là bạn sẽ thấy ít lỗi "biểu thức quá phức tạp" hơn khi biên dịch mã của mình.

Chúng tôi cũng tăng tốc hiệu suất để kiểm tra loại các ký tự mảng.

Trong bản phát hành này, chúng tôi cũng đang nâng cao năng suất của nhà phát triển với ba cải tiến chính để tăng tốc độ xây dựng gia tăng.

Trước hết, bây giờ chúng tôi hỗ trợ nhập gia tăng, có nghĩa là bây giờ chúng tôi không còn xây dựng lại mọi tệp nguồn nhập mô-đun khi mô-đun đó thay đổi.

Ngoài ra, bây giờ chúng tôi tính toán biểu đồ phụ thuộc mô-đun trước để chúng tôi có thể nhanh chóng bắt đầu các bản dựng gia tăng chỉ những gì đã thay đổi.

Cuối cùng, chúng tôi đã mở rộng biên dịch lại có chọn lọc để hoạt động với các tiện ích mở rộng, có nghĩa là ít biên dịch lại hơn khi bạn thay đổi nội dung của tiện ích mở rộng.

Sử dụng dự án mã nguồn mở SwiftDriver làm ví dụ, trung bình, với việc nhập gia tăng trong Swift 5.5, giờ đây chúng tôi biên dịch lại ít hơn một phần mười số tệp khi các mô-đun được nhập thay đổi và thời gian xây dựng giảm khoảng một phần ba.

Những cải tiến hiệu suất từ việc nhập khẩu gia tăng có nghĩa là bây giờ bạn có thể mô đun hóa dự án của mình và thay đổi một mô-đun đã nhập mà không bị phạt lớn trong hiệu suất xây dựng.

Và nhân tiện, một số cải tiến hiệu suất này đã được thực hiện bởi một cột mốc quan trọng cho dự án Swift, phần đầu tiên của trình biên dịch được viết bằng Swift.

Đây là Trình điều khiển Swift, chương trình điều phối việc biên dịch mã nguồn Swift.

Dự án này bắt đầu vào cuối năm 2019 và, kể từ Xcode 13, hiện là mặc định cho việc biên dịch Swift.

Cuối cùng, hãy nói về những cải tiến mà chúng tôi đã thực hiện để giúp quản lý bộ nhớ trong Swift hiệu quả hơn, vì vậy các chương trình Swift lấy lại bộ nhớ nhanh hơn.

Các trường hợp lớp Swift sử dụng Đếm tham chiếu tự động, ARC, để theo dõi có bao nhiêu tham chiếu đến một đối tượng cụ thể tại bất kỳ thời điểm nào.

Trong hầu hết các trường hợp, điều này có nghĩa là quản lý bộ nhớ chỉ hoạt động trong Swift và bạn không cần phải tự nghĩ về việc quản lý bộ nhớ.

ARC tự động giải phóng bộ nhớ được sử dụng bởi các phiên bản lớp khi các phiên bản đó không còn cần thiết nữa.

Để làm điều này, trình biên dịch Swift chèn một thao tác giữ lại bất cứ khi nào một tham chiếu mới được tạo và một thao tác phát hành bất cứ khi nào một tham chiếu mới ngừng được sử dụng.

Năm nay, chúng tôi đã giới thiệu một cách mới để theo dõi các tham chiếu bên trong trình biên dịch cho phép trình biên dịch giảm đáng kể số lượng hoạt động lưu giữ và phát hành.

Chúng tôi đã thấy những cải tiến về hiệu suất và kích thước mã có thể đo lường được từ sự thay đổi này.

Chúng tôi đã thêm cài đặt Xcode, Tối ưu hóa tuổi thọ đối tượng, điều đó sẽ cho phép bạn thấy hiệu quả của việc tối ưu hóa ARC mới, tích cực hơn này đối với mã của mình.

Để biết thêm thông tin về ARC, vui lòng xem phiên "ARC trong Swift".

Đây chỉ là một số cải tiến do Swift 5.5 mang lại cho bạn.

Tiếp theo, Tim sẽ nói chuyện với bạn về Swift Concurrency và các diễn biến khác trong ngôn ngữ Swift.

Cảm ơn, Nicole.

Tất cả chúng ta đều rất hào hứng với Swift Concurrency, nhưng trước khi tôi làm điều đó, tôi muốn thảo luận về một số thay đổi khác mà chúng tôi đã thực hiện đối với Swift để đơn giản hóa và cải thiện chương trình hàng ngày.

Đây là danh sách các cải tiến công thái học mà chúng tôi đã thực hiện trong năm nay.

Các số SE xác định các đề xuất Swift Evolution.

Mỗi đề xuất này được viết bởi một thành viên của cộng đồng, được thảo luận trên diễn đàn Swift Evolution và được Nhóm Swift Core chấp thuận trước khi được chấp nhận vào ngôn ngữ.

Tất cả các đề xuất SE, cho dù được chấp nhận, từ chối hay vẫn đang được thảo luận, đều có thể được tìm thấy trong kho lưu trữ Swift Evolution trên GitHub.

Hãy xem xét một vài trong số những thay đổi này.

Đầu Tiên, Những Người Xây Dựng Kết Quả.

Khi SwiftUI lần đầu tiên được công bố, nó đã giới thiệu một cú pháp mới có thể được sử dụng để mô tả nhanh chóng và dễ dàng các hệ thống phân cấp đối tượng phức tạp.

Năm vừa qua, cú pháp đó đã được chuẩn hóa và tinh chỉnh thông qua quy trình Swift Evolution để nó có thể được sử dụng dễ dàng hơn trong nhiều bối cảnh khác nhau.

Nếu bạn muốn tận dụng công nghệ mạnh mẽ này, chúng tôi có một phiên dành riêng cho việc sử dụng Trình tạo kết quả.

Giao thức Codable là một cách thuận tiện để tuần tự hóa dữ liệu của bạn, nhưng từ lâu nó đã bị thiếu sót đáng chú ý.

Hãy xem xét Enum hai trường hợp này.

Để làm cho nó phù hợp với Codable, bạn đã từng phải thực hiện thủ công tất cả các bản mẫu này.

Bây giờ, bạn chỉ cần khai báo sự phù hợp của Codable và trình biên dịch sẽ thực hiện tất cả công việc đó cho bạn.

Chúng tôi cũng đã thực hiện một số cải tiến quan trọng đối với trình kiểm tra kiểu của Swift.

Như bạn đã biết, suy luận kiểu trong Swift có nghĩa là bạn có thể bỏ qua thông tin kiểu dư thừa.

Ở đây, nó cho phép bạn rút ngắn Coffee.regular xuống chỉ còn .regular.

Nhưng các cấu trúc giống Enum cũng được thể hiện theo những cách khác.

Ví dụ, bạn có thể có một tập hợp các loại phù hợp với giao thức và muốn sử dụng các trường hợp của các loại đó trong API của bạn.

Bây giờ bạn có thể tham khảo các trường hợp của các loại đó bằng cách sử dụng cùng một ký hiệu dấu chấm mà bạn sử dụng cho Enums, bằng cách khai báo một vài thuộc tính tĩnh trên giao thức của bạn.

Điều này được kích hoạt bởi những cải tiến đối với trình kiểm tra kiểu của Swift cho phép nó suy luận tổng quát hơn về các thuộc tính tĩnh trong ngữ cảnh chung, bao gồm các tham chiếu thuộc tính được xâu chuỗi như .large ở đây.

Điều này cho phép các tác giả thư viện xây dựng các mô hình dữ liệu chung tinh vi với các API giống như Enum tự nhiên và dễ sử dụng.

Giấy gói tài sản cũng đã được cải thiện trong năm nay.

Giấy gói thuộc tính là một công cụ thuận tiện để áp dụng ngữ nghĩa phổ biến cho các thuộc tính.

Nhiều người trong số các bạn đã triển khai trình bao bọc tài sản của riêng mình bằng cách sử dụng chú thích @propertyWrapper trên một cấu trúc.

Đây là một ví dụ bổ sung yêu cầu rằng tài sản không được để trống.

Với việc triển khai SE-0293, các trình bao bọc thuộc tính tương tự đó hiện có thể được sử dụng trên các tham số hàm và đóng.

Tích lũy, những thay đổi này và những thay đổi khác đối với ngôn ngữ có thể đơn giản hóa rất nhiều vấn đề mã hóa phổ biến.

Hãy cùng nhau xem xét chúng trong bối cảnh của một mẫu mã SwiftUI đơn giản.

Đây là Chế độ xem SwiftUI có một thuộc tính duy nhất, chứa một mảng cài đặt và nội dung trình bày danh sách các cài đặt đó, với một nút chuyển đổi bên cạnh mỗi cài đặt.

Hãy xem lại mã này và xem các tính năng Swift 5.5 mới có thể đơn giản hóa nó như thế nào.

Đầu tiên, trình khởi tạo Toggle() rõ ràng là trùng lặp.

Sự trùng lặp này từng là cần thiết, nhưng chúng tôi đã nới lỏng việc sử dụng #if để cho phép nó bao quanh các biểu thức hậu tố, chẳng hạn như các công cụ sửa đổi toggleStyle ở đây, cho phép chúng tôi tính đến yếu tố dự phòng đó.

SwiftUI cũng đã được cập nhật để tận dụng các cải tiến trình kiểm tra kiểu mới mà tôi đã đề cập trước đó.

Vì vậy, bạn có thể sử dụng ký hiệu chấm tự nhiên ở nhiều nơi hơn.

Nó - hơi khó xử khi chỉ định các chỉ mục cho mảng cài đặt và sau đó lập chỉ mục mảng trong phần đóng.

Chúng tôi chỉ muốn bước qua các giá trị.

Bây giờ bạn có thể chuyển liên kết dự kiến trực tiếp vào hàm tạo Danh sách, sau đó có thể lặp lại các giá trị mảng.

Hỗ trợ mới cho các đối số trình bao bọc thuộc tính cho phép chúng tôi viết đối số đóng với ký hiệu đô la, điều này sẽ cung cấp cho chúng tôi cài đặt ràng buộc trong đóng của chúng tôi.

Điều đó, đến lượt nó, cho phép chúng tôi truy cập cả giá trị được bọc và ràng buộc.

Và cuối cùng, trình biên dịch Swift hiện chuyển đổi minh bạch giữa CGFloat và Double, cho phép bạn loại bỏ nhiều chuyển đổi số dư thừa khi làm việc với API nền tảng Apple.

Như bạn thấy, nỗ lực liên tục của chúng tôi để tinh chỉnh ngôn ngữ cốt lõi đang làm cho mã bạn viết mỗi ngày đơn giản hơn bao giờ hết và tạo ra nhiều cơ hội hơn cho các tác giả thư viện xây dựng các API phong phú và dễ sử dụng.

Để biết thêm thông tin về một số cách mà lập trình SwiftUI đã được cải thiện trong năm nay, vui lòng xem phiên "Có gì mới trong SwiftUI".

Tất nhiên, điểm nổi bật của Swift 5.5 là một tập hợp các tính năng lồng vào nhau để hỗ trợ lập trình không đồng bộ và đồng thời.

Tôi sẽ giới thiệu những điều này trong giây lát, nhưng trước tiên, hãy để tôi giải thích ngắn gọn ý của tôi khi nói "đồng bộ" và "đồng thời".

Các dự án phần mềm được cấu tạo từ các khối mã thực thi theo một số thứ tự.

Trong trường hợp đơn giản nhất, các khối đó thực thi, lần lượt từng khối một theo một chuỗi đơn giản.

Nhưng các cấu trúc khác cũng phổ biến.

Ví dụ, các API mạng thường được thiết kế theo phong cách không đồng bộ.

Trong các API này, sau khi bạn đã gửi yêu cầu đến máy chủ từ xa, có thể có một sự chậm trễ kéo dài cho đến khi bạn nhận được phản hồi và cần phải làm nhiều việc hơn.

Lý tưởng nhất, mã của bạn sẽ bị đình chỉ trong thời gian trì hoãn này để nó không sử dụng bất kỳ tài nguyên nào cho đến khi bạn có thể hành động theo phản hồi.

Ngược lại, mã đồng thời là khi bạn có hai hoặc nhiều khối mã mà bạn muốn chạy cùng một lúc.

Đây thường là những hoạt động độc lập nhưng có liên quan.

Ví dụ, xử lý một số khung hình của video hoặc chạy lần lặp tiếp theo của trình phân loại ML cùng lúc bạn đang cập nhật giao diện người dùng với bộ kết quả trước đó.

Với những ý tưởng đó trong đầu, hãy xem xét một ví dụ lập trình không đồng bộ đơn giản mà không cần sử dụng các tính năng mới của Swift.

Nếu bạn đã thực hiện nhiều chương trình iOS hoặc macOS, bạn có thể đã viết mã tương tự như thế này nhiều lần.

Điều này sử dụng lớp URLSession của Foundation để thực hiện cuộc gọi mạng.

Phương pháp dataTask là một thao tác không đồng bộ.

Bạn gọi nó với một lập luận kết thúc.

Khi kết quả có sẵn, việc đóng cửa của bạn sẽ được gọi với kết quả để xử lý.

Tuy nhiên, việc sử dụng các đóng cửa theo cách này để thể hiện mã không đồng bộ dẫn đến một thứ tự hoạt động hơi khó xử, như bạn có thể thấy bằng cách xem qua mã này.

Đầu tiên, có một số thiết lập ban đầu và phương pháp dataTask cung cấp cho chúng ta một xử lý nhiệm vụ.

Sau đó, chúng tôi tiếp tục xử lý nhiệm vụ để bắt đầu thao tác nền.

Hàm fetchImage thực sự trả về tại thời điểm này.

Bất cứ ai gọi cho chúng tôi phải sẵn sàng tiếp tục, mặc dù chúng tôi chưa thực sự hoàn thành công việc mà chúng tôi được yêu cầu làm.

Sau đó, sau khi hoạt động mạng kết thúc, việc đóng cửa này sẽ có cơ hội xử lý kết quả.

Hy vọng rằng, mọi thứ diễn ra tốt đẹp, và chúng ta có thể gọi cho người xử lý hoàn thành của mình với kết quả cuối cùng.

Bên cạnh thứ tự thực hiện hơi khó xử, việc sử dụng trình xử lý hoàn thành cũng ngăn chúng tôi sử dụng xử lý lỗi thử/bắt.

Lưu ý cách dataTask cung cấp một tham số lỗi bổ sung cho trình xử lý hoàn thành của nó và cách chúng tôi phải gọi trình xử lý hoàn thành của mình với mọi lỗi có thể xảy ra.

Để xem Swift 5.5 cải thiện điều này như thế nào, chúng ta hãy xem một dòng mã này.

Lưu ý cách cuộc gọi này trả về một nhiệm vụ, một xử lý trừu tượng đại diện cho hoạt động nền.

Đó không thực sự là những gì chúng tôi muốn.

Chúng tôi chỉ muốn lấy dữ liệu.

Vì vậy, hãy thúc đẩy ý tưởng đó một chút và xem chúng ta kết thúc ở đâu.

Vì chúng tôi đang xử lý HTTP, chúng tôi cũng cần nắm bắt một số siêu dữ liệu phản hồi.

Vì vậy, chức năng thực sự sẽ trả về một cặp, với dữ liệu thực tế là mục đầu tiên và thông tin bổ sung là mục thứ hai.

Bằng cách cấu trúc điều này như một lệnh gọi hàm trả về dữ liệu, giờ đây chúng ta có thể sử dụng xử lý lỗi thử/bắt để loại bỏ rất nhiều mẫu từ ví dụ trước.

Chúng tôi chỉ cần một chút cú pháp để thông báo cho trình biên dịch rằng hàm của chúng tôi có thể bị đình chỉ ngay khi phương thức dữ liệu bắt đầu và chúng tôi sẽ không thể hoàn thành bài tập cho đến khi thao tác đó hoàn tất.

Đó chính xác là những gì từ khóa await mới làm.

Hãy xem xét điều đó trong ngữ cảnh.

Đây là chức năng fetchImage của chúng tôi bây giờ trông như thế nào.

Như bạn thấy, mã này bây giờ dễ theo dõi hơn nhiều.

Kiểm soát luồng từ trên xuống dưới, chúng ta không còn cần đóng lồng nhau nữa và chúng ta có thể sử dụng xử lý lỗi thử/bắt.

Từ khóa await chỉ ra một điểm mà hàm fetchImage này có thể bị đình chỉ, được đặt sang một bên để không chạy cho đến khi một số sự kiện xảy ra cho phép nó tiếp tục.

Trong trường hợp này, ngay sau khi URLSession bắt đầu yêu cầu, chức năng của chúng tôi sẽ bị đình chỉ bởi thời gian chạy Swift trong khi thao tác được thực hiện ở nơi khác.

Khi kết quả cuối cùng đã sẵn sàng, cho dù đó là phản hồi thành công hay lỗi ném, chỉ khi đó chức năng của chúng tôi mới được nối lại.

Nếu đó là phản hồi thành công, chúng tôi sẽ hoàn thành việc khởi tạo dữ liệu và các biến phản hồi.

Nếu đó là một lỗi bị ném, chúng tôi sẽ chuyển lại cho bất kỳ ai đã gọi cho chúng tôi.

Một chức năng không đồng bộ không sử dụng bất kỳ tài nguyên nào trong khi nó bị đình chỉ.

Đặc biệt, nó không chặn một chủ đề.

Điều này cho phép thời gian chạy Swift sử dụng lại luồng mà hàm này đang chạy cho công việc khác.

Điều này cho phép một vài chủ đề được chia sẻ giữa nhiều quy trình không đồng bộ.

Về mặt cú pháp, các từ khóa không đồng bộ và chờ đợi được sử dụng tương tự như ném và thử.

Async trang trí khai báo hàm để chỉ ra rằng hàm này phải được biên dịch để hỗ trợ đình chỉ.

Sử dụng từ khóa await để đánh dấu bất kỳ cuộc gọi nào đến hàm, phương thức hoặc đóng không đồng bộ.

Tất nhiên, cơ chế đầy đủ thú vị hơn rất nhiều so với những gì tôi đã trình bày ở đây.

Bạn có thể xem các phiên "Gặp gỡ không đồng bộ/chờ đợi trong Swift" và "Swift concurrency: Hậu trường" để tìm hiểu thêm về cách thức hoạt động của tất cả những điều này.

Tiếp theo, chúng ta hãy xem xét hỗ trợ đồng thời mới của Swift, được xây dựng dựa trên các khái niệm không đồng bộ/chờ đợi mà tôi vừa mô tả.

Đây là một chức năng hiển thị ba hình ảnh khác nhau và sau đó kết hợp chúng.

Như đã viết ở đây, các hoạt động này là tuần tự.

Hình nền, tiền cảnh và tiêu đề sẽ được hiển thị lần lượt, với mỗi hình ảnh chỉ bắt đầu sau khi hình ảnh trước đó hoàn thành.

Chúng tôi muốn các hoạt động kết xuất diễn ra song song.

Nhưng chỉ chạy chúng trong các luồng khác nhau là không đủ: chúng ta cũng cần tổ chức thao tác hợp nhất, cho đến khi chúng ta có cả ba kết quả.

Điều này tương tự, ở một số khía cạnh, với mã hóa không đồng bộ mà tôi vừa nói đến.

Vì vậy, chúng tôi đánh dấu chức năng này là "không đồng bộ" để nó có thể tạm dừng nếu nó cần đợi kết quả đang được tính toán trong các luồng khác.

Tiếp theo, chúng tôi sử dụng cú pháp let không đồng bộ để chạy song song hai thao tác đầu tiên.

Async let trông rất giống một khởi tạo biến, và về cơ bản đó là những gì nó là.

Nhưng việc khởi tạo này sẽ chạy song song với mã khác cho đến khi bạn cố gắng sử dụng kết quả.

Bởi vì các biến nền và tiền cảnh đang được khởi tạo với let không đồng bộ, thời gian chạy của Swift, nếu cần, sẽ tạm dừng hoạt động hợp nhất cho đến khi các giá trị đó sẵn sàng.

Chúng tôi đánh dấu hàm hợp nhất bằng từ khóa đang chờ để chỉ ra điều này.

Điểm quan trọng nhất về mã này là các tác vụ nền không thể tồn tại lâu hơn chức năng này.

Nói cách khác, chức năng này không thể và sẽ không quay lại nếu một trong hai tác vụ nền vẫn đang chạy.

Nếu một lỗi được ném từ bất kỳ đâu bên trong hàm này, thời gian chạy Swift vẫn sẽ chờ các tác vụ nền hoàn thành.

Ở đây, tôi đã đánh dấu một điểm đánh dấu thử cho biết tính toán của hình ảnh tiêu đề có thể ném, nhưng điều tương tự cũng áp dụng cho tất cả các lỗi ném, ngay cả khi chúng xảy ra trong một chuỗi riêng biệt.

Để giữ cho mọi thứ phản hồi nhanh, khi có lỗi ném, thời gian chạy Swift sẽ báo hiệu các tác vụ chưa hoàn thành để chúng có cơ hội hoàn thành sớm.

Phiên của chúng tôi về đồng thời có cấu trúc cung cấp thêm chi tiết, bao gồm thảo luận đầy đủ về cơ chế hủy này và các lựa chọn thay thế linh hoạt hơn cho cú pháp cho phép không đồng bộ mà tôi đã thảo luận ở đây.

Trong phần trước, tôi đã chỉ ra cách Swift 5.5 giúp dễ dàng chạy các thao tác trên nhiều luồng một cách có cấu trúc, có kỷ luật.

Tất nhiên, điều đó không hoàn toàn đủ.

Bất cứ khi nào hai luồng riêng biệt chia sẻ dữ liệu, bạn có nguy cơ dữ liệu sẽ không nhất quán hoặc thậm chí bị hỏng.

Cấu trúc diễn viên mới của Swift giúp bảo vệ dữ liệu của bạn chống lại những vấn đề như vậy.

Một lần nữa, hãy bắt đầu với một ví dụ về mã mà bạn có thể đã tự viết.

Đây là một lớp học thu thập số liệu thống kê.

Nó chứa một bộ đếm và nhiều mã khác sẽ gọi phương thức tăng để cập nhật bộ đếm đó bất cứ khi nào có điều gì đó thú vị xảy ra.

Thật không may, mã này không hoạt động tốt trong một hệ thống đa luồng.

Nếu hai hoặc nhiều luồng gọi phương thức tăng cùng một lúc, bạn có thể kết thúc với một số lượng bị hỏng nặng.

Thay đổi lớp học này thành một diễn viên Swift bảo vệ chống lại sự tham nhũng như vậy.

Các diễn viên làm việc bằng cách đình chỉ bất kỳ hoạt động nào có thể gây hỏng dữ liệu cho đến khi an toàn để thực hiện thay đổi cụ thể đó.

Điều này có nghĩa là bạn thường cần sử dụng await khi bạn gọi một phương thức diễn viên từ bên ngoài diễn viên.

Các diễn viên cũng làm việc liền mạch với async/await.

Đánh dấu phương thức xuất bản này là không đồng bộ cho phép nó bị đình chỉ trong khi chờ hoạt động mạng.

Trong khi nó bị đình chỉ, các phương pháp khác có thể chạy trên tác nhân này mà không cần đợi hoạt động mạng hoàn tất và không có nguy cơ hỏng dữ liệu.

Diễn viên là các loại tham chiếu, giống như các lớp học, nhưng chúng tuân theo một số quy tắc được thiết kế để đảm bảo rằng các diễn viên an toàn để sử dụng trong môi trường đa luồng.

Bằng cách đóng gói dữ liệu của bạn thành các tác nhân, bạn đang nói rõ rằng bạn mong đợi dữ liệu này được truy cập đồng thời và bạn muốn trình biên dịch Swift và thời gian chạy phối hợp truy cập để không thể bị hỏng.

Và, tất nhiên, chúng tôi có một phiên đầy đủ dành riêng cho cấu trúc diễn viên mới của Swift.

Ở đó, bạn có thể tìm ra cách tận dụng đầy đủ các khả năng mà điều này mang lại.

Trước khi chúng ta kết thúc, hãy nói một chút về tương lai của Swift.

Chúng tôi tin rằng ba khái niệm chính mà chúng tôi đã giới thiệu trong Swift 5.5 - các chức năng không đồng bộ, đồng thời có cấu trúc và các tác nhân - là cơ sở tốt để tạo mã an toàn và hiệu suất cao.

Đối với Swift 6, chúng tôi đã nghiên cứu các cách để trình biên dịch phát hiện nhiều loại lỗi đồng thời sớm hơn trong quá trình phát triển và cung cấp cho bạn các lỗi và hướng dẫn chi tiết hơn trong việc khắc phục các vấn đề đó.

Mục tiêu của chúng tôi, khá đơn giản, là loại bỏ hoàn toàn các loại lỗi đồng thời phổ biến nhất, để làm cho lập trình không đồng bộ và đồng thời không phức tạp hơn bất kỳ loại lập trình nào khác.

Và, tất nhiên, khi chúng tôi tiếp tục cải thiện sự hiểu biết của trình biên dịch về các khái niệm này, chúng tôi cũng hy vọng mã sử dụng các cấu trúc mới này sẽ trở nên hiệu quả hơn so với ngày nay.

Swift là một nỗ lực cởi mở, hợp tác chào đón ý kiến đóng góp của bạn.

Để giúp Swift 6 trở nên tốt hơn, hãy cho chúng tôi biết về trải nghiệm của bạn với Swift 5.5.

Những tính năng mới này hoạt động tốt như thế nào đối với bạn trong việc phát triển ứng dụng trong thế giới thực?

Hãy thử một trong những ảnh chụp nhanh trình biên dịch mà bạn có thể tìm thấy trên swift.org.

Chúng tôi cung cấp những ảnh chụp nhanh này để bạn có thể cài đặt chúng vào Xcode và thử các tính năng mới khi chúng tôi đang phát triển chúng.

Bằng cách sử dụng các ảnh chụp nhanh này, bạn có thể giúp hướng dẫn phiên bản Swift tiếp theo.

Các diễn đàn Swift là mạch máu của dự án.

Mỗi tính năng mà tôi đã thảo luận đều bắt đầu cuộc sống bằng cách được giới thiệu trên diễn đàn Swift Evolution, nơi một nhóm người đa dạng đã giúp tinh chỉnh nó thành một đề xuất làm việc.

Chúng tôi cũng có các diễn đàn dành cho nhiều khía cạnh khác của Swift, bao gồm khu vực trợ giúp cho người dùng mới và nơi trao đổi tin tức quan tâm đến cộng đồng Swift.

Có nhiều cách khác để bạn có thể làm cho Swift tốt hơn và chúng tôi mong muốn thu hút nhiều người hơn nữa, chẳng hạn như thông qua Chương trình Cố vấn mới mà Nicole đã đề cập vào đầu phiên này.

Yêu cầu duy nhất là mong muốn chân thành giúp cải thiện Swift cho mọi người trong cộng đồng của chúng tôi.

Tôi mong nhận được phản hồi từ bạn, và tôi hy vọng bạn thích hội nghị.

[Nhạc lạc quan].