10057

♪ Nhạc bass đang phát ♪

♪

Chris Donegan: Xin chào, tôi là Chris, một kỹ sư trên UIKit.

Tôi sẽ được tham gia sau bởi các đồng nghiệp Anant và Mohammed.

iPad là thiết bị chính của nhiều người do sức mạnh và khả năng của nó.

Trong video này, bạn sẽ tìm hiểu về một số tính năng mới thú vị mà bạn nên sử dụng để đưa ứng dụng iPad của mình lên một tầm cao mới.

Đầu tiên, tôi sẽ cho bạn thấy những tiến bộ mới nhất trong đa nhiệm và cảnh quay.

Sau đó, Anant sẽ hướng dẫn bạn những thay đổi mạnh mẽ đối với các phím tắt.

Cuối cùng, Mohammed sẽ chỉ cho bạn những cải tiến mới nhất cho con trỏ hệ thống.

Hãy bắt tay ngay vào đa nhiệm.

iPadOS 13 đã giới thiệu khả năng chạy nhiều phiên bản giao diện người dùng ứng dụng của bạn.

Trong iPadOS 15, chúng tôi đang cải thiện trải nghiệm này với các API mới để trình bày cảnh cũng như khôi phục trạng thái nâng cao.

Những cải tiến này được xây dựng dựa trên cơ sở hạ tầng UIScene hiện có.

Nếu bạn chưa áp dụng UIScene, hãy xem "Giới thiệu nhiều Windows trên iPad."

Hãy xem xét ngắn gọn các khái niệm chính.

Một cảnh đại diện cho một phiên bản duy nhất của giao diện người dùng ứng dụng của bạn.

Cấu trúc của các thành phần của cảnh được xác định bởi cấu hình cảnh.

Ở mức tối thiểu, nó xác định vai trò của cảnh và lớp đại diện.

Bạn cũng có thể cung cấp tên, bảng phân cảnh và lớp con cảnh.

Cấu hình cảnh có thể được khai báo trong Info.plist của bạn hoặc được tạo trong thời gian chạy bằng cách sử dụng đối tượng UISceneConfiguration.

Nội dung của một cảnh được đại diện bởi NSUserActivity.

Những hoạt động này được sử dụng để yêu cầu các cảnh cũng như để khôi phục trạng thái.

Một cảnh được quản lý bởi một đại biểu cảnh.

Người đại diện chịu trách nhiệm thiết lập giao diện người dùng, phản hồi các sự kiện vòng đời, cũng như lưu và khôi phục trạng thái.

Cuối cùng, một cảnh được theo dõi bởi một phiên cảnh.

Bản thân cảnh có thể bị ngắt kết nối và kết nối lại bởi hệ thống khi nó ở chế độ nền.

Phiên cảnh theo dõi cảnh bất kể trạng thái kết nối của nó và vẫn tồn tại giữa các lần phóng.

Phiên có thể được coi là đại diện trong trình chuyển đổi ứng dụng hệ thống.

Mỗi mục trong trình chuyển đổi tương ứng với một phiên cảnh.

Khi yêu cầu một cảnh từ hệ thống, bạn có thể cung cấp một đối tượng tùy chọn để tùy chỉnh yêu cầu.

iPadOS 15 có một lớp con tùy chọn mới dành riêng cho các cảnh cửa sổ.

Sử dụng lớp con này cho phép bạn chỉ định một phong cách trình bày.

Phong cách trình bày cảnh cửa sổ ảnh hưởng đến cách cảnh được trình bày so với các cảnh khác trong không gian làm việc.

Có ba giá trị khả thi: nổi bật, tiêu chuẩn và tự động.

Đây là một cảnh sử dụng phong cách trình bày nổi bật.

Nó được trình bày theo phương thức trong không gian làm việc hiện tại với những cảnh đằng sau nó mờ đi.

Bởi vì nó là phương thức, nó nên cung cấp các nút Hủy, Đóng hoặc Xong.

Phong cách mới này có thể được coi là nơi dàn dựng cho những cảnh mới.

Nó có thể được định vị lại giống như bất kỳ cảnh nào khác bằng cách sử dụng các điều khiển đa nhiệm mới và nó cũng có thể được chuyển vào kệ ứng dụng để sử dụng.

Khi xem xét liệu phong cách này có phù hợp với một cảnh hay không, có một số hướng dẫn cần ghi nhớ.

Đầu tiên, những cảnh nổi bật nên tự nó hữu ích.

Chúng không nên được sử dụng để cung cấp các tùy chọn hoặc công cụ cho một cảnh khác.

Họ nên cung cấp nút Xong hoặc Đóng và họ nên dành riêng cho nội dung cụ thể trong ứng dụng của bạn như tài liệu hoặc tệp.

Phạm vi nội dung chuyên dụng này phải được xác định trong điều kiện kích hoạt của cảnh.

Để biết thêm thông tin về các điều kiện kích hoạt, hãy xem "Nhắm mục tiêu nội dung với nhiều cửa sổ".

Ví dụ này cho thấy cách Safari đang mở một cảnh mới bằng cách sử dụng phong cách tiêu chuẩn.

Chúng được trình bày cạnh nhau, cho phép tương tác với từng cái và cả hai đều cung cấp đầy đủ chức năng của cảnh chính.

Bạn cũng có thể chỉ định tự động làm kiểu.

Giá trị này cho hệ thống biết rằng nó nên chọn kiểu tốt nhất dựa trên cách nó được yêu cầu.

iPadOS 15 không chỉ cung cấp một cách để tùy chỉnh bản trình bày bằng cách sử dụng các phong cách, nó còn giúp mọi người mở nội dung của họ dễ dàng hơn trong các cảnh mới.

Trên Mac, người ta thường tìm thấy một mục Mở trong Cửa sổ Mới trong các menu ngữ cảnh.

Bạn nên mang trải nghiệm quen thuộc này đến ứng dụng iPad của mình bằng cách sử dụng UIWindowScene.ActivationAction.

Đó là một lớp con UIAction mới để yêu cầu các cảnh có thể được sử dụng trong các menu, nút và các mục nút thanh.

Để thêm chức năng này vào ứng dụng của bạn, hãy bắt đầu bằng cách khởi tạo UIWindowScene.ActivationAction.

Nó được khởi tạo với một đóng được thực thi khi mục được chọn.

Việc đóng sẽ trả lại cấu hình kích hoạt với hoạt động của người dùng cho nội dung của cảnh mới.

Cuối cùng, đặt hành động vào thực đơn và bạn đã sẵn sàng.

Trên iPad và Mac Catalyst, menu hiển thị mục Mở trong Cửa sổ Mới, khi được chọn, sẽ hiển thị một cảnh mới.

Trên iPhone, mục này được tự động ẩn vì nhiều cảnh không được hỗ trợ.

Nếu bạn muốn hiển thị một mục khác ở vị trí của nó, bạn có thể cung cấp một hành động thay thế.

Hãy cập nhật ví dụ trước để đưa ra một ví dụ.

Để làm điều này, hãy bắt đầu bằng cách tạo hành động thay thế.

Tiêu đề và hình ảnh của hành động mới được hiển thị khi không có nhiều cửa sổ.

Sau đó, cập nhật trình khởi tạo hành động kích hoạt cảnh bằng cách chuyển hành động mới làm hành động thay thế.

Với một hành động thay thế được cung cấp, các menu trên iPad và Mac Catalyst vẫn hiển thị mục Mở trong Cửa sổ Mới nhưng trên iPhone, mục Hiển thị Chi tiết hiển thị; tất cả được thực hiện mà không có một điều kiện duy nhất trong mã của bạn.

Thêm các mục menu này là một cách rõ ràng và quen thuộc để mọi người mở nội dung của họ trong các cảnh mới.

Nhưng đó không phải là cách duy nhất.

iPad là một thiết bị cảm ứng đầu tiên và thật dễ dàng để mở cảnh chỉ bằng một cử chỉ.

Trong ứng dụng Ghi chú, việc chèn ép trên một ô sẽ mở ghi chú trong một cảnh mới.

Cảnh tương tác làm sinh động từ phòng giam đến vị trí cuối cùng của nó.

Có hai cách để cung cấp chức năng này trong ứng dụng của bạn.

Nếu bạn đang sử dụng chế độ xem bộ sưu tập, có một phương thức đại diện mới.

Đối với các chế độ xem khác, hãy sử dụng UIWindowScene ActivationInteraction.

Cả hai điều này chỉ để trình bày những cảnh với phong cách nổi bật.

Để hỗ trợ cử chỉ này trong chế độ xem bộ sưu tập của bạn, hãy triển khai phương thức đại diện mới có tên là sceneActivationConfiguration ForItemAt indexPath.

Nó rất giống với ví dụ trình đơn ngữ cảnh từ trước đó.

Tạo hoạt động người dùng cho nội dung của cảnh mới, sau đó trả lại cấu hình kích hoạt với hoạt động đó.

Bạn có thể không muốn mọi tế bào hỗ trợ mở một cảnh mới.

Để ngăn cử chỉ bắt đầu, chỉ cần quay lại số không.

Để hỗ trợ cử chỉ này ở các chế độ xem khác, hãy tạo một UIWindowScene. Tương tác kích hoạt.

Nó được tạo ra với một đóng chấp nhận hai đối số: bản thân tương tác và điểm tương tác trong không gian tọa độ xem.

Chúng có thể được sử dụng để tạo các hoạt động người dùng cụ thể cho các khu vực khác nhau của chế độ xem.

Việc đóng cửa sẽ trả về một cấu hình kích hoạt với hoạt động của người dùng.

Sự tương tác cũng cần một trình xử lý lỗi.

Mặc dù tương tác bị vô hiệu hóa trên các nền tảng không hỗ trợ nhiều cảnh, nhưng lỗi vẫn có thể xảy ra do sự cố cấu hình hoặc thiếu tài nguyên hệ thống.

Bạn có thể nhận thấy rằng tất cả các cách trình bày cảnh cửa sổ này đều sử dụng cùng một đối tượng cấu hình kích hoạt.

Yêu cầu duy nhất của nó là hoạt động của người dùng, nhưng nó cũng chứa các tùy chọn yêu cầu cảnh và bản xem trước được nhắm mục tiêu.

Nếu những thứ này không được cung cấp, hệ thống sẽ cố gắng hết sức để tạo ra chúng cho bạn.

Tuy nhiên, bạn có thể cung cấp chúng một cách rõ ràng để tinh chỉnh trải nghiệm.

Ví dụ, các ô xem bộ sưu tập này có hình thu nhỏ, tiêu đề và chú thích.

Khi ô bị chèn ép, một cảnh được trình bày chủ yếu hiển thị phiên bản lớn hơn của nội dung hình thu nhỏ.

Lưu ý rằng cảnh mới đang chuyển đổi từ toàn bộ ô.

Nó sẽ trông đẹp hơn nếu nó chuyển đổi từ chỉ hình thu nhỏ.

Để đạt được hiệu ứng này, cấu hình kích hoạt được tạo ra như trước đây.

Sau đó, kiểm tra xem ô đó có phải là ô thu nhỏ không.

Nếu vậy, hãy sử dụng chế độ xem hình thu nhỏ của ô để tạo bản xem trước được nhắm mục tiêu và đặt nó trên cấu hình.

Bằng cách cung cấp bản xem trước tùy chỉnh trên cấu hình kích hoạt, quá trình chuyển đổi được đánh bóng hơn nhiều.

Chúng ta hãy xem xét kỹ hơn.

Bây giờ, thay vì chuyển đổi từ chính ô, nó chuyển đổi từ hình thu nhỏ, để phần còn lại của ô tại chỗ.

Cấu hình kích hoạt cho phép bạn yêu cầu bất kỳ cảnh nào trong ứng dụng của mình.

Tuy nhiên, bạn có thể chỉ muốn hiển thị một tệp mà không cần phải tự xây dựng cảnh.

iPadOS 15 làm cho điều này rất dễ dàng.

Có một lớp con đặc biệt của UIWindowScene. Cấu hình kích hoạt được gọi là "Cấu hình kích hoạt cảnh QLPreviewScene".

Trả về cấu hình cảnh xem trước yêu cầu cảnh xem trước do hệ thống quản lý.

Không có đại diện cảnh và không có cuộc gọi lại nào phải lo lắng, nhưng ứng dụng của bạn phải tuyên bố hỗ trợ cho nhiều cửa sổ trong Info.plist.

Cung cấp những cách bóng bẩy và thuận tiện để mọi người mở nội dung trong những cảnh mới là rất quan trọng.

Nhưng việc lưu và khôi phục trạng thái của cảnh cũng quan trọng không kém, vì vậy quay lại với họ sau này là một trải nghiệm liền mạch.

Khi một cảnh di chuyển sang nền, hệ thống sẽ yêu cầu đại diện của cảnh cho NSUserActivity đại diện cho trạng thái của nó.

Hoạt động này có thể là hoạt động của bộ điều khiển chế độ xem gốc nếu nó hỗ trợ Handoff hoặc một hoạt động được tạo ngay tại chỗ.

Ở đây, một hoạt động của người dùng được tạo ra để lưu nội dung của trường văn bản trong từ điển thông tin người dùng của hoạt động.

Để mang lại trải nghiệm tốt nhất, trạng thái cảnh nên vượt ra ngoài nội dung.

Bạn cũng nên lưu trạng thái trực quan và tương tác như vị trí cuộn, vị trí con trỏ và trạng thái phản hồi đầu tiên.

Thay vì lưu từng thứ này một cách độc lập, UITextField và UITextView hiện có thuộc tính interactionState.

Thuộc tính này cung cấp một đối tượng duy nhất chứa tất cả trạng thái tương tác.

Đối tượng không chứa nội dung, đó là thông tin bổ sung để bạn lưu trong hoạt động của người dùng.

Tôi đã cập nhật ví dụ trước bằng cách lưu trạng thái tương tác của trường văn bản.

Giờ đây, bằng cách lưu cả nội dung và trạng thái tương tác, hoạt động của người dùng chứa đủ thông tin để được khôi phục chính xác.

Trên iPadOS 14, việc khôi phục trạng thái có thể hơi phức tạp.

Nếu bạn cố gắng khôi phục trạng thái khi cảnh đang kết nối, bạn sẽ nhận thấy rằng bảng phân cảnh và chế độ xem chưa được tải đầy đủ.

Nếu bạn khôi phục sau đó, khi cảnh đang chuyển sang tiền cảnh, bạn phải theo dõi xem đó có phải là lần đầu tiên hay không.

iPadOS 15 giải quyết vấn đề này bằng một phương thức đại diện mới một cách rõ ràng để khôi phục trạng thái.

Nó được gọi sau khi cảnh được kết nối và bảng phân cảnh đã được tải, nhưng trước khi chuyển đổi đầu tiên lên tiền cảnh.

Bất kể ứng dụng của bạn có sử dụng bảng phân cảnh hay không, bạn nên sử dụng lệnh gọi lại mới này để khôi phục trạng thái.

Khôi phục trạng thái từ hoạt động được lưu trong ví dụ trước bắt đầu với hệ thống gọi sceneRestoreInteractionState.

Sau đó, khôi phục nội dung của trường văn bản.

Cuối cùng, khôi phục trạng thái tương tác của nó.

Điều quan trọng là nội dung phải được khôi phục trước trạng thái tương tác.

Cuối cùng, trạng thái khôi phục đồng bộ có thể phức tạp.

Bạn có thể cần truy cập cơ sở dữ liệu hoặc tải tệp và không muốn giao diện người dùng trống trong thời gian đó.

Để giải thích cho điều này, iPadOS 15 cho phép ứng dụng của bạn yêu cầu gia hạn ngắn hạn.

Trong phần mở rộng này, hình ảnh khởi chạy sẽ vẫn hiển thị trong khi vẫn cho phép RunLoop chính thực thi.

Khi nội dung của bạn được tải, ứng dụng sẽ báo hiệu để hoàn tất việc khôi phục.

Tiện ích mở rộng này ngắn gọn và không nhằm mục đích sử dụng cho các tác vụ có khả năng chạy lâu dài như truy cập mạng.

Nếu ứng dụng của bạn không báo hiệu hoàn thành hoặc mất quá nhiều thời gian, nó sẽ bị hệ thống đóng cửa.

Để sử dụng khôi phục trạng thái mở rộng, hãy bắt đầu bằng cách yêu cầu gia hạn từ hiện trường.

Sau đó, bắt đầu công việc không đồng bộ của bạn.

Khi nội dung được tải, hãy khôi phục nó và yêu cầu cảnh khôi phục hoàn tất.

Cảnh sau đó sẽ hiển thị giao diện người dùng mới được khôi phục của bạn.

Hỗ trợ đa nhiệm trong ứng dụng của bạn làm cho nó tỏa sáng, nhưng để trở thành một ứng dụng iPad cấp độ tiếp theo thực sự, còn nhiều việc phải làm.

Và bây giờ, đến Anant.

Anant Jain: Cảm ơn bạn, Chris!

Tên tôi là Anant và tôi là một kỹ sư UIKit.

Mọi người thích rằng iPad đủ nhẹ để cầm trên tay trong khi vẫn có thể gắn vào bàn phím vật lý ngay lập tức.

Họ mong đợi ứng dụng của bạn theo kịp họ bằng cách hỗ trợ bàn phím tuyệt vời.

iPadOS 15 giới thiệu một số tính năng mới để đưa các phím tắt của ứng dụng của bạn lên một tầm cao mới.

iPadOS 15 có giao diện hoàn toàn mới để khám phá các phím tắt.

Nó cấu trúc mỗi lệnh thành các danh mục quen thuộc, mang lại sự cân bằng tăng lên giữa các phiên bản iPad và Mac Catalyst của ứng dụng của bạn.

Menu cung cấp một tính năng tìm kiếm thuận tiện có thể được đưa lên từ mọi nơi trên hệ thống.

Bạn thậm chí có thể nhấn vào một phím tắt để kích hoạt nó.

Nếu bạn cần bồi dưỡng về cách hỗ trợ các phím tắt với UIKeyCommand, bao gồm cách các lệnh được gửi đến chuỗi phản hồi, hãy xem "Hỗ trợ bàn phím phần cứng trong ứng dụng của bạn".

Trên Mac Catalyst, mỗi ứng dụng đều có một menu toàn cầu được gọi là menu chính, được hiển thị trong thanh menu ở đầu màn hình.

Menu chính bao gồm một số menu con danh mục, như Tệp và Chỉnh sửa, và các menu danh mục này lần lượt chứa các menu con khác với tất cả các lệnh của ứng dụng.

Trên iPadOS 15, chúng tôi đã đưa hệ thống menu chính lên các ứng dụng iPad.

Giao diện phím tắt mới, xuất hiện bằng cách giữ phím Command, hiển thị menu này.

Bây giờ, hệ thống menu chính được thể hiện hơi khác một chút trên iPad so với Mac.

Mac hiển thị hệ thống phân cấp menu con đầy đủ trong mỗi danh mục, trong khi iPad làm phẳng các hệ thống phân cấp đó.

Các lệnh bị vô hiệu hóa và không thể thực hiện xuất hiện màu xám trên Mac, trong khi chúng bị ẩn trên iPad.

Hơn nữa, menu phím tắt iPad được thiết kế để giúp khám phá các phím tắt trong một ứng dụng.

Nó sẽ không hiển thị các lệnh không cần chìa khóa như thanh menu Mac.

Theo mặc định, menu chính chứa tất cả các menu danh mục hệ thống như Tệp và Chỉnh sửa.

Chúng bao gồm tất cả các lệnh hệ thống, như Hoàn tác và Làm lại, Dán và Khớp Kiểu, v.v.

iPadOS 15 thêm lệnh In vào danh sách các lệnh hệ thống này, ứng dụng nào có thể nhận được bằng cách thêm khóa UIApplication SupportsPrintCommand vào Info.plist của họ.

Giờ đây, các ứng dụng iPad trên iPadOS 15 hỗ trợ hệ thống menu chính, chúng có thể sử dụng UIMenuBuilder API để tùy chỉnh nó, giống như các ứng dụng Mac Catalyst.

Trên thực tế, nếu bạn đã có phiên bản Mac Catalyst của ứng dụng, bạn đã hoàn thành hầu hết công việc.

Các ứng dụng nên sử dụng trình tạo để thêm tất cả các lệnh chính được hỗ trợ vào menu chính của chúng.

Đây là một thay đổi so với cách các ứng dụng trước đây sẽ khai báo các phím tắt: bằng cách ghi đè thuộc tính keyCommands trên UIResponder hoặc bằng cách gọi addKeyCommand(_:) trên bộ điều khiển chế độ xem.

Các lệnh được xác định theo cách này vẫn hoạt động, nhưng chúng sẽ xuất hiện trong một phần chưa được phân loại riêng biệt của giao diện mới.

Các ứng dụng nên xóa các khai báo lệnh chính như thế này và thay vào đó thêm chúng vào menu chính.

Để tùy chỉnh menu chính, hãy ghi đè buildMenu(withbuilder:) trong AppDelegate của bạn.

UIKit gọi phương thức này khi khởi chạy ứng dụng và chuyển vào đối tượng UIMenuBuilder.

Các ứng dụng nên kiểm tra xem trình tạo có đang sửa đổi hệ thống menu chính hay không.

Nếu vậy, họ có thể sử dụng trình tạo để thực hiện các tùy chỉnh.

Giả sử một ứng dụng muốn một số lệnh chính trong menu Tệp để làm việc với các tab.

Ứng dụng chỉ đơn giản là tạo một menu con bằng API UIMenu và thêm các lệnh phím mong muốn làm menu con.

Sau đó, ứng dụng gọi phương thức insertChild trên đối tượng trình tạo để chèn menu con vào menu Tệp.

Để tham chiếu một phần tử hiện có trong hệ thống menu chính - như menu Tệp, trong trường hợp này - các ứng dụng nên chỉ định số nhận dạng của phần tử.

Các số nhận dạng menu hệ thống tích hợp được định nghĩa là hằng số trong UIMenu.Identifier.

Các ứng dụng cũng có thể dễ dàng tạo các danh mục menu của riêng chúng.

Tại đây, ứng dụng tạo ra một menu Dấu trang - một lần nữa, sử dụng UIMenu API.

Sau đó, ứng dụng sử dụng trình tạo để chèn menu đó vào menu gốc - trong trường hợp này, sau menu Xem hệ thống.

Đó là tất cả những gì nó cần!

Bây giờ, trình tạo có thể được sử dụng để chèn thêm vào menu Dấu trang, giống như với menu Tệp.

Chỉ cần chuyển mã định danh của menu mới, mà UIKit tự động tạo ra.

Bây giờ, tôi tiếp tục đề cập đến các số nhận dạng.

UIMenuBuilder sẽ thực thi rằng mỗi phần tử trong hệ thống menu chính có một mã định danh duy nhất, bao gồm các lệnh riêng lẻ.

Giả sử một ứng dụng chèn các lệnh chính để hiển thị nội dung dưới dạng danh sách hoặc dưới dạng lưới.

Cả hai lệnh đều chia sẻ cùng một hành động: changeViewMode(_:).

Trong hệ thống menu chính, các lệnh được xác định ngầm bởi hành động của chúng, vì vậy cả hai lệnh này đều có chung số nhận dạng.

UIMenuBuilder sẽ không cho phép chèn cả hai lệnh trừ khi chúng có các số nhận dạng khác nhau.

Một cách để phân biệt các lệnh này là cung cấp cho chúng các giá trị propertyList khác nhau.

Nhưng một cách tốt hơn là chỉ cần cung cấp cho mỗi lệnh một hành động duy nhất mô tả những gì nó làm cụ thể.

Trình tạo cũng thực thi rằng các kết hợp phím tắt trong menu chính là duy nhất.

Giả sử một ứng dụng chèn lệnh phím Get Info trên Command-I.

Bởi vì phím tắt in nghiêng hệ thống trong menu kiểu văn bản chia sẻ cùng một phím tắt, việc chèn này cũng sẽ thất bại.

Một lần nữa, có hai giải pháp.

Ứng dụng có thể thay đổi phím tắt Get Info thành một cái gì đó không va chạm với một phím tắt hiện có, chẳng hạn như Control-Command-I.

Ngoài ra, ứng dụng có thể yêu cầu người xây dựng xóa các lệnh kiểu văn bản nếu chúng không cần thiết.

Nếu một phần chèn bao gồm một bản sao, thì UIMenuBuilder sẽ thất bại trong việc chèn đó và ghi lại một lỗi trong bảng điều khiển hiển thị các lệnh phím trùng lặp hoặc các số nhận dạng được chia sẻ.

Nếu bạn thấy các phần chèn của mình không xuất hiện, rất có thể có một bản sao ở đâu đó, vì vậy hãy tìm các bản ghi như thế này trong bảng điều khiển.

Sau khi cuộc gọi buildMenu (với builder:) kết thúc, menu chính của ứng dụng xuất hiện trong thanh menu Mac và lớp phủ phím tắt iPad.

Tuy nhiên, có một vấn đề.

Ứng dụng đã thêm một menu con với các lệnh để sắp xếp dấu trang theo tên hoặc theo ngày.

Nhưng vì lớp phủ phím tắt iPad không hiển thị hệ thống phân cấp menu con, nên không rõ những phím tắt này làm gì trên iPadOS.

Đối với những tình huống như thế này, hãy đặt tiêu đề khả năng khám phá mô tả nhiều hơn trên các lệnh chính.

iPadOS thích tiêu đề khả năng khám phá hơn tiêu đề thông thường nếu cả hai đều được cung cấp.

Bây giờ, tôi đã đề cập trước đó rằng những người phản hồi cá nhân nên tránh khai báo các phím tắt và thay vào đó khai báo chúng trong hệ thống menu chính.

Tuy nhiên, những người phản hồi vẫn nên thực hiện các phương pháp hành động cho các lệnh menu chính.

Khi các lệnh chính được kích hoạt, UIKit sẽ tự động gửi hành động đến người phản hồi.

UIKit thực hiện điều này bằng cách duyệt qua chuỗi phản hồi của ứng dụng.

Ngay khi nó tìm thấy một người phản hồi có thể thực hiện hành động, nó sẽ gọi phương thức hành động của người phản hồi đó.

Nếu không có gì trong chuỗi có thể thực hiện hành động, thì lệnh phím không thể thực hiện được.

Nếu bạn chưa quen với các khái niệm UIResponder, "Hỗ trợ bàn phím phần cứng trong ứng dụng của bạn" có phần giới thiệu tuyệt vời về cách thức hoạt động của nó.

"Chất lượng của một ứng dụng Mac Catalyst tuyệt vời" cũng đi sâu vào chi tiết hơn một chút.

Khi UIKit thực hiện tìm kiếm phản hồi dọc theo chuỗi, nó sẽ gọi hai phương thức UIResponder hữu ích.

Các ứng dụng có thể ghi đè các phương pháp này trong trình phản hồi của chúng để cải thiện các lệnh chính của chúng.

Đầu tiên là canPerformAction (_:withSender:), mà UIKit sử dụng để kiểm tra xem người phản hồi có thể thực hiện một hành động hay không.

Theo mặc định, điều này trả về true nếu người phản hồi thực hiện phương thức hành động đó; nếu không, nó trả về false.

Người trả lời có thể ghi đè điều này để thêm logic tùy chỉnh.

Ví dụ, một trình duyệt web có thể nói với UIKit rằng lệnh closeTab không thể thực hiện được nếu không có các tab đang mở.

Vì UIKit không thể tìm thấy trình phản hồi mục tiêu cho hành động đó, lệnh sẽ không thể thực hiện được và nó sẽ không được hiển thị trong giao diện phím tắt.

Lưu ý rằng ghi đè cho phương thức này phải gọi super cho các trường hợp chưa được xử lý.

Phương thức hữu ích khác là validate(_ command:).

Khi UIKit tìm thấy một người phản hồi mục tiêu cho một lệnh chính, nó sẽ gọi phương thức này trên người phản hồi đó và chuyển vào một bản sao của lệnh.

Người trả lời có thể ghi đè xác thực (_ lệnh:) để cập nhật giao diện của lệnh cho trạng thái hiện tại của ứng dụng.

Tại đây, ứng dụng cập nhật tiêu đề của lệnh toggleBookmark(_:) dựa trên việc trang hiện tại có được đánh dấu hay không.

Tiêu đề được đặt trong phương pháp này sẽ phản ánh trong giao diện phím tắt khi nó xuất hiện.

Trong iPadOS 15, UIKit đang giới thiệu một thay đổi lớn đối với chuỗi phản hồi.

Khi các ứng dụng áp dụng điều hướng bàn phím với hệ thống lấy nét, thì việc đi qua người phản hồi sẽ bắt đầu ở mục tập trung thay vì người phản hồi đầu tiên.

Sự thay đổi này hoạt động cực kỳ tốt với các lệnh chính.

Ví dụ, ảnh cho phép người dùng làm việc với thư viện ảnh của họ chỉ bằng bàn phím.

Khi người dùng tập trung một ô trong lưới, họ có thể nhấn phím cách để xem bức ảnh đó.

Họ thậm chí có thể nhấn Command-C để sao chép bức ảnh đó để dán vào một ứng dụng khác.

Mỗi ô thực hiện các hành động lệnh chính khác nhau và vì quá trình duyệt của người phản hồi bắt đầu tại mục được tập trung, nên các lệnh chính nhắm mục tiêu vào ô.

Nói tóm lại, hệ thống tập trung tăng cấp các lệnh chính và chuỗi phản hồi.

Tận dụng nó để hỗ trợ các phím tắt theo ngữ cảnh mạnh mẽ trong ứng dụng của bạn.

Để tìm hiểu thêm, hãy xem "Tập trung vào điều hướng bàn phím iPad."

Cuối cùng, iPadOS 15 và macOS 12 giới thiệu bản địa hóa phím tắt.

Khi bạn xây dựng ứng dụng của mình với các SDK này, hệ thống sẽ tự động bản địa hóa các công cụ sửa đổi và đầu vào phím tắt cho mỗi bố cục bàn phím.

Lấy phím tắt Command-backslash làm ví dụ.

Mặc dù phím tắt hoạt động trên bàn phím Hoa Kỳ, nhưng không thể thực hiện trên bàn phím Nhật Bản, vì bố cục đó không có phím dấu gạch chéo ngược.

Vì vậy, hệ thống sẽ ánh xạ lại phím tắt cho bàn phím tiếng Nhật.

Điều này có nghĩa là các ứng dụng không nên bản địa hóa các công cụ sửa đổi hoặc đầu vào phím tắt, và thay vào đó hãy để hệ thống thực hiện công việc.

Các ứng dụng cũng có thể chọn không tham gia bản địa hóa tự động, ở cấp độ toàn ứng dụng hoặc trên cơ sở mỗi phím tắt.

Khi hệ thống bản địa hóa các phím tắt, nó cũng phản chiếu chúng cho bố cục từ phải sang trái.

Ví dụ, một phím tắt để điều hướng ngược với dấu ngoặc Command bên trái được lật sang dấu ngoặc Command-phải.

Nếu một phím tắt không nên được phản chiếu, hãy đặt thuộc tính allowsAutomaticMirroring của lệnh thành false để vô hiệu hóa phản chiếu mà không vô hiệu hóa hoàn toàn bản địa hóa tự động.

iPadOS 15 là một bản phát hành lớn cho các phím tắt.

Có rất nhiều cải tiến khác trên tất cả mọi thứ chúng tôi đã đề cập ngày hôm nay.

Vì vậy, bạn đã áp dụng tất cả các tính năng Đa nhiệm mới và bạn đã xây dựng được sự hỗ trợ bàn phím tuyệt vời.

Bây giờ, Mohammed sẽ cung cấp cho bạn một vài gợi ý để đưa ứng dụng iPad của bạn lên mức cao nhất.

Mohammed Jisrawi: Cảm ơn, Anant! Xin chào, tôi là Mohammed.

Hãy nói về những cải tiến mà iPadOS 15 mang lại cho con trỏ hệ thống.

iPadOS 13.4 đã giới thiệu một con trỏ hệ thống thích ứng kết nối giữa giao diện người dùng dựa trên cảm ứng của iPad và độ chính xác của chuột hoặc bàn di chuột.

Nếu bạn chưa quen với các tương tác con trỏ, hãy dành một chút thời gian để làm quen với chúng và xem những video trước đó.

"Xây dựng cho con trỏ iPadOS" phá vỡ các API tương tác con trỏ.

"Thiết kế cho Con trỏ iPadOS" đi sâu vào triết lý thiết kế đằng sau chúng và thảo luận về các phương pháp hay nhất khi áp dụng chúng trong ứng dụng của bạn.

iPadOS 15 mang đến một số tương tác quen thuộc của người dùng Mac theo cách phù hợp với ngôn ngữ thiết kế của iPad.

Nó cũng giới thiệu một số khái niệm mới giúp nâng cao khả năng sử dụng và sự rõ ràng.

Bổ sung đầu tiên trong số những bổ sung này là lựa chọn ban nhạc, một trải nghiệm đa lựa chọn dành riêng cho con trỏ mới quen thuộc với bất kỳ ai đã sử dụng máy Mac.

Trong iPadOS 15, khi bạn nhấp và kéo trong chế độ xem bộ sưu tập, con trỏ sẽ kéo dài thành hình chữ nhật và chế độ xem bộ sưu tập sẽ chọn các mục mà hình chữ nhật bao gồm.

Tất nhiên điều này chuyển một cách tự nhiên sang giao diện người dùng Mac quen thuộc trên các ứng dụng Mac Catalyst.

Sự tương tác này được tích hợp vào UICollectionViews không nằm trong danh sách.

Bất kỳ UICollectionView nào hỗ trợ các cử chỉ đa lựa chọn một và hai ngón tay hiện có thông qua shouldBeginMultiple SelectionInteraction API sẽ tự động nhận được hành vi này trong iPadOS 15.

Đối với bất kỳ thứ gì khác ngoài UICollectionView, UIBandSelectionInteraction API mới cho phép bạn dễ dàng áp dụng trải nghiệm này trong ứng dụng của mình.

Vì logic lựa chọn hoàn toàn phụ thuộc vào bạn, bạn có thể hỗ trợ các hành vi lựa chọn tùy chỉnh và giao diện người dùng của bạn phản ứng với lựa chọn thay đổi theo bất kỳ cách nào bạn chọn.

Để bắt đầu, hãy khởi tạo tương tác với trình xử lý lựa chọn được gọi khi con trỏ di chuyển và trạng thái của tương tác thay đổi.

Sau khi nó được tạo, hãy thêm tương tác vào chế độ xem của bạn như bạn làm với bất kỳ UIInteraction nào khác.

Trong trình xử lý, bạn có thể triển khai logic lựa chọn tùy chỉnh của mình bằng cách phản hồi các thay đổi trong trạng thái tương tác và selectionRect.

Ở đây chúng tôi có một triển khai đơn giản đặt lựa chọn cho các mục trong selectionRect của tương tác trong khi con trỏ đang di chuyển.

Sau đó, nó hoàn tất phiên lựa chọn khi nút chuột chính được nhả ra và tương tác kết thúc.

Ngoài lựa chọn cơ bản, lựa chọn băng tần tích hợp của UICollectionView hỗ trợ một số phím tắt phổ biến ngay lập tức.

Ví dụ, giữ phím Shift khi bắt đầu kéo khiến các mục được thêm vào lựa chọn hiện có thay vì thay thế các mục hiện được chọn.

Giữ lệnh chuyển đổi trạng thái lựa chọn của các mục trong trực tràng lựa chọn.

Điều này có thể được triển khai trong giao diện người dùng tùy chỉnh bằng cách sử dụng thuộc tính InitialModifierFlags của tương tác, cung cấp các khóa được giữ khi bắt đầu kéo.

Vì nó là một tập hợp của tất cả các công cụ sửa đổi được nhấn, bạn có thể phản hồi các tổ hợp phím tùy ý để hỗ trợ hành vi tùy chỉnh hoặc nâng cao hơn dành riêng cho ứng dụng của bạn.

Bổ sung thứ hai cho con trỏ hệ thống là khả năng gắn các phụ kiện.

Các phụ kiện truyền đạt thông tin bổ sung và cung cấp các gợi ý theo ngữ cảnh bằng cách kết hợp các hình dạng phụ với con trỏ chính.

Ví dụ, trong ví dụ bên trái, hai mũi tên chỉ ra rằng chế độ xem này có thể được kéo theo chiều ngang.

Trong ví dụ bên phải, dấu cộng cung cấp một số ngữ cảnh bổ sung cho nút Thêm vào giỏ hàng này.

Có một vài điểm khác biệt chính giữa các phụ kiện và sử dụng hình dạng con trỏ tùy chỉnh.

Các phụ kiện tách biệt về mặt thị giác và thứ cấp so với con trỏ chính.

Điều này được nhấn mạnh bởi thực tế là chúng có thể được hiển thị với một diện mạo khác và hoạt hình riêng biệt với con trỏ chính.

Chúng là những đơn vị độc lập có thể được kết hợp và định vị xung quanh con trỏ để truyền đạt các ý tưởng khác nhau.

Vì chúng độc lập, chúng có thể được kết hợp với bất kỳ kiểu con trỏ nào.

Đây là một minh chứng về cách cùng một bộ phụ kiện - hai mũi tên biểu thị khả năng kéo - có thể được kết hợp với các kiểu con trỏ khác nhau.

Ở bên trái, chúng được kết hợp với hiệu ứng nâng trong đó con trỏ hợp nhất với chế độ xem và nâng nó lên.

Ở giữa, chúng cùng với hiệu ứng tô sáng, trong đó con trỏ biến thành hình chữ nhật tròn và đi dưới tầm nhìn.

Ở bên phải, chúng xuất hiện với con trỏ hệ thống mặc định sử dụng API UIPointerStyle.system() mới.

Vì vậy, chúng tôi có thể cung cấp bối cảnh bổ sung này trong khi vẫn sử dụng hiệu ứng lý tưởng cho tình huống, mà không phải hy sinh tính sống động của con trỏ và trong khi vẫn duy trì mối quan hệ sâu sắc của nó với giao diện người dùng của ứng dụng.

Giống như nó làm sinh động giữa các kiểu con trỏ, hệ thống sẽ tự động làm sinh động sự xuất hiện và biến mất của các phụ kiện.

Nó cũng sẽ hoạt hình liền mạch giữa hình dạng và vị trí của phụ kiện.

Hành động chuyển đổi phụ kiện trong khi một hiệu ứng nhất định đang hoạt động có thể có ý nghĩa.

Sự chuyển đổi như vậy có thể được sử dụng để truyền đạt sự thay đổi về trạng thái hoặc hành vi trong giao diện người dùng cơ bản.

Trong ví dụ bên trái, việc chuyển đổi từ dấu cộng sang dấu không có thể chỉ ra rằng một thao tác trước đây có thể thực hiện được không còn được phép nữa.

Các phụ kiện con trỏ bao gồm UIPointerShape và UIPointerAccessory. Vị trí, mô tả vị trí mong muốn như một độ lệch từ điểm giữa của con trỏ và một góc từ trên xuống.

Để thuận tiện, UIKit cung cấp một số giá trị được xác định trước cho các vị trí xung quanh con trỏ.

Nếu các vị trí được xác định trước không hoàn toàn phù hợp với nhu cầu của bạn, bạn có thể sử dụng chúng làm điểm khởi đầu và tùy chỉnh các thuộc tính riêng lẻ.

Ví dụ này bắt đầu với vị trí topRight và tùy chỉnh độ lệch.

Bạn cũng có thể xác định các vị trí hoàn toàn tùy chỉnh, như trong ví dụ này, tạo ra một vị trí với độ lệch và góc tùy chỉnh.

Để thiết lập ví dụ mà chúng tôi đã thấy ở đầu phân đoạn này, chúng tôi sẽ tạo một UITargetedPreview với chế độ xem của mình và sử dụng nó để tạo UIPointerStyle với hiệu ứng nâng.

Sau đó, chúng tôi sẽ đặt thuộc tính phụ kiện mới của phong cách thành một mảng chứa hai phụ kiện mũi tên của chúng tôi.

UIKit cung cấp một phụ kiện mũi tên được tạo sẵn, vì vậy chúng ta chỉ có thể tạo hai trong số những thứ được đặt ở bên trái và bên phải của hiệu ứng.

Vì vậy, bây giờ khi con trỏ di chuột qua chế độ xem này, hai mũi tên hoạt hình khi chế độ xem nâng lên, gợi ý rằng nó có thể được kéo.

Nếu bạn đã từng cố gắng thực hiện loại tương tác này trong đó chế độ xem có hiệu ứng con trỏ có thể kéo được, bạn có thể nhận thấy điều gì đó như thế này.

Khi con trỏ chạm đến cạnh của vùng con trỏ, nó sẽ rời khỏi chế độ xem được nâng lên và hiệu ứng kết thúc.

Điều này thường được mong muốn, vì nó ngăn con trỏ bám vào chế độ xem khi nó di chuyển xung quanh.

Tuy nhiên, trong những tình huống như thế này, trải nghiệm lý tưởng sẽ là hiệu ứng con trỏ vẫn ổn định và bám vào chế độ xem và theo dõi nó khi nó được kéo.

Để kích hoạt tốt hơn các loại tương tác này, iPadOS 15 giới thiệu khái niệm chốt rìu trên UIPointerRegion.

Khi một vùng bám dọc theo một trục nhất định, hiệu ứng con trỏ của nó đi theo con trỏ dọc theo trục khi nhấn nút chuột chính.

Vùng chốt theo chiều ngang cho phép bạn kéo tự do dọc theo trục x trong khi vẫn dải cao su dọc theo trục y.

Một cái chốt theo chiều dọc cho phép bạn kéo tự do dọc theo trục y.

Và một cái chốt dọc theo cả hai cho phép bạn kéo tự do dọc theo cả hai trục.

Những công cụ mới này có thể được sử dụng để xây dựng một số trải nghiệm mới thực sự mạnh mẽ.

Ở đây chúng được kết hợp trong một ứng dụng chỉnh sửa tài liệu như Pages hoặc Keynote.

Hình ảnh này có thể được chọn bằng cách sử dụng lựa chọn ban nhạc.

Chọn hình ảnh khiến các chỉ báo kéo xuất hiện và khi con trỏ di chuột qua một chỉ báo, các phụ kiện xuất hiện để gợi ý về cách hình ảnh sẽ được thay đổi kích thước nếu nó được kéo.

Và cuối cùng, chốt cho phép hiệu ứng con trỏ và các phụ kiện tuân theo cử chỉ thay đổi kích thước bị khóa trục.

Đây chỉ là một số cải tiến mà iPadOS 15 mang lại cho iPad.

Tận dụng chúng khi áp dụng để thực sự tối đa hóa tiện ích của ứng dụng của bạn.

Áp dụng các cảnh nổi bật để cung cấp cho mọi người một cái nhìn tập trung, không bị gián đoạn về nội dung ứng dụng của bạn.

Trao quyền cho họ để đạt được các tác vụ phức tạp một cách nhanh chóng với menu phím tắt mới và tăng năng suất của họ với các tính năng con trỏ mới.

Cảm ơn vì đã xem!

♪