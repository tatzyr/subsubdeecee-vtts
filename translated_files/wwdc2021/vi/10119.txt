10119

♪ Nhạc bass đang phát ♪

♪

Nathan Tannar: Xin chào, và chào mừng đến với WWDC!

Tên tôi là Nathan, và tôi là một kỹ sư trong nhóm Tiếp cận.

Hôm nay chúng ta sẽ vượt ra ngoài những điều cơ bản để học cách cung cấp các ứng dụng SwiftUI đặc biệt và dễ tiếp cận.

Năm nay đánh dấu một bước tiến lớn cho khả năng tiếp cận trong SwiftUI.

Tại Apple, khả năng tiếp cận là một trong những giá trị cốt lõi của chúng tôi.

Các công nghệ hỗ trợ của chúng tôi trên tất cả các nền tảng của chúng tôi đảm bảo rằng bất kỳ ai cũng có thể sử dụng ứng dụng của bạn bất kể bất kỳ khiếm khuyết về thể chất, thị giác, âm thanh hoặc vận động nào.

Nhóm của tôi và tôi làm việc để đảm bảo hầu hết các ứng dụng của bạn đều có thể truy cập theo mặc định, nhưng bạn luôn có thể làm nhiều hơn để làm phong phú thêm trải nghiệm.

Hôm nay tôi sẽ chỉ cho bạn các công cụ và API mới cho SwiftUI giúp làm phong phú thêm trải nghiệm này một cách dễ dàng.

Hãy bắt đầu với những cải tiến công cụ trong Xcode.

SwiftUI Previews đã thay đổi cách nhiều người trong chúng ta phát triển ứng dụng.

Nó cải thiện đáng kể khả năng lặp lại quan điểm của bạn trên nhiều môi trường, tất cả đều không cần chạy ứng dụng của bạn.

Để thực hiện các công cụ sửa đổi khả năng truy cập quan trọng nhất chỉ bằng một cú nhấp chuột, chúng tôi đã thêm một danh sách các trình chỉnh sửa khả năng truy cập được sắp xếp.

Tôi hy vọng điều này khuyến khích mọi người luôn làm cho quan điểm của họ có thể truy cập được.

Nhưng còn nhiều hơn thế nữa.

Vì các công cụ sửa đổi khả năng truy cập không có thay đổi trực quan trong bản xem trước, một công cụ mới đã được phát triển cho phép bạn kiểm tra khả năng truy cập chế độ xem của mình mà không cần rời khỏi Xcode.

Hãy chuyển từ bảng điều khiển của trình chỉnh sửa sang bảng điều khiển trợ năng mới.

Giao hàng trong Xcode 13, SwiftUI Previews bây giờ cũng sẽ có tính năng Xem trước Trợ năng.

Với nó, bạn có thể kiểm tra các yếu tố khả năng truy cập để xem trước trong thời gian thực.

Và đây là một sự thay đổi cuộc chơi.

Xem trước khả năng truy cập sẽ giúp bạn tạo các ứng dụng có thể truy cập ngay cả khi bạn không có hiểu biết sâu sắc về từng công nghệ hỗ trợ.

Chúng ta hãy xem xét kỹ hơn để xem các thay đổi được phản ánh như thế nào trong Bản xem trước khả năng truy cập.

Đây là một phiên bản đơn giản hóa của chế độ xem mà chúng tôi vừa thấy.

Sau khi chạy bản xem trước, tôi có thể chọn VStack và Bản xem trước khả năng truy cập sẽ cập nhật để hiển thị các yếu tố theo thứ tự đã sắp xếp của chúng.

Lưu ý rằng mỗi phần tử sẽ luôn hiển thị các thuộc tính cơ bản của nó - chẳng hạn như nhãn và đặc điểm.

Ví dụ, chế độ xem Văn bản sẽ tạo ra một phần tử trợ năng với chuỗi làm nhãn của nó.

Nó cũng đạt được đặc điểm .isStaticText.

Bản xem trước sẽ cập nhật cho bất kỳ thay đổi khả năng truy cập nào mà chúng tôi thực hiện, chẳng hạn như thêm đặc điểm .isHeader.

Bạn cũng sẽ có thể thấy một số khả năng truy cập tự động diễn ra đằng sau hậu trường, chẳng hạn như nhãn Biểu tượng SF tự động.

Ví dụ, biểu tượng checkmark.seal.fill được gắn nhãn "Đã xác minh" theo mặc định.

Nếu bạn đang dựa vào nhãn mặc định của biểu tượng, điều quan trọng là phải kiểm tra xem nó có mô tả chính xác giao diện của bạn hay không.

Chúng tôi sẽ tiếp tục sử dụng Bản xem trước khả năng truy cập khi chúng tôi bước qua năm lĩnh vực quan trọng sẽ giúp bạn mang lại trải nghiệm đặc biệt cho tất cả người dùng ứng dụng của mình.

Chúng ta sẽ bắt đầu bằng cách kiểm tra cách tốt nhất để làm cho các điều khiển tùy chỉnh có thể truy cập được.

Tiếp theo, chúng ta sẽ thảo luận về cách làm cho tầm nhìn có thể truy cập được với trẻ em.

Tôi sẽ nhấn mạnh cách kiểm tra ứng dụng của bạn về các vấn đề điều hướng phổ biến và cách Xem trước khả năng truy cập có thể hỗ trợ việc này.

Sau đó, tôi sẽ chỉ cho bạn cách tăng cường điều hướng ứng dụng của bạn với các cánh quạt VoiceOver.

Và cuối cùng, chúng ta sẽ xem xét trọng tâm và cách nó liên quan đến các công nghệ hỗ trợ.

Tôi đang làm việc để tạo mẫu cho một ứng dụng tài chính mới mà tôi gọi là Wallet Pal.

Nó vẫn đang trong giai đoạn đầu, nhưng cho đến nay, tôi khá hài lòng với thiết kế ban đầu.

Tôi rất vui khi biết rằng những người thử nghiệm beta sớm cũng rất thích nó.

Bây giờ tôi đã đánh bóng giao diện người dùng, tôi nên dành chút thời gian để đánh bóng giao diện khả năng truy cập.

Giao diện khả năng truy cập khen ngợi trải nghiệm hình ảnh để đảm bảo rằng mọi người đều có thể sử dụng được.

Tôi đã yêu cầu một số người dùng VoiceOver giúp kiểm tra Wallet Pal và tôi nghe nói rằng ứng dụng này khó điều hướng và không thể truy cập đầy đủ.

Nếu các bộ phận không thể truy cập được với VoiceOver, thì chúng cũng không thể truy cập được đối với các công nghệ hỗ trợ khác.

Điều quan trọng là bất kỳ ai cũng có thể sử dụng Wallet Pal, vì vậy hãy điều tra xem chúng ta có thể cải thiện trải nghiệm ở đâu.

Chúng tôi sẽ bắt đầu với các báo cáo về việc người dùng không thể chỉnh sửa ngân sách của họ, một tính năng quan trọng trong Wallet Pal.

Đây là chế độ xem Công cụ lập kế hoạch ngân sách cho phép người dùng chỉnh sửa thực phẩm, giải trí và ngân sách tiết kiệm của họ.

Để phù hợp với thiết kế của Wallet Pal, cuối cùng tôi cần tạo các thanh trượt tùy chỉnh.

Tôi đã hoàn thành điều này bằng cách tạo một thanh trượt ngân sách từ các hình dạng và sử dụng cử chỉ kéo để tương tác.

Các hình dạng trong SwiftUI giúp dễ dàng tạo ra các chế độ xem tuyệt đẹp và độc đáo, nhưng chúng không thể truy cập theo mặc định, và vì vậy thanh trượt ngân sách của tôi cũng vậy.

Đây hẳn là lý do tại sao một số người dùng không thể chỉnh sửa ngân sách của họ.

Chúng tôi có thể xác nhận rằng nó không thể truy cập được bằng cách chạy bản xem trước SwiftUI và chọn SliderShape.

Bản xem trước khả năng truy cập cho thấy không có yếu tố nào, vì vậy điều khiển này không thể truy cập được.

Lý tưởng nhất, chúng ta nên có một yếu tố khả năng tiếp cận được dán nhãn duy nhất với một giá trị có thể thay đổi được.

Ngược lại, các điều khiển tiêu chuẩn có thể truy cập theo mặc định, có nghĩa là ít hoặc không cần thêm nỗ lực để cung cấp trải nghiệm tuyệt vời.

SwiftUI sử dụng loại chế độ xem và các tham số khởi tạo của nó để tự động lấy nhãn, giá trị, đặc điểm và hành động của phần tử khả năng truy cập.

Vậy cách tốt nhất để làm cho thanh trượt ngân sách tùy chỉnh của chúng tôi có thể truy cập được là gì?

Vì thanh trượt tiêu chuẩn có thể truy cập theo mặc định, nhóm của tôi và tôi nghĩ sẽ rất tuyệt nếu có một API cho phép khả năng truy cập của một chế độ xem được đại diện bởi một chế độ xem khác.

Đây là điều đã khiến chúng tôi tạo ra khả năng tiếp cận Đại diện (đại diện:).

Đó là một API cho phép khả năng truy cập của một chế độ xem được xác định bởi một chế độ xem khác.

Vì tôi muốn điều này được các công nghệ hỗ trợ cảm nhận như một thanh trượt, đó là những gì tôi sẽ sử dụng cho đại diện khả năng tiếp cận.

Với accessibilityRepresentation (đại diện:), chúng tôi hiện đang trên đường làm cho thanh trượt ngân sách này có thể truy cập được.

Thay đổi duy nhất cần thiết để cải thiện trải nghiệm của thanh trượt là mô tả giá trị bằng đô la.

Và tuyệt vời, cứ như vậy, bây giờ thanh trượt ngân sách của chúng tôi hoàn toàn có thể truy cập được.

Trên macOS, loại điều khiển cũng sẽ được nói với người dùng VoiceOver.

Vì vậy, bằng cách sử dụng chế độ xem thanh trượt trong biểu diễn thanh trượt ngân sách của chúng tôi, nó sẽ được công bố dưới dạng thanh trượt.

Bạn nên sử dụng accessibilityRepresentation(representation:) khi có thể, để làm cho các điều khiển tùy chỉnh có thể truy cập được.

Đây chỉ là một cách để sử dụng accessibilityRepresentation(representation:).

Tính linh hoạt của nó cho phép sử dụng nhiều sáng tạo hơn.

Hãy xem liệu chúng ta có thể sử dụng nó để sửa các lỗi trợ năng khác trong ứng dụng của mình hay không.

Mặc dù chúng tôi hiện đã sửa lỗi chức năng chỉnh sửa ngân sách, một số người dùng đã báo cáo rằng họ không thể khám phá cách điều hướng đến chế độ xem Công cụ lập kế hoạch ngân sách.

Khi thiết kế Wallet Pal, chúng tôi quyết định sử dụng Biểu tượng SF cho tất cả các nút của mình.

Mặc dù Biểu tượng SF có thể có nhãn khả năng truy cập mặc định tuyệt vời, nhưng chúng có thể không phải lúc nào cũng phù hợp với trường hợp sử dụng dự định.

Hãy điều tra xem vấn đề có phải là một nút được dán nhãn kém hay không.

NavigationBarView chứa nút Chỉnh sửa Ngân sách.

Vì chúng tôi dựa vào Biểu tượng SF cho rất nhiều nút của mình, tôi đã tạo một buttonStyle tùy chỉnh có tên SymbolButtonStyle.

Nhưng có vẻ như mặc dù đã khởi tạo nút có nhãn "Chỉnh sửa ngân sách", nhãn cho nút là slider.vertical.3.

Vì vậy, nhãn khả năng tiếp cận đang được bắt nguồn từ Biểu tượng SF.

Chúng ta hãy xem xét kỹ hơn về SymbolButtonStyle.

Phương thức makeBody(configuration:) của SymbolButtonStyle trả về chế độ xem Hình ảnh.

Chuỗi Chỉnh sửa Ngân sách mà chúng tôi khởi tạo nút sẽ tạo chế độ xem Văn bản làm nhãn của cấu hình.

Nhưng phong cách này hoàn toàn bỏ qua nhãn của cấu hình.

Đây là lý do tại sao nút này không được gắn nhãn "Chỉnh sửa ngân sách".

Mặc dù chúng tôi muốn Biểu tượng SF xuất hiện trực quan, nhưng chúng tôi muốn khả năng tiếp cận của nút được thể hiện bằng nhãn của cấu hình.

Và vì vậy đây có vẻ là một trường hợp sử dụng tuyệt vời cho accessibilityRepresentation(representation:).

Sử dụng accessibilityRepresentation(representation:), tôi có thể thay thế khả năng truy cập của chế độ xem Hình ảnh bằng chế độ xem khác, trong trường hợp này là nhãn của cấu hình.

Bằng cách này, chúng ta có thể giữ nguyên nhãn mà chúng ta đã sử dụng để tạo nút.

accessibilityRepresentation (đại diện:) không chỉ là cách lý tưởng và được đề xuất để làm cho các điều khiển tùy chỉnh có thể truy cập được, nó còn mở ra các khả năng sáng tạo mới để làm cho các lượt xem có thể truy cập được.

Tiếp theo, hãy thảo luận về mối quan hệ giữa trẻ em và các thùng chứa khả năng tiếp cận.

Như bạn có thể nhớ lại, các yếu tố khả năng tiếp cận có thể được gói lại với nhau trong một nhóm như con của một thùng chứa khả năng tiếp cận.

Điều này được thực hiện với công cụ sửa đổi accessibilityElement(children:) và chứa hành vi của trẻ.

Trong trường hợp bạn không quen thuộc, hành vi chứa con có thể được sử dụng để tạo ra một vùng chứa khả năng tiếp cận, bao bọc các yếu tố khả năng tiếp cận hiện có khi còn nhỏ.

Nhưng điều gì sẽ xảy ra nếu thay vào đó bạn có một yếu tố khả năng tiếp cận và bạn muốn đặt các con của nó?

Tôi đang gặp phải trường hợp này khi cố gắng làm cho biểu đồ Lịch sử Ngân sách có thể truy cập được.

Người dùng báo cáo rằng biểu đồ hoàn toàn không thể truy cập được.

Và vì vậy điều này có nghĩa là khi các công nghệ hỗ trợ tập trung vào tiêu đề Lịch sử Ngân sách và cố gắng điều hướng đến phần tử tiếp theo, chúng sẽ kết thúc ở tiêu đề Cảnh báo.

Người dùng VoiceOver thậm chí sẽ không biết rằng biểu đồ này tồn tại.

Tôi đã xây dựng biểu đồ bằng cách sử dụng chế độ xem Canvas mới.

Canvas giúp việc vẽ một bộ sưu tập các hình dạng dễ dàng hơn.

Để biết thêm về Canvas, vui lòng xem bài thuyết trình của Jacob về cách nó có thể được sử dụng để thêm đồ họa phong phú vào ứng dụng của bạn.

Điểm mấu chốt quan trọng nhất cho khả năng tiếp cận là Canvas vẽ một bộ sưu tập các hình dạng.

Và giống như chúng ta đã thấy với BudgetSlider, các hình dạng không thể truy cập được theo mặc định.

Tất cả người dùng cần có khả năng xem lịch sử ngân sách của họ, vì vậy hãy làm cho mọi người có thể truy cập được điều này.

Bắt đầu với những điều cơ bản, hãy dán nhãn Canvas của chúng tôi.

Điều này sẽ tự động tạo ra một yếu tố trợ năng mới cho Canvas và gán nhãn của nó.

Bây giờ, tôi muốn mỗi thanh trong biểu đồ được thể hiện bằng yếu tố khả năng tiếp cận của riêng chúng.

Đây là một trường hợp sử dụng mà chúng tôi có một yếu tố tiếp cận và muốn cung cấp cho con của nó.

Để làm điều này, tôi sẽ sử dụng công cụ sửa đổi accessibilityChildren(children:) mới.

Điều này sẽ biến phần tử khả năng tiếp cận thành một vùng chứa khả năng tiếp cận, bảo tồn các thuộc tính khả năng tiếp cận khác, chẳng hạn như nhãn.

Công cụ sửa đổi lấy ViewBuilder, cho phép chúng tôi đặt chế độ xem mới làm con của vùng chứa khả năng truy cập.

Nhớ lại rằng biểu đồ Lịch sử Ngân sách của chúng tôi đang vẽ một biểu đồ thanh ngang, vì vậy chúng tôi sẽ sử dụng HStack và trả về chế độ xem cho mỗi ngân sách.

Tôi sẽ sử dụng Hình chữ nhật cho mỗi yếu tố khả năng tiếp cận để khung sẽ lấp đầy tất cả không gian dọc có sẵn.

Điều này sẽ làm cho khung của mỗi yếu tố khả năng tiếp cận lớn hơn những gì được hiển thị trực quan và điều đó không sao cả.

Có một khung hình lớn nhưng nhất quán sẽ giúp điều hướng dễ dàng hơn trên iOS khi người dùng VoiceOver kéo ngón tay của họ trên màn hình để quét các yếu tố trợ năng.

Nếu tôi chọn HStack từ bên trong công cụ sửa đổi accessibilityChildren(children:), Accessibility Preview xác nhận rằng một phần tử đã được tạo cho mỗi thanh trong biểu đồ.

Tất cả những thứ này sẽ có thể truy cập được dưới dạng con của vùng chứa khả năng truy cập Canvas.

Với những thay đổi này, biểu đồ Lịch sử Ngân sách hiện hoàn toàn có thể truy cập được và các công nghệ hỗ trợ có thể điều hướng qua từng thanh trong biểu đồ.

Lưu ý rằng khung cho mỗi phần tử là như nhau, đó là lý tưởng.

Đối với các biểu đồ phức tạp hơn, chúng tôi có những cách khác để làm cho chúng có thể truy cập được.

Đối với điều đó, vui lòng xem bài thuyết trình của Preston về việc đưa khả năng tiếp cận vào biểu đồ.

Nhưng với trẻ em có khả năng tiếp cận, các yếu tố khả năng tiếp cận của chế độ xem có thể khác với những gì được trình bày trực quan, cho phép bạn điều chỉnh trải nghiệm tuyệt vời.

Nhưng trẻ em có khả năng tiếp cận cũng có thể được sử dụng để soạn thảo khả năng tiếp cận với sự trợ giúp của hành vi kết hợp.

Để làm mới nhanh chóng, hành vi con kết hợp sẽ hợp nhất các thuộc tính từ nhiều yếu tố khả năng tiếp cận thành một yếu tố khả năng tiếp cận mới hoặc hiện có.

Nhưng với việc bổ sung API con về khả năng truy cập, giờ đây nó cũng có thể được sử dụng để soạn quyền truy cập theo cách chung chung.

Với đại diện khả năng tiếp cận, khả năng tiếp cận ban đầu được thay thế hoàn toàn.

Điều này có nghĩa là không có thành phần nào có thể diễn ra; trong khi trẻ em có khả năng tiếp cận là phụ gia.

Điều này có nghĩa là sau này bạn có thể kết hợp các con để hợp nhất các thuộc tính của chúng vào phần tử ban đầu.

Đây là một trường hợp sử dụng nâng cao hơn của công cụ sửa đổi accessibilityChildren(children:), nhưng đó là một chức năng mà tôi muốn làm nổi bật.

Các ví dụ được giới thiệu trong Dự án Mẫu Danh mục Khả năng tiếp cận của bài thuyết trình này.

Tôi hy vọng sẽ thấy nhiều người trong số các bạn khám phá những gì có thể với loại sáng tác này.

Khả năng tiếp cận Trẻ em (trẻ em:) cho phép bạn kiểm soát trẻ em của một thùng chứa.

Và với điều đó, các biểu đồ phức tạp được vẽ bằng Canvas có thể được truy cập bằng các công cụ sửa đổi và chế độ xem mà bạn đã quen thuộc.

Và với hành vi kết hợp của trẻ em, khả năng tiếp cận của một chế độ xem duy nhất có thể bao gồm nhiều.

Bây giờ chúng ta đã học được cách làm cho các thành phần riêng lẻ của ứng dụng có thể truy cập được, chúng ta có thể bắt đầu kết hợp mọi thứ lại với nhau để tinh chỉnh trải nghiệm điều hướng.

Tôi nghe nói rằng việc điều hướng Wallet Pal với VoiceOver rất khó hiểu và khó khăn.

Vì vậy, chúng tôi còn một số việc phải làm nếu chúng tôi muốn cung cấp một ứng dụng có thể truy cập tuyệt vời.

Chúng ta hãy xem xét kỹ hơn băng chuyền Những người bạn ở trên cùng.

Mặc dù tôi chưa xây dựng tính năng này, nhưng tôi dự định thêm một số loại trò chơi hóa vào Wallet Pal.

Vì vậy, tôi đã thêm một nút thử thách ở trên cùng bên trái của mỗi chế độ xem bạn bè.

Chúng tôi đã sửa SymbolButtonStyle, vì vậy nút thử thách sẽ được dán nhãn đúng ngay bây giờ.

Nhưng vì người dùng đang báo cáo rằng điều hướng gây nhầm lẫn, có vấn đề nào khác không?

Để trả lời điều đó, trước tiên chúng ta phải hiểu các công nghệ hỗ trợ sẽ điều hướng Wallet Pal như thế nào.

Theo mặc định, các yếu tố khả năng tiếp cận được sắp xếp dựa trên vị trí hình học của chúng liên quan đến các yếu tố khác, từ trên cùng bên trái đến dưới cùng bên phải.

Điều này có nghĩa là nếu không có các vùng chứa khả năng truy cập để phân biệt nội dung, VoiceOver sẽ điều hướng qua từng nút thử thách, sau đó là nút Hình ảnh và Thêm bạn bè và cuối cùng là văn bản có tên của người dùng.

Một tính năng tuyệt vời của Bản xem trước khả năng truy cập là nó hiển thị các yếu tố khả năng truy cập theo thứ tự được sắp xếp của chúng.

Điều này giúp dễ dàng hình dung cách các công nghệ hỗ trợ sẽ điều hướng ngay từ bên trong Xcode.

Đúng như dự đoán, thứ tự được sắp xếp phù hợp với những gì chúng ta đã thấy trước đây.

Và thứ tự này chắc chắn sẽ gây nhầm lẫn khi điều hướng.

Bây giờ có nhiều cách chúng ta có thể sửa thứ tự sắp xếp của các yếu tố khả năng tiếp cận.

Một điều chúng tôi có thể làm là giới thiệu các thùng chứa khả năng tiếp cận.

Tôi sẽ thêm công cụ sửa đổi accessibilityElement(children:) với hành vi chứa.

Điều này sẽ bao bọc các yếu tố khả năng truy cập của mỗi FriendCellView trong một vùng chứa khả năng truy cập.

Điều này sửa thứ tự điều hướng, bởi vì con của vùng chứa khả năng tiếp cận được điều hướng trước khi chuyển sang phần tử khả năng tiếp cận tiếp theo.

Với sự thay đổi này, VoiceOver sẽ điều hướng qua các con của vùng chứa khả năng truy cập trước khi chuyển sang phần tử khả năng truy cập tiếp theo.

Và vì vậy chúng tôi đạt được thứ tự điều hướng mong muốn hơn nhiều.

Nhưng chúng ta có thể làm tốt hơn để cải thiện trải nghiệm này không?

Một vấn đề là nút thử thách được điều hướng đến trước khi biết người dùng là ai.

Người dùng VoiceOver muốn biết tên của người dùng trước khi gửi thử thách, vì vậy nút này thực sự nên được sắp xếp cuối cùng.

Chúng ta có thể sử dụng công cụ sửa đổi accessibilitySortPriority(_:) để khắc phục điều này.

accessibilitySortPriority(_:) có thể được sử dụng để thay đổi thứ tự của các phần tử trong vùng chứa accessibility.

Một phần tử có mức độ ưu tiên cao hơn sẽ được sắp xếp trước, trong khi mức độ ưu tiên thấp hơn sẽ được sắp xếp cuối cùng.

Các yếu tố có mức độ ưu tiên bằng nhau sau đó được sắp xếp dựa trên vị trí hình học của chúng.

Tôi sẽ thêm công cụ sửa đổi accessibilitySortPriority(_:) vào nút thử thách để cải thiện thứ tự điều hướng.

Tôi sẽ sử dụng mức độ ưu tiên -1 vì mặc định là 0, để buộc thứ tự sắp xếp của nút thử thách là cuối cùng.

Bây giờ nút thử thách sẽ được điều hướng đến cuối cùng.

Đây là một cải tiến tốt, vì ít có khả năng người dùng VoiceOver sẽ bối rối không biết họ đang gửi thử thách cho ai, nhưng nó vẫn không tuyệt vời.

Thay vì gói từng FriendCellView trong một vùng chứa khả năng truy cập, chúng ta có thể kết hợp những đứa trẻ thành một yếu tố duy nhất.

Nhớ lại rằng sự kết hợp hợp nhất các thuộc tính từ trẻ em thành một yếu tố khả năng tiếp cận hiện có hoặc mới.

Hành vi kết hợp cũng sắp xếp các thuộc tính nào được hợp nhất để có kết quả mặc định tốt nhất.

Ví dụ, nút thử thách đã trở thành một hành động có tên "Gửi thử thách".

Điều này cũng sửa thứ tự điều hướng và giảm số lượng các yếu tố khả năng tiếp cận.

Bây giờ có một yếu tố duy nhất cho mỗi người dùng và mỗi yếu tố có một hành động Gửi Thử thách.

Thường là lý tưởng để kết hợp các yếu tố khả năng tiếp cận của các chế độ xem được thể hiện trong ForEach.

Như bạn có thể đã chọn bây giờ, kết hợp là một hành vi siêu hữu ích của trẻ.

Thay vì trẻ em có thể điều hướng riêng lẻ, nó hợp nhất các thuộc tính của chúng thành một phần tử duy nhất, có thể điều hướng được.

Vì khi bạn cần một phần tử duy nhất nhưng không muốn nó kế thừa các thuộc tính từ con, hãy sử dụng hành vi bỏ qua.

Và cuối cùng, hành vi chứa trẻ em bao bọc trẻ em trong một thùng chứa khả năng tiếp cận và nên được sử dụng để thể hiện một nhóm quan điểm có liên quan.

Điều này không chỉ cải thiện thứ tự sắp xếp mặc định mà còn có những lợi thế khác đối với các công nghệ hỗ trợ.

Với Bản xem trước khả năng truy cập mới, việc phát hiện những vấn đề điều hướng này thật dễ dàng.

Và với một vài thay đổi nhỏ, bạn có thể cải thiện đáng kể trải nghiệm.

Nhưng để mang lại trải nghiệm điều hướng thực sự đặc biệt cho người dùng VoiceOver, bạn sẽ muốn xem xét các cánh quạt.

Bây giờ nếu bạn chưa quen với khả năng tiếp cận, bạn có thể nghĩ, "Cánh quạt là gì?"

Nói tóm lại, cánh quạt là một công cụ điều hướng mạnh mẽ.

Chúng có thể được coi là dấu trang cho phép người dùng nhanh chóng điều hướng giữa chúng.

Các cánh quạt hệ thống, chẳng hạn như các tiêu đề và cánh quạt thùng chứa, cung cấp nền tảng cho hình thức điều hướng tăng áp này.

Ví dụ, người dùng có thể nhanh chóng điều hướng qua các phần bằng cách sử dụng rôto tiêu đề.

Điều này là do chế độ xem Phần tự động thêm đặc điểm isHeader vào chế độ xem tiêu đề Nếu bạn không sử dụng chế độ xem Phần, bạn có thể thêm đặc điểm isHeader vào chế độ xem của mình với accessibilityAddTraits(_:).

Tương tự, các vùng chứa khả năng tiếp cận được thêm vào rôto của vùng chứa, như chúng ta đã thấy trước đó, được tạo ra với công cụ sửa đổi accessibilityElement(children:).

Như bạn có thể thấy, việc hỗ trợ rôto tiêu đề cực kỳ dễ dàng và rôto của vùng chứa làm tăng thêm lợi ích của việc nhóm các yếu tố khả năng tiếp cận của bạn với hành vi chứa con.

Bây giờ trải nghiệm điều hướng cơ bản của Wallet Pal đã được tinh chỉnh, hãy tiến thêm một bước nữa với các cánh quạt.

Trong Wallet Pal, các cảnh báo giúp kiểm soát thói quen chi tiêu của người dùng bằng cách cung cấp các thông điệp và cảnh báo động lực khi ngân sách gần hoặc vượt quá giới hạn của họ.

Chúng tôi đã kết hợp các Biểu tượng SF cho các loại cảnh báo khác nhau.

Những thứ này cho phép người dùng trực quan nhanh chóng quét qua danh sách.

Nhưng biểu tượng này sẽ không giúp ích gì cho người dùng VoiceOver.

Thay vào đó, họ sẽ phải điều hướng qua mọi cảnh báo chỉ để biết liệu họ có bất kỳ cảnh báo nào không.

Để tái tạo trải nghiệm tương tự mà người dùng nhìn thấy có, người dùng VoiceOver cần có khả năng điều hướng độc quyền các cảnh báo, theo cách đó, ngay lập tức, họ có thể điều hướng đến cảnh báo cảnh báo tiếp theo.

Để làm điều này, chúng ta có thể sử dụng cánh quạt.

Để biết thêm ví dụ về cánh quạt tùy chỉnh và lý do tại sao chúng lại quan trọng đối với hiệu quả, vui lòng xem bài thuyết trình "Hiệu quả giọng nói cho cánh quạt tùy chỉnh" của chúng tôi từ năm 2020.

Để thêm một cánh quạt cảnh báo vào AlertsView của tôi, điều đầu tiên tôi sẽ làm là đảm bảo rằng tôi đang thêm cánh quạt của mình vào vùng chứa khả năng tiếp cận.

Một số chế độ xem trong SwiftUI là các vùng chứa khả năng truy cập theo mặc định - chẳng hạn như Danh sách hoặc LazyVStack - nhưng VStacks và HStacks thì không, vì vậy tôi sẽ thêm công cụ sửa đổi accessibilityElement(children:) với hành vi chứa con.

Tiếp theo, tôi sẽ tạo rôto của mình với công cụ sửa đổi accessibilityRotor(_:entries:), đặt cho nó cái tên "Cảnh báo".

Và cuối cùng, tôi sẽ khai báo cảnh báo nào của mình mà tôi muốn đưa vào rôto cảnh báo, trong trường hợp này là tất cả các cảnh báo cảnh báo.

Và thế là xong!

Thật dễ dàng để tăng cường điều hướng ứng dụng của bạn.

Một phần của điều làm cho các cánh quạt trở nên dễ dàng cho các trường hợp sử dụng đơn giản này là SwiftUI có thể tự động khớp mục nhập rôto với phần tử trợ năng dựa trên ID.

Điều này là do ID của mục nhập rôto của chúng tôi sẽ khớp với ID được cung cấp cho AlertCellView bởi một ForEach.

Bản sắc của một chế độ xem rất quan trọng để hiểu đối với các cánh quạt có khả năng tiếp cận.

Vì vậy, nếu danh tính chế độ xem không rõ ràng hoặc bạn muốn bồi dưỡng, tôi đặc biệt khuyến khích bạn xem bản trình bày "Giải phẫu SwiftUI" để tìm hiểu thêm.

Bây giờ bạn có thể đang nghĩ, "Giữa, quan điểm của tôi không đơn giản như vậy.

Còn những quan điểm không nằm trong ForEach thì sao? ”

Đừng lo lắng, API rôto khả năng truy cập có thể mở rộng từ chế độ xem đơn giản đến phức tạp.

Ốp lưng đơn giản này hoạt động thanh lịch vì có một yếu tố tiếp cận duy nhất - do sự kết hợp - cho AlertCellView.

Và AlertCellView được xác định bởi ID của cảnh báo.

Điều gì sẽ xảy ra nếu đối với mỗi cảnh báo cũng có chế độ xem Hành động?

Trong trường hợp này, VStack hiện là chế độ xem gốc của ForEach của chúng tôi và đó là VStack sẽ được cung cấp danh tính của cảnh báo.

Vì vậy, để đưa AlertCellView vào rôto cảnh báo của chúng tôi, chúng tôi sẽ cần đánh dấu rõ ràng nó là một mục nhập rôto.

Chúng ta có thể làm điều đó với công cụ sửa đổi accessibilityRotorEntry.

Công cụ sửa đổi này yêu cầu không gian tên và ID, có thể là bất kỳ thứ gì miễn là chúng khớp với ID và không gian tên được sử dụng để tạo AccessibilityRotorEntry.

Và cuối cùng, chúng ta sẽ cần bao gồm không gian tên này cho mỗi mục nhập rôto.

Khả năng tham chiếu đến một không gian tên rõ ràng là thứ cho phép API rôto khả năng truy cập mở rộng từ các trường hợp sử dụng đơn giản đến phức tạp, cho phép các yếu tố khả năng truy cập trải dài trên nhiều chế độ xem được bao gồm trong cùng một rôto.

Các cánh quạt trợ năng cũng có thể được thêm vào để làm phong phú thêm điều hướng văn bản.

Để làm điều đó, hãy sử dụng một biến thể khác của công cụ sửa đổi accessibilityRotor, cho phép bạn cung cấp một mảng các dải văn bản.

Công cụ sửa đổi này rất tốt để cung cấp cho người dùng VoiceOver quyền truy cập nhanh chóng và dễ dàng vào các chuỗi cụ thể trong Trình chỉnh sửa văn bản, chẳng hạn như email, liên kết hoặc số điện thoại.

Các cánh quạt trợ năng giúp người dùng VoiceOver điều hướng phức tạp dễ dàng.

Và với SwiftUI rotors API mới, việc cung cấp trải nghiệm điều hướng đặc biệt này chưa bao giờ dễ dàng hơn thế.

Chủ đề cuối cùng cho ngày hôm nay là tập trung.

Khái niệm về yếu tố tập trung là điều bạn có thể đã quen thuộc, nhưng điều bạn có thể không biết là nhiều công nghệ hỗ trợ của chúng tôi có trạng thái tập trung riêng.

Đây là cái mà chúng tôi gọi là "trọng tâm khả năng tiếp cận".

Đó là quan điểm tập trung mà bạn đã thấy sự thay đổi khi tôi đề cập đến việc điều hướng các công nghệ hỗ trợ.

Vị trí của con trỏ của công nghệ hỗ trợ rất quan trọng đối với trải nghiệm người dùng.

Khi tiêu điểm được thay đổi trong VoiceOver, con trỏ di chuyển để khớp với đường dẫn của phần tử được lấy nét ngoài việc nói mô tả về phần tử.

Vậy khi nào sự tập trung thay đổi?

Sự tập trung có thể nhưng không phải lúc nào cũng thay đổi khi một trong ba sự kiện xảy ra.

Trường hợp sử dụng đầu tiên và phổ biến nhất là khi người dùng điều khiển thay đổi tiêu điểm khi điều hướng đến một yếu tố khả năng truy cập khác.

Trường hợp thứ hai là khi giao diện người dùng thay đổi và chế độ xem tập trung trước đó không còn trên màn hình hoặc được bao phủ bởi chế độ xem phương thức.

Khi điều này xảy ra, tiêu điểm thường được đặt lại thành phần tử khả năng truy cập được sắp xếp đầu tiên.

Điều này tự động bao gồm nhiều trường hợp sử dụng, chẳng hạn như chuyển sang yếu tố khả năng truy cập đầu tiên của chế độ xem mới được trình bày.

Nhưng đó có thể không phải là hành vi tốt nhất trong ứng dụng của bạn, đó là lý do tại sao trọng tâm cũng có thể được thay đổi theo yêu cầu có lập trình.

Tuy nhiên, điều này nên được xử lý một cách thận trọng, bởi vì việc di chuyển trọng tâm của người dùng VoiceOver có thể rất gây rối.

Trên lưu ý đó, hãy tập trung - không có ý định chơi chữ - vào trường hợp cuối cùng.

Năm nay chúng tôi có một API mới sẽ cho phép bạn vừa yêu cầu một công nghệ hỗ trợ để di chuyển trọng tâm của nó, ngoài việc đọc nơi một công nghệ hỗ trợ hiện đang tập trung.

Ở đây chúng tôi có một chế độ xem đơn giản theo dõi thông báo và nếu nó tồn tại, sẽ phủ lên Biểu ngữ thông báo tùy chỉnh.

Chúng tôi muốn sử dụng chế độ xem này trong Wallet Pal để hiển thị cảnh báo cho các thông báo đẩy nhận được khi ứng dụng ở phía trước.

Khi NotificationBanner được thêm vào, các công nghệ hỗ trợ sẽ không tự động tập trung vào nó.

Nhưng chúng tôi có thể yêu cầu họ làm như vậy với AccessibilityFocusState mới.

AccessibilityFocusState là một trình bao bọc tài sản cung cấp cả cách đọc trong đó công nghệ hỗ trợ được tập trung và yêu cầu thay đổi trọng tâm theo chương trình.

Tôi sẽ thêm một cái vào chế độ xem của mình và liên kết nó với NotificationBanner với công cụ sửa đổi accessibilityFocused(_:).

Tiếp theo, tôi sẽ sử dụng công cụ sửa đổi onChange(of:perform:) để theo dõi khi nhận được thông báo mới.

Chỉ khi nhận được thông báo ưu tiên cao, chúng tôi mới yêu cầu thay đổi trọng tâm khả năng tiếp cận.

Điều đặc biệt quan trọng cần lưu ý là việc di chuyển tiêu điểm theo chương trình có thể rất gây rối nếu không có sự tương tác của người dùng xảy ra.

Nó đưa người dùng ra khỏi bất kỳ bối cảnh nào mà họ hiện đang tập trung vào, vì vậy nó phải được xử lý cẩn thận.

Vì vậy, đối với các thông báo ưu tiên thấp hơn, tôi sẽ đăng thông báo khả năng truy cập để VoiceOver thông báo.

Bằng cách này, người dùng VoiceOver vẫn biết một thông báo mới đã xuất hiện và có thể điều hướng đến nó nếu muốn.

Bây giờ hãy bước vào bên trong chế độ xem NotificationBanner.

Khi thông báo xuất hiện, một bộ hẹn giờ được bắt đầu.

Sau khi hoàn thành, thông báo được đặt thành số không.

Nhớ lại từ trước đó khi thông báo là số không, NotificationBanner sẽ bị ẩn.

Điều này có nghĩa là nếu người dùng VoiceOver tập trung vào biểu ngữ thông báo và bộ hẹn giờ hết hạn, tiêu điểm của họ sẽ được đặt lại, vì chế độ xem đã bị xóa; và đây không phải là trải nghiệm người dùng tuyệt vời.

Để khắc phục điều này, hãy đọc xem NotificationBanner của chúng tôi có tập trung vào công nghệ hỗ trợ hay không và nếu có, hãy trì hoãn việc loại bỏ thông báo.

Đây là giải pháp lý tưởng.

Tiêu điểm của người dùng VoiceOver sẽ không còn được đặt lại nữa, vì chế độ xem không còn bị xóa trong khi lấy nét.

Ngoài ra, chúng tôi đã cung cấp cho người dùng công nghệ hỗ trợ số lượng thời gian không giới hạn để tiêu hóa nội dung và tương tác nếu muốn; hai điều có thể khiến người dùng công nghệ hỗ trợ mất nhiều thời gian hơn để làm như vậy.

AccessibilityFocusState là phần cuối cùng bạn cần để cung cấp các ứng dụng SwiftUI đặc biệt và dễ tiếp cận trong năm nay và hơn thế nữa.

Với nó, bạn có thể đọc và hướng trọng tâm của các công nghệ hỗ trợ để tạo ra sự chuyển đổi mượt mà giữa các chế độ xem.

Chà, hôm nay chúng tôi đã đề cập rất nhiều về khả năng truy cập SwiftUI.

Chúng tôi đã được giới thiệu về Bản xem trước khả năng truy cập mới, giúp tăng cường cách bạn có thể phát triển và gỡ lỗi khả năng truy cập SwiftUI; chúng tôi đã đề cập đến cách làm cho các điều khiển tùy chỉnh và đồ thị phức tạp có thể truy cập được; và chúng tôi đã dành thời gian để tìm hiểu cách trải nghiệm điều hướng có thể được cải thiện

Kết hợp mọi thứ lại với nhau, và nó thực sự là một bước nhảy vọt lớn cho khả năng tiếp cận trong năm nay.

Để có một số ví dụ đơn giản và phức tạp tuyệt vời về API Khả năng tiếp cận của chúng tôi, vui lòng xem Dự án Mẫu Danh mục Khả năng truy cập.

Nó có nhiều ví dụ hơn mà chúng tôi không thể đề cập đến ngày hôm nay và một số phương pháp hay nhất được đề xuất của chúng tôi.

Cảm ơn bạn rất nhiều vì đã tham gia cùng tôi.

Chúng tôi mong muốn được xem cách bạn làm cho ứng dụng của mình có thể truy cập được với mọi người.

♪