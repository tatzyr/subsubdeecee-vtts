10030

♪ Nhạc bass đang phát ♪

♪

Sihui Liu: Xin chào. Chào mừng đến với "Phát triển nội dung web nâng cao." Tôi là Sihui, và tôi là một kỹ sư trong nhóm Safari và WebKit.

Tôi rất vui được chia sẻ với bạn những cập nhật quan trọng mà chúng tôi đã thực hiện trong WebKit và Safari cho các nhà phát triển web trong năm qua.

Những điều tôi sắp chia sẻ thường được chia thành ba loại.

Đầu tiên, tôi sẽ hướng dẫn bạn các tính năng và cải tiến mới trong JavaScript.

Sau đó tôi sẽ cung cấp cho bạn cái nhìn tổng quan về các bản cập nhật trong WebAssembly.

Và cuối cùng, tôi sẽ giới thiệu cho bạn một số API web mới có thể thêm các khả năng bổ sung vào nội dung web của bạn.

Có rất nhiều thứ để đề cập, vì vậy hãy bắt đầu với tin tức của chúng tôi bằng JavaScript.

Mỗi năm, có hàng trăm thay đổi được thực hiện trong công cụ JavaScript của chúng tôi.

Tôi sẽ đề cập đến một số điều quan trọng nhất mà bạn cần biết nếu bạn làm việc với JavaScript.

Đó là: cú pháp trường lớp mới, tài liệu tham khảo yếu cho phép quản lý bộ nhớ thông minh hơn, cách sử dụng mới từ khóa await, hỗ trợ cho các mô-đun trong công nhân và giao diện được thêm vào họ API Quốc tế hóa.

Để đưa bạn vào bức tranh về những tính năng mới này, tôi sẽ sử dụng một chiếc đồng hồ bấm giờ đơn giản làm ví dụ.

Đồng hồ bấm giờ chỉ có một nút bấm.

Nhấp vào nó một lần, nó bắt đầu đếm.

Nhấp vào nó một lần nữa, nó sẽ dừng lại và cung cấp cho bạn thời lượng đã trôi qua.

Hãy ghi nhớ điều này và chúng tôi sẽ triển khai nó sau trong JavaScript.

Bây giờ, chúng ta hãy xem cú pháp trường lớp mới.

Chúng tôi có các trường và phương thức lớp riêng tư mới cho phép bạn xác định các thành viên riêng tư thực sự có quyền truy cập được bảo vệ bởi ngôn ngữ.

Bạn sẽ thấy lỗi nếu bạn vi phạm các quy tắc truy cập.

Chúng tôi cũng thêm hỗ trợ cho các trường tĩnh, cho phép bạn khai báo một thành viên lớp có thể được truy cập mà không cần tạo một phiên bản của lớp.

Bây giờ bạn đã có ý tưởng cơ bản.

Hãy kiểm tra xem nó có thể được sử dụng như thế nào với ví dụ đồng hồ bấm giờ.

Nếu bạn được yêu cầu triển khai lớp đồng hồ bấm giờ, việc triển khai của bạn có thể trông như thế này.

StopwatchWithOneButton chỉ có một phương thức có tên click().

Nó kiểm tra biến startTime.

Nếu thời gian bắt đầu không được đặt, nhấp chuột có nghĩa là bắt đầu, vì vậy nó sẽ đặt thời gian bắt đầu.

Nếu thời gian bắt đầu đã được đặt, nhấp chuột có nghĩa là dừng lại, vì vậy nó sẽ tính toán thời lượng và đặt lại thời gian bắt đầu.

Bạn có thể thấy startTime đi kèm với một tiền tố gạch dưới.

Đây là một quy ước đặt tên thường được sử dụng để biểu thị rằng biến chỉ nên được sử dụng bên trong lớp.

Nhưng điều đó không thực sự ngăn cản thời gian bắt đầu được truy cập công khai.

Cú pháp riêng tư mới có thể giúp khắc phục điều này.

Chỉ cần thay thế dấu gạch dưới bằng hàm băm và bạn có thể khai báo một trường phiên bản riêng thực.

Sự đóng gói được thực thi bởi ngôn ngữ.

Ngoài ra còn có hỗ trợ cho các phương pháp riêng tư.

Ví dụ, để làm cho các phương thức click() có cấu trúc hơn, chúng ta có thể tạo hai phương thức riêng tư start() và stop() để thay thế nội dung được đánh dấu, như thế này.

Bằng cách thêm tiền tố băm vào các phương thức, chúng tôi đảm bảo rằng các hàm thành viên chỉ có thể được truy cập từ bên trong lớp.

Cú pháp riêng tư mới cũng áp dụng cho các trường tĩnh như startedStopwatchCount.

Tại đây, startedStopwatchCount chỉ có thể được sửa đổi bởi các đối tượng đồng hồ bấm giờ vào thời điểm bắt đầu hoặc dừng.

Tất nhiên, nếu bạn muốn startedStopwatchCount được truy cập ở mọi nơi, bạn có thể khai báo nó là trường tĩnh công khai, mà không cần tiền tố băm.

Trường tĩnh công khai hiện cũng có sẵn trong WebKit.

Các trường phiên bản riêng tư, các phương thức, các trường tĩnh riêng tư và các trường tĩnh công khai; đó là hỗ trợ trường lớp mới của chúng tôi.

Và hãy tiếp tục với một tính năng khác, các tài liệu tham khảo yếu.

Các tham chiếu yếu cho phép bạn giữ tham chiếu đến một đối tượng JavaScript theo cách không ngăn chặn việc thu gom rác.

Không giống như WeakMap và WeakSet, bạn có thể lấy đối tượng cơ bản mà không cần tham chiếu đến nó.

Hỗ trợ cũng bao gồm thông báo về việc thu gom rác, vì vậy bạn có thể thực hiện một số nhiệm vụ dọn dẹp nếu cần.

Và hãy xem nó có thể được sử dụng như thế nào.

Chúng tôi vừa triển khai lớp đồng hồ bấm giờ.

Bây giờ hãy tưởng tượng bạn đã tạo ra nhiều đối tượng đồng hồ bấm giờ cho các tác vụ khác nhau.

Để kiểm tra, bạn cần nhấp vào tất cả chúng cùng một lúc.

Bạn sẽ làm điều đó như thế nào?

Một cách trực quan là giữ một tập hợp tất cả các trường hợp đồng hồ bấm giờ.

Khi đồng hồ bấm giờ được tạo, hãy thêm nó vào bộ.

Sau đó, trong chức năng clickAllStopwatches, lặp lại bộ và nhấp vào từng đồng hồ bấm giờ.

Nhưng có một vấn đề với cách tiếp cận này.

Chúng tôi biết các đối tượng JavaScript giữ tham chiếu mạnh theo mặc định, vì vậy trong trường hợp này, tất cả các đối tượng đồng hồ bấm giờ không thể được thu gom rác vì tập hợp vẫn có tham chiếu đến chúng.

Tất nhiên, chúng tôi không muốn giữ tất cả các đối tượng đồng hồ bấm giờ xung quanh chỉ để thử nghiệm.

Điều này không tốt cho việc sử dụng bộ nhớ.

Bây giờ, bạn có thể đề nghị chỉ thay thế Set bằng WeakSet, nhưng WeakSet không thể lặp lại được.

Vậy bạn sẽ làm gì?

Chúng ta có thể giải quyết nó với giao diện mới WeakRef, giao diện này chứa các tham chiếu yếu đến một đối tượng.

Chúng tôi vẫn có bộ, nhưng lần này chúng tôi thêm WeakRef của các đối tượng đồng hồ bấm giờ vào bộ.

Trong chức năng clickAllStopwatches, chúng tôi kiểm tra xem đối tượng có còn tồn tại hay không bằng cách hủy tham chiếu nó trước khi nhấp.

Điều này dường như giải quyết được vấn đề của chúng tôi, nhưng có một vấn đề khác: chúng tôi không loại bỏ đồng hồ bấm giờ thu gom rác khỏi bộ này một cách kịp thời và bộ này có thể phát triển khá lớn trước khi kiểm tra nhấp chuột tiếp theo của chúng tôi.

Bây giờ chúng ta nên làm gì?

Một giao diện mới khác - FinalizationRegistry - có thể hữu ích trong trường hợp này.

Với nó, bạn có thể chỉ định một cuộc gọi lại sẽ được gọi khi một số đối tượng được thu thập rác.

Ở đây chúng tôi tạo một đối tượng finalizationRegistry với hàm removeStopwatch, vì vậy hàm này được gọi mỗi khi một đối tượng được thu thập.

Sau đó, chúng tôi đăng ký các đối tượng đồng hồ bấm giờ vào sổ đăng ký.

Mỗi đồng hồ bấm giờ được liên kết với một mã định danh, vì vậy removeStopwatch biết nên tháo đồng hồ bấm giờ nào.

Tốt, bây giờ đồng hồ bấm giờ thu gom rác sẽ bị xóa khỏi allStopwatches.

Việc sử dụng các tài liệu tham khảo yếu nghe có vẻ không khó lắm, phải không?

Nhưng hãy lưu ý rằng việc thu gom rác trong JavaScript rất phức tạp và có rất nhiều điều không chắc chắn.

Ví dụ, đối tượng bạn nghĩ nên được thu thập có thể không thực sự được thu thập cho đến một thời gian dài sau đó và bạn có thể không nhận được cuộc gọi lại từ FinalizationRegistry đúng cách vì nó chạy trên vòng lặp sự kiện.

Do đó, hãy đảm bảo rằng bạn hiểu đầy đủ cú pháp và hành vi mong đợi của nó trước khi sử dụng.

Hãy chuyển từ các tham chiếu yếu sang tính năng tiếp theo, cấp cao nhất đang chờ đợi.

Đây là một tính năng mới cho các mô-đun.

Nó cho phép bạn sử dụng từ khóa await bên ngoài hàm async.

Trong trường hợp này, bản thân mô-đun giống như một hàm không đồng bộ lớn, vì vậy một mô-đun không đồng bộ có thể chặn việc thực thi mô-đun nhập chúng.

Hãy để tôi chỉ cho bạn một ví dụ với lớp học đồng hồ bấm giờ của chúng tôi.

Đây là lớp học mà chúng tôi vừa tạo ra.

Để minh họa việc sử dụng await cấp cao nhất, hãy biến nó thành một mô-đun và xuất lớp.

Đây là một tệp HTML chứa một mô-đun nội tuyến.

Nó nhập mô-đun đồng hồ bấm giờ bằng cách sử dụng nhập động.

Hàm nhập trả về một lời hứa, vì vậy chúng ta có thể sử dụng các phương thức then hoặc catch để thực hiện các hành động sau khi nhập xong.

Với await cấp cao nhất, bạn có thể loại bỏ các phương thức xâu chuỗi và viết mã theo cách đồng bộ.

Điều này có thể làm cho mã của bạn dễ theo dõi hơn.

Ngoài ra, bởi vì các mô-đun đã nhập được đánh giá tại thời điểm tải, vì vậy một mô-đun không đồng bộ có thể chặn việc thực thi các mô-đun tùy thuộc vào nó.

Điều đó có nghĩa là nếu mô-đun đồng hồ bấm giờ chạy các hoạt động không đồng bộ và chờ kết quả, biến đồng hồ bấm giờ ở đây sẽ được khởi tạo sau khi mô-đun đồng hồ bấm giờ kết thúc thực thi.

Chờ đợi cấp cao nhất đã giúp việc quản lý phụ thuộc trở nên dễ dàng hơn.

Nhưng một lần nữa, tính năng này chỉ có sẵn trong các mô-đun, vì vậy nếu tập lệnh không phải là một mô-đun, như thế này...

...Bạn sẽ thấy một lỗi cú pháp trong Web Inspector.

Nói về các mô-đun, có một tính năng liên quan khác: công nhân mô-đun.

Người lao động có một số lợi ích nổi tiếng.

Nó có thể chạy các tập lệnh trong một chuỗi nền, vì vậy các tài nguyên có thể được sử dụng hiệu quả hơn.

Với sự hỗ trợ mới này, người lao động hiện chia sẻ những lợi ích của các mô-đun, bao gồm nhập động, tải và thực hiện được tối ưu hóa và quản lý phụ thuộc.

Nó có lợi hơn và dễ dàng hơn cho bạn để di chuyển công việc nặng nhọc từ chủ đề chính sang chủ đề nền ngay bây giờ.

Các mô-đun hiện có sẵn trong các loại công nhân khác nhau, bao gồm nhân viên web, nhân viên dịch vụ và worklet.

Để tạo một nhân viên mô-đun, đối với nhân viên web và nhân viên dịch vụ, bạn cần chỉ định loại là mô-đun trong các tùy chọn.

Đối với một worklet như Audio Worklet, bạn có thể sử dụng chức năng addModule.

Khá dễ dàng để tạo một nhân viên mô-đun giúp tăng tốc ứng dụng của bạn.

Phần cuối cùng trong JavaScript là các bản cập nhật trên API Quốc tế hóa.

API này cung cấp định dạng dựa trên ngôn ngữ.

Sẽ rất hữu ích nếu nội dung web của bạn được xây dựng cho người dùng ở các ngôn ngữ khác nhau.

Để cho bạn thấy nó có thể được sử dụng như thế nào, tôi đã xây dựng trang hồ bấm giờ này bởi vì, bạn biết đấy, đồng hồ bấm giờ cần phải theo kịp thời gian và các bản phát hành tính năng của chúng tôi.

Trang này hiển thị cho chúng tôi thông tin chi tiết về việc sử dụng đồng hồ bấm giờ một lần, bao gồm thời lượng, thời gian bắt đầu, sự kiện, người tham gia và các ngôn ngữ có sẵn của trang.

Bây giờ, chúng ta hãy đi sâu vào từng phần và xem xét kỹ hơn từng giao diện.

Đầu tiên là NumberFormat.

NumberFormat cung cấp định dạng số nhạy cảm với ngôn ngữ và nó được sử dụng để định dạng thời lượng.

Trình tạo của NumberFormat nhận hai tham số tùy chọn: ngôn ngữ và các tùy chọn.

Ở đây tôi đặt ngôn ngữ thành tiếng Anh và tôi tạo hai đối tượng tùy chọn, chỉ định số chữ số tối thiểu khác nhau.

Sau khi tạo hai đối tượng NumberFormat với ngôn ngữ và các tùy chọn, chúng ta có thể sử dụng chúng để định dạng các số thời lượng.

Ở đây, nếu số không phải là mili giây, tôi sử dụng Format1 để giữ hai chữ số; nếu không tôi sử dụng Format2 để giữ ba chữ số.

Như bạn có thể thấy, phương thức định dạng sẽ tự động thêm các số không đệm cho chúng tôi.

Có nhiều tùy chọn khác nhau mà bạn có thể sử dụng để tạo các định dạng bạn cần, chẳng hạn như kiểu dáng, nơi bạn có thể chỉ định giá trị là tiền tệ hoặc đơn vị.

Tiếp theo là DateTimeFormat, cho phép định dạng ngày và giờ nhạy cảm với ngôn ngữ.

Cách sử dụng tương tự như NumberFormat.

Đầu tiên, thiết lập ngôn ngữ.

Sau đó, thiết lập các tùy chọn.

Trong các tùy chọn, tôi đặt các kiểu khác nhau cho ngày và giờ.

Đối tượng DateTimeFormat cung cấp một cấu hình chi tiết thậm chí cho phép bạn chỉ định kiểu cho giây hoặc mili giây.

Sau đó, chúng ta có thể tạo một đối tượng DateTimeFormat với các tham số và sử dụng nó để định dạng thời gian bắt đầu của chúng ta.

Kết quả được thể hiện bằng tiếng Anh.

Bạn có thể thấy ngày tháng chi tiết hơn vì nó có phong cách dài.

Cái tiếp theo là Segmenter.

Nó cho phép bạn thực hiện tách chuỗi nhạy cảm với ngôn ngữ.

Tôi đã sử dụng nó để tìm các từ khóa trong câu sự kiện.

Đây là phiên bản tiếng Trung của trang ghi đồng hồ bấm giờ.

Đầu tiên, tôi khai báo một danh sách ngắn các từ khóa mà tôi muốn làm nổi bật.

Chuỗi sự kiện thậm chí còn bao gồm một Unicode cho biểu tượng độ C.

Ở đây chúng tôi chỉ định tiếng Trung là ngôn ngữ.

Trong các tùy chọn, độ chi tiết được đặt thành một từ.

Các giá trị khả thi khác là đồ thị và câu.

Sau đó, chúng tôi tạo một Segmenter và sử dụng nó để tách chuỗi bằng phương thức phân đoạn.

Chúng ta có thể lặp lại các đối tượng kết quả để có được tất cả các phân đoạn.

Kiểm tra xem mỗi phân đoạn có nằm trong danh sách từ khóa để đánh dấu nó không.

Segmenter khá hữu ích cho việc phiên dịch các ngôn ngữ, như tiếng Trung, nơi ranh giới từ không quá rõ ràng.

Tiếp theo là ListFormat, cho phép định dạng danh sách nhạy cảm với ngôn ngữ.

Giống như trước đây, chúng ta có thể chỉ định ngôn ngữ và các tùy chọn.

ListFormat không có nhiều tùy chọn như các giao diện khác.

Những cái hữu ích nhất mà tôi tìm thấy là kiểu chữ và kiểu dáng.

Với ngôn ngữ và các tùy chọn, chúng tôi có thể tạo Định dạng Danh sách và định dạng danh sách người tham gia mà chúng tôi có.

Như bạn có thể thấy, vì kiểu là liên từ và kiểu dài, phương thức định dạng thêm dấu phẩy và từ "và" trong kết quả.

Cái cuối cùng là DisplayNames.

Nó cung cấp bản dịch nhất quán các tên hiển thị cho ngôn ngữ, khu vực và kịch bản.

Ở đây tôi chỉ định ngôn ngữ là tiếng Nhật.

DisplayNames có thể lấy mã ngôn ngữ làm đầu vào.

Trong các tùy chọn, chúng tôi đặt kiểu làm ngôn ngữ.

Sau đó chúng ta có thể tạo đối tượng DisplayNames.

Và ở đây, sử dụng phương pháp, chúng ta có thể nhận được kết quả đã dịch.

Mặc dù trang này được xây dựng bằng tiếng Anh, người dùng Nhật Bản có thể biết những ngôn ngữ nào được hỗ trợ.

Và đây là cách tôi xây dựng trang hồ bấm giờ với các giao diện quốc tế hóa mới.

Để làm mới trí nhớ của bạn, đây là danh sách những thứ chúng tôi vừa xem xét trong phần JavaScript.

Sau đó, điểm dừng tiếp theo của chúng tôi là cập nhật trong WebAssembly.

Chúng tôi đã vận chuyển công cụ WebAssembly của mình trong một thời gian, nhưng trong trường hợp bạn không quen thuộc với nó, hãy để tôi bắt đầu bằng cách điền vào một số thông tin cơ bản về WebAssembly.

WebAssembly là một định dạng hướng dẫn nhị phân cho một máy ảo dựa trên ngăn xếp.

Nó là một loại mã có thể chạy trong các trình duyệt web hiện đại với hiệu suất gần với mã gốc.

WebAssembly được thiết kế để trở thành mục tiêu biên dịch di động cho các ngôn ngữ lập trình như C, C++ hoặc Rust, vì vậy WebAssembly có thể giúp chúng tôi triển khai các ứng dụng được viết bằng các ngôn ngữ đó trên web.

Trong hầu hết các trường hợp sử dụng của WebAssembly, nó chạy cùng với JavaScript.

Họ có thể giao tiếp với nhau thông qua WebAssembly API.

WebAssembly có thể cung cấp hiệu suất gần như nguyên bản và cung cấp các khuôn khổ mạnh mẽ trên web.

JavaScript có thể thao tác DOM và cung cấp các API web mạnh mẽ.

Chúng có thể là những bổ sung tốt cho nhau.

Một ví dụ điển hình về việc sử dụng WebAssembly là Funky Karts.

Đây là một trò chơi được chuyển đổi từ C++ sang WebAssembly với Emscripten.

Như bạn có thể thấy, nó sẽ chạy rất trơn tru trong Safari.

Năm nay, chúng tôi đã nâng cấp công cụ WebAssembly của mình với các tính năng sau: hướng dẫn bộ nhớ mới cung cấp cho bạn hiệu suất tốt hơn trong các hoạt động bộ nhớ hàng loạt, như sao chép hoặc khởi tạo các khối bộ nhớ; hướng dẫn mới để yêu cầu quy trình người dùng không bị mắc kẹt ngoại lệ, như tràn dương khi chuyển đổi giữa Các đối tượng, chuyển chúng làm đối số và lưu trữ chúng; và cuối cùng, phát trực tuyến tải xuống và biên dịch WebAssembly rút ngắn thời gian thực thi tổng thể.

Đây là những điểm nổi bật của các tính năng WebAssembly mới của chúng tôi.

Chúng tôi hy vọng họ sẽ giúp bạn phát triển.

Bây giờ, hãy chuyển từ mã cấp thấp mạnh mẽ sang một số API cấp cao.

Trong phần này, chúng ta sẽ khám phá các API web mới.

Mục tiêu của tôi là không chỉ cho bạn biết về các tính năng mới mà còn khiến bạn cảm thấy sẵn sàng sử dụng chúng, vì vậy bạn sẽ thấy một số ví dụ điển hình.

Nhưng đây sẽ không phải là một hướng dẫn đầy đủ, vì vậy hãy nhớ kiểm tra tài liệu chính thức trước khi sử dụng.

Đây là bản xem trước các tính năng mà tôi sẽ nói đến.

Một số trong số chúng hoàn toàn mới như Nhận dạng giọng nói và một số trong số chúng đã có sẵn, nhưng chúng tôi có một số cập nhật mà chúng tôi muốn chia sẻ, như Truy cập bộ nhớ.

Bây giờ, hãy tìm hiểu từng người trong số họ.

Chúng tôi biết để làm cho nội dung web hấp dẫn, điều rất quan trọng là cung cấp trải nghiệm hình ảnh tuyệt vời.

Với WebGL2 có sẵn trong WebKit và Safari, bạn sẽ dễ dàng tạo nội dung web đẹp, tương tác hơn.

Đây là một ví dụ điển hình về những gì có thể được thực hiện với WebGL2.

After the Flood là một bản demo tương tác được phát triển bởi PlayCanvas.

Bạn có thể thấy gió nhẹ lắc lư cái cây.

Nó trông sống động trong Safari.

Vậy WebGL2 là gì?

WebGL là một API cấp thấp được sử dụng rất rộng rãi để kết xuất đồ họa 2D và 3D.

WebGL2 là bản nâng cấp của WebGL giúp loại bỏ dự phòng và giới thiệu một số tính năng mới thú vị.

Nó thêm kết cấu 3D để cho phép hiển thị các hiệu ứng thể tích như đám mây.

Nó có các đối tượng lấy mẫu giúp bạn linh hoạt hơn về cách sử dụng kết cấu trong đổ bóng.

Nó cung cấp phản hồi chuyển đổi giúp bạn triển khai các hệ thống hạt hiệu suất trên GPU.

Có rất nhiều tính năng mới tuyệt vời trong WebGL2.

Và quan trọng hơn, WebGL2 hiện có sẵn trong Safari trên tất cả các thiết bị Apple.

Điều đó có nghĩa là bạn có thể xây dựng một trang web đẹp trông tuyệt vời ở mọi nơi.

Và hãy làm quen hơn với WebGL2 với một ví dụ: tạo một hình vuông màu cam.

Và đây là mã JavaScript bạn cần viết cho nó.

Nếu bạn chưa từng sử dụng WebGL trước đây, điều này có thể không dễ dàng như bạn tưởng tượng.

Như tôi đã đề cập, bởi vì WebGL là một API cấp thấp, nó có thể rất dài dòng.

Nhưng đừng lo lắng; có rất nhiều thư viện và khuôn khổ tuyệt vời có thể giúp đơn giản hóa sự phát triển của bạn.

Với họ, không khó để tạo ra một hình vuông đẹp hoặc thứ gì đó phức tạp hơn thế.

Bây giờ, nếu bạn đã sử dụng WebGL trong nội dung web của mình, cũng có một tin tốt.

Chúng tôi đã cải thiện hỗ trợ của mình bằng cách di chuyển phụ trợ từ OpenGL sang Metal.

Điều đó có nghĩa là iOS Simulator hiện có thể sử dụng GPU cho nội dung web, làm cho nó thể hiện chính xác hơn nhiều về những gì người dùng của bạn sẽ thấy.

Ngoài ra, bạn có thể sử dụng các công cụ Metal, chẳng hạn như Xcode Frame Debugger, để phân tích mã WebGL của bạn ngay bây giờ.

Bên cạnh việc tạo nội dung với WebGL, một cách phổ biến khác để cung cấp trải nghiệm hình ảnh tuyệt vời là thông qua video.

Không phải tất cả các trình duyệt đều có cùng loại hỗ trợ cho các định dạng phương tiện, vì vậy đôi khi bạn có thể khó quyết định định dạng nào bạn sẽ sử dụng.

Để giúp mọi thứ dễ dàng hơn cho bạn, năm nay, chúng tôi đã tăng cường hỗ trợ cho WebM, một định dạng phương tiện phổ biến trên web.

Để bắt đầu, hỗ trợ chỉ dành cho phát trực tuyến.

Trong macOS 11.3, chúng tôi đã thêm hỗ trợ phát các tệp WebM có chứa video VP8 hoặc VP9 và âm thanh Vorbis.

Và trong macOS 12, chúng tôi thêm hỗ trợ cho các tệp có chứa âm thanh Opus.

Năm ngoái, chúng tôi đã bắt đầu hỗ trợ WebM được phát thông qua Tiện ích mở rộng nguồn phương tiện trên macOS.

Bây giờ, chúng tôi đang mang sự hỗ trợ đó đến iPadOS 15.

Để kiểm tra xem WebM có được hỗ trợ trong mã của bạn hay không, bạn có thể sử dụng MediaCapabilities API, cho phép bạn phát hiện cấu hình phương tiện chính xác mà bạn muốn sử dụng.

Cấu hình trên màn hình được hỗ trợ trong Safari mới nhất và điều đó có nghĩa là VP9 hiện cũng được hỗ trợ.

Với sự hỗ trợ cho định dạng mã hóa video này, chúng tôi mong đợi nhiều nội dung web hơn sẽ có sẵn trong các ứng dụng Safari và WebKit.

Bạn có thể sử dụng VP9 trong cả phát trực tuyến và WebRTC.

Nó hoạt động trên macOS và iPadOS.

Về hỗ trợ trên các thiết bị khác nhau, nó có sẵn trên tất cả các máy Mac silicon của Apple.

Đối với những người khác, bạn có thể kiểm tra với MediaCapabilities API, giống như những gì chúng ta vừa thấy cho WebM.

Bây giờ, nếu trang web của bạn có nội dung WebM hoặc VP9, tôi khuyến khích bạn kiểm tra xem nó hoạt động như thế nào trong Safari và WebKit mới nhất; nhưng nếu bạn vẫn đang quyết định sử dụng định dạng phương tiện nào, chúng tôi khuyên bạn nên sử dụng H.264 hoặc HEVC.

H.264 đã trưởng thành và được hỗ trợ tốt trên các trình duyệt.

HEVC có sự hỗ trợ tuyệt vời cho các video chất lượng cao.

Cả hai đều đi kèm với khả năng tăng tốc phần cứng có thể phát lại mượt mà hơn và thời lượng pin phát lại lâu hơn.

Nói về việc lưu trữ nội dung video, một trường hợp phổ biến là chúng tôi không sở hữu nội dung; thay vào đó, chúng tôi nhận được nó từ bên thứ ba.

Ví dụ, tôi thấy video hay này trên video.domain.

Để làm cho nó xuất hiện trên trang web của tôi, main.domain, tôi có thể tải nguồn video này từ video.domain, hoặc tôi chỉ tạo iframes của video.domain.

Vì lý do bảo mật, iframe hoặc tài nguyên của bên thứ ba không có quyền truy cập vào bộ nhớ của bên thứ nhất theo mặc định.

Và điều đó có nghĩa là nếu yêu cầu tài nguyên cho video.domain được khởi tạo từ main.domain, nó sẽ không bao gồm cookie của video.domain.

Đây có thể là một vấn đề khi các máy chủ web của video.domain chỉ muốn cung cấp nội dung cho những người dùng được xác thực.

Và không có cookie có nghĩa là không có xác thực.

API Truy cập Lưu trữ giải quyết vấn đề này.

Nó cho phép iframe của bên thứ ba yêu cầu quyền truy cập cookie của bên thứ nhất.

Nếu người dùng cấp quyền, video.domain của bên thứ ba sẽ có thể truy cập cookie của bên thứ nhất.

API Truy cập Lưu trữ đã có sẵn trong WebKit và Safari trong hơn ba năm.

Để cải thiện khả năng tương tác, năm nay chúng tôi đã thêm hai tính năng mới.

Đầu tiên, quyền truy cập được cấp trên phạm vi mỗi trang.

Nó có nghĩa là một khi sự cho phép được cấp cho bên thứ ba, nó sẽ được mở rộng cho tất cả các tài nguyên con của nó trên cùng một trang.

Bạn không cần phải đưa ra yêu cầu cho mỗi iframe.

Thứ hai, chúng tôi cho phép các iframe lồng nhau đưa ra yêu cầu.

Điều này có nghĩa là iframe bên trong iframe cũng có thể yêu cầu quyền truy cập vào cookie của bên thứ nhất, điều này trước đây không thể thực hiện được.

Để tìm hiểu thêm về cách sử dụng mới, vui lòng kiểm tra bài đăng trên blog của chúng tôi "Cập nhật API Truy cập Lưu trữ" tại webkit.org.

Bây giờ chúng tôi đã biết cách tải hoặc nhập nội dung video từ bên thứ ba với sự cho phép của người dùng nếu cần.

Làm thế nào về việc tự tạo ra thứ gì đó?

Với Media Recorder API mới, rất dễ dàng để làm điều đó.

Media Recorder API cho phép bạn thu thập dữ liệu từ các yếu tố phương tiện, bao gồm các yếu tố phương tiện HTML như thẻ video hoặc các đối tượng MediaStream.

Bạn có thể sử dụng nó để ghi lại từ các thiết bị đầu vào của người dùng.

Bạn có thể chỉ định các tùy chọn mong muốn, chẳng hạn như loại MIME của vùng chứa hoặc tốc độ bit mong muốn của các bản nhạc.

API rất đơn giản.

Nó bao gồm một giao diện chính duy nhất, MediaRecorder, thực hiện tất cả công việc thu thập dữ liệu từ nguồn và cung cấp cho bạn.

Để tôi chỉ cho bạn một ví dụ.

Tôi đã sử dụng MediaRecorder API để xây dựng ứng dụng web này có tên là "Voice Memo".

Đây là bản ghi nhớ giọng nói đầu tiên của tôi.

Nhấp vào nút, nó bắt đầu ghi âm từ micrô.

Nhấp một lần nữa, nó dừng ghi âm và cung cấp phát lại.

Đây là bản ghi nhớ giọng nói đầu tiên của tôi.

Điều đó thật vui.

Và bây giờ hãy kiểm tra việc triển khai.

Chúng tôi có hai chức năng chính: startRecording và stopRecording.

Trong startRecording, chúng tôi nhận được luồng phương tiện đầu vào cho micrô.

Sau đó, chúng tôi tạo ra một đối tượng MediaRecorder với điều đó.

Chúng tôi lắng nghe hai sự kiện của máy ghi âm phương tiện truyền thông.

Và sau đó chúng ta có thể khởi động máy ghi âm bằng phương pháp bắt đầu.

Để dừng ghi âm, chúng ta chỉ cần gọi phương thức dừng trên đối tượng mediaRecorder.

Đây là hai người xử lý sự kiện.

Khi một số dữ liệu được thu thập có sẵn, chúng tôi lưu trữ nó trong một mảng.

Khi quá trình ghi bị dừng lại, chúng tôi tạo một đốm màu với dữ liệu được thu thập trong một mảng và gửi nó đến một phần tử âm thanh hiện có để phát lại.

Cứ như vậy, bạn có thể tạo một máy ghi âm chức năng.

Sau khi bạn thu thập dữ liệu âm thanh, bạn có thể muốn chỉnh sửa nó.

Trong trường hợp này, bạn có thể sử dụng tốt Audio Worklet API.

Giao diện Audio Worklet là một phần của Web Audio API, mà bạn có thể đã quen thuộc nếu bạn đã thực hiện xử lý âm thanh trên web trước đây.

Nó cho phép chúng tôi chạy các tập lệnh như mã JavaScript hoặc WebAssembly để xử lý âm thanh trên chuỗi kết xuất âm thanh hỗ trợ AudioNodes tùy chỉnh.

So với ScriptProcessorNode, giải pháp trước đó để chạy tập lệnh tùy chỉnh, nó làm giảm sự nhảy giữa luồng kết xuất và luồng chính và đảm bảo độ trễ thấp.

Với Audio Worklet, tôi đã thêm một khả năng mới vào Voice Memo của mình.

Đây là giọng nói méo mó của tôi.

Nếu hộp Distortion được chọn để ghi âm, một số hiệu ứng biến dạng sẽ được áp dụng cho âm thanh.

Đây là giọng nói méo mó của tôi Nghe có vẻ tuyệt, và chúng ta hãy xem nó được thực hiện như thế nào.

Tôi đã sửa đổi chức năng startRecording để thêm xử lý âm thanh.

Chúng ta vẫn cần lấy MediaStream để nhập âm thanh trước.

Để sử dụng Audio Worklet API, có bốn bước cơ bản.

Bước một: tạo một nguồn.

Bước hai: tạo một AudioWorkletNode và liên kết nó với một bộ xử lý Audio Worklet thực hiện xử lý âm thanh.

Bộ xử lý được triển khai trong một mô-đun, và chúng ta sẽ xem xét nó sau.

Bước ba: tạo một điểm đến.

Bước bốn: kết nối đường dẫn từ nguồn đến đích.

Lần này, MediaRecorder lấy đầu ra từ AudioWorklet làm nguồn và nó ghi lại âm thanh bị biến dạng.

Đây là mô-đun xử lý âm thanh.

Chúng tôi triển khai lớp DistortionProcessor ở đây.

Nó phải mở rộng lớp AudioWorkletProcessor và phải cung cấp việc triển khai cho chức năng quy trình.

Các đầu vào là các mẫu âm thanh đi vào Audio Worklet và đầu ra là các mẫu kết quả sau khi xử lý.

Bạn có thể sử dụng các thuật toán khác nhau để tạo ra đầu ra.

Ở đây, tôi sử dụng một hàm tùy chỉnh được gọi là distort() để tính toán một giá trị dựa trên đầu vào.

Hàm xử lý trả về true, có nghĩa là nút xử lý đang hoạt động.

Đó là cấu trúc cơ bản của chức năng quy trình.

Sau khi tạo lớp bộ xử lý, chúng ta cần đăng ký nó trên toàn cầu dưới một tên được chỉ định, vì vậy nó có thể được sử dụng để xây dựng AudioWorkletNode.

Cứ như vậy, bạn có thể áp dụng hiệu ứng âm thanh cho dữ liệu âm thanh của mình.

Cho đến nay chúng tôi đã thảo luận về việc sản xuất và xử lý dữ liệu âm thanh.

Làm thế nào về việc lưu trữ nó hoặc chia sẻ nó đến một nơi khác để bạn ghi lại?

Tôi đoán bạn không muốn mất bản ghi âm sau khi bạn thoát khỏi trình duyệt.

Với các bản cập nhật cho Web Share API trong năm nay, thật dễ dàng để làm điều đó.

Web Share không phải là mới trong WebKit và Safari.

Nếu bạn chọn chia sẻ liên kết trên trang web trong Safari, một bảng chia sẻ sẽ hiển thị với các mục tiêu chia sẻ như Tin nhắn, Thư hoặc AirDrop.

Bảng chia sẻ phù hợp với phong cách hệ thống được tạo bằng Web Share API.

Năm nay, chúng tôi đã thêm hỗ trợ cho việc chia sẻ tệp.

Điều đó có nghĩa là bạn có thể chia sẻ hình ảnh, video, âm thanh hoặc các loại tệp khác với API này ngay bây giờ.

Hãy thêm khả năng chia sẻ vào Voice Memo.

Nếu hộp Lưu được chọn, Voice Memo sẽ tạo một tệp âm thanh với dữ liệu đã thu được và hiển thị nút Chia sẻ để cho phép chúng tôi chia sẻ tệp.

Ở đây, tôi muốn chia sẻ tệp ghi nhớ qua email.

Chỉ với một cú nhấp chuột, một bản nháp đẹp được tạo ra với tệp ghi nhớ được đính kèm.

Và hãy kiểm tra mã.

Đây là trình xử lý sự kiện dừng mà chúng tôi đã thấy trong ví dụ MediaRecorder.

Đầu tiên, hãy tạo biến blob trong trình xử lý sự kiện dừng toàn cầu, để nó có thể được sử dụng bởi hàm chia sẻ.

Chức năng chia sẻ là trình xử lý sự kiện nhấp chuột của nút chia sẻ.

Nó chuyển đổi một đốm màu thành một tệp và đặt cho nó một tên tệp.

Tệp được đặt trong một mảng vì đó là loại đầu vào dự kiến.

Sau đó, chúng tôi kiểm tra xem API có khả dụng hay không và liệu tệp có thể được chia sẻ với phương thức canShare hay không.

Nếu kiểm tra được thông qua, chúng tôi gọi navigator.share với mảng tệp.

Có những tùy chọn bạn có thể chỉ định, như tiêu đề và văn bản mô tả.

Thật dễ dàng để làm cho ứng dụng web của bạn chia sẻ tệp giống như một ứng dụng gốc.

Chà, nếu bạn không thực sự muốn tương tác với dữ liệu âm thanh, nhưng chỉ muốn văn bản của nó chẳng hạn, trong trường hợp lệnh thoại cũng có một API mới cho bạn.

Đó Là Nhận Dạng Giọng Nói.

Giống như tên gọi của nó được đề xuất, Speech Recognition API ghi lại âm thanh trực tiếp và phiên âm nó thành văn bản.

Nó cũng cung cấp cho bạn xác suất và lựa chọn thay thế bảng điểm.

Nó sử dụng cùng một công cụ giọng nói như Siri, và nó nhận được tất cả các lợi ích: hỗ trợ nhiều ngôn ngữ và độ chính xác cao.

Điều đó cũng có nghĩa là người dùng của bạn sẽ cần bật Siri hoặc Đọc chính tả trong Tùy chọn hoặc Cài đặt Hệ thống để cung cấp API.

Nhận dạng có thể dựa trên máy chủ, vì vậy chúng tôi đưa ra lời nhắc về quyền riêng tư khi dịch vụ nhận dạng được sử dụng lần đầu tiên trong ứng dụng.

Người dùng có thể thay đổi quyền trong Tùy chọn hoặc Cài đặt Hệ thống.

Bây giờ, hãy cập nhật Voice Memo với khả năng mới này.

Nếu hộp Nhận dạng được chọn, điều đó có nghĩa là tạo bảng điểm cho bản ghi âm.

Đây là bản ghi nhớ giọng nói của tôi.

Giai đoạn.

Và hãy kiểm tra mã.

Cách sử dụng hơi giống với máy ghi phương tiện.

Ở đây chúng ta có hai chức năng chính: startRecognition và stopRecognition.

Trước tiên bạn cần tạo một đối tượng webkitSpeechRecognition.

Vâng, chúng tôi vẫn giữ tiền tố WebKit ngay bây giờ để tương thích, vì vậy đừng quên thêm nó.

Sau đó, bạn có thể đặt một số thuộc tính của nhận dạng, như liên tục, yêu cầu nhận dạng tiếp tục cho đến khi nó dừng lại.

Chúng tôi lắng nghe kết quả và kết thúc các sự kiện.

Với đối tượng nhận dạng, chúng ta có thể gọi phương thức bắt đầu để bắt đầu và gọi phương thức dừng để dừng.

Trong sự kiện kết quả, chúng tôi thu thập finalTranscript vào một chuỗi.

Ở đây, tôi chỉ chọn mục đầu tiên của kết quả vì các lựa chọn thay thế phiên âm được sắp xếp dựa trên xác suất.

Khi nhận dạng dừng lại, tôi sử dụng chức năng nhật ký tùy chỉnh để in bảng điểm lên màn hình.

Như vậy, bạn có thể thêm khả năng nhận dạng vào nội dung web của mình chỉ trong vài dòng.

Đó là một hành trình dài, và có một API web cuối cùng mà tôi nghĩ đáng được nhắc đến.

Bạn có thể nhận thấy rằng trên macOS và iOS, tiện ích Đang phát có thể hiển thị cho bạn trạng thái phương tiện trong Safari.

Nó tiện lợi, nhưng nó thường không chứa nhiều thông tin.

Ví dụ, điều này chỉ hiển thị tiêu đề của trang web; không có thông tin về âm thanh đang được phát.

Có một API web mới có thể giúp bạn cải thiện tình huống này: Media Session API.

Media Session API cho phép bạn truyền đạt trạng thái phương tiện giữa trang web và các thành phần nền tảng khác.

Nếu bạn muốn người dùng của mình xem hoặc kiểm soát trạng thái phương tiện bên ngoài trang web, như trong tiện ích Đang phát, đây là API bạn cần biết.

Để biết thêm chi tiết về Media Session API, vui lòng kiểm tra phiên WWDC của chúng tôi "Phối hợp phát lại phương tiện trên web với GroupActivities."

Và đây là những tính năng mới mà chúng tôi vừa khám phá.

Tôi hy vọng bạn cảm thấy bạn đã học được điều gì đó về nó.

Và bài tập về nhà của bạn hôm nay là triển khai Voice Memo của riêng bạn với các API mới này.

Tôi chỉ đùa thôi, nhưng chúng tôi có một vài điều chúng tôi hy vọng bạn có thể làm để giúp chúng tôi mang đến cho bạn trải nghiệm phát triển tốt nhất trong WebKit và Safari.

Vui lòng thử các tính năng mới trong WebKit và Safari mới nhất và gửi báo cáo lỗi tại bugs.webkit.org.

Bạn có thể xem qua các tính năng hoặc tính năng mới đang được phát triển tích cực với Safari Technology Preview.

Nếu bạn quan tâm đến các công nghệ web được sử dụng trong WebKit hoặc Safari, hoặc quan tâm đến việc tham gia cộng đồng WebKit, webkit.org là một nguồn tốt.

Nếu bạn muốn nhận thông tin cập nhật mới về WebKit hoặc nếu bạn có bất kỳ câu hỏi nào cho chúng tôi, đừng quên theo dõi chúng tôi hoặc gắn thẻ chúng tôi trên Twitter.

Cảm ơn vì đã xem phiên này, và tôi hy vọng bạn có một khoảng thời gian tuyệt vời tại WWDC!

♪