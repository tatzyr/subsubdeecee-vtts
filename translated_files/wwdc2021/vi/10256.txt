10256

♪ Nhạc bass đang phát ♪

♪

Kyle Macomber: Xin chào, tôi là Kyle.

Nhóm Thư viện Tiêu chuẩn Swift duy trì một danh sách ngày càng tăng các gói mã nguồn mở bao gồm Swift ArgumentParser, Swift Numerics và Swift System.

Hôm nay, chúng tôi vui mừng giới thiệu hai bổ sung mới lớn cho gia đình: Thuật toán Swift và Bộ sưu tập Swift!

Swift Algorithms là một gói mã nguồn mở gồm các thuật toán trình tự và bộ sưu tập giúp tăng cường thư viện tiêu chuẩn Swift.

Một trong những tính năng mạnh mẽ nhất của Swift là phân loại phong phú của các thuật toán được tích hợp sẵn.

Phải mất một chút đầu tư để học từ vựng, nhưng một khi bạn làm vậy, có thể rất ấn tượng khi khám phá ra có bao nhiêu thuật toán đang ẩn trong tầm nhìn rõ ràng và bạn có thể cải thiện chất lượng mã của mình đến mức nào bằng cách áp dụng chúng.

Để hiểu ý tôi, chúng ta hãy xem một số mã từ ứng dụng nhắn tin mà tôi đang làm việc.

Hãy xem xét vòng lặp này lặp lại trên các đường dẫn chỉ mục cho các hàng đã chọn trong chế độ xem bảng, thu thập tất cả các thông báo tương ứng để chuyển tiếp hoặc xóa.

Đây chỉ là một bản đồ.

Sử dụng bản đồ làm cho mã này rõ ràng hơn cho người đọc vì nó cung cấp thêm ngữ cảnh rằng phần thân của phần đóng, bất kể độ dài hay độ phức tạp của nó, chỉ đang chuyển đổi đầu vào.

Sử dụng bản đồ cũng làm cho mã này nhanh hơn vì nó tránh phân bổ trung gian do thay đổi kích thước mảng bằng cách đặt trước dung lượng - điều mà vòng lặp thô của chúng tôi không bận tâm làm.

Hoặc xem xét vòng lặp này, nếu người dùng nhấn vào một hình ảnh, lặp lại các tin nhắn trong bảng điểm, thu thập tất cả các tệp đính kèm để hiển thị bằng Quick Look.

Đây chỉ là một bản đồ và một bộ lọc!

Trên thực tế, mô hình lọc ra nils và ánh xạ để mở gói các tùy chọn phổ biến đến mức chúng tôi có một tên và thuật toán đặc biệt cho nó: compactMap.

Tiếp theo, hãy xem xét mã này.

Tôi có một mảng tin nhắn, và tôi muốn chuyển đổi nó thành một mảng các mục bảng điểm.

Điều khó khăn là bất kỳ tin nhắn nhất định nào cũng có thể tương ứng với nhiều mục trong bảng điểm trò chuyện.

Sử dụng bản đồ ở đây tạo ra một mảng.

Nhưng đó không phải là điều tôi muốn; Tôi chỉ muốn một mảng phẳng.

Điều này có nghĩa là tôi phải quay lại sử dụng vòng lặp thô?

Tất nhiên là không; chúng tôi có một thuật toán khác cho điều đó.

Nó được gọi là "đã tham gia".

Những gì nó làm là kết hợp tất cả các mảng bên trong lại với nhau thành một tập hợp các phần tử phẳng, duy nhất.

Mô hình lập bản đồ và nối này phổ biến đến mức chúng tôi xác định một loại bản đồ đặc biệt khác cho nó: flatMap.

Tất nhiên, bản đồ và bộ lọc chỉ là phần nổi của tảng băng trôi.

Hãy xem xét vòng lặp thô này từ màn hình chi tiết trò chuyện trong ứng dụng của tôi.

Tôi muốn hiển thị sáu bức ảnh cuối cùng trong một cuộc trò chuyện, từ mới nhất đến cũ nhất.

Vì vậy, tôi lặp lại bảng điểm ngược lại - từ mới nhất đến cũ nhất - và nếu mục đó là ảnh, tôi thêm nó vào mảng.

Và một khi tôi có sáu, tôi dừng lại.

Chúng ta có thể diễn đạt điều này ngắn gọn hơn bằng cách xâu chuỗi các thuật toán lại với nhau từ thư viện tiêu chuẩn - đảo ngược, compactMap và tiền tố - để lấy không quá sáu cái đầu tiên.

Chuỗi các thuật toán lại với nhau cũng giúp chúng ta linh hoạt hơn để thể hiện mã này rõ ràng hơn.

Ví dụ, tôi thấy tự nhiên hơn khi nghĩ về thao tác này dưới dạng hậu tố của bảng điểm hơn là tiền tố của bảng điểm đảo ngược.

Vì vậy, chuỗi thuật toán rõ ràng và súc tích hơn vòng lặp thô, nhưng hiệu suất so sánh như thế nào?

Nếu mỗi bước trong chuỗi phân bổ một mảng trung gian, không phải nó sẽ chậm hơn vòng lặp thô sao?

Câu trả lời sẽ là có nếu thư viện tiêu chuẩn không chơi một số thủ thuật thông minh ở đây.

Hãy quay lại thuật toán đã tham gia mà chúng ta đã thấy trước đó để xem xét kỹ hơn những gì đang diễn ra.

Hóa ra tham gia không thực sự phân bổ và trả về một mảng mới ở đây.

Thay vào đó, nó trả về một FlattenSequence.

FlattenSequence là cái mà chúng ta gọi là "bộ chuyển đổi lười biếng".

Đối với hầu hết các mục đích, nó hoạt động giống như một mảng, nhưng nó chỉ là một trình bao bọc mỏng, vì vậy nó có hiệu quả miễn phí để tạo.

Và nó lười biếng, vì vậy nó xử lý các yếu tố của nó theo yêu cầu, thay vì làm tất cả công việc trước.

Các bộ điều hợp lười biếng như FlattenSequence là những gì cho phép các chuỗi thuật toán có hiệu suất cạnh tranh với các vòng lặp thô.

Hãy quay lại màn hình chi tiết và xem xét kỹ hơn thuật toán của chúng tôi để tính toán sáu bức ảnh cuối cùng trong một cuộc trò chuyện.

Chúng tôi thấy rằng hậu tố thực sự chỉ trả về một lát mảng - thật thông minh - và sự đảo ngược đó cũng được triển khai như một bộ điều hợp lười biếng, một bộ chuyển đổi can thiệp để bắt đầu ở cuối và kết thúc khi bắt đầu.

Còn compactMap thì sao?

Nó vẫn đang trả về một mảng. Điều đó có thể lười biếng không?

Nó có thể.

Bạn chỉ cần thêm một .lazy vào đầu chuỗi, và nó làm cho bất kỳ thuật toán nào đóng cửa, như bản đồ và bộ lọc, lười biếng!

Chuỗi thuật toán lười biếng rất phù hợp với các trường hợp sử dụng như thế này, nơi bạn chỉ xử lý một số lượng nhỏ các yếu tố từ một bộ sưu tập có khả năng rất lớn.

Tất nhiên, đôi khi bạn cần hoặc muốn có một mảng.

Và trong trường hợp đó, bạn luôn có thể bọc chuỗi thuật toán của mình trong trình khởi tạo mảng.

Đây là một lý do nữa tại sao, trong nhóm Thư viện Tiêu chuẩn, chúng tôi là một fan hâm mộ lớn của các thuật toán lười biếng.

Thật dễ dàng để biến một thuật toán lười biếng thành một kết quả háo hức, nhưng không thể đi theo hướng khác.

Vì vậy, tôi đã đạt được tiến bộ lớn trên ứng dụng nhắn tin của mình và nhà thiết kế của tôi tiếp cận tôi với một yêu cầu tính năng.

Họ muốn bao gồm dấu thời gian trong bảng điểm, nếu hơn một giờ trôi qua giữa hai tin nhắn liên tiếp.

Có vẻ hợp lý.

Phải có một thuật toán khác mà tôi có thể sử dụng cho việc này, phải không?

Có. Nhưng để truy cập nó, tôi sẽ cần nhập gói Swift Algorithms.

Thỉnh thoảng, bạn sẽ gặp phải những trường hợp sử dụng như thế này mà thư viện tiêu chuẩn Swift chưa có phạm vi bảo hiểm.

Mục đích của gói Thuật toán là cung cấp một địa điểm ma sát thấp cho chúng tôi - với sự giúp đỡ của bạn - để ươm tạo các họ thuật toán bị thiếu mới để cuối cùng đưa vào thư viện tiêu chuẩn.

Chúng tôi đã thêm hơn 40 thuật toán vào Swift Algorithms.

Đối với những thứ như tạo ra tất cả các kết hợp hoặc hoán vị của một tập hợp các phần tử; hoặc lặp lại các phần tử của một chuỗi bằng hai hoặc ba hoặc trong các nhóm được xác định bởi một vị ngữ; hoặc chọn năm phần tử nhỏ nhất trong một bộ sưu tập, năm phần tử lớn nhất hoặc chỉ năm bất kỳ ngẫu nhiên.

Chúng ta hãy xem xét kỹ hơn một số công cụ lặp lại mạnh mẽ đi kèm với Thuật toán Swift.

windows(ofCount:) cung cấp một cửa sổ trượt, ở đây có kích thước 3, vào các yếu tố của một bộ sưu tập.

Đối với mỗi vòng lặp, cửa sổ chỉ là một chuỗi con của bộ sưu tập cơ sở - đây là ArraySlice - tránh bất kỳ sự phân bổ trung gian nào.

windows(ofCount: 2) đặc biệt phổ biến và vì vậy chúng tôi có một sự tiện lợi cho nó.

Nó được gọi là "cặp liền kề".

Các cặp liền kề chứa một bộ thay vì một dãy con, cho phép truy cập phần tử thuận tiện hơn.

Một công cụ lặp lại mạnh mẽ khác là chunks(ofCount:).

Không giống như các cửa sổ, các khối không chồng lên nhau.

Nếu một bộ sưu tập không chia hết cho số lượng đoạn, đoạn cuối cùng trong chuỗi sẽ chứa phần còn lại.

Và cũng giống như các cửa sổ, các khối là chuỗi con của bộ sưu tập cơ sở, vì vậy chúng rất rẻ để tạo ra.

Đôi khi bạn muốn chia nhỏ một bộ sưu tập thành các yếu tố tương tự.

Ở đây chúng tôi đang chia nhỏ isPrime.

Điều này có nghĩa là chúng ta sẽ lặp lại các phần tử liên tiếp trả về cùng một giá trị cho isPrime.

Để thuận tiện, chunked(on:) định vị một bộ của cả chunk và giá trị được chunk trên.

Bạn đã bao giờ thấy mình viết một vòng lặp thô như thế này mà chỉ hoạt động nếu các yếu tố trước đó và hiện tại khác nhau chưa?

Cái này chỉ là chunked!

Bây giờ chúng ta hãy quay lại yêu cầu tính năng đó từ nhà thiết kế của tôi để bao gồm dấu thời gian trong bảng điểm bất cứ khi nào hơn một giờ trôi qua giữa các tin nhắn.

Nếu bạn nhớ lại, chúng tôi tạo bảng điểm bằng cách ánh xạ phẳng trên các tin nhắn để tạo các mục bảng điểm.

Chà, mọi mục bảng điểm đều có quyền truy cập vào ngày của nó.

Chúng ta có thể chia nhỏ ngày để nhóm các mục bảng điểm lại với nhau nếu ít hơn một giờ trôi qua giữa chúng.

Chúng tôi đã thấy cách chia nhỏ một bộ sưu tập thành các phần tử tương tự.

Các thuật toán Swift đi kèm với một biến thể khác của chunked cho phép bạn cung cấp một vị ngữ tùy chỉnh.

Nó chuyển cho bạn các cặp phần tử liền kề và bạn trả về true nếu chúng thuộc cùng một nhóm.

Ở đây, chúng tôi trả về true nếu khoảng thời gian giữa các mục bảng điểm nhỏ hơn một giờ.

Tiếp theo, chúng ta cần tạo dấu thời gian và kết hợp mọi thứ lại với nhau thành một bộ sưu tập phẳng duy nhất.

Trước đó, chúng tôi đã từng tham gia để làm phẳng một bộ sưu tập lồng nhau.

Thư viện tiêu chuẩn đi kèm với một biến thể khác của tham gia có thể chèn dấu phân cách.

Nó thực sự phổ biến khi sử dụng thuật toán này để nối các chuỗi với nhau với nhau, giả sử, một dòng mới hoặc một dấu phân cách dấu phẩy.

Tuy nhiên, trong trường hợp này, một dấu phân cách không đổi là không đủ.

Chúng tôi cần quyền truy cập vào ngày đầu tiên trong đoạn tiếp theo để xây dựng dấu thời gian.

Chà, gói Thuật toán bao gồm một biến thể khác của tham gia cho phép bạn tính toán dấu phân cách từ các đoạn trước và tiếp theo.

Chúng ta có thể sử dụng nó ở đây để nối lại với nhau các đoạn của các mục bảng điểm, hiện được phân tách bằng dấu thời gian.

Khá thỏa mãn, phải không?

Tất nhiên, chúng tôi không cần phải trả tiền cho bất kỳ phân bổ trung gian nào trong số này.

Tất cả những điều này có thể được tính toán theo yêu cầu chỉ bằng cách thêm một .lazy.

Voilà!

Tuy nhiên, tôi muốn cảnh báo rằng sự lười biếng không phải là một viên đạn bạc.

Khi bạn chỉ lặp lại một chuỗi một lần duy nhất, tính toán theo yêu cầu có thể tiết kiệm công việc và tránh phân bổ.

Nhưng khi bạn lặp đi lặp lại một chuỗi - giống như tôi với bảng điểm trong ứng dụng nhắn tin của mình - máy tính theo yêu cầu sẽ lặp đi lặp lại cùng một công việc - lập bản đồ, phân đoạn và tham gia mỗi khi người dùng vào chế độ chỉnh sửa, nhấn vào hình ảnh hoặc truy cập màn hình chi tiết.

Trong những trường hợp như thế này, bạn vẫn nên sử dụng một chuỗi thuật toán lười biếng.

Chỉ là bước cuối cùng, sẽ hiệu quả hơn nếu bạn lưu công việc của mình bằng cách thu thập mọi thứ lại với nhau thành một mảng.

Chúng tôi đã xem xét hơn một chục thuật toán khác nhau từ thư viện tiêu chuẩn Swift và gói Thuật toán.

Tất cả chúng không chỉ hoạt động trên mảng, mà còn cả chuỗi và mọi loại Swift khác phù hợp với các giao thức trình tự và bộ sưu tập - bao gồm mọi cấu trúc dữ liệu trong gói Bộ sưu tập Swift mới.

Chuỗi các thuật toán với nhau làm cho mã của bạn rõ ràng hơn, nhanh hơn và chính xác hơn.

Và trở nên thành thạo nó không phức tạp; nó chỉ là xây dựng vốn từ vựng của bạn.

Vì vậy, lần tới khi bạn thấy mình đọc hoặc viết một vòng lặp thô, hãy dừng lại và suy nghĩ xem đó là bản đồ, bộ lọc hay một trong những thuật toán khác mà bạn vừa thấy.

Nếu không có gì xuất hiện trong đầu, hãy tìm kiếm tài liệu về các giao thức trình tự và bộ sưu tập, hoặc đọc các hướng dẫn trong kho lưu trữ GitHub của Swift Algorithms hoặc ghé thăm chúng tôi trên các diễn đàn Swift, nơi chúng tôi có thể cùng nhau tìm ra nó.

Ai biết được, nó có thể là nguồn cảm hứng cho một bổ sung mới cho gói Thuật toán!

Tiếp theo, Karoy sẽ dạy bạn về các cấu trúc dữ liệu linh hoạt đi kèm với gói Swift Collections mới.

Karoy?

Karoy Lorentey: Cảm ơn, Kyle!

Hãy nói về cấu trúc dữ liệu.

Như hiện nay, thư viện tiêu chuẩn Swift chỉ triển khai ba cấu trúc dữ liệu có mục đích chung chính: nó cung cấp mảng, bộ không có thứ tự và từ điển không có thứ tự.

Những thứ này đã chứng minh những lựa chọn tuyệt vời như các loại bộ sưu tập phổ quát và chúng đặc biệt tốt cho việc truyền dữ liệu qua các ranh giới mô-đun.

Tất cả chúng đều triển khai ngữ nghĩa giá trị sao chép khi ghi, cung cấp các hoạt động đột biến tại chỗ hiệu quả đồng thời đảm bảo rằng các giá trị bộ sưu tập an toàn để vượt qua mà không có những đột biến này dẫn đến những thay đổi bất ngờ trong bất kỳ bản sao nào được tạo.

Tuy nhiên, có rất nhiều cấu trúc dữ liệu ngoài kia.

Sẽ rất hữu ích nếu có nhiều lựa chọn hơn để lựa chọn.

Đầu năm nay, chúng tôi đã phát hành gói Swift Collections, với việc triển khai cấu trúc dữ liệu mới.

Gói này cho phép các nhà phát triển Swift có được trải nghiệm sản xuất thực tế với các loại bộ sưu tập mới trước khi cuối cùng chúng tôi đề xuất chúng để đưa vào thư viện tiêu chuẩn Swift.

Bằng cách nhập gói Swift Collections, chúng tôi có quyền truy cập vào các loại bổ sung.

Phiên bản ban đầu của gói triển khai ba trong số các cấu trúc dữ liệu được yêu cầu thường xuyên nhất.

Đây là những biến thể mới của ba loại bộ sưu tập tiêu chuẩn.

Chúng tôi có một hàng đợi hai đầu, một OrderedSet, và một OrderedDictionary.

Chúng tương tự như mảng, bộ và từ điển; chúng là các biến thể của cùng một chủ đề, thêm các tính năng mới vào các cấu trúc hiện có.

Điều đó nói rằng, những loại mới này không thay thế cho những loại hiện có; chúng bổ sung cho chúng.

Đối với một số trường hợp sử dụng, các loại mới sẽ phù hợp hơn.

Tuy nhiên, đối với nhiều người khác, các loại hiện có tiếp tục là lựa chọn đúng đắn.

Để biết cấu trúc dữ liệu nào cần tiếp cận, chúng ta cần tìm hiểu xem chúng khác với các loại hiện có như thế nào.

Vì vậy, chúng ta hãy xem xét ngắn gọn từng thứ này, bắt đầu với hàng đợi hai đầu - hay đúng hơn là hàng đợi nói chung.

Hàng đợi bật lên ở khắp mọi nơi cần xử lý từng mặt hàng tùy ý, từ khách hàng xếp hàng chờ trong siêu thị đến các nhiệm vụ không đồng bộ trong ứng dụng.

Ở dạng trừu tượng nhất của chúng, hàng đợi cung cấp hai thao tác chính: chúng ta có thể đẩy các mục ra phía sau hàng đợi và chúng ta có thể bật các phần tử ra khỏi phía trước.

Một hàng đợi hai đầu làm cho các hoạt động hàng đợi này đối xứng.

Nó hỗ trợ đẩy các mặt hàng mới lên đầu hàng đợi một cách hiệu quả...

...Cũng như các yếu tố bật ra khỏi mặt sau.

Cái tên "hàng đợi hai đầu" khá hấp dẫn đối với một loại hữu ích như vậy, vì vậy chúng tôi muốn rút ngắn nó thành "deque".

Và để loại bỏ thêm một âm tiết nữa, điều này theo truyền thống được phát âm là "bộ bài", giống như một bộ bài.

Trong gói Bộ sưu tập, deque có API gần giống với loại mảng quen thuộc và nó triển khai nhiều giao thức giống nhau.

Ví dụ, chúng ta có thể sử dụng một mảng theo nghĩa đen để tạo một deque.

Deque phù hợp với giao thức RandomAccessCollection.

Giống như mảng, deque sử dụng các chỉ số nguyên được đo lệch từ đầu bộ sưu tập.

Điều này giúp dễ dàng truy cập bất kỳ yếu tố nào dựa trên vị trí của nó.

Ví dụ, phần tử ở chỉ mục 1 trong deque này là chữ E.

Bây giờ, tôi chắc chắn rằng tôi không phải là người duy nhất bị làm phiền bởi chữ thường f ở cuối bộ sưu tập này.

May mắn thay, deque phù hợp với giao thức MutableCollection, vì vậy chúng tôi có thể khắc phục điều này bằng cách gán thông qua chỉ mục 2, thay thế chữ thường f bằng chữ hoa.

À, trông đẹp hơn rất nhiều!

Deque cũng triển khai giao thức RangeReplaceableCollection, vì vậy nó cung cấp tất cả các thao tác quen thuộc để chèn, xóa hoặc thay thế các dải con của các phần tử.

Ví dụ, chúng ta có thể chèn một chuỗi ở phía trước deque của mình bằng cách gọi phương thức insert(contentsOf:) với chỉ mục bằng 0.

Cách nó thực thi điều này là nơi deque bắt đầu khác với một mảng.

Nếu chúng ta sử dụng một mảng để lưu trữ các mặt hàng của mình, thì việc chèn các phần tử mới ở phía trước sẽ cần phải bắt đầu bằng cách di chuyển các phần tử hiện có để nhường chỗ cho các phần tử mới.

Để làm cho việc truy cập trở nên đơn giản nhất có thể, các mảng giữ các phần tử của chúng trong một bộ đệm liền kề duy nhất, bắt đầu từ đầu lưu trữ của chúng.

Nếu mảng lớn, điều này làm cho việc chuẩn bị các phần tử mới tương đối tốn kém; vì vậy việc chèn một phần tử mới ở phía trước mất thời gian tỷ lệ thuận với số lượng phần tử đã có trong mảng.

Một deque hoạt động khác nhau.

Nó bọc bộ đệm lưu trữ của nó xung quanh ranh giới của nó để nó có thể thêm các yếu tố mới mà không cần di chuyển bất kỳ yếu tố nào hiện có.

Các chỉ số vẫn được bù đắp từ phần bắt đầu hợp lý của bộ sưu tập, vì vậy sau khi chèn, phần tử ở chỉ mục 1 bây giờ là B.

Điều này có nghĩa là deques cần thực hiện một số công việc để dịch giữa các chỉ số logic và vị trí lưu trữ thực tế của chúng, nhưng việc truy cập các yếu tố vẫn khá hiệu quả.

Và bởi vì việc chuẩn bị cho một deque không liên quan đến việc trượt bất kỳ thành viên hiện có nào, họ có thể thực hiện thao tác này nhanh hơn hoàn toàn so với mảng.

Việc chèn một phần tử mới ở phía trước mất một khoảng thời gian không đổi, bất kể có bao nhiêu phần tử đã có trong bộ sưu tập.

Đây là sức mạnh của cấu trúc dữ liệu.

Khi chúng ta có chúng trong hộp công cụ của mình, chúng ta có thể sử dụng chúng để giải quyết các vấn đề mà trước đây nằm ngoài tầm với.

Chuyển sang cấu trúc dữ liệu phù hợp có thể tạo ra tất cả sự khác biệt.

Nó có thể biến một ứng dụng chậm không sử dụng được thành một kỳ quan đáp ứng, đó là một niềm vui khi sử dụng.

Tất nhiên, deques cũng có thể thông minh về cách họ thực hiện các hoạt động ở giữa kho lưu trữ của họ.

Ví dụ, khi loại bỏ một loạt các phần tử, deque có tùy chọn thu hẹp khoảng cách kết quả bằng cách di chuyển các phần tử trước đó thay vì các phần tử tiếp theo và điều này có thể làm giảm số lượng phần tử cần được di chuyển.

Đây không phải là một cải tiến mạnh mẽ như việc chuẩn bị trước một phần tử, nhưng khi chúng tôi loại bỏ các phần tử một cách ngẫu nhiên, nó làm cho mọi thứ nhanh gấp đôi trung bình.

Vì vậy, đó là deque.

Bây giờ, chúng ta hãy xem các bộ đã đặt hàng.

Loại bộ tiêu chuẩn, đã có từ trước là một bộ sưu tập đảm bảo rằng tất cả các yếu tố của nó là duy nhất.

Tuy nhiên, nó không giữ nguyên đơn đặt hàng ban đầu của họ.

Trên thực tế, thứ tự của các phần tử trong một tập hợp là ngẫu nhiên một cách hiệu quả.

Điều này có nghĩa là hai trường hợp của cùng một tập hợp thường liệt kê chúng trong hai hoán vị hoàn toàn khác nhau.

Mặc dù vậy, hai tập hợp chứa các yếu tố giống nhau được coi là bằng nhau; thứ tự không quan trọng.

Điều này thật tuyệt vời khi tất cả những gì chúng tôi muốn là đảm bảo tính độc đáo, nhưng đôi khi chúng tôi cũng muốn kiểm soát cách các yếu tố được sắp xếp.

Ví dụ: nếu chúng tôi đang viết một ứng dụng danh sách việc cần làm, chúng tôi có thể muốn đảm bảo rằng nó chỉ liệt kê từng mục một lần, nhưng chúng tôi cũng cần giữ chúng theo thứ tự cụ thể do người dùng đặt ra.

Vì vậy, đó là những gì một bộ được đặt hàng làm.

Tùy thuộc vào quan điểm của chúng tôi, nó hoạt động giống như một mảng giữ cho các phần tử của nó là duy nhất hoặc chúng tôi có thể xem nó như một tập hợp duy trì thứ tự mà chúng tôi thiết lập trên các thành viên của nó.

Giống như các mảng và tập hợp, các tập hợp có thứ tự cũng có thể được thể hiện bằng các ký tự mảng.

Tuy nhiên, không giống như một tập hợp, thứ tự của các phần tử được đảm bảo tồn.

Thứ tự cũng rất quan trọng; hai bộ có thứ tự so sánh bằng nhau nếu chúng không chỉ chứa cùng một thành viên, mà chúng cũng phải theo cùng một thứ tự.

Nếu chúng ta chỉ cần biết liệu hai bộ có thứ tự có chứa các phần tử giống nhau hay không, theo bất kỳ thứ tự nào, thì chúng ta có thể so sánh chúng thông qua chế độ xem không có thứ tự đặc biệt.

Chế độ xem nhẹ này bỏ qua thứ tự phần tử, vì vậy nó cung cấp một giao diện giống như bộ, thông thường hơn.

Tuy nhiên, theo mặc định, các tập hợp có thứ tự giống với cách các mảng hoạt động.

Điều này được củng cố bởi thực tế là các tập hợp có thứ tự là các bộ sưu tập truy cập ngẫu nhiên với các chỉ số bù số nguyên.

Chúng ta có thể sử dụng chỉ số con số nguyên để truy cập các mục, giống như trong một mảng hoặc một deque.

Như mong đợi từ một tập hợp, chúng ta cũng có thể thêm và xóa các yếu tố, mặc dù các hoạt động này cần phải tính đến vị trí.

Ví dụ, chúng tôi có một thao tác nối thêm thêm một phần tử mới vào cuối tập hợp nếu nó chưa phải là thành viên.

Giá trị trả về của nó cho biết liệu phần tử có cần được thêm vào hay không và nó cũng báo cáo chỉ mục của mục.

Chúng tôi cũng có một thao tác chèn đặt phần tử mới tại vị trí được chỉ định.

Trong trường hợp này, chữ B đã tồn tại, vì vậy thao tác chỉ đơn giản trả về chỉ mục của thành viên hiện tại.

Loại bỏ một phần tử để lại một lỗ hổng trong tập hợp được sắp xếp và các thành viên còn lại cần được di chuyển để lấp đầy nó, giống như trong một mảng.

Các bộ được đặt hàng cần giữ cho các yếu tố của chúng độc đáo, vì vậy chúng không thể hỗ trợ thay thế mặt hàng tùy ý.

Điều này có nghĩa là không giống như các mảng, chúng không thể phù hợp với các giao thức MutableCollection hoặc RangeReplaceableCollection.

Tuy nhiên, chúng hỗ trợ các hoạt động sắp xếp lại tiêu chuẩn như phân loại hoặc xáo trộn.

Các bộ có thứ tự cũng thực hiện tất cả các hoạt động tập hợp cấp cao từ giao thức SetAlgebra, theo cách bảo toàn thứ tự.

Ví dụ, hình thành một liên minh nối thêm bất kỳ phần tử còn thiếu nào, theo thứ tự chúng xuất hiện trong tập thứ hai.

Trừ đi một tập hợp giữ các phần tử còn lại theo thứ tự ban đầu của chúng.

Mặc dù các bộ có thứ tự thực hiện hầu hết các hoạt động SetAlgebra, chúng không thể chính thức phù hợp với giao thức đó vì nó yêu cầu thứ tự của các phần tử không được quan trọng.

Tuy nhiên, quan điểm không có trật tự của họ có một khái niệm không nhạy cảm với trật tự về sự bình đẳng.

Vì vậy, nó có thể và thực sự phù hợp với SetAlgebra.

Chúng ta có thể sử dụng nó để chuyển các giá trị OrderedSet cho bất kỳ hàm nào yêu cầu giá trị SetAlgebra.

Nhìn dưới mui xe, loại tập hợp tiêu chuẩn, không có thứ tự lưu trữ các phần tử của nó trực tiếp trong bảng băm phẳng bằng cách sử dụng hàm băm phổ quát được gieo hạt ngẫu nhiên.

Điều này cung cấp hiệu suất tra cứu tuyệt vời cho các phần tử, nhưng nó loại bỏ thứ tự ban đầu của chúng.

Để hỗ trợ các thứ tự phần tử tùy ý, do người dùng chỉ định, thay vào đó, một tập hợp có thứ tự lưu trữ các phần tử của nó trong một phiên bản mảng thông thường.

Bộ được sắp xếp vẫn sử dụng cùng một triển khai bảng băm nhanh và an toàn, nhưng trong trường hợp này, bảng chỉ cần lưu trữ các chỉ số nguyên vào mảng lưu trữ.

Phạm vi của các số nguyên này bị ràng buộc bởi kích thước của bảng băm, vì vậy chúng ta có thể nén bảng bằng cách đóng gói các giá trị số nguyên thành càng ít bit càng tốt.

Điều này đôi khi có thể tiết kiệm một lượng bộ nhớ đáng kể so với một bộ thông thường trong khi vẫn duy trì hiệu suất cạnh tranh cho hầu hết các hoạt động.

Hiệu suất tra cứu có thể so sánh với bộ tiêu chuẩn.

Việc tìm kiếm một thành viên ngẫu nhiên mất khoảng thời gian gần như không đổi, bất kể kích thước của bộ sưu tập.

Mảng cần phải xem xét từng yếu tố một cách tốn nhiều công sức, điều này mất nhiều thời gian hơn khi bộ sưu tập phát triển.

Thêm một phần tử mới vào một tập hợp được sắp xếp cũng thực hiện gần như tương đương với việc chèn một phần tử vào một tập hợp tiêu chuẩn.

Điều này vẫn cần băm mục mới và nó cũng bao gồm kiểm tra xem phần tử đã tồn tại chưa, vì vậy đây là một thao tác phức tạp hơn nhiều so với việc trực tiếp thêm một phần tử vào một mảng đơn giản.

Nhưng những thứ này vẫn mất thời gian không đổi, bất kể các bộ sưu tập trở nên lớn đến mức nào.

Tuy nhiên, trong khi OrderedSet có thể nhanh chóng tra cứu các phần tử hiện có và thêm các phần tử mới, nó không thể thực hiện hiệu quả việc xóa hoặc chèn một mục ở mặt trước hoặc giữa bộ.

Giống như mảng, các hoạt động này cần trượt các phần tử xung quanh trong mảng lưu trữ, nhưng chúng cũng cần đánh số lại các chỉ số tiếp theo trong bảng băm.

Điều này có nghĩa là việc loại bỏ và chèn biến thành các hoạt động với độ phức tạp tuyến tính, làm cho chúng chậm hơn so với tập hợp thông thường.

Luôn luôn có một sự đánh đổi!

Nhưng một khi chúng ta làm quen với cách các cấu trúc dữ liệu này hoạt động, chúng ta sẽ có thể tự tin chọn đúng để giải quyết bất kỳ vấn đề nào, dựa trên các yêu cầu chúng ta cần đáp ứng và các hoạt động quan trọng cần tối ưu hóa.

Chọn cấu trúc dữ liệu phù hợp có thể dẫn đến cải tiến thuật toán có thể dẫn đến mã nhanh hơn hàng trăm hoặc thậm chí hàng nghìn lần.

Chọn sai có thể làm ngược lại.

Vì vậy, tôi nghĩ rằng thật hữu ích khi tìm hiểu về những điều này bởi vì, cuối cùng, nó mang lại những ứng dụng tuyệt vời và những người dùng hài lòng.

Loại OrderedSet mới này là một biến thể Swift thuần túy của loại NSOrderedSet hiện có trong Foundation.

Tuy nhiên, vì OrderedSet được triển khai trong một gói, nó không kết nối với NSOrderedSet.

Điều này có nghĩa là các API Objective-C hiện tại sẽ không được nhập tự động để sử dụng loại mới.

Đây là những thứ riêng biệt.

Cấu trúc dữ liệu thứ ba được cung cấp bởi gói Bộ sưu tập là một cấu trúc tương tự có thứ tự của loại từ điển tiêu chuẩn.

Giống như từ điển tiêu chuẩn, đây là một chuỗi các cặp khóa-giá trị cho phép chúng tôi sử dụng khóa làm chỉ số con để nhanh chóng tra cứu giá trị tương ứng của nó.

Không giống như từ điển thông thường, thứ tự của các cặp khóa-giá trị được xác định rõ ràng.

Theo mặc định, nó tuân theo thứ tự mà các phím ban đầu được chèn vào.

Để thêm một phần tử mới, chúng ta có thể gán một giá trị cho một khóa mới.

Chúng ta có thể loại bỏ các phần tử bằng cách gán nil cho một khóa hiện có.

Trong suốt các hoạt động này, từ điển được sắp xếp duy trì nội dung của nó theo thứ tự được xác định rõ ràng.

Từ điển có thứ tự sử dụng các chỉ số nguyên giống như mảng, nhưng điều này giới thiệu một vấn đề thú vị.

Trong từ điển ví dụ của chúng tôi, thao tác chỉ số con lập chỉ mục xung đột với chỉ số con chính.

Khi chúng ta đăng ký bằng số không, chúng ta có nghĩa là truy cập giá trị cho khóa 0 hay chúng ta có nghĩa là truy xuất cặp khóa-giá trị ở độ lệch 0?

Chúng tôi nghĩ rằng chỉ số con dựa trên khóa là thao tác chính cho một loại từ điển, vì vậy để ngăn chặn sự mơ hồ này, đăng ký một từ điển có thứ tự luôn có nghĩa là chỉ số con khóa.

OrderedDictionary hoàn toàn không cung cấp hoạt động chỉ số lập chỉ mục.

Điều này có nghĩa là OrderedDictionary không thể là một bộ sưu tập, bởi vì giao thức bộ sưu tập yêu cầu một chỉ số con như vậy.

Do đó, OrderedDictionary chỉ phù hợp với giao thức trình tự.

Tuy nhiên, đối với các trường hợp mong muốn sự phù hợp của bộ sưu tập, OrderedDictionary cung cấp chế độ xem các yếu tố đặc biệt.

Elements là một bộ sưu tập truy cập ngẫu nhiên cung cấp chỉ số con lập chỉ mục trả về một cặp khóa-giá trị.

Nhìn vào việc triển khai cơ bản, trong khi loại từ điển thông thường sử dụng hai bảng băm riêng biệt để lưu trữ các khóa và giá trị tương ứng, một từ điển có thứ tự sử dụng một bảng băm nén duy nhất và hai mảng song song thay thế.

Điều này có thể tiết kiệm nhiều dung lượng hơn các bộ đã đặt hàng.

Vì vậy, đây là ba cấu trúc dữ liệu mới có sẵn trong gói Bộ sưu tập.

Bằng cách sử dụng các cấu trúc này, chúng tôi có thể tăng hiệu suất của các ứng dụng của mình hoặc giảm việc sử dụng bộ nhớ hoặc - cũng quan trọng không kém - chúng tôi có thể hiện các ràng buộc mà chúng tôi không thể dễ dàng đáp ứng với các loại tiêu chuẩn, chẳng hạn như duy trì thứ tự phần tử trong một tập hợp.

Bởi vì tất cả các loại mới này đều phù hợp với một số giao thức trình tự và bộ sưu tập, chúng cũng tương tác với các thuật toán được cung cấp bởi thư viện tiêu chuẩn cũng như gói Thuật toán mới mà Kyle đã chỉ cho chúng ta trước đó.

Bộ sưu tập Swift và Thuật toán Swift chỉ là hai trong số các thành viên mới trong danh sách các gói mã nguồn mở đang phát triển của chúng tôi.

Tương lai của hệ sinh thái thư viện Swift đang được định hình ngay bây giờ, khi chúng tôi đẩy mạnh các nền tảng mới và vào các miền mới.

Và điều này đang được thực hiện trong tầm nhìn rõ ràng khi chúng tôi ngày càng tận dụng các gói mã nguồn mở.

Chúng tôi đang cố tình phát hành các gói này sớm, trong khi chúng vẫn mềm dẻo và chúng tôi đang phát triển chúng như những nỗ lực cộng đồng trên GitHub.

Vì vậy hãy thử chúng.

Nộp một vấn đề. Mở một yêu cầu kéo.

Đây chưa bao giờ là thời điểm tốt hơn, và việc tham gia và tạo ra tác động chưa bao giờ dễ dàng hơn thế.

Tôi hy vọng bạn cũng hào hứng với những gói Swift mới này như chúng tôi.

Chúng tôi nóng lòng muốn xem bạn xây dựng những gì với những thứ này!

Cảm ơn bạn đã xem, và tận hưởng phần còn lại của hội nghị!

♪