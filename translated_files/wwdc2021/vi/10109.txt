10109

Xin chào, tên tôi là Tony, và tôi là một kỹ sư trong nhóm Foundation.

Chào mừng đến với "Có gì mới trong Foundation." Khung nền tảng cung cấp chức năng cơ bản cho tất cả các ứng dụng và khuôn khổ.

Nó có rất nhiều tính năng, bao gồm mọi thứ từ xử lý tệp đến kết nối mạng và thông báo.

Hôm nay tôi muốn tập trung vào thứ mà tất cả các ứng dụng cần: quốc tế hóa và bản địa hóa.

Trong các bản phát hành năm nay, chúng tôi có một số tiến bộ lớn nhất từ trước đến nay trong API này.

Chúng tôi bắt đầu ở mức thấp, suy nghĩ lại về chuỗi được quy cho là gì trong Swift.

Chúng tôi đã xây dựng lại các trình định dạng của mình cho Swift, giúp chúng nhanh hơn, dễ sử dụng hơn và thêm các tính năng mới.

Và cuối cùng, chúng tôi có một tính năng hoàn toàn mới được gọi là thỏa thuận ngữ pháp tự động.

Nó làm giảm đáng kể số lượng chuỗi bản địa hóa mà bạn cần cung cấp đồng thời làm cho mã của bạn đơn giản hơn.

Hãy nhảy ngay vào các chuỗi được quy kết.

Một chuỗi được gán là sự kết hợp của các ký tự, một tập hợp các phạm vi và một từ điển.

Các chuỗi thuộc tính cho phép bạn liên kết các thuộc tính, là các cặp khóa-giá trị, với một phạm vi cụ thể của một chuỗi.

Các thuộc tính phổ biến nhất được xác định bởi SDK, nhưng bạn cũng có thể tạo thuộc tính của riêng mình.

Bạn sẽ thường tìm thấy các chuỗi được gán trong API hỗ trợ văn bản phong phú.

Hãy xem xét một ví dụ.

Đây là một ứng dụng tôi đang làm việc có tên là Caffé.

Đó là một thực đơn đơn giản.

Tôi chọn thức ăn mà tôi muốn, kích thước, số lượng.

Và cuối cùng, nó cho tôi thấy một biên lai với danh sách mọi thứ tôi đã đặt hàng.

Ở phía dưới đây, tôi quyết định thêm một lời cảm ơn ngắn gọn.

Đây là một chuỗi được quy cho.

Một phần của chuỗi được in đậm và một phần in nghiêng.

Từ cuối cùng cũng có một liên kết.

Như bạn có thể nói ở đây, các thuộc tính có thể trùng lặp.

Kể từ khi bắt đầu Foundation, chúng tôi đã có một loại tham chiếu được gọi là NSAttributedString.

Năm nay, chúng tôi giới thiệu một cấu trúc mới AttributedString, tận dụng tối đa tất cả các tính năng mà Swift cung cấp cho chúng tôi.

Đầu tiên và quan trọng nhất, đó là một loại giá trị.

Nó cũng có hành vi đếm ký tự giống như Swift String.

Là một phần trong cam kết của chúng tôi để giúp dễ dàng viết phần mềm bao gồm, AttributedString hiện có thể bản địa hóa hoàn toàn.

Cuối cùng, nó được xây dựng với sự an toàn và bảo mật trong tâm trí.

Điều này bao gồm cả an toàn thời gian biên dịch bằng cách sử dụng đánh máy mạnh và cũng an toàn trong quá trình hủy lưu trữ bằng Codable.

Hãy cùng tham quan ngắn gọn về những gì bạn có thể làm với AttributedString mới.

Chúng tôi sẽ xây dựng thông điệp cảm ơn của mình.

Đầu tiên, chúng tôi tạo một chuỗi được quy kết bằng cách sử dụng một trình khởi tạo đơn giản.

Tôi muốn đặt một thuộc tính trên toàn bộ chuỗi này.

Điều đó đơn giản như thiết lập thuộc tính phông chữ.

Trong cấu trúc AttributedString, tất cả các thuộc tính đều có sẵn trực tiếp và chúng sử dụng đúng loại.

Ví dụ, thuộc tính này là Phông chữ SwiftUI.

Tiếp theo, chúng tôi tạo ra một chuỗi quy kết khác.

Đây là một tham chiếu đến trang web của chúng tôi, vì vậy chúng tôi đặt thuộc tính liên kết thành một URL.

Ở đây tôi đang thiết lập phông chữ và liên kết trên toàn bộ chuỗi.

Chúng ta sẽ xem xét cách thay đổi chỉ một phần của chuỗi sau.

Một công cụ hữu ích khác là vùng chứa thuộc tính.

Đó là nơi bạn có thể tự giữ các thuộc tính và giá trị mà không cần chuỗi.

Ở đây, tôi tạo một vùng chứa và đặt một số thuộc tính trên đó, tùy thuộc vào tầm quan trọng của tin nhắn của tôi.

Và cuối cùng, tôi hợp nhất các thuộc tính đó thành cả hai chuỗi được gán.

Như tôi đã đề cập, chuỗi quy kết là sự kết hợp của các ký tự, phạm vi và từ điển.

Bản thân chuỗi được quy cho không phải là tập hợp của bất kỳ thứ gì trong số đó.

Thay vào đó, để có quyền truy cập vào các thuộc tính này, nó có cái mà chúng ta gọi là chế độ xem.

Hai chế độ xem quan trọng nhất là các ký tự, cung cấp quyền truy cập vào chuỗi và chạy, cung cấp quyền truy cập vào các thuộc tính.

Những chế độ xem này là bộ sưu tập Swift, có nghĩa là các chức năng bạn quen thuộc từ các loại như Mảng cũng có sẵn ở đây.

Hãy xem xét một ví dụ khác.

Giả sử các nhà thiết kế của chúng tôi đã yêu cầu chúng tôi thêm một chút thú vị vào thông điệp cảm ơn của chúng tôi bằng cách làm cho tất cả các dấu câu trở thành một màu cam vui nhộn.

Để làm điều này, trước tiên tôi cần tìm dấu câu ở đâu trong chuỗi được gán.

Giống như các bộ sưu tập Swift khác, các chế độ xem chuỗi được quy kết sử dụng các chỉ mục, chỉ đơn giản là một vị trí cho một số phần tử trong bộ sưu tập.

Để lặp lại theo chỉ mục, tôi sử dụng hàm chỉ mục thư viện tiêu chuẩn.

Tiếp theo, tôi sử dụng hàm isPunctuation để kiểm tra xem ký tự này có phải là ký tự mà chúng ta cần thay đổi hay không.

Cuối cùng, tôi sử dụng một tính năng khác của chuỗi được quy kết, cắt lát, để áp dụng một thuộc tính chỉ cho một phạm vi con của toàn bộ chuỗi.

Phạm vi bắt đầu từ chỉ mục này và tiếp tục cho đến chỉ mục tiếp theo sau đó, vì vậy một ký tự.

Và bây giờ dấu câu là màu cam.

Hãy nhìn vào một góc nhìn khác, chạy.

Chạy là vị trí bắt đầu, độ dài và giá trị của một thuộc tính cụ thể.

Chúng ta có thể bắt đầu bằng cách đếm tất cả các lần chạy trong tin nhắn của mình.

Điều này sẽ lặp lại từng phạm vi giá trị thuộc tính liền kề trong chuỗi.

Có bốn lần chạy trong chuỗi này.

Mỗi lần chạy có một giá trị hoặc nil cho mỗi thuộc tính.

Phạm vi từ các ký tự và lần chạy có thể hoán đổi cho nhau, vì vậy bạn có thể tìm thấy chuỗi cho một thuộc tính hoặc ngược lại.

Ở đây tôi sử dụng phạm vi của thuộc tính trong chỉ số con để xem các ký tự, chuyển đổi kết quả thành một chuỗi độc lập.

Nó thường hữu ích nhất khi xem xét các lần chạy bằng cách tập trung vào một thuộc tính cụ thể.

Ở đây, chúng tôi sử dụng liên kết đường dẫn chính để kết hợp chỉ cho thuộc tính liên kết.

Mỗi phần tử của bộ sưu tập kết quả sẽ cung cấp cho chúng ta giá trị của thuộc tính liên kết, không tính đến các thuộc tính khác có thể được đặt trong chuỗi.

Nếu chúng ta chỉ nhìn vào các liên kết, chúng ta có ba lần chạy: lần đầu tiên, nơi nó không được đặt; lần thứ hai, nơi nó được đặt thành một giá trị; và lần thứ ba, khoảng thời gian cuối cùng trong câu, nơi nó không được đặt lại.

Lặp lại các lần chạy cho chúng ta một bộ giá trị và phạm vi.

Vì các giá trị là loại an toàn, chúng ta có thể sử dụng API, như lược đồ, tồn tại trên URL, mà không cần truyền hoặc lo lắng về việc nhập sai.

Ở đây tôi đang kiểm tra xem mọi liên kết trong chuỗi được gán có phải là https hay không.

Một kỹ thuật hữu ích khác là tìm kiếm một chuỗi con và sử dụng phạm vi đó để chỉnh sửa các ký tự hoặc thuộc tính.

Giả sử tôi muốn thay thế từ "ghé thăm" bằng thứ gì đó có sự rung cảm trở lại nhiều hơn.

Đầu tiên, tôi tìm phạm vi của một chuỗi con.

Tiếp theo, tôi sử dụng phạm vi đó để đặt các thuộc tính và ký tự chỉ trên phạm vi con đó.

Kết quả là một chuỗi được quy cho với sáu lần chạy, như thế này.

Tiếp theo, hãy nói về bản địa hóa.

AttributedString hoàn toàn có thể định vị được.

Chúng tôi cũng đã thêm hỗ trợ bản địa hóa cho NSAttributedString trong Objective-C.

Các chuỗi thuộc tính được đặt trong các tệp chuỗi ứng dụng của bạn, giống như một chuỗi thông thường.

Trong Swift, giờ đây chúng tôi hỗ trợ định dạng bản địa hóa của Chuỗi và AttributedString bằng cách sử dụng nội suy chuỗi giống như chế độ xem văn bản của SwiftUI.

Đây là một ví dụ đơn giản.

Hàm này trả về một chuỗi được bản địa hóa được tùy chỉnh với tên tài liệu của người dùng.

Thay vì sử dụng các chỉ định định dạng như %@ hoặc %d và gọi một hàm định dạng, bây giờ bạn có thể chuyển trực tiếp giá trị.

Cách tiếp cận tương tự hoạt động cho AttributedString.

Xcode có thể tạo các tệp chuỗi của bạn từ các trình khởi tạo mới này bằng trình biên dịch.

Để bật nó lên, hãy chuyển đến cài đặt xây dựng của bạn, tìm cài đặt bản địa hóa và bật Sử dụng Trình biên dịch để trích xuất chuỗi Swift.

Bạn có thể tự hỏi làm thế nào chuỗi được quy kết được bản địa hóa có được các thuộc tính của nó.

Tôi rất vui được nói với bạn rằng chúng tôi đã thêm hỗ trợ cho Markdown vào AttributedString.

Đây là một ví dụ về việc sử dụng chuỗi được quy kết được bản địa hóa, ngay trong Văn bản SwiftUI.

Tôi bắt đầu chỉ với một sợi dây đơn giản.

Bằng cách thêm hai dấu hoa thị xung quanh văn bản, tôi nhấn mạnh nó, mà SwiftUI hiển thị là in đậm.

Tôi có thể sử dụng dấu gạch dưới để làm cho văn bản được nhấn mạnh, mà SwiftUI hiển thị dưới dạng in nghiêng.

Chúng tôi cũng hỗ trợ các liên kết.

Đây là một cơ hội tuyệt vời để người bản địa hóa cung cấp các URL tùy chỉnh cho các ngôn ngữ khác nhau.

Chúng tôi cũng hỗ trợ các phong cách nội tuyến khác như gạch ngang và giọng nói mã.

Cuối cùng, hãy nói về việc lưu trữ các chuỗi được gán.

Đầu tiên, chúng ta cần khả năng chuyển đổi sang và từ loại tham chiếu NSAttributedString.

Các chuỗi thuộc tính có thể là một phần của mô hình dữ liệu của bạn, có nghĩa là chúng ta cần có khả năng mã hóa và giải mã chúng.

Cuối cùng, chúng tôi muốn có một cách để chỉ định các thuộc tính tùy chỉnh trong Markdown.

Tất cả các hoạt động này đều liên quan đến nhau.

Hãy bắt đầu bằng cách xem xét chuyển đổi.

Tất cả chúng tôi đều đã viết rất nhiều mã sử dụng NSAttributedString, vì vậy chúng tôi đã giúp dễ dàng chuyển đổi từ cấu trúc sang loại lớp.

Đây là một chế độ xem có thuộc tính NSAttributedString.

Để chuyển đổi, chỉ cần chuyển cấu trúc AttributedString của chúng tôi sang trình khởi tạo NSAttributedString.

Đối với các thuộc tính là một phần của SDK, đây là tất cả những gì tôi cần làm.

Bây giờ hãy xem xét mã hóa và giải mã.

Đây là một cấu trúc chứa biên lai từ ứng dụng Caffé của chúng tôi.

Một lần nữa, tôi đang sử dụng các thuộc tính được cung cấp bởi SwiftUI, UIKit, AppKit và Foundation.

Điều đó có nghĩa là việc triển khai Codable mặc định của AttributedString là tất cả những gì tôi cần.

Tôi chỉ cần thêm sự phù hợp của Codable vào Biên lai, và tôi đã hoàn tất.

Hãy đi xa hơn một chút và thêm hỗ trợ để mã hóa một thuộc tính tùy chỉnh.

Chúng ta sẽ bắt đầu bằng cách nói về bản thân thuộc tính.

Một thuộc tính là hai phần: một khóa và một giá trị.

Khóa là một loại phù hợp với giao thức AttributedStringKey mới.

Điều đó xác định loại giá trị mà nó yêu cầu và tên để lưu trữ.

Khóa này cũng có thể phù hợp với các giao thức khác để tùy chỉnh cách giá trị được mã hóa hoặc giải mã.

Giả sử chúng ta muốn xác định một phạm vi của một chuỗi được quy kết để có thêm một số màu sắc.

Hiệu ứng cầu vồng này có ba cấp độ: đơn giản, vui vẻ hoặc cực đoan.

Chúng tôi sẽ sử dụng một enum để biểu diễn giá trị đó và đặt tên thành cầu vồng.

Xác định loại và tên là những yêu cầu duy nhất của giao thức này.

Bây giờ, giả sử chúng tôi muốn tạo thuộc tính này Codable để nó sẽ là một phần của chuỗi được gán được mã hóa.

Tất cả những gì tôi phải làm là thêm sự phù hợp của Codable, như thế này.

Cuối cùng, giả sử chúng ta muốn mức cầu vồng là một phần của chuỗi cục bộ của chúng ta.

Điều đó có nghĩa là nó có thể được áp dụng cho phần bên phải của chuỗi, bất kể nó ở đâu, trong bất kỳ ngôn ngữ nào.

Tất cả những gì chúng ta cần là thêm một sự phù hợp giao thức để chọn tham gia.

Khi chúng ta nói rằng một thuộc tính là Markdown có thể giải mã được, thì chúng ta có thể giải mã nó trực tiếp từ Markdown và chèn nó vào một chuỗi được gán.

Tất cả những gì được yêu cầu là giá trị là Codable.

Tiếp theo, chúng ta hãy xem cú pháp thuộc tính tùy chỉnh cho Markdown.

Trong ví dụ đầu tiên này, chúng tôi có một tham chiếu đến một liên kết.

Nó sử dụng dấu ngoặc vuông cho văn bản liên kết và dấu ngoặc đơn cho đích liên kết, một URL.

Trong ví dụ thứ hai này, chúng ta có một tham chiếu đến một hình ảnh.

Nó bắt đầu bằng một dấu chấm than, sau đó sử dụng dấu ngoặc vuông cho mô tả hình ảnh và dấu ngoặc đơn cho nguồn hình ảnh.

Hai ví dụ đầu tiên này phổ biến trong Markdown.

Ví dụ thứ ba cho thấy cú pháp của chúng tôi cho các thuộc tính tùy chỉnh.

Nó bắt đầu bằng dấu mũ, sau đó sử dụng dấu ngoặc vuông cho văn bản và dấu ngoặc đơn cho các thuộc tính của nó.

Các thuộc tính được thể hiện bằng JSON 5.

JSON 5 tương thích với JSON và cho phép các phím không được trích dẫn, nhận xét và một vài tính năng khác.

Nó phù hợp với một sợi dây thân thiện với con người như thế này.

Chúng tôi cũng đã thêm hỗ trợ JSON 5 vào API JSON khác của chúng tôi trong Foundation.

Bởi vì các thuộc tính tùy chỉnh sử dụng JSON, mọi thứ có thể được giải mã bằng JSONDecoder sẽ tự động tương thích với cú pháp Markdown tùy chỉnh mới.

Ở đây chúng ta có một thuộc tính duy nhất, hai thuộc tính, một chuỗi và một số, và một thuộc tính duy nhất với nhiều thuộc tính.

Chỉ có một phần bổ sung ở đây, đó là cách chúng tôi kết nối những cái tên này trong Markdown với một loại Swift.

Mảnh đó được gọi là phạm vi thuộc tính.

Phạm vi là một nhóm các khóa thuộc tính.

Phạm vi rất hữu ích khi giải mã từ JSON hoặc Markdown, bởi vì chúng cho chúng ta biết thuộc tính nào chúng ta mong đợi tìm thấy, tên của chúng và cách giải mã chúng.

Chúng tôi xác định mỗi phạm vi cho Foundation, UIKit, AppKit và SwiftUI.

Bạn cũng có thể xác định phạm vi thuộc tính của riêng mình.

Hãy xác định phạm vi cho Ứng dụng Caffé của chúng tôi.

Chúng tôi sẽ lồng phạm vi bên trong AttributeScopes và phù hợp với giao thức AttributeScope.

Sau đó, tất cả những gì chúng ta cần làm là liệt kê các thuộc tính bên trong phạm vi của chúng ta với "cho thuê". Cho đến nay, chúng tôi chỉ có thuộc tính cầu vồng của mình.

Tiếp theo, chúng tôi sẽ bao gồm phạm vi SwiftUI bên trong phạm vi của chúng tôi.

Điều đó cho phép tất cả các thuộc tính đó ngoài thuộc tính của chúng ta.

Phạm vi lồng nhau đệ quy, vì vậy điều này cũng bao gồm các thuộc tính Nền tảng.

Thật hữu ích khi xác định một thuộc tính cho phạm vi mới của chúng tôi.

Điều đó cho phép chúng tôi sử dụng cú pháp đường dẫn chính trong các hàm lấy phạm vi làm đối số.

Cuối cùng, bây giờ chúng ta có thể tải chuỗi được quy kết được bản địa hóa và đầy màu sắc của mình từ Markdown tùy chỉnh.

Bạn cũng sẽ tìm thấy các chức năng lấy phạm vi để lưu trữ và chuyển đổi đến và từ NSAttributedString.

Điều này cho phép tùy chỉnh hành vi ở mọi bước.

Đây là màn hình đầu tiên của ứng dụng Caffé một lần nữa, nơi bạn có thể thấy thuộc tính cầu vồng tùy chỉnh của chúng tôi trong tiêu đề.

Sau khi chuỗi được bản địa hóa được chuyển đổi từ Markdown thành chuỗi được gán, ứng dụng sẽ tìm thuộc tính và áp dụng hiệu ứng thú vị cho chỉ phạm vi đó của chuỗi.

Bởi vì thuộc tính đến từ tệp chuỗi được bản địa hóa của chúng tôi, điều này hoạt động chính xác cho tất cả các ngôn ngữ mà Caffé hỗ trợ, như tiếng Tây Ban Nha.

Tuy nhiên, chúng tôi chỉ mới bắt đầu.

Chúng tôi cũng có một Formatter API hoàn toàn mới.

Formatters là một tính năng Foundation lâu năm khác.

Họ chịu trách nhiệm lấy dữ liệu, như số, ngày tháng, giờ và hơn thế nữa và chuyển đổi nó thành một chuỗi được bản địa hóa và có thể trình bày bởi người dùng.

Các trình định dạng được hỗ trợ bởi khá nhiều dữ liệu cấu hình, vì vậy đây là một mẫu phổ biến để lưu trữ và sử dụng lại chúng.

Tuy nhiên, các ứng dụng bao gồm nhiều đoạn mã riêng biệt.

Có thể không phải lúc nào cũng có ý nghĩa khi chia sẻ một trình định dạng giữa tất cả chúng.

Ngoài ra, vì có rất nhiều cách mà mọi người đọc ngày và giờ, cộng với mong muốn của chúng tôi với tư cách là tác giả ứng dụng để trình bày dữ liệu này theo cách phù hợp với thiết kế của chúng tôi, có rất nhiều cơ hội cho các trường hợp cạnh tranh.

Năm nay, chúng tôi đã cải thiện cả hiệu suất và khả năng sử dụng bằng cách xem xét lại API Formatter của chúng tôi từ đầu.

Tóm lại, các API mới của chúng tôi tập trung vào định dạng.

Chúng ta hãy xem mã này từ ứng dụng mẫu Động đất, nơi chúng ta có thể thấy mẫu bộ nhớ đệm đang hoạt động.

Nó có một quy trình gồm hai bước.

Đầu tiên, tạo và cấu hình một bộ định dạng.

Tiếp theo, cung cấp cho người định dạng ngày của chúng tôi và lấy một chuỗi.

Làm thế nào nó có thể đơn giản hơn?

Chà, hãy bắt đầu bằng cách loại bỏ yêu cầu tạo trình định dạng ngày của riêng chúng ta.

Thật dễ dàng để quên rằng điều này cần được lưu vào bộ nhớ cache, điều này sẽ dẫn đến việc tạo lại cùng một trình định dạng cho mọi ô trong bảng.

Tiếp theo, bước định dạng.

Thay vì chuyển ngày của chúng ta qua trình định dạng, hãy sử dụng chính ngày đó.

Bây giờ nó chỉ là một dòng mã.

Bạn chỉ định định dạng bạn muốn, và thế là xong.

Hãy nói nhiều hơn về định dạng số này.

Nó không có nhiều mã, nhưng nó đang che giấu một số phức tạp và có một vài cạm bẫy cần lưu ý.

Nếu đối số không phải là số dấu phẩy động, bạn sẽ nhận được đầu ra hoàn toàn sai ở đây.

Người đọc phải nhận thức được cú pháp trường hợp đặc biệt để định dạng số dấu phẩy động, cùng với một tập hợp các công cụ sửa đổi chỉ là hằng số chuỗi.

Chúng tôi nghĩ rằng mã này dễ hiểu, bảo trì và dễ đọc hơn.

Nó sử dụng các hàm Swift thông thường để xác định chính xác cách chúng tôi muốn số của mình được định dạng.

Bạn cũng nhận được sự tự động hoàn thành và loại an toàn.

Chúng tôi đã áp dụng cách tiếp cận mới này cho tất cả mười người định dạng trong Foundation.

Chúng tôi đã dọn dẹp và đơn giản hóa các giao diện, thực hiện các thay đổi để giúp tránh những cạm bẫy phổ biến và thêm một loạt các tính năng mới trên đường đi.

Chúng ta hãy xem xét chi tiết hai trong số các loại được định dạng phổ biến nhất: ngày tháng và số.

Định dạng ngày là về việc sử dụng lịch và múi giờ để chuyển đổi một thời điểm tuyệt đối thành thứ mà con người hiểu là ngày.

Và thậm chí còn hơn thế nữa, nó tính đến tất cả các sở thích mà con người có về cách họ thích ngày tháng của chính họ trông như thế nào.

Chúng tôi gọi những địa phương ưu tiên đó.

Chúng ta hãy xem một lượng mã nhỏ bạn cần để định dạng một ngày.

Đầu tiên, tôi sẽ có được thời điểm hiện tại bằng cách sử dụng Date.now.

Tiếp theo, tôi gọi hàm được định dạng.

Thế là xong.

Tất nhiên, như chúng ta vừa thấy trong ví dụ của mình, định dạng ngày là thứ có rất nhiều lựa chọn.

Vì vậy, hãy mở rộng điều này ra một chút.

Chức năng được định dạng có thể được cấu hình để chỉ hiển thị ngày hoặc chỉ thời gian.

Cả hai lập luận đó đều có một số lựa chọn để lựa chọn.

Một mục tiêu quan trọng cho API định dạng mới này là cung cấp càng nhiều thời gian biên dịch càng tốt trong việc tạo ra các định dạng chính xác.

Định dạng bằng cách sử dụng các giá trị chuỗi ma thuật nổi tiếng với việc tạo ra những cạm bẫy, trong đó định dạng có vẻ chính xác trong các trường hợp bình thường nhưng tạo ra giá trị hoàn toàn sai trong các trường hợp cạnh, như vào cuối năm.

Đây lại là định dạng mặc định của chúng tôi.

Đây là một phiên bản ngắn của kiểu yêu cầu ngày và giờ, như thế này.

Đối với cả phiên bản không tranh luận và phong cách đơn giản, chúng tôi chọn một định dạng mặc định cho bạn.

Tuy nhiên, nếu bạn thực sự muốn tùy chỉnh ngày, bạn chỉ cần đi từ đây và thêm các trường bạn quan tâm.

Trong ví dụ này, tôi xây dựng một định dạng bằng cách thêm các trường vào kiểu.

Tôi chỉ muốn năm, ngày và tháng.

Các khả năng khác bao gồm giờ, phút, giây, v.v.

Định dạng đầu ra sẽ tự động điều chỉnh theo ngôn ngữ của người dùng.

Những trường này cũng có thể cấu hình được.

Trong trường hợp này, tôi thay đổi tháng sang định dạng rộng, có nghĩa là tên tháng đầy đủ được in.

Định dạng chỉ một phần của ngày cũng dễ dàng với API này.

Ở đây tôi chỉ muốn có được ngày trong tuần.

Ngày tháng cũng có thể được định dạng thành các phong cách khác nhau.

Ở đây tôi chọn sử dụng định dạng ISO 8601 và iso8601, nhưng chỉ với năm, tháng và ngày, và được phân tách bằng dấu gạch ngang.

Với những ví dụ này, mẫu định dạng trở nên rõ ràng.

Chúng tôi bắt đầu với giá trị mà chúng tôi muốn định dạng.

Chúng tôi gọi hàm được định dạng và đối số là kiểu.

Có thể có nhiều hơn một loại phong cách cho mỗi loại.

Ngày, ví dụ, có cả dateTime và iso8601.

Phong cách có thể được sử dụng trong cấu hình mặc định hoặc tùy chỉnh.

API định dạng này hoạt động bằng cách chỉ định một danh sách các trường, một số trong đó có các tùy chọn bổ sung.

Thứ tự của các trường bạn cung cấp không quan trọng.

Mỗi trường chỉ cho người định dạng biết những giá trị nào nên được bao gồm ở đâu đó trong đầu ra cuối cùng.

Chúng tôi chọn một mặc định hợp lý cho các phiên bản ngắn nhất của API, những phiên bản không có đối số hoặc chỉ là tên kiểu.

Khi bạn bắt đầu thêm các trường vào đó, đầu ra sẽ được tùy chỉnh và chỉ phản ánh những gì bạn chọn hiển thị, giống như văn bản giữ chỗ trong giao diện người dùng của bạn.

Ngoài ra còn có một API mới để định dạng hai ngày có liên quan đến nhau.

Đây là một số ví dụ.

Đầu tiên, định dạng hai ngày trong một phạm vi.

Bạn chỉ có thể sử dụng cú pháp dải Swift thông thường với hai ngày.

Phạm vi định dạng cho phép cấu hình hiển thị ngày và giờ, giống như chúng tôi đã làm với một ngày duy nhất.

Bạn có thể định dạng phạm vi này dưới dạng thời lượng hoặc dưới dạng các thành phần hoặc một ngày duy nhất liên quan đến ngay bây giờ.

Một tính năng mới khác trong định dạng là đầu ra được quy cho.

Điều này cho phép bạn tìm vị trí mà trình định dạng đặt một phần cụ thể của giá trị được định dạng sau khi sắp xếp lại xong để phù hợp với sở thích của người dùng.

Tất nhiên, điều này sử dụng cấu trúc mới của chúng tôi AttributedString.

Áp dụng kiểu dáng cho đầu ra được định dạng hiển thị ở tất cả các loại nơi.

Trên watchOS, nhiều biến chứng là các chuỗi được định dạng.

Vì Apple Watch là một thiết bị cá nhân như vậy, điều quan trọng là phải tính đến sở thích của người dùng, nhưng đây cũng là nơi chúng tôi muốn áp dụng một loại ngôn ngữ thiết kế nhất định, chẳng hạn như cho một phần của ngày một màu do người dùng lựa chọn.

Thiết lập điều này thực sự khá thú vị trong SwiftUI.

Hãy cùng nhau xem xét nó trong một bản demo.

Ở đây tôi có điểm khởi đầu cho ứng dụng đồng hành Caffé của mình, ứng dụng này hiển thị khi nào cà phê miễn phí tiếp theo của bạn.

Tôi có chế độ xem SwiftUI chỉ hiển thị ngày được định dạng.

Tôi đã đặt ngôn ngữ trên định dạng để tôi có thể kiểm soát nó bằng bản xem trước SwiftUI của mình tại đây.

Đó là một khởi đầu khá tốt, nhưng tôi muốn tùy chỉnh nó nhiều hơn một chút.

Hãy bắt đầu bằng cách làm cho điều này cụ thể hơn một chút cho ứng dụng của tôi.

Tôi chỉ quan tâm đến phút, giờ và các ngày trong tuần.

Được rồi, trông khá ổn. Bây giờ hãy thêm một chút màu sắc.

Đầu tiên, chúng tôi sẽ thay đổi loại trả về thành AttributedString và yêu cầu đầu ra được quy cho.

Tiếp theo, chúng ta sẽ sử dụng một vùng chứa thuộc tính.

Chúng có thể giữ các thuộc tính mà không cần gắn vào bất kỳ ký tự cụ thể nào trong một chuỗi.

Chúng tôi sẽ tạo một cái cho thuộc tính các ngày trong tuần mà các định dạng ngày đưa vào đầu ra của chúng.

Nó được đặt trên phạm vi của chuỗi chứa các ngày trong tuần.

Tiếp theo, chúng tôi sẽ tạo một vùng chứa cho thuộc tính màu mà chúng tôi muốn đặt.

Và cuối cùng, chúng tôi sẽ sử dụng một hàm chuỗi được gán để thay thế các thuộc tính khớp với các thuộc tính trong vùng chứa đầu tiên bằng các giá trị trong vùng chứa thứ hai trên chuỗi được gán của chúng tôi.

Bởi vì AttributedString là một loại giá trị và thay thế là một hàm đột biến, chúng ta cần thay đổi "let" của mình thành "var". Trông thật tuyệt.

Thậm chí tốt hơn, nó hoạt động cho tất cả các địa phương.

Hãy thêm một vài thứ nữa vào bản xem trước của chúng tôi để kiểm tra lại.

Bạn có thể thấy ở đây rằng các ngày trong tuần có màu cam bất kể nó ở đâu trong ngày được định dạng cho các ngôn ngữ này.

Hãy tiếp tục tìm hiểu về nhiều API định dạng mới hơn nữa.

Bây giờ chúng ta đã thấy cách biến ngày tháng thành chuỗi, hãy nói về cách xâu chuỗi thành ngày tháng.

Date bây giờ có một trình khởi tạo lấy một lập luận chiến lược.

Chiến lược được sử dụng để cho trình phân tích cú pháp biết những lĩnh vực nào sẽ xảy ra trong đầu vào.

Đối với ngày tháng, định dạng cũng là một loại chiến lược.

Điều đó hữu ích cho các ngày quay tròn, như trong trường văn bản vừa hiển thị đầu ra vừa cho phép người dùng nhập ngày mới.

Đây là một ví dụ về chuyến đi khứ hồi.

Bạn sẽ nhận thấy rằng việc phân tích cú pháp có thể ném.

Điều này là do, tùy thuộc vào đầu vào, phân tích cú pháp có thể thất bại.

Một số chiến lược có các tùy chọn nâng cao hơn để phân tích cú pháp.

Ở đây, chúng tôi phân tích cú pháp một định dạng cố định, điều này rất hữu ích khi định dạng ngày là thứ nhận được từ máy chủ.

Để sử dụng nó, hãy khởi tạo một chiến lược với một chuỗi định dạng.

Tuy nhiên, thay vì sử dụng các giá trị chuỗi ma thuật, chúng tôi sử dụng phép nội suy chuỗi.

Trong trường hợp này, chúng tôi mong đợi một chuỗi định dạng năm-tháng-ngày.

Mỗi phép nội suy được xác định rõ ràng theo trường và mỗi nội suy chỉ định chính xác định dạng mong đợi.

Một điều thực sự tuyệt vời về điều này là trải nghiệm tự động hoàn thành.

Nếu tôi muốn sử dụng một định dạng ngày khác, tự động hoàn thành sẽ hiển thị cho tôi các tùy chọn hợp lệ cùng với tài liệu về ý nghĩa của từng tùy chọn.

Không, đoán xem bạn nên sử dụng bao nhiêu ký tự Y để phân tích cú pháp một năm.

Hãy chuyển sang những con số.

Định dạng số là chuyển đổi một giá trị số nguyên hoặc dấu phẩy động thành thứ gì đó mà con người có thể đọc được.

Giống như tất cả các định dạng, nó tính đến các tùy chọn về cách hiển thị các con số.

Điều này bao gồm mọi thứ từ loại chữ số được sử dụng đến ký tự nào được sử dụng để nhóm các chữ số.

Như với định dạng ngày, việc có được đầu ra tuyệt vời thật dễ dàng mà không cần thêm thông số nào.

Có nhiều loại tùy chọn và đầu ra được hỗ trợ.

Ở đây chúng tôi hiển thị tỷ lệ phần trăm, ký hiệu khoa học và tiền tệ.

Cuối cùng, hãy đặt một vài định dạng lại với nhau.

Định dạng danh sách bây giờ chỉ là định dạng một mảng.

Đối số kiểu thành viên này chỉ định kiểu định dạng của từng phần tử trong mảng.

Đây là những con số, vì vậy tôi muốn sử dụng một tỷ lệ phần trăm.

Đầu ra chính xác cho mọi ngôn ngữ của người dùng.

Cho đến nay chúng tôi đã tập trung vào việc định dạng các giá trị trực tiếp.

SwiftUI cũng hỗ trợ đính kèm kiểu định dạng vào TextField.

Vì các kiểu định dạng có thông tin kiểu về các loại giá trị mà chúng định dạng, chúng ta có thể sử dụng cú pháp có thể đọc được nhưng an toàn cho tỷ lệ phần trăm tiền boa trên biên lai của tôi tại đây.

Hãy xem lại ứng dụng Caffé của chúng tôi và xem có bao nhiêu địa điểm định dạng hiển thị.

Chúng tôi sử dụng định dạng danh sách cho các thành phần.

Chúng tôi sử dụng định dạng tiền tệ cho giá cả.

Chúng tôi sử dụng định dạng số cho số lượng và cũng để bản địa hóa số lượng trong nút đặt hàng.

Chúng tôi không thể quên định dạng ngày mà bạn luôn thấy ở góc trên đây.

Bạn sẽ tìm thấy đầu ra được định dạng ở khắp mọi nơi và chúng tôi nghĩ rằng API mới này cũng sẽ làm cho nó dễ dàng, thậm chí thú vị, trong ứng dụng của bạn.

Có rất nhiều tài nguyên có sẵn để trợ giúp với các chuỗi và định dạng được bản địa hóa.

Chúng tôi có thêm hai phiên về chủ đề này, "Địa phương hóa ứng dụng SwiftUI của bạn" và "Hợp lý hóa các chuỗi được bản địa hóa của bạn." Tiếp theo, hãy nói về một tính năng mới được gọi là thỏa thuận ngữ pháp tự động.

Những người bản địa hóa bằng các ngôn ngữ như tiếng Tây Ban Nha đã bị hạn chế về khả năng diễn đạt các bản dịch tự nhiên, đôi khi dẫn đến cuộc đối thoại khó xử.

Những ngôn ngữ này yêu cầu chuyển đổi để đạt được thỏa thuận về giới tính và số nhiều giữa các phần khác nhau của bài phát biểu và đôi khi thậm chí yêu cầu kiến thức về thuật ngữ địa chỉ ưa thích của người dùng.

Tiếng Anh cũng có đặc điểm này, với các danh từ có dạng khác nhau cho số ít và số nhiều.

Tôi đã ném ra rất nhiều biệt ngữ ngôn ngữ ở đó, vì vậy chúng ta hãy xem qua một ví dụ.

Trong ứng dụng Caffé của tôi, tôi có thể chọn một mặt hàng thực phẩm, kích thước và số lượng.

Tôi chọn 1 món salad nhỏ.

Bây giờ bạn tôi nói rằng cô ấy sẽ tham gia cùng tôi, vì vậy tôi tăng số lượng lên 2.

Trong tiếng Anh, từ "salad" phải thay đổi để khớp với số 2.

Đây được gọi là thỏa thuận.

Tất cả những gì có nghĩa là các từ trong câu này phải khớp với nhau.

Trong tiếng Anh, sửa chữa các từ do số nhiều là một loại thỏa thuận phổ biến.

Bây giờ hãy chuyển ứng dụng của chúng tôi sang tiếng Tây Ban Nha và gọi 1 ensalada pequeña, hoặc 1 món salad nhỏ.

Khi tôi đặt hàng cho bạn tôi, nút đặt hàng này cần số nhiều giống như trong tiếng Anh nhưng có một sự thay đổi.

Trong tiếng Tây Ban Nha, cả tính từ, pequeña và danh từ, ensalada, đều phải đồng ý với count, dos.

Vì vậy, thay vì ensalada pequeña, nút nói ensaladas pequeñas.

Tiếp theo, tôi chuyển sang uống rượu.

Đối với câu này, nút không chỉ cần số nhiều chính xác mà còn cần sự đồng ý về giới tính ngữ pháp của những từ này.

Nước trái cây, jugo, là nam tính.

Tính từ pequeño cũng phải khớp.

Để bản địa hóa văn bản như thế này một cách chính xác, chúng tôi kết thúc với một vụ nổ tổ hợp.

Cần có một chuỗi cục bộ khác nhau cho mỗi sự kết hợp của thực phẩm, kích thước và số lượng.

Trong mã, nó thường trông như thế này, nơi chúng ta cần chuyển đổi từng mặt hàng, sau đó chuyển đổi từng kích cỡ, v.v.

Ngoài ra còn có một tệp stringsdict, có thể đa số hóa từng chuỗi này một cách chính xác để đếm.

Giờ đây, bằng cách tận dụng cùng một công nghệ hỗ trợ các đề xuất trong bàn phím, chúng tôi đã tạo ra một API mới có thể dễ dàng xử lý tất cả các trường hợp này và hơn thế nữa.

Chúng tôi gọi tính năng này là thỏa thuận ngữ pháp tự động, bởi vì hệ thống tự động sửa các chuỗi được bản địa hóa để chúng có ngữ pháp chính xác.

Bây giờ mã trở nên đơn giản hơn nhiều.

Bạn có thể kết hợp số lượng, kích thước và thức ăn trong một chuỗi.

Thỏa thuận ngữ pháp tự động sẽ sửa chuỗi cho bạn bằng cách sử dụng một quy trình gọi là biến tố.

Hãy phá vỡ nó.

Để biến đổi, chúng ta cần biết phần nào của chuỗi cần được cố định.

May mắn thay, chúng tôi có một loại trong Swift có thể làm điều đó, AttributedString và một thuộc tính tùy chỉnh trong Markdown.

Trong chuỗi này, tôi sử dụng cú pháp đó để bọc thức ăn, kích thước và số lượng với thuộc tính biến tố của chúng tôi.

Giá trị của thuộc tính là đúng.

Khi chúng tôi xuất bản địa hóa của dự án này, chúng tôi sẽ nhận được một tệp chuỗi chứa chuỗi chú thích của chúng tôi cũng như các chuỗi bản địa hóa khác trong mã nguồn của chúng tôi, như tên của các loại thực phẩm và kích cỡ.

Đây là các chuỗi cho tiếng Tây Ban Nha Mỹ Latinh.

Trình bản địa hóa đã sử dụng cú pháp sắp xếp lại đối số %1, %3, %2, bởi vì một tính từ như "nhỏ" hoặc "lớn" đi trước danh từ trong tiếng Tây Ban Nha.

Họ giữ cú pháp thuộc tính tùy chỉnh để biến đổi vùng này của chuỗi và cung cấp bản dịch cho thực phẩm và kích cỡ.

Công cụ ngữ pháp tự động đảm nhận việc sửa chữa phần còn lại.

Một số ngôn ngữ có sự đồng ý không chỉ giữa các từ trong chính văn bản bản địa hóa mà còn giữa văn bản đó và người đọc nó.

Thỏa thuận ngữ pháp tự động cũng có thể giúp ích cho điều đó.

Ví dụ, chúng ta hãy xem màn hình chào mừng này cho Ghi chú.

Trong tiếng Anh, chúng tôi nói "Chào mừng đến với Ghi chú." Trong tiếng Tây Ban Nha, chúng tôi nói "Te damos la bienvenida a Notas," hoặc "Chúng tôi chào mừng bạn đến với Notes." Chúng tôi muốn có trải nghiệm tiếng Tây Ban Nha giống như chúng tôi làm bằng tiếng Anh.

Tuy nhiên, trong tiếng Tây Ban Nha, từ "bienvenido" phải khớp với thuật ngữ địa chỉ ưa thích của người dùng.

Thuật ngữ này có thể là một trong nhiều lựa chọn và lựa chọn đó sẽ thay đổi văn bản.

Sử dụng thuật ngữ địa chỉ chính xác dẫn đến trải nghiệm cá nhân và toàn diện hơn.

Trong các bản phát hành năm nay, chúng tôi đã giúp những người sử dụng tiếng Tây Ban Nha có thể chỉ định thời hạn địa chỉ của họ.

Trong cài đặt Ngôn ngữ & Khu vực, có một tùy chọn Điều khoản Địa chỉ mới.

Khi bạn chọn nó, bạn có thể chọn sở thích của mình và cũng có thể chọn chia sẻ nó với tất cả các ứng dụng.

Tại đây, bạn thấy màn hình chào mừng mới trong Ghi chú cho một thuật ngữ địa chỉ nữ tính.

Và đây là một thuật ngữ địa chỉ nam tính.

Nếu chúng tôi không biết hoặc người dùng không muốn chỉ định, chúng tôi giữ chuỗi ban đầu của mình như một giải pháp thay thế.

Thuộc tính biến tố tương tự mà chúng ta đã thấy trước đó cũng được sử dụng trong các chuỗi cục bộ đề cập đến người dùng.

Trong trường hợp "chào mừng đến" của chúng tôi, chúng tôi áp dụng thuộc tính biến tố cho từ bienvenido.

Chuỗi tiếng Anh không cần thay đổi.

Tôi cũng có thể thêm một giải pháp thay thế uốn, đó là một chuỗi thay thế mà công cụ sẽ sử dụng nếu nó không có thông tin về sở thích của người dùng.

Năm nay, chúng tôi hỗ trợ thỏa thuận tự động cho tiếng Tây Ban Nha và tiếng Anh.

Chúng tôi đã áp dụng nó ở một số nơi trên hệ điều hành, như màn hình chào mừng trong Ghi chú.

Bạn cũng có thể áp dụng nó trong các ứng dụng của mình.

Những thay đổi mã được yêu cầu chủ yếu chỉ là xóa rất nhiều logic để chọn các chuỗi khác nhau.

Các hướng dẫn về những gì cần biến đổi là một phần của chính chuỗi được bản địa hóa, cho phép người bản địa hóa kiểm soát nhiều hơn cách chuỗi xuất hiện trong ngôn ngữ của họ.

Hãy cùng xem xét thỏa thuận ngữ pháp tự động đang hoạt động cho ứng dụng Caffé của chúng tôi.

Hãy xem qua ứng dụng Caffé đang chạy bằng tiếng Anh.

Tôi sẽ bắt đầu bằng cách thêm một ít bánh pizza vào đơn đặt hàng.

Tôi nghĩ tôi sẽ có một cái lớn. Và chỉ 1.

Chú ý cách văn bản trên nút đã thay đổi từ 0 bánh pizza lớn thành 1 bánh pizza lớn.

Điều đó đã được thực hiện tự động.

Nếu tôi chọn 2, nó sẽ sửa nó một lần nữa.

Tôi sẽ chỉ có một cái.

Ở cuối màn hình này, nút đặt hàng đã thay đổi thành 1 mặt hàng.

Uống gì đó thì sao?

Nhỏ là ổn, và chỉ 1 trong số này.

Chú ý cách nút đã thay đổi để nói "mục" thay vì "mục"?

Chuỗi đó đã được thay đổi tự động.

Hãy kiểm tra.

Đây là biên lai của chúng tôi.

Nó liệt kê pizza và nước trái cây của chúng tôi, cùng với giá định dạng.

Ở dưới cùng là chuỗi được quy cho của chúng tôi, với phông chữ tùy chỉnh và liên kết đến trang web.

Hãy quay lại Xcode và xem nguồn.

Tôi sẽ bắt đầu trong chế độ xem chi tiết đồ ăn.

Đây là chế độ xem hiển thị màn hình lựa chọn kích thước.

Hãy thêm một kích thước mới để chúng ta có thể thấy điều đó chỉ yêu cầu chúng ta thêm một chuỗi bản địa hóa cho tiếng Tây Ban Nha thay vì một chuỗi cho mỗi loại thực phẩm, mỗi kích thước và mỗi lần đếm.

Dòng này hiển thị danh sách.

Danh sách đến từ đối tượng mô hình của chúng tôi.

Hãy đến đó.

Kích thước enum đã có kích thước nhỏ và lớn.

Tôi sẽ thêm một kích thước mới cho những khách hàng khao khát nhất của chúng tôi, được gọi là "khổng lồ". Để làm điều đó, tôi sẽ thêm một trường hợp mới, cùng với một chuỗi được bản địa hóa.

Bây giờ tôi chỉ cần thêm giá cho kích thước lớn.

Đối với bản demo này, tôi vừa đưa chúng vào trình khởi tạo.

Bây giờ tôi chỉ cần thêm giá cho kích thước lớn.

Đối với bản demo này, tôi vừa đưa chúng vào trình khởi tạo của chúng tôi.

Hãy kiểm tra lại quan điểm của chúng ta.

Ở đây trong bản xem trước là kích thước mới của chúng tôi.

Nguồn của chúng tôi đã chứa một chuỗi tiếng Anh.

Tôi chỉ cần một cái tiếng Tây Ban Nha bây giờ.

Để tạo các chuỗi mới, tôi sẽ sử dụng trình biên dịch để tìm chuỗi bản địa hóa mới cho "khổng lồ". Để làm điều đó, tôi chọn Sản phẩm > Xuất bản địa hóa và lưu các chuỗi tiếng Tây Ban Nha.

Bây giờ hãy thêm một bản dịch cho tiếng Tây Ban Nha.

Tôi có thể lọc chuỗi mới của chúng tôi và nhập từ tiếng Tây Ban Nha của chúng tôi.

Tiếp theo, tôi nhập các bản địa hóa này để đưa chúng vào ứng dụng của mình.

Bây giờ tôi sẽ chạy lại ứng dụng của chúng tôi nhưng bằng tiếng Tây Ban Nha.

Để làm điều đó, tôi chọn Sản phẩm > Sơ đồ > Chỉnh sửa Sơ đồ.

Trong Tùy chọn, tôi có thể chọn ngôn ngữ tôi muốn kiểm tra.

Và chạy.

Bạn có thể biết từ tiêu đề của chúng tôi rằng chúng tôi hiện đang chạy bằng tiếng Tây Ban Nha.

Hãy làm một đơn hàng khác, bắt đầu với salad.

Lưu ý khi tôi thay đổi số lượng, nút đặt hàng đã được cố định.

Kích thước khổng lồ mới của chúng tôi được số nhiều chính xác cho 2 món salad.

Thêm vào đó, nó phù hợp với giới tính ngữ pháp cho "ensalada", tất cả chỉ với một chuỗi.

Có rất nhiều tính năng mới tuyệt vời trong Foundation năm nay và chúng đã sẵn sàng để bạn thử trong các ứng dụng của mình ngay hôm nay.

AttributedString cung cấp giao diện nhanh chóng, dễ sử dụng và Swift đầu tiên để thêm các cặp khóa-giá trị vào phạm vi của một chuỗi.

Bạn có thể sử dụng nó với SwiftUI trong văn bản và bắt đầu sử dụng Markdown trong các chuỗi được bản địa hóa của mình.

Formatter API mới của chúng tôi tập trung vào định dạng, đơn giản hóa mã của bạn và cải thiện hiệu suất.

Sử dụng các định dạng ở tất cả những nơi bạn trình bày dữ liệu trong ứng dụng của mình.

Cuối cùng, thỏa thuận ngữ pháp tự động sẽ sửa chữa một cách thông minh các chuỗi được bản địa hóa để chúng khớp với giới tính ngữ pháp, số lượng và thuật ngữ địa chỉ của chính người dùng.

Tôi hy vọng bạn sẽ thích những tính năng mới này.

Chúng tôi rất mong được tìm thấy chúng trong các ứng dụng của bạn.

Cảm ơn bạn.

[Âm nhạc].