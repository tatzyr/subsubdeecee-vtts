10286

♪ Nhạc bass đang phát ♪

♪

Alejandro Segovia Azapian: Chào mừng đến với WWDC!

Tên tôi là Ale Segovia Azapian, và tôi là kỹ sư phần mềm GPU tại Apple.

Trong phiên này, chúng ta sẽ khám phá kết xuất không ràng buộc trong Metal.

Bindless là một mô hình ràng buộc tài nguyên hiện đại cho phép tạo các nhóm tài nguyên có sẵn cho GPU để thực hiện các kỹ thuật kết xuất hiện đại.

Đầu tiên, chúng ta sẽ xem xét sự cần thiết của khái niệm đằng sau bindless.

Sau đó, chúng tôi sẽ giới thiệu mô hình không ràng buộc và chỉ ra cách nó cung cấp sự linh hoạt cần thiết để giải quyết những thách thức của mô hình ràng buộc truyền thống.

Chúng tôi sẽ tóm tắt lại các cơ chế để mã hóa và cung cấp tài nguyên cảnh của bạn cho Metal với bộ đệm đối số và cách điều hướng cấu trúc GPU của bạn từ bộ đổ bóng.

Hãy bắt đầu nào!

Vì vậy, kết xuất không ràng buộc cho phép làm cho tất cả các tài nguyên cảnh của chúng tôi có sẵn cho các bộ đổ bóng của chúng tôi, mang lại sự linh hoạt đáng kinh ngạc cho các kỹ thuật đồ họa của chúng tôi.

Hãy xem xét một ví dụ.

Hãy tưởng tượng chúng ta có một hạt nhân dò tia tìm các giao điểm chống lại cấu trúc gia tốc.

Đối với một số hiệu ứng ánh sáng, chẳng hạn như bóng dò tia, thuật toán này rất tự nhiên.

Chúng tôi muốn tìm bất kỳ vật thể nào giữa điểm giao nhau và ánh sáng.

Tất cả những gì chúng ta cần để theo dõi tia bóng là một vị trí và hướng về phía ánh sáng.

Không cần thuộc tính đối tượng hoặc tài nguyên kim loại nào ngoài vị trí không gian thế giới của giao điểm, mà chúng ta có thể suy ra từ tia và tham số của giao điểm.

Tuy nhiên, đối với các hiệu ứng khác, chẳng hạn như phản ánh, tình hình trở nên phức tạp hơn.

Chúng ta hãy xem một bộ đổ bóng phản xạ dò tia trong Ngôn ngữ tạo bóng kim loại.

Trong ví dụ mới này, chúng tôi vừa tìm thấy một giao lộ và chúng tôi đang cố gắng vẽ điểm ảnh với màu phản chiếu chính xác.

Nếu chúng ta chỉ sơn một màu đồng nhất sau khi chúng ta tìm thấy một giao lộ, sự phản chiếu trên mặt đất sẽ trông không chính xác.

Để tạo ra kết quả chính xác, chúng ta cần xác định các thuộc tính của mỗi điểm phản xạ được tìm thấy và tính toán độ bóng chính xác cho điểm ảnh của nó.

Vấn đề này cũng xuất hiện đối với các hiệu ứng dò tia khác như chiếu sáng toàn cầu khuếch tán và thậm chí tắc nghẽn môi trường xung quanh trong một số trường hợp.

Thách thức là khi chúng ta theo dõi tia, tia của chúng ta có thể va vào bất kỳ vật thể nào trong cấu trúc gia tốc.

Điều này có nghĩa là từ bộ đổ bóng dò tia của chúng tôi, chúng tôi có khả năng cần quyền truy cập vào bất kỳ tài nguyên Kim loại nào trong cảnh của mình, bao gồm dữ liệu đỉnh - được liên kết với lưới giao nhau - và vật liệu của nó.

Không thể ràng buộc lượng tài nguyên này trực tiếp với đường ống của chúng tôi.

Đây là nơi mà mô hình ràng buộc không liên kết xuất hiện.

Ý tưởng đằng sau bindless là tổng hợp các nguồn lực của chúng ta và liên kết chúng lại với nhau.

Điều này cho phép chúng tôi liên kết một bộ đệm duy nhất với đường ống và cung cấp tất cả các tài nguyên được tham chiếu thông qua điều hướng.

Trong Metal, cấu trúc cho phép chúng ta làm điều này là bộ đệm đối số.

Đặc biệt, đối với bộ đệm đối số không ràng buộc, bộ đệm đối số Cấp 2 được yêu cầu.

Những thứ này có sẵn trên các dòng GPU Apple6 và Mac2.

Bộ đệm đối số có thể được sử dụng từ tất cả các loại đổ bóng trong Metal.

Điều này có nghĩa là bạn có thể sử dụng chúng cho cả dò tia và rasterization.

Như chúng ta đã thấy, đối với một số hiệu ứng dò tia nhất định, việc sử dụng không liên kết là bắt buộc để có được kết quả hình ảnh tốt.

Đối với rasterization, việc sử dụng là tùy chọn nhưng cung cấp lợi thế so với mô hình ràng buộc trực tiếp.

Đặc biệt, nó hầu như loại bỏ giới hạn vị trí cho số lượng tài nguyên có thể bị ràng buộc cho bất kỳ cuộc gọi rút thăm nhất định nào và nó cũng cung cấp một số cơ hội tối ưu hóa tốt mà chúng ta sẽ khám phá sau trong phiên này.

Chúng tôi đã giới thiệu bộ đệm đối số với Metal 2 như một cơ chế cho phép bạn liên kết tất cả dữ liệu và tài nguyên không đổi cùng một lúc trong một lần gọi đến Metal API.

Bộ đệm đối số rất linh hoạt và thậm chí có thể tham chiếu đến các bộ đệm khác.

Ý tưởng đằng sau mô hình không ràng buộc là tận dụng khả năng này để liên kết tất cả các tài nguyên cảnh của chúng tôi lại với nhau.

Điều này sẽ cho phép làm cho chúng có sẵn cho GPU cùng một lúc.

Hãy xem xét một ví dụ về cách liên kết tài nguyên cảnh của chúng ta với bộ đệm đối số.

Giả sử chúng tôi muốn kết xuất một mô hình như chiếc xe cứu hỏa này.

Mô hình bao gồm kết cấu, dữ liệu đỉnh và dữ liệu chỉ mục.

Đây là những tài nguyên điển hình mà bạn sẽ liên kết từng tài nguyên một cho mỗi lần gọi rút thăm trong mô hình ràng buộc truyền thống.

Tuy nhiên, trong trường hợp của chúng tôi - bởi vì chúng tôi muốn cung cấp tất cả các kết cấu, dữ liệu đỉnh và chỉ mục của cảnh cùng một lúc - chúng tôi cần tổng hợp những thứ này.

Đây là một cách tiềm năng để làm điều đó.

Trước tiên, chúng ta có thể tạo một bộ đệm đối số mắt lưới để chứa tất cả các mắt lưới hoặc phân đoạn của chúng ta, tùy thuộc vào cách tổ chức tài sản của chúng ta.

Bộ đệm đối số này sẽ cho phép tham chiếu các mảng đỉnh và chỉ mục trong cảnh của chúng tôi.

Tương tự, chúng ta có thể làm tương tự và mã hóa các tài liệu của mình thành một bộ đệm đối số.

Mỗi vật liệu có thể tham chiếu kết cấu của nó cũng như chứa dữ liệu không đổi nội tuyến.

Được rồi, nhưng bây giờ chúng ta đã có sẵn tất cả các mắt lưới và vật liệu của mình cho GPU, làm thế nào chúng ta có thể kết hợp chúng lại với nhau?

Chà, chúng ta có thể, ví dụ, tạo một đối tượng thể hiện và cũng đặt nó vào bộ đệm đối số.

Một ví dụ có thể tham chiếu đến một lưới và một vật liệu liên quan.

Đây cũng là một nơi tuyệt vời để lưu trữ ma trận biến đổi mô hình dưới dạng dữ liệu không đổi nội tuyến.

Nhưng chúng ta không cần phải dừng lại ở đó.

Bây giờ chúng ta có thể lưu trữ một phiên bản, chúng ta có thể tiếp tục điều này và mã hóa tất cả các phiên bản của chúng ta dưới dạng một mảng vào bộ đệm đối số này.

Hãy đơn giản hóa sơ đồ này và thêm một vài trường hợp xe tải nữa, mỗi trường hợp có vật liệu riêng.

Như chúng ta có thể thấy, với điều này, giờ đây chúng ta có thể có toàn bộ cảnh và tài nguyên của nó được mã hóa và liên kết với bộ đệm đối số.

Sau đó, khi chúng tôi muốn tham chiếu bất kỳ tài nguyên nào trong số này từ bộ đổ bóng của mình, chúng tôi chỉ cần một con trỏ đến bộ đệm phiên bản.

Chúng ta có thể truyền nó trực tiếp và diễn giải bộ đệm này dưới dạng một mảng hoặc chuyển một con trỏ qua một bộ đệm đối số cảnh khác.

Bây giờ, điều quan trọng cần lưu ý là điều gì xảy ra với nơi cư trú của các tài nguyên được truy cập gián tiếp.

Vì chúng tôi chỉ chuyển một con trỏ đến cảnh vào đường ống, Metal sẽ biết về tham chiếu bộ đệm này, nhưng không biết về các tài nguyên được truy cập gián tiếp.

Ứng dụng chịu trách nhiệm tuyên bố nơi cư trú của tất cả các tài nguyên được truy cập gián tiếp.

Tạo một cư dân tài nguyên có nghĩa là báo hiệu cho trình điều khiển để làm cho bộ nhớ của nó có sẵn cho GPU.

Điều này là cần thiết để chúng tôi có thể tham khảo chúng từ các bộ đổ bóng của chúng tôi.

Chúng ta có thể làm điều này bằng cách gọi useResource:usage: API cho các bộ mã hóa tính toán và useResource:usage:stages: API cho các bộ mã hóa lệnh kết xuất.

Truy cập tài nguyên không cư trú là nguyên nhân phổ biến khiến GPU khởi động lại và lỗi bộ đệm lệnh.

Điều này là do các trang bộ nhớ của nó có thể không có mặt nếu chúng ta quên gọi API này.

Vì vậy, điều rất quan trọng là phải khai báo mọi tài nguyên được truy cập gián tiếp cho Metal.

Bây giờ, một lựa chọn khác, để thuận tiện, là các tài nguyên được phân bổ từ MTLHeaps hiện có thể được thực hiện thường trú với một cuộc gọi duy nhất bằng API useHeap.

Đây là một lựa chọn tuyệt vời nếu bạn đã phân bổ lại hoặc dự định phân bổ lại tài nguyên từ đống.

Giờ đây, đống là một phần tuyệt vời của Metal API và chúng tôi khuyên bạn nên sử dụng chúng để có hiệu suất tạo tài nguyên tốt nhất và các cơ hội tiết kiệm bộ nhớ.

Tuy nhiên, có một vài cân nhắc để sử dụng chúng một cách hiệu quả.

Điều đầu tiên cần hỏi là, Có phải tất cả các tài nguyên được phân bổ phụ của chúng tôi chỉ được đọc từ?

Ví dụ về nơi chúng ta có thể cần viết vào tài nguyên bao gồm lột da lưới từ bộ đổ bóng tính toán và kết cấu động, trong số những thứ khác.

Trong những trường hợp này, nếu GPU cần ghi vào bất kỳ tài nguyên nào, chúng cần được khai báo là cư dân riêng lẻ với cờ sử dụng ghi.

Ngoài ra, bất kỳ tài nguyên nào có thể đã được sửa đổi mà bây giờ chúng tôi dự định đọc vẫn sẽ cần cuộc gọi useResource của riêng họ.

Điều này là để khung Metal có thể xử lý quá trình chuyển đổi tài nguyên cho bạn, xóa bộ nhớ cache GPU và điều chỉnh bố cục bộ nhớ trong.

Cân nhắc thứ hai là, đống có theo dõi phân bổ phụ thuộc tài nguyên không?

Một lần nữa, điều này đặc biệt quan trọng nếu chúng ta đang đọc và viết vào các tài nguyên đến từ cùng một đống.

Metal rất tốt trong việc tránh các vấn đề đồng bộ hóa thông qua theo dõi sự phụ thuộc và kể từ Metal 2.3, các đống có thể được cấu hình để theo dõi các mối nguy hiểm trong việc truy cập vào tài nguyên của chúng.

Tuy nhiên, vì đống là một tài nguyên duy nhất đối với Metal, đồng bộ hóa được xử lý ở cấp đống chứ không phải cấp phân bổ phụ.

Điều này có thể khiến các tài nguyên được phân bổ lại cho vấn đề chia sẻ sai.

Hãy cùng xem nào.

Hãy tưởng tượng chúng ta có hai đường dẫn kết xuất - A và B - truy cập tài nguyên từ cùng một đống.

Kết xuất vượt qua A là kết xuất thành một kết cấu kết xuất được phân bổ từ một đống được theo dõi.

Kết xuất vượt qua B đang đọc từ một bộ đệm không liên quan được phân bổ lại từ cùng một đống.

Tùy thuộc vào các điều kiện khác nhau, kết xuất vượt qua A và B có thể đủ điều kiện để được thực hiện song song bởi GPU; tuy nhiên, do nguy cơ tiềm ẩn của việc ghi và đọc từ cùng một tài nguyên - đống - Metal phải tuần tự hóa quyền truy cập để đảm bảo không có điều kiện chủng tộc.

Điều này có khả năng làm tăng thời gian thực thi đồng hồ tường của khối lượng công việc của chúng tôi bằng GPU.

Tuy nhiên, trong trường hợp của chúng tôi, nếu chúng tôi biết các nguồn lực cá nhân là độc lập, hàng rào này có thể tránh được.

Có hai cách để làm điều này.

Một lựa chọn là phân bổ lại các tài nguyên có thể cập nhật từ đống riêng biệt sang các tài nguyên được sử dụng cho tài nguyên tĩnh của chúng tôi.

Tùy chọn khác, nếu chúng ta muốn kết hợp mọi thứ lại với nhau, là đảm bảo các đống được định cấu hình để không theo dõi các tài nguyên được phân bổ lại của chúng.

Đây là hành vi mặc định trong Metal, và nó có nghĩa là chúng tôi với tư cách là lập trình viên tự chịu trách nhiệm đồng bộ hóa các mối nguy hiểm.

Bây giờ, trong sơ đồ này, tôi đã đơn giản hóa mọi thứ một chút để minh họa vấn đề chia sẻ sai.

Trong thực tế, sự chồng chéo xảy ra ở cấp độ giai đoạn đổ bóng, không phải ở cấp độ vượt qua kết xuất.

Kết quả là, Metal cho phép chúng tôi xác định hàng rào của mình ở giai đoạn chi tiết.

Điều này thật tuyệt vì nó cho phép chúng tôi vẫn chạy các phần của đường ống của mình - chẳng hạn như giai đoạn đỉnh và rasterizer - đồng thời và chỉ chặn sau đó trong giai đoạn phân mảnh nếu nó xảy ra phụ thuộc vào đầu ra giai đoạn phân đoạn của đường chuyền trước đó.

Chúng tôi khuyên bạn nên luôn làm điều này để có hiệu suất tối đa, nếu có thể.

Bây giờ, điều này rất nhiều điều cần nhớ, vì vậy nếu bạn chỉ nhận được một điều từ danh sách này, vui lòng nhớ điều này: dữ liệu chỉ đọc, chẳng hạn như kết cấu tĩnh và mắt lưới, là dễ xử lý nhất.

Xác định tổng kích thước phân bổ và các yêu cầu căn chỉnh trước và đặt các tài nguyên này vào một đống khi ứng dụng khởi động hoặc trong phần tải trong trò chơi của bạn.

Bằng cách này, sau này bạn có thể làm cho nó cư trú trong một cuộc gọi duy nhất, với chi phí tối thiểu trong con đường quan trọng của bạn.

Bây giờ chúng ta đã biết về mô hình ràng buộc không ràng buộc, chúng ta hãy xem cách chúng ta có thể mã hóa tài nguyên của mình và đưa điều này vào thực tế và làm cho cảnh hoàn chỉnh của chúng ta có sẵn cho GPU với bộ đệm đối số.

Giả sử chúng tôi muốn mã hóa bộ đệm phiên bản của mình.

Hãy nhớ rằng, bộ đệm này bao gồm một loạt các trường hợp.

Như chúng ta đã thấy, các trường hợp tham chiếu đến một lưới, một vật liệu và chứa một ma trận 4x4 không đổi nội tuyến mô tả sự biến đổi từ không gian cục bộ sang không gian thế giới.

Mã hóa được thực hiện thông qua bộ mã hóa bộ đệm đối số và có hai cách riêng biệt để tạo một cách trong Metal.

Bạn có thể quen thuộc với mã hóa thông qua phản chiếu.

Nếu bộ đệm đối số được truyền dưới dạng tham số trực tiếp đến hàm đổ bóng, chúng ta có thể yêu cầu đối tượng MTLFunction tạo bộ mã hóa cho chúng ta.

Cơ chế này hoạt động rất tốt, nhưng khi chúng ta mã hóa toàn bộ cảnh thành bộ đệm đối số, không phải tất cả các bộ mã hóa đều có thể được phản ánh.

Đặc biệt, chữ ký MTLFunction không biết về các bộ đệm được tham chiếu gián tiếp.

Cũng có thể có những tình huống khác mà việc tạo bộ mã hóa từ MTLFunction không thuận tiện; ví dụ: nếu kiến trúc động cơ của bạn xử lý việc tạo bộ đệm đối số và tải tài nguyên tách biệt với việc tạo trạng thái đường ống.

Ngoài ra, chúng ta không thể phản ánh một bộ mã hóa khi hàm dự kiến sẽ được truyền một mảng.

Vậy chúng ta có thể làm gì trong những trường hợp này?

Đối với những trường hợp này, Metal cung cấp một cơ chế thứ hai thuận tiện để tạo ra một bộ mã hóa thông qua MTLArgumentDescriptor.

MTLArgumentDescriptors cho phép mô tả các thành viên cấu trúc thành Metal và sau đó tạo một bộ mã hóa mà không cần MTLFunction.

Trước tiên chúng ta phải tạo một bộ mô tả cho mỗi thành viên, chỉ định loại dữ liệu và chỉ mục ràng buộc.

Tiếp theo, chúng tôi lấy các mô tả của mình và chuyển chúng trực tiếp đến MTLDevice để tạo bộ mã hóa của chúng tôi.

Kết quả là, chúng tôi lấy lại đối tượng bộ mã hóa của mình.

Vì vậy, hãy khám phá điều này trông như thế nào trong mã.

Đối với mỗi thành viên, chúng tôi cần tạo một MTLArgumentDescriptor; chúng tôi chỉ định chỉ mục ràng buộc, tương ứng với thuộc tính ID cho thành viên trong cấu trúc; chúng tôi chỉ định MTLDataType và có khả năng truy cập; và cuối cùng, sau khi chúng tôi đã khai báo tất cả các thành viên, chúng tôi có thể tạo bộ

Khi chúng ta có một bộ mã hóa, thật đơn giản để ghi lại dữ liệu của chúng ta vào bộ đệm.

Chúng tôi đặt bộ đệm đối số trên bộ mã hóa, trỏ vào đầu bộ đệm.

Sau đó, chúng tôi chỉ cần đặt dữ liệu mà chúng tôi muốn lưu trữ.

Mã hóa một mảng cũng rất đơn giản.

Tất cả những gì chúng ta phải làm là bù đắp điểm ghi bộ đệm đối số của bộ mã hóa bằng Độ dài được mã hóa, chúng ta có thể truy xuất thuận tiện từ bộ mã hóa.

Đối với trường hợp tiếp theo, chúng tôi thêm Độ dài được mã hóa vào phần bù của chúng tôi lần thứ hai.

Trên thực tế, độ lệch cho mỗi vị trí chúng ta cần ghi lại sẽ là chỉ mục nhân với Độ dài được mã hóa.

Cơ chế này giúp việc mã hóa các mảng cấu trúc trở nên rất dễ dàng.

Bây giờ, một điểm quan trọng đáng nói là không cần xử lý đặc biệt từ phía đổ bóng đến chỉ mục vào các mảng này.

Bộ đổ bóng không cần biết độ dài của bộ đệm và có thể tự do lập chỉ mục vào bất kỳ vị trí nào trong mảng.

Nó chỉ hoạt động!

Được rồi, bây giờ chúng ta đã mã hóa cảnh không ràng buộc của mình, chúng ta hãy xem điều hướng.

Đối với trường hợp dò tia, điều hướng là rất tự nhiên.

Đầu tiên, chúng tôi liên kết bộ đệm chứa gốc của cảnh không ràng buộc của chúng tôi với đường ống dò tia của chúng tôi.

Đây là bộ đệm đối số từ nơi chúng ta có thể truy cập tất cả những thứ khác.

Tiếp theo, từ hạt nhân của chúng tôi, chúng tôi tiến hành giao điểm dò tia như bình thường.

Sau khi chúng tôi phát hiện ra một giao lộ, đối tượng kết quả giao lộ mô tả điều hướng.

Chúng ta có thể truy vấn đối tượng này cho ví dụ_id, geometry_id, và primitive_id.

Những thành viên này được thiết kế đặc biệt để điều hướng các cấu trúc gia tốc của chúng tôi.

Do đó, điều quan trọng là phải xây dựng cảnh không ràng buộc của chúng ta với một cấu trúc phản ánh cấu trúc gia tốc của chúng ta, chẳng hạn như cấu trúc được hiển thị trước đó.

Hãy cùng xem lại nó một lần nữa.

Hãy nhớ rằng, đây chỉ là một ví dụ về cách sắp xếp cảnh, vì vậy tôi sẽ điều hướng nó theo cách tôi sắp xếp nó.

Các chi tiết cụ thể cho cảnh của bạn có thể khác nhau, tùy theo cách bạn quyết định tổ chức bộ đệm đối số của riêng mình.

Đầu tiên, chúng ta cần tìm một giao lộ.

Một khi chúng tôi có nó, bởi vì chúng tôi đã tổ chức chiến lược cảnh không ràng buộc của mình, với instance_id, bây giờ chúng tôi có thể theo con trỏ đến bộ đệm phiên bản và xác định cái nào chúng tôi đánh.

Tiếp theo, như chúng ta đã thấy, ví dụ biết lưới và chất liệu của nó.

Vì vậy, chúng ta có thể chỉ cần sử dụng geometry_id để xác định hình học nào chúng ta chạm vào trong bộ đệm được tham chiếu.

Cuối cùng, nếu chúng ta chuẩn bị mỗi lưới để biết bộ đệm chỉ mục của nó, chúng ta có thể sử dụng primitive_id để xác định chính xác nguyên thủy mà chúng ta đạt được.

Ví dụ, trong trường hợp của một tam giác, chúng ta có thể kéo ba chỉ số từ mảng này và sử dụng chúng để truy xuất dữ liệu đỉnh của nó.

Đây là điều hướng này trông như thế nào trong Ngôn ngữ đổ bóng kim loại.

Từ đối tượng giao điểm, chúng tôi truy xuất instance_id và sử dụng nó để tự động lập chỉ mục vào mảng phiên bản của chúng tôi và truy xuất phiên bản mà chúng tôi đã truy cập.

Tiếp theo, có ví dụ, chúng tôi sử dụng geometry_id để xác định hình học hoặc lưới con nào đã bị tấn công.

Khi chúng ta đã xác định được hình học, chúng ta có thể trực tiếp lấy các chỉ số từ bộ đệm chỉ mục.

Trong trường hợp của một tam giác, chúng ta kéo ba chỉ số, lần lượt từng chỉ số.

Chúng tôi sử dụng các chỉ mục này để truy cập vào mảng dữ liệu đỉnh và truy xuất bất kỳ thuộc tính nào chúng tôi cần cho kỹ thuật của mình.

Ví dụ, chúng ta có thể truy xuất các chuẩn tương ứng với mỗi đỉnh.

Và cuối cùng, sử dụng tọa độ barycentric của điểm, chúng tôi nội suy thủ công các chuẩn đỉnh để đạt đến chuẩn chính xác tại điểm giao nhau.

Với những thay đổi này tại chỗ, đưa nó trở lại ví dụ ấm trà của chúng tôi, bây giờ chúng tôi có cách tính toán bình thường tại điểm giao nhau, chúng tôi có thể tô bóng chính xác phản xạ của mình.

Chúng tôi đã cập nhật mã để tìm các thuộc tính chính xác tại điểm giao nhau và bây giờ kết quả chính xác về mặt hình ảnh.

Bây giờ chúng ta có thể tiếp tục xây dựng trên khuôn khổ này để tính toán bất kỳ thuộc tính nào khác mà chúng ta muốn, chẳng hạn như tọa độ kết cấu để áp dụng kết cấu hoặc vectơ tiếp tuyến để thực hiện ánh xạ chuẩn.

Vì vậy, ở đây chúng tôi đã thấy cách điều hướng cảnh không liên kết của mình để truy xuất dữ liệu đỉnh, nội suy thủ công và cuối cùng, áp dụng nó để tô bóng chính xác tất cả các điểm giao nhau được phát hiện.

Để giúp bạn đưa những khái niệm này vào công cụ của riêng mình, chúng tôi sẽ phát hành một mẫu mã đồng hành cho thấy việc triển khai cụ thể tất cả những điều này.

Đây là một mẫu kết xuất lai tính toán phản xạ dò tia cho một cảnh được tải bằng khung Model I/O.

Mẫu cho thấy cách bạn có thể mã hóa một cảnh không liên kết phù hợp với cấu trúc gia tốc dò tia và nó cũng cho thấy cách tìm giao điểm và tô bóng chính xác các điểm ảnh liên quan của chúng trực tiếp từ bộ đổ bóng dò tia của bạn.

Như chúng ta có thể thấy ở đây, mẫu cũng cho phép hình dung trực tiếp đầu ra của bộ đổ bóng theo dõi tia phản xạ ngay tại các điểm mà các tia giao với xe tải.

Điều này thật tuyệt vời cho việc thử nghiệm lặp đi lặp lại với thuật toán phản xạ.

Bây giờ, chúng tôi đã bao quát rất nhiều nền tảng ở đây và cho đến nay chúng tôi đã tập trung hầu hết các cuộc thảo luận của mình trong bối cảnh dò tia.

Nhưng như tôi đã đề cập trước đó, chúng ta có thể áp dụng các nguyên tắc tương tự để tô bóng đúng các điểm ảnh của mình trong bối cảnh rasterization.

Kết xuất dựa trên vật lý là một ứng cử viên tuyệt vời cho việc này.

Trong PBR, bộ đổ bóng mảnh của chúng tôi cần thông tin đến từ một số kết cấu; ví dụ, suất phản chiếu, độ nhám, kim loại và tắc nghẽn môi trường xung quanh.

Trong mô hình ràng buộc trực tiếp, chúng ta cần liên kết từng khe riêng lẻ trước khi phát hành từng cuộc gọi rút thăm của chúng ta.

Mô hình không ràng buộc đơn giản hóa điều này rất nhiều.

Khi chúng tôi đã mã hóa bộ đệm đối số của mình, chúng tôi có thể liên kết trực tiếp cảnh, điều hướng đến tài liệu tương ứng với cuộc gọi vẽ của chúng tôi và truy cập gián tiếp tất cả các kết cấu.

Trên thực tế, vì bây giờ chúng ta chỉ cần liên kết một bộ đệm duy nhất một lần, kiến trúc này cung cấp một cơ hội tuyệt vời để tối ưu hóa các công cụ của chúng ta hơn nữa bằng cách giảm số lượng cuộc gọi vẽ và thay vào đó sử dụng kết xuất phiên bản.

Chỉ cần nhớ tạo cho cư dân tất cả các kết cấu mà chúng tôi dự định truy cập.

Đây là một ví dụ về bộ đổ bóng PBR điển hình.

Trong mô hình truyền thống, mỗi kết cấu được tham chiếu cần được liên kết riêng trước cuộc gọi vẽ này.

Nếu cuộc gọi vẽ sau đây yêu cầu một tập hợp các kết cấu khác nhau, tất cả các tài nguyên này cũng cần được ràng buộc từng cái một.

Khi sử dụng mô hình không liên kết, bây giờ chúng ta có thể chuyển bộ đệm đối số gốc của mình và truy xuất tài liệu của chúng ta trực tiếp từ các cấu trúc được tham chiếu của nó, giống như trước đây.

Đầu tiên chúng tôi truy xuất trường hợp - điều này có thể được xác định trong giai đoạn tô bóng đỉnh - sau đó truy xuất tài liệu của nó và sử dụng kết cấu được tham chiếu và dữ liệu không đổi của nó để tính toán bóng thích hợp.

Cuối cùng, chúng tôi chỉ trả lại màu.

Được rồi!

Và đó là một chuyến tham quan về cách thực hiện hiệu quả kết xuất không ràng buộc trong Metal!

Tóm lại, chúng tôi đã khám phá mô hình Metal bindless và thấy nó cực kỳ linh hoạt như thế nào, cho phép bạn thể hiện cảnh của mình theo bất kỳ cách nào bạn muốn.

Đề xuất của tôi là thiết kế và xây dựng các cấu trúc giúp dễ dàng điều hướng cho trình kết xuất đã cho của bạn.

Bằng cách này, điều hướng trở nên rất tự nhiên và bạn thậm chí có thể sử dụng cùng một bộ đệm cho cả dò tia và rasterization.

Bindless thay đổi hoàn toàn trò chơi, cung cấp cho GPU của bạn tất cả dữ liệu bạn cần để thực hiện các kỹ thuật kết xuất hiện đại.

Bạn thậm chí có thể tiến xa hơn và sử dụng kiến trúc này để đặt GPU vào ghế lái và áp dụng các đường ống gián tiếp thông qua bộ đệm lệnh gián tiếp và loại bỏ GPU.

Chúng tôi nóng lòng muốn xem bạn đưa điều này vào thực tế như thế nào để cung cấp thế hệ ứng dụng và trò chơi đồ họa tiếp theo.

Cảm ơn bạn và tận hưởng phần còn lại của WWDC 2021!

♪