10017

♪ ♪

Xin chào mọi người.

Tôi là Michael LeHew từ nhóm Core Data.

Và hôm nay, tôi thực sự vui mừng được nói chuyện với bạn về một số cải tiến mà nhóm đã thực hiện để làm việc với Core Data và Swift trở thành một trải nghiệm thực sự tuyệt vời.

Tôi sẽ bắt đầu với một bài đánh giá về cách Core Data là một giải pháp tuyệt vời cho nhu cầu bền bỉ dữ liệu của khách hàng trên tất cả các nền tảng của Apple.

Sau đó, tôi sẽ tiếp tục thảo luận về một số cách mà Core Data đã áp dụng các cơ hội đồng thời mới trong thời gian chạy Swift.

Tiếp theo, tôi sẽ đề cập đến một số cải tiến mà chúng tôi đã thực hiện đối với API dữ liệu cốt lõi để làm cho mã của bạn biểu cảm hơn trong Swift.

Và sau đó kết thúc cuộc thảo luận bằng việc khám phá các khả năng động mà Core Data đang bổ sung vào hỗ trợ SwiftUI hiện có của chúng tôi mà chúng tôi đã giới thiệu vào năm 2020.

Tuy nhiên, hãy bắt đầu từ đầu, bất kể bạn đang phát triển nền tảng Apple nào, bạn chỉ cần có một ứng dụng.

Tại một thời điểm nào đó, ứng dụng của bạn cuối cùng sẽ gặp phải dữ liệu người dùng và bạn có thể sẽ cần lưu trữ nó ở đâu đó.

Một lựa chọn tuyệt vời cho nhu cầu đó là sử dụng Dữ liệu cốt lõi.

Core Data là khung đặc trưng của Apple dành cho các nhà phát triển ứng dụng, những người mong muốn duy trì dữ liệu người dùng của họ một cách mạnh mẽ và giàu tính năng.

Khung này giải quyết nhiều phức tạp của việc quản lý dữ liệu người dùng một cách thích hợp, từ cách nó được biểu diễn dưới dạng biểu đồ đối tượng trong bộ nhớ đến cách nó được mô hình hóa trong lưu trữ.

Khuôn khổ cũng trải qua những nỗ lực tuyệt vời để quản lý các cân nhắc quan trọng về thời gian chạy, như sử dụng bộ nhớ và độ trễ.

Các khả năng được cung cấp bởi khuôn khổ cũng có thể mở rộng.

Bạn có thể bắt đầu với một cửa hàng đơn giản, liên tục cục bộ và mở rộng để sử dụng nhiều ngữ cảnh thực thi để cải thiện hiệu suất và thậm chí tạo ra trải nghiệm dữ liệu được chia sẻ mạnh mẽ thông qua CloudKit.

Dữ liệu cốt lõi cũng hoạt động trên tất cả các nền tảng do Apple hỗ trợ.

Và tôi thực sự muốn nhấn mạnh điểm cuối cùng này.

Khi bạn bắt đầu sử dụng Core Data, mọi thứ bạn học sẽ hoạt động trên từng nền tảng của chúng tôi, từ máy Mac, đến iPhone hoặc thậm chí là Apple Watch của bạn.

Và, tất nhiên, Core Data cũng hoạt động tốt trong Swift.

Trong vài năm qua, chúng tôi đã tiếp tục nâng cao Core Data API để thể hiện rõ nhất có thể trong Swift.

Và đây là một năm khá thú vị đối với Swift với sự ra đời của các tính năng đồng thời hoàn toàn mới trong ngôn ngữ và thời gian chạy.

Kể từ khi thành lập, Core Data luôn quan tâm đến việc chạy mã đồng thời và có một lý do thực sự chính đáng cho việc này.

Dữ liệu tồn tại đòi hỏi phải đọc và ghi vào một số phương tiện lưu trữ bên ngoài và điều này làm cho việc hỗ trợ mô hình đồng thời mới trở nên phù hợp tự nhiên.

Hãy cùng khám phá cách thức hoạt động của nó trong bối cảnh ứng dụng mẫu Động đất của chúng tôi.

Ứng dụng này đọc nguồn cấp dữ liệu từ Cơ quan Khảo sát Địa chất Hoa Kỳ và sử dụng Dữ liệu Cốt lõi để lưu trữ thông tin về các trận động đất gần đây, chẳng hạn như cường độ, vị trí và ngày xảy ra sự kiện.

Về mặt kiến trúc, Earthquakes là một ứng dụng Swift có ngữ cảnh xem để điều khiển giao diện người dùng và bối cảnh nền để nhập dữ liệu do USGS cung cấp.

Mẫu của chúng tôi có một vùng chứa cục bộ cho ứng dụng của chúng tôi và thu thập dữ liệu động đất từ nguồn cấp dữ liệu JSON của USGS.

Khi chúng tôi tải xuống dữ liệu, chúng tôi chuyển nó cho trình phân tích cú pháp JSON của mình và sau đó nhập nó vào ngữ cảnh nền của chúng tôi để biến thành các đối tượng được quản lý và lưu vào cửa hàng cục bộ của chúng tôi.

Bối cảnh chế độ xem sau đó hợp nhất các thay đổi để cập nhật giao diện người dùng của chúng tôi một cách kỳ diệu.

Vào năm 2020, chúng tôi tập trung vào cách xử lý hiệu quả dữ liệu này thông qua việc sử dụng các hoạt động hàng loạt.

Tuy nhiên, bây giờ, tôi muốn tập trung vào cách chúng tôi thực hiện đồng thời các thao tác này.

Đặc biệt, tôi muốn tập trung vào ba bước mà chúng tôi thực hiện để nhập dữ liệu vào ứng dụng.

Bước một là tải xuống dữ liệu thô và sau khi tải xuống thành công, ứng dụng cần chuyển đổi nó thành đại diện cục bộ cụ thể của chúng tôi.

Và cuối cùng, lưu các đối tượng mới vào cửa hàng liên tục.

Hãy tiếp tục và chuyển đổi cái này thành mã cấp cao.

Tôi đã trừu tượng hóa mỗi thao tác thành chức năng hoặc đóng riêng của nó.

Đầu tiên, ứng dụng truy xuất dữ liệu thô từ máy chủ, xử lý nó thành một biểu diễn cục bộ thuận tiện và sau đó nhập các đối tượng vào Dữ liệu cốt lõi bằng cách thực hiện yêu cầu chèn hàng loạt trên ngữ cảnh đối tượng được quản lý nền.

Được viết như thế này, việc hình dung các nút thắt cổ chai tiềm ẩn sẽ dễ dàng hơn một chút.

Tải dữ liệu qua mạng sẽ là một cơ hội tuyệt vời để xem xét thực hiện công việc của chúng tôi một cách không đồng bộ.

Chuyển đổi cũng có thể là một nơi để xem xét.

Ngoài ra, việc nhập dữ liệu vào cửa hàng liên tục của chúng tôi có vẻ khá cơ hội.

Tuy nhiên, trong lịch sử, trong tất cả các trường hợp này, bạn sẽ cần phải tự mình thực hiện bất kỳ cơ chế không đồng bộ nào như vậy hoặc dựa nhiều vào việc triển khai theo khuôn khổ cụ thể.

Hãy nói về sự trừu tượng cụ thể của Core Data.

Trong trường hợp Dữ liệu cốt lõi, khi bạn gọi performAndWait, ngữ cảnh đối tượng được quản lý sẽ thực hiện đóng được cung cấp trong môi trường thực thi được bảo vệ của riêng nó.

Điều này có khả năng kết nối chuỗi cuộc gọi cho đến khi công việc hoàn tất.

Nếu chúng ta hình dung điều này, chúng ta có thể tưởng tượng ba khối mã mà tôi đã gắn nhãn TRƯỚC, TRONG VÀ SAU.

Khi mã của chúng tôi chạy, trước tiên mã được gắn nhãn TRƯỚC sẽ có cơ hội thực thi trên luồng gốc.

Sau đó, chúng tôi gọi performAndWait và chuỗi gọi sẽ chặn cho đến khi công việc xảy ra TRONG QUÁ TRÌNH đóng hoàn tất.

Khi công việc đó được hoàn thành, mã được mô tả SAU sẽ thực thi.

Tất nhiên, nếu bạn không cần đợi việc đóng cửa kết thúc, chúng tôi luôn cung cấp một biến thể hoàn toàn không đồng bộ.

Nhưng mới trong năm nay, Swift đã đạt được mô hình đồng thời mạnh mẽ với tích hợp ngôn ngữ sâu cho phép Dữ liệu cốt lõi mô tả chính xác hơn ý định của API của chúng tôi.

Cú pháp hơi khác một chút.

Bạn yêu cầu chờ kết quả thực hiện, nhưng mô hình tinh thần để sử dụng API mới này hoàn toàn giống với đối tượng được quản lý luôn hỗ trợ.

Tuy nhiên, lợi ích là tính đồng thời không còn là chi tiết triển khai ẩn nữa, mà thay vào đó được tích hợp sâu vào ngôn ngữ Swift.

Bởi vì điều này, trình biên dịch có thể tự động ngăn chặn nhiều lỗi đồng thời phổ biến, chẳng hạn như các cuộc đua dữ liệu và bế tắc, và thậm chí sử dụng hiệu quả các tài nguyên khi các tác vụ được biết là đang chờ kết quả.

Hãy quay lại mã và xem việc sử dụng cái này trong thực tế như thế nào.

Như chúng ta đã thấy, bạn yêu cầu chờ đợi một chức năng khai báo không đồng bộ.

Điều này có khả năng tạm dừng ngữ cảnh thực thi cuộc gọi cho đến khi hàm không đồng bộ mang lại quyền kiểm soát bằng cách trả về.

Nó cũng hoạt động liền mạch với việc xử lý lỗi có cấu trúc hiện có của Swift bằng cách định tuyến bất kỳ lỗi ném nào đến khung cuộc gọi, giống như bạn mong đợi.

Bây giờ chúng ta đã thấy một ví dụ về việc gọi một hàm không đồng bộ, chúng ta hãy xem cách chúng được khai báo bằng cách xem xét cách hoàn toàn mới của Core Data để thực hiện công việc không đồng bộ trong bối cảnh đối tượng được quản lý.

Có khá nhiều chức năng được đóng gói trong khổ thơ nhỏ này của mã Swift, nhưng tôi sẽ chỉ nói về một vài chi tiết quan trọng, và sau đó chúng ta sẽ nhảy vào chỉ ra cách bạn có thể sử dụng nó trong thực tế.

Bắt đầu với việc tuyên bố quá tải thực hiện mới.

Bạn có thể thấy nó chung chung dựa trên loại kết quả mà nó có thể trả về và được trang trí bằng từ khóa không đồng bộ mới, chọn chức năng này vào các khả năng đồng thời mới trong Swift.

Có lẽ khía cạnh quan trọng nhất của API mới này là việc đóng được cung cấp hiện cho phép bạn ném lỗi hoặc trả về giá trị, giúp bạn tiết kiệm nỗ lực định tuyến chúng trở lại khung gọi bằng tay.

Hãy xem điều này thú vị như thế nào bằng cách khám phá một vài kịch bản khác nhau.

Trong lịch sử, vì sự đồng thời đang ẩn bên trong việc triển khai của chúng tôi, một trong những cách duy nhất để định tuyến lỗi bên ngoài performAndWait là đóng một tùy chọn và sau đó kiểm tra nó sau đó.

Điều này có thể phức tạp hơn nếu bạn đang sử dụng các phiên bản thực hiện hoàn toàn không đồng bộ vì bạn cần phải làm nhiều hệ thống ống nước bằng cách chuyển các trình xử lý hoàn thành xung quanh và đảm bảo rằng bạn đã sử dụng chúng một cách nhất quán.

Với mô hình đồng thời mới trong Swift, tất cả hệ thống ống nước đó đều được xử lý cho bạn!

Chỉ cần thử và chờ đợi công việc không đồng bộ của bạn, và nếu xảy ra lỗi, chỉ cần ném nó đi, và mọi thứ sẽ thư giãn vào khung cuộc gọi một cách tự nhiên.

Vì vậy, bây giờ, chúng tôi tập trung vào các lỗi, nhưng còn kết quả thì sao?

Chà, mọi thứ tôi đã mô tả đều hoạt động giống hệt nhau.

Hãy xem xét một ví dụ cụ thể.

Hãy phác thảo những gì chúng ta muốn làm trước khi nhảy vào mã.

Đối với ví dụ này, tôi muốn định cấu hình yêu cầu tìm nạp để xác định số lượng trận động đất đã xảy ra trong năm giờ qua.

Như một câu, đây là một nhiệm vụ đơn giản để mô tả.

Nhưng trong mã, chúng ta sẽ cần sắp xếp lại mọi thứ một chút.

Trước tiên chúng ta sẽ cần tìm ra khi nào năm giờ trước, chúng ta có thể sử dụng API Lịch để tính toán điều này một cách mạnh mẽ.

Sau đó, chúng tôi sẽ định cấu hình một yêu cầu tìm nạp với một vị ngữ theo ngày đó và yêu cầu loại kết quả đếm.

Trong mã, nó trông khá giống kế hoạch của chúng tôi.

Chúng tôi sử dụng API bù của Lịch để tính toán năm giờ trước bây giờ, và sau đó định cấu hình Quake FetchRequest để trả về kết quả đếm với vị ngữ khớp với ngày mà chúng tôi quan tâm.

Trong lịch sử, kết quả trả về theo một mô hình tương tự như cách chúng tôi bắt lỗi.

Bạn sẽ đóng bất kỳ trạng thái nào mà bạn cần đột biến, thực hiện các phép tính của mình trong ngữ cảnh đối tượng được quản lý và sau đó, sử dụng kết quả sau khi lấy lại quyền kiểm soát.

Bây giờ, chúng ta có thể chỉ cần thử và chờ kết quả của cuộc gọi thực hiện của chúng ta và trả lại kết quả để thực hiện trực tiếp cho khung cuộc gọi của chúng ta.

Phần còn lại của mã hoàn toàn giống nhau.

Đó chỉ là định tuyến giá trị thủ công mà chúng tôi tránh cùng với bất kỳ lỗi hoặc sắc thái tiềm ẩn nào mà mã đó có thể có.

Mã mới này khá ngắn gọn và biểu cảm.

Tuy nhiên, điều đáng nói là có những lúc bạn nên thận trọng.

Hãy xem xét một ví dụ khác để xem tại sao.

Ví dụ này cố gắng trả lại trận động đất gần đây nhất như một vật thể được quản lý.

Mặc dù API mới giúp việc trả về các giá trị thực sự dễ dàng, nhưng không an toàn khi trả về các đối tượng được quản lý đã được đăng ký vào ngữ cảnh đối tượng được quản lý.

Chỉ hợp lệ khi tham khảo các đối tượng đã đăng ký như vậy trong phần đóng của cuộc gọi để thực hiện.

Thay vào đó, nếu bạn cần tham khảo một đối tượng được quản lý giữa các ngữ cảnh thực thi khác nhau, hãy sử dụng ID đối tượng và tìm nạp lại khi cần hoặc sử dụng tùy chọn biểu diễn từ điển của yêu cầu tìm nạp.

Bây giờ trước khi chúng ta xem xét thêm một ví dụ nữa, tôi muốn đề cập đến một chi tiết mà tôi chưa nói đến.

Và chi tiết đó là ScheduledTaskType.

Cho đến nay, mọi hiệu suất không đồng bộ mà chúng ta đã thấy đều về giá trị mặc định cho tùy chọn này: .immediate.

Có một tùy chọn thứ hai được gọi là .enqueued và để hiểu sự khác biệt giữa hai cách tiếp cận lập lịch này, bạn nên suy nghĩ về những gì cụ thể xảy ra bên trong bối cảnh đối tượng được quản lý khi bạn yêu cầu lên lịch làm việc.

Như chúng ta đã thấy, .immediate hoạt động rất giống phiên bản Swift-async-aware của performAndWait.

Nếu bạn đang chạy trên một ngữ cảnh thực thi khác và yêu cầu chờ công việc được thực hiện trên ngữ cảnh nền, bạn sẽ đợi cho đến khi nó được lên lịch và hoàn thành.

Tuy nhiên, nếu bạn đã ở trong cùng một bối cảnh thực hiện, công việc sẽ được lên lịch một cách lạc quan ngay lập tức.

.Enqueued, mặt khác, đơn giản hơn một chút.

Nó chỉ đơn giản là luôn chỉ thêm công việc được yêu cầu vào cuối bộ công việc của ngữ cảnh, bất kể mối quan hệ của trang web cuộc gọi ban đầu.

Hãy tiếp tục và xem thêm một ví dụ nữa.

Tất cả các tính năng không đồng bộ này cũng có thể được bạn áp dụng.

Ở đây, tôi đã tính đến logic nhập mà chúng ta đã nói đến thành một hàm importQuakes mới, được trang trí bằng từ khóa không đồng bộ mới.

Đến lượt nó, chức năng này được triển khai theo chức năng không đồng bộ khác.

Giờ đây, bất kỳ ai cũng có thể chờ đợi chức năng mới này để tận dụng các tính năng đồng thời mới trong Swift.

Hãy tóm tắt những gì chúng ta đã thấy cho đến nay.

Nhìn chung, API mới này mang lại sự hỗ trợ cho tính đồng thời có cấu trúc của Swift ngay vào Dữ liệu cốt lõi.

Các biến thể mới của API thực hiện chỉ là các phiên bản nhận biết đồng thời Swift của API Dữ liệu Cốt lõi hiện có mà bạn đã biết và yêu thích.

Chúng tôi đặc biệt khuyến khích bạn tận dụng API mới này trong các ứng dụng của mình.

Hơn nữa, NSManagedObjectContext không phải là loại duy nhất trong Dữ liệu cốt lõi hỗ trợ thực hiện các tác vụ trong miền đồng thời được bảo vệ của nó.

Chúng tôi cũng đang thêm API tương tự cho cả NSPersistentContainer và NSPersistentStoreCoordinator.

Hình dạng và hành vi chung của các API này khá giống với những gì tôi đã mô tả.

Nhưng với tất cả sức mạnh đồng thời đó, tôi sẽ thiếu sót nếu không đưa ra lời khuyên về việc sử dụng các công cụ gỡ lỗi hiện có theo ý của bạn.

Tất nhiên, địa chỉ và chất khử trùng luồng do Xcode cung cấp cực kỳ hữu ích để phát hiện các lỗi mà bạn thậm chí có thể không biết đã tồn tại.

Cả hai đều có thể được tìm thấy trong ngăn Chẩn đoán của cài đặt Chạy của trình chỉnh sửa sơ đồ.

Mỗi chất khử trùng phát hiện các loại vấn đề khác nhau, bao gồm xác thực các giả định sử dụng bộ nhớ an toàn và sử dụng dữ liệu thích hợp từ nhiều luồng.

Luôn luôn là một ý tưởng tốt để đủ điều kiện cho các ứng dụng của bạn và các thử nghiệm liên quan của chúng với cả hai chất khử trùng trước khi bạn phát hành phần mềm của mình cho cộng đồng người dùng của mình.

Và trong khi các chất khử trùng hữu ích trong mọi ngữ cảnh, tôi cũng muốn nhấn mạnh rằng Dữ liệu cốt lõi cung cấp một cờ thời gian chạy đặc biệt mà bạn có thể kích hoạt để nhận được nhiều trợ giúp cụ thể hơn cho miền.

Bằng cách bật tùy chọn này, Dữ liệu cốt lõi sẽ bật một số xác nhận hữu ích để xác thực các khóa bên trong và xác nhận việc sử dụng phù hợp các loại Dữ liệu cốt lõi khác nhau.

Áp dụng hỗ trợ đồng thời Swift không phải là thay đổi duy nhất được thực hiện đối với Dữ liệu cốt lõi trong năm nay.

Mọi API mới mà chúng tôi đang giới thiệu, từ chia sẻ CloudKit đến tích hợp Spotlight mới, đã được tạo ra với cách trình bày của nó trong Swift.

Năm nay, chúng tôi có một phiên riêng cho từng chủ đề này và tôi khuyến khích bạn kiểm tra chúng.

Chúng tôi cũng đã vượt qua toàn bộ khuôn khổ để xác định những nơi khác mà chúng tôi có thể cải thiện Swift và tôi muốn cho bạn thấy một vài trong số này ngay bây giờ, bắt đầu với các loại cửa hàng liên tục khác nhau mà chúng tôi hỗ trợ.

Nhớ lại, các cửa hàng liên tục mô tả cách bạn thực sự muốn lưu trữ dữ liệu của khách hàng.

Core Data hiện cung cấp bốn cửa hàng như vậy: XML, nhị phân, trong bộ nhớ và SQLite.

Và bạn sử dụng những số nhận dạng này mọi lúc.

Mới trong năm nay, chúng tôi đã tiếp tục và đặt những cái tên tự nhiên hơn này trong Swift.

Các tên hiện có sẽ tiếp tục hoạt động, nhưng API mới tiêu thụ chúng sẽ tiện dụng hơn rất nhiều do tên ngắn hơn và khả năng tự động hoàn thành các ký hiệu này.

Tất nhiên, các cửa hàng liên tục không phải là thứ duy nhất trong Dữ liệu cốt lõi liên quan đến các loại.

Xét cho cùng, khuôn khổ là tất cả về việc lưu trữ dữ liệu đã nhập và các loại như vậy được mô tả bằng các mô tả thuộc tính.

Và năm nay, chúng tôi sẽ thêm một bảng liệt kê mở rộng mới vào mô tả thuộc tính cung cấp cú pháp tự nhiên hơn nhiều để làm việc với các loại của chúng.

Chúng ta hãy xem xét những điều này đang hoạt động bằng cách viết một bài kiểm tra đơn vị có thể xác nhận rằng mô hình thời gian chạy của chúng tôi phù hợp với những gì chúng tôi đã thiết kế trong trình tạo mô hình Xcode.

Để đơn giản, chúng tôi sẽ chỉ cố gắng xác thực một loại thời gian chạy duy nhất được xác định bởi mô hình vật thể động đất của chúng tôi, nhưng bạn có thể tưởng tượng điều này sẽ mở rộng như thế nào.

Đây có vẻ như là một bài kiểm tra nhỏ để viết, nhưng đó là một điều tốt để xác nhận vì nó có thể tăng tốc các chẩn đoán thú vị hơn trong tương lai.

Để viết bài kiểm tra này, chúng tôi sẽ viết một hàm trợ giúp nhanh về loại thuộc tính mới.

Hãy tiếp tục và mô tả chức năng này ngay bây giờ.

Chúng ta sẽ bắt đầu với chữ ký, mong đợi một tên thuộc tính, mô tả thực thể mà chúng ta quan tâm và loại, được mô tả dưới dạng liệt kê AttributeType mới.

Định nghĩa của tiện ích này khá đơn giản.

Trước tiên, chúng tôi xác nhận rằng chúng tôi có một thuộc tính với tên được cung cấp, không đạt bài kiểm tra nếu chúng tôi không thể tìm thấy nó.

Và sau đó chúng tôi xác nhận rằng loại thuộc tính là như mong đợi.

Và đó thực sự là tất cả những gì cần làm.

Chúng tôi có thể lặp lại điều này cho từng thực thể và tài sản và yên tâm rằng hành vi thời gian chạy của chúng tôi phù hợp với mô hình mà chúng tôi đã xác định.

Và đây chỉ là một ví dụ về một số cải tiến công thái học mà chúng tôi đã thực hiện đối với việc liệt kê Dữ liệu Cốt lõi trong Swift trong năm nay.

Cho đến bây giờ, tôi đã tập trung vào rất nhiều tương tác khung cấp thấp hơn và cách chúng thể hiện trong Swift, nhưng còn việc trình bày dữ liệu cho người dùng của bạn thì sao?

Vào năm 2020, chúng tôi đã giới thiệu một số tiện ích khi làm việc với Core Data trong SwiftUI.

Và bây giờ, đồng nghiệp của tôi, Scott, có khá nhiều điều để chia sẻ với bạn về những cải tiến mới mà chúng tôi đang giới thiệu trong năm nay.

Scott?

Cảm ơn, Michael!

Có một loạt các cải tiến đối với trải nghiệm sử dụng Dữ liệu cốt lõi với SwiftUI trong năm nay, bắt đầu với việc giải quyết thực thể lười biếng trong các yêu cầu tìm nạp, giúp giảm yêu cầu các ứng dụng phải thiết lập ngăn xếp Dữ liệu cốt lõi trước khi chúng xây dựng chế độ xem của mình.

Cũng trong năm nay, các yêu cầu tìm nạp nhận cấu hình động cho các mô tả và vị ngữ sắp xếp của chúng.

Và có một loại yêu cầu tìm nạp mới trong thị trấn hỗ trợ tìm nạp theo phân đoạn.

Tôi sẽ xem qua từng thứ này bằng ứng dụng mẫu Động đất của chúng tôi mà Michael đã đề cập trước đó trong buổi nói chuyện, bắt đầu với giải pháp thực thể lười biếng.

Có lẽ trong ứng dụng của bạn, bạn có một số mã như thế này.

Thuộc tính vùng chứa này ở đây không thực sự cần thiết để hỗ trợ mã trong loại này, hoặc thậm chí là ứng dụng rộng hơn.

Tất cả những thứ đó nhận được những gì nó cần trực tiếp từ loại QuakesProvider.

Không, thuộc tính này tồn tại để đảm bảo ngăn xếp Dữ liệu Cốt lõi đã được thiết lập trước khi bất kỳ chế độ xem nào trong môi trường cố gắng tham chiếu đến bất kỳ thực thể nào trước khi mô hình được tải.

Xem ở đây rằng công cụ sửa đổi chế độ xem môi trường được gọi sau khi ContentView đã được khởi tạo.

Thủ thuật này không còn cần thiết nữa khi triển khai chống lại SDK của năm nay.

Trình bao bọc thuộc tính FetchRequest hiện tìm kiếm các thực thể theo tên một cách lười biếng tại thời điểm tìm nạp, tại thời điểm đó môi trường đã đảm bảo rằng ngăn xếp Dữ liệu Cốt lõi đã được thiết lập, vì vậy bây giờ an toàn để xóa thuộc tính này...

Và chỉ cần tham khảo...

QuakesProvider chia sẻ vùng chứa trực tiếp trong cuộc gọi môi trường.

Chuyển sang một số API mới, FetchRequest hiện hỗ trợ cấu hình động.

Có hai thuộc tính mới trên giá trị được bọc để thay đổi trực tiếp vị ngữ của yêu cầu cũng như các bộ mô tả sắp xếp của nó, được thể hiện cả với NSSortDescriptors mà bạn đã quen cũng như loại giá trị SortDescriptor mới cung cấp sự tiện lợi và an toàn hơn khi tìm nạp các thực thể với các lớp con đối tượng được quản lý

Và cuối cùng, có một ràng buộc cấu hình với cùng một tập hợp các thuộc tính như giá trị được bọc để tích hợp dễ dàng hơn với các chế độ xem.

Trước API mới này, tôi sẽ phải thiết kế các chế độ xem của mình để các tham số sắp xếp và vị ngữ được truyền qua trình khởi tạo của chế độ xem, nhưng điều đó khiến việc hỗ trợ những thứ như định cấu hình yêu cầu tìm nạp của tôi bằng cách sử dụng các điều khiển trên thanh công cụ thực sự khó khăn.

Ma sát này được loại bỏ bởi các thuộc tính cấu hình động mới này và tôi muốn chỉ cho bạn cách sử dụng chúng bằng cách thêm sắp xếp và lọc vào ứng dụng mẫu Động đất.

Trước tiên hãy xem xét các mô tả sắp xếp.

Theo mặc định, ứng dụng Earthquakes sắp xếp theo thời gian gần đây, nhưng tôi cũng muốn sắp xếp chúng theo cường độ, vì vậy tôi sẽ thêm một menu cho phép tôi kiểm soát thứ tự kết quả.

Tôi sẽ bắt đầu bằng cách thêm một mảng tĩnh của các bộ...

Chứa các mô tả sắp xếp mà tôi muốn hỗ trợ cũng như tên cho chúng.

Xem ở đây rằng họ cũng đang sử dụng loại SortDescriptor mới.

Tôi cũng sẽ muốn một chút tiểu bang để theo dõi thứ tự sắp xếp mà tôi hiện đang sử dụng.

Tôi đã tạo một loại cho cái này, vì vậy tôi sẽ thêm nó làm thuộc tính của chế độ xem nội dung.

Bây giờ tôi sẽ thêm một menu thanh công cụ vào chế độ xem danh sách...

Điều đó sửa đổi sắp xếp đã chọn cũng như công cụ sửa đổi onChange cập nhật các bộ mô tả sắp xếp của yêu cầu tìm nạp.

Bây giờ trong bản xem trước, chúng ta có thể thấy menu mới và tôi có thể sử dụng nó để sắp xếp các trận động đất theo cường độ.

Tuyệt vời!

Bây giờ để thêm bộ lọc.

Tôi muốn lọc dựa trên vị trí của trận động đất.

Điều đầu tiên tôi cần là một số trạng thái cho văn bản của trường tìm kiếm.

Và tôi sẽ tạo ra một tài sản ràng buộc...

Cho trường tìm kiếm cập nhật yêu cầu tìm nạp.

Với những thứ đó tại chỗ, tất cả những gì tôi cần là giao diện người dùng.

Thuận tiện...

Có thể tìm kiếm có một liên kết với một chuỗi, vì vậy chúng ta có thể đặt nó ngay tại đây.

Bây giờ trong bản xem trước của chúng tôi, chúng tôi có thể thu hẹp tất cả các trận động đất gần một nơi phù hợp với bánh sandwich bằng cách chỉ cần gõ "bánh sandwich" vào lĩnh vực mới này ở đây.

Và đó là cấu hình động cho FetchRequest.

Một phần chức năng thường được yêu cầu khác là hỗ trợ tìm nạp theo từng phần, xuất hiện trong năm nay dưới dạng một loại trình bao bọc thuộc tính mới được gọi là SectionedFetchRequest.

Loại này hỗ trợ các thuộc tính cấu hình động mới giống như FetchRequest, nhưng nó được khởi tạo với một tham số bổ sung, một đường dẫn chính đến một thuộc tính xác định phần, rất giống NSFetchedResultsController.

Nhưng không giống như bộ điều khiển kết quả được tìm nạp, thuộc tính xác định phần có thể có bất kỳ loại nào bạn thích, miễn là nó có thể băm được.

Điều này được mã hóa trong hệ thống kiểu sử dụng một tham số chung bổ sung trên SectionedFetchRequest.

Cuối cùng, loại mới này bao bọc một loại kết quả hai chiều.

SectionedFetchResults là một tập hợp các phần, mỗi phần tự nó là một tập hợp các kết quả.

Mỗi phần cũng có một thuộc tính với mã định danh phần.

Điều này thực sự dễ áp dụng, vì vậy tôi sẽ thêm tìm nạp phân đoạn vào ứng dụng Earthquakes.

Đầu tiên, tôi cập nhật khai báo FetchRequest của mình.

Quake đã có một tài sản trong ngày, vì vậy tôi sẽ sử dụng nó cho đường dẫn chính phân đoạn.

Tiếp theo, tôi cần cập nhật thuộc tính cơ thể...

Để phù hợp với loại kết quả được phân đoạn mới.

Vòng lặp bên ngoài ở đây lặp lại các phần, vì vậy tôi đang phát ra chế độ xem Phần ở đây và bản thân mỗi phần là một tập hợp các Trận động đất, vì vậy ForEach bên trong này lặp lại phần đó, giống như tôi đã lặp lại kết quả trước đây.

Nếu chúng ta xem qua bản xem trước, bây giờ tôi đã có các trận động đất được sắp xếp theo thời gian và được phân đoạn theo ngày.

Và SwiftUI thậm chí còn cung cấp cho tôi hỗ trợ tự động cho các phần thu gọn.

Loại SectionedFetchRequest mới này hỗ trợ các thuộc tính cấu hình động giống như FetchRequest cũng như một thuộc tính cấu hình bổ sung cho đường dẫn khóa nhận dạng phần.

Điều này cực kỳ quan trọng vì chúng tôi không thực sự an toàn để thay đổi việc phân loại nữa.

Nó có thể khiến các phần không liền kề nhau vì thời gian và cường độ động đất không tương quan hoàn hảo, điều này có lẽ là tốt nhất.

Để khắc phục điều này, tôi cần cập nhật các loại hàng đầu...

Vì vậy mỗi cái có một đường dẫn khóa nhận dạng phần tương ứng.

Tiếp theo, xuống thanh công cụ...

Tôi cần cập nhật đường dẫn khóa nhận dạng phần mỗi khi tôi cập nhật các mô tả sắp xếp.

Nhưng đây là phần quan trọng.

Các thay đổi đối với yêu cầu được cam kết bất cứ khi nào trình nhận kết quả được gọi, vì vậy để cập nhật cả sắp xếp và phân đoạn một cách an toàn...

Tôi cần cập nhật cấu hình trên một tham chiếu đến các kết quả mà tôi đã kéo vào một địa phương.

Bây giờ trong bản xem trước, chúng ta có thể thấy rằng việc thay đổi thứ tự cũng thay đổi phần.

Chúng ta có thể lật giữa các trận động đất được sắp xếp theo thời gian, được phân chia theo ngày và các trận động đất được sắp xếp và phân chia theo cường độ.

Và chúng ta đã có nó: khởi tạo ngăn xếp lười biếng, cấu hình động và tìm nạp phân đoạn, tất cả đều dễ dàng áp dụng cho một ứng dụng hiện có sử dụng iOS 15 và macOS Monterey.

Vì vậy, tóm lại, Core Data là cửa hàng một cửa của bạn để quản lý nhu cầu bền bỉ dữ liệu của ứng dụng trên tất cả các nền tảng của Apple.

Nó khai thác các tính năng đồng thời mới có sẵn trong Swift thông qua API thực hiện mới và vẫn có tính năng gỡ lỗi an toàn luồng mạnh mẽ được tích hợp ngay trong đó.

Nó có các giao diện liệt kê mới giúp các loại lưu trữ và thuộc tính trở nên tự nhiên hơn khi sử dụng trong Swift, cộng với chia sẻ CloudKit và tích hợp Spotlight.

Và việc kết nối dữ liệu của bạn với chế độ xem của bạn dễ dàng hơn bao giờ hết bằng SwiftUI với cấu hình động và tìm nạp phân đoạn.

Có rất nhiều thứ mới để tìm hiểu liên quan đến những chủ đề này.

Chúng tôi khuyên bạn nên kiểm tra các bộ sưu tập "Đơn giản hóa với SwiftUI và Gặp gỡ Swift Concurrency."

Và thế là xong!

Tôi thực sự mong chờ được xem tất cả các bạn xây dựng những gì với các API mới này.

[Nhạc lạc quan].