10061

Donna: Xin chào.

Tôi là Donna Tom, và tôi là một kỹ sư TextKit.

Đồng nghiệp Chris Willmore của tôi sẽ tham gia cùng tôi sau trong video này.

Chúng tôi đang giới thiệu TextKit 2, công cụ văn bản thế hệ tiếp theo của Apple.

Để hiểu TextKit 2 là gì, hãy xem lại ngắn gọn TextKit gốc, mà chúng ta sẽ gọi là TextKit 1.

TextKit 1 là một công cụ văn bản điều khiển bố cục văn bản và hiển thị trên tất cả các nền tảng của Apple.

Điều khiển văn bản trong UIKit và AppKit sử dụng TextKit 1 để quản lý việc lưu trữ và kiểm soát bố cục của nội dung văn bản.

TextKit 1 lần đầu tiên xuất hiện trên hệ thống trong OpenStep hơn 20 năm trước.

Nó đã phát triển và phát triển cùng chúng tôi qua nhiều năm từ macOS 10.0 đến iOS 7 đến macOS 11 và iOS 14.

Thật tuyệt vời khi TextKit 1 vẫn cung cấp rất nhiều chức năng thiết yếu trên tất cả các thiết bị của Apple.

Các nguyên tắc thiết kế công nghệ và kỹ thuật đã thay đổi rất nhiều trong nhiều thập kỷ.

Vì TextKit 1 gắn liền với các nguyên tắc ban đầu của nó, nên việc cung cấp các API tích hợp tốt với các công nghệ mới hơn của chúng tôi trong khi vẫn mang lại tiêu chuẩn hiệu suất cao trở nên khó khăn hơn trong những năm qua.

Đó là lý do tại sao chúng tôi đã xây dựng TextKit 2.

TextKit 2 là công cụ văn bản thế hệ tiếp theo của Apple, được xây dựng trên một tập hợp các nguyên tắc thiết kế hướng tới tương lai.

Và đoán xem?

Bạn đã sử dụng TextKit 2 trên máy Mac của mình.

Trong Big Sur, chúng tôi đã cập nhật nhiều thành phần văn bản trên hệ điều hành để sử dụng TextKit 2 đằng sau hậu trường.

Bất ngờ lớn: bạn đã sử dụng TextKit 2 từ macOS 11.

Bây giờ, hãy xem lại ngắn gọn kiến trúc cho phép chúng tôi làm điều này.

TextKit 2 cùng tồn tại với TextKit 1.

Cũng giống như người tiền nhiệm của nó, TextKit 2 được xây dựng dựa trên Foundation, Quartz và Core Text.

Các điều khiển văn bản trong UIKit và AppKit được xây dựng trên TextKit 2.

TextKit 2 cũng giữ lại một cách lỏng lẻo thiết kế MVC của người tiền nhiệm của nó.

Phần xem vẫn nằm trong các đối tượng xem của khung UIKit và AppKit, trong khi có các phiên bản mới của những người bạn cũ của chúng tôi, NSTextStorage và NSLayoutManager.

Ngoài các phiên bản mới này, còn có nhiều lớp và giao thức mới tham gia vào các lớp mô hình và bộ điều khiển.

Có khá nhiều người trong số họ, nhưng đừng lo lắng.

Những thành phần mới này kết hợp đơn giản, tập trung và mạnh mẽ.

Chúng giúp bạn dễ dàng thể hiện những gì bạn muốn làm với văn bản của mình và ít lo lắng hơn về cách hệ thống hoàn thành những gì bạn muốn.

Bây giờ chúng ta đã có cái nhìn kiến trúc về hệ thống, hãy đi sâu vào chi tiết.

Đầu tiên, chúng ta sẽ thảo luận về các nguyên tắc thiết kế cốt lõi của TextKit 2 và cách các nguyên tắc này sẽ thay đổi cách bạn nghĩ về việc tùy chỉnh lưu trữ, bố cục và hiển thị văn bản trong ứng dụng của mình.

Sau đó, Chris sẽ hướng dẫn bạn qua ứng dụng mẫu TextKit 2 mà chúng tôi đã tạo ra để cộng tác trên một cuốn sách công thức nấu ăn.

Ứng dụng này sử dụng các lớp TextKit 2 mới để bố trí và hiển thị văn bản trong CALayers.

Tại đây, bạn sẽ được học cách các nguyên tắc thiết kế hoạt động trong thực tế.

Cuối cùng, chúng tôi sẽ đề cập đến một số chi tiết kỹ thuật quan trọng để hiện đại hóa các ứng dụng của bạn cho TextKit 2.

Vậy hãy bắt đầu với các nguyên tắc thiết kế.

Các nguyên tắc thiết kế cấp cao cốt lõi của TextKit 2 là tính chính xác, an toàn và hiệu suất.

Chúng tôi đã thực hiện một cách tiếp cận cân bằng.

Cả ba nguyên tắc đều quan trọng, vì vậy không có ưu tiên cho thứ tự mà chúng ta thảo luận về chúng.

Mỗi nguyên tắc thiết kế cấp cao này thông báo một sự thay đổi thiết kế cụ thể trong hệ thống.

Để chính xác, TextKit 2 tóm tắt việc xử lý glyph.

Để đảm bảo an toàn, TextKit 2 tập trung nhiều hơn vào ngữ nghĩa giá trị.

Và để đạt hiệu suất, TextKit 2 sử dụng bố cục và kết xuất dựa trên khung nhìn.

Chúng ta sẽ bắt đầu với sự đúng đắn.

Trong lĩnh vực này, chúng tôi đã trừu tượng hóa việc xử lý glyph để cung cấp trải nghiệm nhất quán cho văn bản quốc tế.

Các thiết bị của Apple được sử dụng ở mọi nơi trên thế giới, vì vậy điều thực sự quan trọng là cung cấp bố cục, kết xuất và tương tác chính xác cho văn bản bằng tất cả các ngôn ngữ và tập lệnh.

Chúng tôi muốn mọi người có thể đọc và tương tác với văn bản trên thiết bị của họ.

Và thiết kế của một số API TextKit 1 gây khó khăn cho việc làm việc với văn bản quốc tế theo cách chính xác trên toàn cầu.

Để hiểu tại sao, trước tiên chúng ta cần hiểu glyph là gì.

Một glyph là một biểu diễn trực quan của một số ký tự thay đổi.

Trong nhiều ngôn ngữ phương Tây, một glyph thường đại diện cho một ký tự, nhưng điều này không phải lúc nào cũng đúng.

Bạn có thể có nhiều glyphs đại diện cho một ký tự duy nhất, hoặc có thể ngược lại.

Một glyph duy nhất có thể đại diện cho nhiều ký tự.

Chữ tượng đơn lẻ này được sử dụng để đại diện cho nhiều ký tự được gọi là chữ ghép.

Không có quá nhiều chữ ghép trong các ngôn ngữ phương Tây và chúng thường không ảnh hưởng đến tính dễ đọc của văn bản.

Bạn vẫn có thể đọc nó tốt mà không cần chữ ghép.

Nhưng điều đó không đúng với tất cả các ngôn ngữ.

Các chữ viết như tiếng Ả Rập và Devanagari sử dụng rất nhiều chữ ghép, và chúng ảnh hưởng đến tính dễ đọc.

Kiểm tra từ này bằng chữ Ả Rập.

Đó là một từ tiếng Urdu có nghĩa là "khoảnh khắc".

Bây giờ hãy dành một chút thời gian để so sánh hai kết xuất này.

Từ đầy đủ, được vẽ bằng chữ ghép ở bên phải, xuất hiện rất khác so với các ký tự riêng lẻ ở bên trái.

Độc giả bản địa của ngôn ngữ sẽ coi phiên bản bên trái là không đọc được.

Nhiều API trong TextKit 1 yêu cầu làm việc với chỉ mục hoặc phạm vi glyph.

Ví dụ, để có được hình chữ nhật giới hạn của một số văn bản, bạn cần biết phạm vi glyph của văn bản bạn muốn.

Nếu văn bản bằng ngôn ngữ phương Tây, việc tìm ra phạm vi glyph phù hợp không quá tệ.

Trong ví dụ tiếng Anh này, khá dễ dàng để tìm phạm vi glyph cho bốn ký tự đầu tiên của văn bản.

Bây giờ hãy xem xét Kannada, một chữ viết và ngôn ngữ được nói bởi hàng triệu người ở Ấn Độ.

Nó không chỉ sử dụng nhiều chữ ghép, các glyphs có thể được sắp xếp lại và kết hợp theo đủ loại cách thú vị.

Từ Kannada này có nghĩa là "Tháng Mười" có một nguyên âm phân tách ở chỉ mục ký tự bốn, do đó được chia thành hai glyphs.

Sau đó, cái bên trái được sắp xếp lại giữa các glyph đại diện cho các ký tự một và hai trước khi chữ ghép cho hai được áp dụng.

Glyph đại diện cho ký tự ở chỉ mục ba cũng được thay thế bằng một dạng dính liền.

Trong từ cuối cùng, nó được vẽ bên dưới một trong những glyphs trong nguyên âm phân chia.

Bây giờ, nếu bạn không hiểu bất kỳ điều gì tôi vừa nói, điều đó hoàn toàn ổn.

Đây là những chi tiết mà khuôn khổ nên xử lý cho bạn để bạn có thể tập trung vào việc xây dựng ứng dụng của mình.

Vấn đề là, không thể tìm thấy phạm vi glyph cho bốn ký tự đầu tiên của văn bản như thế này.

Không có phạm vi glyph nào đại diện cho bốn ký tự đó.

Và vì nhiều API TextKit 1 yêu cầu phạm vi glyph, việc sử dụng các API đó có khả năng phá vỡ bố cục và kết xuất cho các tập lệnh phức tạp như thế này.

Và đó là lý do tại sao TextKit 2 tóm tắt việc xử lý glyph.

TextKit 2 hiển thị tất cả văn bản với Core Text-- vì vậy bạn sẽ tự động nhận được kết xuất chính xác cho các tập lệnh phức tạp.

Bạn sẽ không phải quản lý glyphs chút nào với TextKit 2.

Thay vào đó, bạn sử dụng các đối tượng cấp cao hơn để kiểm soát bố cục văn bản và tương tác.

Gặp gỡ NSTextSelection, một trong những đối tượng cấp cao hơn này.

Nó chứa tất cả các ngữ cảnh cần thiết để thể hiện một lựa chọn văn bản, chẳng hạn như độ chi tiết của nó, ái lực của nó và các phạm vi văn bản có thể rời rạc tạo nên lựa chọn.

Các thuộc tính này trên NSTextSelection chỉ được đọc, vì vậy bạn sẽ không sửa đổi các trường hợp của đối tượng lựa chọn để thay đổi chúng.

Thay vào đó, bạn sử dụng một phiên bản của NSTextSelectionNavigation để thực hiện các hành động trên các lựa chọn văn bản, nhận các phiên bản mới của NSTextSelection đại diện cho lựa chọn kết quả.

Bạn có thể yêu cầu đối tượng điều hướng cung cấp cho bạn các lựa chọn do các sự kiện nhấn hoặc chuột xuống tại một điểm trên màn hình hoặc nhận một lựa chọn mới do điều hướng về phía trước hoặc phía sau.

Điều này giúp việc làm mọi thứ dễ dàng hơn, như mở rộng lựa chọn về phía trước bằng một từ và nhận được kết quả chính xác, tính đến văn bản hai chiều bằng ngôn ngữ từ phải sang trái.

Bây giờ tôi muốn kêu gọi sự chú ý của bạn đến điều gì đó thú vị về các API lựa chọn mới này.

Phương pháp này lấy một NSTextLocation.

Đây là một đối tượng mới khác trong TextKit 2.

Gặp gỡ NSTextLocation và NSTextRange.

Chúng rất giống với các lớp UITextPosition và UITextRange từ UIKit, ngoại trừ việc bạn không bắt buộc phải phân lớp chúng.

Hầu hết thời gian, bạn sẽ sử dụng các đối tượng vị trí và phạm vi mặc định với TextKit 2.

Sử dụng các đối tượng thay vì số nguyên cho phép các mô hình tài liệu biểu cảm hơn vì các phạm vi được xác định theo các vị trí tương đối với nhau.

Mô hình đối tượng tài liệu HTML là một ví dụ điển hình về điều này.

Vì nó có các phần tử lồng nhau, một vị trí cần đại diện cho cả vị trí tuyệt đối trong tài liệu và cả vị trí trong văn bản hiển thị.

Điều này không thể được thể hiện bằng một chỉ số số duy nhất.

Và đó là nó cho sự chính xác.

Tiếp theo là sự an toàn.

Trong lĩnh vực này, chúng tôi đã thiết kế TextKit 2 với sự nhấn mạnh hơn vào ngữ nghĩa giá trị để phù hợp hơn với các mục tiêu của các công nghệ như Swift và SwiftUI.

Và khi tôi nói "ngật nghĩa giá trị", tôi không nói về các loại giá trị.

Chúng tôi đã không biến NSLayoutManager thành một cấu trúc.

Các loại giá trị giữ một bản sao duy nhất của dữ liệu của chúng, điều này ngăn chặn sự đột biến của dữ liệu đó.

Điều này làm cho mã của bạn an toàn và ổn định hơn bằng cách loại bỏ việc chia sẻ ngoài ý muốn và các tác dụng phụ liên quan.

Nhưng các loại giá trị không phải là cách duy nhất để có được lợi ích này.

Các lớp bất biến có các thuộc tính không thể thay đổi sau khi khởi tạo, điều này cũng ngăn chặn sự đột biến dữ liệu của chúng.

Các lớp này hoạt động giống như các kiểu giá trị, vì vậy chúng tôi gọi chúng là có ngữ nghĩa giá trị.

Nếu bạn muốn thay đổi dữ liệu trong một trong những đối tượng này, bạn phải tạo một phiên bản hoàn toàn mới để thay thế phiên bản gốc.

Và nhiều lớp học trong TextKit 2 được thiết kế theo cách này.

Để minh họa những lợi ích của sự thay đổi thiết kế này, hãy làm mới trí nhớ của chúng ta về thiết kế của TextKit 1.

Luồng văn bản từ bộ lưu trữ đến màn hình đã từng hoạt động như thế này.

Các bản cập nhật cho bộ lưu trữ văn bản đã thông báo cho trình quản lý bố cục, sau đó sẽ tạo các glyphs, định vị chúng và vẽ chúng trực tiếp vào chế độ xem.

Với cách tiếp cận vẽ glyphs trực tiếp vào chế độ xem, thật khó để tìm ra nơi tách văn bản để tạo khoảng trống cho bản vẽ tùy chỉnh.

Để hiểu ý tôi về điều đó, hãy xem ảnh chụp màn hình lén lút này từ ứng dụng mẫu, nơi tôi đã để lại một số nhận xét về công thức.

Chú ý cách nhận xét xuất hiện ngay bên dưới công thức mà nó đề cập đến và nó được vẽ bằng nền màu chàm, hình bong bóng và văn bản màu trắng khác biệt này.

Chúng ta nên thực hiện cách tiếp cận nào để chèn nhận xét vào đúng vị trí và làm cho chúng trông khác với phần còn lại của văn bản?

Bạn có thể mong đợi làm điều này bằng cách chia văn bản công thức thành các đơn vị hoặc yếu tố có ý nghĩa, đặt mỗi nhận xét vào phần tử riêng của nó và định vị từng nhận xét sau công thức mà nó liên quan, đồng thời cung cấp hướng dẫn về cách vẽ nhận xét.

Với TextKit 1, thực tế hoàn toàn khác.

Bạn phải lo lắng về rất nhiều chi tiết, như tìm chỉ mục glyph, đảm bảo rằng glyph không nằm ở giữa cụm đồ thị, điều chỉnh chỉ mục glyph đó nếu có, thay đổi khoảng cách dòng và có thể tùy chỉnh hình học phân mảnh đường.

Và những chi tiết này không liên quan đến những gì bạn đang cố gắng làm.

Vì vậy, với TextKit 2, chúng tôi đang hướng tới việc biến kỳ vọng thành hiện thực.

Chúng tôi đã thay đổi luồng văn bản thông qua hệ thống để có thể thực hiện các cách tiếp cận như thế này.

Đây là cách luồng đó hoạt động trong TextKit 2.

Các bản cập nhật cho bộ lưu trữ văn bản đi qua một đối tượng mới được gọi là trình quản lý nội dung.

Trình quản lý nội dung chia văn bản thành các yếu tố và theo dõi chúng.

Khi đến lúc bố cục, trình quản lý bố cục văn bản sẽ hỏi người quản lý nội dung về các yếu tố.

Sau đó, trình quản lý bố cục văn bản đưa ra các phần tử vào vùng chứa văn bản và tạo ra các đoạn bố cục có chứa thông tin bố cục và định vị.

Khi đến lúc hiển thị, các đoạn bố cục được chuyển cho ViewportLayoutController, bộ điều phối vị trí và bố cục của các đoạn đó trong bề mặt kết xuất mà bạn chọn, cho dù đó là chế độ xem hay lớp.

Như bạn có thể nói, có rất nhiều đối tượng mới tham gia vào quá trình này.

Và đây là nơi mà sự nhấn mạnh vào ngữ nghĩa giá trị xuất hiện.

Bạn kiểm soát bố cục và hiển thị văn bản của mình bằng cách kết nối vào hệ thống ở đúng điểm và lấy thông tin bạn cần từ các đối tượng sử dụng ngữ nghĩa giá trị.

Để thực hiện các thay đổi, bạn tạo các phiên bản mới của các đối tượng giá trị với các thay đổi bạn muốn và đưa chúng trở lại hệ thống.

Hệ thống sử dụng các giá trị từ các đối tượng thay thế của bạn để bố trí và hiển thị.

Vì vậy, bây giờ, hãy gặp những đối tượng mới này và xác định các điểm khác nhau của hệ thống nơi bạn có thể nhận hoặc thay thế chúng.

Chúng ta sẽ bắt đầu với các đối tượng lưu trữ.

Gặp gỡ NSTextElement.

Các yếu tố là các khối xây dựng tài liệu của bạn.

Mỗi phần tử đại diện cho một phần của nội dung và chứa một phạm vi mô tả vị trí của nó trong tài liệu.

Và các yếu tố có ngữ nghĩa giá trị.

Các thuộc tính của chúng, bao gồm phạm vi, là bất biến và không thể thay đổi sau khi tạo phần tử.

Mô hình hóa tài liệu như một chuỗi các yếu tố thay vì một loạt các ký tự mang lại cho chúng ta nhiều sức mạnh hơn.

Chúng tôi có được khả năng dễ dàng phân biệt loại nội dung mà một phần tử nhất định đại diện, cho dù đó là đoạn văn bản, tệp đính kèm hay một số loại tùy chỉnh khác.

Và chúng ta có thể đưa ra quyết định về cách bố trí các yếu tố dựa trên loại của chúng.

Bây giờ hãy gặp NSTextContentManager.

Người quản lý nội dung biết cách tạo các yếu tố từ nội dung văn bản và theo dõi phạm vi của các yếu tố đó trong tài liệu tổng thể.

Nó cũng biết cách làm việc với cửa hàng sao lưu và cách tạo các yếu tố mới với phạm vi cập nhật khi nội dung trong cửa hàng sao lưu thay đổi.

Hãy nghĩ về trình quản lý nội dung như một trình bao bọc cho cửa hàng hỗ trợ.

Trình quản lý nội dung cung cấp một giao diện để dịch dữ liệu thô thành các phần tử.

NSTextContentManager và NSTextElement đều là các loại trừu tượng, vì vậy bạn có thể phân lớp chúng nếu bạn cần sử dụng mô hình tài liệu tùy chỉnh hoặc cửa hàng sao lưu tùy chỉnh.

Các tiêu đề và tài liệu cung cấp hướng dẫn về cách thực hiện việc này.

Nhưng hầu hết thời gian, bạn có thể sử dụng những cái mặc định mà TextKit 2 cung cấp.

Gặp gỡ NSTextContentStorage và NSTextParagraph.

Đây là trình quản lý nội dung mặc định và các loại phần tử.

NSTextContentStorage là một trình quản lý nội dung sử dụng NSTextStorage làm cửa hàng dự phòng.

Nó biết cách chia nội dung lưu trữ văn bản thành các phần tử đoạn văn, là các trường hợp của NSTextParagraph.

NSTextContentStorage cũng biết cách tạo các phần tử đoạn văn được cập nhật khi văn bản trong bộ lưu trữ văn bản thay đổi.

Điều này đưa tôi đến một điểm quan trọng.

Khi thực hiện các thay đổi đối với bộ lưu trữ văn bản cơ bản, bạn nên gói các bản cập nhật của mình trong phương pháp performEditingTransaction này.

Điều này đảm bảo rằng các phần khác của hệ thống TextKit 2 được thông báo về những thay đổi của bạn.

Bạn có thể làm một số thứ thú vị với các đại diện lưu trữ nội dung mà không cần phải triển khai một lớp con NSTextContentManager đầy đủ.

Sau đó trong video này, Chris sẽ đề cập đến cách sử dụng các đại diện nội dung để thay đổi phông chữ và màu sắc nhận xét mà không cần sửa đổi bộ nhớ văn bản và cách ẩn hoàn toàn nhận xét.

Vì vậy, hãy theo dõi để biết thêm chi tiết.

Được rồi.

Bây giờ chúng tôi đã hiểu cách TextKit 2 tạo ra các yếu tố từ nội dung văn bản của bạn.

Điều đó quan tâm đến hai bước đầu tiên từ cách tiếp cận mới của chúng tôi.

Bộ lưu trữ nội dung tự động chia văn bản thành các phần tử đoạn văn và nó biết cách tạo đoạn văn mới cho các nhận xét mới.

Tiếp theo, hãy tìm ra cách chúng ta có thể hoàn thành hai bước cuối cùng: định vị và hiển thị nhận xét.

Quay trở lại sơ đồ dòng chảy của chúng tôi, chúng tôi cần lấy thông tin bố cục cho các yếu tố nhận xét của mình.

Có những đối tượng bố cục mới để giúp chúng tôi thực hiện những nhiệm vụ này.

Hãy gặp họ ngay bây giờ.

Gặp gỡ NSTextLayoutManager.

Trình quản lý bố cục văn bản kiểm soát quá trình bố cục văn bản.

NSTextLayoutManager tương tự như NSLayoutManager cũ từ TextKit 1 với một điểm khác biệt chính: NSTextLayoutManager không xử lý glyphs.

Thay vào đó, NSTextLayoutManager lấy các phần tử văn bản, đặt chúng vào vùng chứa văn bản và tạo các đoạn bố cục cho các phần tử đó.

Bạn làm việc với các đoạn bố cục để lấy thông tin bố cục cho các phần tử văn bản.

Vì vậy, bây giờ hãy tìm hiểu về các đoạn bố cục.

Gặp gỡ NSTextLayoutFragment.

Một đoạn bố cục chứa thông tin bố cục cho một hoặc nhiều phần tử văn bản.

Cũng giống như các phần tử, chúng sử dụng ngữ nghĩa giá trị và các thuộc tính của chúng là bất biến.

Vì vậy, trình quản lý bố cục văn bản sẽ tạo các đoạn bố cục cho từng yếu tố nhận xét của chúng tôi và sau đó chúng tôi có thể sử dụng thông tin từ các đoạn bố cục để định vị và hiển thị chúng.

Các đoạn bố cục truyền đạt thông tin bố cục thông qua ba thuộc tính: một mảng textLineFragments, layoutFragmentFrame và renderingSurfaceBounds.

Nếu bạn muốn tùy chỉnh hoặc thay đổi bố cục, điều cần thiết là phải hiểu thông tin bạn nhận được với từng thuộc tính này.

Vì vậy, chúng ta sẽ xem xét điều đó tiếp theo.

Đối với tài sản đầu tiên, chúng tôi sẽ gặp NSTextLineFragment.

Các đoạn dòng chứa thông tin đo lường cho từng dòng văn bản trong đoạn bố cục.

Chúng rất hữu ích để thu thập thông tin hình học cho các dòng cụ thể hoặc để đếm số dòng trong một đoạn bố cục.

Thuộc tính thứ hai, khung đoạn bố cục, mô tả cách văn bản trong đoạn bố cục được bố trí bên trong khu vực vùng chứa văn bản.

Trong TextKit 2, bố cục văn bản về cơ bản là xếp chồng các khung đoạn bố cục trong vùng chứa.

Hãy nghĩ về những khung hình này như gạch.

Hệ thống đang chia khu vực vùng chứa văn bản thành các ô, trong đó mỗi đoạn bố cục là một ô duy nhất.

Các đường rỗng có khung phân đoạn bố cục riêng, như được hiển thị trong sơ đồ.

Nói chung, các khung phân đoạn bố cục rất hữu ích để định vị các chế độ xem khác trong giao diện người dùng của bạn gần nội dung phân đoạn hoặc để tính tổng chiều cao của nội dung văn bản.

Bây giờ, khung này không thể hiện chính xác không gian cần thiết để vẽ chính văn bản.

Thông tin đó đến từ tài sản thứ ba.

Giới hạn bề mặt kết xuất mô tả diện tích cần thiết để vẽ văn bản.

Đây là hình chữ nhật bạn muốn sử dụng để lấy kích thước của văn bản trong không gian tọa độ xem.

Và điều này khác với khung phân đoạn bố cục vì văn bản có thể vượt quá các cạnh của khung phân đoạn.

Điều này xảy ra với dấu phụ hoặc, như được hiển thị ở đây, với các dấu xuống dài trong phông chữ in nghiêng.

Chú ý cách cạnh dưới bên trái của chữ J nhô ra chỉ một chút từ khung mảnh bố cục.

Nó không nổi bật nhiều như vậy, vì vậy đây là một ví dụ cực đoan hơn.

Một số phông chữ, như Zapfino, có các glyphs mở rộng rất xa bên ngoài giới hạn đánh máy.

Giới hạn bề mặt kết xuất sẽ lớn hơn nhiều so với khung phân đoạn bố cục trong trường hợp này.

Bây giờ chúng ta đã hiểu thông tin bố cục mà các đoạn bố cục cung cấp, hãy sao lưu một chút và nói về cách sử dụng thông tin này để tùy chỉnh bố cục của các phần tử văn bản.

Vì các đoạn bố cục là bất biến, bạn không thể trực tiếp thay đổi thông tin bố cục trên một đoạn.

Quay trở lại sơ đồ dòng chảy của chúng tôi, chúng tôi cần kết nối với quy trình bố cục và tạo các phiên bản mới của NSTextLayoutFragment với thông tin chúng tôi muốn thay đổi.

Và bạn kết nối với quy trình bố cục bằng cách sử dụng phương thức đại diện này trên NSTextLayoutManager.

Phương pháp này được gọi trong quá trình bố cục khi trình quản lý bố cục văn bản đang tạo ra các đoạn bố cục từ các phần tử.

Tại đây bạn có cơ hội tạo đoạn bố cục của riêng mình cho một phần tử.

Điều đó giải quyết hai bước cuối cùng trong cách tiếp cận của chúng tôi đối với vấn đề bình luận.

Chúng tôi sẽ xử lý việc định vị và vẽ tùy chỉnh đoạn bố cục nhận xét của mình bằng cách sử dụng lớp con của NSTextLayoutFragment và cung cấp các trường hợp của đoạn tùy chỉnh của chúng tôi trong đại diện trình quản lý bố cục văn bản.

Sau đó trong video này, Chris sẽ trình bày cách thực hiện điều này trong ứng dụng mẫu của chúng tôi.

Và đó là sự an toàn.

Bây giờ hãy chuyển sang biểu diễn.

Hiệu suất là một trong những thách thức lớn nhất đối với bất kỳ công cụ văn bản nào.

TextKit 2 cực kỳ nhanh cho một loạt các tình huống cực kỳ rộng, từ việc hiển thị nhanh chóng các nhãn chỉ có một vài dòng mỗi dòng đến bố trí các tài liệu có hàng trăm megabyte được cuộn qua với tốc độ tương tác.

Và đối với những tình huống này, khi bạn cuộn qua các tài liệu thực sự lớn này với tốc độ thay đổi, bố cục văn bản không liền kề là hoàn toàn cần thiết cho hiệu suất tuyệt vời.

Hãy xem lại sự khác biệt giữa bố cục liền kề và không liền kề.

Sơ đồ này cho thấy một tài liệu trong đó hình chữ nhật màu vàng đại diện cho vùng nội dung hiển thị trên màn hình.

Bố cục liền kề bắt đầu từ đầu tài liệu và theo thứ tự từ đầu đến cuối văn bản.

Vì vậy, nếu bạn cuộn đến một số điểm ở giữa tài liệu, bố cục tiếp giáp sẽ thực hiện bố cục cho tất cả văn bản xuất hiện trước thời điểm đó.

Điều này bao gồm tất cả văn bản đã được cuộn ra khỏi màn hình, quay trở lại đầu.

Và nếu có nhiều văn bản, hiệu suất có thể chậm và bạn có thể gặp trục trặc hoạt hình khi cuộn.

Trong trường hợp xấu nhất, nó có thể bị treo.

Ngược lại, bố cục không liền kề có nghĩa là chúng ta có thể bố trí một đoạn văn bản ở bất kỳ đâu trong tài liệu mà không cần bố trí các phần xuất hiện trước nó.

Bây giờ khi bạn cuộn đến giữa tài liệu, bố cục sẽ xảy ra cho khu vực hiển thị đó ngay lập tức.

Điều này cải thiện hiệu suất bằng cách chỉ thực hiện bố cục cho các phần văn bản hiển thị trên màn hình, cộng với vùng cuộn quá mức bổ sung, dẫn đến trải nghiệm cuộn mượt mà hơn.

Và bố cục trong TextKit 2 luôn không liền kề nhau.

Ngược lại, bố cục không liền kề là tùy chọn trong TextKit 1.

Nó được kích hoạt bằng cách sử dụng thuộc tính boolean trên NSLayoutManager.

API này đơn giản, nhưng vì nó đơn giản, nó không thể thể hiện thông tin về trạng thái của bố cục tại thời điểm bạn yêu cầu thông tin bố cục.

Bố cục không liền kề dựa trên các ước tính có thể thay đổi sau này khi các phần khác của tài liệu đã được trình bày.

Với TextKit 1, bạn chỉ có thể bật hoặc tắt bố cục không liền kề.

Không có khả năng kiểm soát phần nào của tài liệu được bố trí và không có cách nào để biết khi nào bố cục kết thúc và ước tính bố cục được cập nhật thành các giá trị thực.

TextKit 2 API phong phú và biểu cảm hơn.

TextKit 2 cung cấp cho bạn thông tin bố cục nhất quán cho các yếu tố trong khu vực nội dung hiển thị và thông báo cho bạn khi bố cục cập nhật cho khu vực hiển thị đó.

Khu vực này được gọi là khung nhìn.

Bạn quản lý khung nhìn bằng cách điều chỉnh hoặc di chuyển nó và bạn nhận được các cuộc gọi lại trước, trong và sau khi bố cục khung nhìn.

Để có hiệu suất tối ưu, mã của bạn nên tập trung vào việc làm việc với thông tin bố cục bên trong khu vực khung nhìn.

Tránh yêu cầu thông tin bố cục cho các yếu tố bên ngoài khung nhìn khi có thể.

Thông tin bố cục cho các phần tử bên ngoài khung nhìn có thể không chính xác trừ khi bạn yêu cầu rõ ràng đảm bảo bố cục cho các phạm vi văn bản tương ứng với các phần tử đó.

Cuộc gọi này có thể tốn kém, đặc biệt là đối với các tài liệu lớn.

Xem lại sơ đồ dòng chảy của chúng tôi từ trước đó, có một lớp bộ điều khiển mới khác để giúp chúng tôi quản lý khung nhìn.

Gặp gỡ NSTextViewportLayoutController.

Đây là nguồn gốc của sự thật cho thông tin bố cục khung nhìn.

Nó nói chuyện với trình quản lý bố cục văn bản để lấy các đoạn bố cục cho các phần tử trong khu vực khung nhìn.

Bạn có thể truy cập bộ điều khiển bố cục khung nhìn thông qua thuộc tính trên trình quản lý bố cục văn bản.

Bây giờ chúng ta đã gặp bộ điều khiển bố cục khung nhìn, hãy nói về cách tham gia vào quá trình bố trí khung nhìn.

Bộ điều khiển bố cục khung nhìn gọi ba phương thức quan trọng trên đại diện của nó trong quá trình bố cục khung nhìn: TextViewportLayoutController WillLayout, textViewportController configureRenderingSurface FortextLayoutFragment và textViewportLayoutController DidLayout.

Đầu tiên, bộ điều khiển bố cục khung nhìn gọi phương thức willLayout trước khi bố trí các phần tử trong khung nhìn.

Đây là nơi bạn thực hiện bất kỳ công việc thiết lập nào để chuẩn bị cho bố cục, chẳng hạn như xóa nội dung của chế độ xem hoặc lớp.

Tiếp theo, bộ điều khiển bố cục khung nhìn gọi configureRenderingSurface cho mọi đoạn bố cục hiển thị trong khung nhìn.

Đây là nơi bạn cập nhật hình học của mỗi chế độ xem hoặc lớp phân đoạn.

Cuối cùng, bộ điều khiển bố cục khung nhìn gọi phương thức didLayout sau khi hoàn tất việc bố trí tất cả các đoạn bố cục hiển thị trong khung nhìn.

Và đây là nơi bạn thực hiện bất kỳ cập nhật cần thiết nào sau khi bố cục khung nhìn hoàn tất, chẳng hạn như nếu bạn muốn điều chỉnh khung nhìn để làm cho phần tử cuối cùng hiển thị đầy đủ trên màn hình.

Và điều đó tóm tắt nó cho hiệu suất.

Bây giờ tôi sẽ giao nó cho Chris để chỉ cho bạn cách sử dụng TextKit 2 trong thực tế.

Cảm ơn bạn, Donna.

Chúng tôi đã viết một ứng dụng mẫu thể hiện một số cách khác nhau mà bạn có thể sử dụng TextKit 2 để bố trí và tương tác với văn bản trong ứng dụng của mình.

Bạn có thể tải xuống mã mẫu được sử dụng trong video này.

Hãy mở nó ra và dùng thử.

Chúng tôi đang sử dụng ứng dụng cộng tác này để xem lại một cuốn sách công thức nấu ăn để chúng tôi có thể tìm ra những gì chúng tôi muốn làm cho bữa trưa.

Cuộn qua các công thức nấu ăn hoạt động như mong đợi, nhưng có điều gì đó đặc biệt đang xảy ra đằng sau hậu trường: Chỉ những đoạn văn có thể nhìn thấy trong khung nhìn mới được vẽ.

Và thay vì mỗi đoạn văn được hiển thị trên cùng một bề mặt lớn, mỗi đoạn văn được hiển thị thành lớp riêng của nó.

Nếu tôi nhấp vào nút Hiển thị Giới hạn trên thanh công cụ ở đây, những hình chữ nhật màu này sẽ xuất hiện.

Hình chữ nhật màu cam hiển thị giới hạn của mỗi lớp.

Vẽ văn bản thành các lớp riêng biệt cho phép chúng tôi thực hiện một tính năng thú vị: Tôi có thể để lại nhận xét về các công thức nấu ăn.

Bây giờ, tôi nghĩ rằng một chiếc bánh sandwich trứng nghe có vẻ khá ngon, vì vậy tôi sẽ nhấp đúp vào đoạn này và gõ, "này cái này nghe có vẻ khá hay" và nhấn Enter để chèn bình luận.

Tôi vừa chèn một đoạn văn mới vào tài liệu.

Nền bong bóng đang được vẽ bởi một lớp con tùy chỉnh của NSTextLayoutFragment được gọi là BubbleLayoutFragment.

Thêm về điều đó sau.

Điều đặc biệt là, khi tôi chèn nhận xét vào tài liệu, tất cả các đoạn bên dưới nhận xét đều di chuyển để nhường chỗ cho nó.

Nếu bạn không bắt được nó lần đầu tiên, tôi sẽ nhấp vào nút rùa này trên thanh công cụ để bật Chế độ chậm.

Hãy thêm một bình luận khác.

"Ừ chúng ta hãy làm nó cho bữa trưa hôm nay.

Sau khi tôi nhấn Enter, bình luận được thêm vào tài liệu bên dưới nó, và tất cả các đoạn bên dưới nó hoạt hình từ từ.

Nếu bạn muốn ẩn tất cả các bình luận, bạn có thể nhấp vào nút Chuyển đổi Bình luận trên thanh công cụ.

Đây không thực sự là chỉnh sửa tài liệu cơ bản.

Thay vào đó, nó yêu cầu người quản lý nội dung văn bản bỏ qua nhận xét khi liệt kê các yếu tố văn bản để bố cục.

TextKit 2 hoạt động tốt trên iOS cũng như trên macOS.

Điều này có nghĩa là các phần TextKit 2 của ứng dụng macOS có thể được sử dụng lại trên iOS.

Hãy chạy nó trên iPad.

Chúng tôi đã sử dụng những phần đó để viết phiên bản iOS của ứng dụng cộng tác của chúng tôi với tất cả các chức năng giống nhau.

Tôi đang nhấn lâu vào một đoạn văn để lại bình luận, sau đó gõ, "này nghe hay đấy"...

Và nhấn Enter.

Cũng giống như ứng dụng trên macOS, tôi có thể nhấn vào nút Hiển thị/Ẩn nhận xét để ẩn tất cả nhận xét.

Tôi vừa xem qua một ứng dụng sử dụng TextKit 2 để bố trí, vẽ và tương tác với văn bản.

Bây giờ chúng ta hãy xem qua một số mã trong ứng dụng mẫu và cách TextKit 2 làm cho nó có thể.

Ứng dụng thể hiện rất nhiều chức năng mà TextKit 2 cung cấp, nhưng bây giờ tôi muốn tập trung vào hai lĩnh vực: cách nó bố trí văn bản trong khung nhìn bằng NSViewportLayoutController và cách nó thực hiện hành vi ẩn tùy chỉnh và hiển thị nhận xét.

Khi trình quản lý bố cục văn bản sắp bố trí tài liệu vì nó đã thay đổi, kích thước vùng chứa đã bị thay đổi hoặc một phần chưa từng thấy trước đây của tài liệu đã được chuyển vào khung nhìn, nó sẽ gọi textViewportLayout ControllerWillLayout trên đại diện bố cục khung nhìn của nó.

Chúng tôi đang sử dụng nó ở đây để xóa tất cả các lớp con văn bản và mở một giao dịch hoạt hình.

Đối với mỗi phần tử văn bản mà trình quản lý bố cục văn bản đưa ra, nó gọi textViewportLayoutController, configureRenderingSurfaceFor textLayoutFragment.

Ở đây chúng tôi đang nhận được một lớp để hiển thị đoạn bố cục văn bản, cập nhật hình học của nó, tạo hoạt ảnh cho nó đến vị trí mới, nếu có thể và thêm nó làm lớp con của chế độ xem.

Khi trình quản lý bố cục hoàn tất việc bố trí, nó sẽ gọi textViewportLayout ControllerDidLayout.

Chúng tôi cam kết giao dịch hoạt hình, cập nhật các điểm nổi bật của lựa chọn và cập nhật kích thước nội dung để ngón tay cái cuộn được đặt chính xác.

Bây giờ hãy nói về những bình luận.

TextKit 2 cung cấp một số móc mà bạn có thể sử dụng để tùy chỉnh phần tử bố cục và tạo đoạn bố cục.

Tôi sẽ chỉ cho bạn cách chúng tôi nhận xét trong tài liệu, đặt các thuộc tính tùy chỉnh như phông chữ và màu sắc để hiển thị và vẽ bong bóng phía sau chúng.

Đối với mỗi đoạn trong tài liệu, việc lưu trữ nội dung văn bản cho người đại diện của nó cơ hội tùy chỉnh các thuộc tính trên đoạn văn đó.

Trong quá trình triển khai của chúng tôi, chúng tôi đang thiết lập phông chữ và màu tùy chỉnh trên nhận xét mà không cần phải thay đổi phông chữ hoặc màu sắc của bộ lưu trữ văn bản cơ bản.

Trình quản lý nội dung văn bản cũng cho đại diện của mình cơ hội quyết định yếu tố văn bản nào sẽ được hiển thị cho trình quản lý bố cục văn bản trong quá trình bố cục.

Trả về false cho một phần tử văn bản ngăn không cho nó được hiển thị.

Ở đây chúng tôi đang ẩn các nhận xét bằng cách chọn không liệt kê chúng mà không cần phải thực sự xóa chúng khỏi bộ lưu trữ văn bản cơ bản.

Trình quản lý bố cục văn bản cũng có một đại biểu.

Bằng cách triển khai textLayoutManager, textLayoutFragmentFor vị trí trong textElement, đại diện có thể tạo một đoạn bố cục văn bản tùy chỉnh thay vì phiên bản NSTextLayoutFragment mặc định cho một NSTextElement nhất định.

Trong trường hợp này, khi nó gặp một NSTextElement đại diện cho một nhận xét, nó sẽ tạo ra một BubbleLayoutFragment, là một lớp con tùy chỉnh của NSTextLayoutFragment.

BubbleLayoutFragment ghi đè lên phương thức vẽ của NSTextLayoutFragment để vẽ bong bóng nền trước khi gọi triển khai lớp cơ sở để vẽ văn bản ở trên cùng.

Lưu ý rằng văn bản đang được hiển thị với phông chữ tùy chỉnh và màu văn bản mà chúng tôi đã đặt trước đó.

Tôi đã xem xét cách ứng dụng mẫu sử dụng TextKit 2 để thực hiện bố cục văn bản hoạt hình dựa trên khung nhìn và cách nó hiển thị nhận xét trong các bong bóng đầy màu sắc đó, đi từ các thuộc tính tùy chỉnh trong lưu trữ văn bản đến bản vẽ tùy chỉnh.

Nhưng có rất nhiều thứ trong mã mẫu tận dụng API mới do TextKit 2 cung cấp, bao gồm diễn giải các sự kiện chuột để xác định lựa chọn văn bản, làm nổi bật lựa chọn văn bản, đặt cửa sổ bật lên nhận xét tại một đoạn cụ thể trong tài liệu và ước tính chiều cao tài liệu.

Bạn có thể tìm thêm thảo luận về tất cả các chủ đề này trong mã mẫu.

Hãy quay lại với Donna để nói về việc chuẩn bị ứng dụng của bạn cho TextKit 2.

Cảm ơn, Chris.

Đó là một ví dụ tuyệt vời về cách TextKit 2 hoạt động trong thực tế.

Bây giờ chúng ta đã xem xét những gì TextKit 2 có thể làm, hãy thảo luận về một số cách tiếp cận để hiện đại hóa ứng dụng.

Mọi thứ chúng ta đã nói cho đến nay đều áp dụng cho việc tạo ngăn xếp TextKit 2 của riêng bạn để sử dụng với chế độ xem hoặc lớp chung.

Tất cả các lớp mới đều có sẵn trong UIKit với iOS 15 và trong AppKit với macOS 12.

Vì vậy, nếu bạn muốn đi theo con đường này, bạn có thể bắt đầu viết mã mới với TextKit 2 ngay hôm nay.

Mặt khác, nhiều ứng dụng sử dụng các điều khiển văn bản tích hợp, như chế độ xem văn bản, để tận dụng tất cả các chức năng tuyệt vời, miễn phí, như hỗ trợ khả năng truy cập và các dịch vụ lựa chọn và chỉnh sửa.

Một số điều khiển này đã được cập nhật để sử dụng TextKit 2.

Nếu ứng dụng của bạn sử dụng các điều khiển tích hợp sẵn, có một vài chi tiết bổ sung cần lưu ý.

Duy trì khả năng tương thích cũng quan trọng đối với chúng tôi như đối với bạn.

Vì TextKit 1 là một phần không thể thiếu của các điều khiển văn bản tích hợp, chúng tôi sẽ cố gắng hết sức để duy trì khả năng tương thích cho các ứng dụng đang sử dụng chúng.

Đây là lý do tại sao chỉ một số điều khiển sử dụng TextKit 2 tự động trong iOS 15 và macOS 12.

Ngoài ra, một số điều khiển yêu cầu thực hiện các bước bổ sung để sử dụng TextKit 2 trong các phiên bản hệ điều hành này.

Đối với các nhà phát triển AppKit, NSTextView không tự động sử dụng TextKit 2.

Nếu bạn muốn sử dụng TextKit 2 với NSTextView, bạn cần chọn tham gia theo chương trình tại thời điểm tạo.

Đây là cách để làm điều đó.

Đầu tiên, tạo một trình quản lý bố cục văn bản.

Tiếp theo, tạo một vùng chứa văn bản.

Sau đó liên kết vùng chứa văn bản với trình quản lý bố cục văn bản bằng cách sử dụng thuộc tính textContainer trên NSTextLayoutManager.

Cuối cùng, tạo NSTextView của bạn bằng cách sử dụng trình khởi tạo được chỉ định với vùng chứa văn bản.

Bây giờ bạn sẽ có một chế độ xem văn bản sử dụng TextKit 2.

Bạn có thể truy cập trình quản lý bố cục văn bản và lưu trữ nội dung văn bản với các thuộc tính mới trên NSTextView.

Chỉ có một điều cần cẩn thận.

Nhớ lại rằng NSTextView có thuộc tính layoutManager cho phép lấy và đặt NSLayoutManager của nó.

NSLayoutManager là một đối tượng TextKit 1 và nó không tương thích với ngăn xếp TextKit 2.

Chế độ xem văn bản không thể có cả trình quản lý bố cục và trình quản lý bố cục văn bản cùng một lúc.

Vậy đây là thỏa thuận.

Chúng tôi đã thêm một chế độ tương thích đặc biệt cho NSTextView để chuyển nó sang TextKit 1 khi cần.

Chế độ xem văn bản có thể tự động phát hiện xem nó có cần sử dụng chế độ này hay không và thay thế NSTextLayoutManager bằng NSLayoutManager.

Để có hiệu suất tối ưu, chế độ xem văn bản sẽ vẫn ở chế độ tương thích từ thời điểm đó trở đi.

Ngay cả khi bạn chọn tham gia TextKit 2, chế độ xem văn bản của bạn sẽ tự động chuyển sang TextKit 1 nếu bạn gọi rõ ràng thuộc tính layoutManager trên chế độ xem văn bản hoặc vùng chứa văn bản của mình.

Chế độ xem văn bản cũng sẽ chuyển đổi nếu nó gặp nội dung văn bản chưa được hỗ trợ hoặc phát hiện các điều kiện khác yêu cầu TextKit 1.

Và điều này cũng có thể xảy ra với các biên tập viên hiện trường.

Trình chỉnh sửa trường cho NSTextField sử dụng TextKit 2 theo mặc định.

Nhưng nếu lớp con trường văn bản của bạn đang yêu cầu thông tin bố cục từ trình quản lý bố cục của trình chỉnh sửa trường, trình chỉnh sửa trường sẽ chuyển sang TextKit 1 cho tất cả các trường văn bản trong cửa sổ đó.

Hệ thống sẽ phát hành thông báo trước và sau khi chế độ xem văn bản chuyển sang TextKit 1.

Bạn có thể quan sát những thông báo này để nhận thông tin này.

Các đối tượng thông báo chứa một tham chiếu đến chế độ xem văn bản chính xác đã thay đổi chế độ.

Để biết chi tiết đầy đủ về chế độ tương thích TextKit 1 cho AppKit, vui lòng tham khảo tài liệu trên cổng thông tin Nhà phát triển Apple.

Đối với các nhà phát triển UIKit, UITextField sử dụng TextKit 2 tự động trong iOS 15.

UITextView với TextKit 2 không khả dụng trong iOS 15.

Chúng tôi đang làm việc để đảm bảo khả năng tương thích tối đa cho tất cả các ứng dụng sử dụng UITextView và có khá nhiều trong số chúng.

Trong thời gian chờ đợi, bạn có thể xem lại mã hiện có của mình để sử dụng thuộc tính layoutManager của UITextView và suy nghĩ về cách thể hiện ý định của bạn với TextKit 2.

Bằng cách đó, bạn sẽ sẵn sàng chuyển đổi khi nó có sẵn.

Và đó là một cái bọc.

Bây giờ bạn đã gặp TextKit 2, công cụ văn bản mới của Apple để đưa chúng ta vào tương lai.

Chúng tôi mong muốn được thấy những gì bạn sẽ xây dựng với TextKit 2.

Cảm ơn vì đã xem.

[Nhạc lạc quan].