10095

♪ Nhạc bass đang phát ♪

♪

Guoye Zhang: Xin chào, tôi là Guoye.

Đồng nghiệp của tôi Zhenchao và tôi làm việc trên các khung HTTP.

Tôi chắc rằng bây giờ bạn đã nghe rất nhiều về Swift concurrency.

Nếu bạn chưa có, hãy xem "Gặp gỡ không đồng bộ/chờ đợi trong Swift".

Tôi sẽ tìm hiểu cách async/await hoạt động với URLSession.

Điều tôi thích nhất về Swift đồng thời là nó làm cho mã của bạn tuyến tính, súc tích và nó hỗ trợ xử lý lỗi Swift gốc.

Mạng vốn không đồng bộ, và trong iOS 15 và macOS Monterey, chúng tôi đã giới thiệu một bộ API mới trong URLSession để bạn tận dụng các tính năng đồng thời của Swift.

Để cho bạn thấy các API mới của chúng tôi, đây là một ứng dụng mà chúng tôi đang làm việc để áp dụng async/await.

Đây là một ứng dụng chia sẻ ảnh chỉ dành cho những người yêu chó và chúng tôi có thể yêu thích những bức ảnh này.

Đây là mã hiện có của chúng tôi để tìm kiếm một bức ảnh con chó.

Nó đang sử dụng phương pháp tiện lợi dựa trên completionHandler trên URLSession.

Mã có vẻ đơn giản, và nó hoạt động trong thử nghiệm giới hạn của tôi.

Tuy nhiên, nó có ít nhất ba sai lầm.

Hãy đi sâu vào.

Đầu tiên, hãy làm theo quy trình kiểm soát.

Chúng tôi tạo ra một nhiệm vụ dữ liệu và tiếp tục nó.

Sau đó, khi nhiệm vụ hoàn thành, chúng tôi nhảy vào trình xử lý hoàn thành, chúng tôi kiểm tra phản hồi, tạo hình ảnh và đó là nơi luồng điều khiển kết thúc.

Hừm, chúng ta đang nhảy qua lại.

Còn việc xâu chuỗi thì sao?

Nó phức tạp một cách đáng ngạc nhiên đối với đoạn mã nhỏ này.

Chúng tôi có tổng cộng ba bối cảnh thực thi khác nhau.

Lớp ngoài cùng chạy trên bất kỳ luồng hoặc hàng đợi nào của người gọi, URLSessionTask completionHandler chạy trên hàng đợi đại diện của phiên và trình xử lý hoàn thành cuối cùng chạy trên hàng đợi chính.

Vì trình biên dịch không thể giúp chúng tôi ở đây, chúng tôi phải hết sức thận trọng để tránh bất kỳ vấn đề phân luồng nào như các cuộc đua dữ liệu.

Bây giờ, tôi nhận thấy có điều gì đó không ổn.

Các cuộc gọi đến completionHandler không được gửi một cách nhất quán đến hàng đợi chính.

Đây có thể là một lỗi.

Ngoài ra, chúng tôi đang bỏ lỡ một sự trở lại sớm ở đây.

Trình xử lý hoàn thành có thể được gọi hai lần nếu chúng tôi gặp lỗi.

Điều này có thể vi phạm các giả định do người gọi đưa ra.

Cuối cùng, điều này có thể không rõ ràng lắm, nhưng việc tạo UIImage có thể thất bại.

Nếu dữ liệu ở định dạng không chính xác, trình khởi tạo UIImage này sẽ trả về nil, vì vậy chúng tôi sẽ gọi completionHandler với cả hình ảnh nil và lỗi nil.

Điều này có thể không được mong đợi.

Bây giờ đây là phiên bản mới sử dụng async/await.

Chà, nó đơn giản hơn rất nhiều!

Luồng điều khiển là tuyến tính từ trên xuống dưới và chúng tôi biết rằng mọi thứ trong hàm này chạy trong cùng một ngữ cảnh đồng thời, vì vậy chúng tôi không còn cần phải lo lắng về các vấn đề phân luồng nữa.

Ở đây, chúng tôi đã sử dụng phương thức dữ liệu không đồng bộ mới trên URLSession.

Nó đình chỉ ngữ cảnh thực thi hiện tại mà không bị chặn, và nó trả về dữ liệu và phản hồi khi hoàn thành thành công hoặc gây ra lỗi.

Chúng tôi cũng đã sử dụng từ khóa ném để ném lỗi khi phản hồi không mong muốn.

Điều này cho phép người gọi bắt và xử lý lỗi bằng cách xử lý lỗi gốc Swift.

Cuối cùng, trình biên dịch sẽ sủa nếu chúng ta cố gắng trả về một UIImage tùy chọn từ hàm này, vì vậy về cơ bản nó buộc chúng ta phải xử lý nil một cách chính xác.

Đây là chữ ký của các phương pháp chúng tôi vừa sử dụng để lấy dữ liệu từ mạng.

Các phương thức URLSession.data chấp nhận URL hoặc URLRequest.

Chúng tương đương với các phương pháp thuận tiện nhiệm vụ dữ liệu hiện có.

Chúng tôi cũng cung cấp các phương thức tải lên nơi bạn có thể tải lên dữ liệu hoặc tải lên tệp.

Chúng tương đương với các phương pháp tiện lợi nhiệm vụ tải lên hiện có.

Đảm bảo đặt đúng phương thức HTTP trước khi gửi yêu cầu vì phương thức mặc định GET không hỗ trợ tải lên.

Các phương thức tải xuống lưu trữ nội dung phản hồi dưới dạng tệp thay vì trong bộ nhớ.

Khác với các phương pháp tiện lợi của tác vụ tải xuống, các phương pháp mới này không tự động xóa tệp, vì vậy đừng quên tự làm như vậy.

Trong ví dụ này, chúng tôi đang di chuyển tệp đến một vị trí khác để xử lý thêm.

Việc hủy bỏ Swift concurrency hoạt động với các phương thức không đồng bộ URLSession.

Một cách để hủy bỏ là sử dụng Task.Handle đồng thời.

Ở đây, chúng tôi gọi async để tạo một Nhiệm vụ đồng thời tải từng tài nguyên một.

Sau đó, chúng ta có thể sử dụng Task.Handle để hủy hoạt động đang chạy hiện tại của nó.

Xin lưu ý rằng Nhiệm vụ đồng thời không liên quan đến URLSessionTask, mặc dù chúng có chung tên "Nhiệm vụ".

Các phương pháp chúng ta vừa nói đến - dữ liệu, tải lên, tải xuống - đợi toàn bộ nội dung phản hồi đến trước khi quay lại.

Điều gì sẽ xảy ra nếu chúng ta muốn nhận nội dung phản hồi từng bước?

Tôi rất vui khi giới thiệu các phương pháp URLSession.bytes.

Chúng trả về khi các tiêu đề phản hồi đã được nhận và cung cấp nội dung phản hồi dưới dạng AsyncSequence của các byte.

Để cho bạn thấy nó hoạt động như thế nào, đồng nghiệp Zhenchao của tôi sẽ giới thiệu cách anh ấy áp dụng nó trong ứng dụng Chó.

Zhenchao Li: Cảm ơn, Guoye! Xin chào, tôi là Zhenchao.

Tôi đang làm việc trên một tính năng mới của ứng dụng Chó cho thấy có bao nhiêu người yêu thích một bức ảnh chó.

Ngay bây giờ, tôi có thể kéo chế độ xem cuộn xuống để làm mới số lượng yêu thích.

Tôi muốn cập nhật những con số yêu thích này trong thời gian thực.

Bằng cách đó, ứng dụng cảm thấy tương tác nhiều hơn.

Để làm điều đó, các kỹ sư back-end của chúng tôi đã xây dựng một điểm cuối sự kiện theo thời gian thực cung cấp cho chúng tôi các bản cập nhật trực tiếp cho các bức ảnh.

Tôi sẽ kiểm tra điểm cuối để kiểm tra phản hồi.

Mỗi dòng của nội dung phản hồi là một phần dữ liệu JSON mô tả các bản cập nhật cho một bức ảnh, chẳng hạn như số lượng yêu thích được cập nhật.

Hãy sử dụng API trình tự không đồng bộ mới để sử dụng phản hồi của điểm cuối và cập nhật số lượng yêu thích khi các sự kiện thời gian thực được phân tích cú pháp.

Chúng ta có thể bắt đầu cập nhật trực tiếp trong chức năng onAppearHandler, đây là một hành động được gọi khi chế độ xem bộ sưu tập ảnh xuất hiện.

Trong hàm, tôi sẽ gọi URLSession.bytes API mới để tìm nạp dữ liệu từ điểm cuối mới của chúng tôi.

Lưu ý rằng các byte được trả về ở đây có một loại URLSession.AsyncBytes.

Điều này cho chúng ta một cách để tiêu thụ từng bước cơ thể phản ứng.

Tôi cũng đã thêm kiểm tra lỗi ở đây để đảm bảo rằng chúng tôi đã nhận được phản hồi thành công từ máy chủ.

Chúng tôi muốn phân tích cú pháp từng dòng phản hồi dưới dạng một phần dữ liệu JSON.

Để làm điều đó, chúng ta có thể sử dụng phương thức dòng trên AsyncBytes.

Điều này cho phép chúng tôi tiêu thụ từng dòng phản hồi khi dữ liệu được nhận.

Trong vòng lặp, tôi chỉ có thể phân tích dữ liệu JSON và cập nhật giao diện người dùng của mình bằng cách gọi updateFavoriteCount.

Lưu ý rằng các cập nhật giao diện người dùng cần phải xảy ra trên tác nhân chính và đó là lý do tại sao tôi đang sử dụng cú pháp await để gọi updateFavoriteCount, đây là một hàm không đồng bộ.

Tuyệt vời. Bây giờ những con số yêu thích này được cập nhật theo thời gian thực.

Quay lại với bạn, Guoye.

Guoye: Zhenchao vừa chỉ cho chúng ta cách sử dụng phép biến đổi tích hợp AsyncSequence - dòng - để phân tích cú pháp từng dòng nội dung phản hồi.

AsyncSequence hỗ trợ nhiều chuyển đổi thuận tiện và bạn cũng có thể sử dụng AsyncSequence với các API khung hệ thống khác như FileHandle.

Để tìm hiểu thêm về AsyncSequence, tôi khuyến khích bạn xem video "Gặp gỡ AsyncSequence".

URLSession được thiết kế xung quanh một mô hình đại diện cung cấp các cuộc gọi lại cho các sự kiện như thử thách xác thực, số liệu và hơn thế nữa.

Các phương thức không đồng bộ mới không còn phơi bày nhiệm vụ cơ bản, vậy làm thế nào để chúng ta xử lý các thách thức xác thực cụ thể cho một nhiệm vụ?

Có, tất cả các phương pháp đó có thể nhận một đối số bổ sung - một đại diện dành riêng cho nhiệm vụ - cho phép bạn cung cấp một đối tượng để xử lý các tin nhắn đại diện cụ thể cho hoạt động tải lên, tải xuống hoặc byte dữ liệu này.

Chúng tôi cũng đang giới thiệu thuộc tính đại diện trên NSURLSessionTask trong Objective-C để bạn tận dụng khả năng tương tự.

Đại biểu được giữ vững bởi một nhiệm vụ cho đến khi nó hoàn thành hoặc thất bại.

Điều đáng chú ý là đại diện dành riêng cho nhiệm vụ không được hỗ trợ bởi URLSession nền.

Nếu một phương thức được triển khai trên cả đại diện phiên và đại diện nhiệm vụ, phương thức đại diện nhiệm vụ sẽ được gọi.

Bây giờ, Zhenchao sẽ chỉ cho chúng ta cách sử dụng một đại diện nhiệm vụ cụ thể để xử lý các thách thức xác thực.

Zhenchao: Cảm ơn, Guoye!

Ứng dụng Dogs của chúng tôi có một lớp tìm nạp dữ liệu đơn giản được viết bằng các API không đồng bộ mới.

Đối với một số tác vụ tìm nạp dữ liệu của chúng tôi, chẳng hạn như đánh dấu ảnh là yêu thích hoặc tìm nạp tất cả ảnh yêu thích, người dùng cần được xác thực.

Ngay bây giờ, khi tôi nhấn để yêu thích một bức ảnh, tôi gặp lỗi "Không được phép".

Hãy xem qua cách chúng ta có thể thêm xác thực người dùng bằng cách sử dụng một đại diện dành riêng cho nhiệm vụ.

Đầu tiên, hãy viết một URLSessionTaskDelegate.

Hãy gọi nó là AuthenticationDelegate.

AuthenticationDelegate phù hợp với giao thức URLSessionTaskDelegate và nó chấp nhận một phiên bản của signInController trong trình khởi tạo của nó.

Lớp signInController mà chúng tôi đã triển khai đã chứa một số chức năng trợ giúp tốt mà chúng tôi có thể sử dụng để nhắc người dùng cung cấp thông tin đăng nhập.

Tiếp theo, hãy triển khai phương thức đại diện thử thách URLSession didReceive.

Trong phương thức đại diện, chúng ta có thể chọn phản hồi các thách thức xác thực cơ bản HTTP bằng cách nhắc người dùng cung cấp thông tin đăng nhập.

Tất nhiên, chúng ta không nên quên xử lý lỗi.

Bây giờ hãy sử dụng lớp AuthenticationDelegate này làm đại diện nhiệm vụ cụ thể của chúng tôi.

Để làm điều đó, tôi chỉ có thể khởi tạo một phiên bản của nó và phân tích cú pháp nó làm tham số đại diện cho phương thức URLSession.data.

Lưu ý rằng đối tượng đại diện không phải là một biến thể hiện và nó được nhiệm vụ giữ chặt chẽ cho đến khi nhiệm vụ hoàn thành hoặc thất bại.

Điểm mới ở đây là đại diện có thể được sử dụng để xử lý các sự kiện cụ thể cho một phiên bản của tác vụ URLSession, điều này rất hữu ích khi logic bên trong các phương thức đại diện của bạn chỉ áp dụng cho một số tác vụ URLSession nhất định chứ không áp dụng cho các tác vụ khác.

Tuyệt vời. Bây giờ khi chúng ta nhấn để yêu thích bức ảnh...

...Nó bật lên một biểu mẫu đăng nhập.

Khi chúng tôi đăng nhập, ảnh sẽ hiển thị như đã yêu thích và nó đã được thêm vào bộ sưu tập ảnh yêu thích của chúng tôi.

Quay lại với bạn, Guoye.

Guoye: Cảm ơn bạn, Zhenchao, vì bản demo.

Chúng tôi không thể chờ đợi bạn thử async/await với URLSession và chúng tôi khuyến khích bạn áp dụng các khái niệm không đồng bộ tương tự để cải thiện mã của mình, bao gồm thay đổi chức năng, đưa trình xử lý hoàn thành vào các hàm không đồng bộ và thay đổi trình xử lý sự kiện lặp lại thành AsyncSequences.

Để tìm hiểu thêm về những tiến bộ trong URLSession, chúng tôi có một video về một công cụ mới thú vị kiểm tra lưu lượng HTTP của ứng dụng của bạn và một video về hỗ trợ HTTP/3 trong URLSession.

Cảm ơn bạn và chúc bạn có một WWDC tuyệt vời!

♪