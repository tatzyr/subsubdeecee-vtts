10054

♪ Nhạc bass đang phát ♪

♪

Jeff Nadeau: Xin chào, và chào mừng đến với "Có gì mới trong AppKit."

Tôi là Jeff Nadeau.

Tôi làm việc trên AppKit, và tôi có một số cập nhật tuyệt vời để chia sẻ với bạn.

macOS Monterey bao gồm một số tính năng và cải tiến mới tuyệt vời cho các ứng dụng Mac.

Thực sự có một cái gì đó cho tất cả mọi người trong bản phát hành này, bao gồm các bản cập nhật cho thiết kế giao diện người dùng của chúng tôi, cải tiến nhiều điều khiển của chúng tôi, bản cập nhật lớn cho SF Symbols, một công cụ văn bản hoàn toàn mới có tên TextKit 2, các tính năng ngôn ngữ Swift mới mạnh mẽ và tự động hóa

Hãy đi sâu vào, bắt đầu với một số cập nhật về thiết kế của giao diện người dùng macOS.

Chúng tôi rất vui mừng trước phản hồi đối với thiết kế lại toàn hệ thống đã ra mắt trong macOS Big Sur.

Rất nhiều ứng dụng yêu thích của chúng tôi đã cập nhật để áp dụng thiết kế mới chỉ trong vài tháng ngắn ngủi.

Trong macOS Monterey, chúng tôi đã tiếp tục lặp lại và tinh chỉnh thiết kế mới này, vì vậy bạn sẽ nhận thấy một vài điểm nhấn mới trên toàn hệ thống.

Một số trong số chúng lớn và đáng chú ý, như cửa sổ bật lên hiện xuất hiện và rút đi với hình ảnh động hoàn toàn mới hoặc thanh trượt hiện lướt nhẹ nhàng vào vị trí khi bạn nhấp vào chúng.

Ngoài ra còn có nhiều thay đổi tinh tế hơn, như các số liệu tinh chỉnh trong các điều khiển thanh công cụ và hỗ trợ tải lò xo trên nút Tìm kiếm, vì vậy thật dễ dàng để kéo văn bản và mã thông báo.

Và tăng khoảng cách giữa các phần của bảng để cải thiện độ rõ nét.

Chúng tôi đã tiếp tục lặp lại và nâng cao thiết kế mới đến từng chi tiết nhỏ nhất.

Và điều đó dẫn tôi đến một số cải tiến kiểm soát mà bạn có thể sử dụng để tinh chỉnh các thiết kế của riêng mình.

Cái lớn đầu tiên là kiểm soát nhuộm màu.

Chúng tôi đã bật tính năng tùy chỉnh các nút riêng lẻ, các điều khiển được phân đoạn và thanh trượt.

Mỗi điều khiển này chấp nhận một màu sắc thái tùy chỉnh bằng cách sử dụng một trong các API sau: bezelColor, selectedSegmentColor và trackFillColor.

Chúng tôi đã giới thiệu các API này trong macOS Sierra để cho phép nhuộm màu các điều khiển riêng lẻ trong Touch Bar.

Và bắt đầu từ macOS Monterey, chúng cũng hoạt động cho các điều khiển trong cửa sổ.

Tóm lại, hầu hết các điều khiển vẽ bằng cách sử dụng màu nhấn, có thể định cấu hình trong Tùy chọn hệ thống.

Điều này cho phép mọi người tạo chủ đề cho máy Mac của họ để phù hợp với màu sắc yêu thích của họ.

Tùy chọn Nhiều màu cho phép mỗi ứng dụng xác định màu tùy chỉnh của riêng mình.

Đối với chủ đề phổ biến, bạn có thể xác định màu nhấn tùy chỉnh trong danh mục nội dung của ứng dụng.

API pha màu mới cung cấp một cách để ghi đè màu cho một điều khiển cụ thể.

Điều này rất tốt cho các điều khiển mà bạn muốn áp dụng một màu có ý nghĩa ngữ nghĩa.

Ví dụ: nếu ứng dụng của bạn sử dụng một màu cam cụ thể để phân biệt đơn đặt hàng trước với giao dịch mua thông thường, bạn có thể củng cố thiết kế đó bằng cách sử dụng nút màu.

Một ví dụ khác sẽ là ứng dụng hội nghị truyền hình, trong đó các nút Bắt đầu và Kết thúc Cuộc gọi thực hiện hai trong số các hành động có ý nghĩa nhất trong ứng dụng.

Tô màu xanh lá cây và đỏ làm tăng thêm điểm nhấn và nó làm cho chức năng của chúng có thể nhận ra ngay lập tức.

Một lưu ý quan trọng là các nút màu luôn hiển thị màu sắc của chúng ở mọi trạng thái hoạt động, không giống như các nút ấn thông thường có màu trắng hoặc xám.

Điều này đặt màu sắc thái của bạn ở phía trước và trung tâm.

Tuy nhiên, hãy cẩn thận trong thiết kế của bạn để không tạo ra sự nhầm lẫn với nút mặc định, nút này cũng sử dụng vẻ ngoài đầy màu sắc.

Cuối cùng, điều quan trọng là truyền đạt mục đích điều khiển của bạn không chỉ bằng màu sắc.

Bạn muốn đảm bảo rằng những người gặp khó khăn trong việc phân biệt giữa các màu sắc vẫn có thể dễ dàng xác định mục đích của một điều khiển nhất định, vì vậy hãy đảm bảo cung cấp một nhãn hoặc biểu tượng rõ ràng.

Một thay đổi thiết kế nút quan trọng khác là các nút nhấn không còn làm nổi bật bằng cách sử dụng màu nhấn khi nhấp chuột.

Điều này đưa chúng phù hợp với các yếu tố có thể nhấp khác, như các phân đoạn điều khiển được phân đoạn, núm trượt và bước.

Đây là một thay đổi quan trọng, bởi vì nếu bạn đang thực hiện bất kỳ bản vẽ tùy chỉnh nào có vẻ ngoài đầy màu sắc trong khi được tô sáng - giả sử, nếu bạn chọn vẽ nội dung màu trắng lên trên - nó có thể trông không chính xác trên macOS Monterey.

Thay vì kiểm tra trạng thái nổi bật, bạn có thể đưa ra quyết định vẽ của mình bằng cách sử dụng thuộc tính interiorBackgroundStyle.

Thuộc tính này phản ánh kiểu cơ bản của viền nút, vì vậy nó sẽ luôn trả về .bình thường cho các trạng thái không màu và nó sẽ trả về .được nhấn mạnh cho các trạng thái nhấn mạnh đầy màu sắc, như các nút màu, nút mặc định và các nút được chuyển sang trạng thái "bật".

Cuối cùng, chúng tôi đã cập nhật kiểu nút Nhấn linh hoạt - trước đây được gọi là Hình vuông thông thường - để phục vụ như một nút nhấn có chiều cao thay đổi.

Bây giờ nó hỗ trợ tất cả các cấu hình giống như một nút nhấn thông thường, có nghĩa là nó có thể đóng vai trò là nút mặc định và bạn có thể tô màu nó.

Bán kính góc và phần đệm nội dung hiện phù hợp với các nút nhấn tiêu chuẩn ở mỗi kích thước điều khiển, vì vậy chúng sẽ phù hợp tuyệt vời với các điều khiển khác của bạn, nhưng thiết kế có thể thay đổi kích thước theo chiều dọc của chúng có nghĩa là chúng có thể chứa các biểu tượng hoặc văn bản lớn hơn với ngắt dòng.

Mặc dù phần lớn các nút nhấn nên tiếp tục sử dụng kiểu chiều cao cố định tiêu chuẩn, nhưng kiểu mở rộng mới này cung cấp một số tính linh hoạt cho những trường hợp đặc biệt đó khi bạn cần chứa nội dung cao hơn.

Một bản cập nhật điều khiển rất quan trọng khác xuất hiện dưới dạng bản địa hóa tự động cho các phím tắt menu.

Có rất nhiều bố cục bàn phím ngoài kia trên thế giới, và điều đó có thể làm cho việc bản địa hóa các phím tắt khá phức tạp.

Một số tổ hợp phím khó tiếp cận trên một số bàn phím và những tổ hợp khác hoàn toàn không thể đánh máy được.

Ngoài ra, một số phím tắt định hướng thực sự nên phản chiếu bằng các ngôn ngữ từ phải sang trái.

Tin tuyệt vời là, trong macOS Monterey, AppKit có thể làm điều đó cho bạn.

Đây là một ví dụ về một phím tắt có thể được hưởng lợi từ việc bản địa hóa: Dấu gạch chéo ngược lệnh.

Mặc dù điều này hoạt động tốt trên bàn phím tiếng Anh Hoa Kỳ, nhưng thực sự không thể gõ trên bàn phím tiếng Nhật, bàn phím này hoàn toàn không có phím dấu gạch chéo ngược.

Bắt đầu từ macOS Monterey, hệ thống tự động ánh xạ lại phím tắt, cung cấp một phím tắt tương đương tự nhiên để nhập.

Một trường hợp phổ biến khác là một phím tắt có ý nghĩa định hướng.

Ví dụ, Safari sử dụng dấu ngoặc vuông lệnh để đi lùi và tiến trong lịch sử.

Trong ngôn ngữ từ phải sang trái, việc sử dụng dấu ngoặc trái để đi ngược không trực quan lắm, vì vậy AppKit hiện tự động hoán đổi nó sang dấu ngoặc phải khi chạy bằng ngôn ngữ từ phải sang trái.

Hành vi này áp dụng cho dấu ngoặc, dấu ngoặc đơn, dấu ngoặc đơn và phím mũi tên.

Trong một số trường hợp, bạn có thể muốn vô hiệu hóa hành vi phản chiếu này.

Ví dụ: nếu mục menu của bạn có định hướng tuyệt đối - ví dụ như căn chỉnh bên trái - bạn sẽ muốn sử dụng dấu ngoặc trái ngay cả trong ngôn ngữ từ phải sang trái.

Chúng tôi đã cung cấp lựa chọn không tham gia cho các trường hợp như thế này.

Bạn có thể kiểm soát hành vi này bằng cách sử dụng một số thuộc tính mới trên NSMenuItem.

allowsAutomaticKey EquivalentMirroring cho phép bạn kiểm soát hành vi phản chiếu cho các phím định hướng như dấu ngoặc và cho phépAutomaticKey EquivalentLocalization điều khiển tất cả các tính năng bản địa hóa, bao gồm ánh xạ và phản chiếu bàn phím.

Nếu bạn đã bản địa hóa cẩn thận các phím tắt của mình hoặc nếu ứng dụng của bạn có triển khai tùy chỉnh nhiều ràng buộc phím tắt, bạn có thể muốn tắt tính năng này cho toàn bộ ứng dụng của mình.

Để làm điều đó, bạn có thể triển khai phương thức đại diện ứng dụng này, applicationShouldAutomatically LocalizeKeyEquivalents và trả về false.

Hầu hết các ứng dụng sẽ không cần sử dụng cái này.

Các API mục menu riêng lẻ được ưu tiên mạnh mẽ để chọn không tham gia các mục cụ thể và hầu hết các ứng dụng hoàn toàn không cần phải chọn không tham gia.

Tiếp theo, một số cải tiến lớn đối với hình ảnh biểu tượng.

Chúng tôi đã đưa SF Symbols lên macOS trong Big Sur, mở ra một loạt các hình ảnh biểu tượng đẹp, cân bằng kiểu chữ cho tất cả các ứng dụng Mac.

Trong macOS Monterey, chúng tôi đã xây dựng một thế hệ API và công cụ biểu tượng mới mà chúng tôi gọi là Biểu tượng SF 3.

Đó là một bản cập nhật lớn trải dài mọi khía cạnh của quy trình làm việc hình ảnh biểu tượng và tất cả đều có sẵn cho các ứng dụng AppKit của bạn.

SF Symbols 3 mở rộng khả năng của ứng dụng SF Symbols để xem trước, xuất và nhập hình ảnh biểu tượng.

Nó cũng đi kèm với một định dạng cập nhật để chú thích các biểu tượng tùy chỉnh, cho phép bạn xác định các lớp riêng biệt trong hình ảnh biểu tượng và chúng tôi đã mở rộng các API của mình trong AppKit, UIKit và SwiftUI để cho phép bạn tô màu riêng từng lớp của biểu tượng.

Trong Big Sur, chúng tôi đã cung cấp hai chế độ kết xuất riêng biệt cho các biểu tượng.

Đầu tiên, có phong cách Mẫu truyền thống, được vẽ bằng cách sử dụng một màu hoặc hiệu ứng tông màu duy nhất trên toàn bộ biểu tượng.

Thứ hai là Multicolor, vẽ giống như một hình ảnh đầy đủ màu sắc hơn, vẽ từng phần tử đường dẫn bằng cách sử dụng một màu được xác định trong chính hình ảnh biểu tượng.

Trong SF Symbols 3, chúng tôi đã thêm hai chế độ kết xuất mới tận dụng thông tin lớp được cung cấp bởi định dạng hình ảnh biểu tượng mới.

Đầu tiên, Phân cấp, vẽ bằng cách sử dụng một màu duy nhất, đồng thời nhấn mạnh vào các phần cụ thể của biểu tượng trong khi nhấn mạnh các phần khác.

Và thứ hai, Bảng màu, cho phép bạn gán bất kỳ màu nào bạn muốn cho từng lớp của biểu tượng.

Bạn có thể truy cập các chế độ kết xuất này bằng API mới trên NSImage.SymbolConfiguration.

Tôi đang đại diện cho các tham số NSColor dưới dạng các dấu chấm để hiển thị cách chúng tương ứng với biểu tượng được hiển thị.

Chế độ kết xuất phân cấp có một màu duy nhất, được áp dụng cho các lớp biểu tượng với độ mờ giảm dần.

Chế độ Bảng màu chấp nhận một mảng màu sắc được áp dụng cho các lớp nguyên văn.

Bạn cũng có thể tạo một cấu hình thích chế độ kết xuất nhiều màu.

Chúng tôi cũng đã thêm một API mới cho phép bạn ánh xạ từ một biểu tượng cơ sở thành một trong các biến thể của nó.

Ví dụ, bạn có thể ánh xạ biểu tượng trái tim đến biến thể đầy của nó, hoặc một biến thể được ghi như vòng tròn, hoặc thậm chí đến biến thể có dấu gạch chéo qua nó.

Điều này thực sự hữu ích cho các tình huống mà bạn thích một kiểu biểu tượng cụ thể cho một bối cảnh cụ thể.

Ví dụ, bạn có thể có một điều khiển bộ chọn nơi bạn thích phác thảo cho các trạng thái chưa được chọn, nhưng một kiểu đầy đủ cho lựa chọn của bạn.

Thông thường, điều khiển này sẽ cần hai thuộc tính hình ảnh khác nhau để chỉ định các phiên bản đã chọn và không được chọn của hình ảnh.

Nhưng với API biến thể, nó chỉ có thể chấp nhận một biểu tượng cơ sở duy nhất và tự động lấy trạng thái đã điền.

Điều khiển này có thể gọi hình ảnh (với: .fill) để thích một biểu tượng đã điền ở trạng thái lựa chọn của nó và nó sẽ tự động chọn đúng phiên bản của biểu tượng bất cứ khi nào có biến thể đã điền.

Có các hằng số cho từng loại biến thể biểu tượng và bạn có thể kết hợp chúng để yêu cầu nhiều biến thể với nhau, như hình tròn và điền.

Đây chỉ là phần giới thiệu ngắn gọn về các tính năng của Biểu tượng SF 3.

Có một bộ sưu tập video mới, nơi bạn có thể nhận được thông tin chi tiết đầy đủ về mọi thứ mới trên toàn bộ quy trình làm việc của biểu tượng.

Hãy chắc chắn thêm chúng vào danh sách theo dõi của bạn.

macOS Monterey cũng có một bản cập nhật lớn cho hệ thống văn bản dưới dạng TextKit 2.

TextKit là công cụ bố cục và kết xuất văn bản cho tất cả các thiết bị của Apple và nó là một công cụ văn bản tuyệt vời với hồ sơ theo dõi đã được chứng minh.

TextKit là một công cụ bố cục văn bản tuyến tính, có nghĩa là nó sắp chữ một khối văn bản từ đầu đến cuối.

Khi chúng tôi phát triển các nền tảng và công nghệ của mình, chúng tôi đã tìm thấy rất nhiều trường hợp bố cục văn bản phi tuyến sẽ phục vụ chúng tôi tốt hơn nhiều.

Vì vậy, chúng tôi đã quay trở lại những điều cơ bản và tạo ra một phiên bản mới của TextKit và đó là TextKit 2.

Chúng tôi đã có một vài mục tiêu chính cho TextKit 2.

Như mọi khi, chúng tôi muốn cung cấp trải nghiệm tốt nhất cho văn bản quốc tế của mọi kịch bản và bố cục.

Chúng tôi cũng muốn làm cho việc trộn văn bản với các loại nội dung khác dễ dàng hơn.

Và cuối cùng, TextKit 2 được thiết kế để định hình và hiển thị văn bản siêu nhanh, hiệu quả, cho dù đó là nhãn ngắn hay được cuộn ngang qua một tài liệu lớn.

TextKit 2 cùng tồn tại với TextKit 1, vì vậy bạn có thể chọn công cụ nào để sử dụng cho chế độ xem văn bản nhất định.

Bây giờ tôi sẽ cho bạn biết một bí mật.

Bạn đã chạy TextKit 2 trên máy Mac của mình vì bắt đầu từ Big Sur, TextEdit sử dụng nó cho các tài liệu văn bản thuần túy và các trường văn bản AppKit sử dụng TextKit 2 cho hầu hết các cấu hình.

Vì vậy, bạn đã thực sự xem lén toàn bộ thời gian này.

Một trong những điểm khác biệt chính trong TextKit 2 là nó luôn sử dụng hệ thống bố cục phi tuyến.

Điều đó có nghĩa là nó có thể thực hiện bố cục văn bản ở cấp độ chi tiết hơn, điều này cho phép nó tránh được những công việc không cần thiết.

Ví dụ, nếu chúng ta có một tài liệu lớn trong đó chỉ một phần của văn bản được cuộn để hiển thị, một hệ thống tuyến tính vẫn phải bố trí tất cả các văn bản trước đó để hiển thị khu vực này.

Bằng cách so sánh, một hệ thống phi tuyến như TextKit 2 có thể bắt đầu bố cục ở ranh giới đoạn gần nhất.

Đối với các tài liệu lớn, đây là một sự tăng tốc rất lớn.

Công cụ bố cục mới cung cấp một tập hợp các điểm tùy chỉnh mạnh mẽ, giúp việc mở rộng hệ thống bố cục và thêm các hành vi của riêng bạn trở nên đơn giản.

Hệ thống bố cục phi tuyến cũng cho phép trộn các yếu tố phi văn bản vào bố cục văn bản của bạn.

Và nó thực hiện tất cả những điều này trong khi cải thiện hiệu suất cho ngay cả những tài liệu lớn nhất.

Để tìm hiểu thêm, hãy xem "Gặp gỡ TextKit 2", đi vào chi tiết đầy đủ về thiết kế của API mới và cách sử dụng nó.

Tiếp theo, tôi muốn chia sẻ một số cập nhật về AppKit trong Swift bắt đầu bằng đồng thời.

Swift 5.5 giới thiệu một số tính năng cấp ngôn ngữ quan trọng để quản lý đồng thời.

Đầu tiên, async/await, cho phép các cuộc gọi phương thức không đồng bộ hoạt động rất giống coroutines.

Thứ hai, các loại diễn viên, bảo vệ trạng thái có thể thay đổi khỏi các cuộc đua dữ liệu bằng cách cô lập quyền truy cập vào một chuỗi thực thi duy nhất.

AppKit hoạt động tốt với cả hai tính năng mới này.

Đối với async/await, nhiều phương thức không đồng bộ trong AppKit - nghĩa là, các phương thức tiếp tục làm khối xử lý hoàn thành - đã được chuyển đổi trong SDK để cung cấp các biến thể không đồng bộ.

Một ví dụ đơn giản là NSColorSampler, cho phép người dùng chọn màu từ bất kỳ đâu trên màn hình.

Cuộc gọi này không đồng bộ vì nó đợi người dùng chọn màu họ muốn, và sau đó nó chạy trình xử lý hoàn thành khi họ hoàn thành.

Với async/await, bạn có thể diễn đạt điều này dưới dạng một cuộc gọi hàm không đồng bộ.

Nó mang lại chuỗi thực thi của nó trong khi nó đang chờ công việc không đồng bộ hoàn thành, và sau đó nó chọn lại ngay nơi nó đã dừng lại.

Bạn thậm chí có thể làm điều đó từ bên trong một tuyên bố bảo vệ.

Bây giờ, phần tiếp theo - công việc sẽ được thực hiện tiếp theo - không còn được lồng vào bên trong khối trình xử lý hoàn thành.

Thay vào đó, mã đọc tự nhiên theo trình tự.

Các diễn viên làm việc để bảo vệ trạng thái khỏi sự truy cập đồng thời bằng cách cô lập nó thành một chuỗi thực thi duy nhất.

Nếu điều đó nghe có vẻ quen thuộc, đó là bởi vì hầu hết trạng thái của AppKit, như hệ thống phân cấp chế độ xem và chuỗi phản hồi, cũng nên được truy cập từ một luồng thực thi duy nhất, cụ thể là luồng chính.

Hạn chế này phù hợp với mô hình diễn viên một cách độc đáo, vì vậy chúng tôi đã giới thiệu khái niệm MainActor, đây là một loại phải được truy cập từ chuỗi chính.

Trong AppKit, chúng tôi đã chỉ định NSResponder bao gồm các lớp con của NSView, ViewController, WindowController và Application, cộng với NSCell, Alert, Document và DocumentController làm MainActors.

Mã chạy trong MainActor có thể tự do gọi các phương thức trên các loại MainActor khác, vì bạn biết rằng bạn đã ở trên luồng chính.

Tuy nhiên, mã không chạy trong MainActor phải sử dụng các tính năng không đồng bộ/chờ mới để thực hiện giao diện người dùng đó hoạt động trong ngữ cảnh của MainActor.

Bằng cách thực thi điều này ở cấp độ trình biên dịch, Swift có thể giúp bạn tránh được một nguồn lỗi phổ biến khi trộn đồng thời với mã giao diện người dùng.

Các video đồng thời Swift đi sâu vào tính năng ngôn ngữ mới mạnh mẽ này.

Bạn không muốn bỏ lỡ chúng.

Cũng mới trong Swift 5.5 là phiên bản được nhập giá trị của AttributedString.

Ngoài việc cung cấp ngữ nghĩa giá trị, nó còn có các thuộc tính an toàn kiểu và công thái học Swift tuyệt vời để liệt kê và thao tác các phạm vi thuộc tính.

Khi bạn đang sử dụng AttributedString với AppKit, bạn sẽ tự động có quyền truy cập vào các thuộc tính có liên quan đến hệ thống vẽ văn bản của chúng tôi; những thứ như màu nền trước, kiểu đoạn văn, v.v.

Bạn có thể chuyển đổi giữa cấu trúc AttributedString và NSAttributedString được nhập tham chiếu, vì vậy bạn có thể tương tác với các API sử dụng NSAttributedString.

Video "Có gì mới trong Foundation" đi vào chi tiết hơn về thiết kế của AttributedString và cách sử dụng nó.

Cải tiến Swift cuối cùng của chúng tôi liên quan đến việc cập nhật lái xe cho NSViews của bạn.

Nó sử dụng tính năng trình bao bọc thuộc tính của Swift để giảm đáng kể bản mẫu phổ biến trong các thuộc tính chế độ xem.

Hãy xem qua một ví dụ.

Đây là chế độ xem tùy chỉnh có thể định cấu hình thông qua một số thuộc tính.

Và mặc dù điều này có vẻ ổn, nhưng thực tế là các khai báo thuộc tính trong quan điểm của chúng tôi có nhiều khả năng chứa nhiều didSets và các tác dụng phụ bổ sung, bởi vì nó phổ biến đến mức bạn cần vẽ lại hoặc bố cục hoặc cập nhật các ràng buộc của mình khi có điều gì đó thay đổi.

Bây giờ, đó là rất nhiều nồi hơi.

Vì vậy, chúng tôi đã làm cho kịch bản này tốt hơn bằng cách tạo một trình bao bọc thuộc tính Swift mới chỉ cho trường hợp này.

Nó được gọi là Vô hiệu hóa.

Nó được lồng trong NSView và nó cho phép bạn chỉ định một hoặc nhiều khía cạnh của chế độ xem để vô hiệu hóa khi thuộc tính được bọc thay đổi.

Tất cả các didSets và dấu ngoặc đều biến mất, giúp việc tập trung vào định nghĩa của chính tài sản dễ dàng hơn.

AppKit cung cấp một số trường hợp vô hiệu hóa tích hợp sẵn: hiển thị, bố cục, ràng buộc, kích thước nội dung nội tại và trạng thái có thể khôi phục.

Vì những sự vô hiệu hóa này chỉ có ý nghĩa đối với các chế độ xem, chúng tôi đã hạn chế trình bao bọc thuộc tính để nó chỉ hoạt động trên các lớp con của NSView.

Chúng tôi cũng yêu cầu giá trị phù hợp với Equatable.

Chúng tôi sử dụng sự phù hợp này để kiểm tra những thay đổi có ý nghĩa về giá trị trước khi thực hiện vẽ lại hoặc vượt qua bố cục có khả năng tốn kém.

Nếu bạn muốn làm điều gì đó tùy chỉnh, bạn thậm chí có thể xác định sự vô hiệu hóa của chính mình bằng cách tuân thủ một loại với giao thức NSViewInvalidating.

Cuối Cùng, Các Phím Tắt.

Trong macOS Monterey, chúng tôi rất vui mừng được mang toàn bộ sức mạnh của Phím tắt đến Mac và điều đó bao gồm tích hợp Phím tắt với các ứng dụng AppKit của bạn.

Tin tuyệt vời là, nếu ứng dụng của bạn hỗ trợ Dịch vụ, thì nó đã hỗ trợ Phím tắt và Phím tắt xuất hiện ở tất cả những nơi giống nhau mà bạn có thể truy cập Dịch vụ ngay hôm nay.

Nếu bạn chưa quen với chức năng này, nó thực sự dễ áp dụng.

AppKit quyết định phím tắt nào phù hợp theo ngữ cảnh bằng cách kiểm tra chuỗi phản hồi.

Nó hỏi mỗi người trả lời liệu nó có thể cung cấp hoặc nhận các loại dữ liệu được mong đợi bởi mỗi phím tắt hay không.

Chúng tôi thể hiện điều này bằng cách sử dụng loại bảng dán, trong hầu hết các trường hợp, tương ứng với số nhận dạng loại thống nhất.

Tất cả những gì bạn phải làm là triển khai validRequestor cho phương thức sendType và returnType.

Và nếu bạn có thể chấp nhận hoặc cung cấp các loại được chỉ định, hãy trả về một đối tượng phù hợp với giao thức NSServicesMenuRequestor.

Trong hầu hết các trường hợp, bạn sẽ chỉ thực hiện giao thức đó trực tiếp và sau đó trả lại bản thân.

Khi một Phím tắt được gọi, bạn sẽ nhận được các cuộc gọi để ghi và/hoặc đọc dữ liệu từ một bảng dán đặc biệt mà Phím tắt sử dụng cho đầu vào và đầu ra của nó.

Và thế là xong!

Thật dễ dàng để tích hợp ứng dụng của bạn với Phím tắt.

Chúng tôi cũng đã đưa Siri Intents lên macOS.

Bây giờ bạn có thể xử lý Ý định bằng cách tạo Phần mở rộng Ý định trong Xcode.

Hoặc, nếu bạn cần xử lý chúng từ ứng dụng chính của mình, bạn có thể trả lại trình xử lý Ý định từ đại diện ứng dụng của mình.

Trong đại diện ứng dụng của bạn, hãy triển khai phương thức xử lý ứng dụng For intent:, trả về một đối tượng xử lý cho bất kỳ ý định nào mà bạn có thể xử lý.

Mỗi loại ý định đều có giao thức xử lý riêng mà đối tượng được trả về phải tuân thủ, vì vậy hãy kiểm tra tài liệu khung Ý định để biết thêm chi tiết về việc triển khai đối tượng xử lý.

Bây giờ bạn đã được trang bị tất cả thông tin mới này, điều gì tiếp theo?

Đầu tiên, hãy nghĩ về cách các tính năng như điều khiển nhuộm màu và Biểu tượng SF 3 có thể giúp bạn nâng cao thiết kế ứng dụng của mình.

Tiếp theo, nếu ứng dụng của bạn sử dụng TextKit để tạo trải nghiệm văn bản tùy chỉnh, hãy xem video "Gặp gỡ TextKit 2" và dùng thử API mới.

Bạn sẽ thích cách dễ dàng để thể hiện bố cục tùy chỉnh và nội dung phong phú với TextKit 2.

Cách ứng dụng của bạn quản lý đồng thời là một phần quan trọng trong kiến trúc của nó và các tính năng đồng thời mới của Swift sẽ là một cải tiến lớn trong lĩnh vực này.

Bây giờ là lúc để bắt đầu lập kế hoạch cho cách các tính năng như async/await sẽ định hình cách ứng dụng của bạn quản lý khối lượng công việc đồng thời của nó.

Cuối cùng, chuẩn bị sẵn sàng ứng dụng của bạn cho Phím tắt bằng cách áp dụng các tính năng tự động hóa của AppKit.

Cảm ơn bạn đã dành thời gian và quan tâm.

Chúng tôi hy vọng bạn thích tất cả những cải tiến tuyệt vời này trong macOS Monterey.

♪