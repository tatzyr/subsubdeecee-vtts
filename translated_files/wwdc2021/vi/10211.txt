10211

♪ Nhạc bass đang phát ♪

♪

Alejandro Lucena: Xin chào mọi người.

Cảm ơn bạn đã tham dự phiên họp này về biểu tượng.

Mặc dù biểu tượng hóa có vẻ như là một thuật ngữ mơ hồ, chúng ta sẽ thấy vai trò công cụ của nó trong việc giúp bạn nhanh chóng xác định nguyên nhân gốc rễ của lỗi, sự cố và tắc nghẽn hiệu suất.

Chúng tôi sẽ có được trực giác sâu sắc hơn về cách thức hoạt động của biểu tượng và bao gồm một số công cụ mà bạn có theo ý của mình để làm theo trực tiếp.

Trên đường đi, chúng ta sẽ thảo luận về các nguồn thông tin gỡ lỗi khác nhau cần thiết cho trải nghiệm biểu tượng phong phú và cách bạn có thể định cấu hình ứng dụng của mình để sử dụng tốt nhất thông tin này.

Hãy bắt đầu bằng cách làm quen với một định nghĩa và ví dụ cụ thể về biểu tượng.

Về cơ bản, biểu tượng hóa là một cơ chế để chuyển đổi hoặc dịch cách các thiết bị của chúng ta nhìn thấy các ứng dụng của chúng ta trong thời gian chạy - đó là về địa chỉ bộ nhớ và hướng dẫn - trở lại cách chúng ta với tư cách là nhà phát triển nhìn thấy ứng dụng của mình - đó là về chức năng, tên và tệp.

Nếu không có lớp bắc cầu này, nó sẽ làm phức tạp đáng kể việc chẩn đoán lỗi ngay cả đối với một vài dòng mã.

Ví dụ, hãy xem xét mã Swift này.

Ở đây tôi có một hàm, `generateMagicNumber()`, chọn một số cụ thể từ danh sách các số ứng cử viên.

Để làm điều này, trước tiên chúng tôi gọi vào `numberChoices()` trả về một mảng gồm 10 số được tạo ngẫu nhiên.

Sau đó, chúng tôi chuyển mảng đó vào `selectMagicNumber(choices:)`, trả về số tại một chỉ mục cụ thể.

Đây có vẻ là một chương trình hợp lý, nhưng tôi gặp sự cố khi lần đầu tiên chạy nó.

Cách truy đòi đầu tiên của tôi là kiểm tra nhật ký sự cố, điều này khá không có kết quả.

Tất cả những gì tôi có thể nói từ backtrace chủ đề là ứng dụng MagicNumbers của tôi bị lỗi ở đâu đó.

Cảm ơn, nhưng tôi đã biết điều đó rồi.

Tôi cũng không biết bất kỳ sổ đăng ký nào đang đề cập đến điều gì.

Tôi có thể thử bước qua ứng dụng với trình gỡ lỗi và xác định sự cố, nhưng điều gì sẽ xảy ra nếu điều này chỉ xảy ra trong những trường hợp cụ thể mà tôi không thể tái tạo?

Sử dụng trình gỡ lỗi sẽ không nhất thiết phải xác định chính xác vấn đề đối với tôi trong trường hợp đó.

Hoặc tôi có thể cố gắng nhìn vào việc tháo gỡ, nhưng việc theo dõi mọi thứ khó khăn hơn nhiều.

Đây rõ ràng không phải là một cách khả thi để chẩn đoán vấn đề, và quan trọng hơn, với sự trợ giúp của biểu tượng, chúng ta không phải gỡ lỗi từ điểm bắt đầu này.

Xcode Organizer cho tôi biết tôi có thể tải xuống dSYM cho ứng dụng này, ứng dụng này sẽ xử lý lại nhật ký sự cố.

Khi làm như vậy, Xcode áp dụng các khái niệm về biểu tượng để tôi có thể chẩn đoán sự cố bằng nhật ký sự cố đẹp hơn nhiều, nơi tôi không chỉ có thể thấy tất cả các chức năng của mình thực sự được gọi mà còn có thể xác định tệp và số dòng để tham chiếu lại trong mã của mình.

Nhật ký sự cố được cập nhật này cũng cho tôi biết rằng chúng tôi đã cố gắng truy cập một chỉ mục ngoài phạm vi.

Ngoài ra, nếu tôi đã có dSYM, tôi có thể sử dụng lệnh `atos` để lấy thông tin tương tự.

Nhìn lại mã của mình, tôi nhận ra rằng `MAGIC_CHOICE` nằm ngoài giới hạn của mảng 10 phần tử của chúng ta.

Rất tiếc.

Trong một trường hợp khác, tôi quan tâm đến việc lập hồ sơ ứng dụng của mình để mang lại trải nghiệm người dùng nhanh nhất.

Ở đây, Công cụ cho tôi thấy rằng ứng dụng chu kỳ qua các giai đoạn sử dụng cao và sử dụng thấp.

Nếu chúng ta tập trung vào khoảng thời gian sử dụng thấp, Instruments cho chúng ta biết rằng ứng dụng đang ghi một số nội dung vào một tệp.

Tuy nhiên, khi tôi kiểm tra một khoảng thời gian sử dụng cao, tôi nhận được cùng một dấu vết ngược chính xác.

Làm thế nào điều này có thể xảy ra?

Cái này không thực thi cùng một mã chính xác sao?

Như chúng ta sẽ thấy, dấu vết Dụng cụ này chỉ được tượng trưng một phần.

Ví dụ, tôi không thấy bất kỳ tên tệp hoặc số dòng nào trong dấu vết ngược như tôi đã làm với nhật ký sự cố được cập nhật.

Kết quả là, nó thiếu một số thông tin.

Với ý nghĩ đó, tôi có thể xác định vị trí tương tự dSYM của mình trong Instruments.

Sau khi làm điều này, dấu vết Công cụ mới của tôi cho thấy các vùng sử dụng cao thực sự đang ghi vào một tệp, nhưng chúng đặc biệt nằm trong đường dẫn mã gỡ lỗi mà tôi đã để lại trong chương trình.

Các khu vực sử dụng thấp tránh điều này và thể hiện cách ứng dụng của tôi hoạt động trong sản xuất.

Giống như Xcode đã sử dụng dSYM để tượng trưng cho một nhật ký sự cố khá thiếu thông tin, Instruments cũng đã sử dụng dSYM để làm phong phú thêm một dấu vết được tượng trưng một phần và cho tôi biết nguyên nhân chính xác của vấn đề hiệu suất.

Bây giờ, mặc dù thật tuyệt khi những công cụ này tận dụng tính biểu tượng để xác định các khu vực có vấn đề trong mã của tôi, nhưng nó tự nhiên đặt ra một vài câu hỏi.

Tất cả những thứ này hoạt động như thế nào?

Tôi có thể áp dụng cái này ở đâu khác?

Và đây có phải là tất cả về dSYMs không?

Để trả lời những câu hỏi này và mở khóa khả năng của biểu tượng, chúng ta sẽ cần đi sâu hơn vào các chi tiết.

Điều này có vẻ hơi quá sức, nhưng đây là những khái niệm quan trọng cần hiểu.

Có rất nhiều công cụ để hỗ trợ gỡ lỗi và lập hồ sơ dựa trên biểu tượng.

Chỉ riêng `atos` đã cho chúng tôi nguyên nhân gốc rễ chính xác của sự cố và có nhiều công cụ khác được tích hợp trong Xcode.

Hơn nữa, chúng tôi đã chỉ định các cờ như `o`, `l` và `i` cho `atos`, nhưng chúng có nghĩa là gì?

Chúng ta có luôn sử dụng cùng một bộ cờ không?

Điều gì sẽ xảy ra nếu chúng ta không có sẵn một trong những giá trị?

Bạn cũng sẽ có được một nền tảng tốt trong việc hiểu khi nào và tại sao dấu vết ngược của bạn có thể không được tượng trưng hóa hoàn toàn và làm thế nào để khắc phục điều đó, như chúng ta đã thấy trong trường hợp Dụng cụ.

Cuối cùng, có một số cài đặt xây dựng mà bạn đang kiểm soát ảnh hưởng đến sự phong phú của biểu tượng.

Chúng tôi sẽ xem xét các cài đặt xây dựng này để bạn có trực giác vững chắc về cách chúng được sử dụng.

Cuối cùng, tôi muốn giới thiệu quy trình hai bước để tượng trưng hóa.

Bước số một sẽ quay lại tệp và bước số hai là tham khảo thông tin gỡ lỗi.

Như chúng ta sẽ thấy, quay lại tệp là tất cả về việc chuyển đổi hoặc dịch các địa chỉ bộ nhớ thời gian chạy thành một dạng ổn định hơn, có thể sử dụng được.

Điều này cho phép chúng tôi giao tiếp với thông tin gỡ lỗi của mình để tạo kết nối có ý nghĩa giữa địa chỉ bộ nhớ thô và mã nguồn.

Hãy bắt đầu bằng cách thảo luận về bước số một, quay lại tệp.

Mục tiêu cuối cùng trong bước này là dịch địa chỉ bộ nhớ thời gian chạy, chẳng hạn như những địa chỉ chúng ta đã thấy trong nhật ký sự cố ban đầu, sang một địa chỉ tương ứng trong tệp nhị phân của bạn trên đĩa.

Giống như chúng tôi có địa chỉ thời gian chạy, các ứng dụng và khuôn khổ của bạn cũng có không gian địa chỉ trên đĩa!

Không gian địa chỉ trên đĩa khác với không gian địa chỉ mà ứng dụng của bạn chiếm trong thời gian chạy và chúng tôi cần một cơ chế để tìm ra những khác biệt đó.

Đầu tiên, chúng ta nên hiểu chính xác địa chỉ trên đĩa là gì.

Những địa chỉ này được chỉ định bởi trình liên kết khi bạn xây dựng ứng dụng của mình.

Cụ thể, trình liên kết nhóm nhị phân của bạn thành các phân đoạn.

Mỗi phân đoạn chứa dữ liệu liên quan và có các thuộc tính như tên, kích thước và địa chỉ được chỉ định của chúng.

Ví dụ, đoạn `__TEXT` của tệp nhị phân của bạn chứa tất cả các hàm và phương thức bạn đã viết và đoạn `__DATA` chứa trạng thái toàn chương trình như các biến toàn cục.

Mỗi phân đoạn này được chỉ định một địa chỉ khác nhau sao cho chúng không trùng lặp.

Trình liên kết ghi lại thông tin này ngay từ đầu tệp thực thi của bạn như một phần của tiêu đề Mach-O.

Mach-O là định dạng được sử dụng cho tất cả các tệp nhị phân và thư viện thực thi, và hệ thống biết rằng nó cần đọc tiêu đề này để chạy ứng dụng của bạn.

Nhìn kỹ hơn một chút, tiêu đề Mach-O chứa một số lệnh tải giữ các thuộc tính phân đoạn.

Hệ thống sử dụng các lệnh tải này để tải các phân đoạn vào bộ nhớ.

Lưu ý rằng nếu ứng dụng của bạn là Universal 2, thì ứng dụng sẽ có một tiêu đề và một tập hợp các phân đoạn cho mỗi kiến trúc.

Chúng ta có thể tự xem bằng cách sử dụng lệnh `otool -l`, lệnh này in các lệnh tải cho một tệp được chỉ định.

Ở đây, chúng tôi đang tìm kiếm một lệnh tải phân đoạn được xác định bằng `LC_SEGMENT_64`.

Các lệnh tải này nói rằng đoạn `__TEXT` bắt đầu tại địa chỉ trong `vmaddr` và dài `vmsize` byte.

Vì vậy, nếu hạt nhân tuân theo các lệnh tải này để tải các phân đoạn vào bộ nhớ, chính xác thì sự khác biệt giữa thời gian chạy và địa chỉ liên kết là gì?

Chà, trước khi hạt nhân thực sự tải các phân đoạn, nó khởi tạo một giá trị ngẫu nhiên được gọi là slide ASLR.

Hạt nhân sau đó thêm slide ASLR vào các địa chỉ trong các lệnh tải.

Vì vậy, thay vì tải phân đoạn `__TEXT` tại địa chỉ A và phân đoạn `__DATA` tại địa chỉ B, hạt nhân thay vào đó tải chúng vào A+S và B+S, trong đó S là trang chiếu ASLR.

Vì A+S và B+S là những địa chỉ thực sự mà hệ thống sử dụng, chúng còn được gọi là địa chỉ tải.

Với ý nghĩ đó, bây giờ chúng ta biết rằng sự khác biệt giữa địa chỉ thời gian chạy và địa chỉ liên kết là slide ASLR.

Chúng ta có thể tính toán slide ASLR với phương trình sau: S = L-A, trong đó S là slide ASLR, L là địa chỉ tải và A là địa chỉ liên kết.

Chúng ta sẽ sớm thấy các ví dụ về phương trình này, nhưng điểm mấu chốt là chúng ta luôn có thể quay lại không gian địa chỉ tệp khi chúng ta biết trang chiếu ASLR.

Phương trình trượt ASLR yêu cầu hai địa chỉ - địa chỉ tải và địa chỉ liên kết - vậy chúng ta lấy chúng từ đâu?

Chúng tôi đã thấy cách chúng tôi có thể truy vấn các lệnh tải để biết địa chỉ liên kết bằng `otool`.

Để biết địa chỉ thời gian chạy, hệ thống truy vấn ứng dụng của bạn tại thời điểm xảy ra sự cố hoặc khi nó được Công cụ lập hồ sơ cho không gian địa chỉ thời gian chạy của nó.

Thông tin này được phản ánh trong danh sách Hình ảnh nhị phân trong nhật ký sự cố của bạn.

Bạn cũng có thể xem các địa chỉ tải tương tác với công cụ `vmmap`, công cụ này liệt kê các vùng bộ nhớ đang hoạt động trong chương trình của bạn.

Hãy tự tính giá trị slide ASLR từ nhật ký sự cố ban đầu.

Trong danh sách Hình ảnh nhị phân, tôi có địa chỉ tải của phân đoạn `__TEXT`.

Tôi cũng có địa chỉ liên kết cho tệp nhị phân trên đĩa khi tôi xem các lệnh tải.

Trừ hai cái này tạo ra giá trị trượt ASLR là 0x45c000.

Điều này có nghĩa là mọi địa chỉ trong phân đoạn `__TEXT` thời gian chạy của chương trình của tôi đều cách địa chỉ phân đoạn `__TEXT` của trình liên kết 0x45c000 byte.

Vì vậy, để xem địa chỉ backtrace từ nhật ký sự cố tương ứng với những gì trong tệp, tôi có thể trừ 0x45c000 khỏi nó để lấy địa chỉ trên đĩa.

Vì địa chỉ này hiện là một phần của không gian địa chỉ trên đĩa, tôi có thể kiểm tra ứng dụng của mình để xem những gì nằm ở đó.

Nhật ký sự cố cho tôi biết rằng một luồng bị lỗi trong khi thực hiện bất kỳ thứ gì tại địa chỉ này, vì vậy chúng ta có thể sử dụng lại `otool` để xem hướng dẫn có vấn đề.

Lần này, tôi đã chỉ định cờ `-tV` cho `otool`, cờ này sẽ in phần tháo gỡ.

Lưu ý rằng tôi cũng đang chỉ định kiến trúc là arm64.

Điều này là để otool biết tiêu đề và phân đoạn Mach-O nào cần xem xét vì ứng dụng được xây dựng dưới dạng Universal 2.

Đầu ra của `otool` hiển thị một hướng dẫn `brk` tại địa chỉ.

`brk` báo hiệu một ngoại lệ hoặc một vấn đề trong ứng dụng.

Các công cụ như `atos` cũng tính toán slide ASLR bằng cách sử dụng cùng một kỹ thuật mà chúng tôi đã trải qua cùng nhau.

`atos` sẽ đọc các lệnh tải cho tệp được chỉ định bởi cờ `-o` và chúng tôi cho nó biết về địa chỉ tải với cờ `-l`.

Như tôi đã đề cập, `vmmap` cũng có thể cho chúng ta biết về địa chỉ tải của một ứng dụng đang chạy.

Hãy thử tính toán này một lần nữa, nhưng lần này chúng ta sẽ sử dụng `vmmap` thay vì danh sách hình ảnh nhị phân để xác định slide ASLR.

Tôi đã chạy lại chương trình MagicNumbers và nhận được địa chỉ tải phân đoạn `__TEXT` trước khi chương trình gặp sự cố.

Sử dụng công thức trước đó, tôi có thể xác định rằng lần này giá trị slide ASLR là 0x104d14000.

Một lần nữa, để quay lại tệp, tôi cần trừ đi giá trị slide ASLR.

Nếu tôi trừ 0x104d14000 từ mục nhập trên cùng trong nhật ký sự cố mới, tôi sẽ nhận được địa chỉ tệp chính xác như trước đây.

Và điều này không phải ngẫu nhiên; hạt nhân chỉ chọn một giá trị ASLR khác nên địa chỉ tải của chúng tôi đã thay đổi giữa các bản ghi sự cố.

Tuy nhiên, chúng tôi vẫn có thể xác định địa chỉ tệp chịu trách nhiệm cho sự cố.

Điều quan trọng ở đây là chúng tôi có một cơ chế để hiểu chính xác những gì ứng dụng của chúng tôi đang làm ở cấp độ hướng dẫn, bất kể địa chỉ thời gian chạy của nó.

Và với ánh xạ đó, sau đó chúng ta có thể tham khảo thông tin gỡ lỗi của mình để biết mã nguồn được biên dịch theo các hướng dẫn đó.

Trước khi chúng tôi tiếp tục, tôi muốn trình bày một bản tóm tắt về những gì chúng tôi đã đề cập và các công cụ chúng tôi đã sử dụng.

Các tệp nhị phân và khuôn khổ ứng dụng là các tệp Mach-O.

Điều này có nghĩa là họ có nội dung liên quan trong các phân đoạn khác nhau của họ.

Các phân đoạn này được tạo bởi trình liên kết.

Các lệnh tải tiêu đề Mach-O mô tả các thuộc tính của các phân đoạn đó, bao gồm một địa chỉ.

Chúng tôi đã sử dụng `otool` với cờ `-l` để in ra các lệnh tải.

Tiếp theo, chúng tôi biết rằng hạt nhân thêm một giá trị ngẫu nhiên, được gọi là slide ASLR, vào các địa chỉ liên kết.

Việc bổ sung slide ASLR và địa chỉ liên kết được gọi là địa chỉ tải.

Chúng ta có thể kiểm tra danh sách hình ảnh nhị phân trong nhật ký sự cố để xem địa chỉ tải trong trường hợp xảy ra sự cố hoặc chúng ta có thể sử dụng `vmmap` để xem địa chỉ tải cho một ứng dụng đang chạy.

Cuối cùng, chúng tôi đã xem qua một số ví dụ về tính toán trang chiếu ASLR để quay lại không gian địa chỉ tệp.

Bây giờ chúng ta có thể thảo luận về thông tin gỡ lỗi, trong đó có các liên kết quan trọng giữa địa chỉ tệp và mã nguồn.

Xcode tạo thông tin gỡ lỗi khi bạn xây dựng ứng dụng của mình và sẽ nhúng nó trực tiếp vào các tệp nhị phân ứng dụng của bạn hoặc lưu trữ nó dưới dạng một tệp riêng biệt, chẳng hạn như dSYM.

Có một vài danh mục hoặc loại thông tin gỡ lỗi.

Mỗi người cung cấp một mức độ chi tiết khác nhau cho một địa chỉ tệp nhất định.

Hôm nay chúng ta sẽ xem xét ba loại thông tin gỡ lỗi khác nhau.

Đầu tiên, chúng ta sẽ đề cập đến hàm bắt đầu, bản thân nó không thêm quá nhiều giá trị, nhưng nó là một điểm khởi đầu phổ biến.

Tiếp theo chúng ta sẽ thấy các bảng ký hiệu nlist, thêm tên hàm và phương thức.

Cuối cùng, chúng ta sẽ xem xét DWARF, xuất phát từ dSYMs và các thư viện tĩnh.

DWARF bổ sung nhiều chi tiết nhất, bao gồm tên tệp, số dòng và bản ghi tối ưu hóa.

Vì DWARF cung cấp nhiều chi tiết nhất, chúng tôi thực sự muốn cố gắng có loại thông tin gỡ lỗi này bất cứ khi nào có thể.

Chúng ta sẽ tìm hiểu về từng thứ này và cách chúng có thể được sử dụng để xây dựng nhật ký sự cố mang tính biểu tượng đầy đủ.

Hãy bắt đầu với chức năng bắt đầu.

Như chúng ta đã thấy trong bảng, chức năng bắt đầu cung cấp ít chi tiết mã nguồn nhất.

Cũng đúng với tên của nó, loại thông tin gỡ lỗi này chỉ cho chúng ta biết về địa chỉ đầu tiên - hoặc bắt đầu theo nghĩa đen - của các chức năng của chúng ta.

Ví dụ, điều này sẽ cho chúng ta biết rằng một hàm bắt đầu và tồn tại tại một địa chỉ nhất định.

Tuy nhiên, nó không cho chúng ta biết chức năng nào bắt đầu từ những địa chỉ đó, chỉ có điều chúng tồn tại.

Chức năng bắt đầu gỡ lỗi thông tin thực hiện điều này bằng cách mã hóa danh sách các địa chỉ trong phân đoạn `__LINKEDIT` của ứng dụng của bạn.

Vì cái này được nhúng trực tiếp vào ứng dụng của bạn, tiêu đề Mach-O cũng có lệnh tải để thông báo cho chúng tôi nơi chúng tôi có thể tìm thấy nó, đó là `LC_FUNCTION_STARTS`.

Bạn có thể tự mình xem những thứ này bằng lệnh `symbols` và cờ `-onlyFuncStartsData`.

Ở đây chúng tôi lấy lại danh sách các địa chỉ và trình giữ chỗ rỗng.

Những trình giữ chỗ này lý tưởng sẽ có tên hàm và phương thức thay vì null, nhưng hàm bắt đầu dữ liệu không cung cấp tên.

Một lần nữa, đây không phải là dữ liệu mô tả nhiều nhất.

Tuy nhiên, nó cho phép cập nhật nhẹ nhật ký sự cố.

Bây giờ chúng ta có thể xem các địa chỉ tệp dưới dạng phần bù từ một hàm.

Ví dụ, trước tiên chúng ta quay lại tệp bằng cách trừ đi giá trị slide ASLR.

Sau đó, chúng tôi tìm thấy giá trị bắt đầu hàm có thể chứa địa chỉ tệp.

Trong trường hợp này, chỉ có giá trị đầu tiên mới có thể chứa địa chỉ vì tất cả các giá trị khác đều lớn hơn địa chỉ.

Cuối cùng, chúng tôi có thể khẳng định rằng địa chỉ tệp của chúng tôi thực sự là 264 byte trong chức năng này.

Điều này chủ yếu hữu ích cho những người gỡ lỗi, vì họ có thể hiểu chi tiết về cách chức năng này được thiết lập và thanh ghi nào đã được sửa đổi.

Tuy nhiên, điều này có ý nghĩa đối với bạn là nếu bạn gặp nhật ký sự cố thiếu tên hàm, có lẽ bạn đang xử lý thông tin gỡ lỗi ở mức thấp nhất này.

Đây là tin tốt vì nó có nghĩa là có rất nhiều cơ hội để làm phong phú nhật ký sự cố với thông tin gỡ lỗi tốt hơn.

Đương nhiên, cấp độ chi tiết tiếp theo mà chúng tôi muốn thấy là tên hàm.

Điều này mang lại cho chúng tôi cơ hội thực sự đầu tiên để lấy nhật ký sự cố hoặc dấu vết của Công cụ và sử dụng nó để theo dõi sự cố trong mã nguồn của chúng tôi.

Điều này dẫn chúng ta đến các bảng biểu tượng nlist.

Các bảng ký hiệu được xây dựng dựa trên ý tưởng bắt đầu hàm và cũng mã hóa danh sách thông tin trong phân đoạn `__LINKEDIT` và cũng có lệnh tải riêng.

Tuy nhiên, thay vì chỉ mã hóa địa chỉ, chúng mã hóa các cấu trúc C.

Điều này cho phép chúng tôi thêm nhiều chi tiết hơn cho bất kỳ mục nhập nhất định nào so với chức năng bắt đầu.

Cụ thể, họ mã hóa cấu trúc `nlist_64`.

Ở đây chúng ta có định nghĩa của cấu trúc đó.

Một cái nhìn lướt qua cho thấy rằng chúng ta có quyền truy cập vào một tên và một số thuộc tính.

Các giá trị của các trường cấu trúc này được xác định bởi `n_type` của nlist.

Có ba loại n_ chính mà chúng tôi quan tâm, nhưng hiện tại chúng tôi sẽ chỉ tập trung vào hai.

Cái đầu tiên được gọi là biểu tượng trực tiếp.

Đây là những chức năng và phương pháp mà bạn đã xác định đầy đủ trong các ứng dụng và khuôn khổ của mình.

Các ký hiệu trực tiếp có tên và địa chỉ trong cấu trúc `nlist_64`.

Ngoài ra, chúng được biểu diễn bằng một mẫu bit cụ thể trong trường `n_type`.

Cụ thể, `n_type` sẽ có bộ bit ít quan trọng thứ hai, thứ ba và thứ tư.

Những bit này còn được gọi là `N_SECT`.

Chúng ta có thể thấy những thứ này với `nm` và chỉ định cờ `-defined-only` và `--numeric-sort`.

Ở đây, `nm` đã xem qua các biểu tượng được xác định của chương trình MagicNumbers và liệt kê chúng theo thứ tự địa chỉ.

Những cái tên chúng tôi lấy lại có vẻ khó hiểu.

Đó là bởi vì những cái tên thực sự được lưu trữ trong các bảng biểu tượng là những cái tên bị xáo trộn.

Những cái tên bị xáo trộn này giúp trình biên dịch và trình liên kết xác định duy nhất một hàm, nhưng chúng không dễ hiểu trừ khi chúng bị gỡ rối.

Để có được một phiên bản thân thiện hơn của những cái tên này, tôi đã chuyển đầu ra cho `swift-demangle`.

Bây giờ chúng tôi nhận được một số tên quen thuộc, chẳng hạn như `main` và `numberChoices`, bởi vì chúng được xác định trực tiếp trong ứng dụng của tôi.

Tương tự, công cụ `symbols` có một tùy chọn để hiển thị dữ liệu nlist và nó cũng tự động gỡ rối các tên.

Bây giờ chúng ta có thể liên kết tên hàm với một địa chỉ, điều này cho phép chúng ta cập nhật nhật ký sự cố một lần nữa.

Ở đây chúng ta có thể quan sát thấy rằng biểu thức bù đắp mà chúng ta nhận được từ dữ liệu bắt đầu hàm cũng khớp với một mục nhập từ các ký hiệu trực tiếp và mục nhập đó có tên.

Kết hợp hai thứ này lại với nhau, bây giờ chúng ta có thể nói rằng sự cố của chúng ta đã xảy ra ở mức 264 byte vào chính.

Điều này vẫn để lại một số chi tiết mong muốn, vì chúng tôi biết một thực tế rằng main không phải là chức năng duy nhất liên quan.

Và nó cũng sẽ giúp có một số dòng chính xác.

Chúng tôi đã gặp phải một cái gì đó tương tự như thế này trong ví dụ theo dõi Công cụ - chúng tôi có sẵn một số tên hàm, nhưng nó đã bỏ lỡ những tên khác.

Một lý do cho điều này là bảng biểu tượng chỉ có các mục nhập biểu tượng trực tiếp cho các chức năng liên quan đến liên kết.

Đây là những chức năng mà bạn sử dụng trên các mô-đun hoặc chức năng mà bạn xuất từ các khuôn khổ của mình.

Điều này làm cho nó hữu ích cho việc xác định ranh giới API.

Và nó cũng có nghĩa là nó có dữ liệu cần thiết để cung cấp năng lượng tải động với các chức năng như `dlsym()` và `dladdr()`.

Tuy nhiên, một nhược điểm là các hàm cục bộ hoặc tĩnh không được biểu diễn trong bảng ký hiệu vì chúng không được tham chiếu bên ngoài mô-đun của chúng.

Điều này cuối cùng bỏ qua các chức năng triển khai nơi chúng ta có thể có một phần đáng kể của logic ứng dụng.

Hơn nữa, thông thường các tệp nhị phân được xây dựng ở chế độ Phát hành để loại bỏ bảng biểu tượng của chúng.

Điều này có nghĩa là các mục nhập không cần thiết sẽ bị xóa khỏi bảng biểu tượng, giúp giảm kích thước ứng dụng của bạn.

Nếu chúng ta nghĩ về nó, việc trình điều khiển chính của ứng dụng của chúng ta xuất chức năng ở bất cứ đâu là không phổ biến, vì vậy chúng ta sẽ lãng phí không gian để giữ các mục nhập bảng biểu tượng đó xung quanh.

Đối với các khuôn khổ và thư viện của chúng tôi, chúng tôi chắc chắn đã xuất các chức năng mà khách hàng nên sử dụng, nhưng không cần phải giữ các chức năng được chia sẻ cục bộ vì chúng không thể được sử dụng ở bất kỳ nơi nào khác.

Việc loại bỏ các tệp thực thi ứng dụng chính của chúng tôi hầu như sẽ luôn để trống bảng biểu tượng.

Việc loại bỏ các khuôn khổ và thư viện của chúng tôi chỉ để lại các chức năng đã xuất.

Bạn có thể đã bắt gặp các cài đặt xây dựng trong Xcode như Sản phẩm được liên kết dải, Kiểu dải và Biểu tượng dải Swift.

Các cài đặt xây dựng này kiểm soát cách ứng dụng của bạn bị loại bỏ trong quá trình xây dựng.

Nếu Sản phẩm Liên kết Dải được bật, thì nhị phân sẽ bị tước theo Kiểu Dải.

Ví dụ, Tất cả các Biểu tượng sẽ thực hiện loại bỏ xâm lấn nhất và chỉ để lại những yếu tố cần thiết.

Non Globals loại bỏ các biểu tượng trực tiếp được sử dụng trong các mô-đun khác nhau của ứng dụng của bạn nhưng không được xuất để sử dụng trong các ứng dụng khác.

Biểu tượng gỡ lỗi loại bỏ loại thứ ba của loại nlist mà chúng ta sẽ thảo luận sau khi chúng ta đến DWARF.

Tuy nhiên, phong cách dải này vẫn giữ được các biểu tượng trực tiếp.

Ví dụ, ở đây tôi có một khuôn khổ xác định hai giao diện công khai và một chức năng triển khai được chia sẻ nội bộ.

Vì tất cả các chức năng này đóng một vai trò trong việc liên kết, tất cả chúng đều có các mục nhập biểu tượng trực tiếp.

Nếu tôi loại bỏ các giao diện không toàn cầu, thì tôi chỉ còn lại với các giao diện của mình.

Chức năng triển khai được chia sẻ chỉ được sử dụng trong khuôn khổ của tôi, vì vậy nó không được coi là toàn cầu.

Tương tự, việc loại bỏ tất cả các biểu tượng vẫn rời khỏi giao diện vì những điều này được yêu cầu cho các ứng dụng khác để sử dụng khung.

Bạn cũng có thể nhận thấy trong đầu ra `symbols --onlyNListData` rằng có các địa chỉ bắt đầu hàm xen kẽ giữa các ký hiệu trực tiếp.

Những địa chỉ này đại diện cho các chức năng không bao giờ có trong các ký hiệu trực tiếp hoặc đã bị tước bỏ.

Bạn có thể điều chỉnh các cài đặt dải này theo mức độ hiển thị bảng biểu tượng mong muốn của mình.

Với thông tin này, chúng tôi có thể xác định khi nào chúng tôi làm việc với các biểu tượng trực tiếp.

Một số dấu hiệu nhận biết về điều này là có tên hàm nhưng không có số dòng hoặc tên tệp; hoặc có sự kết hợp giữa tên hàm và địa chỉ bắt đầu hàm, như chúng ta có ở đây với ví dụ khung.

Loại cấu trúc nlist thứ hai mà chúng ta sẽ phân tích được gọi là biểu tượng gián tiếp, trái ngược với biểu tượng trực tiếp.

Đây là khi `n_type` chỉ khớp với mẫu bit `N_EXT`.

Đây là các hàm và phương thức mà bạn đang sử dụng từ các khung hoặc thư viện khác, chẳng hạn như `print()`.

Bạn có thể thấy những thứ này với `nm`, chỉ lần này chúng tôi sẽ chỉ định `--chỉ không xác định` thay vì `--chỉ xác định`.

Chúng tôi cũng sẽ thêm cờ `-m`, cờ này sẽ cho bạn thấy các khung hoặc thư viện mà các chức năng nên được tìm thấy trong đó.

Ví dụ, ứng dụng MagicNumbers phụ thuộc vào nhiều chức năng Swift được xác định trong libswiftCore.

Bây giờ chúng tôi đã đề cập đến hai trong số ba danh mục thông tin gỡ lỗi, hãy đảm bảo rằng chúng tôi hiểu các thuộc tính của chúng.

Chức năng bắt đầu là một danh sách các địa chỉ, vì vậy chúng thiếu tên, nhưng cho phép chúng tôi xác định độ lệch.

Các bảng ký hiệu nlist mã hóa toàn bộ cấu trúc thông tin và có thể liên kết tên với một địa chỉ.

Chúng mô tả các biểu tượng trực tiếp - được xác định trong ứng dụng của bạn - và các biểu tượng gián tiếp, được cung cấp bởi các phụ thuộc.

Các biểu tượng trực tiếp thường được dành riêng cho các chức năng liên quan đến liên kết và cài đặt xây dựng dải ảnh hưởng đến các biểu tượng trực tiếp nào có sẵn.

Cuối cùng, cả chức năng bắt đầu và bảng biểu tượng nlist đều được nhúng trực tiếp vào ứng dụng của bạn.

Những gì chúng ta chưa thấy là mức độ chi tiết phong phú hơn, chẳng hạn như tên tệp và số dòng.

Cái này được cung cấp cho chúng tôi bởi DWARF.

DWARF đưa các khái niệm về bảng biểu tượng nlist lên một cấp độ hoàn toàn khác.

Thay vì chỉ giữ lại một tập hợp con các chức năng, DWARF cố gắng mô tả mọi thứ.

Chúng tôi thấy rằng các bảng biểu tượng nlist đã bổ sung rất nhiều thông tin so với hàm bắt đầu.

Nó đã hoàn thành điều đó bằng cách thêm một chiều.

Hãy nhớ rằng, chúng ta bắt đầu chỉ với một chiều duy nhất, đó là địa chỉ, khi chúng ta nhìn vào hàm bắt đầu.

Sau đó, chúng tôi đã nâng cấp lên hai chiều bằng cách mã hóa một cấu trúc đầy đủ thông tin trong bảng ký hiệu nlist.

DWARF thêm một chiều thứ ba, đó là về các mối quan hệ.

DWARF nhận ra rằng các chức năng không bị cô lập.

Chúng gọi các hàm khác, chúng có các tham số, trả về dữ liệu có ý nghĩa và được xác định trong một tệp cụ thể.

Mã hóa các mối quan hệ này mở ra các khía cạnh mạnh mẽ nhất của biểu tượng.

Khi chúng tôi phân tích DWARF, chúng tôi chủ yếu đề cập đến một gói dSYM.

Ngoài các siêu dữ liệu khác như plists, gói dSYM chứa một tệp nhị phân với DWARF.

Điều gì khiến hệ nhị phân này trở nên đặc biệt?

Hệ nhị phân chứa dữ liệu của nó trong một phân đoạn `__DWARF` đặc biệt.

Thông số kỹ thuật của DWARF đề cập đến ba luồng dữ liệu trong phân khúc mà chúng tôi sẽ tập trung vào.

`debug_info` chứa dữ liệu thô, `debug_abbrev` gán cấu trúc cho dữ liệu và `debug_line` chứa tên tệp và số dòng.

DWARF cũng định nghĩa hai loại từ vựng mà chúng ta sẽ nghiên cứu đầu tiên: đơn vị biên dịch và chương trình con.

Chúng tôi sẽ giới thiệu cái thứ ba sau.

Một đơn vị biên dịch đại diện cho một tệp nguồn duy nhất đã đi vào việc xây dựng sản phẩm.

Ví dụ, chúng tôi có thể mong đợi có một đơn vị biên dịch cho mỗi tệp Swift trong dự án của chúng tôi.

DWARF gán các thuộc tính cho một đơn vị biên dịch, chẳng hạn như tên của tệp, SDK, phần của phân đoạn `__TEXT` mà các chức năng của nó chiếm và hơn thế nữa.

Đơn vị biên dịch main.swift chứa các thuộc tính này trong luồng `debug_info` ở bên trái và nó có một mục nhập tương ứng trong luồng `debug _abbrev` ở bên phải cho chúng ta biết các giá trị đại diện cho điều gì.

Ở đây chúng ta thấy tên tệp, ngôn ngữ được viết và một cặp thấp/cao đại diện cho phạm vi phân đoạn `__TEXT`.

Một chương trình con đại diện cho một hàm được xác định.

Chúng tôi đã thấy các hàm được xác định trong bảng ký hiệu nlist, nhưng chương trình con cũng có thể mô tả các hàm tĩnh và cục bộ.

Một chương trình con cũng có tên và phạm vi địa chỉ phân đoạn `__TEXT` của nó.

Một mối quan hệ cơ bản giữa các đơn vị biên dịch và các chương trình con là các chương trình con được xác định trong một đơn vị biên dịch.

DWARF đại diện cho điều này bằng một cái cây.

Đơn vị biên dịch nằm ở gốc của cây và nó có các mục nhập chương trình con khi còn nhỏ.

Những đứa trẻ có thể tìm kiếm bằng cách theo dõi phạm vi địa chỉ của chúng.

Chúng ta có thể kiểm tra những điều này chi tiết hơn bằng lệnh `dwarfdump`.

Đầu tiên chúng ta sẽ xem xét một đơn vị biên dịch.

Điều này khớp với một số thuộc tính của một đơn vị biên dịch mà tôi đã đề cập trước đó.

`dwarfdump` kết hợp hữu ích nội dung `debug_ info` và `debug _abbrev` để hiển thị cho bạn cấu trúc và nội dung của dữ liệu trong dSYMs của bạn.

Và nếu chúng ta cuộn xuống đầu ra, chúng ta sẽ gặp một chương trình con.

Phạm vi địa chỉ mà nó chiếm nằm trong giới hạn của đơn vị biên dịch và chúng ta cũng có thể thấy tên của hàm.

Tôi đã đề cập rằng DWARF mô tả dữ liệu của nó cực kỳ chi tiết.

Mặc dù chúng ta sẽ không dành nhiều thời gian cho tất cả các chi tiết này, nhưng tôi nghĩ thật thú vị khi thấy các chi tiết như các tham số hàm.

Họ có loại từ vựng riêng mô tả tên và loại tham số.

Theo mô hình cây, một tham số là con của một chương trình con.

Ở đây chúng ta bắt gặp mục nhập cho tham số lựa chọn mà chúng ta cung cấp cho một hàm.

Tiếp theo, tên tệp và số dòng đến từ luồng `debug_line`.

Dòng suối này không có cấu trúc cây.

Thay vào đó, nó định nghĩa một chương trình bảng dòng trong đó các địa chỉ tệp riêng lẻ có thể được ánh xạ trở lại một dòng mã chính xác.

Điều này cuối cùng tạo ra một danh sách các chi tiết mã nguồn mà chúng ta có thể tìm kiếm để tìm tệp và dòng.

Nếu chúng ta phân tích cú pháp cây `debug_info` và tạo danh sách `debug_line`, chúng ta sẽ kết thúc với một cấu trúc như sau.

Vì vậy, nếu muốn khớp với một địa chỉ tệp, chúng ta có thể đi qua cây.

Đầu tiên, chúng ta sẽ bắt đầu từ đơn vị biên dịch và theo dõi các nhánh.

Sau đó, chúng tôi sẽ chọn bất kỳ mục nhập `debug_line` nào khớp.

Chúng ta có thể tự động hóa điều này một lần nữa với `atos`, chỉ lần này tôi đặc biệt bỏ cờ `-i`.

Chú ý bất cứ điều gì hơi kỳ lạ ở đây?

Vâng, chúng tôi có tên hàm và số dòng, vì vậy chúng tôi chắc chắn đang sử dụng DWARF.

Tuy nhiên, ngoài điều này không quá khác biệt so với bản cập nhật bảng biểu tượng nlist.

Trên thực tế, khi chúng tôi so sánh nó với lần đầu tiên chúng tôi sử dụng `atos`, có vẻ như chúng tôi vẫn đang thiếu rất nhiều chức năng và chi tiết có giá trị!

Chuyện gì đã xảy ra ở đây vậy?

Điều duy nhất thay đổi là lần này chúng tôi đã không chỉ định `-i` cho `atos`.

Lá cờ đó là viết tắt của "các chức năng nội tuyến."

Inlining là một tối ưu hóa thông thường mà trình biên dịch thực hiện.

Điều này liên quan đến việc thay thế trực tiếp một cuộc gọi hàm bằng phần thân của hàm.

Một hiệu ứng thú vị mà nó có là làm cho mã dường như biến mất.

Chúng ta có thể nghĩ về nó vì, thay vì gọi `numberChoices()`, toàn bộ mã cho `numberChoices()` đã bị bỏ vào vị trí.

Đột nhiên không còn lệnh gọi hàm nào đến `numberChoices()` nữa!

DWARF đại diện cho điều này với một chương trình con nội tuyến.

Đây là loại từ vựng thứ ba và cuối cùng cho DWARF mà chúng ta sẽ thảo luận hôm nay.

Một chương trình con nội tuyến là một chương trình con - vì vậy nó là một hàm - được nội tuyến vào một chương trình con khác.

Vì một hàm nội tuyến hoàn toàn bị nhấn chìm bởi một nút khác trong cây mối quan hệ, chương trình con nội tuyến là con của nút đó.

Định nghĩa này cũng áp dụng đệ quy, có nghĩa là một chương trình con nội tuyến có thể có những đứa trẻ nội tuyến khác.

Một lần nữa, với `dwarfdump`, chúng ta có thể tìm kiếm các chương trình con nội tuyến.

Chúng được liệt kê là con của các nút khác và có các thuộc tính tương tự như các chương trình con, chẳng hạn như tên và địa chỉ.

Tuy nhiên, trong DWARF, các thuộc tính này thường được truy cập thông qua một nút chung, được gọi là nguồn gốc trừu tượng.

Nếu có nhiều bản sao nội tuyến của một hàm cụ thể, thì các thuộc tính chung, được chia sẻ của chúng được giữ trong nguồn gốc trừu tượng để chúng không bị sao chép ở mọi nơi.

Một thuộc tính duy nhất mà các chương trình con nội tuyến có là một trang web cuộc gọi.

Đây là vị trí trong mã nguồn của chúng tôi, nơi chúng tôi đã viết lệnh gọi hàm thực tế, nhưng trình tối ưu hóa đã thay thế nó.

Ví dụ ở đây, chúng tôi đã thực hiện cuộc gọi đến `generateANumber` trên dòng 36 của tệp main.swift.

Điều này cho phép chúng tôi cập nhật cây của mình với các nút con mới.

Và bây giờ điều này trông giống như một cái nhìn toàn diện hơn nhiều về chương trình của chúng tôi.

Các chi tiết tối ưu hóa cho các chức năng nội tuyến là các chi tiết chính trong việc đưa chúng ta đến nhật ký sự cố được tượng trưng hóa hoàn toàn.

Cờ `-i` cho `atos` hướng dẫn công cụ xem xét chúng trong quá trình biểu tượng hóa.

Chúng cũng là những chi tiết còn thiếu từ dấu vết Dụng cụ của chúng tôi.

Lý do tại sao chúng tôi cần một dSYM cho cả Công cụ và nhật ký sự cố chính xác là để chúng tôi có thể trích xuất tất cả nội dung này.

Có một nguồn khác mà bạn sẽ tìm thấy DWARF, và đó là từ các thư viện tĩnh và các tệp đối tượng.

Trong trường hợp không có dSYM, bạn vẫn có thể thu thập DWARF cho các hàm mà bạn đã liên kết từ thư viện tĩnh hoặc tệp đối tượng.

Trong những trường hợp đó, bạn sẽ tìm thấy các loại nlist Biểu tượng gỡ lỗi.

Đây là một trong những loại biểu tượng có thể bị tước bỏ.

Tuy nhiên, họ không tự mình giữ DWARF.

Thay vào đó, họ liên kết một hàm trở lại tệp mà họ đến.

Nếu thư viện được xây dựng với thông tin gỡ lỗi, thì mục nhập nlist có thể trỏ chúng ta đến DWARF đó.

Những loại mục nhập nlist này có thể được nhìn thấy chi tiết với `dsymutil -dump-debug-map`.

Ở đây chúng tôi có danh sách các chức năng khác nhau và nơi chúng được lấy từ.

Những vị trí đó có thể được quét và xử lý cho DWARF.

Tóm lại, DWARF là một nguồn quan trọng của dữ liệu biểu tượng chuyên sâu.

DWARF phơi bày các mối quan hệ quan trọng giữa các chức năng và tệp.

Các tối ưu hóa như nội tuyến chức năng có tác động rất lớn đến chất lượng biểu tượng và DWARF có thể thể hiện nó rất tốt.

Chúng tôi cũng thấy rằng dSYM và thư viện tĩnh chứa DWARF.

Tuy nhiên, vui lòng ưu tiên dSYM vì bạn có thể dễ dàng chuyển chúng cho người khác và có hỗ trợ tích hợp từ một số công cụ.

Cuối cùng, tôi muốn chia sẻ các công cụ và mẹo khác nhau mà bạn có thể sử dụng để tạo điều kiện tượng trưng.

Đối với các bản dựng phát triển cục bộ, bạn thường sẽ có rất nhiều thông tin gỡ lỗi nếu bạn xây dựng ở chế độ gỡ lỗi.

Đối với chế độ phát hành, bạn có thể đảm bảo rằng Xcode tạo ra dSYM bằng cách kiểm tra cài đặt xây dựng Định dạng Thông tin Gỡ lỗi.

Đảm bảo Bản phát hành được đặt thành DWARF với Tệp dSYM.

Đối với các ứng dụng đã được gửi đến App Store, bạn có thể tải xuống dSYM của mình thông qua App Store Connect.

Điều này cũng bao gồm bất kỳ ứng dụng nào có bật mã bit.

Nếu bạn muốn kiểm tra xem một dSYM nhất định đã có trên thiết bị của mình chưa, bạn có thể sử dụng lệnh `mdfind`.

Chuỗi chữ và số ở đây là UUID nhị phân của bạn, là một mã định danh duy nhất được xác định trong lệnh tải.

Bạn có thể xem UUID cho dSYM của mình với `biểu tượng -uuid`.

Đôi khi, một chuỗi công cụ có thể tạo ra DWARF không hợp lệ.

Bạn có thể kiểm tra điều này với `dwarfdump -verify`.

Nếu bạn thấy bất kỳ lỗi nào được báo cáo, vui lòng gửi lỗi!

Dữ liệu DWARF cũng có giới hạn bốn gigabyte trên mỗi nhị phân.

Nếu bạn đang gặp sự cố với dSYM của mình và thấy rằng chúng vượt quá bốn gigabyte, hãy cân nhắc chia dự án thành các thành phần riêng biệt để mỗi thành phần có dSYM nhỏ hơn của riêng mình.

Bạn có thể đảm bảo rằng dSYM bạn đang sử dụng khớp với bản dựng cụ thể của ứng dụng mà bạn quan tâm bằng cách so sánh UUID.

UUID của ứng dụng nằm trong phần danh sách Hình ảnh nhị phân của các báo cáo sự cố và bạn cũng có thể xem nó bằng lệnh `biểu tượng`.

Bạn nên đảm bảo rằng cả ứng dụng và dSYM của bạn đều có cùng UUID.

Công cụ `symbols` cũng cho phép bạn kiểm tra các loại thông tin gỡ lỗi mà ứng dụng của bạn có sẵn.

Chúng tôi đã thấy các ví dụ về điều này, nhưng đó là một lời nhắc nhở hữu ích rằng các thẻ này trong ngoặc vuông cho bạn biết nguồn thông tin.

Sẽ rất hữu ích nếu bạn không chắc chắn mình có thể đang xử lý thông tin gỡ lỗi nào.

Nếu bạn chắc chắn rằng bạn có sẵn dSYM nhưng vẫn không nhận được tên cho các chức năng của mình trong dấu vết Công cụ, vui lòng kiểm tra quyền lợi và ký mã của bạn.

Cụ thể, với lệnh `codesign`, bạn có thể xác minh rằng bạn có chữ ký mã thích hợp.

Bạn cũng nên xác minh rằng các ứng dụng được xây dựng cục bộ để phát triển có quyền `get-task-allow`.

Quyền này cấp quyền cho các công cụ như Công cụ để tượng trưng cho ứng dụng của bạn.

Xcode nên tự động đặt quyền này với hành động Hồ sơ, nhưng nó rất hữu ích để xác minh.

Nếu bạn chưa bật quyền `get-task-allow`, bạn nên kiểm tra cài đặt xây dựng Quyền cơ sở tiêm ký mã của mình và đảm bảo rằng nó được bật khi bạn đang phát triển.

Cuối cùng, đối với các ứng dụng Universal 2, bạn nên chỉ định kiến trúc mà bạn quan tâm cho các công cụ.

`symbols`, `otool` và `dwarfdump` đều có cờ `-arch` chỉ hoạt động trên một lát kiến trúc cụ thể.

Điều này kết luận "Biểu tượng: Vượt ra ngoài những điều cơ bản."

Nếu không có gì khác, tôi muốn thực sự nhấn mạnh một vài điểm chính.

UUID và địa chỉ tệp là một cách nhất quán và đáng tin cậy để xác định ứng dụng của bạn đang làm gì vì chúng độc lập với slide ASLR.

Chúng cũng là chìa khóa của chúng tôi để truy vấn thông tin gỡ lỗi.

Bạn cũng nên sử dụng dSYM bất cứ khi nào có thể.

dSYMs chứa thông tin gỡ lỗi phong phú nhất dưới dạng DWARF và được hỗ trợ bởi Xcode và Instruments.

Cuối cùng, chúng tôi đã đề cập đến một số công cụ.

Những công cụ này có sẵn cho bạn trong Xcode và chúng cung cấp các chẩn đoán và thông tin chi tiết mạnh mẽ.

Bạn nên cố gắng kết hợp chúng vào quy trình làm việc của mình để gỡ lỗi và tối ưu hóa.

Nếu bạn quan tâm đến việc tìm hiểu thêm, tôi khuyên bạn nên sử dụng hai phiên này từ WWDC18 để tìm hiểu cách các ứng dụng của bạn trở nên sống động khi ra mắt: "Tối ưu hóa thời gian khởi động ứng dụng" và "Thời gian khởi động ứng dụng: Quá khứ, hiện tại và tương lai".

Cảm ơn tất cả các bạn rất nhiều vì đã tham gia cùng tôi để tìm hiểu về biểu tượng hóa!

Chúc bạn có một phần còn lại tuyệt vời trong tuần.

♪