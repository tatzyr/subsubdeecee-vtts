10021

Xin chào, tôi là Jacob, và chào mừng đến với "Thêm đồ họa phong phú vào ứng dụng SwiftUI của bạn."

Tôi đang làm việc trên một ứng dụng để xây dựng gradient với một vài đồng nghiệp của mình.

Năm nay, màu sắc là thứ nóng bỏng trong đội của chúng tôi.

Hầu hết việc triển khai đã được thực hiện.

Bây giờ tôi chỉ cần hoàn thành nó bằng cách thêm một số đồ họa phong phú.

Khi chúng tôi tùy chỉnh ứng dụng, chúng tôi sẽ thấy một vài khu vực khác nhau: làm việc với khu vực an toàn, bao gồm tùy chỉnh nó; hỗ trợ phong cách tiền cảnh mới; một bộ vật liệu mới phong phú; và vẽ bằng Canvas, một chế độ xem mới mạnh mẽ.

Vậy hãy bắt đầu nào.

Tôi sẽ cho bạn thấy những gì có trong ứng dụng cho đến nay.

Chúng tôi có một thư viện các gradient, và tôi có thể xem các gradient đó.

Có điều gì đó về cái này mà tôi thực sự thích.

Tôi chỉ không thể đặt ngón tay của mình lên nó.

Tôi cũng có thể chỉnh sửa một gradient...

Điều đó cho phép tôi thay đổi màu sắc dừng lại.

Và tôi có thể thêm một gradient mới.

Tôi cũng có thể sử dụng các gradient này trong một số trình hiển thị...

Nhưng từng bước một. Chúng ta sẽ xem xét chúng một lát sau.

Hiện tại, hãy tập trung vào chế độ xem chi tiết gradient này.

Nó có chức năng, nhưng nội dung thực tế của chúng tôi khá nhỏ so với chrome và không gian trống.

Tôi muốn độ dốc thực sự chiếm lĩnh màn hình này.

Vậy hãy bắt đầu chỉnh sửa nó trong Xcode.

Đây là chế độ xem chi tiết chính của chúng tôi và nó cũng được sử dụng cho chế độ chỉnh sửa của chúng tôi.

Hãy bắt đầu với isEditing false, và chúng ta sẽ xem xét chế độ chỉnh sửa sau.

Hãy làm cho gradient của chúng ta sử dụng càng nhiều không gian càng tốt bằng cách xóa khung này.

Và bây giờ độ dốc đang chiếm hết chiều cao, chúng ta không còn cần miếng đệm này nữa.

Chúng ta có thể tiến xa hơn nữa bằng cách đặt các điều khiển của mình lên trên gradient này bằng cách thay đổi điều này thành ZStack.

Nếu bạn chưa từng nhìn thấy ZStack trước đây, nó sẽ đặt các yếu tố chồng lên nhau thay vì cạnh nhau.

Hãy di chuyển các điều khiển chỉnh sửa của chúng ta xuống dưới cùng.

Và chúng ta chỉ cần đệm trên các điều khiển, không phải trên gradient của chúng ta...

Vậy hãy di chuyển cái này.

Bạn có thể tự hỏi tại sao vẫn còn khoảng trống ở trên cùng và dưới cùng của gradient, ngay cả sau khi chúng tôi đã loại bỏ phần đệm.

Theo mặc định, SwiftUI định vị nội dung của bạn trong khu vực an toàn, tránh mọi thứ có thể che khuất hoặc cắt chế độ xem của bạn, như chỉ báo Trang chủ hoặc bất kỳ thanh nào đang được hiển thị.

Khu vực an toàn được thể hiện dưới dạng khu vực được chèn vào từ khu vực đầy đủ ngoài cùng nơi hiển thị chế độ xem.

Nội dung trong khu vực an toàn được tự động bố trí trong các nội dung thích hợp để tránh những khu vực mà nó sẽ bị che khuất.

Khu vực an toàn cũng là cách SwiftUI giúp bạn tránh vẽ nội dung dưới bàn phím.

Vì vậy, trong ứng dụng của chúng tôi, các điều khiển của chúng tôi sẽ tự động nhấc ra khỏi bàn phím.

Điều này hoạt động theo cùng một cách, và nếu chúng ta xem xét kỹ hơn về cách thức, đó là bởi vì có nhiều khu vực an toàn khác nhau.

Cái phổ biến nhất là khu vực an toàn container, được điều khiển bởi container, chế độ xem được hiển thị bên trong và bao gồm những thứ như thanh và thiết bị mạ crôm.

Ngoài ra, có một khu vực an toàn cho bàn phím để tránh bàn phím.

Và lưu ý rằng khu vực an toàn bàn phím luôn là khu vực trong khu vực an toàn thùng chứa.

Nó giữ nội dung an toàn từ cùng khu vực với khu vực an toàn thùng chứa ngoài bàn phím.

Có thể chọn không tham gia các khu vực an toàn.

Thông thường bạn sẽ không cần phải làm điều này, vì hầu hết nội dung phải nằm trong khu vực an toàn để nó không bị cắt xén.

Rốt cuộc thì nó an toàn.

Nhưng bỏ qua khu vực an toàn có thể có ý nghĩa đối với hình nền hoặc nội dung khác mà bạn muốn đi hết cạnh này sang cạnh khác.

Bạn có thể sử dụng mã này để chọn không tham gia tất cả các khu vực an toàn hoặc chỉ định khu vực bàn phím để chọn không tham gia khu vực an toàn bàn phím.

Hãy thêm ignoresSafeArea vào gradient tuyến tính của chúng tôi để có được hiệu ứng chảy máu đầy đủ đó.

Nút Chỉnh sửa này không hiển thị rõ trên đỉnh gradient của chúng tôi, vì vậy hãy bỏ qua khu vực an toàn ở cạnh dưới.

Bây giờ, để đảm bảo rằng chúng ta không gặp phải vấn đề tương tự với văn bản dưới cùng này không đọc được từ gradient, hãy thêm một nền đằng sau nó.

Chúng tôi sẽ tùy chỉnh nền trong một phút, nhưng hãy bắt đầu với mặc định đơn giản nhất, cho chúng tôi nền trắng tự động thay đổi trong Chế độ tối.

Và nền này cũng tự động mở rộng ra ngoài khu vực an toàn.

Phiên bản nền này và hành vi của nó là mới trong iOS 15 và các bản phát hành hệ điều hành phù hợp.

Hãy xem nó hoạt động như thế nào.

Hãy bắt đầu với chế độ xem container và khu vực an toàn của nó.

Sau đó, chúng tôi có chế độ xem nội dung của mình, nó sẽ chỉ nằm trong khu vực an toàn để giữ cho nó dễ đọc.

Nếu chúng ta ngây thơ thêm một nền có cùng giới hạn vào chế độ xem mà nó được áp dụng, chúng ta sẽ nhận được điều này.

Nhưng nếu chúng ta áp dụng công cụ sửa đổi ignoresSafeArea chỉ cho chế độ xem nền, thì nó sẽ mở rộng ra ngoài khu vực an toàn trong khi vẫn giữ cho nội dung chính đẹp và an toàn.

Công cụ sửa đổi nền mới tự động cung cấp cho bạn hành vi này.

Hãy quay lại nền tảng của chúng ta và bắt đầu tùy chỉnh nó.

Chúng ta có thể vượt qua một phong cách cụ thể, có thể là một màu hoặc bất kỳ phong cách nào khác, như một gradient.

Nó không thực sự có ý nghĩa trong ứng dụng này, nhưng hãy nhìn vào thứ gì đó màu pastel.

Tôi cũng có thể chuyển một hình dạng để cắt nền này để...

Ví dụ, một hình chữ nhật tròn.

Lưu ý rằng khi tôi sử dụng một hình dạng tùy chỉnh, nền không còn mở rộng ra khỏi khu vực an toàn để hình dạng phù hợp với giới hạn nội dung của bạn.

Những gì tôi nghĩ sẽ phù hợp với ứng dụng của chúng tôi hơn là làm mờ nền của chúng tôi.

Chúng ta có thể sử dụng một API mới khác để làm điều đó: Vật liệu.

Vật liệu là một tập hợp các kiểu làm mờ tiêu chuẩn mà bạn có thể áp dụng.

Và hãy làm cho nền này quay trở lại chiếm toàn bộ khu vực.

Tài liệu rất tuyệt vời cho những nơi mà chúng tôi muốn hiển thị thông qua nội dung đầy màu sắc như thế này.

Có một bộ vật liệu khác nhau mà bạn có thể lựa chọn, từ Siêu Mỏng đến Siêu Dày.

Và tất cả những thứ này tự động hiển thị thiết kế phù hợp trên mọi nền tảng.

Tôi sẽ sử dụng một vật liệu mỏng ở đây.

Tiếp theo, tôi muốn tùy chỉnh văn bản của chúng tôi.

Hãy làm cho số lượng màu ít nổi bật hơn một chút để cho thấy rằng tên là thông tin chính ở đây.

Tôi có thể làm điều đó bằng cách thiết lập một phong cách tiền cảnh của thứ cấp.

Bạn có thể nhận thấy rằng nội dung phụ được hiển thị tự động với một hiệu ứng gọi là Vibrancy, kết hợp màu sắc đằng sau nó.

Trong SwiftUI, không có API bổ sung cho hiệu ứng này.

Nó xảy ra tự động khi bạn sử dụng các kiểu Trung học thông qua Đệ tứ mới trong bối cảnh vật chất.

Điều đó có thể xảy ra khi bạn thêm rõ ràng một nền với một tài liệu, như chúng tôi vừa làm, hoặc khi nội dung của bạn nằm trong một thành phần hệ thống, như thanh bên, thêm tài liệu cho bạn.

Và những phong cách này có rất nhiều thông minh tự động.

Chúng cũng tự động làm điều đúng đắn khi được sử dụng trong bối cảnh không bị mờ, nơi chúng không sử dụng hiệu ứng sống động.

Chúng cũng tự động thay đổi hành vi của chúng khi bạn đặt màu lên chúng, đặt các phiên bản màu cho từng cấp độ.

Và hỗ trợ tương tự hoạt động để thiết lập bất kỳ kiểu tiền cảnh cơ bản nào, ngay cả những thứ như độ dốc.

Vui lòng sử dụng một cách trang nhã.

Một điều cần lưu ý: Bất kỳ văn bản nhất định nào cũng có thể có một kiểu tiền cảnh duy nhất được áp dụng cho nó, nhưng nhiều màu trong phạm vi của nó.

Vì vậy, ví dụ, tôi có thể sử dụng phép nội suy chuỗi để nhúng một Văn bản bên trong...

Và sau đó áp dụng màu nền trước của màu đỏ...

Đến từ "màu sắc."

Và nó sẽ hiển thị màu đó, tự động chọn không tham gia sự sống động cho phạm vi đó.

Thậm chí quan trọng hơn, với những phong cách tiền cảnh này, lần đầu tiên, bạn có được hành vi đúng đắn với biểu tượng cảm xúc được nhúng, nơi chúng hoạt động.

Cái này trông ổn đấy.

Hãy chạy lại và thử chế độ Chỉnh sửa với những thay đổi này.

Nó hầu như đã hoạt động rồi.

Và những màu này bị mờ, điều đó thật tuyệt.

Nhưng nếu bạn nhìn kỹ, nó không làm điều hoàn toàn đúng đắn.

Khi tôi cuộn xuống hết cỡ, có một chút danh sách ẩn đằng sau vết mờ.

Hãy xem xét kỹ hơn những gì đang xảy ra.

Hãy lấy đi chrome và chỉ nhìn vào các quan điểm có liên quan, tại đây.

Nếu chúng ta trượt các chế độ xem này ra xa nhau một chút theo chiều ngang, chúng ta có thể thấy điều này là do thanh chỉ được xếp chồng lên trên nội dung của chúng ta.

Bây giờ chúng ta muốn xem tất cả các chế độ xem ở phía sau, đó không phải là hành vi đúng đắn.

Chúng tôi có thể thay đổi thành VStack ở đây, nhưng nếu không có danh sách dưới phần mờ, chúng tôi sẽ không nhận được bất kỳ màu nào hiển thị khi cuộn xuống.

Chúng tôi muốn nền của danh sách và khu vực có thể cuộn của nó mở rộng dưới thanh nhưng không phải nội dung chính của nó.

Và đây chính xác là mục đích của khu vực an toàn.

Nếu chúng ta làm cho khu vực an toàn bị chèn vào bởi thanh này, thì bất kỳ nội dung quan trọng nào sẽ không bị che khuất.

Để tùy chỉnh khu vực an toàn trong chế độ xem của riêng chúng tôi, chúng tôi có thể sử dụng công cụ sửa đổi mới: safeAreaInset.

Điều này cho phép chúng tôi thêm nội dung phụ trợ, như thanh của chúng tôi, qua nội dung chính.

Tôi sẽ thay thế ZStack của chúng ta...

Với một khu vực an toàn bên trong...

Sử dụng một cạnh của.đáy...

Và đặt sự kiểm soát của chúng tôi vào đó.

Hãy chạy lại lần nữa để kiểm tra.

Khung cảnh này trông vẫn như cũ, điều đó thật tốt.

Đó là bởi vì nó đang bỏ qua khu vực an toàn.

Và trong chế độ Chỉnh sửa...

Chúng ta vẫn có thể cuộn dưới thanh để làm mờ nó.

Nhưng khi chúng ta cuộn xuống dưới cùng, không có gì bị che khuất.

Tuyệt vời.

Tiếp theo, hãy xem các trình hiển thị của chúng tôi.

Hãy bắt đầu với trình hiển thị Shapes, đã được viết sẵn.

Nó hiển thị một số lượng lớn các biểu tượng hình dạng ngẫu nhiên, mỗi biểu tượng được vẽ bằng một trong các gradient từ ứng dụng.

Tôi có thể nhấn vào một biểu tượng để phóng to nó...

Hoặc nhấn vào nền để định vị lại tất cả các biểu tượng.

Và nếu bạn đã xem các bản trình diễn hoạt hình SwiftUI của chúng tôi trước đây, bạn biết rằng nó luôn tương tác và có thể bị gián đoạn.

Vì vậy tôi có thể tiếp tục sắp xếp lại...

Và thậm chí nhấn để chọn và bỏ chọn các hình dạng trong khi điều đó đang diễn ra.

Nếu tôi đi xem mã...

Nó đang sử dụng một kỹ thuật phổ biến để vẽ đồ họa trong SwiftUI.

Có một GeometryReader để tôi có thể đọc kích thước của chế độ xem để bố trí tất cả các đồ họa này và ZStack để giúp tôi định vị chúng.

Và ở cuối phần thân, có một công cụ sửa đổi mà bạn có thể đã thấy trước đây: drawingGroup.

Một drawingGroup yêu cầu SwiftUI kết hợp tất cả các chế độ xem mà nó chứa trong một lớp duy nhất để vẽ.

Điều này hoạt động tốt cho các yếu tố đồ họa như thế này nhưng không nên được sử dụng với các điều khiển giao diện người dùng như trường văn bản và danh sách.

Đây là một kỹ thuật tuyệt vời để sử dụng khi bạn muốn hiển thị một số lượng lớn các yếu tố đồ họa như chúng tôi đang làm ở đây.

Và một trong những lợi ích của drawingGroup là mặc dù các chế độ xem này được vẽ khác nhau, bạn vẫn có thể sử dụng cùng một chức năng từ SwiftUI mà bạn sử dụng ở mọi nơi khác trong ứng dụng của mình.

Ví dụ, ở đây, chúng tôi có một cử chỉ được áp dụng cho mỗi biểu tượng để chạm vào chúng và cũng là một hình ảnh động áp dụng khi chúng tôi thay đổi lựa chọn hoặc định vị lại chúng.

Thông tin khả năng truy cập có trong các chế độ xem này cũng được thông qua bình thường - ví dụ: các hành động khả năng truy cập này trên mỗi biểu tượng.

Tuy nhiên, để hỗ trợ tất cả các tính năng này, có một số sổ sách kế toán và lưu trữ cần thiết cho mỗi chế độ xem.

Nếu bạn có số lượng yếu tố đủ cao, thì ngay cả chi phí bổ sung đó cũng có thể là quá nhiều.

Và đối với những trường hợp đó, chúng tôi đã giới thiệu một chế độ xem Canvas mới.

Trình hiển thị tiếp theo của chúng tôi sẽ hiển thị một hệ thống hạt phức tạp và nó vẫn chưa được viết.

Hãy đi xây dựng nó.

Hãy bắt đầu với chế độ xem Canvas của chúng tôi để vẽ nó.

Điều này cho phép chúng tôi thực hiện một kết thúc chạy mỗi khi khung vẽ được vẽ và chứa các lệnh vẽ của chúng tôi.

Nếu bạn đã quen thuộc với drawRect trong UIKit hoặc AppKit, điều này hoạt động khá giống nhau.

Việc đóng cửa này cung cấp cho chúng ta một ngữ cảnh, đó là những gì chúng ta gửi lệnh vẽ đến và một kích thước mà chúng ta có thể sử dụng để có được kích thước của toàn bộ khung vẽ.

Hãy bắt đầu bằng cách vẽ một hình ảnh.

Tôi có thể tạo một cái bằng cách sử dụng cùng một loại Hình ảnh mà tôi sử dụng trong phần còn lại của mã SwiftUI của mình.

Và hãy nói với bối cảnh để vẽ hình ảnh của chúng ta.

Khi chúng ta vẽ nó ở 0,0, nó ở trên đây, tập trung vào điểm gốc, nơi nó không thể nhìn thấy rõ lắm.

Vì chúng ta có sẵn kích thước của toàn bộ khung vẽ, thay vào đó hãy sử dụng nó để vẽ nó ở giữa.

Và một điều bạn có thể thấy nếu tôi thay đổi bản xem trước của chúng tôi để ở Chế độ tối...

Đó có phải là hình ảnh của chúng tôi tự động lật để vẽ màu trắng, vì nó sử dụng cùng một kiểu tiền cảnh mà chúng tôi đã thấy trước đó.

Vì chúng ta muốn xây dựng một hệ thống hạt, hãy vẽ hình ảnh này thêm vài lần nữa.

Lưu ý rằng việc đóng cửa này dành cho mã mệnh lệnh.

Nó không phải là ViewBuilder.

Vì vậy, tôi chỉ có thể sử dụng một vòng lặp bình thường.

Và hãy thay đổi từng hình ảnh một chút để chúng ta thực sự có thể nhìn thấy chúng.

Bây giờ, chúng tôi đang vẽ hình ảnh này nhiều lần, nhưng mỗi lần, bối cảnh cần phải giải quyết nó để đánh giá nó dựa trên những thứ như môi trường hiện tại, mặc dù mỗi lần, đó là cùng một hình ảnh.

Chúng ta có thể cải thiện điều này bằng cách tự giải quyết hình ảnh trước khi vẽ nó.

Bây giờ chúng tôi có hiệu suất tốt hơn vì chúng tôi đang chia sẻ cùng một hình ảnh được giải quyết, nhưng hình ảnh được giải quyết cũng cho phép chúng tôi làm một số việc khác.

Bây giờ chúng ta có thể yêu cầu kích thước và đường cơ sở của nó.

Trong trường hợp của chúng tôi, chúng tôi sẽ sử dụng kích thước của nó để thay đổi từng cái với số lượng phù hợp.

Tiếp theo, hãy thêm các hình elip phía sau lấp lánh của chúng ta.

Tôi sẽ vẽ chúng trong cùng một khu vực.

Vì vậy, hãy kéo ra một khung để vẽ cả hai vào.

Tôi sẽ tạo một CGRect với cùng giá trị X và Y và sử dụng imageSize của chúng tôi cho chiều rộng và chiều cao...

Sau đó vẽ hình ảnh của chúng tôi trong khung đó.

Bởi vì mỗi thao tác vẽ được thực hiện theo thứ tự, để đặt hình elip của chúng ta phía sau hình ảnh, chúng ta cần vẽ nó trước.

Và chúng ta có thể vẽ nó với ngữ cảnh. điền vào...

Cái nào có một con đường và một bóng râm.

Bạn có thể xây dựng một đường dẫn với các đường cong bezier tiêu chuẩn, nhưng đây là một mẹo: Bạn cũng có thể sử dụng các hình dạng như hình elip và yêu cầu chúng cung cấp đường dẫn của chúng trong một hình chữ nhật nhất định.

Lập luận khác là một bóng râm, đó là thứ để lấp đầy con đường của chúng ta.

Và điều này có thể sử dụng các kiểu tương tự như phần còn lại của ứng dụng SwiftUI của chúng tôi.

Hãy sử dụng màu lục lam.

Và có những hình elip.

Tuy nhiên, không có nhiều sự tương phản với những hình ảnh.

Hãy sửa nó đi.

Bối cảnh đồ họa có nhiều thuộc tính vẽ tiêu chuẩn, như độ mờ, chế độ hòa trộn, biến đổi và hơn thế nữa.

Hãy đặt độ mờ ở đây.

Và chúng ta có thể xem xét một lĩnh vực mà bối cảnh này hoạt động hơi khác so với những gì bạn có thể đã quen.

Nếu tôi chỉ đặt độ mờ đục trên ngữ cảnh, thì nó sẽ hoạt động như bạn mong đợi.

Nó ảnh hưởng đến tất cả các hoạt động xảy ra sau đó.

Trước đây, nếu tôi muốn thay đổi ngữ cảnh đồ họa chỉ áp dụng cho một số thao tác vẽ của mình, tôi sẽ phải đặt các thao tác đó trong cuộc gọi lưu và khôi phục.

Nhưng với ngữ cảnh SwiftUI, tất cả những gì tôi phải làm là thực hiện các thay đổi trên một bản sao.

Và những thay đổi đó chỉ ảnh hưởng đến bản vẽ được thực hiện với ngữ cảnh đã sửa đổi.

Bản vẽ được thực hiện trên bối cảnh ban đầu không bị ảnh hưởng.

Hãy thêm một số màu sắc vào hình ảnh của chúng ta nữa.

Một điều khác mà chúng ta có thể làm với một hình ảnh được phân giải là đặt một bóng để kiểm soát cách các biểu tượng được vẽ.

Hãy đặt một màu xanh ở đây.

Điều đó trông kém sáng hơn một chút so với những gì tôi mong đợi.

Đôi khi khi bạn đang vẽ, chế độ hòa trộn phù hợp có thể tạo ra sự khác biệt lớn.

Các chế độ pha trộn kiểm soát cách kết hợp màu sắc, đặc biệt là với độ mờ một phần, như chúng ta có ở đây.

Hãy thiết lập chế độ hòa trộn màn hình.

Điều đó kết hợp màu sắc để chúng luôn sáng hơn.

Điều đó có vẻ tốt hơn.

Có rất nhiều thao tác vẽ khác mà bạn có thể làm.

Kiểm tra loại GraphicsContext để xem mọi thứ có thể.

Bây giờ, để làm cho điều này giống như một mô phỏng, nó cần phải thực sự di chuyển.

Có một vài công cụ để thay đổi theo thời gian trong SwiftUI.

Ảnh động là phổ biến nhất và chúng thường chỉ xảy ra tự động khi bạn thực hiện thay đổi.

Năm nay, chúng tôi sẽ giới thiệu một công cụ cấp thấp mới được gọi là TimelineView khi bạn muốn kiểm soát chính xác cách mọi thứ thay đổi theo thời gian.

Tôi có thể sử dụng TimelineView bằng cách quấn nó xung quanh chế độ xem mà tôi muốn thay đổi.

Và tôi có thể cấu hình nó với một lịch trình, cho biết tần suất cập nhật.

Có lịch trình cho những thứ như bộ hẹn giờ, nhưng chúng tôi sẽ sử dụng lịch trình hoạt hình để nhận thông tin cập nhật nhanh nhất có thể.

Nếu bạn đã quen thuộc với một liên kết hiển thị, liên kết này hoạt động rất giống nhau.

Và nếu bạn không, điều đó hoàn toàn ổn.

Chúng tôi được thông qua một bối cảnh dòng thời gian cung cấp cho chúng tôi thông tin về những gì chúng tôi nên hiển thị.

Tôi có thể rút ra thời gian trong vài giây mà chúng ta sẽ sử dụng để tạo hiệu ứng động cho hình ảnh của mình xung quanh.

Hãy làm cho hình ảnh của chúng ta di chuyển theo dao động quay.

Vì vậy, tôi sẽ tạo ra một góc nhìn từ thời điểm hiện tại.

Hãy lặp lại nó ba giây một lần bằng cách sử dụng phần còn lại...

Và nhân nó với 120 để đạt 360 độ.

Và chúng ta sẽ nhận được giá trị X với cosin.

Hay đó là sine?

Tôi hy vọng bạn nhớ lượng giác của mình.

Bây giờ hãy sử dụng giá trị đó để thay đổi phần bù của chúng ta...

Và xem trước trực tiếp các bản xem trước của chúng tôi để xem nó trông như thế nào.

Tốt. Xem làm thế nào khi chúng chồng lên nhau, chúng thậm chí còn sáng hơn?

Đó là chế độ hòa trộn màn hình của chúng tôi tại nơi làm việc.

Tiếp theo, hãy thêm một số tương tác.

Trước đó, chúng tôi đã xem xét một số tương tác mà chúng tôi có thể thực hiện bằng cách thêm cử chỉ vào chế độ xem cá nhân.

Hãy nhớ rằng một trong những sự đánh đổi của việc sử dụng canvas là các yếu tố riêng lẻ bên trong nó được kết hợp thành một bản vẽ duy nhất.

Vì vậy, chúng tôi không thể, ví dụ, gắn một cử chỉ vào những hình ảnh riêng lẻ này.

Tuy nhiên, chúng ta vẫn có thể thêm một cử chỉ vào toàn bộ chế độ xem.

Hãy thêm khả năng tăng số lượng lấp lánh được hiển thị.

Chúng tôi sẽ thêm một số trạng thái để hiển thị bao nhiêu.

Và hãy để nó bắt đầu với hai.

Hãy sử dụng số đếm để kiểm soát vòng lặp của chúng ta.

Sau đó, chúng tôi sẽ thêm một TapGesture để tăng số lượng.

Hãy cập nhật bản xem trước của chúng tôi.

Và bây giờ chúng ta có thể nhấn để thêm lấp lánh.

Một khía cạnh quan trọng khác của việc sử dụng canvas là, vì nó là một đồ họa duy nhất, không có bất kỳ thông tin nào về nội dung của nó có sẵn cho Accessibility.

Để làm cho điều này có thể truy cập được, chúng tôi sẽ sử dụng các công cụ sửa đổi khả năng truy cập tiêu chuẩn để thêm thông tin về chế độ xem của chúng tôi.

Và đối với các trường hợp nâng cao hơn, có một công cụ sửa đổi .accessibilityChildren mới mạnh mẽ cho phép bạn chỉ định một hệ thống phân cấp chế độ xem SwiftUI tùy ý để sử dụng để tạo thông tin khả năng truy cập về chế độ xem.

Xem "SwiftUI Accessibility: Beyond the Basics" để biết thêm thông tin về cách sử dụng nó.

Chúng tôi đã xây dựng một cách sử dụng Canvas tương đối đơn giản, nhưng nó được thiết kế để hỗ trợ các mục đích sử dụng phức tạp hơn nhiều, vì vậy hãy thêm gia vị cho mọi thứ một chút.

Một trong những đồng nghiệp của tôi đã viết một số mã mô phỏng cho tôi hoạt động giống như những gì chúng ta có ở đây, nhưng với nhiều yếu tố hơn làm những điều thú vị hơn.

Tôi có tệp mà anh ấy đã gửi cho tôi ở đây mà tôi sẽ dán vào chế độ xem của chúng tôi.

Mã này có cấu trúc giống như những gì chúng tôi vừa làm.

Bây giờ chúng tôi có một đối tượng mô hình tồn tại lâu dài mà chúng tôi đang cập nhật theo thời gian để theo dõi tất cả các hạt của chúng tôi.

Chúng tôi có cùng một TimelineView và Canvas để tạo hiệu ứng động và vẽ nội dung của chúng tôi.

Chúng tôi đang cập nhật mô hình của mình với ngày mới, đặt chế độ hòa trộn màn hình đó và yêu cầu mỗi hạt đang hoạt động tự vẽ giống như hình elip mà chúng tôi vừa có.

Và cuối cùng, chúng tôi có các công cụ sửa đổi tương tự được áp dụng, chỉ với một cử chỉ phức tạp hơn một chút.

Vậy hãy xem nó trông như thế nào.

Nó tạo ra một vụ nổ pháo hoa mới theo định kỳ, và chúng ta cũng có thể chạm để thêm nhiều vụ nổ hơn.

Và chúng được tạo ra bằng cách sử dụng hình elip với màu sắc từ độ dốc của ứng dụng.

Một điều tuyệt vời khác về vẽ trong Canvas là nó cũng hoạt động trên watchOS, tvOS và macOS.

Nó có sẵn trên tất cả các nền tảng SwiftUI.

Được rồi. Chúng tôi đã hoàn thành ứng dụng của mình.

Và trên đường đi, chúng tôi đã xem xét làm việc và sửa đổi các khu vực an toàn, cách sử dụng các kiểu tiền cảnh để kiểm soát cách vẽ nội dung, cách sử dụng vật liệu để làm mờ và sống động, và chúng tôi đã sử dụng Canvas và TimelineView để xây dựng đồ họa hoạt hình phức tạp.

Tôi nóng lòng muốn xem bạn xây dựng đồ họa tuyệt vời nào trong ứng dụng của mình.

[Âm nhạc].