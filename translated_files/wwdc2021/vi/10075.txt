10075

♪ Nhạc bass đang phát ♪

♪

Courtland Idstrom: Xin chào, tên tôi là Courtland Idstrom, và tôi là một kỹ sư trong nhóm RealityKit.

Trong video này, tôi sẽ chỉ cho bạn cách sử dụng các tính năng kết xuất mới trong RealityKit 2.

RealityKit là một khuôn khổ được thiết kế để giúp việc xây dựng các ứng dụng AR trở nên đơn giản và trực quan.

Kết xuất là một phần quan trọng của RealityKit, tập trung vào kết xuất dựa trên vật lý, chân thực cao.

Kể từ lần phát hành đầu tiên vào năm 2019, chúng tôi đã làm việc với phản hồi của bạn và chúng tôi đang gửi một bản cập nhật lớn cho RealityKit.

Trong phiên "Dive into Reality Kit 2", chúng tôi đã đề cập đến sự phát triển của RealityKit, cung cấp nhiều cải tiến - từ các bản cập nhật cho hệ thống ECS, khả năng vật liệu và hoạt hình phát triển hơn, đồng thời tạo ra các tài nguyên âm thanh và kết cấu trong thời gian chạy.

Để giới thiệu những cải tiến này, chúng tôi đã xây dựng một ứng dụng biến phòng khách của bạn thành một bể cá dưới nước.

Trong buổi nói chuyện này, chúng tôi sẽ hiển thị một số tính năng kết xuất mới đã đi vào ứng dụng.

RealityKit 2 cung cấp khả năng kiểm soát và linh hoạt với cách các đối tượng được kết xuất, cho phép bạn tạo ra trải nghiệm AR tốt hơn nữa.

Năm nay chúng tôi mang lại những tiến bộ cho hệ thống vật liệu của mình, cho phép bạn thêm tài liệu của riêng mình bằng cách tạo ra các bộ đổ bóng kim loại tùy chỉnh.

Hiệu ứng bài đăng tùy chỉnh cho phép bạn tăng cường hiệu ứng bài đăng của RealityKit bằng hiệu ứng bài đăng của riêng bạn.

Các API lưới mới cho phép tạo, kiểm tra và sửa đổi lưới trong thời gian chạy.

Hãy bắt đầu với tính năng được yêu cầu nhiều nhất trong RealityKit 2, hỗ trợ cho các bộ đổ bóng tùy chỉnh.

Kết xuất của RealityKit xoay quanh một mô hình kết xuất dựa trên vật lý.

Bộ đổ bóng tích hợp của nó giúp dễ dàng tạo ra các mô hình trông tự nhiên bên cạnh các vật thể thực trong nhiều điều kiện ánh sáng.

Năm nay, chúng tôi đang xây dựng trên những bộ đổ bóng dựa trên vật lý này và phơi bày khả năng bạn tùy chỉnh hình học và bề mặt của các mô hình bằng cách sử dụng bộ đổ bóng.

API đổ bóng đầu tiên của chúng tôi là công cụ sửa đổi hình học.

Công cụ sửa đổi hình học là một chương trình, được viết bằng Ngôn ngữ tạo bóng kim loại, mang đến cho bạn cơ hội thay đổi các đỉnh của một đối tượng mỗi khung hình khi nó được hiển thị trên GPU.

Điều này bao gồm di chuyển chúng và tùy chỉnh các thuộc tính của chúng, chẳng hạn như màu sắc, bình thường hoặc tia cực tím.

Nó được chạy bên trong bộ đổ bóng đỉnh của RealityKit và hoàn hảo cho hoạt hình xung quanh, biến dạng, hệ thống hạt và biển quảng cáo.

Rong biển của chúng tôi là một ví dụ tuyệt vời về hoạt hình xung quanh.

Rong biển đang di chuyển chậm do sự chuyển động của nước xung quanh nó.

Chúng ta hãy xem xét kỹ hơn.

Ở đây bạn có thể thấy khung dây của rong biển do nghệ sĩ của chúng tôi tạo ra; điều này cho thấy các đỉnh và hình tam giác bao gồm lưới.

Chúng ta sẽ viết một chương trình đổ bóng thực thi trên mỗi đỉnh để tạo chuyển động của chúng ta.

Chúng ta sẽ sử dụng sóng sin, một hàm tuần hoàn đơn giản, để tạo ra chuyển động.

Chúng tôi đang mô phỏng các dòng nước nên chúng tôi muốn các đỉnh gần đó hoạt động tương tự, bất kể quy mô hay hướng của mô hình của chúng.

Vì lý do này, chúng tôi sử dụng vị trí thế giới của đỉnh làm đầu vào cho hàm sin.

Chúng tôi cũng bao gồm một giá trị thời gian, để nó di chuyển theo thời gian.

Sóng sin đầu tiên của chúng tôi nằm ở chiều Y để tạo ra chuyển động lên xuống.

Để kiểm soát chu kỳ chuyển động, chúng ta sẽ thêm một thang đo không gian.

Và chúng ta có thể kiểm soát lượng chuyển động của nó với biên độ.

Chúng tôi sẽ áp dụng cùng một chức năng cho các kích thước X và Z để nó di chuyển theo cả ba trục.

Bây giờ, hãy nhìn vào mô hình nói chung.

Một điều chúng tôi chưa tính đến: các đỉnh gần gốc thân cây có rất ít chỗ để di chuyển, trong khi các đỉnh có quyền tự do di chuyển cao nhất.

Để mô phỏng điều này, chúng ta có thể sử dụng tọa độ y của đỉnh liên quan đến nguồn gốc của đối tượng làm hệ số chia tỷ lệ cho cả ba trục, điều này cho chúng ta công thức cuối cùng.

Bây giờ chúng ta đã có kế hoạch cho bộ đổ bóng của mình, chúng ta hãy xem nơi để tìm các thông số này.

Các thông số hình học được tổ chức thành một vài loại.

Đầu tiên là đồng nhất, các giá trị giống nhau cho mọi đỉnh của đối tượng trong một khung.

Chúng ta cần thời gian cho rong biển của chúng ta.

Kết cấu chứa tất cả các kết cấu được tạo ra như một phần của mô hình, cộng với một khe tùy chỉnh bổ sung, mà bạn có thể sử dụng khi bạn thấy phù hợp.

Các hằng số vật liệu có bất kỳ tham số nào, chẳng hạn như tỷ lệ sắc thái hoặc độ mờ, được tạo ra với đối tượng hoặc được đặt thông qua mã.

Hình học chứa một số giá trị chỉ đọc, chẳng hạn như vị trí mô hình của đỉnh hiện tại hoặc ID đỉnh.

Chúng ta cần cả vị trí mô hình và thế giới cho phong trào rong biển của chúng ta.

Hình học cũng có các giá trị đọc-ghi, bao gồm bình thường, tia cực tím và độ lệch vị trí mô hình.

Khi chúng tôi đã tính toán độ lệch của mình, chúng tôi sẽ lưu trữ nó ở đây để di chuyển các đỉnh của chúng tôi.

Hãy đi sâu vào Metal shader.

Chúng tôi bắt đầu bằng cách bao gồm RealityKit.h.

Bây giờ chúng tôi khai báo một hàm với thuộc tính hàm hiển thị.

Điều này hướng dẫn trình biên dịch làm cho nó có sẵn riêng biệt với các chức năng khác.

Hàm nhận một tham số duy nhất, đó là geometry_parameters của RealityKit.

Chúng tôi sẽ truy xuất tất cả các giá trị thông qua đối tượng này.

Sử dụng thành viên hình học của các tham số, chúng tôi sẽ yêu cầu cả vị trí thế giới và vị trí mô hình.

Tiếp theo chúng tôi tính toán độ lệch pha, dựa trên vị trí thế giới ở đỉnh và thời gian.

Sau đó, chúng tôi áp dụng công thức của mình để tính toán độ lệch của đỉnh này.

Chúng tôi lưu trữ độ lệch trên hình học, sẽ được thêm vào vị trí mô hình của đỉnh.

Chúng tôi có công cụ sửa đổi hình học của mình, nhưng nó vẫn chưa được kết nối với rong biển của chúng tôi.

Hãy chuyển sang lớp con ARView của chúng ta, được viết bằng Swift.

Chúng tôi bắt đầu bằng cách tải thư viện Metal mặc định của ứng dụng, có chứa bộ đổ bóng của chúng tôi.

Tiếp theo, chúng tôi xây dựng một geometryModifier bằng cách sử dụng tên và thư viện đổ bóng của chúng tôi.

Đối với mỗi vật liệu trên rong biển, chúng tôi tạo ra một vật liệu tùy chỉnh mới.

Chúng tôi chuyển vật liệu hiện có làm tham số đầu tiên cho CustomMaterial, để nó kế thừa các kết cấu và thuộc tính vật liệu từ vật liệu cơ bản trong khi thêm công cụ sửa đổi hình học của chúng tôi.

Nó trông khá đẹp! Kể từ khi chúng tôi ở dưới nước, chúng tôi đã giữ hoạt hình khá chậm.

Bằng cách điều chỉnh biên độ và pha, hiệu ứng tương tự có thể được mở rộng sang cỏ, cây cối hoặc các tán lá khác.

Bây giờ chúng ta đã chỉ ra cách sửa đổi hình học, hãy nói về bóng râm.

Đây là con bạch tuộc của chúng tôi từ cảnh dưới nước, trông tuyệt vời với bộ đổ bóng tích hợp của chúng tôi.

Khi họ làm vậy, bạch tuộc của chúng ta chuyển đổi giữa nhiều ngoại hình.

Cái nhìn thứ hai có màu đỏ.

Nghệ sĩ của chúng tôi đã tạo ra hai kết cấu màu cơ bản, một cho mỗi diện mạo.

Ngoài sự thay đổi màu sắc, bạch tuộc đỏ có giá trị nhám cao hơn, làm cho nó ít phản chiếu hơn.

Và, để làm cho bạch tuộc của chúng tôi trở nên đặc biệt hơn, chúng tôi muốn tạo ra một sự chuyển đổi tốt đẹp giữa các ngoại hình.

Ở đây bạn có thể thấy quá trình chuyển đổi đang hoạt động.

Mê hoặc.

Mặc dù mỗi cái nhìn có thể được mô tả như một vật liệu dựa trên vật lý, nhưng đối với chính quá trình chuyển đổi, chúng ta cần viết một bộ đổ bóng bề mặt.

Vậy bộ đổ bóng bề mặt là gì?

Bộ đổ bóng bề mặt cho phép bạn xác định diện mạo của một vật thể.

Nó chạy bên trong bộ đổ bóng đoạn cho mọi điểm ảnh có thể nhìn thấy của một đối tượng.

Ngoài màu sắc, điều này bao gồm các đặc tính bề mặt như bình thường, gương và nhám.

Bạn có thể viết đổ bóng giúp tăng cường diện mạo của đối tượng hoặc thay thế hoàn toàn, tạo ra các hiệu ứng mới.

Chúng tôi đã thấy hai kết cấu màu cơ bản cho bạch tuộc của chúng tôi.

Đối với hiệu ứng chuyển tiếp, nghệ sĩ của chúng tôi đã mã hóa một kết cấu đặc biệt cho chúng tôi.

Kết cấu này thực sự là sự kết hợp của ba lớp khác nhau.

Có một lớp nhiễu ở trên cùng tạo ra các mẫu chuyển tiếp cục bộ.

Chúng ta có một lớp chuyển tiếp, quyết định chuyển động tổng thể, bắt đầu từ đầu và di chuyển về phía các xúc tu.

Và có một lớp mặt nạ cho các khu vực mà chúng ta không muốn thay đổi màu sắc, chẳng hạn như mắt và mặt dưới của xúc tu.

Ba lớp này được kết hợp thành các kênh màu đỏ, xanh lá cây và xanh dương của kết cấu của chúng tôi, mà chúng tôi gán cho khe kết cấu tùy chỉnh.

Với kết cấu của chúng tôi được thiết lập, hãy xem cách truy cập chúng từ bộ đổ bóng bề mặt.

Tương tự như công cụ sửa đổi hình học, bộ đổ bóng bề mặt có quyền truy cập vào đồng phục, kết cấu và hằng số vật liệu.

Thời gian là đầu vào cho quá trình chuyển đổi bạch tuộc của chúng ta.

Chúng tôi sẽ lấy mẫu kết cấu được tạo bằng mô hình của chúng tôi và đọc các hằng số vật liệu, cho phép nghệ sĩ của chúng tôi thực hiện các điều chỉnh trên toàn mô hình.

Hình học - chẳng hạn như vị trí, bình thường hoặc tia cực tím - xuất hiện trong cấu trúc hình học.

Đây là những đầu ra nội suy từ bộ đổ bóng đỉnh.

Chúng tôi sẽ sử dụng UV0 làm tọa độ kết cấu của chúng tôi.

Một bộ đổ bóng bề mặt viết một cấu trúc bề mặt.

Các thuộc tính bắt đầu với các giá trị mặc định và chúng tôi có thể tự do tính toán các giá trị này theo bất kỳ cách nào chúng tôi thấy phù hợp.

Chúng tôi sẽ tính toán màu cơ bản và màu bình thường.

Sau đó, bốn thông số bề mặt: độ nhám, kim loại, tắc môi trường xung quanh và gương.

Bây giờ chúng ta đã biết giá trị của mình tồn tại ở đâu, hãy bắt đầu viết đổ bóng của chúng ta.

Chúng tôi sẽ làm điều này trong ba bước.

Đầu tiên hãy tính giá trị chuyển tiếp, trong đó 0 là một con bạch tuộc màu tím hoàn toàn và 1 là màu đỏ hoàn toàn.

Sử dụng giá trị chuyển tiếp, chúng tôi sẽ tính toán màu sắc và chuẩn mực và sau đó tinh chỉnh bằng cách gán các thuộc tính vật liệu.

Hãy bắt đầu nào.

Bước đầu tiên: chuyển đổi.

Chúng tôi đang xây dựng hàm bề mặt bạch tuộc, lấy đối số surface_parameters.

Vì chúng tôi đang sử dụng kết cấu, chúng tôi khai báo một bộ lấy mẫu.

Ở bên phải, bạn có thể thấy bạch tuộc của chúng ta trông như thế nào với một bóng đổ bóng bề mặt trống rỗng - nó có màu xám và hơi sáng bóng.

RealityKit giúp bạn kiểm soát hoàn toàn những gì đóng góp hoặc không đóng góp vào sự xuất hiện của người mẫu của bạn.

Để tính toán màu sắc, có một vài điều chúng ta cần làm trước.

Chúng tôi sẽ lưu trữ một số biến số tiện lợi.

Chúng tôi truy cập UV0 của mình, chúng tôi sẽ sử dụng làm tọa độ kết cấu.

Metal và USD có các hệ tọa độ kết cấu khác nhau, vì vậy chúng tôi sẽ đảo ngược tọa độ y để khớp với các kết cấu được tải từ USD.

Bây giờ chúng tôi sẽ lấy mẫu kết cấu chuyển tiếp của mình - kết cấu ba lớp mà nghệ sĩ của chúng tôi đã tạo ra.

Nghệ sĩ của chúng tôi đã thiết lập một hàm nhỏ lấy giá trị mặt nạ cộng với thời gian và trả về 0 đến 1 giá trị cho pha trộn và pha trộn màu.

Bước thứ hai: màu sắc và bình thường.

Với biến pha trộn được tính toán trước đây của chúng tôi, bây giờ chúng tôi có thể tính toán màu của bạch tuộc và xem quá trình chuyển đổi.

Để làm điều này, chúng tôi lấy mẫu hai kết cấu: màu cơ bản và màu cơ bản phụ, mà chúng tôi đã lưu trữ trong emissive_color.

Sau đó, chúng tôi pha trộn giữa hai màu bằng cách sử dụng colorBlend được tính toán trước đó.

Chúng ta sẽ nhân với base_color_tint - một giá trị từ vật liệu - và đặt màu cơ bản của chúng ta trên bề mặt.

Tiếp theo chúng ta sẽ áp dụng bản đồ bình thường, thêm độ lệch bề mặt, đáng chú ý nhất trên đầu và xúc tu.

Chúng tôi lấy mẫu kết cấu bản đồ bình thường, giải nén giá trị của nó và sau đó đặt trên đối tượng bề mặt.

Về các thuộc tính vật liệu.

Đây là bạch tuộc của chúng tôi cho đến nay, với màu sắc và bình thường.

Hãy xem các đặc tính bề mặt ảnh hưởng đến vẻ ngoài của nó như thế nào.

Độ nhám, mà bạn sẽ thấy ở phần dưới cơ thể; tắc nghẽn xung quanh, sẽ làm tối phần dưới; và gương, cho chúng ta một sự phản chiếu tốt đẹp trên mắt và một số định nghĩa bổ sung trên cơ thể.

Hãy thêm những thứ này vào đổ bóng của chúng ta.

Chúng tôi lấy mẫu bốn kết cấu trên mô hình, một cho mỗi thuộc tính.

Tiếp theo chúng tôi chia tỷ lệ các giá trị này với các cài đặt vật liệu.

Ngoài ra, chúng tôi cũng đang tăng độ nhám khi chúng tôi chuyển từ màu tím sang màu đỏ.

Sau đó, chúng tôi đặt bốn giá trị của mình trên bề mặt.

Tương tự như trước đây, chúng ta cần áp dụng bộ đổ bóng cho mô hình của mình.

Chúng tôi gán tài liệu này cho mô hình của chúng tôi trong lớp con ARView của chúng tôi.

Đầu tiên chúng tôi tải hai kết cấu bổ sung của mình, sau đó tải bộ đổ bóng bề mặt của chúng tôi.

Giống như trước đây, chúng tôi đang xây dựng các vật liệu mới từ vật liệu cơ bản của vật thể, lần này với một bộ đổ bóng bề mặt và hai kết cấu bổ sung của chúng tôi.

Và chúng ta đã hoàn thành.

Vì vậy, tóm lại, chúng tôi đã hiển thị hoạt ảnh rong biển bằng cách sử dụng các công cụ sửa đổi hình học và cách xây dựng quá trình chuyển đổi bạch tuộc với các bộ đổ bóng bề mặt.

Mặc dù chúng tôi đã trình diễn chúng một cách riêng biệt, bạn có thể kết hợp cả hai để có hiệu ứng thú vị hơn nữa.

Chuyển sang một tính năng được yêu cầu cao khác, hỗ trợ thêm hiệu ứng xử lý bài đăng tùy chỉnh.

RealityKit đi kèm với một bộ phong phú các hiệu ứng bài đăng phù hợp với máy ảnh như làm mờ chuyển động, nhiễu máy ảnh và độ sâu trường ảnh.

Tất cả các hiệu ứng này đều được thiết kế để làm cho các đối tượng ảo và thực có cảm giác như chúng là một phần của cùng một môi trường.

Những thứ này có sẵn để bạn tùy chỉnh trên ARView.

Năm nay, chúng tôi cũng đang phơi bày khả năng để bạn tạo ra các hiệu ứng toàn màn hình của riêng mình.

Điều này cho phép bạn tận dụng RealityKit cho chủ nghĩa hiện thực của ảnh và thêm các hiệu ứng mới để điều chỉnh kết quả cho ứng dụng của bạn.

Vậy quy trình đăng bài là gì?

Quá trình đăng bài là một trình đổ bóng hoặc một loạt các trình đổ bóng thực thi sau khi các đối tượng đã được hiển thị và sáng.

Nó cũng xảy ra sau bất kỳ hiệu ứng bài đăng RealityKit nào.

Đầu vào của nó là hai kết cấu: màu sắc và bộ đệm độ sâu.

Bộ đệm độ sâu được hiển thị dưới dạng thang độ xám ở đây; nó chứa giá trị khoảng cách cho mỗi điểm ảnh so với máy ảnh.

Một quá trình đăng bài ghi kết quả của nó vào một kết cấu màu đích.

Hiệu ứng bài viết đơn giản nhất sẽ sao chép màu nguồn thành màu đích.

Chúng ta có thể xây dựng những thứ này theo một vài cách.

Các nền tảng của Apple đi kèm với một số công nghệ tích hợp tốt với các hiệu ứng bài đăng, chẳng hạn như Core Image, Metal Performance Shaders và SpriteKit.

Bạn cũng có thể tự viết bằng Ngôn ngữ tô bóng kim loại.

Hãy bắt đầu với một số hiệu ứng Core Image.

Core Image là một khuôn khổ của Apple để xử lý hình ảnh.

Nó có hàng trăm hiệu ứng xử lý màu sắc, cách điệu và biến dạng mà bạn có thể áp dụng cho hình ảnh và video.

Nhiệt là một hiệu ứng gọn gàng - thứ mà bạn có thể bật cho một công cụ tìm cá dưới nước.

Hãy xem việc tích hợp với RealityKit dễ dàng như thế nào.

Tất cả các hiệu ứng bài đăng của chúng tôi sẽ theo cùng một mô hình.

Bạn đặt lệnh gọi lại kết xuất, phản hồi để chuẩn bị với thiết bị và sau đó quá trình đăng bài sẽ được gọi mọi khung hình.

Kết xuất các cuộc gọi lại tồn tại trên ARView của RealityKit.

Chúng tôi muốn cả cuộc gọi lại prepareWithDevice và postProcess.

Chuẩn bị với thiết bị sẽ được gọi một lần với MTLDevice.

Đây là một cơ hội tốt để tạo kết cấu, tải tính toán hoặc kết xuất đường ống và kiểm tra khả năng của thiết bị.

Đây là nơi chúng tôi tạo ra bối cảnh Core Image của mình.

Cuộc gọi lại postProcess được gọi mỗi khung.

Chúng tôi sẽ tạo một CIImage, tham khảo kết cấu màu nguồn của chúng tôi.

Tiếp theo chúng tôi tạo ra bộ lọc nhiệt của chúng tôi.

Nếu bạn đang sử dụng một bộ lọc Core Image khác, đây là nơi bạn sẽ định cấu hình các thông số khác của nó.

Sau đó, chúng tôi tạo một điểm đến kết xuất, nhắm vào kết cấu màu đầu ra của chúng tôi và sử dụng bộ đệm lệnh của ngữ cảnh.

Chúng tôi yêu cầu Core Image giữ nguyên hướng của hình ảnh và bắt đầu nhiệm vụ.

Thế là xong!

Với Core Image, chúng tôi đã mở khóa hàng trăm hiệu ứng dựng sẵn mà chúng tôi có thể sử dụng.

Bây giờ hãy xem cách chúng ta có thể sử dụng Metal Performance Shaders để xây dựng các hiệu ứng mới.

Hãy nói về sự nở hoa.

Bloom là một kỹ thuật không gian màn hình tạo ra ánh sáng xung quanh các vật thể được chiếu sáng rực rỡ, mô phỏng hiệu ứng thấu kính trong thế giới thực.

Core Image chứa hiệu ứng nở hoa, nhưng chúng tôi sẽ tự xây dựng để có thể kiểm soát từng bước của quy trình.

Chúng tôi sẽ xây dựng hiệu ứng với Metal Performance Shaders, một bộ sưu tập các bộ đổ bóng đồ họa và tính toán được tối ưu hóa cao.

Để xây dựng bộ đổ bóng này, chúng ta sẽ xây dựng một biểu đồ các bộ lọc sử dụng màu sắc làm nguồn.

Đầu tiên chúng tôi muốn cách ly những khu vực sáng sủa.

Để làm điều này, chúng tôi sử dụng một thao tác gọi là "ngưỡng về 0".

Nó chuyển đổi màu sắc thành độ sáng và đặt mọi điểm ảnh dưới một mức độ sáng nhất định thành 0.

Sau đó, chúng tôi làm mờ kết quả bằng cách sử dụng làm mờ Gaussian, truyền ánh sáng lên các khu vực lân cận.

Việc làm mờ hiệu quả có thể là một thách thức để thực hiện và thường yêu cầu nhiều giai đoạn.

Metal Performance Shaders xử lý việc này cho chúng tôi.

Sau đó, chúng tôi thêm kết cấu mờ này vào màu gốc, thêm ánh sáng xung quanh các vùng sáng.

Hãy thực hiện biểu đồ này như một hiệu ứng bài đăng.

Chúng tôi bắt đầu bằng cách tạo ra một bloomTexture trung gian.

Sau đó thực hiện thao tác ThresholdToZero của chúng tôi, đọc từ sourceColor và viết để bloomTexture.

Sau đó, chúng tôi thực hiện một gaussianBlur tại chỗ.

Cuối cùng, chúng tôi thêm màu gốc của chúng tôi và màu nở này lại với nhau.

Thế là xong!

Bây giờ chúng ta đã thấy một vài cách để tạo hiệu ứng bài đăng, hãy nói về cách đặt hiệu ứng lên trên đầu ra của chúng ta bằng SpriteKit.

SpriteKit là khuôn khổ của Apple cho các trò chơi 2D hiệu suất cao, tiết kiệm pin.

Nó hoàn hảo để thêm một số hiệu ứng lên trên chế độ xem 3D của chúng tôi.

Chúng tôi sẽ sử dụng nó để thêm một số bong bóng trên màn hình như một hiệu ứng bài đăng, sử dụng cùng một cuộc gọi lại prepareWithDevice và postProcess.

Chúng tôi có hai bước giống như trước đây.

Trong prepareWithDevice, chúng tôi sẽ tạo trình kết xuất SpriteKit của mình và tải cảnh chứa bong bóng của chúng tôi.

Sau đó, trong cuộc gọi lại postProcess của chúng tôi, chúng tôi sẽ sao chép màu nguồn của mình sang màu đích, cập nhật cảnh SpriteKit của chúng tôi và hiển thị trên nội dung 3D.

prepareWithDevice khá đơn giản - chúng tôi tạo trình kết xuất và tải cảnh của chúng tôi từ một tệp.

Chúng tôi sẽ vẽ cái này trên cảnh AR của chúng tôi, vì vậy chúng tôi cần nền SpriteKit của chúng tôi trong suốt.

Trong postProcess, trước tiên chúng tôi bật màu nguồn thành targetColorTexture; đây sẽ là nền mà SpriteKit hiển thị ở phía trước.

Sau đó chuyển cảnh SpriteKit của chúng tôi sang thời điểm mới để bong bóng của chúng tôi di chuyển lên trên.

Thiết lập một RenderPassDescriptor và kết xuất trên đó.

Và thế là xong!

Chúng tôi đã chỉ ra cách sử dụng các khuôn khổ hiện có để tạo hiệu ứng bài đăng, nhưng đôi khi bạn thực sự cần tạo một khuôn khổ từ đầu.

Bạn cũng có thể tạo hiệu ứng toàn màn hình bằng cách viết trình đổ bóng tính toán.

Đối với bản demo dưới nước của chúng tôi, chúng tôi cần một hiệu ứng sương mù áp dụng cho các vật thể ảo và máy ảnh truyền qua.

Sương mù mô phỏng sự tán xạ ánh sáng qua môi trường; cường độ của nó tỷ lệ thuận với khoảng cách.

Để tạo hiệu ứng này, chúng ta cần biết mỗi điểm ảnh cách thiết bị bao xa.

May mắn thay, ARKit và RealityKit đều cung cấp quyền truy cập vào thông tin chuyên sâu.

Đối với các thiết bị hỗ trợ LiDAR, ARKit cung cấp quyền truy cập vào sceneDepth, chứa khoảng cách tính bằng mét từ máy ảnh.

Những giá trị này cực kỳ chính xác ở độ phân giải thấp hơn toàn màn hình.

Chúng tôi có thể sử dụng trực tiếp độ sâu này nhưng nó không bao gồm các vật thể ảo, vì vậy chúng sẽ không sương mù chính xác.

Trong postProcess của chúng tôi, RealityKit cung cấp quyền truy cập vào chiều sâu cho nội dung ảo và - khi tính năng hiểu cảnh được bật - các mắt lưới gần đúng cho các đối tượng trong thế giới thực.

Lưới được xây dựng dần dần khi bạn di chuyển, vì vậy nó chứa một số lỗ mà chúng tôi hiện chưa quét.

Những lỗ hổng này sẽ cho thấy sương mù như thể chúng ở rất xa.

Chúng tôi sẽ kết hợp dữ liệu từ hai kết cấu chiều sâu này để giải quyết sự khác biệt này.

ARKit cung cấp các giá trị chiều sâu như một kết cấu.

Mỗi điểm ảnh là khoảng cách, tính bằng mét, của điểm được lấy mẫu.

Vì cảm biến ở hướng cố định trên iPhone hoặc iPad của bạn, chúng tôi sẽ yêu cầu ARKit xây dựng chuyển đổi từ hướng của cảm biến sang hướng màn hình hiện tại và sau đó đảo ngược kết quả.

Để đọc chiều sâu nội dung ảo, chúng ta cần một chút thông tin về cách RealityKit đóng gói chiều sâu.

Bạn sẽ nhận thấy rằng, không giống như sceneDepth của ARKit, các giá trị sáng hơn gần với máy ảnh hơn.

Các giá trị được lưu trữ trong phạm vi từ 0 đến 1, sử dụng Phép chiếu Reverse-Z Vô hạn.

Điều này chỉ có nghĩa là 0 có nghĩa là vô cùng xa, và 1 nằm ở mặt phẳng gần của máy ảnh.

Chúng ta có thể dễ dàng đảo ngược sự biến đổi này bằng cách chia độ sâu mặt phẳng gần cho độ sâu được lấy mẫu.

Hãy viết một hàm trợ giúp để làm điều này.

Chúng tôi có một hàm Kim loại lấy độ sâu và ma trận chiếu của mẫu.

Các điểm ảnh không có nội dung ảo chính xác là 0.

Chúng ta sẽ kẹp vào một epsilon nhỏ để tránh chia cho 0.

Để hoàn tác phép chia phối cảnh, chúng tôi lấy giá trị z của cột cuối cùng và chia cho độ sâu được lấy mẫu của chúng tôi.

Tuyệt vời!

Bây giờ chúng ta đã có hai giá trị độ sâu của mình, chúng ta có thể sử dụng giá trị tối thiểu của cả hai làm đầu vào cho chức năng sương mù của mình.

Sương mù của chúng ta có một vài thông số: khoảng cách tối đa, cường độ tối đa ở khoảng cách đó và số mũ đường cong lũy thừa.

Các giá trị chính xác đã được chọn bằng thực nghiệm.

Chúng định hình giá trị độ sâu của chúng tôi để đạt được mật độ sương mù mong muốn của chúng tôi.

Bây giờ chúng ta đã sẵn sàng để ghép các mảnh lại với nhau.

Chúng tôi có giá trị độ sâu từ ARKit, giá trị độ sâu tuyến tính hóa từ RealityKit và một chức năng cho sương mù của chúng tôi.

Hãy viết trình đổ bóng tính toán của chúng tôi.

Đối với mỗi điểm ảnh, chúng tôi bắt đầu bằng cách lấy mẫu cả hai giá trị độ sâu tuyến tính.

Sau đó, chúng tôi áp dụng chức năng sương mù của mình bằng cách sử dụng các tham số điều chỉnh, biến độ sâu tuyến tính thành giá trị 0 đến 1.

Sau đó, chúng tôi pha trộn giữa màu nguồn và màu sương mù, tùy thuộc vào giá trị của fogBlend, lưu trữ kết quả trong outColor.

Tóm lại, API quy trình đăng bài mới của RealityKit cho phép một loạt các hiệu ứng bài đăng.

Với Core Image, chúng tôi đã mở khóa hàng trăm hiệu ứng được xây dựng sẵn.

Bạn có thể dễ dàng xây dựng những cái mới với Metal Performance Shaders, thêm lớp phủ màn hình với SpriteKit và viết của riêng bạn từ đầu với Metal.

Để biết thêm thông tin về Core Image hoặc Metal Performance Shaders, hãy xem các phiên được liệt kê.

Bây giờ chúng ta đã đề cập đến các hiệu ứng kết xuất, hãy chuyển sang chủ đề tiếp theo của chúng ta, các mắt lưới động.

Trong RealityKit, tài nguyên lưới lưu trữ dữ liệu lưới.

Trước đây, loại mờ đục này cho phép bạn gán mắt lưới cho các thực thể.

Năm nay, chúng tôi đang cung cấp khả năng kiểm tra lưới, tạo và cập nhật lưới trong thời gian chạy.

Hãy xem cách chúng ta có thể thêm các hiệu ứng đặc biệt vào thợ lặn.

Trong bản demo này, chúng tôi muốn hiển thị một hiệu ứng xoắn ốc nơi các đường viền xoắn ốc xung quanh thợ lặn.

Bạn cũng có thể thấy hình xoắn ốc đang thay đổi lưới của nó theo thời gian như thế nào để tạo hiệu ứng chuyển động của nó.

Hãy cùng xem cách tạo cái này bằng cách sử dụng API lưới mới của chúng tôi.

Hiệu ứng tập trung thành ba bước.

Chúng tôi sử dụng kiểm tra lưới để đo mô hình bằng cách kiểm tra các đỉnh của nó.

Sau đó chúng tôi xây dựng một hình xoắn ốc, sử dụng các phép đo làm hướng dẫn.

Và cuối cùng, chúng ta có thể cập nhật vòng xoắn ốc theo thời gian.

Bắt đầu với việc kiểm tra lưới.

Để giải thích cách các mắt lưới được lưu trữ, hãy xem mô hình thợ lặn của chúng tôi.

Trong RealityKit, lưới của Thợ lặn được thể hiện dưới dạng tài nguyên lưới.

Với bản phát hành năm nay, MeshResource hiện có một thành viên có tên là Contents.

Đó là nơi mà tất cả các hình học lưới được xử lý tồn tại.

Nội dung chứa một danh sách các trường hợp và mô hình.

Các mô hình chứa dữ liệu đỉnh thô, trong khi các trường hợp tham chiếu chúng và thêm một phép biến đổi.

Các trường hợp cho phép hiển thị cùng một hình học nhiều lần mà không cần sao chép dữ liệu.

Một mô hình có thể có nhiều phần.

Một phần là một nhóm hình học với một vật liệu.

Cuối cùng, mỗi phần chứa dữ liệu đỉnh mà chúng tôi quan tâm, chẳng hạn như vị trí, chuẩn, tọa độ kết cấu và chỉ số.

Trước tiên chúng ta hãy xem cách chúng ta sẽ truy cập dữ liệu này trong mã.

Chúng tôi sẽ tạo một phần mở rộng trên MeshResource.Contents, gọi đóng với vị trí của mỗi đỉnh.

Chúng tôi bắt đầu bằng cách xem qua tất cả các trường hợp.

Mỗi trường hợp này ánh xạ đến một mô hình.

Đối với mỗi trường hợp, chúng tôi tìm thấy sự biến đổi của nó liên quan đến thực thể.

Sau đó, chúng ta có thể đi sâu vào từng bộ phận của mô hình và truy cập các thuộc tính của bộ phận.

Đối với chức năng này, chúng tôi chỉ quan tâm đến vị trí.

Sau đó, chúng ta có thể chuyển đổi đỉnh thành vị trí không gian thực thể và gọi lại cuộc gọi lại của chúng ta.

Bây giờ chúng ta có thể truy cập các đỉnh, hãy xem cách chúng ta muốn sử dụng dữ liệu này.

Chúng tôi sẽ chia thợ lặn của chúng tôi thành các lát cắt ngang.

Đối với mỗi lát cắt, chúng ta sẽ tìm bán kính giới hạn của mô hình của mình và làm điều này cho mỗi lát cắt.

Để thực hiện điều này, chúng ta sẽ bắt đầu bằng cách tạo ra một mảng không chứa đầy với các phần tử numSlices.

Sau đó, chúng tôi tìm ra các giới hạn của lưới dọc theo trục y để tạo ra các lát cắt của chúng tôi.

Sử dụng hàm chúng tôi vừa tạo, cho mỗi đỉnh trong mô hình, chúng tôi tìm ra lát cắt nào đi vào và chúng tôi cập nhật bán kính với bán kính lớn nhất cho lát cắt đó.

Cuối cùng, chúng tôi trả về một đối tượng Slices chứa bán kính và giới hạn.

Bây giờ chúng tôi đã phân tích lưới của mình để biết nó lớn như thế nào, hãy xem cách tạo lưới xoắn ốc.

Hình xoắn ốc là một lưới được tạo ra động.

Để tạo lưới này, chúng ta cần mô tả dữ liệu của mình cho RealityKit.

Chúng tôi làm điều này với một mô tả lưới.

Mô tả lưới chứa các vị trí, chuẩn mực, tọa độ kết cấu, nguyên thủy và chỉ số vật liệu.

Khi bạn có một bộ mô tả lưới, bạn có thể tạo một tài nguyên lưới.

Điều này gọi bộ xử lý lưới của RealityKit, giúp tối ưu hóa lưới của bạn.

Nó sẽ hợp nhất các đỉnh trùng lặp, tam giác các tứ giác và đa giác của bạn, và đại diện cho lưới ở định dạng hiệu quả nhất để kết xuất.

Kết quả của quá trình xử lý này cung cấp cho chúng tôi một tài nguyên lưới mà chúng tôi có thể gán cho một thực thể.

Lưu ý rằng các chuẩn mực, tọa độ kết cấu và vật liệu là tùy chọn.

Bộ xử lý lưới của chúng tôi sẽ tự động tạo ra các chuẩn mực chính xác và điền chúng vào.

Là một phần của quá trình tối ưu hóa, RealityKit sẽ tái tạo cấu trúc liên kết của lưới.

Nếu bạn cần một cấu trúc liên kết cụ thể, bạn có thể sử dụng MeshResource.Contents trực tiếp.

Bây giờ chúng ta đã biết cách tạo lưới hoạt động, hãy xem cách tạo vòng xoắn ốc.

Để mô hình hóa hình xoắn ốc, chúng ta hãy xem xét kỹ hơn một phần.

Xoắn ốc còn được gọi là xoắn ốc.

Chúng tôi sẽ xây dựng cái này trong các phân đoạn cách đều nhau.

Chúng ta có thể tính toán từng điểm bằng cách sử dụng định nghĩa toán học của một vòng xoắn và bán kính từ lưới được phân tích của chúng ta.

Sử dụng hàm này cho mỗi phân đoạn trên vòng xoắn, chúng ta có thể xác định bốn đỉnh.

P0 và P1 chính xác là các giá trị mà p() trả về.

Để tính P2 và P3, chúng ta có thể bù P0 và P1 theo chiều dọc với độ dày đã cho của chúng ta.

Chúng tôi đang tạo ra các hình tam giác, vì vậy chúng tôi cần một đường chéo.

Chúng ta sẽ tạo ra hai hình tam giác bằng cách sử dụng những điểm này.

Đã đến lúc kết hợp tất cả lại với nhau.

Chức năng generateSpiral của chúng tôi cần lưu trữ các vị trí và chỉ số.

Các chỉ số tham chiếu các giá trị ở các vị trí.

Đối với mỗi phân đoạn, chúng tôi sẽ tính toán bốn vị trí và lưu trữ các chỉ số của chúng - i0 là chỉ số của p0 khi nó được thêm vào mảng.

Sau đó, chúng tôi thêm bốn vị trí và sáu chỉ số - cho hai tam giác - vào mảng của chúng.

Một khi bạn đã có hình học của mình, việc tạo lưới rất đơn giản.

Đầu tiên, tạo một MeshDescriptor mới.

Sau đó chỉ định các vị trí và nguyên thủy.

Chúng tôi đang sử dụng nguyên thủy tam giác, nhưng chúng tôi cũng có thể chọn tứ giác hoặc đa giác.

Khi hai trường đó được điền vào, chúng tôi có đủ để tạo một MeshResource.

Bạn cũng có thể cung cấp các thuộc tính đỉnh khác như chuẩn, tọa độ kết cấu hoặc gán vật liệu.

Chúng tôi đã đề cập đến cách tạo lưới.

Điều cuối cùng trong ví dụ xoắn ốc của chúng tôi là cập nhật lưới.

Chúng tôi sử dụng các bản cập nhật lưới để làm cho vòng xoắn ốc di chuyển xung quanh thợ lặn.

Để cập nhật lưới, có hai cách.

Chúng tôi có thể tạo một MeshResource mới cho mỗi khung bằng cách sử dụng MeshDescriptors API.

Nhưng đây không phải là một con đường hiệu quả, vì nó sẽ chạy qua trình tối ưu hóa lưới mỗi khung hình.

Một lộ trình hiệu quả hơn là cập nhật nội dung trong MeshResource.

Bạn có thể tạo một MeshContents mới và sử dụng nó để thay thế lưới.

Tuy nhiên, có một cảnh báo.

Nếu chúng tôi tạo lưới ban đầu của mình bằng MeshDescriptor, bộ xử lý lưới của RealityKit sẽ tối ưu hóa dữ liệu.

Cấu trúc liên kết cũng được giảm xuống thành hình tam giác.

Do đó, hãy đảm bảo rằng bạn biết lưới của mình bị ảnh hưởng như thế nào trước khi áp dụng bất kỳ bản cập nhật nào.

Hãy xem mã để biết cách bạn có thể cập nhật vòng xoắn ốc.

Chúng tôi bắt đầu bằng cách lưu trữ nội dung của vòng xoắn ốc hiện có.

Tạo một mô hình mới từ mô hình hiện có.

Sau đó, đối với mỗi phần, chúng tôi thay thế triangleIndices bằng một tập hợp con các chỉ số.

Cuối cùng, với nội dung mới, chúng ta có thể gọi thay thế trên MeshResource hiện có.

Và đó là nó cho các mắt lưới động.

Để tóm tắt những điều quan trọng về lưới động, chúng tôi đã giới thiệu một trường Nội dung mới trong MeshResource.

Vùng chứa này cho phép bạn kiểm tra và sửa đổi dữ liệu thô của lưới.

Bạn có thể tạo các mắt lưới mới bằng cách sử dụng MeshDescriptor.

Lộ trình linh hoạt này cho phép bạn sử dụng hình tam giác, tứ giác hoặc thậm chí đa giác và RealityKit sẽ tạo ra một lưới được tối ưu hóa để kết xuất.

Cuối cùng, để cập nhật lưới, chúng tôi đã cung cấp khả năng cập nhật nội dung của MeshResource, lý tưởng cho việc cập nhật thường xuyên.

Để kết thúc, hôm nay chúng tôi đã giới thiệu một số tính năng kết xuất mới trong RealityKit 2.

Công cụ sửa đổi hình học cho phép bạn di chuyển và sửa đổi các đỉnh.

Bộ đổ bóng bề mặt cho phép bạn xác định diện mạo bề mặt của mô hình.

Bạn có thể sử dụng hiệu ứng bài đăng để áp dụng hiệu ứng cho khung cuối cùng và các mắt lưới động giúp dễ dàng tạo và sửa đổi các mắt lưới trong thời gian chạy.

Để xem thêm các tính năng của năm nay, đừng bỏ lỡ "Dive into RealityKit 2."

Và để biết thêm thông tin về RealityKit, hãy xem "Xây dựng ứng dụng với RealityKit."

Chúng tôi rất vui mừng về bản phát hành năm nay và nóng lòng muốn xem những trải nghiệm bạn xây dựng với nó.

Cảm ơn bạn.

♪