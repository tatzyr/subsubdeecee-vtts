10094

♪ Nhạc bass đang phát ♪

♪

Rui Paulo: Xin chào mọi người, tôi là Rui.

Hôm nay, đồng nghiệp Eric của tôi và tôi sẽ nói về cách bạn có thể tăng tốc độ kết nối mạng ứng dụng của mình với HTTP/3 và QUIC - hai giao thức mới có sẵn trong iOS 15 và macOS Monterey.

Chúng ta sẽ bắt đầu bằng cách khám phá sự phát triển của HTTP và cách HTTP/3 cải thiện hiệu suất.

Chúng ta cũng sẽ nói về QUIC, giao thức vận chuyển mới đằng sau HTTP/3.

Sau đó, chúng tôi sẽ giải thích cách bạn có thể sử dụng HTTP/3 trong URLSession và cách bạn nên định cấu hình máy chủ HTTP của mình để hỗ trợ HTTP/3.

Cuối cùng, chúng ta sẽ đi sâu vào API để sử dụng QUIC và cách bạn có thể triển khai các giao thức mạng tùy chỉnh của mình trên QUIC.

Sau đó hãy bắt đầu với sự phát triển của HTTP.

Giả sử chúng ta cần tìm nạp một tài nguyên.

Chúng tôi thiết lập kết nối, gửi yêu cầu, đợi máy chủ xử lý và nhận phản hồi.

Bây giờ, nếu chúng tôi muốn tìm nạp một tài nguyên khác trước khi tài nguyên đầu tiên kết thúc, chúng tôi đã trải qua quy trình tương tự một lần nữa: thiết lập kết nối, gửi yêu cầu, chờ xử lý và nhận phản hồi, lần này được biểu thị bằng màu xanh đậm.

Đây là một ví dụ khác cho tài nguyên thứ ba, màu cam.

Như được phác thảo trong sơ đồ, rất nhiều thời gian được dành cho việc thiết lập kết nối.

Điều gì sẽ xảy ra nếu chúng ta sử dụng lại một kết nối HTTP/1 duy nhất?

Chúng tôi đã lưu thời gian thiết lập kết nối, nhưng yêu cầu chỉ có thể được gửi sau khi phản hồi trước đó kết thúc.

Điều này được gọi là chặn đầu dòng.

Trong quá khứ, việc triển khai HTTP đã sử dụng nhiều kết nối song song để khắc phục vấn đề này.

Số lượng kết nối HTTP song song thậm chí còn có thể được cấu hình bởi ứng dụng.

Tuy nhiên, điều này dẫn đến các hành vi kết nối mạng không hiệu quả cho cả máy khách và máy chủ.

HTTP/2 giải quyết vấn đề chặn đầu dòng bằng cách ghép kênh nhiều luồng trên một kết nối duy nhất.

Các yêu cầu được gửi sớm hơn và dữ liệu từ các luồng khác nhau có thể được xen kẽ.

Điều này cho phép sử dụng hiệu quả hơn một kết nối TCP duy nhất, vì thời gian chờ đợi nhàn rỗi giảm đáng kể.

Với HTTP/3, thiết lập kết nối nhanh hơn nhiều, vì vậy các yêu cầu có thể được gửi đi sớm hơn.

Tuy nhiên, đó không phải là lợi ích duy nhất của HTTP/3.

Các luồng HTTP/3 độc lập, khác với HTTP/2, trong đó tất cả các luồng chia sẻ một kết nối TCP duy nhất.

Trên hầu hết các mạng, các gói tin bị mất.

Đây là một sự kiện bình thường trên mạng không dây và là một phần tự nhiên của việc phát hiện dung lượng của mạng.

Trong HTTP/2, mất gói có thể ảnh hưởng đến nhiều luồng vì tất cả các luồng HTTP/2 đều chia sẻ một kết nối TCP duy nhất.

Trong HTTP/3, chỉ có luồng HTTP tương ứng bị ảnh hưởng.

Dữ liệu thuộc về các luồng khác có thể được phân phối sớm hơn.

Chúng tôi vừa chỉ ra cách HTTP/3 có thể thiết lập kết nối sớm hơn và cách nó có thể đối phó tốt hơn với việc mất gói.

Những cải tiến này được kích hoạt bởi giao thức vận chuyển cơ bản: QUIC.

QUIC là một giao thức vận chuyển đáng tin cậy mới đã được tiêu chuẩn hóa bởi Lực lượng Đặc nhiệm Kỹ thuật Internet.

Nó dựa trên các khái niệm tương tự của TCP nhưng cung cấp mã hóa đầu cuối, các luồng ghép kênh và xác thực.

Bảo mật của QUIC được xây dựng dựa trên giao thức TLS 1.3 nổi tiếng.

Lợi ích chính của QUIC là cải thiện hiệu suất.

Hãy cùng khám phá cách QUIC đạt được điều đó.

QUIC dựa vào TLS 1.3 để thực hiện bắt tay an toàn và không yêu cầu bắt tay ba chiều TCP quen thuộc, giảm thời gian bắt tay xuống còn một chuyến khứ hồi duy nhất.

Các luồng ghép kênh là một khái niệm chính của QUIC, vì vậy nó không bị chặn đầu dòng.

Điểm cuối QUIC có thể truyền đạt thông tin phức tạp hơn về các gói mà nó đã nhận được đến điểm cuối khác và không bị cản trở bởi giới hạn của TCP, vì vậy các kết nối QUIC được cải thiện khả năng phục hồi mất mát.

Giao thức cũng hỗ trợ di chuyển kết nối cho phép các kết nối di chuyển liền mạch qua các giao diện mạng khác nhau mà không cần thiết lập lại phiên, ví dụ, giữa mạng di động và Wi-Fi.

Nếu bạn muốn tìm hiểu thêm về sự chậm trễ của mạng, vui lòng xem phiên "Giảm sự chậm trễ mạng cho ứng dụng của bạn".

Hãy nói về cách bạn có thể sử dụng HTTP/3 trong ứng dụng của mình.

Nếu bạn đang sử dụng URLSession, bạn không cần phải thay đổi ứng dụng của mình vì iOS 15 và macOS Monterey xuất xưởng với HTTP/3 được bật theo mặc định.

Khi bạn bật HTTP/3 trên máy chủ của mình, bạn đã sẵn sàng.

Cả phiên bản HTTP/3 RFC sắp tới và phiên bản HTTP/3 Draft 29 trước đó đều được hỗ trợ.

Vậy làm thế nào bạn có thể chắc chắn rằng ứng dụng của bạn đang sử dụng HTTP/3?

Hãy sử dụng Dụng cụ để tìm hiểu!

Trong Xcode 13, chúng tôi đang giới thiệu một công cụ mới trong mẫu hồ sơ mạng để kiểm tra Lưu lượng HTTP.

Nó khai thác trực tiếp vào URLSession, vì vậy không cần thiết lập.

Chúng tôi có thể sử dụng Công cụ để tìm hiểu xem ứng dụng của chúng tôi đang sử dụng HTTP/3 hay phiên bản HTTP cũ hơn.

Chúng tôi sẽ khởi chạy một ứng dụng iOS, khi bắt đầu, sẽ tìm nạp một bộ ảnh chó.

Sau đó chúng tôi sẽ kiểm tra các tiêu đề HTTP để tìm hiểu cách máy chủ quảng cáo HTTP/3.

Hãy tiếp tục và chọn mẫu hồ sơ mạng.

Hãy nhấp vào Ghi lại ở trên cùng bên trái.

Một lời nhắc sẽ được hiển thị cho thấy ý nghĩa riêng tư của việc ghi lại Lưu lượng HTTP.

Sau khi chúng tôi đồng ý, Instruments sẽ bắt đầu ghi lại các giao dịch HTTP.

Tiếp theo, Instruments sẽ hiển thị một biểu đồ với tất cả các giao dịch HTTP trên mỗi ứng dụng và trên mỗi miền.

Bây giờ chúng tôi đã thu thập tất cả dữ liệu mà chúng tôi cần.

Chúng ta có thể nhấp vào nút Tạm dừng nằm ở trên cùng bên trái.

Hãy chọn miền mà chúng tôi đang sử dụng.

Chúng ta có thể làm điều đó bằng cách nhấp vào Tùy chọn vào các giao dịch HTTP và sau đó chọn miền.

Chúng ta cần cấu hình Công cụ để hiển thị chi tiết của Giao dịch HTTP.

Để thực hiện điều đó, hãy đảm bảo menu ở phía bên trái hiển thị Giao dịch HTTP.

Hãy chọn yêu cầu đầu tiên.

Bằng cách cuộn sang phải, chúng ta có thể tìm thấy cột Phiên bản HTTP xác định phiên bản HTTP mà giao dịch này đã sử dụng.

Hừm, chúng tôi vẫn đang sử dụng HTTP/2, nhưng tại sao vậy?

Ở phía bên tay phải, chúng ta có thể tìm thấy chế độ xem chi tiết mở rộng có chứa các tiêu đề phản hồi.

Điều này cho chúng ta câu trả lời: máy chủ đã sử dụng Dịch vụ Thay thế HTTP để quảng cáo hỗ trợ cho HTTP/3.

URLSession sẽ không sử dụng HTTP/3 trừ khi nó được quảng cáo.

Trong ví dụ này, HTTP/3 đã được quảng cáo thông qua tiêu đề HTTP Alt-Svc.

Các máy chủ HTTP thường quảng cáo hỗ trợ cho HTTP/3, sử dụng tiêu đề này.

Thông tin này được ghi nhớ cho các kết nối trong tương lai và chúng tôi gọi đây là "khám phá dịch vụ".

Bây giờ hãy ghi lại ứng dụng một lần nữa.

Khi Instruments khởi chạy lại ứng dụng, cùng một bộ giao dịch HTTP sẽ diễn ra.

Một lần nữa, bây giờ chúng ta có thể tạm dừng Dụng cụ.

Hãy phóng to lại và kiểm tra giao dịch đầu tiên.

Vì chúng tôi đã nhớ rằng máy chủ hỗ trợ HTTP/3, chúng tôi hiện đang sử dụng HTTP/3.

Khám phá dịch vụ HTTP/3 minh bạch cho ứng dụng của bạn.

Việc phát hiện hỗ trợ máy chủ HTTP/3 diễn ra theo hai cách.

Cách tiếp cận được đề xuất là định cấu hình máy chủ DNS của bạn để quảng cáo hỗ trợ cho HTTP/3 thông qua bản ghi tài nguyên HTTPS.

Đơn giản chỉ cần cấu hình giao thức lớp ứng dụng để quảng cáo HTTP/3 bằng cách sử dụng chuỗi h3.

Bạn cũng nên định cấu hình máy chủ của mình để thêm tiêu đề mới quảng cáo HTTP/3 bằng các Dịch vụ Thay thế.

Máy chủ của bạn nên gửi tiêu đề Alt-Svc quảng cáo HTTP/3.

Điều này bao gồm số cổng và độ tuổi tối đa của dịch vụ, tính bằng giây.

Ưu điểm của bản ghi DNS là vì thông tin nằm trong DNS, kết nối HTTP/3 có thể được thiết lập ngay lần đầu tiên ứng dụng của bạn cố gắng liên hệ với máy chủ của bạn.

Khi bạn biết rằng máy chủ của bạn hỗ trợ HTTP/3 và bạn muốn tăng tốc quá trình khám phá, bạn có thể sử dụng thuộc tính giả định HTTP3Capable.

Điều này cho phép ngăn xếp HTTP giả định rằng bạn có một máy chủ HTTP/3 nhưng không đảm bảo rằng HTTP/3 sẽ được sử dụng.

Các mạng vẫn có thể chặn HTTP/3 hoặc máy chủ của bạn có thể không thực sự hỗ trợ HTTP/3.

Trong trường hợp đó, chúng ta sẽ quay trở lại HTTP/2.

HTTP cho phép khách hàng chỉ định các ưu tiên cho từng tài nguyên.

Vì các tài nguyên thường có liên quan, các ưu tiên cho phép máy chủ gửi một số tài nguyên sớm hơn các tài nguyên khác, dựa trên nhu cầu của khách hàng.

Ví dụ, trải nghiệm người dùng để duyệt web có thể được cải thiện bằng cách ưu tiên các tài nguyên ảnh hưởng đến kết xuất trang web nhiều nhất.

Một sơ đồ ưu tiên đã được giới thiệu trong HTTP/2 nhưng nó thường không được tôn trọng do sự phức tạp của nó.

Vì lý do đó, mô hình ưu tiên cũ đã bị xóa khỏi HTTP/3.

Một mô hình mới, đơn giản hơn, dựa trên các tiêu đề HTTP, được sử dụng bởi ngăn xếp HTTP/3.

Trong mô hình này, mức độ ưu tiên được chỉ định với một tham số khẩn cấp - từ 0 đến bảy - và một tham số phân phối gia tăng tùy chọn.

Khi sử dụng URLSession, API để hỗ trợ các ưu tiên vẫn giữ nguyên.

Bạn vẫn chỉ định mức độ ưu tiên HTTP, sử dụng thuộc tính ưu tiên, được truyền đến máy chủ bằng cách sử dụng mức độ khẩn cấp.

Bạn có thể kích hoạt giao hàng gia tăng với thuộc tính prefersIncrementalDelivery.

Mức độ ưu tiên mặc định là 3.

URLSession suy ra việc phân phối gia tăng tùy thuộc vào việc API tiện lợi - như phương thức dữ liệu không đồng bộ - có được sử dụng hay không.

Khi ứng dụng của bạn đang tải xuống nội dung không thể xử lý cho đến khi toàn bộ tài nguyên được tải xuống, bạn nên đặt thuộc tính này thành sai.

Tự động thay đổi mức độ ưu tiên của tài nguyên sau khi yêu cầu được gửi cũng được hỗ trợ.

Ví dụ: bạn có thể tìm nạp trước ảnh ở mức độ ưu tiên thấp hơn và sau đó tăng mức độ ưu tiên đó khi người dùng điều hướng đến phần đó trong ứng dụng của bạn.

Tiếp theo, đồng nghiệp Eric của tôi sẽ giải thích cách bạn có thể thay đổi các giao thức mạng tùy chỉnh của mình để áp dụng QUIC.

Cảm ơn bạn.

Eric Kinnear: Cảm ơn, Rui!

Như chúng ta đã thảo luận trước đó, HTTP/3 được xây dựng trên QUIC, cung cấp các luồng ghép kênh, tương tự như các luồng được tìm thấy trong HTTP/2, nhưng không có vấn đề gì được đưa ra bằng cách chia sẻ một kết nối TCP duy nhất làm phương tiện vận chuyển cơ bản.

Kết nối vận chuyển QUIC - hoặc đường hầm QUIC - ghép kênh dữ liệu cho nhiều luồng QUIC một chiều hoặc hai chiều.

Các luồng có thể được tạo bởi một trong hai điểm cuối, có thể gửi đồng thời dữ liệu xen kẽ với các luồng khác và có trạng thái tương tự như các luồng truyền thống do TCP cung cấp.

Trên hết, QUIC có bảo mật TLS 1.3 được tích hợp sẵn và có thể đáp ứng tốt hơn với các điều kiện mạng thay đổi.

Những khả năng này không chỉ hữu ích cho HTTP.

Nếu ứng dụng của bạn đang trao đổi dữ liệu không dựa trên yêu cầu/phản hồi, có thể được hưởng lợi từ việc có các luồng ghép kênh chia sẻ ngữ cảnh vận chuyển cơ bản hoặc đang triển khai bất kỳ giao thức tùy chỉnh nào khác - chẳng hạn như giao tiếp ngang hàng hoặc cuộc gọi RPC - hãy cân nhắc sử dụng vận chuyển QUIC cho ứng dụng của bạn.

Trong iOS 15 và macOS Monterey, NWProtocolQUIC tham gia các giao thức tích hợp khác do Network.framework cung cấp.

Tạo một kết nối sử dụng QUIC rất quen thuộc.

Chỉ cần cung cấp điểm cuối của bạn và các tham số QUIC mới có sẵn.

Các tham số này chỉ định chuỗi ALPN, giao thức lớp ứng dụng để thương lượng với máy chủ.

Đặt trình xử lý cập nhật trạng thái - giống như bình thường - để có thể phản hồi khi kết nối tiến triển và sẵn sàng.

Và, cuối cùng, bắt đầu kết nối của bạn trên hàng đợi điều phối mà bạn muốn sử dụng cho các bản cập nhật trạng thái và các cuộc gọi lại khác.

Bây giờ bạn đã thiết lập luồng QUIC, bạn có thể gửi và nhận dữ liệu giống như bất kỳ NWConnection nào khác.

Sử dụng chức năng gửi để cung cấp dữ liệu bạn muốn gửi đến điểm cuối từ xa và lên lịch gửi tiếp theo khi hoàn tất.

Sử dụng nhận để xử lý dữ liệu đến và lên lịch nhận tiếp theo khi hoàn thành.

Năm ngoái, chúng tôi đã giới thiệu đối tượng Nhóm Kết nối trong Network.framework để giúp xử lý các tình huống có liên quan hoặc nhóm nhiều kết nối dễ dàng hơn.

Các luồng QUIC được ghép kênh trên bối cảnh vận chuyển cơ bản - hoặc đường hầm - được nhóm lại một cách hợp lý dựa trên mối quan hệ đó và có thể được sử dụng với một loại nhóm mới: NWMultiplexGroup.

Nhóm kết nối tuân theo vòng đời tương tự như vòng đời của các đối tượng Network.framework khác và cho phép bạn suy luận về trạng thái của đường hầm QUIC cơ bản được chia sẻ bởi các luồng QUIC của bạn.

Nó cũng cho phép bạn tạo các luồng đi mới từ một đường hầm QUIC cụ thể cũng như nhận các luồng đến mới được khởi tạo bởi điểm cuối từ xa.

Để tạo một nhóm kết nối cho một giao thức ghép kênh, hãy sử dụng bộ mô tả nhóm ghép kênh.

Trong trường hợp này, chúng tôi sẽ tạo một bộ mô tả nhóm cho example.com trên cổng 443.

Tiếp theo, chúng tôi tạo một NWConnectionGroup với bộ mô tả đó và các tham số QUIC, cung cấp chuỗi ALPN của chúng tôi khi chúng tôi tạo chúng.

Cũng giống như với NWConnection, chúng tôi đặt trình xử lý cập nhật trạng thái, nhưng lần này, nó đang theo dõi trạng thái của đường hầm QUIC bên dưới, thay vì trạng thái của một luồng riêng lẻ.

Cuối cùng, chúng tôi bắt đầu nhóm kết nối, cung cấp hàng đợi gọi lại của chúng tôi.

Các luồng đi mới có thể được tạo bằng cách khởi tạo NWConnection từ nhóm hoặc bằng cách gọi hàm trích xuất trên nhóm.

Các luồng đến được khởi tạo bởi điểm cuối từ xa có thể được xử lý bằng cách đặt trình xử lý kết nối mới trên nhóm.

Các kết nối này có thể được thiết lập như bình thường với trình xử lý trạng thái - lần này theo dõi trạng thái luồng - và bắt đầu với hàng đợi để sử dụng cho các cuộc gọi lại.

Cũng giống như các giao thức khác, bạn có thể sử dụng QUIC.Options để cấu hình khi tạo đối tượng tham số của mình.

Đối với QUIC, bạn có thể định cấu hình các tham số vận chuyển được liệt kê trong đặc tả QUIC và bạn cũng có thể tùy chỉnh các thuộc tính của các luồng riêng lẻ khi tạo chúng từ một nhóm kết nối; ví dụ: nếu bạn muốn tạo một luồng một chiều mới.

Nếu bạn đang sử dụng NWListener để chạy một máy chủ trong ứng dụng của mình, nó cũng đã được cải tiến để cho phép bạn nhận các đường hầm QUIC mới đến thông qua NewConnectionGroupHandler.

Trình xử lý nhóm kết nối mới của bạn sẽ được gọi mỗi khi ai đó thiết lập đường hầm QUIC mới cho máy chủ của bạn.

Bên trong trình xử lý đó, bạn có thể thiết lập nhóm như bình thường để nhận các cập nhật trạng thái.

Đây cũng là một nơi tốt để thiết lập trình xử lý kết nối mới mà chúng ta vừa thảo luận.

Nếu bạn muốn nhận các luồng tiếp theo được mở trên đường hầm này, hãy bắt đầu nhóm với hàng đợi để sử dụng cho các cuộc gọi lại và bạn đã sẵn sàng!

Cuối cùng, bạn có thể sử dụng NWProtocolMetadata để truy cập thông tin về các luồng.

Ví dụ, bạn có thể muốn kiểm tra ID luồng của luồng mới được tạo.

Và khi bạn hoàn thành một luồng, nếu giao thức tùy chỉnh của bạn đã xác định mã applicationError, bạn có thể sử dụng siêu dữ liệu để thông báo bất kỳ lỗi nào đến điểm cuối từ xa trước khi hủy luồng.

Vì vậy, chúng tôi vừa khám phá cách chúng tôi có thể sử dụng loại NWMultiplexGroup mới để tạo và quản lý các đường hầm QUIC và từ nhóm đó, tạo các Kết nối NW riêng lẻ cho mỗi luồng QUIC.

Chúng ta có thể sử dụng NWListener để lắng nghe các đường hầm đến và sử dụng các nhóm kết nối kết quả để nhận các luồng đến mới.

Trên các luồng đó, chúng tôi có thể gửi và nhận dữ liệu giống như trên bất kỳ kết nối nào khác và chúng tôi có thể sử dụng các tùy chọn giao thức QUIC để chỉ định các tham số vận chuyển và định cấu hình luồng, đồng thời sử dụng siêu dữ liệu giao thức QUIC để kiểm tra các luồng và truyền thông tin cụ thể của QUIC đến điểm cuối từ

Bây giờ chúng tôi đã cải thiện mạng trong ứng dụng của mình bằng cách áp dụng QUIC, làm cách nào để biết nó có hoạt động hay không?

Chúng tôi có thể khởi chạy ứng dụng của mình trong khi gỡ lỗi, với một biến môi trường mới xuất ra các tệp qlog.

Qlog là một định dạng ghi nhật ký tiêu chuẩn mới được đề xuất trong IETF, cho phép bạn xuất thông tin phong phú hơn về cách các kết nối QUIC của bạn hoạt động so với hiện diện trong chụp gói truyền thống.

Sau khi chạy thử, bạn có thể sử dụng cửa sổ Thiết bị trong Xcode để tải xuống vùng chứa ứng dụng của mình với các tệp qlog để phân tích.

Và có một số hình ảnh trực quan hóa nguồn mở khác nhau giúp việc xem xét hành vi của các kết nối QUIC của bạn dễ dàng hơn nhiều.

Hôm nay, chúng tôi đã kiểm tra những cải tiến mà HTTP/3 cung cấp cho lưu lượng HTTP của bạn.

Trên máy khách, nó đã được bật theo mặc định cho người dùng API mạng hiện đại, vì vậy hãy bật HTTP/3 trên máy chủ của bạn để tận dụng hiệu suất tăng lên và khả năng phục hồi của nó trước các điều kiện mạng thay đổi.

Nếu bạn đang sử dụng giao thức mạng tùy chỉnh, không phải HTTP, hãy sử dụng hỗ trợ giao thức ghép kênh mới được tích hợp trong Network.framework để tạo kết nối QUIC với NWConnectionGroup.

Và cho dù bạn đang sử dụng giao thức nào, bạn có thể sử dụng các công cụ gỡ lỗi mới để hình dung những lợi ích tuyệt vời của thế hệ giao thức mạng tiếp theo.

Cảm ơn vì đã xem.

♪