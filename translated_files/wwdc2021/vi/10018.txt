10018

♪ Nhạc bass đang phát ♪

♪

Matt Ricketson: Chào mừng đến với "Có gì mới trong SwiftUI." Tôi là Matt, và sau này, tôi sẽ được Taylor tham gia.

Phiên này là tất cả về SwiftUI, khung giao diện người dùng khai báo của Apple.

SwiftUI vẫn còn trẻ, nhưng chúng ta đã đi rất xa rồi.

SwiftUI được phát hành lần đầu tiên vào năm 2019, giới thiệu một cách mới mạnh mẽ để xây dựng giao diện người dùng theo phong cách khai báo, dựa trên trạng thái.

Chúng tôi đã thực hiện bước tiến lớn tiếp theo với bản phát hành thứ hai của SwiftUI, cho phép 100% ứng dụng SwiftUI với API Ứng dụng và Cảnh mới.

Năm nay chúng tôi tập trung vào việc hỗ trợ việc áp dụng SwiftUI sâu hơn nữa trong các ứng dụng của bạn với một bộ tính năng mới phong phú tuyệt vời.

Bây giờ nếu bạn chưa có cơ hội tự mình dùng thử SwiftUI, không sao cả!

Chỉ có bạn mới biết điều gì là tốt nhất cho ứng dụng của bạn.

Nhưng đây là một vài mẹo cần ghi nhớ khi bạn tìm hiểu về tất cả các tính năng mới có sẵn trong năm nay.

Một cách hay để nhúng ngón chân của bạn vào SwiftUI là sử dụng nó để tạo các tính năng hoàn toàn mới trong một ứng dụng hiện có, như cách nó cung cấp năng lượng cho luồng hoạt động mới trong Ghi chú cho iOS, iPadOS và macOS.

Hoặc bộ chọn hình đại diện mới trong macOS, cũng được xây dựng bằng SwiftUI.

Hãy nhớ rằng, bạn có thể kết hợp SwiftUI cùng với mã UIKit hoặc AppKit hiện có của mình.

SwiftUI cũng là một công cụ hữu ích để mở rộng ứng dụng của bạn sang các nền tảng mới, như cách SwiftUI được sử dụng để xây dựng ứng dụng Phím tắt mới trên macOS.

Với SwiftUI, bạn có thể dễ dàng chia sẻ mã chung giữa các nền tảng trong khi vẫn tạo ra trải nghiệm độc đáo cho từng thiết bị.

Và khi bạn đã sẵn sàng thiết kế lại ứng dụng của mình, đó là thời điểm hoàn hảo để SwiftUI trợ giúp.

Quy trình mua Apple Pay hoàn toàn mới được thiết kế lại bằng SwiftUI, cũng được sử dụng để mang lại một lớp sơn mới cho Trình xem trợ giúp mới trên macOS và ứng dụng Mẹo trên watchOS.

Và cuối cùng, chúng ta không thể quên ứng dụng Thời tiết mới tuyệt đẹp dành cho iOS, cũng được xây dựng lại từ đầu trong SwiftUI.

Đây chỉ là một vài ví dụ về cách SwiftUI đang giúp xây dựng thế hệ ứng dụng tiếp theo.

Đối với phiên này, chúng tôi muốn chia sẻ một số API mới tuyệt vời giúp tất cả trở nên khả thi.

Chúng tôi sẽ bắt đầu bằng cách xem xét các cải tiến về cách chúng tôi xây dựng các bộ sưu tập nội dung với danh sách và lưới.

Tiếp theo, chúng tôi sẽ vượt ra ngoài danh sách, giới thiệu các tính năng mới để đưa các ứng dụng dựa trên dữ liệu của bạn lên một tầm cao mới.

Thứ ba, chúng tôi sẽ giới thiệu một số công cụ mới tuyệt đẹp để điều khiển đồ họa và hiệu ứng hình ảnh.

Chúng ta sẽ nói về những cải tiến đối với văn bản, bàn phím và điều hướng dựa trên tiêu điểm.

Và cuối cùng, chúng tôi sẽ dành một số tình yêu cho các nút.

Vì vậy, hãy đi sâu vào, bắt đầu với danh sách và lưới, đây là những tính năng quan trọng để tổ chức và hiển thị dữ liệu trong các ứng dụng SwiftUI.

Năm nay, chúng tôi đang làm cho việc viết các danh sách và lưới phong phú, tương tác trở nên dễ dàng hơn.

Hãy bắt đầu với một cái vui vẻ.

SwiftUI hiện có hỗ trợ tích hợp để tải hình ảnh không đồng bộ.

SwiftUI giúp việc tải những hình ảnh này trở nên dễ dàng với chế độ xem AsyncImage mới.

Chỉ cần cung cấp cho nó một URL và SwiftUI sẽ tự động tìm nạp và hiển thị hình ảnh từ xa cho bạn, và thậm chí cung cấp một trình giữ chỗ mặc định.

AsyncImage cũng có thể được tùy chỉnh.

Ví dụ, chúng ta có thể thêm công cụ sửa đổi vào hình ảnh đã tải và cũng xác định trình giữ chỗ tùy chỉnh, giống như tôi đang làm ở đây để thêm một số màu sắc thú vị.

Chúng tôi thậm chí có thể thêm hoạt ảnh tùy chỉnh và xử lý lỗi!

Và AsyncImage có sẵn trên tất cả các nền tảng.

Chúng tôi hy vọng bạn kiểm tra nó.

AsyncImage tải nội dung của nó ngay lập tức, nhưng đôi khi ứng dụng của bạn cần tải nội dung theo yêu cầu, như khi hiển thị nguồn cấp dữ liệu.

Đây là một trường hợp sử dụng tuyệt vời để hỗ trợ kéo để làm mới trên iOS và iPadOS, sử dụng công cụ sửa đổi có thể làm mới mới.

Công cụ sửa đổi này định cấu hình một hành động làm mới và truyền xuống môi trường.

Danh sách trên iOS và iPadOS sử dụng hành động này để tự động thêm kéo để làm mới, nhưng bạn cũng có thể sử dụng nó để xây dựng các hành vi làm mới tùy chỉnh của riêng mình.

Bạn có thể nhận thấy từ khóa chờ đợi mới này, đây là một trong những tính năng ngôn ngữ đồng thời mới trong Swift 5.5.

Điều này chỉ ra rằng phương thức updateItems là một hành động không đồng bộ, cho phép chúng tôi làm mới danh sách của mình mà không chặn giao diện người dùng.

Một tính năng SwiftUI liên quan đến đồng thời mới khác là công cụ sửa đổi tác vụ.

API này cho phép bạn đính kèm một tác vụ không đồng bộ vào vòng đời của chế độ xem.

Điều đó có nghĩa là nhiệm vụ sẽ bắt đầu khi chế độ xem tải lần đầu tiên và tự động hủy khi chế độ xem bị xóa.

Đây là một cách tuyệt vời để chúng tôi tự động tải lô ảnh đầu tiên.

Những công cụ sửa đổi đồng thời mới này trông đơn giản trên bề mặt, nhưng có thể được sử dụng để xây dựng các hành vi không đồng bộ tinh vi vào ứng dụng của bạn.

Ví dụ, ở đây tôi đã thiết lập một nhiệm vụ để tải những bức ảnh mới nhất khi chúng có sẵn.

Tôi chỉ viết một vòng lặp thông thường, nhưng bạn cũng sẽ nhận thấy từ khóa await được sử dụng ở đây.

Đó là bởi vì các ứng cử viên mới nhất thực sự là một chuỗi không đồng bộ, đây là một tính năng đồng thời mới khác trong Swift 5.5.

Điều này có nghĩa là chúng tôi sẽ chờ ứng cử viên mới nhất không đồng bộ, chỉ lặp lại vòng lặp khi ứng cử viên tiếp theo có sẵn.

Điều đó có nghĩa là chúng tôi thực sự đang đóng gói rất nhiều chức năng chỉ trong công cụ sửa đổi duy nhất này.

Chế độ xem bắt đầu một tác vụ lắng nghe ứng viên không đồng bộ ngay khi nó xuất hiện, cập nhật danh sách mỗi khi một ứng cử viên mới có sẵn và sau đó tự động hủy tác vụ khi chế độ xem biến mất, tất cả mà không chặn giao diện người dùng của ứng dụng của chúng tôi.

Có rất nhiều điều để tìm hiểu về tính đồng thời của Swift và cách tận dụng nó trong SwiftUI, vì vậy chúng tôi đã chuẩn bị một vài cuộc nói chuyện khác để tìm hiểu chi tiết.

"Khám phá tính đồng thời trong SwiftUI" sẽ giải thích cách đồng thời liên quan đến mô hình cập nhật của SwiftUI và giới thiệu một số tính năng mới mà chúng tôi vừa thảo luận.

Và trong "Swift concurrency: Update a sample app", chúng tôi hướng dẫn bạn từng bước nâng cấp một dự án hiện có với mã mô hình không đồng bộ.

Tiếp theo, chúng tôi sẽ cung cấp cho bạn những cách mới và tốt hơn để xây dựng tính tương tác vào nội dung danh sách của bạn.

Trong ví dụ này, tôi đã viết một danh sách đơn giản để chia sẻ hướng dẫn đến nơi ẩn náu siêu bí mật của mình.

Cái này trông đẹp, nhưng văn bản không thể chỉnh sửa được.

Hãy sửa nó đi.

Thay vào đó, chúng ta có thể chỉnh sửa văn bản bằng cách hoán đổi nó cho một trường văn bản.

Tuy nhiên, một trường văn bản yêu cầu liên kết với văn bản.

Trong phần đóng nội dung danh sách của chúng tôi, chúng tôi chỉ được cung cấp một giá trị đơn giản cho mỗi phần tử trong bộ sưu tập của mình, không phải ràng buộc.

Trong những tình huống như thế này, có thể khó tìm ra cách liên kết với phần tử bộ sưu tập cho mỗi hàng.

Thay vào đó, một cách tiếp cận phổ biến là lặp lại các chỉ số của bộ sưu tập, sử dụng chỉ số con để có được liên kết với phần tử tại chỉ mục đó.

Tuy nhiên, kỹ thuật này không được khuyến khích, bởi vì SwiftUI sẽ buộc phải tải lại toàn bộ danh sách khi có bất kỳ thay đổi nào.

Trên thực tế, chúng tôi đã chuẩn bị toàn bộ buổi nói chuyện thảo luận về chủ đề này chi tiết hơn nhiều.

Để tìm hiểu thêm, tôi khuyên bạn nên xem "Demystify SwiftUI." Hiện tại, hãy hoàn tác những thay đổi này và xem xét một giải pháp tốt hơn.

Năm nay, SwiftUI đang cung cấp một cách dễ dàng hơn nhiều để có quyền truy cập vào các ràng buộc cho các yếu tố riêng lẻ trong một bộ sưu tập.

Chỉ cần chuyển một ràng buộc cho bộ sưu tập của bạn vào danh sách, sử dụng toán tử ký hiệu đô la thông thường và SwiftUI sẽ chuyển lại một ràng buộc cho từng phần tử riêng lẻ trong phần đóng.

Mã chỉ cần đọc giá trị có thể giữ nguyên chính xác như trước đây, giống như bạn đã quen.

Nhưng bây giờ chúng ta có thể dễ dàng thêm các điều khiển tương tác như trường văn bản bằng cách sử dụng cú pháp ràng buộc thông thường mà chúng ta đã quen, điều đó có nghĩa là cuối cùng tôi có thể điền vào mã cửa siêu bí mật mà tôi đã quên bao gồm trước đó.

Cú pháp mới này là một phần của ngôn ngữ Swift, vì vậy nó hoạt động ở mọi nơi bạn mong đợi, không chỉ là danh sách.

Ví dụ, thay vào đó, chúng ta có thể sử dụng cùng một kỹ thuật trong chế độ xem ForEach trong danh sách của mình.

Và tốt hơn nữa, bạn thậm chí có thể triển khai lại mã này cho bất kỳ bản phát hành nào trước đó được SwiftUI hỗ trợ.

Nhưng chúng tôi không chỉ làm cho mã hiện tại của bạn dễ viết hơn.

Danh sách cũng đang đạt được một số tính năng mới tuyệt vời!

Hãy bắt đầu với một số cách mới để tùy chỉnh trực quan danh sách của bạn.

Với công cụ sửa đổi listRowSeparatorTint mới, bạn có thể thay đổi màu sắc của các dấu phân cách hàng riêng lẻ, như tôi đã làm ở đây để căn chỉnh dấu phân cách và màu biểu tượng cho mỗi hàng.

SwiftUI cũng có một công cụ sửa đổi tương đương cho các dấu phân cách phần.

Tuy nhiên, đối với ứng dụng này, tất cả các dấu phân cách đó có vẻ hơi mất tập trung.

Tôi muốn hướng dẫn của mình cảm thấy như một dòng chảy thống nhất, duy nhất.

Có lẽ chúng ta nên thử xóa chúng, điều mà bây giờ chúng ta có thể làm với công cụ sửa đổi listRowSeparator mới, định cấu hình các dấu phân cách của chúng ta bị ẩn.

Bây giờ hướng dẫn của chúng tôi cảm thấy ít lộn xộn hơn nhiều.

Hãy xem một ứng dụng khác mà tôi đang tạo...

...Điều này giúp các tác giả truyện tranh theo dõi tất cả các siêu anh hùng và nhân vật phản diện của họ.

Ứng dụng này sử dụng các thao tác vuốt để ghim và xóa các ký tự một cách nhanh chóng và thuận tiện, nhưng không làm lộn xộn giao diện người dùng của chúng tôi với các điều khiển bổ sung.

Mới trong năm nay, SwiftUI cho phép bạn xác định các hành động vuốt hoàn toàn tùy chỉnh bằng cách sử dụng công cụ sửa đổi swipeActions mới.

Bạn định cấu hình các hành động vuốt giống như bất kỳ loại menu nào khác trong SwiftUI, xác định các hành động bằng cách sử dụng các nút.

Bạn cũng có thể tùy chỉnh màu sắc của chúng bằng cách thêm công cụ sửa đổi tông màu mới, mà tôi đang sử dụng để làm cho hành động ghim của mình có màu vàng.

Theo mặc định, SwiftUI hiển thị các hành động vuốt ở cạnh sau của hàng.

Nhưng bạn có thể chuyển chúng sang phía trước bằng cách sử dụng tham số cạnh của công cụ sửa đổi.

Bạn thậm chí có thể hỗ trợ cả hành động vuốt đầu và cuối bằng cách thêm nhiều công cụ sửa đổi với các cấu hình cạnh khác nhau.

Và cuối cùng, công cụ sửa đổi swipeActions có sẵn trên mọi nền tảng hỗ trợ chúng, giúp bạn dễ dàng chia sẻ mã trong ứng dụng đa nền tảng của mình.

Nói về các nền tảng khác, hãy kiểm tra phiên bản macOS của ứng dụng của tôi.

Nó hiển thị một giao diện nhiều cột, sử dụng thêm dung lượng có sẵn trên Mac.

Thay vì nhồi nhét tất cả dữ liệu của tôi vào thanh bên, tôi có một tab tổng quan liệt kê tất cả các ký tự của tôi.

Điều đó cho phép tôi chỉ cần giữ các ký tự được ghim của mình trong thanh bên.

Tuy nhiên, danh sách này có cảm giác hơi đơn giản.

Hãy thử làm mới nó một chút.

Đây là mã hiện có của tôi.

Tôi hiện đang sử dụng kiểu danh sách chèn để phù hợp với danh sách trong cửa sổ của mình một cách trơn tru.

Và chúng tôi có thể thể hiện phong cách này một cách đẹp mắt trong mã bằng cách sử dụng cú pháp giống như enum mới có sẵn trên tất cả các kiểu xem trong năm nay.

Cũng mới trong năm nay, phong cách danh sách bên trong đang đạt được một thủ thuật mới.

Bây giờ nó có thể thay thế nền của các hàng bằng cách chỉ cần sửa đổi kiểu với cờ alternatesRowBackgrounds.

Danh sách của chúng tôi hiện đang trông đẹp hơn rất nhiều, với mỗi hàng được phân biệt rõ ràng với hàng kia.

Nhưng đối với một ứng dụng macOS, vẫn có cảm giác như chúng tôi không tận dụng tối đa không gian đó trong cửa sổ của mình.

Vì vậy, đối với phần tiếp theo, hãy vượt ra ngoài danh sách để tận dụng tối đa ứng dụng của bạn.

Để giúp chúng tôi tận dụng tốt hơn tất cả không gian này, hãy nâng cấp danh sách của chúng tôi lên một bảng nhiều cột phong phú!

Với bốn cột, bây giờ tôi nhận được bốn danh sách với giá của một!

Nhưng phần tốt nhất là một bảng phức tạp vừa phải như thế này có thể được khai báo với rất ít mã, nó phù hợp với một trang chiếu duy nhất.

Đó là bởi vì các bảng sử dụng cùng một loại cấu trúc khai báo mà bạn đã quen trong SwiftUI.

Cũng giống như với danh sách, bạn có thể tạo một bảng từ một bộ sưu tập nội dung duy nhất.

Nhưng không giống như một danh sách, một bảng được tạo thành từ TableColumns xác định nội dung trong mỗi cột trực quan.

Mỗi cột này được gắn nhãn trực quan và sử dụng dữ liệu từ bộ sưu tập để xác định nội dung trực quan của chúng với một số tiện ích tốc ký cho các trường hợp phổ biến như chỉ hiển thị văn bản.

Nhưng các bảng cũng có tính tương tác, hỗ trợ lựa chọn hàng cho cả hàng đơn và nhiều hàng, giống như trong danh sách thông thường.

Các bảng cũng hỗ trợ sắp xếp với sự trợ giúp của các đường dẫn chính đến các giá trị có thể sắp xếp trên các cột.

Giờ đây, các bảng hỗ trợ một số tính năng khác, bao gồm nhiều phong cách hình ảnh khác nhau cũng như tinh chỉnh giao diện của mỗi cột.

Nhưng hãy nói nhiều hơn về dữ liệu bạn cung cấp cho một bảng hoặc danh sách.

Năm nay, chúng tôi có một số cải tiến mới đối với sự hỗ trợ của SwiftUI cho các yêu cầu tìm nạp CoreData.

FetchRequests hiện cung cấp một ràng buộc cho các bộ mô tả sắp xếp của chúng, mà chúng ta có thể chuyển đến Bảng, cho phép chúng ta viết một bảng hoàn toàn dựa trên Dữ liệu Cốt lõi, hoàn chỉnh với các cột lựa chọn và có thể sắp xếp, chỉ trong một vài dòng mã.

SwiftUI hiện cũng cung cấp một yêu cầu tìm nạp theo từng phần, cho phép các danh sách phức tạp, đa phần như danh sách bên phải được điều khiển từ một yêu cầu duy nhất.

Trong ví dụ này, chúng tôi phân chia dữ liệu của mình thành các phần dựa trên việc chúng có được ghim hay không.

Chúng tôi sử dụng nhiều SortDescriptors để sắp xếp dữ liệu, đầu tiên để chia nó thành các phần được ghim và không ghim, và thứ hai để sắp xếp các ký tự được sửa đổi gần đây cuối cùng.

Tiếp theo chúng tôi chỉ định rằng bất kỳ thay đổi nào cũng nên được hoạt hình.

Và cuối cùng chúng tôi xây dựng các phần và hàng trong danh sách của mình một cách linh hoạt, dựa trên kết quả của yêu cầu.

Tất cả cùng nhau, yêu cầu duy nhất này có thể điều khiển danh sách hoạt hình ở bên phải.

Để biết thêm thông tin về việc xây dựng ứng dụng cho macOS, làm việc với các bảng và tích hợp Dữ liệu cốt lõi với SwiftUI, hãy nhớ xem các cuộc nói chuyện khác này.

Loạt bài gồm hai phần "SwiftUI trên Mac" sẽ hướng dẫn bạn từng bước xây dựng một ứng dụng được tối ưu hóa cho Mac.

Và "Mang dữ liệu cốt lõi đồng thời đến Swift và SwiftUI" sẽ bao gồm các API yêu cầu tìm nạp Dữ liệu cốt lõi mới chi tiết hơn nhiều.

Bây giờ là lúc lùi lại và suy nghĩ về cách chúng tôi có thể giúp người dùng tìm thấy những gì họ cần giữa tất cả dữ liệu này.

Tất nhiên, tôi đang nói về tìm kiếm.

Tìm kiếm là một phần quan trọng trong tất cả các nền tảng của chúng tôi.

Nó giúp người dùng tìm thấy chính xác những gì họ cần khi họ cần.

Bạn sẽ tìm thấy nó trên các thiết bị lớn như Apple TV, thậm chí cho đến các thiết bị nhỏ nhất, như Apple Watch.

Vì vậy, vì tìm kiếm là một vấn đề đa nền tảng, nó cần một giải pháp đa nền tảng có thể mở rộng trên tất cả các thiết bị này.

May mắn thay, việc thêm tìm kiếm vào ứng dụng của bạn không thể dễ dàng hơn; chỉ cần thêm công cụ sửa đổi có thể tìm kiếm, như chúng tôi đã làm ở đây trên NavigationView của mình.

Với một công cụ sửa đổi này, SwiftUI sẽ tự động thêm trường tìm kiếm vào vị trí thích hợp trong ứng dụng của bạn và tùy chọn hiển thị các đề xuất theo cách phù hợp với nền tảng và ngữ cảnh.

Công cụ sửa đổi có liên kết với văn bản tìm kiếm, cho phép bạn lọc dữ liệu của mình dựa trên giá trị hiện tại.

Bây giờ, có rất nhiều điều để nói về tìm kiếm trong SwiftUI, nhưng may mắn thay, chúng tôi có cả một phiên để hướng dẫn bạn cách suy nghĩ về khả năng tìm kiếm trên nhiều nền tảng.

Kiểm tra "Trải nghiệm tìm kiếm thủ công trong SwiftUI" để tìm hiểu thêm.

Cho đến nay, chúng tôi đã khám phá cách tải, hiển thị, sắp xếp và tìm kiếm thông qua dữ liệu ứng dụng của bạn bằng cách sử dụng danh sách và lưới.

Bây giờ hãy nói về cách chia sẻ dữ liệu đó ngoài ứng dụng của bạn.

Một trong những phương pháp chia sẻ dữ liệu đơn giản nhất là chỉ cần kéo nó ra khỏi ứng dụng của bạn.

Trong ứng dụng Heroes & Villains của tôi, tôi đã định cấu hình biểu tượng nhân vật trên màn hình chi tiết để có thể kéo được bằng cách sử dụng công cụ sửa đổi onDrag hiện có.

Mới trong năm nay, bây giờ bạn có thể thêm các bản xem trước tùy chỉnh vào chế độ xem có thể kéo của mình.

Bản xem trước này được hiển thị thay vì chế độ xem trong khi nó đang được kéo.

Kéo và thả được cung cấp bởi các nhà cung cấp vật phẩm, cho phép sao chép và chia sẻ dữ liệu giữa các quy trình khác nhau.

Năm nay, SwiftUI đang cung cấp thêm một số cách để sử dụng các nhà cung cấp mặt hàng để tích hợp với các ứng dụng và dịch vụ khác như định cấu hình ứng dụng của bạn để hỗ trợ nhập các nhà cung cấp mặt hàng từ các dịch vụ bên ngoài, sử dụng công cụ sửa đổi importsItemProviders mới.

Trong ví dụ này, chúng tôi đã định cấu hình chế độ xem của mình để có thể nhập hình ảnh và thêm chúng dưới dạng tệp đính kèm cho các nhân vật câu chuyện của chúng tôi.

Chúng ta có thể ghép nối khả năng này với tính năng macOS mới: Continuity Camera.

Bằng cách thêm các lệnh "Nhập từ Thiết bị" vào menu chính của ứng dụng, giờ đây chúng tôi có thể sử dụng iPhone hoặc iPad để chỉ chụp ảnh để nhập vào ứng dụng Mac của mình.

Hãy thử nó đi!

Biểu tượng của siêu anh hùng View Builder là chiếc búa đáng tin cậy của cô ấy.

Sẽ thật tuyệt nếu đính kèm một bức ảnh của nó vào hồ sơ của cô ấy.

May mắn thay, tôi tình cờ có nó ngay tại đây!

Từ bên trong ứng dụng của mình, tôi có thể truy cập các lệnh "Nhập từ thiết bị" trong menu Tệp.

Sau đó, tôi có thể chọn chụp ảnh bằng iPhone của mình...

....Tự động mở ứng dụng Camera để chúng ta có thể nhanh chóng chụp ảnh.

Và ảnh mới được nhập và thêm vào ứng dụng của tôi, sử dụng công cụ sửa đổi importsItemProviders mà chúng tôi đã trình bày trước đó.

SwiftUI cũng hỗ trợ xuất dữ liệu ra khỏi ứng dụng của chúng tôi.

Xuất dữ liệu cho phép bạn tận dụng các dịch vụ khác, chẳng hạn như có thể kích hoạt các phím tắt trực tiếp trong ứng dụng của bạn.

Trong SwiftUI, bạn có thể xuất dữ liệu bằng cách sử dụng công cụ sửa đổi exportsItemProviders mới.

Điều này hiển thị dữ liệu ứng dụng của bạn cho phần còn lại của hệ thống, ví dụ, cho phép nó được sử dụng bởi các dịch vụ và phím tắt trên macOS.

Hãy cùng xem điều này xuất hiện như thế nào đối với những người sử dụng ứng dụng.

Bây giờ tôi có thể thấy các hành động nhanh hiển thị trong menu Dịch vụ của ứng dụng khi tôi đã chọn một trong các ký tự được ghim của mình.

Đây là một phím tắt tiện dụng để thêm biểu ngữ tiêu đề vào bức ảnh gần đây nhất, mà tôi có thể sử dụng để chia sẻ những ý tưởng siêu anh hùng mới nhất của mình với bạn bè.

Tôi đã tìm thấy bức ảnh tuyệt vời này để sử dụng cho siêu anh hùng Stylizer của mình, người cũng là một chú chó đáng yêu.

Phím tắt tùy chỉnh của tôi đã thêm biểu ngữ vui nhộn này lên trên cùng và phủ tên của anh hùng.

Phím tắt của tôi cũng cho phép tôi chia sẻ bức ảnh.

Tôi rất muốn nhận được phản hồi của Taylor, vì anh ấy biết một hoặc hai điều về đồ họa tuyệt vời.

Tôi chỉ có thể thêm Taylor làm người nhận và nhập một tin nhắn nhanh và gửi nó đi!

Bạn nghĩ sao, Taylor?

Taylor Kelly: Cảm ơn bạn, Matt. Nó trông thật hoàn hảo.

Và nó chắc chắn sẽ là ảnh liên lạc mới của bạn.

Hình ảnh đáng yêu này là một sự chuyển tiếp tuyệt vời cho phần tiếp theo, Đồ họa nâng cao.

Có một loạt các cải tiến thú vị trong năm nay: từ cập nhật biểu tượng, vật liệu và sự sống động, đến chế độ xem canvas mới mạnh mẽ.

Đầu tiên là các biểu tượng.

Biểu tượng SF là một cách tuyệt vời và dễ dàng để thêm biểu tượng đẹp trong ứng dụng của bạn.

Không chỉ có nhiều cái mới trong năm nay, mà chúng còn đi kèm với một số tính năng mới để giúp việc sử dụng chúng trong ứng dụng của bạn trở nên dễ dàng và biểu cảm hơn.

Có hai chế độ kết xuất mới cho phép bạn kiểm soát nhiều hơn cách tạo kiểu biểu tượng.

Phân cấp sử dụng kiểu tiền cảnh hiện tại để tô màu biểu tượng, giống như đơn sắc, nhưng tự động thêm nhiều cấp độ mờ để thực sự nhấn mạnh các yếu tố chính của biểu tượng.

Và bảng màu cung cấp cho bạn quyền kiểm soát chi tiết hơn nữa đối với các lớp riêng lẻ của biểu tượng với các lần tô tùy chỉnh.

Kiểm tra "Có gì mới trong Biểu tượng SF" để biết thêm thông tin và hướng dẫn thiết kế về các chế độ mới này.

Kết hợp hoàn hảo với những thứ này là bản cập nhật cho bộ màu có sẵn trong SwiftUI.

Những màu này được tối ưu hóa cho tất cả các cấu hình khác nhau mà chúng xuất hiện: Chế độ sáng và tối, giao diện cụ thể trên các vết mờ và thậm chí cả nền tảng cụ thể mà chúng được hiển thị.

Ngoài các màu sắc khác nhau, các biểu tượng có nhiều hình dạng khác nhau.

Nhiều biểu tượng có công cụ sửa đổi để hiển thị dưới dạng điền, khoanh tròn và hơn thế nữa.

Trước đây bạn phải mã hóa cứng các biến thể này.

Nhưng hơn thế nữa, bạn phải biết biến thể nào đúng để sử dụng trong bối cảnh nào.

Nguyên tắc giao diện con người iOS mô tả cách trong các thanh tab, các biến thể đã điền nên được ưu tiên, vì vậy bạn phải bao gồm cụ thể công cụ sửa đổi .fill đó trong tên.

Năm nay, bạn không phải lo lắng về điều đó.

SwiftUI sẽ tự động chọn biến thể phù hợp với bạn dựa trên ngữ cảnh bạn sử dụng nó.

Tất cả những gì bạn phải làm là cung cấp biểu tượng cơ sở mà bạn muốn sử dụng.

Và bằng cách không xác định quá mức cấu hình chính xác mà bạn muốn, bạn cũng nhận được mã có thể tái sử dụng nhiều hơn.

Ví dụ, nếu chúng ta chạy cùng một mã này trên macOS, chúng ta sẽ nhận được biến thể chính xác cho nền tảng đó: phác thảo.

Để tìm hiểu cách tận dụng sự hỗ trợ tự động này trong chế độ xem tùy chỉnh của riêng bạn, cũng như nhiều cải tiến biểu tượng hơn, hãy xem "Biểu tượng SF trong SwiftUI".

Hiện tại có rất nhiều Biểu tượng SF, vì vậy tôi muốn xây dựng một trình hiển thị thú vị để duyệt qua tất cả chúng.

Đây là một cách sử dụng tuyệt vời cho chế độ xem Canvas mới của SwiftUI.

Canvas hỗ trợ vẽ chế độ ngay lập tức tương tự như drawRect từ UIKit hoặc AppKit.

Khi soạn nhiều yếu tố đồ họa không cần theo dõi hoặc vô hiệu hóa riêng lẻ, đây là một công cụ tuyệt vời.

Ở đây tôi có một khung vẽ hiển thị mọi Biểu tượng SF đi kèm với hệ điều hành.

Và đối với tất cả 3166 người trong số họ, nó thu hút mỗi người trong số họ vào khung của riêng họ.

Canvas hoạt động trên mọi nền tảng.

Và vì Canvas là một chế độ xem giống như bất kỳ chế độ xem nào khác, chúng tôi cũng có thể đính kèm cử chỉ, thông tin khả năng truy cập và cập nhật nó dựa trên trạng thái hoặc môi trường như thích ứng với Chế độ tối.

Ở đây, tôi đã thêm một cử chỉ cho phép tôi đặt tiêu điểm để phóng to.

Và tôi sẽ cập nhật khung và độ mờ đục của mỗi biểu tượng dựa trên điều đó.

Bây giờ tôi có thể nhấp và kéo xung quanh và mọi biểu tượng cập nhật trơn tru khi con trỏ di chuyển xung quanh màn hình.

Chúng tôi cũng có thể đảm bảo rằng điều này hoàn toàn có thể truy cập được bằng cách tận dụng công cụ sửa đổi accessibilityChildren mới.

Điều thú vị là bạn sử dụng lại các chế độ xem giống nhau mà bạn đã sử dụng trong SwiftUI để tinh chỉnh cách nó xuất hiện thông qua các tính năng trợ năng.

Trong trường hợp này, các biểu tượng bây giờ có thể được liệt kê giống như ai đó sẽ duyệt qua các phần tử trong danh sách, nói từng phần tử khi chúng điều hướng qua.

Công cụ sửa đổi này không chỉ giới hạn ở Canvas, nhưng có thể được sử dụng với bất kỳ chế độ xem nào để thực sự đánh bóng trải nghiệm khả năng tiếp cận của nó.

Một điều cuối cùng chúng tôi có thể thêm vào khung vẽ của mình là cập nhật theo thời gian, sử dụng TimelineView mới.

Một sự tinh chỉnh để thực hiện cho tvOS là để tiêu điểm đó di chuyển một cách hoạt hình xung quanh màn hình, hoạt động giống như một trình bảo vệ màn hình.

TimelineView được tạo ra với một lịch trình - trong trường hợp này là lịch trình hoạt hình - và nó cung cấp thời gian hiển thị hiện tại.

Và vì vậy chúng ta có thể sử dụng thời gian đó để cập nhật tiêu điểm trong quá trình chuyển đổi, tạo ra trình bảo vệ màn hình biểu tượng tuyệt đẹp của chúng ta.

Chế độ xem dòng thời gian này có thể làm được nhiều hơn thế.

Một tính năng thực sự thú vị của Apple Watch là nó luôn hiển thị.

Trước đây, ứng dụng của bạn sẽ bị mờ với thời gian được phủ lên khi nó chuyển sang trạng thái Luôn Bật.

Và với watchOS 8, ứng dụng của bạn hiện mờ dần theo mặc định và bạn có nhiều quyền kiểm soát hơn đối với cách nó xuất hiện với SwiftUI cung cấp cho bạn các công cụ bạn cần, một trong số đó là TimelineView.

Khi đồng hồ chuyển sang trạng thái Luôn Bật, TimelineView có thể tải trước màn hình hiển thị chế độ xem của bạn vào những ngày trong tương lai.

Và khi chúng ta tiến tới tương lai, những chế độ xem đó sẽ tự động được hiển thị trên màn hình mà không bao giờ lấy ứng dụng của bạn từ nền.

Một phần quan trọng của việc này là Lịch trình Dòng thời gian.

Trong ví dụ này, tôi đang sử dụng lịch trình everyMinute đơn giản để TimelineView sẽ tải trước màn hình của mỗi phút trên phút, hiển thị cho tôi biểu tượng tiếp theo trong trình duyệt.

Có một số loại lịch trình khác cũng như để giúp phù hợp với nhu cầu của ứng dụng của bạn, chẳng hạn như một bộ sưu tập các ngày rõ ràng, hoạt động tốt khi sẽ có các sự kiện vào những thời điểm cụ thể.

Bây giờ, một khía cạnh quan trọng khác của chế độ này là ẩn thông tin nhạy cảm với người dùng vì nó có thể hiển thị với những người khác.

Tôi thực sự muốn giữ riêng tư biểu tượng yêu thích của mình.

Và chỉ cần thêm công cụ sửa đổi privacySensitive, nó sẽ tự động được chỉnh sửa lại khi đồng hồ chuyển sang trạng thái Luôn Bật.

Kiểm tra "Có gì mới trong watchOS 8" để biết thêm thông tin về màn hình Luôn Bật và hơn thế nữa.

Và công cụ sửa đổi nhạy cảm với quyền riêng tư này cũng hoạt động trong các tiện ích.

Các tiện ích được thêm vào màn hình Khóa sẽ sử dụng điều này để ẩn thông tin nhạy cảm trong khi thiết bị vẫn bị khóa và hiển thị khi thiết bị được mở khóa.

"Nguyên tắc của các tiện ích tuyệt vời" sẽ đi vào chi tiết hơn về điều này và các cách khác để xây dựng các tiện ích tuyệt vời cho ứng dụng của bạn.

Tài liệu được sử dụng trên tất cả các nền tảng và ứng dụng của Apple để tạo ra các hiệu ứng hình ảnh đẹp mắt thực sự nhấn mạnh nội dung của chúng và bây giờ bạn có thể tạo chúng trực tiếp trong SwiftUI!

Tôi đã thử nghiệm thêm màu sắc và vật liệu vào Trình duyệt Biểu tượng của mình và tôi đang thêm lớp phủ được hỗ trợ bởi vật liệu để hiển thị số lượng biểu tượng.

Thêm một tài liệu dễ dàng như thêm một nền.

Tôi đang sử dụng ultraThinMaterial, và có thể cung cấp cho nó bất kỳ hình dạng tùy chỉnh nào để lấp đầy.

Những tài liệu này tự động đi kèm với sự pha trộn sôi động như mong đợi của nội dung bên trên chúng khi sử dụng các phong cách sơ cấp, trung học, đại học và bây giờ thậm chí là tiền cảnh bậc bốn.

Và biểu tượng cảm xúc được tự động loại trừ khỏi điều đó, vì vậy chúng trông chính xác như bình thường.

Trên Mac, bối cảnh hệ thống như thanh bên và cửa sổ bật lên tự động có nền vật liệu mờ và giờ đây cũng sẽ có giao diện sống động như mong đợi cho nội dung bên trong chúng.

Những tài liệu mới này hoạt động tốt khi kết hợp với công cụ sửa đổi safeAreaInset mới, cho phép bạn đặt nội dung lên trên chế độ xem có thể cuộn và vị trí nội dung vẫn bắt đầu và kết thúc như mong đợi.

Phiên "đồ họa phong phú" đi sâu vào chi tiết hơn rất nhiều trên vải, vật liệu và hơn thế nữa.

Và để kết thúc nó, bổ sung các cách mới để xác định các chế độ xem tùy chỉnh tuyệt đẹp này là một vài cải tiến đối với các bản xem trước SwiftUI trong Xcode.

Đầu tiên là một công cụ sửa đổi định hướng xem trước mới cho phép bạn chỉ định hướng của thiết bị iOS trong các bản xem trước và thậm chí trộn và kết hợp các bản xem trước trên các hướng khác nhau.

Và thứ hai là một cải tiến lớn đối với cách bạn chỉnh sửa và xem khả năng truy cập ứng dụng của mình trong các bản xem trước.

Trình chỉnh sửa tài sản hiện có một danh sách được sắp xếp các công cụ sửa đổi khả năng truy cập, giúp việc đánh bóng hành vi khả năng truy cập của chế độ xem trở nên dễ dàng hơn.

Và có một cách hoàn toàn mới để xem bản xem trước của bạn với tab Xem trước Trợ năng mới.

Bạn sẽ được hiển thị một đại diện trực tiếp, văn bản của các yếu tố khả năng tiếp cận và các thuộc tính của chúng.

Đây là thông tin tương tự cung cấp các tính năng trợ năng, nhưng hiện được trình bày cho bạn ở định dạng có thể quen thuộc hơn với bạn.

Kiểm tra phiên "Truy cập SwiftUI" để biết thêm thông tin về điều này và nhiều hơn nữa về cách tạo trải nghiệm khả năng truy cập tuyệt vời cho ứng dụng của bạn!

Bây giờ, tiếp theo là một loạt các cải tiến đối với văn bản, các điều khiển liên quan đến văn bản và điều hướng bàn phím.

Văn bản rất cơ bản cho mọi ứng dụng.

Đó là một trong những cách chính mà ứng dụng của bạn giao tiếp với mọi người; nó thường là chế độ xem đầu tiên bạn viết.

Và năm nay, nó đã đạt được rất nhiều tính năng thú vị mới từ kiểu dáng đến bản địa hóa, đến tương tác và định dạng.

Đầu tiên là hỗ trợ Markdown.

Văn bản bây giờ có thể chứa định dạng Markdown trực tiếp nội tuyến.

Điều này có thể được sử dụng để thêm sự nhấn mạnh mẽ, các liên kết - có thể được tương tác với - và thậm chí cả bản trình bày kiểu mã.

Và tất cả điều này được xây dựng dựa trên AttributedString mới, mạnh mẽ dựa trên Swift trong Foundation.

Ngoài hỗ trợ Markdown, nó còn mang đến toàn bộ bộ các thuộc tính phong phú, an toàn kiểu và khả năng xác định các thuộc tính của riêng bạn và thậm chí sử dụng chúng trong cú pháp Markdown.

Để biết thêm thông tin về điều này và thỏa thuận Ngữ pháp Tự động mới tuyệt vời, hãy xem "Có gì mới trong Nền tảng."

Quan trọng hơn, văn bản cũng bản địa hóa nội dung của nó để mọi người trên khắp thế giới có thể sử dụng ứng dụng của bạn.

Và điều này cũng đúng với hỗ trợ Markdown mới, cho phép các thuộc tính nhạy cảm với ngôn ngữ được bản địa hóa đúng cách.

Một cải tiến tuyệt vời khác cho bản địa hóa đến từ Xcode 13.

Bây giờ nó sử dụng trình biên dịch Swift để tạo các chuỗi và danh mục bản địa hóa từ mọi lần sử dụng LocalizedStringKey và các trình khởi tạo localizedString và attributedString mới.

Để tìm hiểu thêm về điều này và các mẹo và thủ thuật bản địa hóa khác, hãy xem "Nội địa hóa ứng dụng SwiftUI của bạn".

Bây giờ, ngoài những cách hiển thị văn bản mới này, còn có những cách mới để làm cho văn bản trở nên năng động hơn.

Đầu tiên là một tính năng tiếp cận quan trọng: Loại động.

SwiftUI đã hỗ trợ Dynamic Type kể từ khi thành lập và năm nay có một API mới cho phép hạn chế phạm vi kích thước loại mà giao diện người dùng hỗ trợ để giữ cho nó không quá lớn hoặc quá nhỏ.

Điều này cho thấy tiêu đề của chúng tôi trông như thế nào ở kích thước lớn mặc định.

Cá nhân tôi sử dụng Dynamic Type để có thêm mật độ thông tin vào nội dung của mình và điều này cho thấy tiêu đề vẫn giữ nguyên kích thước ở kích thước loại nhỏ như thế nào, vì nó bị giới hạn ở mức tối thiểu là kích thước lớn.

Ở đầu kia của quang phổ, việc sử dụng kích thước khả năng tiếp cận dẫn đến tiêu đề của chúng tôi phát triển lớn hơn, nhưng chỉ lên đến kích thước cực lớn.

Mặc dù macOS không hỗ trợ Dynamic Type, nhưng nó hỗ trợ một tương tác văn bản quan trọng khác: văn bản có thể lựa chọn.

Điều này cho phép mọi người thực hiện hành động trên văn bản không thể chỉnh sửa từ ứng dụng của bạn và hiện có thể được bật bằng cách sử dụng công cụ sửa đổi textSelection.

Công cụ sửa đổi đó có thể được áp dụng cho bất kỳ chế độ xem nào và nó áp dụng cho tất cả văn bản bên trong nó - trong ví dụ này, bây giờ áp dụng cho văn bản trong tiêu đề.

Và chúng tôi cũng đã giới thiệu công cụ sửa đổi này trên iOS và iPadOS, nơi nó cho phép văn bản được sao chép hoặc chia sẻ trên báo chí dài.

Cuối cùng, các API kiểu định dạng mới của Foundation giúp việc định dạng văn bản đơn giản hơn rất nhiều, nhưng vẫn cho phép trình bày chính xác.

Ở đây chúng ta có một ngày áp dụng định dạng mặc định.

Và đây là một biến thể chỉ hiển thị thời gian, như được sử dụng trong danh sách hoạt động.

Và cuối cùng, một định dạng mở rộng cho phép chỉ định các thành phần chính xác để hiển thị.

Danh sách hoạt động của chúng tôi cũng giới thiệu định dạng một mảng người thành một bài thuyết trình được bản địa hóa đúng cách.

Hãy nhanh chóng xem qua điều này.

Chúng tôi đang ánh xạ các giá trị người của mình vào một mảng PersonNameComponents và định dạng nó bằng cách sử dụng kiểu định dạng danh sách.

Và đối với mỗi thành viên trong danh sách, sử dụng định dạng PersonNameComponent với kiểu ngắn, chỉ hiển thị tên đầu tiên.

Và cuối cùng, tham gia nó với một sự kết hợp "và".

Tất cả cùng nhau, tạo ra một biểu hiện định dạng hiệu quả và an toàn kiểu xử lý đúng cách bất kỳ số lượng người nào.

TextField cũng đã nhận được sự hỗ trợ cho các kiểu định dạng mới này, cho phép bạn thêm văn bản được định dạng có thể chỉnh sửa với liên kết an toàn kiểu với một số giá trị cơ bản.

Trường người tham dự mới được liên kết với giá trị PersonNameComponents và nó được định dạng bằng định dạng tên tiêu chuẩn.

Điều này quan tâm đến việc phân tích cú pháp đầu vào và tạo ra tên người kết quả.

"Có gì mới trong Foundation" cũng đi vào chi tiết về sức mạnh của những phong cách định dạng mới này.

TextField hiện cũng hỗ trợ thêm lời nhắc rõ ràng, tách biệt với nhãn của nó, để cho người dùng biết loại nội dung mà một trường đang mong đợi.

Và khi thêm TextField vào biểu mẫu trên macOS, họ sẽ căn chỉnh nhãn của mình tương tự như các điều khiển khác và sử dụng lời nhắc làm nội dung giữ chỗ của nó.

Bây giờ, toàn bộ điểm của trường văn bản là thêm văn bản và bàn phím là công cụ của chúng tôi để làm điều đó.

Từ bàn phím phần mềm trên iPhone đến iPad, hỗ trợ cả bàn phím phần mềm và phần cứng, và tất nhiên, macOS, luôn có bàn phím phần cứng.

Năm nay, có một số cải tiến để làm cho trải nghiệm sử dụng bàn phím trở nên tốt hơn.

Với công cụ sửa đổi onSubmit mới, bạn có thể dễ dàng thêm các hành động bổ sung khi người dùng gửi văn bản của trường, chẳng hạn như bằng cách nhấn phím Return.

Công cụ sửa đổi này cung cấp thêm một số tính linh hoạt ở chỗ nó thậm chí có thể được áp dụng cho toàn bộ hình thức điều khiển.

Và để giúp cung cấp cho người dùng gợi ý về loại hành động nào sẽ xảy ra khi gửi một trường, có công cụ sửa đổi submitLabel mới.

Trên bàn phím phần mềm, điều này sẽ được sử dụng làm nhãn cho phím Return.

Và cuối cùng, chúng tôi đã có thể thêm chế độ xem phụ kiện vào bàn phím bằng cách sử dụng vị trí thanh công cụ bàn phím mới.

Những chế độ xem này sẽ được hiển thị trên thanh công cụ phía trên bàn phím phần mềm trên iOS và iPadOS hoặc trong Touch Bar trên macOS.

Đây là một cách tuyệt vời để cung cấp cho người dùng quyền truy cập nhanh vào các hành động phía trên bàn phím mà không bỏ qua nó để tránh làm gián đoạn trải nghiệm chỉnh sửa ứng dụng của bạn.

Bàn phím cũng phục vụ một vai trò quan trọng khác của điều hướng và lấy nét, và chức năng này tồn tại trên mọi nền tảng; từ việc sử dụng tập trung trên watchOS đến đầu vào Digital Crown trực tiếp, đến sử dụng Siri Remote để điều hướng xung quanh nội dung trên tvOS.

Đối với hầu hết mọi thứ, SwiftUI chỉ quan tâm đến những quan điểm nào có thể tập trung và cách nó di chuyển giữa chúng.

Nhưng đôi khi có những cải tiến bổ sung mà bạn có thể thực hiện để tạo ra trải nghiệm mượt mà hơn trong ứng dụng của mình.

Để giúp điều đó, SwiftUI có một công cụ mới, mạnh mẽ được gọi là FocusState.

Đây là một trình bao bọc thuộc tính vừa phản ánh trạng thái tập trung vừa cung cấp quyền kiểm soát chính xác đối với nó.

Đơn giản nhất, nó có thể phản ánh một giá trị Boolean.

Điều này có thể được gắn với chế độ xem có thể lấy nét bằng cách sử dụng công cụ sửa đổi lấy nét.

Khi quan điểm đó được tập trung, giá trị sẽ đúng và sai khi không.

Giá trị này cũng có thể được ghi vào, để kiểm soát tiêu điểm.

Ví dụ, để đáp lại việc ai đó nhấn một nút.

Ví dụ này có thể hoạt động như một máy gia tốc, cho phép người dùng bắt đầu nhập ngay lập tức sau khi thực hiện một hành động liên quan.

Phiên bản Boolean này là một sự tiện lợi cho hình thức đầy đủ của nó, đại diện cho bất kỳ loại nào có thể băm được.

Mã này có chức năng tương đương với slide trước đó nhưng với một số tính linh hoạt được tăng lên.

Hãy đi qua nó.

Đầu tiên, tôi đã xác định một bảng liệt kê đơn giản các trường mà tôi có thể muốn biết được tập trung.

Thuộc tính FocusState sử dụng loại đó để phản ánh trạng thái hiện tại.

Nó là tùy chọn để chỉ ra khả năng không ai trong số những người đã tập trung.

Công cụ sửa đổi tập trung của chúng tôi vẫn bị ràng buộc với cùng trạng thái lấy nét đó, nhưng chỉ khi nó bằng addAttendee.

Và cuối cùng, khi chúng tôi muốn tập trung vào lĩnh vực đó, chúng tôi đặt giá trị trạng thái tập trung của mình thành addAttendee.

Tính linh hoạt mới này cho phép thêm chức năng bổ sung, chẳng hạn như xây dựng các nút thanh công cụ từ trước, di chuyển tiêu điểm giữa mỗi trường và phản ánh xem tiêu điểm đạt đến đầu hay cuối.

Trạng thái lấy nét cũng cung cấp một cách tuyệt vời để các ứng dụng iOS loại bỏ bàn phím phần mềm bằng cách xóa giá trị của nó.

Nếu bạn quan tâm đến việc tìm hiểu thêm về các cách khác để tinh chỉnh trải nghiệm tập trung trong ứng dụng của mình, hãy xem phiên năm nay, "Trực tiếp và phản ánh sự tập trung trong SwiftUI."

Cuối cùng, chúng ta sẽ tập trung vào các nút vì các nút rất quan trọng.

Tất cả chúng ta đều biết một nút điển hình trông như thế nào; nó thay đổi từ nền tảng này sang nền tảng khác và nó là một trong những cách đơn giản nhất để cho phép mọi người tương tác với ứng dụng của bạn.

Và đặc biệt là trong SwiftUI, các nút được sử dụng cho rất nhiều thứ.

Matt đã thảo luận trước đó về cách các hành động vuốt được tạo thành từ các nút.

Và năm nay, có rất nhiều thứ mới với các nút.

Đầu tiên, SwiftUI hiện có các nút viền tiêu chuẩn trên iOS.

Bạn có thể tạo một nút có viền chỉ bằng cách thêm công cụ sửa đổi buttonStyle, giống như tôi đang làm với nút Thêm này.

Giống như các công cụ sửa đổi kiểu khác, điều này có thể được thêm vào một nhóm các điều khiển và áp dụng cho tất cả chúng.

Nó hỗ trợ nhuộm màu cho các trường hợp bạn muốn có một diện mạo cụ thể cho một nút nhất định.

Nhưng đối với giao diện người dùng này, tôi thích giao diện mặc định sử dụng màu nhấn.

Cũng có nhiều tùy chỉnh hơn được tích hợp sẵn.

Đầu tiên là kiểm soát kích thước và sự nổi bật.

Tôi đang sử dụng những thứ này để tùy chỉnh các nút đại diện cho các thẻ.

Họ đang sử dụng kích thước điều khiển nhỏ tiêu chuẩn mới và có tông màu với sự nổi bật ngày càng tăng để thực sự làm cho chúng nổi bật.

Chúng ta có thể sử dụng các công cụ sửa đổi tương tự này để tạo ra một loại nút phổ biến khác: những nút có kích thước lớn này hiện được tích hợp vào SwiftUI.

Bằng cách chỉ định kích thước điều khiển lớn, bạn sẽ tự động nhận được các nút hình chữ nhật tròn, đẹp mắt này.

Và để mang lại cho họ cảm giác về hệ thống phân cấp, tôi đã sửa đổi cái quan trọng nhất để tăng sự nổi bật, lấp đầy nó bằng một màu nhấn có độ tương phản cao.

Và nút phụ vẫn có thể được nhuộm màu nhưng có độ tương phản thấp hơn.

Các nút này cũng có ít công cụ sửa đổi để làm cho chúng trở nên tuyệt vời trên iPad.

Các nhãn văn bản có chiều rộng tối đa để nút tổng thể linh hoạt nhưng không lớn một cách hài hước.

Và nút chính có phím tắt hành động mặc định, vì vậy khi sử dụng ứng dụng có bàn phím, tôi có thể nhanh chóng nhấn phím Return để thêm nút này vào lọ của mình.

Giờ đây, nhiều API này đã tồn tại trên macOS, giúp việc xây dựng ứng dụng cho nhiều nền tảng trở nên dễ dàng hơn.

Một bổ sung mới là tăng cường hỗ trợ tông màu nổi bật để cho phép bạn thêm các nút sáng này vào ứng dụng của mình một cách trang nhã.

Lưu ý rằng các nút không nổi bật, như các nút Thêm này, không hiển thị bất kỳ tông màu nào vì chrome của chúng là thứ cho thấy tính tương tác của chúng trên macOS.

Sau khi tìm hiểu về sự nổi bật, tôi có thể bị cám dỗ để áp dụng điều đó cho tất cả các nút Thêm của mình, nhưng có thể trở nên quá sức và khó hiểu khi có rất nhiều nút nổi bật trên màn hình.

Tốt nhất là dành nó cho các hành động chính đơn lẻ.

Màu sắc nổi bật thấp hơn là một sự thay thế tuyệt vời để thêm một chút màu sắc trên iOS.

Bây giờ, điều yêu thích của tôi về các kiểu nút mới này là chúng tự động có trạng thái nhấn và tắt dự kiến, hỗ trợ Chế độ tối và tất nhiên hoàn toàn có thể truy cập và tương thích với Loại động.

Và chúng giúp mang lại sự nhất quán giữa các ứng dụng.

Và API mới của các nút không dừng lại ở đây.

SwiftUI cũng đã thêm hỗ trợ hạng nhất cho các nút có ngữ nghĩa bổ sung, chẳng hạn như đánh dấu một nút là phá hoại, điều này sẽ tự động cung cấp cho chúng tông màu đỏ dự kiến.

Một ngữ cảnh mới mà điều này cũng có thể được sử dụng trong các hộp thoại xác nhận, cho phép người dùng xác nhận các hành động có tác động nghiêm trọng đến dữ liệu của họ.

Trên iOS, điều này hiển thị dưới dạng bảng hành động, trên iPad dưới dạng cửa sổ bật lên và trên macOS dưới dạng cảnh báo.

SwiftUI tự động xử lý theo độ nhạy thiết kế của từng nền tảng.

Tiếp theo, hãy nói về các nút không phải là nút "vốn B".

Hiện tại, các nút Thêm của ứng dụng chỉ cần thêm vào lọ mặc định của người dùng.

Nhưng đối với những nhà sưu tập cuồng nhiệt, tôi muốn hỗ trợ thêm vào các lọ cụ thể.

Đây là một trường hợp sử dụng hoàn hảo cho một nút menu.

Chúng tôi sẽ sử dụng cùng một nhãn "Thêm", nhưng trình bày một menu gồm tất cả các lọ có thể có sau khi nhấp vào nút.

Tuy nhiên, các nút menu này trực quan mang rất nhiều điểm nổi bật.

Chúng tôi có thể ẩn các chỉ báo bằng cách sử dụng công cụ sửa đổi menuIndicator mới được thêm vào trong năm nay.

Và ngay cả khi không có chỉ báo, nút này vẫn hiển thị menu khi nhấp chuột.

Nhưng đối với các nút này, lý tưởng nhất là chúng ta sẽ tận dụng tốt nhất cả hai thế giới: chỉ với một cú nhấp chuột đơn giản để thêm vào lọ mặc định và tính linh hoạt trong việc hiển thị menu của những người khác.

Điểm mới trong năm nay là khả năng tùy chỉnh hành động chính của menu để giúp giải quyết loại trường hợp này.

Theo mặc định, một menu với hành động chính có giao diện hai phân đoạn trên macOS.

Phần chính của nút kích hoạt hành động chính trong chỉ báo trình bày menu.

Và khi chỉ báo bị ẩn, nó lại trông giống như nút mà tôi đã bắt đầu nhưng có sự khác biệt về hành vi.

Một cú nhấp chuột kích hoạt hành động chính và nhấn và giữ sẽ hiển thị menu.

Và điều tuyệt vời là điều tương tự này cũng hoạt động trên iOS!

Bây giờ các menu này cung cấp rất nhiều sự linh hoạt, thực sự phục vụ cho cách ứng dụng của bạn cần sử dụng chúng.

Một ví dụ mới khác về việc điều khiển đạt được kiểu nút là Chuyển đổi.

Điều này tạo ra một nút mà khi chạm vào, bật và tắt trực quan và có thể được sử dụng giống như bất kỳ nút chuyển đổi nào khác.

Và tham gia các kiểu điều khiển mới này là một vùng chứa nhóm các điều khiển liên quan; được gọi một cách khéo léo là ControlGroup.

Trên iOS, các điều khiển trong một nhóm được sắp xếp chặt chẽ hơn một chút trên thanh công cụ.

Và trên macOS, có các khả năng trực quan chỉ ra hai nút được nhóm lại.

Và để kết thúc tất cả những điều này, tự nhiên tất cả những thứ này có thể được kết hợp với nhau.

Ví dụ, các nút quay lại/chuyển tiếp tiêu chuẩn này là một ControlGroup gồm hai menu.

Mỗi menu này đều có một Hành động chính được thực hiện khi được nhấp vào.

Và một khi thực đơn được nhấn từ lâu, họ sẽ trình bày nội dung của họ.

Giờ đây, chỉ với một vài tùy chỉnh bổ sung trên các nút và các kiểu mới này, rất nhiều sự linh hoạt đã mở ra về cách bạn có thể sử dụng các điều khiển này trong ứng dụng của mình.

Chúng tôi đã trải qua rất nhiều trong phiên này, và thậm chí còn có nhiều thứ hơn mà chúng tôi không có thời gian để trang trải.

Chúng tôi rất vui khi bạn tận dụng các tính năng mới này trong các ứng dụng SwiftUI của riêng bạn và áp dụng SwiftUI ở nhiều nơi hơn nữa.

Cảm ơn bạn và chúc bạn có một phần còn lại tuyệt vời trong năm 2021 của bạn!

♪