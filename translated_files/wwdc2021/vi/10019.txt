10019

Xin chào, chào mừng đến với "Khám phá sự đồng thời trong SwiftUI."

Tôi là Curt Clifton, một kỹ sư trong nhóm SwiftUI.

Lát nữa, tôi sẽ được tham gia bởi đồng nghiệp Jessica của tôi.

Swift 5.5 giới thiệu nhiều công cụ mới để quản lý đồng thời trong mã Swift của bạn.

Trong buổi nói chuyện này, Jessica và tôi sẽ giúp bạn hiểu những cải tiến này tương tác với các ứng dụng SwiftUI của bạn như thế nào.

Tôi sẽ hướng dẫn cách các công cụ mới có thể giúp bạn làm cho các mô hình dữ liệu của mình trở nên tốt hơn và chỉ cho bạn cách SwiftUI hoạt động với diễn viên chính mới.

Sau đó, Jessica sẽ chỉ cho bạn cách kết nối mô hình dữ liệu đồng thời với chế độ xem SwiftUI của bạn và giới thiệu một số API mới tuyệt vời tận dụng các công cụ đồng thời mới của Swift.

Để tận dụng tối đa thông tin Jessica và tôi sẽ chia sẻ, điều quan trọng là phải có một số thông tin cơ bản về hỗ trợ đồng thời mới của Swift.

Chúng tôi khuyên bạn nên xem "Gặp gỡ không đồng bộ/chờ đợi trong Swift" và "Khám phá sự đồng thời có cấu trúc trong Swift" trước khi đi sâu vào phần còn lại của video này.

Khi tôi còn là một đứa trẻ, tôi luôn mơ ước trở thành một phi hành gia.

Đôi khi tôi làm việc trong một con tàu vũ trụ, nhưng nếu không thì giấc mơ thời thơ ấu đặc biệt đó đã không thành hiện thực.

Tuy nhiên, tôi vẫn chưa mất đi sự nhiệt tình của mình đối với không gian.

Vì vậy, tôi quyết định áp dụng các kỹ năng thực tế của mình với tư cách là một kỹ sư SwiftUI để xây dựng một ứng dụng tải xuống các bức ảnh liên quan đến không gian.

Hãy cùng xem ứng dụng mà tôi đã lên kế hoạch.

Ứng dụng hiển thị một danh sách các bức ảnh không gian ngẫu nhiên.

Những màu này thật đẹp.

Khi tôi nhìn thấy một bức ảnh mà tôi thực sự yêu thích, tôi có thể lưu nó để xem sau.

Để tìm nạp những hình ảnh đẹp này, ứng dụng của tôi sẽ tương tác với dịch vụ web bằng REST API.

Điều này nghe có vẻ như là một cách sử dụng hoàn hảo các tính năng đồng thời mới được giới thiệu trong Swift.

Hãy bắt đầu với mô hình dữ liệu của chúng ta.

Tôi đang sử dụng cấu trúc SpacePhoto để giữ thông tin cho một hình ảnh duy nhất.

Cấu trúc có các trường như tiêu đề, mô tả về ảnh, ngày hình ảnh được đăng và URL trỏ đến hình ảnh thực tế.

Tôi đã tạo Type Codable của mình để tôi có thể dễ dàng khởi tạo các phiên bản từ phản hồi của máy chủ hoặc lưu chúng vào đĩa và có thể nhận dạng để tôi có thể sử dụng chúng trong ForEach và các chế độ xem dựa trên dữ liệu khác.

Tiếp theo, tôi muốn hiển thị danh sách các mục này.

Đối với điều đó, tôi cần một mô hình sẽ tìm nạp và giữ một bộ sưu tập của chúng.

Tôi đang sử dụng một lớp Ảnh cho việc này.

Bằng cách làm cho lớp Ảnh của tôi phù hợp với ObservableObject, chế độ xem SwiftUI của tôi sẽ tự động cập nhật bất cứ khi nào dữ liệu của tôi cập nhật.

Tôi đang sử dụng một tài sản đã xuất bản để lưu trữ một mảng SpacePhotos.

Để tìm nạp các mục đã cập nhật từ điểm cuối REST, tôi đang sử dụng phương pháp Cập nhật các mục.

Tôi sẽ sớm nói về điều đó chi tiết hơn.

Nhưng trước tiên tôi muốn thô bạo trong giao diện người dùng cơ bản.

Đây là giao diện người dùng mà tôi muốn xây dựng.

Cho đến nay, tôi chỉ có chế độ xem tab của mình và Chế độ xem ảnh cơ bản.

PhotoView của tôi chụp một bức ảnh không gian và hiển thị tiêu đề của nó.

Thế là đủ hệ thống ống nước để tôi có thể thấy mô hình dữ liệu của mình đang hoạt động.

Hãy xem chế độ xem Danh mục tiếp theo.

Chế độ xem Danh mục của tôi sẽ hiển thị danh sách các bức ảnh.

Để làm điều đó, tôi sẽ thêm một Đối tượng Trạng thái và khởi tạo nó với đối tượng có thể quan sát được Ảnh của tôi.

Trong phần thân chế độ xem của tôi, tôi sẽ thêm Chế độ xem điều hướng.

Sử dụng chế độ xem điều hướng ở đây sẽ cho phép tôi thêm một tiêu đề điều hướng lớn trong thời gian ngắn.

Tiếp theo, bên trong NavigationView của tôi, tôi sẽ thêm một Danh sách.

Và bên trong Danh sách của mình, tôi sẽ sử dụng ForEach để lập bản đồ các bức ảnh của mình, hiển thị Chế độ xem ảnh cho từng bức ảnh.

Với điều đó, tôi có thể xem dữ liệu mẫu của mình.

Đó là xa như tôi cần đi bây giờ, nhưng hãy thêm một chút đánh bóng ở đây.

Đầu tiên, đây là tiêu đề điều hướng đã hứa.

Bây giờ, kiểu danh sách chèn mặc định ở đây trông rất tuyệt, nhưng để thực sự thể hiện các bức ảnh không gian của mình, tôi muốn chuyển sang kiểu đơn giản để các bức ảnh sẽ thực sự bật lên trên nền đen.

Tôi có thể làm cho kiểu danh sách đơn giản bằng cách sử dụng cú pháp thành viên tĩnh giống như enum mới ở đây.

Với cú pháp này, các công cụ sửa đổi kiểu của SwiftUI có được chính tả ngắn gọn hơn với sự hỗ trợ tốt hơn cho việc tự động hoàn thành trong Xcode 13.

Cuối cùng, hãy để tôi sử dụng một tính năng mới khác trong SwiftUI năm nay: kiểm soát dấu phân cách danh sách.

Bên trong ForEach của tôi, tôi có thể sử dụng công cụ sửa đổi listRowSeparator để ẩn các dấu phân cách.

Đôi khi khi tôi đánh bóng giao diện người dùng với SwiftUI, tôi cảm thấy khó dừng lại.

Nhưng tôi sẽ rời khỏi giao diện người dùng ngay bây giờ.

Jessica đang lên kế hoạch hoàn thành nó sau khi tôi hoàn thành mô hình dữ liệu.

Tuy nhiên, trước khi tôi đào sâu vào mô hình dữ liệu, tôi muốn nói một chút về cách SwiftUI tương tác với các đối tượng có thể quan sát được của bạn.

Và cách các tính năng đồng thời mới trong Swift 5.5 giúp tương tác này trở nên dễ dàng hơn bao giờ hết.

Tại Dub Dub 2020, trong "Data Essentials trong SwiftUI", đồng nghiệp Raj của tôi đã nói về vòng đời cập nhật SwiftUI.

Tôi sẽ đề cập đến mã điều khiển vòng đời này là "vòng lặp chạy". Với Swift 5.5, vòng lặp chạy chạy trên diễn viên chính.

Để biết thêm chi tiết về các diễn viên nói chung, hãy xem bài nói chuyện, "Bảo vệ trạng thái có thể thay đổi với các diễn viên Swift." Jessica và tôi sẽ tập trung vào diễn viên chính trong buổi nói chuyện này.

Vòng lặp chạy SwiftUI nhận các sự kiện từ người dùng của bạn, cho phép bạn cập nhật mô hình của mình và sau đó hiển thị chế độ xem SwiftUI của bạn lên màn hình.

Tôi muốn gọi những cập nhật này là "các ký tên của vòng lặp chạy." Hãy mở vòng lặp này để chúng ta có thể xem xét nhiều tích tắc liên tiếp.

Trong SwiftUI, ObservableObjects có thể tương tác với vòng lặp chạy SwiftUI theo một số cách thú vị.

Hãy quay lại Photos ObservableObject và xem phương thức updateItems.

Tôi sẽ gọi updateItems từ chế độ xem SwiftUI của mình và nó sẽ chạy trên diễn viên chính.

Hãy sử dụng hình chữ nhật màu xanh này để hiển thị thời gian khi updateItems đang chạy.

Tôi muốn tập trung vào dòng mã này, nơi tôi gán các bức ảnh đã tìm nạp cho thuộc tính "mục" của mình.

Bởi vì "các mục" là một thuộc tính đã xuất bản, bài tập này kích hoạt một sự kiện objectWillChange, ngay sau đó là viết các bức ảnh đã tìm nạp vào bộ nhớ cho "các mục". Khi SwiftUI nhìn thấy đối tượng này WillChange, nó sẽ chụp nhanh các mục của tôi.

Trong lần đánh dấu tiếp theo của vòng lặp chạy sau ảnh chụp nhanh, SwiftUI so sánh ảnh chụp nhanh với giá trị hiện tại.

Bởi vì những giá trị này khác nhau, SwiftUI biết cập nhật quan điểm của tôi phụ thuộc vào Ảnh.

Lưu ý rằng vì objectWillChange, cập nhật bộ nhớ và vòng lặp chạy đều xảy ra trên tác nhân chính, chúng được đảm bảo xảy ra theo thứ tự.

Trong bài nói chuyện "Data Essentials" năm 2020, Raj mô tả các cập nhật chậm khi chế độ xem của bạn thực hiện quá nhiều công việc trong cơ thể.

Cập nhật chậm cũng có thể xảy ra nếu mã mô hình của bạn làm quá nhiều việc trên diễn viên chính.

Ví dụ, giả sử chức năng fetchPhotos của tôi chặn trong khi chờ quá trình tải xuống hoàn tất và giả sử tôi đang kết nối chậm.

Bởi vì tôi đang chặn diễn viên chính, tôi nhớ dấu tích này của vòng lặp chạy.

Điều này hiển thị với người dùng của tôi như một trở ngại.

Trước đây, bạn có thể đã gửi đến một hàng đợi khác để thực hiện công việc, để các ảnh tìm nạp tiền xảy ra ngoài luồng chính.

Điều này có vẻ hoạt động tốt, nhưng tôi có một vấn đề khó khăn ở đây.

Tôi đang thay đổi ObservableObject của mình từ diễn viên chính.

Các thay đổi của tôi và đánh dấu vòng lặp chạy có thể xen kẽ.

Ví dụ: khi tôi gán cho "các mục" và SwiftUI chụp nhanh objectWillChange của nó, có thể điều này xảy ra ngay lập tức trước khi tích tắc vòng lặp chạy.

Sự thay đổi trạng thái vẫn chưa xảy ra, vì vậy SwiftUI so sánh ảnh chụp nhanh với giá trị không thay đổi.

Thay đổi trạng thái thực tế xảy ra sau khi đánh dấu vòng lặp chạy, nhưng SwiftUI không thấy thay đổi đó và vì vậy chế độ xem của tôi không được cập nhật.

Để cập nhật chính xác, SwiftUI cần các sự kiện này xảy ra theo thứ tự: objectWillChange, trạng thái của ObservableObject được cập nhật và sau đó vòng lặp chạy đạt đến lần đánh dấu tiếp theo.

Nếu tôi có thể đảm bảo rằng tất cả những điều này xảy ra trên diễn viên chính, tôi có thể đảm bảo đơn đặt hàng này.

Trước Swift 5.5, tôi có thể đã gửi trở lại hàng đợi chính để cập nhật trạng thái của mình, nhưng bây giờ nó dễ dàng hơn nhiều.

Chỉ cần sử dụng chờ đợi!

Bằng cách sử dụng await để thực hiện cuộc gọi không đồng bộ từ diễn viên chính, tôi để công việc khác tiếp tục trên diễn viên chính trong khi công việc không đồng bộ xảy ra.

Điều này được gọi là "năng suất" diễn viên chính.

Trong updateItems, tôi có thể sử dụng await để đưa diễn viên chính trở lại SwiftUI trong I/O chạy dài của mình, vì vậy nó có thể giữ cho vòng lặp chạy tích tắc và tránh bất kỳ trở ngại nào của giao diện người dùng.

Khi công việc không đồng bộ hoàn tất, Swift sẽ nhập lại phương thức updateItems của tôi trở lại diễn viên chính, vì vậy tôi có thể cập nhật trạng thái của mình.

Hãy xem cái này hoạt động như thế nào.

Thay vì gửi đến một hàng đợi khác, tôi chỉ đơn giản là chờ đợi kết quả của hoạt động kéo dài.

Khi tôi viết await, hàm updateItems mang lại quyền kiểm soát của diễn viên chính để vòng lặp chạy có thể tiếp tục.

Khi quá trình tìm nạp đang chờ hoàn tất, diễn viên chính sẽ nhập lại chức năng của tôi, để tôi có thể cập nhật tài sản đã xuất bản của mình một cách an toàn, kích hoạt objectWillChange và cung cấp giá trị mới cho SwiftUI.

Hãy nhảy vào Xcode và xem liệu tôi có thể thực hiện việc tìm nạp hay không.

Đây là phương thức updateItems mà tôi đã trình bày trên các trang trình bày.

Để triển khai fetchPhotos, hãy bắt đầu bằng cách thêm mã để tìm nạp một bức ảnh duy nhất.

Tôi sẽ làm cho phương thức fetchPhoto của mình lấy URL của ảnh từ điểm cuối còn lại và trả về SpacePhoto.

Tiếp theo, tôi sẽ sử dụng phiên bản không đồng bộ mới của sự tiện lợi dữ liệu trên URLSession để tìm nạp dữ liệu từ URL.

Để đưa ra điều này, tôi đang sử dụng một lần thử bắt buộc.

Tôi sẽ dọn dẹp nó trong thời gian ngắn.

À, phương thức dữ liệu không đồng bộ, vì vậy tôi cần sử dụng await.

Và điều đó có nghĩa là tôi cần làm cho phương thức fetchPhoto của mình không đồng bộ.

Được rồi, tuyệt vời.

Bây giờ tôi đã có dữ liệu của mình, tôi sẽ sử dụng trình khởi tạo Decodable để khởi tạo ảnh và trả lại nó.

Hãy xem xét fetchPhotos tiếp theo.

Tôi đã viết một số mã để có được một lựa chọn ngẫu nhiên về ngày tháng và lặp lại chúng.

Tôi muốn xây dựng một mảng, vì vậy tôi sẽ tạo "tải xuống" một var và thêm một biến ngày vào vòng lặp của mình.

Bên trong vòng lặp, tôi sẽ gọi một phương thức trợ giúp mà tôi đã phải xây dựng URL điểm cuối còn lại để tìm nạp một ngày cụ thể.

Sau đó, tôi sẽ gọi phương thức fetchPhoto của mình và nối thêm kết quả vào mảng của tôi.

Và hãy xây dựng.

Ah, bởi vì fetchPhoto không đồng bộ, tôi cần chờ kết quả.

Và điều đó có nghĩa là fetchPhotos cũng cần phải không đồng bộ.

Tôi đang thực hiện các cuộc gọi này để tìm nạp Ảnh tuần tự để đơn giản.

Kiểm tra các nhóm nhiệm vụ của Swift 5.5 để biết các tùy chọn mạnh mẽ hơn nữa.

Bây giờ, tôi chỉ cần đợi tìm nạp Ảnh như tôi đã hiển thị trong các trang trình bày.

Và với điều đó, logic cập nhật của tôi đã được áp dụng.

Bây giờ, có lẽ bạn cũng lo lắng như tôi bởi những nỗ lực bắt buộc này để thực hiện việc tìm nạp.

Hãy dọn dẹp nó đi.

Hiện tại, tôi sẽ trả lại nil khi quá trình tải xuống không thành công.

Sau đó, trong fetchPhotos, tôi sẽ chỉ thêm các giá trị non-nil vào mảng của mình.

Bây giờ Photos sử dụng async-await, tôi có thể chắc chắn rằng nó sẽ không gặp phải bất kỳ lỗi thay đổi đối tượng phức tạp nào mà tôi đã thảo luận, miễn là nó chạy trên diễn viên chính.

Nhưng làm thế nào tôi có thể đảm bảo điều đó?

May mắn thay, trình biên dịch Swift có thể giúp tôi ở đây.

Bằng cách thêm chú thích @MainActor mới vào Ảnh, trình biên dịch sẽ đảm bảo rằng các thuộc tính và phương thức trên Ảnh chỉ được truy cập từ tác nhân chính.

Với điều đó đã hoàn thành, mô hình đã sẵn sàng.

Tiếp theo, Jessica sẽ kết nối quan điểm của chúng tôi với mô hình và hiển thị cho bạn một số API SwiftUI mới tuyệt vời để tận dụng tính đồng thời trong các ứng dụng của bạn.

Jessica?

Cảm ơn bạn, Curt.

Hãy chuyển sang CatalogView và sử dụng phương thức updateItems mà Curt vừa chỉ cho chúng ta.

Tôi muốn gọi updateItems bất cứ khi nào Danh mục của tôi hiển thị.

Trước đây, bạn có thể đã sử dụng onAppear cho việc này, nhưng bắt đầu từ năm nay trong SwiftUI, hãy sử dụng công cụ sửa đổi tác vụ.

Nhiệm vụ cho phép bạn liên kết một nhiệm vụ không đồng bộ với chế độ xem của mình.

Nhiệm vụ bắt đầu từ đầu cuộc đời của quan điểm.

Nhiệm vụ được đồng bộ theo mặc định, vì vậy bên trong phần đóng của nó, tôi có thể gọi updateItems trên đối tượng myPhotos và chờ kết quả.

Đây là một cách sử dụng nhiệm vụ tuyệt vời, nhưng thậm chí còn có nhiều hơn cho công cụ sửa đổi mới này.

Tuổi thọ của một nhiệm vụ gắn liền với vòng đời của chế độ xem, vì vậy bạn có thể làm những việc như chờ đợi trên một chuỗi không đồng bộ và phản hồi các giá trị của nó.

Và nhiệm vụ sẽ tự động bị hủy khi thời gian tồn tại của chế độ xem kết thúc.

Để biết thêm về thời gian xem trọn đời, hãy chắc chắn xem bài nói chuyện "Demystify SwiftUI." Sử dụng bản xem trước trực tiếp, tôi có thể thấy rằng các mục nhập đã được cập nhật.

Nhưng chúng tôi vẫn đang thiếu những hình ảnh đẹp.

Tôi đã cập nhật PhotoView mà Curt đã hiển thị trước đó.

Tôi sẽ thêm một số tài liệu cơ bản đằng sau tiêu đề.

Bây giờ, hãy thêm các hình ảnh.

May mắn thay, sử dụng API AsyncImage mới, tải hình ảnh từ máy chủ từ xa dễ dàng hơn bao giờ hết.

Tất cả những gì tôi phải làm là lấy URL hình ảnh mà tôi muốn lấy ra khỏi mục nhập của chúng tôi và chuyển nó đến AsyncImage.

Chà, cái này hơi quá lớn ở kích thước đầy đủ của nó, vì vậy hãy sử dụng quá tải của AsyncImage cho phép tôi điều chỉnh hình ảnh và hiển thị trình giữ chỗ để người dùng biết hình ảnh của họ đang tải.

Tiếp theo, tôi sẽ làm cho hình ảnh có thể thay đổi kích thước và đặt tỷ lệ khung hình của nó để lấp đầy khoảng trống.

Cuối cùng, tôi sẽ thêm chiều rộng và chiều cao tối thiểu để làm cho hình ảnh của tôi linh hoạt.

Sử dụng chiều cao tối thiểu khác 0 cũng sẽ đảm bảo rằng chế độ xem tiến trình ló ra khu vực tiêu đề của tôi.

Giống như phần còn lại của SwiftUI, AsyncImage được xây dựng với các mặc định thông minh, vì vậy ngay cả khi có lỗi khi tải hình ảnh của bạn, kết quả sẽ là tiếp tục hiển thị trình giữ chỗ.

Bạn cũng có thể chọn tùy chỉnh hành vi xử lý lỗi.

Để làm điều đó, hãy xem "Quá tải của AsyncImage sử dụng một pha." Sẽ thật tuyệt nếu người dùng có thể lưu những hình ảnh yêu thích của họ để xem sau.

Hãy thêm một nút vào khu vực tiêu đề này để làm điều đó.

Nút sẽ kích hoạt một hành động không đồng bộ để lưu mục nhập hình ảnh vào đĩa.

Các mục đã lưu sẽ xuất hiện trong tab Đã lưu trong ứng dụng của chúng tôi.

Tôi đã bối rối trước việc làm điều này.

Hãy để tôi thêm nó vào đây, sau đó chúng ta có thể xem mã của nó.

Đây là phiên bản bị bỏ qua của nút Lưu của tôi.

Hãy thêm một hành động để lưu ảnh.

Các hành động của nút trong SwiftUI là đồng bộ, nhưng phương thức "lưu" của tôi không đồng bộ.

Để gọi phương thức, tôi sẽ bắt đầu một nhiệm vụ không đồng bộ.

Sau đó, bên trong phần đóng, tôi sẽ gọi phương thức "lưu" trên "ảnh". Nó không đồng bộ, vì vậy tôi sẽ chỉ sử dụng chờ đợi.

Tôi nghĩ sẽ rất tuyệt nếu hiển thị chế độ xem tiến độ trong khi việc lưu đang diễn ra.

Để làm điều đó, tôi sẽ thêm một tài sản Nhà nước.

Sau đó, tôi sẽ cập nhật Trạng thái xung quanh cuộc gọi của mình để lưu.

Sau đó, tôi sẽ cập nhật nhãn trên nút của mình để hiển thị chế độ xem tiến trình khi quá trình lưu đang diễn ra.

Tôi đang sử dụng "độ mờ" để ẩn nhãn Lưu và lớp phủ để hiển thị chế độ xem tiến trình.

Sự kết hợp này đảm bảo rằng nút vẫn giữ nguyên kích thước, dựa trên bản địa hóa của từ "lưu". Cuối cùng, tôi sẽ vô hiệu hóa nút trong khi lưu đang diễn ra.

Hãy xem điều này hoạt động như thế nào với bản xem trước trực tiếp.

Điều đó khá tuyệt!

Hãy quay lại chế độ xem Danh mục để ghép tất cả lại với nhau.

SwiftUI có một công cụ sửa đổi mới tuyệt vời trong năm nay mà bạn có thể sử dụng để cung cấp cho mọi người khả năng làm mới dữ liệu của họ theo cách thủ công.

Bằng cách thêm công cụ sửa đổi có thể làm mới vào Danh sách của tôi, tôi nói với SwiftUI rằng nội dung này có thể làm mới được.

Tôi có thể cung cấp một đóng cửa không đồng bộ để làm mới và gọi phương thức updateItems của chúng tôi để cập nhật Danh sách.

Như tôi đã chỉ ra trước đó với "nhiệm vụ", tôi sẽ sử dụng await trên phương pháp không đồng bộ này.

Chỉ báo làm mới sẽ tự động loại bỏ khi công việc không đồng bộ của tôi hoàn tất.

Bây giờ, tôi có thể kéo xuống để làm mới hình ảnh của mình, nhấn Lưu để lưu hình ảnh tôi thích và chuyển sang tab Đã lưu để xem hình ảnh đã lưu của tôi.

Các tính năng mới của Swift giúp dễ dàng làm việc với dữ liệu đồng thời.

SwiftUI tích hợp độc đáo với các tính năng đồng thời của Swift để cung cấp cho bạn hành vi tốt nhất theo mặc định.

Trong nhiều trường hợp, bạn chỉ cần sử dụng await để tận dụng sức mạnh của sự đồng thời.

Đánh dấu ObservableObject của bạn là “@MainActor” để kiểm tra mạnh mẽ hơn rằng đối tượng của bạn có cập nhật theo những cách phù hợp với quan điểm của bạn hay không.

Tận dụng các bổ sung API của SwiftUI để viết các ứng dụng đồng thời an toàn và hiệu quả với nỗ lực tối thiểu.

Sử dụng AsyncImage để tải đồng thời hình ảnh.

Thêm công cụ sửa đổi "có thể làm mới" vào hệ thống phân cấp chế độ xem của bạn để cho phép người dùng làm mới dữ liệu của họ theo cách thủ công.

Như chúng ta đã thấy với nút Lưu, bạn có thể sử dụng các tính năng đồng thời mới của Swift trong chế độ xem tùy chỉnh của riêng bạn.

Như chúng ta đều biết, đồng thời rất khó khăn.

Đó là một vấn đề khó khăn, nhưng với các tính năng ngôn ngữ mới này và SwiftUI APIs, giờ đây bạn đã có các công cụ để quản lý sự phức tạp đó trong các ứng dụng của mình.

Chúng tôi hy vọng bạn thích tìm hiểu về các công cụ đồng thời mới tuyệt vời trong Swift 5.5 và SwiftUI, và chúng tôi mong muốn được xem tất cả các cách bạn sử dụng chúng để giải quyết các vấn đề phức tạp trong ứng dụng của mình.

[Âm nhạc].