10074

♪ ♪

Xin chào. Tôi là Amanda, và tôi sẽ được tham gia một chút bởi đồng nghiệp của tôi, Olivier.

Trong buổi nói chuyện này, chúng ta sẽ khám phá các tính năng mà chúng ta đã thêm vào RealityKit vào năm 2021.

RealityKit là một khung tác giả thực tế tăng cường được giới thiệu vào năm 2019 tập trung vào kết xuất thực tế và giúp dễ dàng tạo các ứng dụng AR.

Tận dụng ARKit để đọc dữ liệu cảm biến của thiết bị, RealityKit cho phép bạn đặt nội dung 3D trong môi trường thế giới thực và làm cho nội dung đó trông chân thực nhất có thể.

Dưới đây là một số ví dụ tuyệt vời về trải nghiệm RealityKit trong hành động.

Đi săn xác thối trong thế giới thực, ném bóng hầu như chống lại bạn bè của bạn, thậm chí trở thành một tác phẩm điêu khắc trong bảo tàng và tìm thấy một số con bọ đầy màu sắc.

Trong vài năm qua, chúng tôi đã thấy một số ứng dụng tuyệt vời được tạo bằng RealityKit và nhận được phản hồi thực sự tốt để làm cho khuôn khổ này thậm chí còn tốt hơn.

Và chúng tôi đã lắng nghe phản hồi của bạn.

Chúng tôi rất vui khi chia sẻ rằng RealityKit 2 giới thiệu một loạt các tính năng mới để giúp bạn tạo ra các ứng dụng và trò chơi AR nhập vai hơn nữa.

Trong phiên này, chúng tôi sẽ làm nổi bật một số trong số chúng, bao gồm các tính năng được yêu cầu nhiều nhất của chúng tôi, như đổ bóng và vật liệu tùy chỉnh, hệ thống tùy chỉnh và khái niệm bộ điều khiển ký tự mới của chúng tôi.

Vì vậy, hãy đeo mặt nạ ống thở của bạn và đi sâu vào.

Khi tôi lớn lên ở Trung Đông, tôi đã học lặn biển ở vùng Vịnh.

Mặc dù tôi không được đội một trong những chiếc mũ bảo hiểm steampunk siêu dễ thương này, nhưng tôi thích nhìn thấy tất cả các trường học về cá đầy màu sắc.

Tôi nghĩ sẽ rất thú vị khi tạo lại sự rung cảm dưới nước ngay tại đây trong phòng khách của tôi.

Olivier và tôi đã viết bản demo này bằng cách sử dụng một loạt các tính năng mà chúng tôi sẽ giới thiệu cho bạn trong phiên này và trong phiên RealityKit thứ hai của chúng tôi vào cuối tuần này.

Chúng tôi đã xử lý hậu kỳ để tạo ra hiệu ứng sương mù sâu và chất ăn da nước, một công cụ sửa đổi hình học tùy chỉnh để làm cho rong biển nhảy múa trên sóng và nhiều hơn nữa.

Về cơ bản, RealityKit 2 cho phép bạn tùy chỉnh rất nhiều thứ ngay bây giờ.

Mã mẫu này có sẵn để bạn dùng thử tại developer.apple.com.

Có năm chủ đề chính mà chúng ta sẽ đề cập hôm nay.

Chúng tôi sẽ tóm tắt lại ECS là gì và cách chúng tôi sử dụng tính năng hệ thống tùy chỉnh mới của mình để thực hiện hành vi đánh bắt cá trong ứng dụng của chúng tôi.

Chúng tôi sẽ cho bạn thấy những tiến bộ trong những gì bạn có thể làm với vật liệu cũng như hình ảnh động, bộ điều khiển nhân vật mới, đó là cách chúng tôi khiến thợ lặn tương tác liền mạch với lưới AR của phòng khách và cách bạn có thể tạo tài nguyên trong thời gian chạy.

Vậy hãy bắt đầu với ECS.

ECS, viết tắt của hệ thống thành phần thực thể, là một cách cấu trúc dữ liệu và hành vi, và nó thường được sử dụng trong các trò chơi và mô phỏng.

Nó khác với lập trình hướng đối tượng, trong đó bạn có xu hướng mô hình hóa một mục như một gói đóng gói của cả chức năng của nó và trạng thái được liên kết với mục đó.

Nhưng với ECS, bạn có ba ngạnh: thực thể, thành phần và hệ thống, nơi chức năng đi vào hệ thống, trạng thái đi vào các thành phần và thực thể là số nhận dạng cho một nhóm các thành phần.

Năm nay, với RealityKit 2, chúng tôi đang hướng tới việc triển khai ECS thuần túy hơn, hướng dẫn bạn giữ nhiều chức năng hơn trong lớp hệ thống với các hệ thống tùy chỉnh mới của chúng tôi.

Thực thể có ý nghĩa gì với chúng ta?

Một thực thể đại diện cho một điều trong khung cảnh của bạn.

Đây là những thực thể đại diện cho các sinh vật biển trong khung cảnh của chúng ta.

Một thực thể có thể có các thực thể con, cung cấp cho bạn một cấu trúc đồ thị để làm việc.

Ví dụ, thành phần biến đổi sử dụng biến đổi của thực thể mẹ để thêm vị trí riêng của nó vào.

Bản thân một thực thể không hiển thị bất cứ thứ gì trên màn hình.

Đối với điều đó, bạn cần cung cấp cho nó một thành phần mô hình hoặc tạo một thực thể mô hình, điều này sẽ làm điều đó cho bạn.

Để thêm các thuộc tính, thuộc tính và hành vi, bạn thêm các thành phần vào thực thể của mình.

Nói về điều đó, hãy nói về các thành phần.

Các thành phần dùng để lưu trữ trạng thái giữa các khung và để đánh dấu sự tham gia của một thực thể vào một hệ thống.

Tuy nhiên, bạn không cần phải bao gồm bất kỳ logic nào để xử lý trạng thái đó ở đây.

Logic và hành vi của bạn đi vào hệ thống tùy chỉnh của bạn.

Có một số thành phần sẽ có mặt trên bất kỳ thực thể nào bạn tạo.

Không được hiển thị ở đây là các thành phần tích hợp sẵn: các thành phần chuyển đổi và đồng bộ hóa.

Họ ở trên cả ba thực thể này.

Có những thứ khác mà bạn thường muốn thêm vào, như thành phần mô hình, chứa lưới và vật liệu làm cho thực thể của bạn hiển thị trên màn hình.

Bạn cũng có thể thêm và xóa các thành phần khỏi các thực thể của mình trong thời gian chạy, nếu bạn muốn tự động thay đổi hành vi của chúng.

Chúng tôi sẽ đánh dấu con cá đầu tiên này là tham gia vào Hệ thống đổ xô và chúng tôi sẽ nói với nó rằng nó thích ăn tảo.

Con cá thứ hai này, nó cũng sẽ đổ đàn với con cá đầu tiên, nhưng nó thích ăn sinh vật phù du hơn ngay bây giờ.

Anh chàng thứ ba này là một sinh vật phù du.

Nó sẽ là thức ăn cho con cá thứ hai.

Nó nên xem lại, bởi vì trong ứng dụng của chúng tôi, chúng tôi có một số sinh vật đói.

Chúng tôi biết những người nào đang đói vì chúng có các thành phần AlgaeEater hoặc PlanktonEater trên đó.

Mỗi khung hình, Hệ thống Ăn uống của chúng tôi đều có chức năng cập nhật được gọi.

Ở đây, nó tìm thấy tất cả các thực thể trong cảnh có một trong hai thành phần này, cộng với tất cả các thực thể là thức ăn, vì vậy nó có thể hướng dẫn cá đói về phía thức ăn mà chúng thích ăn.

Nhưng cách hiệu quả để Hệ thống Ăn uống tìm ra thực thể nào đang đói, thực thể nào là thực phẩm và thực thể nào không?

Chúng tôi không muốn phải đi qua biểu đồ thực thể của mình và kiểm tra các thành phần của từng thành phần.

Thay vào đó, chúng tôi thực hiện một truy vấn thực thể.

Hãy để RealityKit làm sổ sách kế toán cho bạn.

Hệ thống Flocking muốn tìm tất cả các thực thể có FlockingComponent trên đó.

Trong khi Hệ thống Ăn uống muốn cả hai loại thực thể đói, cộng với thực thể đó là một loại thực phẩm.

Vì vậy, chúng ta hãy xem xét kỹ hơn chính xác những gì đang xảy ra khi một hệ thống sử dụng một truy vấn thực thể.

Các hệ thống có chức năng cập nhật của chúng được gọi là mọi khung hình.

Hãy xem xét Hệ thống đổ xô cho cá Tang vàng của chúng ta.

Chúng tôi sẽ tạm dừng ở khung hình này để xem chuyện gì đang xảy ra.

Trong chức năng cập nhật của Hệ thống Flocking, chúng tôi truy vấn tất cả các thực thể trong cảnh có cả FlockingComponent và MotionComponent trên đó.

Rất nhiều thứ có MotionComponent, nhưng chúng tôi không muốn tất cả chúng, chúng tôi chỉ muốn đàn của mình.

Truy vấn của chúng tôi trả về cá đàn của chúng tôi, vì vậy bây giờ chúng tôi có thể điều khiển vật lý trò chơi tùy chỉnh của mình bằng cách áp dụng mô phỏng Boids cổ điển cho từng con cá trong đàn.

Chúng tôi thêm lực lên MotionComponent của mỗi con cá, nơi chúng tôi giữ trạng thái giữa các khung hình, lực dính vào nhau, thích cách nhau một khoảng cách nhất định và cố gắng hướng mũi của chúng theo cùng một hướng.

Khi Hệ thống chuyển động chạy, trong cùng một khung hình nhưng sau khi Hệ thống đổ xô chạy, nó cuộn tất cả các lực này lại để quyết định gia tốc, vận tốc và vị trí mới của cá.

Nó không quan tâm hệ thống nào khác đã thêm chúng.

Có những người khác, như Hệ thống Ăn uống và Hệ thống Sợ hãi cũng hoạt động trên MotionComponent để đẩy cá theo nhiều hướng khác nhau.

Vậy hãy xem mã.

Đây là phác thảo về Hệ thống đổ xô của chúng tôi.

Đó là một lớp phù hợp với giao thức RealityKit.System.

Khi bạn đăng ký hệ thống tùy chỉnh của mình tại thời điểm khởi chạy ứng dụng, bạn đang nói với công cụ rằng bạn muốn nó khởi tạo một trong những loại này cho mỗi cảnh trong ứng dụng của bạn.

Init là bắt buộc, và bạn cũng có thể cung cấp một thiết kế.

Chúng tôi có thể chỉ định các phụ thuộc.

Hệ thống này phải luôn chạy trước MotionSystem, đó là lý do tại sao chúng tôi đã sử dụng giá trị liệt kê.trước đây.

Trong chức năng cập nhật của chúng tôi, chúng tôi sẽ thay đổi trạng thái được lưu trữ trong MotionComponent và MotionSystem sẽ hoạt động theo trạng thái mà chúng tôi cung cấp, vì vậy chúng tôi cần đảm bảo FlockingSystem chạy trước MotionSystem, giống như mối quan hệ giữa nhà sản xuất và người tiêu dùng.

Bạn cũng có thể sử dụng tùy chọn .after.

Nếu bạn không chỉ định các phụ thuộc, các chức năng cập nhật hệ thống của bạn sẽ được thực hiện theo thứ tự bạn đã đăng ký chúng.

EntityQuery của chúng tôi nói rằng chúng tôi muốn tất cả các thực thể có Thành phần Flocking và Motion.

Đó là một phép tĩnh vì nó sẽ không thay đổi trong suốt thời gian mô phỏng của chúng tôi.

Trong trải nghiệm AR nhiều người chơi, các thành phần phù hợp với mã hóa được tự động đồng bộ hóa qua mạng.

Tuy nhiên, dữ liệu trong hệ thống không được tự động đồng bộ hóa qua mạng.

Dữ liệu thường nên được lưu trữ trong các thành phần.

Bây giờ chúng ta hãy đi sâu vào chức năng cập nhật của FlockingSystem của chúng ta.

Nó cần một SceneUpdateContext, trong đó có deltaTime cho khung đó và một tham chiếu đến chính cảnh đó.

Đầu tiên, chúng tôi thực hiện EntityQuery của mình trên hiện trường, trả về kết quả truy vấn mà chúng tôi có thể lặp lại cho các thực thể có FlockingComponent trên đó.

Chúng tôi nhận được MotionComponent của mỗi người, mà chúng tôi sẽ sửa đổi.

Tại sao chúng ta không nhận được FlockingComponent?

Bởi vì nó không có bất kỳ dữ liệu nào liên quan đến nó.

Chúng tôi sử dụng cái đó như một thẻ để biểu thị tư cách thành viên trong đàn.

Sau đó, chúng tôi chạy mô phỏng Boids tiêu chuẩn của mình trên chúng để hướng dẫn đàn, sửa đổi tập hợp lực trong MotionComponent.

Cuối cùng, vì chúng tôi đã thêm lực cho mỗi con cá để đẩy nó theo hướng mong muốn và bởi vì các thành phần là cấu trúc Swift là các loại giá trị, chúng tôi cần lưu trữ MotionComponent của mình trở lại thực thể mà nó đến từ.

Các hệ thống không cần phải thực hiện chức năng cập nhật tùy chỉnh.

Nó cũng có thể hữu ích để tạo ra một hệ thống chỉ cung cấp một init, như đăng ký trình xử lý sự kiện cho các sự kiện cảnh.

Cho đến nay, chúng tôi đã xem xét các mối quan hệ giữa các thực thể, thành phần và hệ thống tùy chỉnh.

Bây giờ hãy thu nhỏ một chút và nói về một số thay đổi kiến trúc cấp cao mà chúng tôi đã mang đến trong RealityKit 2.

Trước đây, bạn sẽ đăng ký sự kiện SceneEvents.update bằng cách sử dụng đóng cửa sẽ được gọi là mọi khung hình.

Những loại người xử lý sự kiện này thường sẽ sống, hoặc ít nhất là được đăng ký vào, các lớp học giống như Trình quản lý trò chơi của bạn.

Thay vì đóng cửa như vậy, giờ đây bạn có thể tách logic cập nhật của mình một cách rõ ràng và được đặt hàng chính thức trong các chức năng cập nhật hệ thống riêng biệt.

Vì vậy, điều đó có nghĩa là Người quản lý trò chơi của bạn có thể đóng ít vai trò hơn.

Thay vì thực hiện tất cả các đăng ký của bạn để cập nhật sự kiện ở đó và sau đó quản lý thứ tự mà bạn gọi cập nhật tất cả mọi thứ trong trò chơi của mình, bây giờ Người quản lý trò chơi chỉ phải thêm các thành phần vào các thực thể để biểu thị cho hệ thống của bạn rằng các thực thể đó nên được đưa vào các truy vấn của họ.

Trước đây, bạn sẽ khai báo sự phù hợp giao thức trên các lớp con thực thể của mình để thể hiện rằng loại thực thể đó có các thành phần nhất định.

Bây giờ bạn không cần phải phân lớp thực thể nữa, vì nó cũng có thể đóng ít vai trò hơn.

Nó có thể chỉ đơn thuần là một mã định danh cho một đối tượng và các thuộc tính của nó có thể được mô hình hóa như các thành phần.

Bởi vì khi bạn không thực thể lớp con, bạn không ràng buộc đối tượng của mình mãi mãi giữ các thành phần đó.

Bạn có thể tự do thêm và xóa các thành phần trong quá trình trải nghiệm.

Vì vậy, với RealityKit 2, các thành phần tùy chỉnh của bạn hữu ích hơn rất nhiều vì bạn có các hệ thống tùy chỉnh.

Nhưng bạn vẫn có thể làm điều đó theo cách nào đó.

Đó là vẻ đẹp của sự phát triển trò chơi.

Thế giới là con hàu của bạn.

Trong bản demo dưới nước của chúng tôi, chúng tôi đang sử dụng cả hai phương pháp.

Chúng tôi cũng đã thêm một loại thành phần mới: TransientComponent.

Giả sử, ví dụ, cá của bạn sợ bạch tuộc, nhưng chỉ khi chúng đã từng nhìn vào nó.

Khi bạn nhân bản một thực thể cá mới, bạn có thể không muốn bản sao thừa hưởng nỗi sợ bạch tuộc của con cá đó.

Bạn có thể làm cho FearComponent của mình phù hợp với TransientComponent.

Bằng cách đó, nó sẽ không có mặt trên thực thể mới.

Tuy nhiên, TransientComponent vẫn được bao gồm trong đồng bộ hóa mạng, nếu nó phù hợp với mã hóa, giống như bất kỳ loại thành phần nào khác làm như vậy.

Một bổ sung khác là tiện ích mở rộng mới của chúng tôi trên cancellable.

Bạn không cần phải quản lý thủ công việc hủy đăng ký các sự kiện cho một thực thể nữa.

Chúng tôi sẽ làm điều đó cho bạn khi bạn sử dụng storeWhileEntityActive.

Ở đây, chúng tôi đang xử lý các sự kiện va chạm cho một thực thể cá.

Chúng tôi không cần đăng ký này để tồn tại lâu hơn chính con cá, vì vậy chúng tôi sử dụng storeWhileEntityActive.

Như mọi khi, khi xây dựng một trò chơi, có rất nhiều cài đặt mà bạn muốn điều chỉnh nhanh chóng mà không cần phải biên dịch lại.

Trong trò chơi của chúng tôi, chúng tôi đã xây dựng chế độ xem Cài đặt trong SwiftUI và chúng tôi chuyển mô hình sao lưu của nó xuống các Hệ thống Tùy chỉnh khác nhau của mình bằng cách gói chúng trong CustomComponents.

Chúng tôi tạo phiên bản Cài đặt của mình dưới dạng @StateObject và chuyển nó vào cả chế độ xem ARViewContainer và SwiftUI của chúng tôi dưới dạng environmentObject.

Chúng tôi bọc đối tượng Cài đặt trong một Thành phần Tùy chỉnh, một Thành phần Cài đặt.

Sau đó, khi chúng tôi tạo thực thể cá của mình, chúng tôi cung cấp cho nó một Thành phần Cài đặt.

Bằng cách đó, khi bất kỳ Hệ thống Tùy chỉnh nào xuất hiện muốn các cài đặt đó, nó có thể đọc chúng từ đó, như lấy giá trị "tốc độ tối đa" và sử dụng nó để giới hạn vận tốc của mỗi con cá.

Và bây giờ tôi sẽ giao nó cho đồng nghiệp của tôi, Olivier, để nói với bạn về tài liệu.

Cảm ơn, Amanda.

Năm nay, chúng tôi đã thêm các API mới cho các tài liệu.

Chúng tôi đã có một vài loại, chẳng hạn như SimpleMaterial, với màu cơ bản, độ nhám và đặc tính kim loại.

Chúng tôi cũng có UnlitMaterial, chỉ với một màu và không có ánh sáng.

Chúng tôi đã có OcclusionMaterials, có thể được sử dụng như một mặt nạ để ẩn các đối tượng ảo.

Và năm ngoái, chúng tôi đã giới thiệu VideoMaterials, đó là UnlitMaterials sử dụng video làm màu của chúng.

Lưu ý rằng năm nay chúng tôi đã thêm hỗ trợ cho sự minh bạch.

Nếu tệp video chứa độ trong suốt, nó sẽ được sử dụng để hiển thị đối tượng.

Năm nay, chúng tôi đã thêm các API mới cung cấp cho bạn quyền kiểm soát vật liệu nâng cao hơn, bắt đầu với loại Vật liệu dựa trên vật lý, rất giống với lược đồ cho vật liệu bằng USD.

Nó là một siêu tập hợp của SimpleMaterial và có hầu hết các thuộc tính PBR tiêu chuẩn mà bạn có thể tìm thấy trong các trình kết xuất khác.

Đây là tài liệu mà bạn sẽ tìm thấy trên các thực thể đã được nạp từ một USD.

Ví dụ, bạn có thể nạp USD của cá hề và sau đó sửa đổi các thuộc tính riêng lẻ trên vật liệu của nó để làm cho nó thành vàng hoặc tím.

Trong số các thuộc tính của vật liệu, ví dụ, bạn có thể thay đổi bản đồ bình thường để thêm các chi tiết nhỏ không phải là một phần của lưới.

Bạn cũng có thể chỉ định một kết cấu xác định độ trong suốt của mô hình.

Theo mặc định, độ trong suốt đang sử dụng pha trộn alpha, nhưng nếu bạn cũng chỉ định ngưỡng mờ, tất cả các đoạn dưới ngưỡng đó sẽ bị loại bỏ.

Bạn có thể thiết lập kết cấu cho sự tắc nghẽn môi trường xung quanh, xác định các bóng mờ trong mô hình.

Và một ví dụ về đặc tính tiên tiến hơn là lớp phủ trong suốt, sẽ mô phỏng một lớp sơn phản chiếu bổ sung trên vật liệu.

Và có nhiều thuộc tính khác có sẵn trên loại Vật liệu dựa trên vật lý.

Chúng tôi cũng đã thêm một loại mới gọi là vật liệu tùy chỉnh để tạo ra vật liệu bằng mã kim loại của riêng bạn.

Đây là những gì chúng tôi đã sử dụng để tạo hiệu ứng chuyển đổi màu sắc trên mô hình bạch tuộc này.

Chúng tôi sẽ giải thích bộ đổ bóng này và các tài liệu tùy chỉnh trong buổi nói chuyện thứ hai về kết xuất.

Ngoài các tài liệu, chúng tôi cũng đã thêm nhiều quyền kiểm soát hơn đối với hoạt ảnh trong RealityKit.

Đầu tiên, hãy xem qua API hiện có cho hoạt ảnh, chủ yếu là về việc phát lại hoạt ảnh được tải từ USD.

Nếu bạn tải một hình ảnh động từ một USD, bạn có thể chơi nó một lần.

Bạn cũng có thể lặp lại nó để nó lặp lại vô hạn, đó là những gì chúng tôi muốn cho hoạt hình nhàn rỗi của thợ lặn của chúng tôi ở đây.

Bạn cũng có thể tạm dừng, tiếp tục và dừng hoạt ảnh.

Cuối cùng, khi phát một hình ảnh động mới, bạn có thể chỉ định thời lượng chuyển tiếp.

Nếu bạn không chỉ định một cái, nhân vật sẽ ngay lập tức chuyển sang hình ảnh động mới.

Nếu bạn chỉ định thời lượng chuyển tiếp, RealityKit sẽ pha trộn giữa hoạt ảnh cũ và mới trong thời gian đó.

Điều này rất hữu ích, ví dụ, khi chuyển đổi giữa chu kỳ Đi bộ và Nhàn rỗi của thợ lặn.

Nhưng chúng ta vẫn có thể cải thiện hình ảnh động của bàn chân ở đó.

Chúng ta có thể sử dụng API mới cho các lớp pha trộn để làm cho hình ảnh động chân thực hơn.

Chúng tôi phát hoạt hình Đi bộ và hoạt hình nhàn rỗi trên hai lớp pha trộn riêng biệt, và vì chúng tôi đã phát hoạt hình Đi bộ ở lớp trên cùng, đó là hoạt hình duy nhất mà chúng tôi hiện đang thấy.

Nhưng chúng ta có thể thay đổi yếu tố pha trộn của hoạt ảnh Đi bộ để tiết lộ hoạt hình Nhàn rỗi bên dưới.

Chú ý làm thế nào, khi yếu tố pha trộn trở nên nhỏ hơn, bước chân cũng trở nên nhỏ hơn.

Và chúng ta cũng có thể thay đổi tốc độ phát lại của hình ảnh động để làm cho thợ lặn đi nhanh hơn hoặc chậm hơn.

Ở đây, thợ lặn đang đi bộ với tốc độ một nửa.

Cuối cùng, chúng tôi sử dụng tốc độ của ký tự so với mặt đất để kiểm soát cả hai giá trị này.

Bằng cách này, chúng ta có thể làm cho hình ảnh động mượt mà hơn và giảm độ trượt của bàn chân so với mặt đất.

Cho đến nay, chúng tôi đã sử dụng nhiều clip hoạt hình, chẳng hạn như chu kỳ Nhàn rỗi và Đi bộ.

Chúng được lưu trữ dưới dạng Tài nguyên Hoạt hình trong RealityKit.

Và có nhiều cách để tải chúng từ các tệp USD.

Cách đầu tiên là có một tệp USD cho mỗi clip.

Chúng ta có thể tải mỗi USD như một thực thể và nhận hoạt ảnh của nó dưới dạng AnimationResources.

AnimationResource sau đó có thể được phát trên bất kỳ thực thể nào, miễn là tên của các khớp trong bộ xương của nó khớp với hoạt hình.

Một cách khác để tải nhiều clip hoạt hình là có chúng trong một USD duy nhất trên cùng một dòng thời gian và sau đó sử dụng AnimationViews để cắt dòng thời gian này thành nhiều clip.

Điều này đòi hỏi phải biết mã thời gian giữa mỗi clip.

Mỗi AnimationView sau đó có thể được chuyển đổi thành AnimationResource và được sử dụng chính xác giống hệt như phương pháp trước đó.

Bây giờ chúng ta hãy xem qua hình ảnh động của bạch tuộc trong ứng dụng.

Con bạch tuộc đang trốn, nhưng khi người chơi đến gần, nó sẽ sợ hãi và di chuyển đến một nơi ẩn náu mới.

Hãy xem làm thế nào để tạo hiệu ứng động cho nó.

Chúng tôi bắt đầu với việc tải các hình ảnh động xương của bạch tuộc: nhảy, bơi và hạ cánh.

Những hình ảnh động này được tải từ một USD, giống như những gì chúng tôi đã làm cho thợ lặn.

Nhưng chúng tôi cũng muốn làm sinh động sự biến đổi của bạch tuộc để di chuyển nó từ vị trí này sang vị trí khác.

Để tạo hiệu ứng động cho việc chuyển đổi, chúng tôi sử dụng một API mới để tạo một hình ảnh động kiểu FromToByAnimation theo chương trình.

Bằng cách này, chúng ta có thể tạo hiệu ứng động cho vị trí.

Hãy xem nó trông như thế nào trên bạch tuộc.

Để làm cho nó thú vị hơn, chúng ta cũng hãy tạo hiệu ứng động cho vòng quay.

Bạch tuộc bây giờ quay trong khi nó di chuyển, nhưng nó đang bơi sang một bên, điều này không thực tế lắm.

Chúng ta có thể cải thiện điều này bằng cách tạo ra một chuỗi các hình ảnh động.

Đầu tiên, chúng tôi xoay con bạch tuộc về phía vị trí mới.

Sau đó chúng tôi dịch nó sang vị trí mới.

Và cuối cùng, chúng tôi xoay con bạch tuộc trở lại phía máy ảnh.

Và đây là hình ảnh động đầy đủ.

Ngoài các API mới cho hoạt ảnh, chúng tôi cũng đã thêm một cách để quản lý vật lý của các nhân vật.

Nó được gọi là bộ điều khiển nhân vật.

Điều này cho phép chúng tôi tạo ra các nhân vật có thể tương tác vật lý với các máy va chạm trong cảnh.

Ở đây, chúng ta thấy thợ lặn nhảy từ sàn lên đi văng và đi trên đó.

Điều này đạt được bằng cách thêm một bộ điều khiển ký tự vào thợ lặn.

Với điều đó, thợ lặn sẽ tự động tương tác với lưới môi trường, được tạo ra từ cảm biến LiDAR.

Tạo một bộ điều khiển ký tự rất đơn giản.

Tất cả những gì bạn cần làm là xác định một viên nang phù hợp với hình dạng nhân vật của bạn.

Khi sáng tạo, bạn phải chỉ định chiều cao của viên nang và bán kính của nó.

Sau khi bộ điều khiển ký tự đã được gán cho thực thể, bạn có thể gọi hàm di chuyển (đến:) mọi khung hình.

Nó sẽ khiến nhân vật di chuyển đến vị trí mong muốn, nhưng không vượt qua chướng ngại vật.

Mặt khác, nếu bạn muốn bỏ qua chướng ngại vật, bạn có thể sử dụng chức năng dịch chuyển tức thời.

Bây giờ tôi sẽ giao nó cho Amanda, người sẽ đưa bạn qua một vài tính năng thú vị hơn mà chúng tôi đã thêm vào bản phát hành RealityKit này.

Tuyệt vời. Cảm ơn, Olivier.

Được rồi, vì vậy tôi sẽ làm nổi bật hai API mới có sẵn để tạo tài nguyên một cách nhanh chóng mà không cần phải tải chúng từ đĩa.

Đầu tiên tôi sẽ chỉ cho bạn cách bạn có thể lấy lưới khuôn mặt của một người từ SceneUnderstanding, và sau đó tôi sẽ hướng dẫn bạn cách tạo âm thanh.

Có một biển khả năng mà những thứ này mở ra cho nghệ thuật được tạo ra theo thủ tục.

Đầu tiên, lưới mặt.

Tôi đã rất lấy cảm hứng từ vẻ ngoài của bạch tuộc màu tím và cam mà chúng tôi có trong ứng dụng demo của mình, tôi đã thử vẽ một con trên khuôn mặt của mình, nhưng hầu như, sử dụng khả năng lưới mặt mới.

SceneUnderstanding giờ đây có thể cung cấp cho bạn các thực thể đại diện cho khuôn mặt của mọi người và các thực thể đó có ModelComponents trên đó, có nghĩa là bạn có thể hoán đổi các thuộc tính của vật liệu trên lưới của thực thể khuôn mặt.

Chúng tôi đã có rất nhiều niềm vui khi tạo ra các kết cấu để áp dụng cho lưới mặt một cách nhanh chóng với các bản vẽ trực tiếp của chúng tôi.

Hãy nhìn vào mã.

SceneUnderstandingComponent hiện có một thuộc tính enum được gọi là entityType, được thiết lập bởi SceneUnderstandingSystem và có thể lấy một trong hai giá trị: face, có nghĩa là nó đại diện cho khuôn mặt của một người trong thế giới thực, hoặc meshChunk, có nghĩa là nó là một số phần khác của lưới thế giới được tái tạo lại.

Nó cũng có thể là số không, có nghĩa là loại của nó vẫn chưa được biết đến.

Đây là một EntityQuery một lần nữa.

Bạn có thể truy vấn các thực thể có SceneUnderstandingComponent và kiểm tra entityType của chúng để tìm khuôn mặt.

Sau đó, bạn có thể lấy ModelComponents từ các thực thể đó và làm bất cứ điều gì bạn muốn với chúng.

Trong mẫu vẽ mặt của chúng tôi, chúng tôi đang sử dụng PencilKit để cho phép mọi người vẽ trên khung vẽ và sau đó gói CGImage kết quả lên khuôn mặt Entity bằng cách tạo TextureResource từ CGImage đó.

Chúng tôi đang sử dụng Vật liệu dựa trên vật lý để có thể làm cho lớp sơn mặt này trông chân thực nhất có thể và chúng tôi đang thiết lập một vài thuộc tính trên đó để quay số cho giao diện của chúng tôi.

Để tạo hiệu ứng sơn lấp lánh, chúng tôi sử dụng kết cấu bản đồ bình thường cho trình kết xuất dựa trên vật lý biết nó sẽ phản chiếu ánh sáng khác nhau như thế nào trên bề mặt này so với khi chúng tôi chỉ đơn giản rời khỏi vật liệu kim loại.

Sau đó, chúng tôi cung cấp TextureResource được vẽ bằng bút chì cho vật liệu và đặt nó trên thực thể.

Vì vậy, đó là một cách để làm việc với các tài nguyên được tạo mới của chúng tôi.

Một loại tài nguyên khác mà bây giờ bạn có thể tạo ra là AudioBufferResource.

Bạn có thể nhận AVAudioBuffer theo cách bạn muốn: bằng cách ghi lại đầu vào micrô, tự tạo nó theo thủ tục hoặc sử dụng AVSpeechSynthesizer.

Sau đó, bạn có thể sử dụng AVAudioBuffer để tạo Tài nguyên AudioBuffer và sử dụng nó để phát âm thanh trong ứng dụng của mình.

Đây là cách chúng tôi biến văn bản thành lời nói bằng cách viết AVSpeechUtterance thành AVSpeechSynthesizer.

Chúng tôi nhận được AVAudioBuffer trong một cuộc gọi lại.

Ở đây, chúng tôi đang tạo một AudioBufferResource và đặt inputMode của nó thành .spatial để sử dụng âm thanh vị trí 3D.

Các chế độ đầu vào có sẵn khác là không gian và môi trường xung quanh.

Sau đó, chúng tôi yêu cầu một thực thể phát âm thanh đó.

Tất nhiên, bạn có thể xử lý bộ đệm âm thanh bằng các thủ thuật lạ mắt để làm cho nó có vẻ như cá của bạn đang thổi bong bóng khi chúng nói chuyện dưới nước hoặc bất cứ điều gì thú vị mà bạn có thể nghĩ ra.

Vì vậy, đây là tổng quan về một số tính năng mới trong RealityKit năm nay.

Chúng tôi đã thực sự tập trung vào việc giúp bạn kiểm soát nhiều hơn sự xuất hiện và hành vi của các cảnh của bạn.

Chúng tôi đã sửa đổi ECS của mình để cung cấp cho bạn các hệ thống tùy chỉnh, điều này giúp bạn linh hoạt hơn trong việc cấu trúc các hành vi của ứng dụng.

Chúng tôi đã thêm rất nhiều tiến bộ vào tài liệu và API hoạt hình của mình.

Chúng tôi đã giới thiệu bộ điều khiển ký tự để giúp các thực thể của bạn dễ dàng tương tác với môi trường thế giới thực.

Cuối cùng, chúng tôi đã nêu bật một số cách mà bạn có thể tạo tài nguyên một cách nhanh chóng.

Nhưng đó chắc chắn không phải là một danh sách đầy đủ mọi thứ mới trong RealityKit 2.

Trong phiên RealityKit thứ hai của chúng tôi vào cuối tuần này, bạn có thể tìm hiểu thêm về khả năng kết xuất mới và xem cách chúng tôi triển khai một số thứ trong bản demo dưới nước của mình.

Công cụ sửa đổi hình học là những gì chúng ta sử dụng để tạo hiệu ứng động cho rong biển của mình.

Bạch tuộc sử dụng các bộ đổ bóng bề mặt để chuyển đổi đẹp mắt giữa các màu sắc của nó.

Hiệu ứng sương mù có độ sâu xanh lam cũng như các chất ăn da dưới nước được tạo ra bằng cách sử dụng xử lý hậu kỳ.

Và trong chủ đề tài nguyên tổng hợp, bạn sẽ học cách sử dụng các mắt lưới động.

Để bồi dưỡng, bạn cũng có thể muốn xem phiên "Xây dựng ứng dụng với RealityKit" từ năm 2019.

Cảm ơn bạn, và chúng tôi mong muốn được nhìn thấy chiều sâu sáng tạo của bạn với các API này.

[Nhạc lạc quan].