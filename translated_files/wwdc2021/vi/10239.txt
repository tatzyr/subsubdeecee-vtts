10239

♪ Nhạc bass đang phát ♪

♪

Stuart Cheshire: Chào mừng đến với "Giảm sự chậm trễ mạng cho ứng dụng của bạn".

Tên tôi là Stuart Cheshire.

Tôi sẽ nói về các yếu tố góp phần làm cho các ứng dụng mạng cảm thấy chậm ngày hôm nay và sau đó tôi sẽ bàn giao cho đồng nghiệp Vidhi Goel của tôi để cho bạn biết về các kỹ thuật và API bạn có thể sử dụng để làm cho ứng dụng mạng của bạn phản hồi nhanh hơn.

Hãy bắt đầu bằng cách nói về điều gì đó mà bạn có thể đã thấy trong bản beta WWDC của iOS.

Nếu bạn nhìn vào cài đặt Nhà phát triển, bạn sẽ thấy một mục mới trong phần Mạng được gọi là Khả năng phản hồi.

Mặc dù thông lượng tải lên, thông lượng tải xuống và thời gian ping nhàn rỗi đều thú vị, nhưng yếu tố chính ảnh hưởng đến khả năng phản hồi của ứng dụng mạng của bạn là khả năng phản hồi của mạng trong điều kiện làm việc, không phải điều kiện nhàn rỗi.

Phép đo thời gian ping nhàn rỗi kiểm tra tốc độ internet điển hình cho bạn biết kết nối internet của bạn hoạt động tốt như thế nào khi bạn không sử dụng nó.

Điều quan trọng là kết nối internet của bạn hoạt động tốt như thế nào khi bạn đang sử dụng nó.

Nhấn vào Kiểm tra.

Nó sẽ cảnh báo bạn rằng nó sẽ tạo ra lưu lượng mạng, nó sẽ đo lường mạng của bạn trong vài giây, và sau đó nó sẽ cho bạn biết mạng của bạn đang hoạt động tốt như thế nào trong điều kiện làm việc.

Công cụ báo cáo khả năng phản hồi của mạng trong các chuyến đi khứ hồi mỗi phút, hoặc RPM, thay vì mili giây.

Chúng tôi đã tạo ra số liệu RPM mới này vì mili giây là một khái niệm khá trừu tượng đối với nhiều người.

Mọi người cũng quen thuộc hơn với các số liệu trong đó cao hơn là tốt hơn.

Chỉ số RPM tạo ra các con số trong phạm vi từ vài trăm RPM đến vài nghìn RPM, giống như RPM của động cơ ô tô của bạn.

Ngoài ra còn có một phiên bản dòng lệnh của công cụ kiểm tra này trên macOS được gọi là NetworkQuality.

Bạn có thể nghĩ rằng mạng gia đình hoặc nơi làm việc của bạn có thời gian ping tuyệt vời, nhưng đó là khi nó không hoạt động.

Chạy bài kiểm tra chất lượng mạng này cho chính bạn - trên iPhone hoặc Mac của bạn - và bạn có thể thấy rằng khi mạng của bạn đang được sử dụng, khả năng phản hồi của nó trở nên tồi tệ hơn rất nhiều.

Và ý tôi là tệ hơn rất nhiều.

Mạng của bạn có thể có thời gian khứ hồi nhàn rỗi là 20 mili giây, nghe có vẻ khá tốt, nhưng bạn có thể thấy rằng trong điều kiện làm việc, thời gian khứ hồi lên tới 600 mili giây trở lên.

Điều đó tệ hơn gấp 30 lần.

Khả năng phản hồi của mạng trong điều kiện làm việc là điều quan trọng đối với trải nghiệm người dùng ứng dụng của bạn.

Tất cả chúng ta đều thấy vấn đề này mọi lúc, nhưng đặc biệt là với việc đóng băng âm thanh và video, và bỏ học trong hội nghị truyền hình.

Độ trễ mạng cao làm tổn thương tất cả các ứng dụng, nhưng chúng tôi đã quen với điều đó, vì vậy chúng tôi nhận thấy nó nhiều hơn khi nó ảnh hưởng đến hội nghị truyền hình.

Khi chúng tôi gặp vấn đề với hội nghị truyền hình, chúng tôi nghĩ rằng chúng tôi sẽ khắc phục nó bằng cách nâng cấp kết nối internet của mình.

Mọi người đã chuyển từ một vài megabit mỗi giây sang gigabit trở lên, nhưng các vấn đề vẫn xảy ra.

Một vài megabit mỗi giây sẽ rất nhiều cho hội nghị truyền hình, vậy tại sao chúng ta vẫn gặp phải những vấn đề này?

Khi bộ đệm trong mạng quá lớn, khi chúng lấp đầy, chúng không cải thiện thông lượng, nhưng chúng làm tăng thêm độ trễ.

Chúng ta thường nghĩ về internet hoạt động như thế này, với các gói tin chảy nhanh qua mạng.

Nhưng nếu chúng ta nhìn vào bên trong đám mây, chúng ta sẽ thấy rằng nó thực sự hoạt động giống như thế này.

Gói bạn thấy ra khỏi mạng không phải là gói mà bạn thấy đi vào.

Các gói dành nhiều thời gian ngồi trong các bộ đệm quá lớn trong mạng.

Hiện tượng bộ đệm quá lớn này được gọi là bộ đệm phình to, và cho đến nay nó vẫn chưa được đo lường rộng rãi, bất chấp ảnh hưởng của nó đối với việc sử dụng mạng hàng ngày.

Tin tốt là có các thuật toán quản lý hàng đợi hiện đại, như CoDel - thuật toán xếp hàng trễ có kiểm soát - loại bỏ sự phình to bộ đệm.

Khi mạng giữ hàng đợi ngắn, thời gian một gói dành cho việc chờ đợi trong mạng sẽ giảm đáng kể.

Có thể có được thông lượng cao và độ trễ thấp cùng một lúc.

Nó không phải là một trong hai/hoặc sự lựa chọn. Nó không phải là một trò chơi có tổng bằng không.

Chúng tôi đang làm việc với ngành để triển khai các thuật toán quản lý hàng đợi thông minh hơn và cải thiện khả năng phản hồi mạng trong điều kiện làm việc.

Nhưng hiện tại, nếu bạn muốn mang lại trải nghiệm người dùng tuyệt vời, bạn sẽ muốn làm cho các ứng dụng của mình đối phó với internet như ngày nay.

Bufferbloat là một thành phần lớn của sự chậm trễ mạng mà ứng dụng của bạn sẽ gặp phải, nhưng nó không phải là nguồn trì hoãn duy nhất.

Có thời gian xử lý phần mềm và phần cứng.

Khi CPU nhanh hơn bao giờ hết, thời gian xử lý này tiếp tục thu hẹp.

Có thời gian truyền dữ liệu thực tế.

Khi tốc độ dữ liệu tăng từ kilobit lên megabit lên gigabit mỗi giây, thời gian truyền tiếp tục giảm.

Sau đó là sự chậm trễ thời gian do bộ đệm trong mạng.

Như tôi đã nói, chúng tôi đang làm việc với ngành công nghiệp để giảm bớt sự chậm trễ này.

Nhưng sẽ luôn có độ trễ lan truyền tín hiệu tốc độ ánh sáng.

Trở lại những năm 1990, thời gian ping Stanford-to-MIT, khứ hồi, từ bờ biển đến bờ biển, trên khắp Hoa Kỳ, đã dưới 100 mili giây.

Điều đó đã khá gần với giới hạn tốc độ ánh sáng rồi, vì vậy nó sẽ không khá hơn nhiều.

Chúng tôi đang làm việc để giảm ba độ trễ còn lại, nhưng độ trễ tốc độ ánh sáng sẽ không bao giờ biến mất, vì vậy đây là lý do tại sao điều quan trọng là phải thiết kế các ứng dụng của bạn có tính đến thời gian khứ hồi của mạng.

Khi chúng ta nói về việc tính đến thời gian khứ hồi trên mạng, chúng ta đang nói về loại ứng dụng nào?

Mọi người đều biết rằng hội nghị truyền hình bị ảnh hưởng nghiêm trọng bởi sự chậm trễ mạng cao.

Mọi người đều biết rằng các trò chơi trực tuyến bị ảnh hưởng nghiêm trọng bởi độ trễ mạng cao.

Nhưng điều này ảnh hưởng đến tất cả các ứng dụng sử dụng mạng.

Tôi đang nói về việc nhận dự báo thời tiết, báo giá cổ phiếu, chỉ đường lái xe.

Điều này ảnh hưởng đến việc duyệt web.

Nó ảnh hưởng đến việc bỏ qua phía trước trong khi xem video phát trực tuyến.

Hãy suy nghĩ về việc có bao nhiêu ứng dụng bao gồm một số chỉ báo độ trễ quay hoạt hình trong khi ứng dụng đang chờ mạng.

Có thể là ứng dụng của bạn.

Chúng tôi chỉ ra rằng chỉ báo "vui lòng đợi" để người dùng không nghĩ rằng ứng dụng đã bị treo.

Thật tuyệt khi chúng tôi đã nỗ lực rất nhiều để cung cấp cho người dùng thứ gì đó để xem xét trong khi họ chờ đợi mạng chậm, nhưng chúng tôi cũng nên nỗ lực như nhau để giảm thời gian họ chờ đợi.

Nếu bạn có một ứng dụng mà bạn đã từng hiển thị chỉ báo độ trễ trong khi chờ dữ liệu từ mạng, có những kỹ thuật bạn có thể sử dụng để giảm thời gian chờ đợi đó.

Thời gian một ứng dụng chờ dữ liệu mạng là một hàm của việc mất bao lâu cho một chuyến đi khứ hồi mạng và số chuyến đi khứ hồi mạng mà ứng dụng của bạn yêu cầu.

Là một nhà phát triển ứng dụng, bạn không thể làm gì nhiều để cải thiện thời gian khứ hồi mạng cơ bản, nhưng bạn có thể kiểm soát số lần khứ hồi mà ứng dụng của bạn yêu cầu.

Hãy để tôi giới thiệu đồng nghiệp của tôi, Vidhi Goel, để cho bạn biết cách bạn có thể làm điều đó.

Vidhi Goel: Cảm ơn, Stuart.

Xin chào, tôi là Vidhi, và hôm nay tôi muốn nói chuyện với bạn về những gì bạn có thể làm với tư cách là một nhà phát triển để giảm sự chậm trễ của mạng trong ứng dụng của bạn.

Khả năng phản hồi của ứng dụng tỷ lệ nghịch với số lượng chuyến đi khứ hồi trên mạng.

Hãy để tôi chỉ cho bạn cách bạn có thể giảm các chuyến đi khứ hồi mạng này bằng cách áp dụng các giao thức mạng hiện đại và làm cho các ứng dụng của bạn trở nên siêu linh hoạt.

Để tăng tốc các ứng dụng của bạn, hãy áp dụng các giao thức mạng hiện đại như HTTP/3 & QUIC, TCP Fast Open, TLS 1.3 và Multipath TCP.

Với những kỹ thuật này, ứng dụng của bạn có khả năng đạt được nhiều mức giảm khứ hồi trong việc cung cấp dữ liệu cho người dùng của bạn.

Hỗ trợ phía máy chủ là cần thiết cho tất cả các giao thức hiện đại này, vì vậy hãy kiểm tra với nhà cung cấp của bạn về sự sẵn sàng của chúng.

Chúng tôi rất vui khi nói với bạn rằng tất cả các công nghệ này đều có sẵn trên iOS và macOS.

Hãy xem xét từng công nghệ này.

Đầu tiên, chúng tôi có HTTP/3 và QUIC được bật theo mặc định trong iOS 15 và macOS Monterey.

QUIC là một giao thức vận chuyển có thể thiết lập kết nối nhanh hơn nhiều so với TCP và TLS.

Bằng cách giảm chặn đầu dòng, QUIC có thể giảm đáng kể sự chậm trễ trong việc cung cấp dữ liệu cho người dùng của bạn.

Và đây là phần hay nhất: nếu bạn đã sử dụng URLSession, bạn đã sẵn sàng.

Nếu bạn cung cấp lớp ứng dụng của riêng mình bằng cách sử dụng API khung mạng và muốn tận dụng QUIC, chỉ cần tạo một NWConnection với các tham số QUIC và đặt giao thức Lớp ứng dụng TLS hoặc ALPN.

Vui lòng xem phiên "Tăng tốc mạng với HTTP/3 và QUIC" để tìm hiểu thêm về cách sử dụng các công nghệ này trong ứng dụng của bạn.

QUIC hữu ích trong nhiều tình huống.

Tuy nhiên, TCP vẫn có thể là lựa chọn đúng đắn cho một số ứng dụng.

Khi sử dụng TCP, bạn có thể loại bỏ toàn bộ chuyến đi khứ hồi bằng cách gửi dữ liệu ứng dụng cùng với cái bắt tay TCP.

TCP Fast Open được hỗ trợ trong khung mạng và ổ cắm.

Để sử dụng nó với NWConnections, có hai tùy chọn: tùy chọn đầu tiên là cho phép Mở nhanh trên kết nối của bạn và trong trường hợp này, ứng dụng sẽ cung cấp dữ liệu ban đầu được gửi đi cùng với cái bắt tay.

Để kích hoạt điều này, hãy đặt tham số allowFastOpen thành true và tạo kết nối của bạn.

Và sau đó, trước khi bắt đầu cuộc gọi, bạn sẽ gọi gửi cùng với dữ liệu ban đầu của mình.

Khi sử dụng TCP Fast Open, bạn phải cẩn thận rằng bạn chỉ gửi các yêu cầu idempotent bằng cái bắt tay.

Idempotent về cơ bản có nghĩa là dữ liệu an toàn để được phát lại qua mạng.

Có một cách khác để sử dụng TCP Fast Open mà không yêu cầu ứng dụng của bạn gửi dữ liệu ban đầu của riêng nó.

Nếu ứng dụng của bạn đang sử dụng TLS qua TCP, bạn có thể chọn gửi tin nhắn bắt tay TLS làm dữ liệu ban đầu.

Để kích hoạt điều này, hãy chuyển đến các tùy chọn TCP cụ thể của bạn và đặt enableFastOpen thành true.

Cách được đề xuất để sử dụng TCP Fast Open là thông qua API khung mạng, nhưng nếu ứng dụng của bạn được xây dựng trên Sockets, thì bạn sẽ gọi connectx API với các cờ tương ứng để chỉ định rằng bạn muốn gửi dữ liệu idempotent bằng cái bắt tay.

Tôi đã đề cập đến idempotent một vài lần.

Hãy để tôi giải thích ý nghĩa của nó và tại sao điều quan trọng là chỉ gửi yêu cầu idempotent với cái bắt tay.

Hoạt động idempotent và phát lại an toàn là hoạt động không có tác dụng bổ sung nếu nó được thực hiện nhiều lần.

Ví dụ, khi người dùng truy cập trang web developer.apple.com, yêu cầu HTTP GET cho trang web này được gửi đi cùng với cái bắt tay TCP.

Nếu xác nhận cho yêu cầu này bị trì hoãn hoặc bị rớt trong mạng, thiết bị sẽ gửi lại yêu cầu HTTP GET có thể được định tuyến đến một máy chủ khác.

Và lần này sự thừa nhận đến cùng với phản hồi HTTP.

Vì yêu cầu HTTP GET không có bất kỳ tác dụng bổ sung nào khi nó được gửi lại qua mạng, nó được coi là một yêu cầu idempotent.

Bây giờ, giả sử người dùng đang cố gắng mua một chiếc iPhone 12 mới.

Yêu cầu HTTP được gửi cho hoạt động này không phải là yêu cầu idempotent.

Nó có thể dẫn đến nhiều giao dịch nếu yêu cầu đi đến một máy chủ khác nhau mỗi khi dữ liệu được phát lại qua mạng.

Hãy ghi nhớ điều đó, hãy nói về TLS 1.3.

TLS 1.3 loại bỏ toàn bộ chuyến đi khứ hồi khỏi cái bắt tay so với TLS 1.2.

Nó cũng cung cấp bảo mật mạnh mẽ hơn.

Nó được bật theo mặc định kể từ iOS 13.4 cho URLSession và NWConnection.

Giao thức TLS 1.3 xác định hỗ trợ dữ liệu sớm, có thể tiết kiệm thêm một chuyến đi khứ hồi khác bằng cách gửi các yêu cầu idempotent cùng với tin nhắn bắt tay TLS.

Hãy chuyển đổi bánh răng và xem xét Multipath TCP hoạt động hơi khác một chút trong việc giảm sự chậm trễ của mạng.

TCP đa đường cho phép một kết nối TCP duy nhất tiếp tục khi thiết bị chuyển từ mạng này sang mạng khác.

Để có được tính năng độ trễ thấp của Multipath TCP, hãy sử dụng API chế độ tương tác.

Nó sẽ lưu tất cả các chuyến đi khứ hồi cần thiết để thiết lập một kết nối mới và hệ thống sẽ tự động chọn đường dẫn mạng nhanh hơn cho các gói dữ liệu của bạn.

Để chọn tham gia từ máy khách, hãy đặt thuộc tính multipathServiceType thành tương tác trên cấu hình URLSession hoặc trên NWParameters của bạn.

Để cung cấp cho bạn ý tưởng về số lượng chuyến đi khứ hồi bạn có thể tiết kiệm với những công nghệ hiện đại này, hãy bắt đầu với một điểm tham chiếu.

Giả sử ứng dụng của bạn hiện đang chạy TLS 1.2 qua TCP.

Trong trường hợp này, sẽ mất bốn chuyến đi khứ hồi để có được byte đầu tiên cho người dùng của bạn.

Nếu máy chủ của bạn chuyển từ TLS 1.2 sang TLS 1.3, các kết nối của bạn sẽ loại bỏ toàn bộ chuyến đi khứ hồi.

Nếu bạn bật TCP Fast Open trên kết nối của mình, bạn sẽ lưu thêm một chuyến khứ hồi khác.

Trong iOS 15, HTTP/3 qua QUIC cung cấp giảm xuống còn hai chuyến đi khứ hồi.

Giao thức QUIC cũng xác định hỗ trợ dữ liệu sớm, điều này có thể cho phép giảm thêm một chuyến khứ hồi.

Dựa trên các phép đo của chúng tôi tại Apple, người dùng thường thấy thời gian khứ hồi đôi khi tăng vọt lên tới 600 mili giây.

Hãy xem điều đó có ý nghĩa gì đối với ứng dụng của bạn.

Bốn chuyến đi khứ hồi ở 600 mili giây có nghĩa là người dùng của bạn đang đợi gần hai giây rưỡi để dữ liệu đến nơi.

Đó là một khoảng thời gian rất lớn để chờ đợi và nhìn chằm chằm vào con quay mạng.

Bằng cách áp dụng các giao thức mạng hiện đại, bạn có thể giảm thời gian đó xuống byte đầu tiên từ 2,4 giây xuống còn khoảng nửa giây.

Người dùng chắc chắn sẽ nhận thấy sự khác biệt khi dữ liệu đến sớm hơn cả giây rưỡi.

Mọi nhà phát triển muốn có hiệu suất mạng tuyệt vời nên chú ý đến số lượng chuyến đi khứ hồi.

Đây là nơi có những chiến thắng lớn.

Tất cả các công nghệ mà tôi đã nói đến giúp giảm sự chậm trễ mạng trong ứng dụng của bạn trong điều kiện mạng trong thế giới thực.

Nếu bạn kiểm tra ứng dụng của mình trên mạng 5G, LTE hoặc Wi-Fi nhanh, khả năng phản hồi ứng dụng của bạn có vẻ phù hợp với bạn.

Nhưng người dùng của bạn không phải lúc nào cũng sử dụng ứng dụng của bạn trong điều kiện mạng tốt nhất.

Để mô phỏng các mạng thực tế, công cụ Điều hòa Liên kết Mạng có sẵn cho iOS từ menu cài đặt Nhà phát triển.

Đối với macOS, bạn có thể tải xuống từ trang web Nhà phát triển Apple.

Công cụ này là một cách đáng tin cậy và có thể lặp lại để kiểm tra ứng dụng của bạn trong các điều kiện mạng khác nhau mà người dùng của bạn có thể gặp phải trong cuộc sống hàng ngày của họ.

Nếu bạn nhớ lại, Stuart đã đề cập trước đó rằng bạn không thể làm gì nhiều về việc giảm thời gian khứ hồi trên mạng của mình.

Chà, điều đó không hoàn toàn đúng.

Hãy để tôi giải thích cách bạn có thể giảm thời gian khứ hồi của mạng khi bạn thông báo chính xác cho hệ thống về lưu lượng truy cập ứng dụng của mình.

Hầu hết các ứng dụng đều có sự kết hợp của lưu lượng truy cập mà chúng gửi hoặc nhận.

Có rất nhiều dữ liệu được trao đổi từ thiết bị của người dùng khi chạy một loạt các ứng dụng.

Trong các mạng trong thế giới thực, như Wi-Fi gia đình hoặc văn phòng, một số thiết bị chia sẻ cùng một mạng.

Các thiết bị này đồng thời gửi và nhận một lượng dữ liệu đáng kể trong khi sử dụng một bộ ứng dụng.

Để tránh xây dựng hàng đợi dài trong mạng chia sẻ này, điều quan trọng là bạn phải phân loại dữ liệu ứng dụng của mình một cách thích hợp để hệ thống có thể quản lý lưu lượng truy cập của bạn một cách hiệu quả nhằm duy trì độ trễ mạng thấp.

Và khi bạn cho phép hệ thống duy trì độ trễ mạng thấp, nó sẽ làm cho lưu lượng truy cập tiền cảnh của ứng dụng của bạn nhanh hơn và do đó dữ liệu quan trọng nhất đối với người dùng được phân phối nhanh chóng.

Hãy để tôi minh họa điều này bằng một ví dụ.

Nhiều ứng dụng tìm nạp trước nội dung như đồ họa, tệp âm thanh, v.v., để có sẵn để sử dụng sau này.

Khi ứng dụng đang tìm nạp trước một lượng dữ liệu đáng kể, đây là mạng có thể trông như thế nào.

Hàng đợi nút cổ chai có thể trở nên đầy.

Nếu tại thời điểm này, người dùng bắt đầu một hoạt động mạng - như xem trang hồ sơ của họ - phản hồi cho yêu cầu này sẽ được xếp hàng ở cuối hàng đợi mạng và có thể mất vài giây trước khi hồ sơ được hiển thị.

Đây sẽ không phải là một trải nghiệm người dùng tốt.

Bây giờ, hãy xem điều gì xảy ra với mạng khi chúng tôi đánh dấu các tác vụ tìm nạp trước không phải người dùng này làm nền.

Đánh dấu những chuyển giao không phải do người dùng bắt đầu này làm nền sẽ làm giảm đáng kể kích thước của hàng đợi mạng, sau đó sẽ có sẵn cho các dữ liệu tiền cảnh khác.

Do đó, bất kỳ dữ liệu tiền cảnh nào - tức là các gói màu xanh lá cây - sẽ được gửi ngay lập tức để có trải nghiệm nhanh chóng, thú vị.

Trong iOS 15 và macOS Monterey, loại dịch vụ nền đã được cải thiện đáng kể.

Chúng tôi đã thêm các thuật toán kiểm soát tắc nghẽn mới để tải lên và tải xuống nền.

Các thuật toán mới này không chỉ làm giảm đáng kể độ trễ mạng, để có trải nghiệm người dùng tốt hơn mà còn đảm bảo rằng việc chuyển nền kết thúc gần như cùng lúc với các lưu lượng truy cập khác.

Hãy xem xét các API mạng mà bạn có thể áp dụng để tận dụng loại dịch vụ nền.

Khi ứng dụng của bạn ở phía trước và thực hiện chuyển khoản không do người dùng khởi tạo, bạn sẽ sử dụng URLSession mặc định và đặt loại dịch vụ mạng thành nền trên các yêu cầu URL của mình.

Một lần nữa, điều này cho phép hệ thống duy trì độ trễ mạng thấp.

Và đối với NWConnection, bạn sẽ đặt lớp dịch vụ thành nền trên NWParameters của mình.

Nếu ứng dụng của bạn bắt đầu chuyển giao lâu dài, cho dù đó có phải là người dùng khởi tạo hay không, bạn sẽ tạo một URLSession nền để tiếp tục chạy ngay cả khi ứng dụng của bạn bị tạm ngưng.

Đối với các tác vụ không nhạy cảm về thời gian, bạn có thể đặt thuộc tính isDiscretionary thành true.

Điều này sẽ cho phép hệ thống chờ các điều kiện tối ưu để thực hiện chuyển khoản.

Chúng tôi đã nói về cách ứng dụng của bạn có thể giúp giữ cho hàng đợi mạng ngắn.

Một nguồn chậm trễ khác có thể là trên chính thiết bị gửi.

Trong lịch sử, các ngăn xếp mạng đã sử dụng bộ đệm gửi rất lớn.

Điều này làm tăng thêm rất nhiều độ trễ không cần thiết, đôi khi theo thứ tự giây, trước khi gói tin thậm chí đi vào mạng.

Chúng tôi đã khắc phục điều này cho URLSession và NWConnection vào năm 2015.

Nhưng hầu hết các máy chủ trên internet đều chạy trên Linux và sử dụng BSD Sockets.

Liên hệ với các nhà khai thác máy chủ của bạn để đảm bảo rằng họ đang sử dụng tùy chọn ổ cắm hình mờ thấp TCP không gửi để giảm sự chậm trễ tại nguồn.

Đối với các bước tiếp theo của bạn, Áp dụng các giao thức mạng hiện đại để loại bỏ nhiều chuyến khứ hồi.

Sử dụng chế độ nền để tìm nạp trước tài sản, chuyển hàng loạt và các tác vụ không khẩn cấp.

Kiểm tra hiệu suất ứng dụng của bạn trong các điều kiện mạng khác nhau.

Network Link Conditioner là một công cụ tuyệt vời để làm điều đó.

Giữ độ trễ mạng ở mức thấp sẽ cải thiện khả năng phản hồi của ứng dụng của bạn và nâng cao trải nghiệm người dùng tổng thể.

Cảm ơn vì đã xem và có một WWDC tuyệt vời!

♪