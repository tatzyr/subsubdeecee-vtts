10058

♪ Nhạc bass đang phát ♪

♪

Philippe Hausler: Xin chào, tên tôi là Philippe, và tôi thực sự vui mừng được giới thiệu với bạn một tính năng mới thú vị trong Swift, AsyncSequence.

Hôm nay chúng ta sẽ xem xét các chuỗi không đồng bộ là gì và các nguyên tắc cơ bản đằng sau chúng.

Sau đó, chúng tôi sẽ nói về cách bạn có thể sử dụng chúng trong mã của mình và xem qua một vài API AsyncSequence mới.

Và cuối cùng, chúng ta sẽ khám phá cách bạn có thể xây dựng các chuỗi không đồng bộ của riêng mình.

Vậy chúng ta hãy đi sâu vào.

Đây là một công cụ thực sự đơn giản mà tôi đã viết để minh họa một số thứ mới thú vị mà bạn có thể làm với AsyncSequence.

Trong công cụ này, chúng tôi bắt đầu với một URL đến một điểm cuối.

Nó liệt kê các trận động đất gần đây.

Bây giờ, thông thường việc tải xuống nội dung thực sự là một nhiệm vụ không đồng bộ có thể mất một thời gian.

Nhưng trong trường hợp này, chúng tôi không muốn đợi tất cả mọi thứ tải xuống; thay vào đó, chúng tôi muốn hiển thị mọi thứ khi chúng được nhận.

Vì vậy, tôi quyết định thay đổi mọi thứ một chút và sử dụng các tính năng không đồng bộ/chờ đợi mới để nhận được phản hồi từ điểm cuối này.

Dữ liệu mà chúng tôi đang tìm nạp được định dạng dưới dạng văn bản được phân tách bằng dấu phẩy, vì vậy mỗi dòng là một hàng dữ liệu hoàn chỉnh.

Vì chuỗi dòng không đồng bộ đang phát ra từng dòng khi nó nhận được, điều đó có nghĩa là chúng ta có khả năng có một bản tải xuống thực sự lớn trước mắt.

Nhưng bằng cách phát ra chúng khi chúng tôi nhận được chúng, đoạn mã cảm thấy thực sự phản hồi và phần tuyệt vời nhất về nó là bạn có thể sử dụng những thứ tương tự mà bạn quen thuộc với việc sử dụng từ các chuỗi thông thường trong bối cảnh không đồng bộ mới này.

Điều đó có nghĩa là bạn có thể sử dụng cú pháp for-await-in mới để lặp lại và các hàm như ánh xạ, lọc và giảm; hoặc - như trong mẫu này - hàm dropFirst để thao tác các giá trị đó.

Vậy cái này hoạt động như thế nào?

Chà, rất nhiều điều mà tôi sẽ nói hôm nay có nền tảng của chúng dựa trên cuộc nói chuyện không đồng bộ/chờ đợi.

Nhưng hãy tóm tắt lại một vài điểm chính.

Các hàm không đồng bộ cho phép bạn viết mã đồng thời mà không cần gọi lại, bằng cách sử dụng từ khóa await.

Việc gọi một hàm không đồng bộ sẽ tạm dừng và sau đó được tiếp tục bất cứ khi nào một giá trị hoặc lỗi được tạo ra.

Mặt khác, AsyncSequence sẽ tạm dừng trên mỗi phần tử và tiếp tục khi trình lặp cơ bản tạo ra một giá trị hoặc ném.

Về cơ bản, như tên gọi của nó, chúng giống như các chuỗi thông thường nhưng có một vài điểm khác biệt chính.

Cụ thể, mỗi phần tử được phân phối không đồng bộ.

Nhưng bởi vì chúng là một giao hàng không đồng bộ, điều đó có nghĩa là thất bại chắc chắn là một khả năng.

Một số chuỗi không đồng bộ ném, nhưng nếu thất bại không phải là một lựa chọn, những chuỗi khác thì không.

Cũng giống như các hàm ném, trình biên dịch sẽ giúp đảm bảo rằng các lỗi được xử lý khi lặp hoặc soạn.

Nói chung, các chuỗi không đồng bộ là một mô tả về cách tạo ra các giá trị theo thời gian.

Vì vậy, một chuỗi không đồng bộ có thể bằng không hoặc nhiều giá trị hơn và sau đó biểu thị sự hoàn thành bằng cách trả về một số không từ trình lặp của nó, giống như các chuỗi.

Khi xảy ra lỗi, đó cũng là điểm mà chuỗi không đồng bộ ở trạng thái đầu cuối và sau khi xảy ra lỗi, họ sẽ trả về nil cho bất kỳ cuộc gọi tiếp theo nào tiếp theo trên trình lặp của họ.

Vì vậy, chúng ta hãy đi sâu vào cách thức hoạt động của định nghĩa đó bằng cách trước tiên bắt đầu với sự lặp lại thông thường.

Ở đây chúng tôi có một mô hình khá quen thuộc.

Đây là một vòng lặp for-in.

Trong trường hợp này, nó lặp lại các trận động đất từ một chuỗi và sau đó gọi một hàm khi độ lớn trên một giá trị nhất định.

Trình biên dịch có kiến thức về cách hoạt động của lần lặp lại này, nhưng những gì nó làm không phải là phép thuật.

Bước biên dịch thực sự chỉ thực hiện một số chuyển đổi đơn giản.

Hãy kiểm tra những biến đổi đó để bạn có thể hiểu dạng không đồng bộ của điều này là gì.

Đây gần như là những gì trình biên dịch làm khi xây dựng mã trước đó.

Đầu tiên, nó bắt đầu bằng cách tạo một biến lặp và sau đó sử dụng vòng lặp while để có được mọi trận động đất do trình lặp tạo ra khi lần lặp tiếp theo được gọi.

Để sử dụng chức năng không đồng bộ/chờ đợi mới, có một thay đổi nhỏ có thể được thực hiện.

Nó đơn giản như thay đổi chức năng tiếp theo đó thành một chức năng không đồng bộ.

Bây giờ chúng ta có thể có sự lặp lại tham gia vào Swift đồng thời bằng cách chờ đợi trận động đất tiếp theo.

Hãy tua lại để khám phá điều này sẽ như thế nào nếu vòng lặp nằm trên một chuỗi không đồng bộ.

Như đã đề cập trước đó, chúng ta cần đợi từng mục ra khỏi chuỗi không đồng bộ.

Điều này được phản ánh trong cú pháp chờ đợi mới.

Tất cả điều này có nghĩa là nếu bạn biết cách sử dụng Sequence, bạn đã có một ý tưởng hay về cách sử dụng AsyncSequence.

Có một vài cách bạn có thể sử dụng các chuỗi không đồng bộ.

Như chúng tôi vừa đề cập, bạn có thể sử dụng cú pháp for-await-in mới; hoặc nếu chuỗi không đồng bộ ném, bạn có thể sử dụng cú pháp for-try-await-in mới.

Điều này cho phép bạn dễ dàng lặp lại các giá trị được tạo ra không đồng bộ - mà không cần phải lo lắng về việc đóng cửa - và sử dụng cú pháp mà bạn đã quen thuộc để lặp lại thông qua chúng.

Ngay cả những thứ như nghỉ ngơi và tiếp tục chỉ hoạt động.

Bây giờ bạn đã có một giới thiệu tốt về lý thuyết về các chuỗi không đồng bộ.

Hãy cùng khám phá sự lặp lại đó xa hơn một chút.

Cho một nguồn là một chuỗi không đồng bộ, bạn có thể chờ từng giá trị bằng cách sử dụng cú pháp for-await-in.

Điều này có nghĩa là nó sẽ chờ đợi từng mặt hàng được sản xuất bởi trình lặp và khi nó chạm vào một thiết bị đầu cuối, nó sẽ hoàn thành vòng lặp.

Khi lặp lại các chuỗi không đồng bộ, ngắt rõ ràng là một cách tốt để kết thúc lặp lại sớm từ bên trong vòng lặp.

Điều này hoạt động giống như các chuỗi thông thường.

Ở đây chúng tôi đang phá vỡ khi dữ liệu vị trí không có mặt cho trận động đất.

Hoặc nếu chúng ta có một số giá trị mà chúng ta muốn bỏ qua, chúng ta có thể sử dụng tiếp tục.

Trong trường hợp này, nếu độ sâu lớn hơn một số giá trị, chúng tôi sẽ bỏ qua chúng và tiếp tục chờ đợi trận động đất tiếp theo.

Lần lặp tiếp theo này từ bản tải xuống hoạt động giống như trước đây, nhưng trong trường hợp này, nguồn mà chúng tôi có có thể gây ra lỗi.

Cũng giống như các chức năng ném, cần phải thử xử lý từng phần tử khi AsyncSequence được lặp lại có thể ném.

Và cũng giống như ném các chức năng, trình biên dịch sẽ phát hiện khi bạn bỏ lỡ một lần thử và cung cấp cho bạn một Fix-it để sửa lỗi.

Điều này có nghĩa là khi một chuỗi không đồng bộ có thể tạo ra lỗi, bạn luôn an toàn, bởi vì ngôn ngữ buộc bạn phải ném lỗi đó hoặc bắt nó.

Lần lặp thứ hai này chạy tuần tự sau lần lặp vòng lặp đầu tiên.

Chạy mã tuần tự không phải lúc nào cũng như mong muốn.

Nếu nó hữu ích để chạy lặp lại đồng thời với những thứ khác đang diễn ra, bạn có thể tạo một tác vụ không đồng bộ mới gói gọn sự lặp lại.

Điều này có thể hữu ích khi bạn biết các chuỗi không đồng bộ mà bạn đang sử dụng có thể chạy vô thời hạn.

Bây giờ, mặc dù chuỗi đó có khả năng là vô thời hạn, nhưng nó ít xảy ra hơn đáng kể.

Nhưng trong thế giới của hành vi không đồng bộ, nó là một cái gì đó phổ biến hơn nhiều và một cái gì đó mà bạn cần xem xét khi sử dụng chúng.

Rất may, các cơ sở vật chất đồng thời trong Swift làm cho việc này thực sự dễ dàng và an toàn để thực hiện.

Điều này cũng có thể thực sự hữu ích khi bạn muốn có khả năng hủy bỏ lần lặp lại bên ngoài.

Ở đây chúng ta có thể chạy đồng thời hai lần lặp và chấm dứt lần lặp sau này.

Khá dễ dàng với các nhiệm vụ để xác định phạm vi công việc của một lần lặp có thể là vô thời hạn trong vòng đời của một số vùng chứa.

Tiếp theo chúng ta hãy tham quan một số API AsyncSequence có sẵn như macOS Monterey, iOS 15, tvOS 15 và watchOS 8.

Có rất nhiều trong số chúng, nhưng tôi sẽ chỉ cho bạn một số điểm nổi bật.

Đọc từ các tệp thường là một trường hợp sử dụng chính cho hành vi không đồng bộ.

FileHandle hiện có thuộc tính byte mới cho phép truy cập vào một chuỗi byte không đồng bộ từ FileHandle đó.

Điều này có thể được sử dụng kết hợp với tiện ích mở rộng mới trên AsyncSequence để chuyển đổi các chuỗi byte không đồng bộ thành các dòng.

Nhưng việc xử lý các tệp phổ biến đến mức chúng tôi quyết định rằng URL nên có bộ truy cập cho cả byte và dòng.

Đây là cùng một API mà tôi đã sử dụng trong ví dụ ban đầu.

Đó là một thuộc tính tiện lợi trên URL để trả về AsyncSequence của các dòng từ nội dung, từ một tệp hoặc từ mạng.

Tôi chắc chắn điều này sẽ làm cho một số nhiệm vụ thực sự phức tạp trước đây trở nên dễ dàng và an toàn.

Đôi khi việc lấy mọi thứ từ mạng đòi hỏi phải kiểm soát nhiều hơn một chút đối với các phản hồi và xác thực.

Vì vậy, URLSession hiện có chức năng byte để tìm nạp một chuỗi byte không đồng bộ được cung cấp URL hoặc URLRequest.

Nếu bạn muốn biết thêm, bạn chắc chắn nên xem phiên "Sử dụng async/ await với URLSession" để biết thêm một số chi tiết về điều này và nhiều khả năng không đồng bộ mới hơn với URLSession.

Nhưng các tệp và mạng không phải là thứ duy nhất có ý nghĩa đối với AsyncSequence.

Thông báo hiện có thể được chờ đợi với API thông báo mới.

Và lặp lại không phải là cách duy nhất để tương tác với AsyncSequence.

Trong ví dụ này, chúng tôi đang chờ thông báo đầu tiên cho các thay đổi từ xa có UUID cửa hàng khớp.

Sử dụng các phương pháp như firstWhere, cùng với chuỗi thông báo không đồng bộ, cho phép một số mẫu thiết kế mới thực sự gọn gàng có thể làm cho mã trước đây thể hiện logic phức tạp giờ đây nhỏ gọn và dễ đọc hơn.

Và nếu tất cả những thứ đó không đủ thú vị, có rất nhiều API mới để thao tác không đồng bộ các giá trị từ các chuỗi không đồng bộ.

Những thứ này nên khá quen thuộc, bởi vì chúng là một số chức năng tương tự có sẵn trên Sequence.

Chúng tôi đã đề cập đến một vài vấn đề cho đến nay, như dropFirst và firstWhere, nhưng có rất nhiều thứ khác ngoài những thứ đó.

Khá nhiều thứ bạn có thể nghĩ ra để sử dụng trên Sequence hiện có một đối tác không đồng bộ để làm việc với AsyncSequence.

Bây giờ đó là rất nhiều thứ để tiếp thu, và bạn có thể nghĩ, "Này, những API mới đó thực sự rất tuyệt, và cú pháp đó cực kỳ gọn gàng, nhưng làm thế nào tôi có thể tạo các chuỗi không đồng bộ của riêng mình?"

Chà, hãy làm chính xác điều đó!

Có một vài cách để triển khai một chuỗi không đồng bộ, nhưng tôi sẽ tập trung vào cách điều chỉnh mã hiện có của bạn.

Đặc biệt, có một vài mẫu thiết kế hoạt động thực sự tốt với AsyncSequence và chúng tôi có một số cơ sở tuyệt vời để tạo ra những gì bạn đã tương tác với khái niệm mới này.

Một số mẫu thiết kế đó giống như đóng cửa được gọi nhiều lần, nhưng một số đại biểu cũng có thể hoạt động tốt.

Khá nhiều thứ không cần phản hồi lại và chỉ thông báo về một giá trị mới xảy ra có thể là ứng cử viên chính để tạo ra một chuỗi không đồng bộ.

Những mẫu thiết kế này thực sự phổ biến và bạn có thể đã có một vài mẫu trong ứng dụng của mình ngày hôm nay.

Đây là một ví dụ về mô hình xử lý phổ biến.

Đó là một lớp có thuộc tính xử lý và phương thức bắt đầu và dừng.

Nó có vẻ như là một ứng cử viên hoàn hảo cho AsyncSequence.

Việc sử dụng hiện tại có thể là một cái gì đó như thế này khi một màn hình được tạo ra và một trình xử lý để nhận các giá trị được chỉ định, và sau đó màn hình được bắt đầu để các trận động đất có thể được gửi đến trình xử lý.

Sau đó, màn hình có thể bị dừng lại để hủy bỏ các sự kiện đang được sản xuất.

Chúng ta có thể sử dụng cùng một giao diện để điều chỉnh việc sử dụng cho phù hợp với loại AsyncStream mới.

Chỉ cần một chút mã để sử dụng nó và cho phép bạn xây dựng một chuỗi không đồng bộ.

Khi xây dựng một luồng không đồng bộ, một loại phần tử và đóng công trình được chỉ định.

Việc đóng cửa có sự tiếp tục có thể mang lại các giá trị nhiều hơn một lần, kết thúc hoặc xử lý việc chấm dứt.

Vì vậy, điều này có nghĩa là, trong trường hợp này, màn hình có thể được tạo ra bên trong việc đóng cửa công trình.

Và sau đó người xử lý có thể được chỉ định để tạo ra các trận động đất để tiếp tục.

Và sau đó onTermination có thể xử lý việc hủy bỏ và dọn dẹp.

Và sau đó chúng ta có thể bắt đầu giám sát.

Mã màn hình tương tự mà chúng tôi đã có trước đây có thể dễ dàng được đóng gói trong cấu trúc luồng không đồng bộ.

Điều này làm giảm nhu cầu tái tạo cùng một logic trong mọi trang web sử dụng.

Và đây là cách sử dụng luồng không đồng bộ này sẽ hoạt động.

Bạn có thể sử dụng các chức năng chuyển đổi mạnh mẽ - như bộ lọc - và cú pháp chờ đợi mới.

Điều này cho phép bạn tập trung vào mục đích của mã của mình thay vì cần phải lo lắng về việc sao chép sổ sách kế toán, vì mọi thứ được gói gọn thành một nơi.

Có rất nhiều sự linh hoạt với AsyncStream để tạo ra các chuỗi không đồng bộ của riêng bạn.

Đây thực sự chỉ là một ví dụ và có thể có rất nhiều ví dụ khác mà bạn có thể điều chỉnh trong mã của riêng mình.

AsyncStream là một cách tuyệt vời để điều chỉnh mã hiện có của bạn để trở thành một chuỗi không đồng bộ.

Nó xử lý tất cả những điều bạn mong đợi từ một chuỗi không đồng bộ, như an toàn, lặp lại và hủy bỏ; nhưng chúng cũng xử lý bộ đệm.

AsyncStream là một cách vững chắc để xây dựng các chuỗi không đồng bộ của riêng bạn và một loại trả về phù hợp từ các API của riêng bạn, vì nguồn duy nhất của các phần tử được tạo ra là từ việc xây dựng.

Và nếu bạn cần đại diện cho các lỗi được ném?

Chà, chúng tôi có một loại cho điều đó!

AsyncThrowingStream giống như AsyncStream nhưng có thể xử lý lỗi.

Nó cung cấp tính linh hoạt và an toàn giống như AsyncStream nhưng có thể xử lý các lỗi bằng cách ném từ lần lặp lại của nó.

AsyncSequence là một công cụ thực sự mạnh mẽ, vừa an toàn vừa quen thuộc để xử lý nhiều hơn một giá trị không đồng bộ.

Nếu bạn biết cách sử dụng Sequence, bạn đã biết cách sử dụng AsyncSequence.

Chúng tôi đã xem xét các chuỗi không đồng bộ là gì và cách chúng được sử dụng và giới thiệu cho bạn AsyncStream.

Chúng tôi đã đi sâu vào lý thuyết và những gì định nghĩa chúng, và một vài chuỗi không đồng bộ mới được giới thiệu, và cuối cùng, làm thế nào để xây dựng của riêng bạn.

Tôi háo hức chờ đợi những gì bạn làm với họ tiếp theo.

♪