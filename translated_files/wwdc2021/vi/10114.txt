10114

♪ Nhạc bass đang phát ♪

♪

Ross LeBeau: Xin chào, và chào mừng đến với WWDC21.

Tên tôi là Ross LeBeau, và tôi là một kỹ sư trong nhóm StoreKit.

Hôm nay, chúng ta sẽ nói về StoreKit, và đây thực sự là một trong ba phiên được thiết kế để giúp bạn triển khai mã phía máy khách, xây dựng máy chủ của bạn để mua hàng trong ứng dụng và hỗ trợ khách hàng của bạn và xử lý hoàn lại tiền.

Phiên này là Meet StoreKit 2, và bạn có thể tìm thấy hai phiên còn lại ở đây tại WWDC21.

Phiên này sẽ tập trung vào các tính năng và triển khai phía máy khách.

Vậy hãy bắt đầu nào!

Kể từ khi StoreKit được giới thiệu trong iOS 3, nó đã tạo ra những cơ hội tuyệt vời cho bạn và doanh nghiệp của bạn.

Ngày nay, nó tồn tại trên bốn nền tảng của Apple và hỗ trợ mọi thứ từ trò chơi đến ứng dụng tin tức, tựa game độc lập đến các bản hit quốc tế.

Trong những năm qua, chúng tôi đã giới thiệu các tính năng tuyệt vời như mã ưu đãi, Chia sẻ trong gia đình và thử nghiệm StoreKit trong Xcode.

Nhưng năm nay, chúng tôi quyết định quay trở lại từ đầu.

Hôm nay, tôi rất vui được giới thiệu với StoreKit 2!

StoreKit 2 là một bộ hoàn toàn mới các API Swift hiện đại và linh hoạt để làm việc với Mua hàng trong ứng dụng trên iOS, macOS, tvOS và watchOS.

Chúng tôi đã có một cái nhìn mới về StoreKit với tư duy Swift đầu tiên.

Chúng tôi đã chấp nhận một số tính năng ngôn ngữ mới nhất, như Swift đồng thời bằng cách sử dụng mẫu không đồng bộ/chờ đợi, để tạo các API đơn giản nhưng mạnh mẽ.

Chúng tôi cũng đã thực hiện một số cập nhật lớn cho các giao dịch mua hàng trong ứng dụng, giúp chúng dễ làm việc hơn nhiều, đồng thời cung cấp thêm thông tin và bảo mật cao.

Và chúng tôi đã thêm các API mạnh mẽ hơn dành riêng cho đăng ký để cung cấp cho bạn cái nhìn sâu sắc hơn mà bạn có thể sử dụng để phát triển doanh nghiệp của mình.

StoreKit 2 APIs sống bên trong cùng một khung StoreKit tồn tại ngày nay và tập trung vào trải nghiệm mua hàng cốt lõi trong ứng dụng thay vì thay thế mọi API.

Các API StoreKit 2 mới bao gồm năm lĩnh vực chính: Sản phẩm, Mua hàng, Thông tin giao dịch, Lịch sử giao dịch và trạng thái đăng ký.

Hôm nay tôi sẽ cung cấp cho bạn cái nhìn tổng quan về từng lĩnh vực này và đồng nghiệp Jakob của tôi sẽ chỉ cho bạn cách sử dụng API StoreKit 2 tương ứng trong mã thực.

Vì vậy, trước tiên, hãy bắt đầu với các khối xây dựng của StoreKit: sản phẩm và mua hàng.

Cấu trúc sản phẩm StoreKit 2 là phiên bản tăng áp của đối tượng sản phẩm StoreKit mà bạn đã quen.

Để bắt đầu, chúng tôi đã thêm dữ liệu bổ sung vào nó, chẳng hạn như loại sản phẩm và thông tin đăng ký mở rộng.

Với StoreKit 2, chúng tôi đang giúp việc tìm hiểu xem khách hàng có đủ điều kiện nhận ưu đãi giới thiệu của bạn trở nên dễ dàng hơn hay không.

Chúng tôi cũng đang làm cho các sản phẩm StoreKit 2 tương thích chuyển tiếp với các tính năng mới.

Chúng tôi đã hoàn thành điều này bằng cách thêm một loại gói có tên BackingValue cho phép bạn truy xuất dữ liệu có trong sản phẩm bằng cách đăng ký trực tiếp các sản phẩm.

Điều này có nghĩa là nếu chúng tôi thêm dữ liệu vào các sản phẩm trong tương lai, bạn sẽ luôn có thể truy cập chúng trong StoreKit 2, ngay cả trên SDK và các thiết bị chạy hệ điều hành có phiên bản StoreKit 2 cũ hơn.

Điều này có nghĩa là bạn có thể sử dụng các tính năng mới nhất để cung cấp chức năng mới cho một phần lớn hơn trong cơ sở khách hàng của bạn.

Với StoreKit 2, bạn yêu cầu các sản phẩm bằng cách gọi một hàm tĩnh trên chính loại sản phẩm đó.

Điều này yêu cầu siêu dữ liệu sản phẩm từ App Store giống như SKProductsRequest hiện có.

Nhưng nhờ vào mẫu Swift đồng bộ/chờ đợi đồng thời Swift mới, yêu cầu sản phẩm StoreKit 2 chỉ yêu cầu một dòng mã.

Tương tự, mua một sản phẩm trong StoreKit 2 là một nhiệm vụ đơn giản, một dòng khác.

Mua hàng bây giờ là một phương pháp ví dụ trên loại sản phẩm, có nghĩa là bạn có thể lấy những sản phẩm bạn vừa truy xuất và gọi mua trực tiếp trên chúng.

Vì phương thức mua hàng cũng sử dụng async/await, bạn sẽ nhận được kết quả mua hàng nội tuyến trong mã của mình.

Bây giờ chúng tôi biết rằng không phải mọi giao dịch mua đều giống nhau.

Nếu bạn muốn sửa đổi hành vi mua hàng ngoài cài đặt mặc định, StoreKit 2 có các tùy chọn Mua hàng.

Tùy chọn Mua hàng là một mặt hàng mô tả một tài sản duy nhất của giao dịch mua.

Bạn có thể soạn các tùy chọn Mua hàng thành một tập hợp mà bạn chuyển vào phương thức mua hàng.

StoreKit 2 bao gồm các tùy chọn mua hàng cho những thứ như số lượng và ưu đãi khuyến mại.

Và trong StoreKit 2, chúng tôi đang thêm một tùy chọn mới gọi là mã thông báo tài khoản ứng dụng.

Mã thông báo tài khoản Ứng dụng là một cách để bạn theo dõi tài khoản người dùng ứng dụng nào đã bắt đầu và hoàn tất giao dịch.

Đó là một mã thông báo mờ đục mà bạn tạo ra mà bạn có thể liên kết với các tài khoản mà ứng dụng của bạn sở hữu.

Thật dễ dàng để tạo mã thông báo tài khoản Ứng dụng, bởi vì yêu cầu duy nhất là nó phải phù hợp với định dạng UUID.

Bạn gửi mã thông báo tài khoản Ứng dụng khi mua hàng dưới dạng tùy chọn Mua hàng và mã thông báo này được trả lại trong thông tin giao dịch cho giao dịch mua đó.

Mã thông báo tài khoản Ứng dụng tồn tại trong thông tin giao dịch mãi mãi, ngay cả trên các thiết bị.

Nếu ứng dụng của bạn hỗ trợ hệ thống tài khoản của riêng nó, điều này có thể giúp bạn theo dõi những giao dịch mua mà mỗi tài khoản trong ứng dụng đã thực hiện, bất kể ID Apple hoặc thiết bị được sử dụng để mua chúng.

Vì vậy, chúng ta đã nói về việc nhận sản phẩm từ App Store và bắt đầu mua hàng; bây giờ điều gì sẽ xảy ra khi giao dịch mua đó hoàn tất?

Như bạn có thể mong đợi, StoreKit sẽ trả lại một giao dịch thành công cho bạn cùng với thông tin được ký bằng mật mã.

Nghe có vẻ quen thuộc, phải không?

Chà, StoreKit 2 đang mang đến bản cập nhật lớn nhất cho các giao dịch mua hàng trong ứng dụng từ trước đến nay.

Để bắt đầu, StoreKit 2 sẽ cung cấp một đối tượng được ký riêng cho mỗi giao dịch.

Không chỉ vậy, bắt đầu từ StoreKit 2, thông tin giao dịch mua hàng trong ứng dụng giờ đây sẽ được cung cấp ở một định dạng rất phổ biến, dễ làm việc: JSON.

Và vì chúng tôi biết rằng ký mật mã an toàn là một phần quan trọng trong việc mua StoreKit, chúng tôi hiện đang sử dụng một tiêu chuẩn chung được sử dụng trên web được gọi là Chữ ký web JSON.

Thêm vào đó, tất cả thông tin chứa trong đối tượng đã ký giờ đây sẽ có sẵn thông qua các API StoreKit gốc, giúp bạn dễ dàng làm việc với dữ liệu này trong mã ứng dụng của mình.

Trên thực tế, chúng tôi sẽ cho bạn thấy nó dễ dàng như thế nào.

Đây là Jakob với một minh chứng về các API này trong mã thực.

Jakob Swank: Xin chào, tôi là Jakob.

Tôi là một kỹ sư trong nhóm StoreKit.

Hôm nay tôi thực sự vui mừng được cho bạn thấy việc bắt đầu và chạy dễ dàng như thế nào với StoreKit 2 trong ứng dụng của bạn.

Ở bên phải, tôi có một ứng dụng mà tôi đang xây dựng có tên là Pocket Cars.

Bạn có thể tải xuống mã mẫu cho ứng dụng này trong phần tài nguyên của phiên này và làm theo.

Ứng dụng có hai chế độ xem chính.

Có một cái nhìn cho những chiếc xe thu thập của tôi và một cái nhìn cho cửa hàng của tôi.

Chúng ta hãy đi qua cửa hàng.

Hiện tại, cửa hàng của tôi trống rỗng vì tôi không có sản phẩm nào có sẵn để bán.

Tôi sẽ tiếp tục và thực hiện những điều đó ngay bây giờ.

Để bắt đầu và chạy nhanh chóng, tôi đang sử dụng thử nghiệm StoreKit trong Xcode.

Điều này cho phép tôi xây dựng và kiểm tra cửa hàng của mình trước khi xác định các sản phẩm trong App Store Connect.

Trong dự án Xcode của mình, tôi đã tạo một tệp cấu hình StoreKit xác định các sản phẩm tôi muốn bán.

Đây là cùng một tệp cấu hình mà tôi đã sử dụng cho StoreKit; Tôi không cần thay đổi hoặc di chuyển bất cứ thứ gì.

Ở đây, tôi cũng có một plist chứa tất cả các số nhận dạng sản phẩm của tôi.

Nó được bao gồm như một tệp tài nguyên được tích hợp trong ứng dụng của tôi để tôi có thể sử dụng nó trong thời gian chạy.

Để hiển thị các sản phẩm này trong cửa hàng của tôi, trước tiên tôi cần thực hiện yêu cầu sản phẩm bằng cách sử dụng một bộ số nhận dạng sản phẩm mà tôi muốn hiển thị.

Với StoreKit 2, tôi có thể làm điều này đơn giản bằng cách gọi một phương thức tĩnh trên cấu trúc Sản phẩm.

Sau khi tôi nhận được các sản phẩm từ App Store, tôi muốn tách chúng theo loại.

Tôi có thể làm điều này một cách dễ dàng với StoreKit 2 vì loại Sản phẩm hiện cung cấp một thuộc tính cho loại như được xác định trên máy chủ App Store.

Trong ứng dụng của tôi, tôi đang bán ba loại sản phẩm: nhiên liệu, ô tô và gói điều hướng.

Nhiên liệu là một sản phẩm tiêu hao - một khi tôi sử dụng nó, nó sẽ biến mất - vì vậy tôi sẽ đưa tất cả các vật tư tiêu hao vào mảng nhiên liệu.

Ô tô là một thứ không thể tiêu thụ được.

Một khi tôi mua một chiếc xe hơi, tôi sẽ sở hữu nó mãi mãi.

Vì vậy, tôi sẽ đưa tất cả các vật tư tiêu hao vào mảng ô tô.

Gói điều hướng là một sản phẩm đăng ký với ba cấp độ dịch vụ.

Khách hàng của tôi có thể đăng ký một cấp độ dịch vụ tại một thời điểm và họ được lập hóa đơn định kỳ.

Ngoài ra, họ có thể nâng cấp hoặc hạ cấp bất cứ lúc nào nếu họ muốn thay đổi mức độ dịch vụ của mình.

App Store sẽ trả lại một Sản phẩm cho mỗi cấp độ dịch vụ, vì vậy tôi sẽ đưa tất cả các đăng ký tự động gia hạn vào mảng đăng ký.

Tôi cũng muốn sắp xếp các sản phẩm của mình trong từng loại theo giá, từ thấp nhất đến cao nhất.

Hãy chạy ứng dụng của tôi và kiểm tra những gì tôi đã làm cho đến nay.

Bây giờ tôi sẽ điều hướng đến cửa hàng.

Ồ!

Trước đây, cửa hàng của tôi trống rỗng, nhưng bây giờ nó trông khá tuyệt vời với tất cả các sản phẩm của tôi được trưng bày.

Chỉ với một dòng mã, tôi có thể yêu cầu các sản phẩm ứng dụng của mình từ App Store, sau đó tôi có thể nhóm và sắp xếp các sản phẩm đó chỉ dựa trên siêu dữ liệu tôi nhận được giúp dễ dàng xây dựng giao diện người dùng cửa hàng của mình.

Bây giờ các sản phẩm của tôi trông rất tuyệt, nhưng nếu tôi nhấn vào nút mua, không có gì xảy ra.

Đó là bởi vì phương thức mua hàng trong cửa hàng của tôi không làm được gì cả.

Nó nên bắt đầu mua hàng với StoreKit.

Chúng tôi có thể làm điều này đơn giản bằng cách gọi phương thức mua hàng trên sản phẩm.

Như Ross đã đề cập, StoreKit 2 được xây dựng từ đầu để sử dụng các khả năng đồng thời mới của Swift.

Điều này cho phép ứng dụng của tôi giữ mã để mua và xử lý kết quả của giao dịch mua đó trong cùng một ngữ cảnh để giữ cho mã của tôi dễ đọc.

Khi giao dịch mua hoàn tất, PurchaseResult sẽ được trả lại.

PurchaseResult này cho tôi biết liệu giao dịch mua đã thành công hay chưa hoặc nếu nó hoàn thành ở một số trạng thái không có lỗi khác, chẳng hạn như người dùng đã hủy giao dịch mua hoặc giao dịch mua cần một số xác thực hoặc phê duyệt ngân hàng bổ sung từ phụ huynh.

Để xử lý từng trường hợp, tôi sẽ chỉ chuyển qua chúng.

Nếu PurchaseResult ở trạng thái thành công, tôi cũng nhận được kết quả xác minh.

Kết quả xác minh bao gồm hai trường hợp: đã xác minh và chưa được xác minh.

Trong StoreKit 2, loại giao dịch chứa tải trọng JWS đại diện cho giao dịch đã ký.

Mỗi khi ứng dụng của tôi nhận được giao dịch từ StoreKit 2, giao dịch đã trải qua quá trình xác minh để xác nhận xem tải trọng có được App Store ký cho ứng dụng của tôi cho thiết bị này hay không.

Bạn đã nghe đúng điều đó.

StoreKit 2 thực hiện xác minh giao dịch cho bạn.

Tất nhiên, cách tôi chọn xử lý kết quả xác minh hoàn toàn phụ thuộc vào tôi và nhu cầu kinh doanh của tôi.

Đối với ứng dụng của tôi, tôi sẽ đảm bảo rằng giao dịch này tôi nhận được từ StoreKit đã được xác minh.

Ở đây trong cửa hàng của tôi, tôi sẽ tạo một phương pháp checkVerified mà tôi có thể sử dụng cho bất kỳ VerificationResult nào.

Nếu kết quả chưa được xác minh, tôi sẽ ném lỗi Xác minh không thành công của chính mình để cảnh báo các phần khác trong ứng dụng của mình.

Nếu kết quả được xác minh, tôi sẽ mở gói giao dịch và trả lại cho người gọi.

Bây giờ tôi có thể sử dụng phương pháp checkVerified này trên kết quả mua hàng.

Cuối cùng, với giao dịch của tôi đã được xác minh, tôi cung cấp nội dung cho người dùng của mình.

Sau khi người dùng có nội dung, tôi cần đảm bảo rằng tôi đã nói với StoreKit để hoàn tất giao dịch.

Sau đó tôi cần trả lại nó để giao diện người dùng của tôi có thể được cập nhật.

Ứng dụng của tôi có một cơ sở dữ liệu tài khoản mà tôi duy trì.

Tôi muốn bao gồm người dùng đã đăng nhập hiện tại của ứng dụng của mình với giao dịch mua StoreKit để thông tin này luôn có sẵn cho ứng dụng của tôi khi nó nhận được giao dịch đã ký trên App Store.

Tôi có thể làm điều này bằng cách tạo tùy chọn mua appAccountToken bằng cách sử dụng phiên bản mã thông báo của tài khoản đã đăng nhập của tôi và chuyển tùy chọn đó sang phương thức mua hàng.

Được rồi.

Tất cả chúng ta đã sẵn sàng với việc triển khai phương thức mua hàng của tôi.

Hãy chạy lại ứng dụng của tôi.

Bây giờ chúng tôi đã trở lại cửa hàng của tôi, và tôi cảm thấy khá mạo hiểm.

Vì vậy, tôi sẽ mua một chiếc xe máy vì tôi luôn muốn có một chiếc.

Có bảng thanh toán từ StoreKit cho tôi thấy việc mua hàng đã được bắt đầu đúng cách.

Tôi sẽ nhấn để xác nhận việc mua hàng.

StoreKit sau đó hiển thị một cảnh báo cho thấy việc mua hàng đã thành công.

Sau khi tôi bỏ qua cảnh báo đó, nút mua của tôi thay đổi thành dấu kiểm màu xanh lá cây cho thấy ứng dụng của tôi tin tưởng giao dịch và xe máy của tôi đã được giao.

Có một điều quan trọng nữa tôi muốn lưu ý ở đây.

Như tôi đã nói trước đây, đôi khi khách hàng sẽ phải thực hiện một số xác minh bổ sung trên tài khoản của họ hoặc họ sẽ cần sự chấp thuận của phụ huynh trước khi giao dịch mua hoàn tất.

Trong những trường hợp này, kết quả mua hàng tôi nhận được từ product.purchase() sẽ ở trạng thái chờ xử lý.

Điều này có nghĩa là sau khi khách hàng hoàn tất xác minh tài khoản hoặc phụ huynh của họ phê duyệt, ứng dụng của tôi sẽ cập nhật giao diện người dùng để phản ánh giao dịch mua đã hoàn thành.

Để lắng nghe những cập nhật giao dịch này, tôi cần lặp lại một thuộc tính tĩnh trên loại giao dịch.

Thuộc tính này là một chuỗi không đồng bộ vô hạn.

Điều đó có nghĩa là nó sẽ tiếp tục lặp lại các bản cập nhật giao dịch khi chúng đến từ StoreKit cho đến khi tôi chọn hủy hoặc thoát ra khỏi vòng lặp for.

Ở đây tôi đang tạo một tác vụ tách rời sẽ trả về một xử lý tác vụ mà tôi có thể sử dụng để hủy rõ ràng trình nghe cập nhật của mình khi cửa hàng được phân bổ.

Cũng giống như tất cả các giao dịch tôi nhận được từ StoreKit 2, tôi muốn kiểm tra xem kết quả xác minh có được xác minh hay không trước khi gửi nội dung cho người dùng.

Tôi có thể sử dụng phương pháp checkVerified đã được xác định trước đó của mình.

Và, giống như với phản hồi mua hàng, một khi tôi đã xác minh giao dịch của mình, tôi cần cung cấp nội dung cho người dùng của mình.

Và tất nhiên, tôi luôn cần hoàn thành các giao dịch của mình.

Điều rất quan trọng là tôi bắt đầu cập nhật trình nghe giao dịch của mình ngay khi ứng dụng của tôi khởi chạy để tôi không bỏ lỡ một ứng dụng nào.

Tôi sẽ làm điều này ngay khi cửa hàng của tôi được tạo, điều này xảy ra ngay khi khởi chạy ứng dụng.

Để kiểm tra trình nghe cập nhật của mình, tôi sẽ bật Ask To Buy trong môi trường kiểm tra Xcode của mình để mô phỏng phản hồi mua hàng ở trạng thái đang chờ xử lý.

Để làm điều này, tôi chọn tệp cấu hình StoreKit của mình và trong menu Trình chỉnh sửa, tôi chọn Bật Yêu cầu Mua.

Hãy chạy lại ứng dụng của tôi và mua hàng.

Lần này, sau khi tôi xác nhận trên bảng thanh toán, tôi thấy một cảnh báo mới từ StoreKit nói rằng tôi cần xin phép để hoàn tất giao dịch mua.

Tôi sẽ tiếp tục và nhấn Hỏi.

Phản hồi mua hàng được trả lại cho ứng dụng của tôi ở trạng thái đang chờ xử lý.

Để phê duyệt giao dịch mua, tôi sẽ mở thử nghiệm StoreKit trong trình quản lý giao dịch Xcode và nhấp vào nút Phê duyệt ở góc trên cùng bên phải.

Tuyệt vời!

Ngay sau khi tôi phê duyệt giao dịch, trình nghe cập nhật của tôi đã nhận được kết quả xác minh và giao diện người dùng ngay lập tức thay đổi để hiển thị giao dịch mua đã được phê duyệt.

Bây giờ tôi có một chiếc 5 chỗ tiêu chuẩn hoàn toàn mới để đi vòng quanh.

Tôi vừa cho bạn thấy việc yêu cầu sản phẩm, bắt đầu mua hàng, phản ứng với các kết quả mua hàng khác nhau dễ dàng như thế nào, xác minh tính toàn vẹn của giao dịch và nhận thông tin cập nhật từ App Store cho các giao dịch đang chờ xử lý, tất cả đều sử dụng StoreKit 2.

Bây giờ chúng ta hãy quay lại Ross để được giới thiệu về cách làm việc với lịch sử giao dịch và trạng thái đăng ký của người dùng của bạn.

Ross: Ồ! Thật tuyệt vời khi thấy những API mới này đang hoạt động.

Và xác thực tự động, bạn còn muốn gì hơn nữa?

Cái gì vậy?

Bạn yêu thích mật mã và bạn vẫn muốn tự xác thực dữ liệu?

Đừng lo lắng.

Xác thực tự động của StoreKit 2 nâng cao tiêu chuẩn bảo mật, nhưng nó không có nghĩa là thay thế hoàn toàn xác thực của chính bạn.

Như mọi khi, bảo mật nằm trên phạm vi sức mạnh, thời gian và sự phức tạp.

Tôi sẽ cung cấp cho bạn tin sốt dẻo về xác nhận một lát sau.

Đầu tiên, nếu bạn hào hứng với các giao dịch StoreKit 2 như tôi, bạn sẽ rất muốn biết rằng chúng tôi đang cung cấp cho bạn rất nhiều cách mới để làm việc với chúng.

Chúng tôi đang thêm một bộ API mới để truy vấn các giao dịch đã hoàn thành trong lịch sử giao dịch của người dùng.

Trong StoreKit 2, bạn có thể truy cập tất cả các giao dịch trước đây của người dùng chỉ bằng một lệnh gọi API duy nhất.

Bạn cũng có thể truy cập giao dịch mới nhất cho một sản phẩm.

Vì vậy, nếu bạn muốn xem lần gia hạn đăng ký gần đây nhất, bạn có thể.

Và chúng tôi biết rằng điều số một bạn cần biết là những sản phẩm mà người dùng đã trả tiền để truy cập ngay bây giờ.

Vì vậy, chúng tôi đã chắt lọc thông tin đó thành một hàm duy nhất được gọi là CurrentEntitlements.

Các quyền lợi hiện tại chứa tất cả các vật tư không tiêu hao trong lịch sử giao dịch của người dùng, cũng như tất cả các giao dịch đăng ký hiện đang hoạt động.

Với điều này, bạn có tất cả thông tin bạn cần để mở khóa mọi thứ mà người dùng đã trả tiền trong ứng dụng của bạn.

Và vì điều này chỉ đại diện cho những thứ mà người dùng nên có quyền truy cập ngay bây giờ, bất kỳ giao dịch nào đã bị thu hồi đều không được bao gồm trong phản hồi.

Hàng tiêu dùng cũng không được bao gồm, vì chúng không phải là một phần liên tục của lịch sử giao dịch.

Bây giờ, chắc hẳn bạn đang nghĩ, "Tôi không thể chờ đợi!

Khi nào tôi có thể bắt đầu gọi những thứ này trong ứng dụng của mình?"

Chà, với StoreKit 2, mọi giao dịch mà người dùng đã từng hoàn thành đều có sẵn cho ứng dụng của bạn ngay khi bạn yêu cầu.

Điều này có nghĩa là khi người dùng cài đặt ứng dụng của bạn trên một thiết bị mới, bạn sẽ có thể biết họ có quyền truy cập vào sản phẩm nào ngay lần đầu tiên ứng dụng của bạn được mở.

Hơn nữa, lịch sử giao dịch sẽ tự động cập nhật trên các thiết bị của người dùng.

Khi khách hàng của bạn mua hàng trên một thiết bị, ứng dụng của bạn sẽ có thể xem giao dịch mua trên mọi thiết bị khác mà nó được cài đặt.

Trên thực tế, nếu ứng dụng của bạn đang chạy khi giao dịch mua được thực hiện trên một thiết bị khác, bạn sẽ được thông báo về giao dịch mới.

Jakob đã đề cập rằng điều quan trọng là phải lắng nghe các giao dịch ngay khi ứng dụng của bạn khởi động và đây chỉ là một lý do nữa là đúng.

Vì vậy, tất cả những điều này có nghĩa là người dùng sẽ không cần khôi phục các giao dịch đã hoàn thành khi ứng dụng của bạn được cài đặt lại hoặc tải xuống trên một thiết bị mới.

Mọi thứ sẽ tự động được StoreKit tìm nạp và luôn cập nhật.

Nhưng mọi người sử dụng thiết bị Apple của họ theo hàng triệu cách ở hàng triệu nơi.

Trong trường hợp hiếm hoi mà người dùng nghĩ rằng họ nên có một giao dịch nhưng bạn không thấy nó, bạn có thể sử dụng API đồng bộ hóa App Store.

Điều này ngay lập tức đồng bộ hóa lại tất cả các giao dịch StoreKit 2.

Đây là sự thay thế cho API restoreCompletedTransactions và bạn nên cung cấp giao diện người dùng trong ứng dụng của mình cho phép người dùng bắt đầu đồng bộ hóa.

Tuy nhiên, nhờ đồng bộ hóa tự động của StoreKit 2, rất hiếm khi người dùng cần bắt đầu đồng bộ hóa theo cách thủ công.

Đồng bộ hóa tự động sẽ bao gồm phần lớn các trường hợp.

Nếu người dùng cần bắt đầu đồng bộ hóa thủ công, họ sẽ được yêu cầu xác thực tài khoản của mình.

Vì lý do này, bạn chỉ nên sử dụng API này để phản hồi đầu vào của người dùng.

Cuối cùng, tất cả các giao dịch được thực hiện bằng API StoreKit 2 đều có sẵn trong API StoreKit ban đầu và ngược lại.

Vì vậy, nếu ứng dụng của bạn có các giao dịch hiện có, bạn sẽ có thể thấy chúng trong StoreKit 2 APIs ngay khi bạn bắt đầu sử dụng chúng.

Các giao dịch mua mới được thực hiện bằng API StoreKit ban đầu sẽ có sẵn thông qua API StoreKit 2 ngay lập tức và các giao dịch mua được thực hiện với StoreKit 2 cũng sẽ có sẵn bên trong biên lai thống nhất khi nó được làm mới.

Ngoài lịch sử giao dịch, StoreKit 2 cũng đang bổ sung các cách để bạn có được thông tin chi tiết về trạng thái đăng ký của người dùng.

Trạng thái đăng ký có ba phần.

Đầu tiên là giao dịch mới nhất.

Điều này thuận tiện cho phép bạn truy cập giao dịch cuối cùng xảy ra cho đăng ký này và nó giống như khi bạn gọi giao dịch mới nhất mà chúng ta đã nói trước đó.

Thứ hai là trạng thái đổi mới.

Đây là một bảng liệt kê cho bạn biết trạng thái hiện tại của đăng ký.

Nếu bạn chỉ muốn biết điều gì đang xảy ra với đăng ký ngay bây giờ, chỉ cần nhìn vào giá trị này.

Nó sẽ cho bạn biết nếu nó hiện đang được đăng ký, hết hạn, trong thời gian gia hạn và hơn thế nữa.

Chúng tôi đã thiết kế nó để cung cấp cho bạn một nơi duy nhất để tìm kiếm nhằm giúp bạn dễ dàng dựa trên logic ứng dụng dựa trên giá trị này.

Và phần cuối cùng của trạng thái đăng ký là thông tin gia hạn.

Đây là nơi bạn có thể xem tất cả các chi tiết về đăng ký của người dùng.

Nó chứa tất cả các loại thông tin không có trong thông tin giao dịch vì dữ liệu này thực sự có thể thay đổi mà không cần giao dịch.

Ví dụ: trong thông tin gia hạn, bạn có thể tìm thấy trạng thái tự động gia hạn, cho bạn biết người dùng đã bật hoặc tắt tính năng tự động gia hạn cho đăng ký này.

Bạn thậm chí có thể thấy ID sản phẩm mà tính năng tự động gia hạn của họ được thiết lập.

Vì vậy, nếu một người dùng gần đây đã hạ cấp đăng ký của họ, bạn có thể thấy điều đó ngay tại đây và có thể sử dụng điều đó như một cơ hội để giới thiệu cho họ một đề nghị giành lại để ở cấp cao hơn.

Nếu đăng ký đã hết hạn, bạn có thể sử dụng thông tin gia hạn để xem lý do hết hạn.

Và thông tin gia hạn đầy đủ có tất cả dữ liệu này và hơn thế nữa, cộng với một tính năng quan trọng khác.

Đúng vậy, tất cả những người yêu thích mật mã, thông tin gia hạn được ký bằng JWS!

Cũng giống như thông tin giao dịch, thông tin gia hạn là một phần quan trọng trong việc mở khóa dịch vụ và đưa ra quyết định tiếp thị.

Vì vậy, chúng tôi đang cho bạn sự tự tin để biết rằng nó hợp lệ và trực tiếp từ Apple.

Và, để trả lời câu hỏi mà tôi chắc chắn đang chạy qua đầu bạn ngay bây giờ, vâng, StoreKit 2 sẽ tự động xác thực thông tin gia hạn cho bạn.

Một điều cuối cùng cần biết về API trạng thái đăng ký là chúng trả về một loạt các trạng thái.

Điều này là do, trong một số trường hợp, người dùng có thể có nhiều đăng ký cho cùng một sản phẩm.

Ví dụ: người dùng có thể đã đăng ký sản phẩm của bạn và sau đó cũng nhận được đăng ký thông qua Chia sẻ trong gia đình.

Bạn nên kiểm tra mảng để xem mức dịch vụ cao nhất mà họ được hưởng là gì.

Bây giờ tôi sẽ đưa nó lại cho Jakob để cho bạn thấy nó trông như thế nào khi làm việc với các API lịch sử giao dịch và trạng thái đăng ký này trong mã ứng dụng của bạn.

Jakob: Cảm ơn, Ross.

Hãy quay lại ứng dụng mà tôi đang làm việc và cập nhật nó để sử dụng lịch sử giao dịch mới và API trạng thái đăng ký mà Ross vừa nói đến.

Bạn sẽ nhận thấy chiếc xe máy tôi đã mua trước đây không có séc màu xanh lá cây và sau khi tôi điều hướng ra khỏi chế độ xem cửa hàng của mình, sau đó quay lại, chiếc xe 5 chỗ tiêu chuẩn cũng không có séc màu xanh lá cây.

Là một người dùng, tôi không thể biết mình đã mua gì.

Đây là một vấn đề dễ dàng giải quyết với StoreKit 2.

Bất cứ lúc nào, ứng dụng của tôi có thể truy vấn StoreKit về những sản phẩm đã được mua để tôi có thể luôn cập nhật giao diện người dùng của ứng dụng của mình.

Trong tệp Store.swift của tôi, phương thức isPurchased hiện chỉ trả về false.

Hãy khắc phục điều đó bằng một cuộc gọi đơn giản đến Transaction.latest(for:).

Sau đó chuyển mã định danh sản phẩm của tôi để nhận giao dịch gần đây nhất.

Phương thức StoreKit này trả về một kết quả xác minh khác cho tôi biết giao dịch đã được thông qua kiểm tra xác minh của StoreKit 2.

Tôi sẽ xác nhận giao dịch đã được xác minh và mở gói bằng phương pháp checkVerified mà tôi đã viết trước đó.

Sau đó, tôi sẽ đảm bảo rằng ứng dụng của tôi không cung cấp nội dung cho một giao dịch đã được hoàn trả bằng cách kiểm tra revocationDate bằng nil.

Ngoài ra, các đăng ký mà khách hàng của tôi đã nâng cấp lên cấp độ dịch vụ cao hơn vào giữa kỳ sẽ có cờ isUpgraded được đặt thành true.

Tôi muốn đảm bảo rằng ứng dụng của tôi đang cung cấp dịch vụ ở mức cao nhất mà khách hàng của tôi đã đăng ký, vì vậy phương thức isPurchased nên bỏ qua bất kỳ giao dịch nâng cấp nào.

Đối với một sản phẩm đăng ký, loại giao dịch chỉ kể một phần của câu chuyện.

Ngoài ngày giao dịch và ngày hết hạn đăng ký, tôi cũng muốn biết khi nào là ngày gia hạn tiếp theo và liệu khách hàng của tôi có tắt tính năng tự động gia hạn cho đăng ký của họ hay liệu thời gian gia hạn tiếp theo của họ có thay đổi mức độ dịch vụ mà họ đã đăng ký hay không.

Để có được tất cả thông tin này, StoreKit 2 cung cấp API trạng thái đăng ký.

Trong tệp SubscriptionsView.swift của tôi, phương thức updateSubscriptionStatus chịu trách nhiệm lấy trạng thái đăng ký từ StoreKit và hiển thị nó cho người dùng.

Bởi vì tất cả các sản phẩm đăng ký của tôi thuộc cùng một nhóm, tôi có thể sử dụng bất kỳ sản phẩm nào trong số chúng để có được trạng thái hiện tại cho nhóm.

Tôi sẽ chỉ chọn sản phẩm đăng ký đầu tiên từ cửa hàng.

Khi tôi có một sản phẩm, tôi có thể nhận được thuộc tính trạng thái từ đăng ký.

Thật dễ dàng.

Như Ross đã đề cập, người dùng có thể trả tiền cho đăng ký cá nhân của riêng họ trong khi họ cũng có đăng ký được chia sẻ bởi một thành viên trong gia đình.

Vì vậy, thuộc tính trạng thái sẽ trả về một mảng chứa tất cả các trạng thái cho mỗi đăng ký.

Bây giờ, họ có thể có một cấp tiêu chuẩn được chia sẻ với họ trong khi cá nhân họ đã đăng ký cấp chuyên nghiệp.

Tôi muốn đảm bảo rằng người dùng của tôi có thể nhận được mức dịch vụ cao nhất mà họ có quyền truy cập, vì vậy tôi sẽ lặp lại từng trạng thái.

Tiếp theo, tôi sẽ kiểm tra xem trạng thái đã hết hạn hay bị thu hồi.

Tôi muốn bỏ qua những trường hợp này và không hiển thị bất cứ thứ gì cho người dùng.

Đối với tất cả các trường hợp khác, tôi sẽ nhận được Thông tin gia hạn và đảm bảo rằng nó được xác minh bằng phương pháp checkVerified trên cửa hàng của tôi.

Khi tôi xác nhận thông tin gia hạn đã được xác minh, tôi sẽ so sánh mức độ dịch vụ với các sản phẩm trước đó.

Kiểm tra này sẽ nhận được sản phẩm tương ứng cho trạng thái đăng ký, sau đó nó sẽ so sánh với bất kỳ sản phẩm nào trước đó và nếu đó là cấp cao hơn, chúng tôi đặt Trạng thái cao nhất và Sản phẩm cao nhất cho đăng ký mới.

Khi tôi đã kiểm tra tất cả các trạng thái của mình và tôi đã xác định mức dịch vụ cao nhất, tôi sẽ đặt trạng thái và đăng ký hiện tại theo quan điểm của mình.

Hãy xây dựng và chạy ngay bây giờ.

Trong chế độ xem cửa hàng của tôi, các sản phẩm tôi đã mua trước đây hiện hiển thị dấu kiểm màu xanh lá cây cho biết tôi đã sở hữu chúng và tôi không cần phải mua lại chúng.

Hãy xem điều gì sẽ xảy ra khi tôi mua một trong những sản phẩm đăng ký của mình.

Sau khi tôi xác nhận mua hàng, trạng thái được hiển thị ngay trong cửa hàng của tôi.

Tôi có thể cho người dùng của mình biết những gì họ đã đăng ký và khi nào đăng ký của họ sẽ gia hạn tất cả bằng cách sử dụng các API được tích hợp trong StoreKit 2.

Bây giờ chế độ xem Ô tô của tôi thì sao?

Nó sẽ hiển thị tất cả các sản phẩm đã mua của tôi, nhưng hiện tại nó trống rỗng.

Để điền thông tin này, tôi có thể lặp lại tất cả các sản phẩm của mình, sau đó nhận giao dịch mới nhất cho mỗi sản phẩm, kiểm tra ngày hết hạn của giao dịch và liệu nó đã được hoàn lại chưa, nhưng điều đó nghe có vẻ rất nhiều.

Rất may, tôi có thể sử dụng sức mạnh của StoreKit 2 và một API mới, đơn giản và thuận tiện để nhận tất cả các giao dịch hợp lệ của người dùng được gọi là currentEntitlements.

Trong chế độ xem Ô tô của tôi, tôi có phương pháp này để làm mới các sản phẩm đã mua của mình khi chế độ xem được tải.

Cũng giống như với các bản cập nhật giao dịch, tôi lặp lại các quyền hiện tại.

Nhưng không giống như cập nhật giao dịch, chuỗi không đồng bộ của quyền lợi hiện tại là hữu hạn, vì vậy nó sẽ không chờ đợi trong vòng lặp mãi mãi, cung cấp các quyền mới khi người dùng mua nhiều hơn.

Đối với mỗi quyền lợi, tôi muốn kiểm tra kết quả xác minh như tôi làm với mọi giao dịch khác.

Khi tôi biết chúng đã được xác minh, tôi sẽ lọc các quyền lợi thành các mảng khác nhau bằng cách chuyển đổi thuộc tính productType, giống như tôi đã làm với yêu cầu sản phẩm ban đầu của mình.

Các quyền lợi hiện tại sẽ chỉ trả lại các giao dịch cho các sản phẩm không tiêu dùng và tự động tái tạo.

Tôi có thể bỏ qua bất kỳ loại sản phẩm nào khác để hoàn thành câu lệnh chuyển đổi của mình và giữ cho trình biên dịch Swift hài lòng.

Khi tôi có giao dịch, tôi cần làm cho sản phẩm liên quan hiển thị trong giao diện người dùng của mình.

Đối với các giao dịch không tiêu hao, tôi sẽ tìm kiếm mảng sản phẩm ô tô để tìm số nhận dạng sản phẩm phù hợp với giao dịch này.

Và tương tự như vậy, tôi sẽ tìm kiếm mảng sản phẩm đăng ký để phù hợp với bất kỳ giao dịch tự động gia hạn nào.

Hãy chạy lại và kiểm tra giao diện người dùng của tôi.

Bây giờ, khi tôi đi vào chế độ xem Ô tô của tôi, tôi thấy mọi thứ tôi đã mua.

Tất cả những chiếc xe của tôi được nhóm lại với nhau ở trên cùng và đăng ký của tôi ở bên dưới.

Bây giờ ứng dụng của tôi có một cửa hàng hoạt động đầy đủ và nó trông thật tuyệt vời!

Và đó là cách bạn có thể sử dụng lịch sử giao dịch và API trạng thái đăng ký để đưa ra quyết định sáng suốt trong ứng dụng của mình về những gì giao diện người dùng mà người dùng của bạn nhìn thấy.

Bây giờ chúng ta hãy quay lại với Ross, người sẽ nói sâu hơn về đối tượng Chữ ký Web JSON.

Ross: Cảm ơn một lần nữa vì bản demo tuyệt vời, Jakob.

Bạn thực sự có thể thấy các API giao dịch và đăng ký mới có ích như thế nào.

Bây giờ chúng ta đã thấy hai cách mà StoreKit 2 sử dụng JWS để bảo mật, tôi đã hứa chúng ta sẽ xem xét kỹ hơn về nó và cách bạn có thể tự xác thực.

Chữ ký web JSON bao gồm ba phần.

Đầu tiên là tiêu đề, chứa siêu dữ liệu về đối tượng.

Điều này chứa thông tin quan trọng như thuật toán nào được sử dụng để ký và nơi tìm chứng chỉ được sử dụng để xác thực chữ ký.

StoreKit 2 hiện đang sử dụng thuật toán ECDSA, được hỗ trợ nguyên bản trong Swift với CryptoKit.

Đối với chứng chỉ, StoreKit 2 sử dụng tiêu đề x5c, cho biết rằng toàn bộ chuỗi chứng chỉ được bao gồm trong dữ liệu JWS.

Điều này có nghĩa là không cần kết nối internet để xác thực các chữ ký JWS này.

Phần tiếp theo của dữ liệu JWS là tải trọng.

Đây là thông tin chính như ID giao dịch, ID sản phẩm, ngày mua hàng, v.v.

Khi bạn đã xác thực chữ ký, đây là nơi bạn đến để đọc tất cả dữ liệu bạn muốn biết về giao dịch hoặc đăng ký.

Và phần cuối cùng của dữ liệu JWS là chính chữ ký.

Điều này được tạo ra bằng cách sử dụng cả tiêu đề và tải trọng.

Xác thực chữ ký JWS là một phần được ghi chép đầy đủ của tiêu chuẩn, vì vậy tôi khuyên bạn nên đi thẳng đến nguồn gốc nếu bạn quan tâm đến việc viết triển khai của riêng mình.

Tôi đã bao gồm một liên kết đến tài liệu này trong các tài nguyên được liên kết với phiên này.

Khi bạn đã xác thực chữ ký từ dữ liệu JWS, chỉ có một vài điều nữa bạn nên làm để đảm bảo thông tin đã ký hợp lệ cho ứng dụng của bạn và thiết bị hiện tại.

Đầu tiên, bạn nên đảm bảo rằng ID gói có trong tải trọng thông tin đã ký khớp với ID gói của ứng dụng của bạn.

Chúng tôi khuyên bạn nên tăng cường bảo mật, bạn nhúng ID gói ứng dụng của mình ở đâu đó trong ứng dụng, thay vì dựa vào lệnh gọi API và sử dụng giá trị đó để so sánh nó với ID gói trong tải trọng.

Và điều cuối cùng bạn nên làm là thực hiện kiểm tra xác thực thiết bị.

Điều này đảm bảo rằng thông tin đã ký thực sự được tạo cho thiết bị hiện tại.

Sử dụng StoreKit 2 API AppStore.deviceVerificationID để truy xuất mã định danh xác minh thiết bị hiện tại.

Sau đó, lấy nonce xác minh thiết bị từ thông tin đã ký và thêm số nhận dạng xác minh thiết bị bạn vừa nhận được từ StoreKit.

Thực hiện hàm băm SHA384 trên giá trị này và so sánh kết quả với trường xác minh thiết bị từ thông tin đã ký.

Nếu chúng khớp, thì thông tin đã ký đã được tạo cho thiết bị này và quá trình xác thực thông tin đã ký của bạn đã hoàn tất.

Một điều cuối cùng cần lưu ý là những đối tượng JWS mới này chỉ dành cho mua trong ứng dụng.

Vì vậy, nếu bạn cần xác thực biên lai ứng dụng, bạn nên sử dụng API và quy trình hiện có cho việc đó.

Và tất nhiên, chúng tôi đang cung cấp các API máy chủ App Store mới cho các đối tượng JWS mới này, vì vậy bạn có thể truy xuất và xác thực chúng trực tiếp trên máy chủ của mình.

Chà, tôi hy vọng bạn cũng hào hứng được gặp StoreKit 2 như chúng tôi đã giới thiệu nó với bạn hôm nay.

StoreKit 2 đang làm cho việc mua hàng trong ứng dụng trở nên tốt hơn với các API mới cung cấp cho bạn nhiều thông tin hơn và dễ sử dụng hơn bao giờ hết.

Điều này bao gồm các đối tượng thông tin dựa trên JSON mới cho mỗi giao dịch, cũng như các API để cung cấp cho bạn chi tiết giao dịch và dữ liệu giao dịch lịch sử trong mã gốc của bạn.

Kết hợp điều đó với các API trạng thái đăng ký mới và StoreKit 2 mở ra vô số khả năng cho các giao dịch mua trong ứng dụng của bạn.

Để tìm hiểu thêm về mua hàng trong ứng dụng, tôi khuyến khích bạn xem các phiên khác này để mã hóa phía máy chủ và hỗ trợ khách hàng.

Jakob và tôi rất vui vì chúng tôi có thể giới thiệu cho bạn StoreKit 2.

Cảm ơn vì đã tham gia cùng chúng tôi tại WWDC21!

♪