10058

♪ 베이스 음악 연주 ♪

♪

Philippe Hausler: 안녕하세요, 제 이름은 Philippe입니다. Swift의 멋진 새로운 기능인 AsyncSequence를 소개하게 되어 정말 기쁩니다.

오늘 우리는 비동기 시퀀스가 무엇인지와 그 뒤에 있는 기본 사항을 살펴볼 것이다.

그런 다음 코드에서 그것들을 사용하는 방법에 대해 이야기하고 새로운 AsyncSequence API 몇 가지를 살펴볼 것입니다.

그리고 마지막으로, 우리는 당신이 어떻게 자신만의 비동기 시퀀스를 만들 수 있는지 탐구할 것입니다.

그러니까 바로 뛰어들자.

이것은 내가 AsyncSequence로 할 수 있는 멋진 새로운 것들을 설명하기 위해 쓴 정말 간단한 도구이다.

이 도구에서, 우리는 엔드포인트에 대한 URL로 시작합니다.

그것은 최근의 지진을 열거한다.

이제, 일반적으로 물건을 다운로드하는 것은 시간이 좀 걸릴 수 있는 비동기 작업이다.

하지만 이 경우, 우리는 모든 것이 다운로드될 때까지 기다리고 싶지 않습니다; 대신, 우리는 그들이 받은 대로 보여주고 싶습니다.

그래서 나는 상황을 조금 흔들고 새로운 비동기/대기 기능을 사용하여 이 엔드포인트에서 라인이 응답하도록 하기로 결정했다.

우리가 가져오는 데이터는 쉼표로 구분된 텍스트로 포맷되므로, 각 줄은 완전한 데이터 행입니다.

라인의 비동기 시퀀스가 수신된 대로 각 라인을 방출하고 있기 때문에, 그것은 우리가 잠재적으로 우리 앞에 정말 큰 다운로드를 할 수 있다는 것을 의미합니다.

하지만 우리가 그것들을 얻을 때 그것들을 방출함으로써, 스니펫은 정말 반응이 좋으며, 가장 멋진 부분은 이 새로운 비동기 컨텍스트에서 일반 시퀀스에서 사용하는 것과 같은 것을 사용할 수 있다는 것입니다.

즉, 새로운 for-await-in 구문을 사용하여 반복하고 지도, 필터링 및 축소와 같은 기능을 사용할 수 있습니다. 또는 이 샘플과 같이 dropFirst 함수를 사용하여 해당 값을 조작할 수 있습니다.

그래서 이건 어떻게 작동해?

음, 내가 오늘 이야기할 많은 것들은 비동기/대기 대화에 기반한 토대를 가지고 있다.

하지만 몇 가지 요점을 요약해 봅시다.

비동기 함수를 사용하면 await 키워드를 사용하여 콜백 없이 동시 코드를 작성할 수 있습니다.

비동기 함수를 호출하면 값이나 오류가 발생할 때마다 일시 중지되고 재개됩니다.

반면에 AsyncSequence는 각 요소에서 일시 중지되고 기본 반복자가 값을 생성하거나 던질 때 재개됩니다.

기본적으로, 이름에서 알 수 있듯이, 그것들은 일반 시퀀스와 비슷하지만 몇 가지 주요 차이점이 있다.

즉, 각 요소는 비동기적으로 전달된다.

하지만 그것들은 비동기 배송이기 때문에, 그것은 실패가 확실히 가능성이 있다는 것을 의미한다.

일부 비동기 시퀀스는 던지지만, 실패가 옵션이 아니라면, 다른 것들은 그렇지 않다.

던지는 함수와 마찬가지로, 컴파일러는 반복하거나 구성할 때 오류가 처리되도록 하는 데 도움이 될 것이다.

일반적으로 비동기 시퀀스는 시간이 지남에 따라 값을 생성하는 방법에 대한 설명이다.

따라서 비동기 시퀀스는 0 이상의 값일 수 있으며 시퀀스와 마찬가지로 반복기에서 nil을 반환하여 완료를 의미할 수 있습니다.

오류가 발생하면, 그것은 또한 비동기 시퀀스가 터미널 상태에 있는 지점이며, 오류가 발생한 후, 반복기에서 다음 호출에 대해 nil을 반환합니다.

그래서 먼저 정기적인 반복으로 시작하여 그 정의가 어떻게 작동하는지 살펴봅시다.

여기 꽤 친숙한 패턴이 있습니다.

이건 포인 루프야.

이 경우, 시퀀스에서 지진을 반복한 다음 크기가 특정 값 이상일 때 함수를 호출합니다.

컴파일러는 이 반복이 어떻게 작동해야 하는지에 대한 지식을 가지고 있지만, 그것이 하는 일은 마법이 아니다.

편집 단계는 정말 간단한 변형을 한다.

이것의 비동기 형태가 무엇인지 이해할 수 있도록 그 변환을 살펴봅시다.

이것은 대략 컴파일러가 이전 코드를 작성할 때 하는 일이다.

먼저 반복자 변수를 만드는 것으로 시작한 다음 다음에 호출될 때 반복자에 의해 생성된 모든 지진을 얻기 위해 while 루프를 사용합니다.

새로운 비동기/대기 기능을 사용하려면, 할 수 있는 약간의 변경이 하나 있습니다.

다음 기능을 비동기 기능으로 바꾸는 것만큼 간단합니다.

우리는 이제 다음 지진을 기다리면서 스위프트 동시성에 반복을 참여할 수 있다.

루프가 비동기 시퀀스에 있었다면 이것이 어땠을지 밝히기 위해 되감아 봅시다.

앞서 언급했듯이, 우리는 비동기 시퀀스에서 각 항목을 기다려야 합니다.

이것은 새로운 for-await-in 구문에 반영된다.

이 모든 것은 당신이 시퀀스를 사용하는 방법을 알고 있다면, 이미 AsyncSequence를 사용하는 방법에 대한 좋은 아이디어를 가지고 있다는 것을 의미합니다.

비동기 시퀀스를 활용할 수 있는 몇 가지 방법이 있습니다.

방금 다루었듯이, 새로운 for-await-in 구문을 사용할 수 있습니다. 또는 비동기 시퀀스가 throw되면 새로운 for-try-await-in 구문을 사용할 수 있습니다.

이를 통해 클로저로 뒤지지 않고 비동기적으로 생성된 값을 쉽게 반복하고 이미 익숙한 구문을 사용하여 반복할 수 있습니다.

심지어 휴식을 취하고 계속하는 것과 같은 것들도 그냥 일한다.

이제 당신은 비동기 시퀀스 이론에 대한 좋은 소개를 했습니다.

그 반복을 조금 더 탐구해 봅시다.

비동기 시퀀스인 소스를 감안할 때, for-await-in 구문을 사용하여 각 값을 기다릴 수 있습니다.

이것은 반복자에 의해 생성된 각 항목을 기다릴 것이며, 터미널에 부딪히면 루프를 완료한다는 것을 의미합니다.

비동기 시퀀스를 반복할 때, 브레이킹은 분명히 루프 내부에서 반복을 일찍 종료하는 좋은 방법이다.

이것은 일반 시퀀스처럼 작동한다.

여기서 우리는 지진에 대한 위치 데이터가 없을 때 깨지고 있다.

또는 우리가 건너뛰고 싶은 가치가 있다면, 계속 사용할 수 있습니다.

이 경우, 깊이가 어떤 값보다 크면, 우리는 그것들을 건너뛰고 다음 지진을 계속 기다리고 있다.

다운로드의 다음 반복은 이전과 마찬가지로 작동하지만, 이 경우 우리가 가지고 있는 소스는 오류를 일으킬 수 있습니다.

던지는 기능과 마찬가지로, 반복되는 AsyncSequence가 던질 수 있을 때 각 요소를 처리하기 위해 시도해야 합니다.

그리고 또한 함수를 던지는 것과 마찬가지로, 컴파일러는 당신이 시도를 놓쳤을 때 감지하고 실수를 바로잡기 위한 Fix-it을 제공할 것입니다.

이것은 비동기 시퀀스가 오류를 생성할 수 있을 때, 언어가 오류를 던지거나 잡도록 강요하기 때문에 항상 안전하다는 것을 의미합니다.

이 두 번째 반복은 첫 번째 루프의 반복 후에 순차적으로 실행된다.

코드를 순차적으로 실행하는 것이 항상 원하는 것은 아니다.

진행 중인 다른 것들과 동시에 반복을 실행하는 것이 유용하다면, 반복을 캡슐화하는 새로운 비동기 작업을 만들 수 있습니다.

이것은 당신이 사용하고 있는 비동기 시퀀스가 무기한으로 실행될 수 있다는 것을 알 때 유용할 수 있습니다.

이제, 그 순서가 잠재적으로 무기한일 수 있지만, 발생하는 것은 상당히 덜 일반적이다.

하지만 비동기 행동의 세계에서, 그것은 훨씬 더 일반적인 것이며 그것들을 사용할 때 고려해야 할 것이다.

고맙게도, 스위프트의 동시성 시설은 이것을 정말 쉽고 안전하게 만든다.

이것은 또한 잠재적으로 외부에서 반복을 취소하고 싶을 때 정말 도움이 될 수 있습니다.

여기서 우리는 두 반복을 동시에 실행하고 나중에 반복을 종료할 수 있다.

일부 컨테이너의 수명에 무기한일 수 있는 반복 작업의 범위를 지정하는 작업은 꽤 쉽다.

다음으로 macOS Monterey, iOS 15, tvOS 15 및 watchOS 8에서 사용할 수 있는 AsyncSequence API를 둘러보겠습니다.

그것들이 많이 있지만, 하이라이트 중 몇 가지를 보여드리겠습니다.

파일에서 읽는 것은 종종 비동기 동작의 주요 사용 사례이다.

FileHandle에는 이제 해당 FileHandle의 비동기 바이트 시퀀스에 액세스할 수 있는 새로운 바이트 속성이 있습니다.

이것은 비동기 바이트 시퀀스를 줄로 변환하는 AsyncSequence의 새로운 확장과 함께 사용할 수 있습니다.

하지만 파일을 다루는 것은 너무 흔해서 우리는 URL에 바이트와 라인 모두에 대한 접근자가 있어야 한다고 결정했다.

이것은 내가 초기 예시에서 사용한 것과 같은 API이다.

파일이나 네트워크에서 콘텐츠에서 줄의 AsyncSequence를 반환하는 것은 URL의 편의 속성입니다.

나는 이것이 이전에 정말 복잡한 많은 작업을 쉽고 안전하게 만들 것이라고 확신한다.

때때로 네트워크에서 물건을 얻으려면 응답과 인증에 대한 좀 더 많은 통제가 필요합니다.

따라서 URLSession에는 이제 URL 또는 URLRequest가 주어진 비동기 바이트 시퀀스를 가져오는 바이트 함수가 있습니다.

더 알고 싶다면, "비동기 사용/URLSession으로 대기" 세션을 확인하여 이에 대한 자세한 내용과 URLSession을 통한 훨씬 더 많은 새로운 비동기 기능을 확인해야 합니다.

하지만 파일과 네트워크만이 AsyncSequence에 맞는 것은 아니다.

이제 새로운 알림 API로 알림을 기다릴 수 있습니다.

그리고 반복이 AsyncSequence와 상호 작용하는 유일한 방법은 아니다.

이 예에서, 우리는 일치하는 상점 UUID가 있는 원격 변경에 대한 첫 번째 알림을 기다리고 있습니다.

알림 비동기 시퀀스와 함께 firstWhere와 같은 방법을 사용하면 이전에 복잡한 논리를 표현했던 코드를 이제 작고 읽기 쉽게 만들 수 있는 정말 깔끔한 새로운 디자인 패턴을 사용할 수 있습니다.

그리고 그 모든 것이 충분히 멋지지 않았다면, 비동기 시퀀스에서 값을 비동기적으로 조작하기 위한 새로운 API가 많이 있습니다.

이것들은 시퀀스에서 사용할 수 있는 동일한 기능 중 일부이기 때문에 꽤 친숙해야 합니다.

우리는 이미 dropFirst와 firstWhere와 같은 몇 가지를 다루었지만, 그것보다 훨씬 더 많은 것이 있다.

시퀀스에서 사용하기 위해 생각할 수 있는 거의 모든 것은 이제 AsyncSequence로 작업하기 위한 비동기 대응을 가지고 있습니다.

이제 그것은 받아들일 것이 많았고, 당신은 "이봐, 그 새로운 API는 정말 멋지고, 그 구문은 매우 깔끔하지만, 어떻게 나만의 비동기 시퀀스를 만들 수 있을까?"라고 생각할 수도 있습니다.

음, 정확히 그렇게 하자!

비동기 시퀀스를 구현하는 몇 가지 방법이 있지만, 기존 코드를 조정하는 방법에 집중할 것입니다.

특히, AsyncSequence와 정말 잘 작동하는 몇 가지 디자인 패턴이 있으며, 우리는 당신이 이미 가지고 있는 것을 이 새로운 개념과 상호 작용할 수 있는 환상적인 시설을 갖추고 있습니다.

이러한 디자인 패턴 중 일부는 여러 번 호출되는 폐쇄와 비슷하지만, 일부 대표단도 잘 작동할 수 있다.

응답이 필요하지 않고 발생하는 새로운 가치를 알리는 거의 모든 것은 비동기 시퀀스를 만들기 위한 주요 후보가 될 수 있다.

이러한 디자인 패턴은 정말 일반적이며 오늘 이미 앱에 몇 가지가 있을 것입니다.

이것은 일반적인 핸들러 패턴의 예이다.

핸들러 속성과 시작 및 중지 방법이 있는 클래스입니다.

그것은 AsyncSequence의 완벽한 후보처럼 보인다.

기존 사용은 모니터가 생성되고 값을 얻기 위한 핸들러가 할당된 다음 모니터가 시작되어 지진이 핸들러로 전송될 수 있는 것과 같은 것일 수 있습니다.

나중에, 생산되는 이벤트를 취소하기 위해 모니터가 중단될 수 있다.

우리는 동일한 인터페이스를 사용하여 새로운 AsyncStream 유형에 맞게 사용법을 조정할 수 있습니다.

그것을 사용하는 데 약간의 코드만 필요하며 비동기 시퀀스를 만들 수 있습니다.

비동기 스트림을 구성할 때, 요소 유형과 구성 폐쇄가 지정됩니다.

폐쇄는 한 번 이상 값을 산출하거나, 끝내거나, 종료를 처리할 수 있는 연속을 가지고 있다.

그래서 이것은, 이 경우, 모니터가 건설 폐쇄 내부에서 만들어질 수 있다는 것을 의미한다.

그리고 나서 핸들러는 계속에 지진을 내도록 할당될 수 있다.

그리고 나서 onTermination은 취소와 정리를 처리할 수 있다.

그리고 나서 우리는 모니터링을 시작할 수 있다.

우리가 이전에 가지고 있던 것과 동일한 모니터 코드는 비동기 스트림의 구성 내에서 쉽게 캡슐화될 수 있다.

이것은 모든 사용 사이트에서 동일한 논리를 복제할 필요성을 줄인다.

그리고 이것이 이 비동기 스트림의 사용법이다.

필터와 같은 강력한 변환 함수와 새로운 대기 구문을 사용할 수 있습니다.

이것은 모든 것이 한 곳에 싸여 있기 때문에 부기를 복제하는 것에 대해 걱정할 필요 없이 코드의 의도에 집중할 수 있게 해준다.

AsyncStream에는 자신만의 비동기 시퀀스를 만들 수 있는 많은 유연성이 있습니다.

이것은 정말 한 가지 예일 뿐이며 자신의 코드에 적응할 수 있는 수많은 다른 것들이 있을 것입니다.

AsyncStream은 기존 코드를 비동기 시퀀스로 조정할 수 있는 좋은 방법입니다.

그것은 안전, 반복 및 취소와 같은 비동기 시퀀스에서 기대할 수 있는 모든 것을 처리하지만, 버퍼링도 처리합니다.

AsyncStream은 생성되는 요소의 유일한 소스가 구성이기 때문에 자체 비동기 시퀀스와 자체 API에서 적절한 반환 유형을 구축하는 견고한 방법입니다.

그리고 만약 당신이 던져지는 오류를 나타내야 한다면?

음, 우리는 그걸 위한 유형이 있어!

AsyncThrowingStream은 AsyncStream과 비슷하지만 오류를 처리할 수 있습니다.

그것은 AsyncStream과 같은 유연성과 안전성을 제공하지만 반복에서 던져 실패를 처리할 수 있다.

AsyncSequence는 하나 이상의 비동기 값을 처리하는 데 안전하고 친숙한 정말 강력한 도구입니다.

시퀀스를 사용하는 방법을 알고 있다면, 이미 AsyncSequence를 사용하는 방법을 알고 있습니다.

우리는 비동기 시퀀스가 무엇인지, 그리고 어떻게 사용되는지 살펴봤고, 당신에게 AsyncStream을 소개했습니다.

우리는 이론과 그것들을 정의하는 것, 그리고 새로 도입된 비동기 시퀀스 중 몇 가지, 그리고 마지막으로, 당신만의 시퀀스를 만드는 방법에 대해 깊이 파고들었다.

나는 네가 다음에 그들과 함께 무엇을 할지 간절히 기다리고 있어.

♪