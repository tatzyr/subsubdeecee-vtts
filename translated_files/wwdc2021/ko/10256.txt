10256

♪ 베이스 음악 연주 ♪

♪

카일 매코머: 안녕하세요, 저는 카일입니다.

Swift Standard Library 팀은 Swift ArgumentParser, Swift Numerics 및 Swift System을 포함한 오픈 소스 패키지의 증가하는 명단을 유지합니다.

오늘, 우리는 가족에 새로운 두 가지를 소개하게 되어 기쁩니다: 스위프트 알고리즘과 스위프트 컬렉션!

스위프트 알고리즘은 스위프트 표준 라이브러리를 보강하는 시퀀스 및 컬렉션 알고리즘의 오픈 소스 패키지이다.

스위프트의 가장 강력한 기능 중 하나는 내장된 알고리즘의 풍부한 분류이다.

어휘를 배우는 데는 약간의 투자가 필요하지만, 일단 그렇게 하면, 얼마나 많은 알고리즘이 평범한 시야에 숨어 있는지, 그리고 그것들을 채택함으로써 코드의 품질을 얼마나 향상시킬 수 있는지 발견하는 것은 놀라운 일이 될 수 있습니다.

내 말이 무슨 뜻인지 보기 위해, 내가 작업하고 있는 메시징 애플리케이션의 코드를 살펴봅시다.

테이블 뷰에서 선택한 행의 인덱스 경로를 반복하여 전달 또는 삭제를 위해 모든 해당 메시지를 수집하는 이 루프를 고려하십시오.

이건 그냥 지도야.

지도를 사용하면 길이나 복잡성에 관계없이 클로저의 본문이 입력을 변환하고 있다는 추가 컨텍스트를 제공하기 때문에 이 코드를 독자에게 더 명확하게 만듭니다.

지도를 사용하면 용량을 예약하여 배열 크기 조정으로 인한 중간 할당을 피하기 때문에 이 코드가 더 빨라집니다. 우리의 원시 루프는 귀찮게 하지 않았습니다.

또는 사용자가 이미지를 탭하면 대본의 메시지를 반복하여 퀵 룩을 사용하여 표시할 모든 첨부 파일을 수집하는 이 루프를 고려하십시오.

이건 그냥 지도와 필터야!

사실, nils를 필터링하고 옵션을 언랩하기 위해 매핑하는 이 패턴은 너무 흔해서 우리는 특별한 이름과 알고리즘을 가지고 있다: compactMap.

다음으로, 이 코드를 고려하세요.

나는 일련의 메시지를 가지고 있고, 그것을 일련의 성적 증명서 항목으로 바꾸고 싶다.

까다로운 점은 주어진 메시지가 채팅 기록의 여러 항목에 해당할 수 있다는 것이다.

여기서 지도를 사용하면 배열 배열이 생성됩니다.

하지만 그건 내가 원하는 게 아니야; 난 그냥 평평한 배열을 원해.

이것은 내가 루프를 위해 raw를 다시 사용해야 한다는 것을 의미하나요?

물론 아니지; 우리는 그것에 대한 또 다른 알고리즘을 가지고 있다.

그건 "가입"이라고 불려.

그것이 하는 일은 모든 내부 배열을 하나의 평평한 요소 모음으로 결합하는 것이다.

이 매핑과 결합 패턴은 너무 흔해서 우리는 또 다른 특별한 종류의 지도를 정의한다: flatMap.

물론, 지도와 필터는 빙산의 일각에 불과하다.

내 앱의 채팅 세부 정보 화면에서 이 원시 루프를 고려해 보세요.

나는 가장 새로운 것부터 가장 오래된 것까지 채팅에서 마지막 여섯 장의 사진을 보여주고 싶다.

그래서 나는 성적표를 거꾸로 반복한다 - 가장 새로운 것부터 가장 오래된 것까지 - 그리고 그 항목이 사진이라면, 나는 그것을 배열에 추가한다.

그리고 일단 내가 여섯 개를 갖게 되면, 나는 멈춘다.

우리는 표준 라이브러리의 알고리즘을 함께 연결하여 이것을 더 간결하게 표현할 수 있습니다 -- 반전, compactMap, 접두사 -- 처음 여섯 개 이상을 차지하지 않습니다.

알고리즘을 함께 연결하면 이 코드를 더 명확하게 표현할 수 있는 더 많은 유연성을 얻을 수 있다.

예를 들어, 나는 반전된 성적 증명서의 접두사가 아닌 성적 증명서의 접미사 측면에서 이 작업에 대해 생각하는 것이 더 자연스럽다고 생각한다.

그래서 알고리즘 체인은 원시 루프보다 더 명확하고 간결하지만, 성능은 어떻게 비교됩니까?

체인의 각 단계가 중간 배열을 할당한다면, 원시 루프보다 느리지 않을까요?

표준 도서관이 여기서 영리한 트릭을 하지 않는다면 대답은 '예'일 것이다.

이전에 본 결합된 알고리즘으로 돌아가서 무슨 일이 일어나고 있는지 자세히 살펴봅시다.

조인된 것은 실제로 여기에 새로운 배열을 할당하고 반환하지 않는다는 것이 밝혀졌다.

대신, 그것은 FlattenSequence를 반환한다.

플랫텐 시퀀스는 우리가 "게으른 어댑터"라고 부르는 것이다.

대부분의 목적을 위해, 그것은 배열처럼 작동하지만, 얇은 포장지일 뿐이므로, 효과적으로 자유롭게 만들 수 있습니다.

그리고 그것은 게으르기 때문에, 모든 일을 미리 하기보다는 필요에 따라 요소를 처리한다.

FlattenSequence와 같은 게으른 어댑터는 알고리즘 체인이 루프를 위한 원시와 경쟁력 있는 성능을 가질 수 있게 해준다.

세부 화면으로 돌아가서 채팅에서 마지막 여섯 장의 사진을 계산하기 위해 알고리즘을 자세히 살펴봅시다.

우리는 접미사가 실제로 배열 슬라이스를 반환한다는 것을 알 수 있습니다. 그것은 영리합니다. 그리고 반전은 또한 마지막에 시작하고 시작에 끝나는 게으른 어댑터로 구현됩니다.

컴팩트맵은 어때?

그것은 여전히 배열을 반환하고 있다. 그게 게을러질 수 있어?

할 수 있어.

체인의 시작 부분에 .lazy를 추가하기만 하면, 지도와 필터와 같은 폐쇄를 취하는 알고리즘을 게으르게 만듭니다!

게으른 알고리즘 체인은 잠재적으로 매우 큰 컬렉션에서 소수의 요소만 처리하는 이와 같은 사용 사례에 매우 적합합니다.

물론, 때때로 당신은 배열이 필요하거나 원합니다.

그리고 그 경우, 당신은 항상 배열 이니셜라이저로 알고리즘 체인을 래핑할 수 있습니다.

이것이 표준 라이브러리 팀에서 우리가 게으른 알고리즘의 열렬한 팬인 또 하나의 이유입니다.

게으른 알고리즘을 열망하는 결과로 바꾸는 것은 정말 쉽지만, 다른 방향으로 가는 것은 불가능하다.

그래서 나는 메시징 앱에서 큰 진전을 보이고 있으며, 디자이너는 기능 요청으로 나에게 접근한다.

두 개의 연속적인 메시지 사이에 한 시간 이상이 지난 경우, 그들은 성적 증명서에 타임 스탬프를 포함시키고 싶어 한다.

합리적인 것 같아.

내가 이것을 위해 사용할 수 있는 또 다른 알고리즘이 있어야 해, 그렇지?

있어. 하지만 그것에 접근하려면, 나는 Swift Algorithms 패키지를 가져와야 할 것이다.

가끔씩, 당신은 스위프트 표준 라이브러리가 아직 커버하지 않는 이와 같은 사용 사례를 접하게 될 것입니다.

알고리즘 패키지의 목적은 당신의 도움으로 우리에게 마찰이 적은 장소를 제공하여 결국 표준 라이브러리에 포함시키기 위해 누락된 알고리즘의 새로운 제품군을 배양하는 것입니다.

우리는 이미 Swift Algorithms에 40개 이상의 알고리즘을 추가했습니다.

요소 컬렉션의 모든 조합이나 순열을 생성하는 것과 같은 것들; 또는 시퀀스의 요소를 두 개 또는 세 개 또는 술어에 의해 결정된 그룹으로 반복하는 것; 또는 컬렉션에서 가장 작은 다섯 개의 요소, 가장 큰 다섯 개 또는 무작위로 다섯 개의 요소를 선택하는 것과 같은 것들.

스위프트 알고리즘과 함께 제공되는 강력한 반복 도구 중 일부를 자세히 살펴봅시다.

windows(ofCount:)는 컬렉션의 요소로 크기 3의 슬라이딩 창을 제공합니다.

루프의 각 회전에 대해, 창은 중간 할당을 피하는 기본 컬렉션의 하위 시퀀스일 뿐입니다.

창문(ofCount: 2)은 특히 일반적이기 때문에 우리는 그것을 위한 편리함을 가지고 있다.

그것은 "adjacentPairs"라고 불린다.

adjacentPairs는 하위 시퀀스가 아닌 튜플을 판매하여 더 편리한 요소 액세스를 가능하게 합니다.

또 다른 강력한 반복 도구는 청크(ofCount:)이다.

창문과 달리, 덩어리는 겹치지 않는다.

컬렉션이 청크 수로 균등하게 나눌 수 없다면, 시퀀스의 마지막 청크는 나머지를 포함할 것이다.

그리고 창문과 마찬가지로, 덩어리는 기본 컬렉션의 하위 시퀀스이므로 만들기에 저렴합니다.

때때로 당신은 컬렉션을 같은 요소로 나누고 싶을 때가 있습니다.

여기서 우리는 isPrime을 숴딩하고 있다.

이것은 우리가 isPrime에 대해 동일한 값을 반환하는 연속적인 요소의 덩어리를 반복한다는 것을 의미합니다.

편의를 위해, 청크(on:)는 청크와 청크가 있는 값 모두의 튜플을 판매한다.

이전 요소와 현재 요소가 다를 때만 작동하는 이와 같은 원시 루프를 작성하는 자신을 발견한 적이 있나요?

이건 그냥 덩어리야!

이제 메시지 사이에 한 시간 이상 경과할 때마다 성적 증명서에 타임 스탬프를 포함하도록 디자이너의 기능 요청으로 돌아가자.

당신이 기억한다면, 우리는 성적표 항목을 만들기 위해 메시지를 평평하게 매핑하여 성적표를 만듭니다.

음, 모든 성적 증명서 항목은 날짜에 접근할 수 있습니다.

그 사이에 한 시간도 채 지나지 않았다면 우리는 그 날짜에 성적 증명서 항목을 함께 그룹화할 수 있다.

우리는 이미 컬렉션을 같은 요소로 청크하는 방법을 보았다.

스위프트 알고리즘은 사용자 지정 조건자를 제공할 수 있는 청크의 또 다른 변형과 함께 제공됩니다.

그것은 당신에게 인접한 요소 쌍을 전달하고, 그들이 같은 그룹에 속한다면 당신은 true를 반환합니다.

여기서, 우리는 성적 증명서 항목 사이의 시간 간격이 한 시간 미만인 경우 true를 반환합니다.

다음으로, 우리는 타임 스탬프를 만들고 모든 것을 하나의 플랫 컬렉션으로 결합해야 합니다.

이전에, 우리는 중첩된 컬렉션을 평평하게 하기 위해 합류하곤 했다.

표준 라이브러리에는 구분 기호를 삽입할 수 있는 또 다른 결합 변형이 함께 제공됩니다.

이 알고리즘을 사용하여 문자열을 새 줄이나 쉼표 구분 기호와 결합하는 것이 정말 일반적입니다.

그러나, 이 경우, 일정한 구분 기호만으로는 충분하지 않다.

우리는 타임스탬프를 구성하기 위해 다음 덩어리의 첫 번째 날짜에 접근해야 한다.

음, 알고리즘 패키지에는 이전 및 다음 청크에서 구분 기호를 계산할 수 있는 또 다른 결합 변형이 포함되어 있습니다.

우리는 그것을 사용하여 이제 타임 스탬프로 구분된 성적 증명서 항목의 덩어리를 다시 결합할 수 있습니다.

꽤 만족스러워, 응?

물론, 우리는 이러한 중간 할당에 대해 지불할 필요가 없습니다.

이 모든 것은 .lazy를 추가하는 것만으로 필요에 따라 계산할 수 있다.

Voilà!

하지만, 나는 게으름이 은색 총알이 아니라는 것을 경고하고 싶다.

시퀀스를 한 번만 반복할 때, 주문형 컴퓨팅은 작업을 절약하고 할당을 피할 수 있습니다.

하지만 시퀀스를 반복해서 반복할 때 - 내가 메시징 앱의 성적표를 가지고 있는 것처럼 - 주문형 컴퓨팅은 사용자가 편집 모드로 들어가거나, 이미지를 탭하거나, 세부 화면을 방문할 때마다 매핑, 청킹 및 참여와 같은 작업을 반복할 것입니다.

이와 같은 경우, 당신은 여전히 게으른 알고리즘 체인을 사용해야 합니다.

마지막 단계로, 모든 것을 배열로 모아서 작업을 저장하면 더 효율적일 것입니다.

우리는 스위프트 표준 라이브러리와 알고리즘 패키지에서 12개 이상의 다른 알고리즘을 살펴보았다.

그들 모두는 배열뿐만 아니라 문자열, 그리고 새로운 스위프트 컬렉션 패키지의 모든 데이터 구조를 포함하여 시퀀스 및 컬렉션 프로토콜을 준수하는 다른 모든 스위프트 유형에서도 작동합니다.

알고리즘을 함께 연결하면 코드가 더 명확하고, 더 빠르고, 더 정확합니다.

그리고 그것에 능숙해지는 것은 복잡하지 않다; 그것은 단지 당신의 어휘를 쌓는 것에 관한 것이다.

그래서 다음에 원시 루프를 읽거나 쓰는 것을 발견하면, 멈추고 그것이 지도, 필터 또는 방금 본 다른 알고리즘 중 하나인지 생각해 보세요.

아무 것도 생각나지 않는다면, 시퀀스 및 수집 프로토콜에 대한 문서를 검색하거나, Swift Algorithms GitHub 저장소의 가이드를 읽거나, 함께 알아낼 수 있는 Swift 포럼을 방문하세요.

누가 알겠습니까, 그것은 알고리즘 패키지에 새로 추가된 것에 대한 영감이 될 수 있습니다!

다음으로, 카로이는 새로운 스위프트 컬렉션 패키지와 함께 제공되는 다양한 데이터 구조에 대해 가르쳐 줄 것입니다.

카로이?

카로이 로렌티: 고마워, 카일!

데이터 구조에 대해 이야기해 봅시다.

오늘날 Swift 표준 라이브러리는 세 가지 주요 범용 데이터 구조만 구현합니다: 배열, 정렬되지 않은 세트 및 정렬되지 않은 사전을 제공합니다.

이것들은 보편적인 수집 유형으로 훌륭한 선택으로 입증되었으며, 모듈 경계를 넘어 데이터를 전송하는 데 특히 좋습니다.

그들은 모두 복사-온-쓰기 값 의미론을 구현하여 효율적인 현장 돌연변이 작업을 제공하는 동시에 수집 값이 생성된 복사본의 예상치 못한 변화로 이어지는 이러한 돌연변이 없이 안전하게 전달되도록 보장합니다.

하지만, 거기에는 훨씬 더 많은 데이터 구조가 있다.

선택할 수 있는 더 많은 선택을 하는 것이 유용할 것이다.

올해 초, 우리는 새로운 데이터 구조 구현과 함께 스위프트 컬렉션 패키지를 출시했습니다.

이 패키지를 통해 스위프트 개발자는 결국 스위프트 표준 라이브러리에 포함되도록 제안하기 전에 새로운 컬렉션 유형으로 실제 제작 경험을 쌓을 수 있습니다.

스위프트 컬렉션 패키지를 가져오면, 추가 유형에 접근할 수 있습니다.

패키지의 초기 버전은 가장 자주 요청되는 세 가지 데이터 구조를 구현한다.

이것들은 세 가지 표준 컬렉션 유형의 새로운 변형이다.

우리는 양방향 대기열, OrderedSet, 그리고 OrderedDictionary가 있습니다.

이것들은 배열, 세트 및 사전과 유사하다; 그것들은 동일한 테마의 변형이며, 기존 구조에 새로운 기능을 추가한다.

즉, 이러한 새로운 유형은 기존 유형을 대체하는 것이 아니다; 그것들은 그것들을 보완한다.

일부 사용 사례의 경우, 새로운 유형이 더 잘 맞을 것이다.

그러나, 다른 많은 사람들에게, 기존 유형은 계속해서 올바른 선택이다.

어떤 데이터 구조에 도달해야 하는지 알기 위해, 우리는 이것들이 기존 유형과 어떻게 다른지 배워야 한다.

그래서 이중 대기열 또는 오히려 일반적으로 대기열부터 시작하여 이들 각각을 간략하게 살펴봅시다.

슈퍼마켓에서 줄을 서서 기다리는 고객부터 애플리케이션의 비동기 작업에 이르기까지 임의의 수의 항목을 하나씩 처리해야 하는 모든 곳에서 대기열이 나타납니다.

가장 추상적인 형태로, 대기열은 두 가지 주요 작업을 제공합니다: 우리는 대기열의 뒤쪽으로 항목을 푸시할 수 있고, 전면에서 요소를 팝업할 수 있습니다.

양방향 대기열은 이러한 대기열 작업을 대칭으로 만든다.

그것은 새로운 아이템을 대기열 앞에 효율적으로 밀어 넣는 것을 지원합니다...

...뒤에서 요소를 터뜨리는 것뿐만 아니라.

"이중식 대기열"이라는 이름은 그러한 유용한 유형에 대해 꽤 한 입이기 때문에, 우리는 그것을 "deque"로 줄이고 싶습니다.

그리고 한 음절을 더 깎기 위해, 이것은 전통적으로 카드 덱처럼 "덱"으로 발음된다.

컬렉션 패키지에서, deque는 친숙한 배열 유형과 거의 동일한 API를 가지고 있으며, 많은 동일한 프로토콜을 구현합니다.

예를 들어, 우리는 배열 리터럴을 사용하여 deque를 만들 수 있다.

Deque는 RandomAccessCollection 프로토콜을 준수합니다.

배열과 마찬가지로, deque는 컬렉션의 시작부터 측정된 오프셋인 정수 인덱스를 사용합니다.

이것은 위치에 따라 모든 요소에 쉽게 접근할 수 있게 해준다.

예를 들어, 이 deque의 인덱스 1의 요소는 문자 E이다.

이제, 나는 이 컬렉션의 끝에 있는 소문자 f에 신경 쓰는 유일한 사람이 아니라고 확신한다.

운 좋게도, deque는 MutableCollection 프로토콜을 준수하므로 인덱스 2를 통해 할당하여 소문자 f를 대문자로 대체하여 이 문제를 해결할 수 있습니다.

아, 그게 훨씬 나아 보여!

Deque는 또한 RangeReplaceableCollection 프로토콜을 구현하므로 요소의 하위 범위를 삽입, 제거 또는 교체하기 위한 모든 친숙한 작업을 제공합니다.

예를 들어, 인덱스가 0인 insert(contentsOf:) 메서드를 호출하여 deque의 전면에 시퀀스를 삽입할 수 있습니다.

이것이 어떻게 실행되는지는 deque가 배열과 다르기 시작하는 곳이다.

만약 우리가 아이템을 저장하기 위해 배열을 사용했다면, 전면에 새로운 요소를 삽입하는 것은 새로운 요소를 위한 공간을 만들기 위해 기존 요소를 이동하는 것으로 시작해야 할 것이다.

가능한 한 간단하게 접근하기 위해, 배열은 저장소의 시작 부분에서 시작하여 단일 연속 버퍼에 요소를 유지합니다.

배열이 크면, 이것은 새로운 요소를 상대적으로 비싸게 만든다; 따라서 전면에 새로운 요소를 삽입하는 것은 이미 배열에 있는 요소의 수에 대략 비례하는 시간이 걸린다.

데크는 다르게 작동한다.

그것은 저장 버퍼를 경계 주위로 감싸서 기존 요소를 이동하지 않고도 새로운 요소를 추가할 수 있도록 한다.

인덱스는 여전히 컬렉션의 논리적 시작에서 오프셋되므로, 삽입 후 인덱스 1의 요소는 이제 B입니다.

이것은 deques가 논리적 인덱스와 실제 저장 위치 사이를 번역하기 위해 몇 가지 작업을 해야 한다는 것을 의미하지만, 요소에 접근하는 것은 여전히 매우 효율적이다.

그리고 deque에 선행하는 것은 기존 멤버를 슬라이딩하는 것을 포함하지 않기 때문에, 그들은 배열보다 훨씬 빠르게 이 작업을 수행할 수 있다.

전면에 새로운 요소를 삽입하는 것은 이미 컬렉션에 얼마나 많은 요소가 있는지에 상관없이 일정한 시간이 걸린다.

이것이 데이터 구조의 힘이다.

일단 우리가 그것들을 툴박스에 넣으면, 우리는 이전에 손이 닿지 않았던 문제를 해결하기 위해 그것들을 사용할 수 있다.

올바른 데이터 구조로 전환하면 모든 차이를 만들 수 있다.

그것은 사용할 수 없을 정도로 느린 앱을 사용하기에 즐거운 반응형 경이로 바꿀 수 있다.

물론, deques는 또한 창고 한가운데에서 작업을 수행하는 방법에 대해 영리할 수 있다.

예를 들어, 요소의 범위를 제거할 때, deque는 후속 요소가 아닌 이전 요소를 이동하여 결과 격차를 좁힐 수 있는 옵션이 있으며, 이는 이동해야 하는 요소의 수를 줄일 수 있습니다.

이것은 요소를 선행하는 것만큼 과감한 개선은 아니지만, 우리가 무작위로 요소를 제거할 때, 그것은 평균적으로 두 배 더 빠르게 만든다.

그래서, 그건 데크야.

이제, 주문한 세트를 살펴봅시다.

표준, 기존 세트 유형은 모든 요소가 고유하다는 것을 보장하는 컬렉션이다.

그러나, 그것은 그들의 원래 주문을 보존하지 않는다.

사실, 세트의 요소 순서는 사실상 무작위이다.

이것은 같은 세트의 두 인스턴스가 종종 그것들을 완전히 다른 두 개의 순열로 나열한다는 것을 의미한다.

그럼에도 불구하고, 같은 요소를 포함하는 두 세트는 동등한 것으로 간주된다; 순서는 중요하지 않다.

이것은 우리가 원하는 모든 것이 독특함을 보장하는 것일 때 훌륭하지만, 때때로 우리는 또한 요소가 어떻게 정렬되는지 통제하고 싶어 한다.

예를 들어, 할 일 목록 앱을 작성하는 경우, 각 항목을 한 번만 나열하도록 하고 싶을 수도 있지만, 사용자가 설정한 특정 순서로 유지해야 합니다.

그래서 그것이 주문된 세트가 하는 일이다.

우리의 관점에 따라, 그것은 요소를 독특하게 유지하는 배열처럼 작동하거나, 우리가 구성원에 설정한 순서를 보존하는 세트로 볼 수 있습니다.

배열과 세트와 마찬가지로, 정렬된 세트는 배열 리터럴로도 표현할 수 있다.

그러나, 세트와 달리, 요소의 순서는 보존되도록 보장된다.

그 순서도 중요하다; 두 개의 정렬된 세트는 같은 멤버를 포함할 뿐만 아니라 같은 순서로 있어야 한다면 동등하게 비교된다.

두 개의 정렬된 세트가 어떤 순서로든 동일한 요소를 포함하고 있는지 알아야 한다면, 특별한 정렬되지 않은 보기를 통해 비교할 수 있습니다.

이 가벼운 보기는 요소 순서를 무시하므로, 더 전통적인 세트와 같은 인터페이스를 제공합니다.

하지만, 기본적으로, 정렬된 세트는 배열이 작동하는 방식과 비슷하다.

이것은 정렬된 세트가 정수 오프셋 인덱스가 있는 랜덤 액세스 컬렉션이라는 사실에 의해 강화된다.

배열이나 데크처럼 정수 첨자를 사용하여 항목에 액세스할 수 있습니다.

세트에서 예상대로, 우리는 또한 요소를 추가하고 제거할 수 있지만, 이러한 작업은 그 위치를 고려해야 한다.

예를 들어, 아직 멤버가 아닌 경우 세트 끝에 새 요소를 추가하는 추가 작업이 있습니다.

반환 값은 요소를 추가해야 하는지 여부를 나타내며, 항목의 인덱스도 보고합니다.

우리는 또한 지정된 위치에 새로운 요소를 두는 삽입 작업이 있습니다.

이 경우, 문자 B가 이미 존재하므로, 작업은 단순히 기존 구성원의 인덱스를 반환합니다.

요소를 제거하면 정렬된 세트에 구멍이 남고, 나머지 멤버는 배열에서처럼 그것을 채우기 위해 이동해야 합니다.

주문한 세트는 요소를 고유하게 유지해야 하므로 임의의 항목 교체를 지원할 수 없습니다.

이것은 배열과 달리 MutableCollection 또는 RangeReplaceableCollection 프로토콜을 준수할 수 없다는 것을 의미합니다.

그러나, 그들은 정렬이나 셔플링과 같은 표준 재정렬 작업을 지원합니다.

주문 세트는 또한 주문 보존 방식으로 SetAlgebra 프로토콜의 모든 고급 세트 작업을 구현합니다.

예를 들어, 조합을 형성하는 것은 두 번째 세트에 나타나는 순서대로 누락된 요소를 추가한다.

세트를 빼면 나머지 요소는 원래 순서로 유지됩니다.

정렬된 세트는 대부분의 SetAlgebra 연산을 구현하지만, 요소의 순서가 중요하지 않아야 하기 때문에 공식적으로 그 프로토콜을 준수할 수 없다.

그러나, 그들의 질서 없는 견해는 질서에 민감하지 않은 평등의 개념을 가지고 있다.

그래서 그것은 SetAlgebra를 준수할 수 있고 준수한다.

우리는 그것을 사용하여 SetAlgebra 값이 필요한 모든 함수에 OrderedSet 값을 전달할 수 있습니다.

후드 아래를 보면, 표준, 정렬되지 않은 세트 유형은 무작위로 시드된 범용 해시 함수를 사용하여 플랫 해시 테이블에 요소를 직접 저장합니다.

이것은 요소에 대한 훌륭한 조회 성능을 제공하지만, 원래 순서를 폐기합니다.

임의의 사용자 지정 요소 순서를 지원하기 위해, 정렬된 세트는 대신 요소를 일반 배열 인스턴스에 저장합니다.

주문된 세트는 여전히 동일한 빠르고 안전한 해시 테이블 구현을 사용하지만, 이 경우 테이블은 정수 인덱스를 스토리지 배열에 저장하기만 하면 됩니다.

이러한 정수의 범위는 해시 테이블의 크기에 의해 제한되므로, 정수 값을 가능한 한 적은 비트로 포장하여 테이블을 압축할 수 있습니다.

이것은 때때로 대부분의 작업에서 경쟁력 있는 성능을 유지하면서 일반 세트에 비해 상당한 양의 메모리를 절약할 수 있다.

조회 성능은 표준 세트와 비슷하다.

무작위 멤버를 찾는 것은 컬렉션의 크기에 상관없이 대략 일정한 시간이 걸린다.

배열은 각 요소를 힘들게 살펴봐야 하며, 컬렉션이 성장함에 따라 시간이 더 오래 걸린다.

정렬된 세트에 새로운 요소를 추가하는 것은 또한 표준 세트에 요소를 삽입하는 것을 대략 비슷하게 수행한다.

이것은 여전히 새 항목을 해시해야 하며, 요소가 이미 존재하는지 확인하는 것도 포함하므로, 이것은 요소를 간단한 배열에 직접 추가하는 것보다 훨씬 더 복잡한 작업이다.

하지만 컬렉션이 아무리 커지더라도, 이것들은 여전히 일정한 시간이 걸린다.

그러나, OrderedSet은 기존 요소를 빠르게 찾고 새 요소를 추가할 수 있지만, 세트의 전면이나 중간에 항목을 제거하거나 삽입하는 것을 효율적으로 구현할 수 없습니다.

배열과 마찬가지로, 이러한 작업은 스토리지 배열에서 요소를 밀어야 하지만, 해시 테이블에서 후속 인덱스의 번호를 다시 매겨야 합니다.

이것은 제거와 삽입이 선형 복잡성을 가진 작업으로 바뀌어 일반 세트보다 느리게 만든다는 것을 의미합니다.

항상 절충안이 있어!

하지만 이러한 데이터 구조가 어떻게 작동하는지 익숙해지면, 우리는 충족해야 할 요구 사항과 최적화하는 데 중요한 작업에 따라 문제를 해결할 수 있는 올바른 것을 자신 있게 선택할 수 있을 것입니다.

올바른 데이터 구조를 선택하면 수백 또는 수천 배 더 빠른 코드를 얻을 수 있는 알고리즘 개선으로 이어질 수 있습니다.

잘못된 것을 선택하면 그 반대를 할 수 있다.

그래서 나는 이것들에 대해 배우는 것이 유용하다고 생각한다. 왜냐하면, 궁극적으로, 그것은 훌륭한 앱과 행복한 사용자를 낳기 때문이다.

이 새로운 OrderedSet 유형은 Foundation의 기존 NSOrderedSet 유형의 순수한 Swift 변형입니다.

그러나, OrderedSet은 패키지로 구현되기 때문에, NSOrderedSet과 연결되지 않습니다.

이것은 기존 Objective-C API가 새로운 유형을 사용하기 위해 자동으로 가져오지 않는다는 것을 의미합니다.

이것들은 별개의 것들이야.

컬렉션 패키지에서 제공하는 세 번째 데이터 구조는 표준 사전 유형의 정렬된 아날로그이다.

표준 사전과 마찬가지로, 이것은 키를 첨자로 사용하여 해당 값을 빠르게 찾을 수 있는 일련의 키-값 쌍입니다.

일반 사전과 달리, 키-값 쌍의 순서는 잘 정의되어 있다.

기본적으로, 그것은 키가 원래 삽입된 순서를 따른다.

새 요소를 추가하기 위해, 우리는 새 키에 값을 할당할 수 있다.

기존 키에 nil을 할당하여 요소를 제거할 수 있습니다.

이러한 작업 전반에 걸쳐, 정렬된 사전은 내용을 잘 정의된 순서로 유지한다.

정렬된 사전은 배열과 같은 정수 인덱스를 사용하지만, 이것은 흥미로운 문제를 야기한다.

예제 사전에서, 인덱싱 첨자 작업은 키 첨자와 충돌합니다.

우리가 0으로 첨자를 할 때, 키 0의 값에 접근한다는 뜻인가요, 아니면 오프셋 0에서 키-값 쌍을 검색한다는 뜻인가요?

우리는 키 기반 첨자가 사전 유형의 기본 연산이라고 생각하기 때문에, 이러한 모호성을 방지하기 위해, 정렬된 사전을 첨자하는 것은 항상 키잉 첨자를 의미합니다.

OrderedDictionary는 인덱싱 첨자 작업을 전혀 제공하지 않습니다.

이것은 컬렉션 프로토콜에 그러한 첨자가 필요하기 때문에 OrderedDictionary가 컬렉션이 될 수 없다는 것을 의미합니다.

따라서, OrderedDictionary는 시퀀스 프로토콜만 준수합니다.

그러나, 컬렉션 적합성이 바람직한 경우, OrderedDictionary는 특별한 요소 보기를 제공한다.

요소는 키-값 쌍을 반환하는 인덱싱 첨자를 제공하는 랜덤 액세스 컬렉션입니다.

기본 구현을 살펴보면, 일반 사전 유형은 각각 키와 값을 저장하기 위해 두 개의 별도의 해시 테이블을 사용하는 반면, 정렬된 사전은 대신 단일 압축 해시 테이블과 두 개의 병렬 배열을 사용합니다.

이것은 주문한 세트보다 훨씬 더 많은 공간을 절약할 수 있다.

그래서 이것들은 컬렉션 패키지에서 사용할 수 있는 세 가지 새로운 데이터 구조이다.

이러한 구조를 사용함으로써, 우리는 앱의 성능을 향상시키거나, 메모리 사용을 줄이거나, - 마찬가지로 중요한 것은 - 세트에서 요소 순서를 보존하는 것과 같은 표준 유형으로 쉽게 만족할 수 없었던 제약을 표현할 수 있습니다.

이러한 새로운 유형은 모두 일부 시퀀스 및 수집 프로토콜을 준수하기 때문에, 카일이 이전에 우리에게 보여준 새로운 알고리즘 패키지뿐만 아니라 표준 라이브러리에서 제공하는 알고리즘과도 상호 운용됩니다.

스위프트 컬렉션과 스위프트 알고리즘은 늘어나는 오픈 소스 패키지 목록의 새로운 멤버 중 두 명에 불과합니다.

우리가 새로운 플랫폼과 새로운 도메인으로 추진함에 따라, 스위프트 라이브러리 생태계의 미래는 지금 형성되고 있다.

그리고 우리가 점점 더 오픈 소스 패키지를 활용함에 따라 이것은 눈에 띄게 이루어지고 있다.

우리는 여전히 유연한 동안 의도적으로 이 패키지를 일찍 출시하고 있으며, GitHub에서 커뮤니티 노력으로 개발하고 있습니다.

그러니 그것들을 시도해 봐.

문제를 제기하세요. 풀 리퀘스트를 여세요.

이보다 더 좋은 때는 없었고, 참여하고 영향을 미치는 것이 그 어느 때보다 쉬웠다.

나는 당신이 우리처럼 이 새로운 스위프트 패키지에 대해 흥분하기를 바랍니다.

우리는 당신이 이것들로 무엇을 만드는지 빨리 보고 싶어요!

시청해 주셔서 감사합니다, 그리고 남은 컨퍼런스를 즐기세요!

♪