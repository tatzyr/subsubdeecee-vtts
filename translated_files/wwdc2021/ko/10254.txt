10254

♪ 베이스 음악 연주 ♪

♪

Rokhini Prabhu: 안녕하세요, "Swift Concurrency Behind the Scenes"에 오신 것을 환영합니다.

제 이름은 로키니이고, 저는 다윈 런타임 팀에서 일합니다.

오늘, 제 동료 바룬과 저는 스위프트 동시성에 대한 근본적인 뉘앙스에 대해 당신과 이야기하게 되어 매우 기쁩니다.

이것은 스위프트 동시성에 대한 초기 회담 중 일부를 기반으로 한 고급 회담이다.

비동기/대기, 구조화된 동시성 및 배우의 개념에 익숙하지 않다면 다른 사람들이 먼저 이야기하는 것을 보는 것이 좋습니다.

스위프트 동시성에 대한 이전 회담에서 당신은 올해 스위프트 고유에서 사용할 수 있는 다양한 언어 기능과 사용 방법에 대해 배웠습니다.

이 강연에서, 우리는 언어 안전뿐만 아니라 성능과 효율성을 위해 왜 이러한 원시적인 것들이 있는 그대로 설계되었는지 이해하기 위해 더 깊이 파고들 것이다.

자신의 앱에서 스위프트 동시성을 실험하고 채택할 때, 우리는 이 이야기가 스위프트 동시성에 대해 추론하는 방법과 그랜드 센트럴 디스패치와 같은 기존 스레딩 라이브러리와 어떻게 인터페이스하는지에 대한 더 나은 정신적 모델을 제공하기를 바랍니다.

우리는 오늘 몇 가지에 대해 논의할 것이다.

먼저, 우리는 스위프트 동시성 뒤에 있는 스레딩 모델에 대해 이야기하고 그랜드 센트럴 디스패치와 대조할 것입니다.

우리는 동시성 언어 기능을 활용하여 Swift를 위한 새로운 스레드 풀을 구축하여 더 나은 성능과 효율성을 달성하는 방법에 대해 이야기할 것입니다.

마지막으로, 이 섹션에서는 스위프트 동시성을 사용하기 위해 코드를 포팅할 때 명심해야 할 고려 사항을 다룰 것입니다.

그런 다음 바룬은 배우를 통해 스위프트 동시성의 동기화에 대해 이야기할 것이다.

우리는 배우들이 후드 아래에서 어떻게 작동하는지, 당신이 이미 익숙할 수 있는 기존 동기화 프리미티브와 어떻게 비교되는지에 대해 이야기할 것입니다 - 시리얼 디스패치 큐와 같이 - 그리고 마지막으로, 배우들과 코드를 작성할 때 명심해야 할 몇 가지 사항.

우리는 오늘 다루어야 할 것이 많으니 바로 뛰어들자.

스레딩 모델에 대한 오늘 토론에서, 우리는 Grand Central Dispatch와 같이 오늘날 사용 가능한 기술로 작성된 예제 앱을 살펴보는 것으로 시작할 것입니다.

그런 다음 우리는 스위프트 동시성으로 다시 쓸 때 동일한 응용 프로그램이 어떻게 진행되는지 볼 것이다.

내가 나만의 뉴스 피드 리더 앱을 쓰고 싶다고 가정해 보자.

내 지원서의 높은 수준의 구성 요소가 무엇인지에 대해 이야기해 봅시다.

내 앱에는 사용자 인터페이스를 구동할 메인 스레드가 있을 것이다.

나는 사용자가 구독한 뉴스 피드를 추적하는 데이터베이스를 가질 것이며, 마지막으로 피드에서 최신 콘텐츠를 가져오기 위해 네트워킹 로직을 처리하는 하위 시스템을 갖게 될 것이다.

그랜드 센트럴 디스패치 대기열로 이 앱을 어떻게 구성할 수 있는지 생각해 봅시다.

사용자가 최신 뉴스를 보라고 요청했다고 가정해 봅시다.

메인 스레드에서, 우리는 사용자 이벤트 제스처를 처리할 것이다.

여기서부터, 우리는 데이터베이스 작업을 처리하는 직렬 대기열에 요청을 비동기화로 보낼 것입니다.

이것의 이유는 두 가지이다.

첫째, 작업을 다른 대기열에 파견함으로써, 우리는 잠재적으로 많은 양의 작업이 일어나기를 기다리는 동안에도 메인 스레드가 사용자 입력에 반응할 수 있도록 합니다.

둘째, 직렬 대기열이 상호 배제를 보장하기 때문에 데이터베이스에 대한 접근은 보호된다.

데이터베이스 대기열에 있는 동안, 우리는 사용자가 구독한 뉴스 피드를 반복하고 각각에 대해 URLSession에 네트워킹 요청을 예약하여 해당 피드의 내용을 다운로드할 것입니다.

네트워킹 요청의 결과가 들어오면, URLSession 콜백은 동시 대기열인 대리자 대기열에서 호출될 것이다.

각 결과에 대한 완료 핸들러에서, 우리는 향후 사용을 위해 캐시하기 위해 이러한 각 피드의 최신 요청으로 데이터베이스를 동기적으로 업데이트할 것입니다.

그리고 마지막으로, 우리는 UI를 새로 고치기 위해 메인 스레드를 깨울 것이다.

이것은 그러한 응용 프로그램을 구성하는 완벽하게 합리적인 방법처럼 보인다.

우리는 요청을 처리하는 동안 메인 스레드를 차단하지 않도록 했습니다.

그리고 네트워크 요청을 동시에 처리함으로써, 우리는 프로그램에 내재된 병렬성을 활용했습니다.

네트워킹 요청의 결과를 어떻게 처리하는지 보여주는 코드 스니펫을 자세히 살펴봅시다.

먼저, 우리는 뉴스 피드에서 다운로드를 수행하기 위한 URLSession을 만들었습니다.

여기에서 볼 수 있듯이, 우리는 이 URLSession의 대리 대기열을 동시 대기열로 설정했습니다.

그런 다음 업데이트해야 하는 모든 뉴스 피드를 반복하고 각각에 대해 URLSession에서 데이터 작업을 예약합니다.

대리 대기열에서 호출될 데이터 작업의 완료 핸들러에서 우리는 다운로드 결과를 역직렬화하고 기사로 포맷합니다.

그런 다음 피드 결과를 업데이트하기 전에 데이터베이스 대기열에 대한 동기화를 발송합니다.

그래서 여기서 당신은 우리가 꽤 간단한 것을 하기 위해 직선 코드를 작성했다는 것을 알 수 있지만 이 코드에는 숨겨진 성능 함정이 있습니다.

이러한 성능 문제에 대해 더 이해하기 위해, 우리는 먼저 GCD 대기열 작업을 처리하기 위해 스레드가 어떻게 발생하는지 파헤쳐야 한다.

그랜드 센트럴 디스패치에서, 작업이 대기열에 있을 때, 시스템은 해당 작업 항목을 서비스하기 위한 스레드를 불러올 것이다.

동시 대기열은 한 번에 여러 작업 항목을 처리할 수 있기 때문에, 시스템은 모든 CPU 코어를 포화시킬 때까지 여러 스레드를 불러올 것이다.

그러나, 첫 번째 CPU 코어에서 볼 수 있듯이 스레드가 차단되고 동시 대기열에서 수행해야 할 더 많은 작업이 있다면, GCD는 나머지 작업 항목을 소모하기 위해 더 많은 스레드를 불러올 것이다.

이것의 이유는 두 가지이다.

첫째, 프로세스에 또 다른 스레드를 제공함으로써, 우리는 각 코어가 주어진 시간에 작업을 실행하는 스레드를 계속 갖도록 할 수 있습니다.

이것은 당신의 애플리케이션에 좋고 지속적인 수준의 동시성을 제공합니다.

둘째, 차단된 스레드는 더 많은 진전을 이루기 전에 세마포와 같은 자원을 기다리고 있을 수 있다.

대기열에서 작업을 계속하기 위해 제기된 새 스레드는 첫 번째 스레드에서 대기 중인 리소스의 차단을 해제하는 데 도움이 될 수 있습니다.

이제 GCD의 스레드 가져오기에 대해 조금 더 이해했으니, 돌아가서 뉴스 앱에서 코드의 CPU 실행을 살펴봅시다.

Apple Watch와 같은 2코어 장치에서 GCD는 먼저 피드 업데이트 결과를 처리하기 위해 두 개의 스레드를 불러올 것이다.

스레드가 데이터베이스 큐에 액세스하는 것을 차단함에 따라, 네트워킹 큐에서 계속 작업하기 위해 더 많은 스레드가 생성됩니다.

그런 다음 CPU는 다양한 스레드 사이의 흰색 수직선으로 표시된 대로 네트워킹 결과를 처리하는 다른 스레드 간에 컨텍스트를 전환해야 합니다.

이것은 우리의 뉴스 애플리케이션에서, 우리가 매우 많은 수의 스레드로 쉽게 끝날 수 있다는 것을 의미한다.

사용자가 업데이트해야 할 100개의 피드가 있다면, 각 URL 데이터 작업은 네트워크 요청이 완료될 때 동시 대기열에 완료 블록을 갖게 됩니다.

GCD는 각 콜백이 데이터베이스 큐에서 차단될 때 더 많은 스레드를 불러올 것이며, 그 결과 애플리케이션은 많은 스레드를 갖게 될 것이다.

이제 당신은 물어볼 수 있습니다, 우리 애플리케이션에 많은 스레드가 있는 것이 뭐가 그렇게 나쁜가요?

애플리케이션에 많은 스레드가 있다는 것은 시스템이 CPU 코어보다 더 많은 스레드로 과도하게 커밋된다는 것을 의미합니다.

6개의 CPU 코어가 있는 iPhone을 고려해 보세요.

우리의 뉴스 애플리케이션에 처리해야 할 100개의 피드 업데이트가 있다면, 이는 우리가 코어보다 16배 더 많은 스레드로 iPhone을 과도하게 커밋했다는 것을 의미합니다.

이것은 우리가 실 폭발이라고 부르는 현상이다.

우리의 이전 WWDC 회담 중 일부는 응용 프로그램의 교착 상태 가능성을 포함하여 이와 관련된 위험에 대해 더 자세히 설명했습니다.

스레드 폭발은 또한 즉시 분명하지 않을 수 있는 메모리와 스케줄링 오버헤드와 함께 제공되므로, 이것을 더 자세히 살펴봅시다.

우리의 뉴스 애플리케이션을 되돌아보면, 차단된 각 스레드는 다시 실행되기를 기다리는 동안 귀중한 메모리와 자원을 보유하고 있다.

각 차단된 스레드에는 스레드를 추적하기 위한 스택과 관련 커널 데이터 구조가 있습니다.

이 스레드 중 일부는 실행 중인 다른 스레드가 필요할 수 있는 자물쇠를 잡고 있을 수 있습니다.

이것은 진전이 없는 스레드를 위해 붙잡아야 할 많은 자원과 메모리이다.

또한 스레드 폭발의 결과로 더 큰 스케줄링 오버헤드가 있다.

새 스레드가 올라올 때, CPU는 새 스레드를 실행하기 위해 이전 스레드에서 벗어나기 위해 전체 스레드 컨텍스트 스위치를 수행해야 합니다.

차단된 스레드가 다시 실행 가능해짐에 따라, 스케줄러는 모두 앞으로 진행할 수 있도록 CPU의 스레드를 시분할해야 합니다.

이제, 그것이 몇 번 일어난다면 스레드의 시분할은 괜찮습니다 - 그것이 동시성의 힘입니다.

하지만 스레드 폭발이 있을 때, 코어가 제한된 장치에서 수백 개의 스레드를 시분할해야 하는 것은 과도한 컨텍스트 전환으로 이어질 수 있다.

이러한 스레드의 스케줄링 대기 시간이 그들이 할 수 있는 유용한 작업의 양을 능가하므로 CPU가 덜 효율적으로 실행됩니다.

우리가 지금까지 보았듯이, GCD 대기열로 애플리케이션을 작성할 때 스레딩 위생에 대한 이러한 뉘앙스 중 일부를 놓치기 쉽기 때문에 성능 저하와 더 큰 오버헤드가 발생합니다.

이 경험을 바탕으로, 스위프트는 언어로 동시성을 설계할 때 다른 접근 방식을 취했다.

우리는 당신의 앱이 통제되고, 구조화되고, 안전한 동시성을 즐길 수 있도록 성능과 효율성을 염두에 두고 스위프트 동시성을 구축했습니다.

스위프트를 사용하면, 우리는 많은 스레드와 컨텍스트 스위치가 있는 다음 모델에서 앱의 실행 모델을 이것으로 변경하고 싶습니다.

여기서 당신은 우리가 두 코어 시스템에서 실행되는 두 개의 스레드만 있고 스레드 컨텍스트 스위치가 없다는 것을 알 수 있습니다.

우리의 모든 차단된 스레드는 사라지고 대신 작업 재개를 추적하기 위한 연속으로 알려진 가벼운 물체가 있습니다.

스레드가 스위프트 동시성에서 작업을 실행할 때 전체 스레드 컨텍스트 스위치를 수행하는 대신 연속 간에 전환합니다.

이것은 우리가 이제 함수 호출 비용만 지불한다는 것을 의미한다.

따라서 우리가 스위프트 동시성에 대해 원하는 런타임 동작은 CPU 코어가 있는 만큼의 스레드만 만들고, 스레드가 차단될 때 작업 항목 간에 저렴하고 효율적으로 전환할 수 있도록 하는 것입니다.

우리는 당신이 추론하기 쉽고 안전하고 통제된 동시성을 제공하는 직선 코드를 작성할 수 있기를 바랍니다.

우리가 추구하고 있는 이러한 행동을 달성하기 위해, 운영 체제는 스레드가 차단하지 않을 런타임 계약이 필요하며, 이는 언어가 우리에게 그것을 제공할 수 있는 경우에만 가능합니다.

따라서 스위프트의 동시성 모델과 그 주변의 의미는 이 목표를 염두에 두고 설계되었다.

이를 위해, 저는 런타임과 계약을 유지할 수 있는 스위프트의 언어 수준 기능 중 두 가지를 살펴보고 싶습니다.

첫 번째는 await의 의미론에서 비롯되고 두 번째는 Swift 런타임의 작업 종속성 추적에서 비롯됩니다.

예시 뉴스 애플리케이션의 맥락에서 이러한 언어 기능을 고려해 봅시다.

이것은 뉴스 피드 업데이트 결과를 처리하는 우리가 이전에 살펴봤던 코드 스니펫입니다.

대신 스위프트 동시성 프리미티브로 작성될 때 이 논리가 어떻게 생겼는지 봅시다.

우리는 먼저 도우미 기능의 비동기 구현을 만드는 것으로 시작할 것입니다.

그런 다음, 동시 디스패치 대기열에서 네트워킹 요청의 결과를 처리하는 대신, 여기서 우리는 동시성을 관리하기 위해 작업 그룹을 사용하고 있습니다.

작업 그룹에서, 우리는 업데이트가 필요한 각 피드에 대한 하위 작업을 만들 것입니다.

각 자식 작업은 공유 URLSession을 사용하여 피드의 URL에서 다운로드를 수행합니다.

그런 다음 다운로드 결과를 역직렬화하고, 기사로 포맷하고, 마지막으로 데이터베이스를 업데이트하기 위해 비동기 함수를 호출할 것입니다.

여기서, 비동기 함수를 호출할 때, 우리는 await 키워드로 주석을 다는 것이다.

"Meet async/await in Swift" 강연에서, 우리는 await가 비동기 대기라는 것을 배웠다.

즉, 비동기 함수의 결과를 기다리는 동안 현재 스레드를 차단하지 않습니다.

대신, 기능은 일시 중지될 수 있으며 스레드는 다른 작업을 실행하기 위해 해제될 것이다.

어떻게 이런 일이 일어나나요?

어떻게 실을 포기할 수 있나요?

내 동료 바룬은 이제 이것을 가능하게 하기 위해 스위프트 런타임에서 후드 아래에서 행해지는 일을 밝힐 것이다.

바룬 간디: 고마워, 로키니.

비동기 함수가 어떻게 구현되는지에 뛰어들기 전에, 비동기 함수가 어떻게 작동하는지 빠르게 재교육해 봅시다.

실행 중인 프로그램의 모든 스레드에는 함수 호출의 상태를 저장하는 데 사용하는 하나의 스택이 있습니다.

일단 한 스레드에 집중하자.

스레드가 함수 호출을 실행할 때, 새 프레임이 스택으로 푸시됩니다.

이 새로 생성된 스택 프레임은 함수에서 로컬 변수, 반환 주소 및 필요한 기타 정보를 저장하는 데 사용할 수 있습니다.

함수가 실행을 완료하고 반환하면, 스택 프레임이 팝업됩니다.

이제 비동기 함수를 고려해 봅시다.

updateDatabase 함수의 피드 유형에서 add(_:) 메소드를 호출하는 스레드를 가정합니다.

이 단계에서, 가장 최근의 스택 프레임은 add(_:)가 될 것이다.

스택 프레임은 서스펜션 지점에서 사용할 필요가 없는 로컬 변수를 저장합니다.

Add(_:)의 본문에는 await로 표시된 하나의 정지 지점이 있다.

지역 변수, id 및 기사는 그 사이에 정지 지점 없이 정의된 후 for 루프의 본문에서 즉시 사용됩니다.

그래서 그것들은 스택 프레임에 저장될 것이다.

또한, 힙에는 두 개의 비동기 프레임이 있을 것이며, 하나는 updateDatabase용이고 다른 하나는 추가용입니다.

비동기 프레임은 정지 지점에서 사용할 수 있어야 하는 정보를 저장합니다.

newArticles 인수는 대기 전에 정의되지만 대기 후에 사용할 수 있어야 합니다.

이것은 추가를 위한 비동기 프레임이 새로운 기사를 추적할 것이라는 것을 의미합니다.

스레드가 계속 실행된다고 가정해 봅시다.

저장 기능이 실행되기 시작하면, 추가를 위한 스택 프레임은 저장을 위한 스택 프레임으로 대체됩니다.

새로운 스택 프레임을 추가하는 대신, 미래에 필요한 모든 변수가 이미 비동기 프레임 목록에 저장되었기 때문에 가장 많은 스택 프레임이 대체됩니다.

저장 기능은 또한 사용을 위한 비동기 프레임을 얻는다.

기사가 데이터베이스에 저장되는 동안, 스레드가 차단되는 대신 유용한 작업을 할 수 있다면 더 좋을 것이다.

저장 함수의 실행이 중단되었다고 가정해 봅시다.

그리고 스레드는 차단되는 대신 다른 유용한 작업을 하기 위해 재사용됩니다.

정지 지점에서 유지되는 모든 정보는 힙에 저장되기 때문에, 나중 단계에서 실행을 계속하는 데 사용할 수 있습니다.

이 비동기 프레임 목록은 연속의 런타임 표현이다.

잠시 후, 데이터베이스 요청이 완료되었고, 일부 스레드가 해제되었다고 가정해 봅시다.

이것은 이전과 같은 스레드일 수도 있고, 다른 스레드일 수도 있다.

저장 기능이 이 스레드에서 실행을 재개한다고 가정해 봅시다.

실행을 완료하고 일부 ID를 반환하면, 저장을 위한 스택 프레임은 다시 추가를 위한 스택 프레임으로 대체됩니다.

그 후, 스레드는 zip 실행을 시작할 수 있다.

두 배열을 압축하는 것은 비동기 작업이므로, 새로운 스택 프레임을 만들 것이다.

스위프트는 운영 체제 스택을 계속 사용하기 때문에, 비동기 및 비동기 스위프트 코드 모두 C와 Objective-C를 효율적으로 호출할 수 있다.

게다가, C와 Objective-C 코드는 비동기 스위프트 코드를 효율적으로 호출할 수 있다.

Zip 기능이 완료되면, 스택 프레임이 터지고 실행이 계속됩니다.

지금까지, 나는 다른 작업을 하기 위해 스레드의 자원을 확보하면서 효율적인 중단과 재개를 보장하기 위해 await가 어떻게 설계되었는지 설명했다.

다음으로, Rokhini는 작업 간의 종속성을 추적하는 런타임인 제2언어 기능을 설명할 것이다.

로키니: 고마워, 바룬.

앞서 설명했듯이, 함수는 잠재적인 정지 지점으로도 알려진 대기에서 연속으로 나눌 수 있다.

이 경우, URLSession 데이터 작업은 비동기 함수이고 그 이후의 나머지 작업은 연속이다.

연속은 비동기 함수가 완료된 후에만 실행될 수 있다.

이것은 스위프트 동시성 런타임이 추적하는 종속성이다.

마찬가지로, 작업 그룹 내에서 부모 작업은 여러 자식 작업을 만들 수 있으며 부모 작업을 진행하기 전에 각 자식 작업을 완료해야 합니다.

이것은 작업 그룹의 범위에 의해 코드에서 표현되는 종속성이므로 스위프트 컴파일러와 런타임에 명시적으로 알려져 있습니다.

스위프트에서 작업은 연속 작업이든 자식 작업이든 스위프트 런타임에 알려진 다른 작업만 기다릴 수 있습니다.

따라서, 스위프트의 동시성 프리미티브로 구성된 코드는 런타임에 작업 간의 종속성 체인에 대한 명확한 이해를 제공한다.

지금까지, 당신은 스위프트의 언어 기능을 통해 기다리는 동안 작업을 일시 중지하는 방법을 배웠습니다.

대신, 실행 스레드는 작업 종속성에 대해 추론하고 대신 다른 작업을 선택할 수 있다.

이것은 스위프트 동시성으로 작성된 코드가 스레드가 항상 진행될 수 있는 런타임 계약을 유지할 수 있다는 것을 의미합니다.

우리는 Swift 동시성을 위한 통합 OS 지원을 구축하기 위해 이 런타임 계약을 활용했습니다.

이것은 기본 실행자로 Swift 동시성을 뒷받침하는 새로운 협력 스레드 풀의 형태이다.

새로운 스레드 풀은 CPU 코어가 있는 만큼의 스레드만 생성하여 시스템을 과도하게 커밋하지 않도록 합니다.

작업 항목이 차단될 때 더 많은 스레드를 생성하는 GCD의 동시 대기열과 달리, 스위프트 스레드는 항상 앞으로 나아갈 수 있다.

따라서, 기본 런타임은 얼마나 많은 스레드가 생성되는지 제어하는 데 신중할 수 있다.

이를 통해 과도한 동시성의 알려진 함정을 피하면서 애플리케이션에 필요한 동시성을 제공할 수 있습니다.

이전 WWDC에서 그랜드 센트럴 디스패치와의 동시성에 대해 이야기하면서, 우리는 애플리케이션을 별개의 하위 시스템으로 구성하고 하위 시스템당 하나의 직렬 디스패치 큐를 유지하여 애플리케이션의 동시성을 제어할 것을 권장했습니다.

이것은 스레드 폭발의 위험을 감수하지 않고 하위 시스템 내에서 하나보다 더 큰 동시성을 얻는 것이 어렵다는 것을 의미했습니다.

스위프트를 사용하면, 이 언어는 런타임이 활용한 강력한 불변성을 제공하여 기본 런타임에서 더 잘 제어되는 동시성을 투명하게 제공할 수 있습니다.

이제 스위프트 동시성의 스레딩 모델에 대해 조금 더 이해했으므로, 코드에 이러한 흥미로운 새로운 기능을 채택하는 동안 명심해야 할 몇 가지 고려 사항을 살펴보겠습니다.

명심해야 할 첫 번째 고려 사항은 동기 코드를 비동기 코드로 변환할 때 성능과 관련이 있습니다.

이전에, 우리는 스위프트 런타임의 추가 메모리 할당 및 논리와 같은 동시성과 관련된 비용에 대해 이야기했습니다.

따라서 코드에 동시성을 도입하는 비용이 관리 비용보다 클 때만 Swift 동시성으로 새 코드를 작성하도록 주의해야 합니다.

여기에 있는 코드 스니펫은 단순히 사용자의 기본값에서 값을 읽기 위해 자식 작업을 생성하는 추가 동시성으로 인해 실제로 도움이 되지 않을 수 있습니다.

이것은 아동 작업에 의해 수행된 유용한 작업이 작업을 만들고 관리하는 비용에 의해 줄어들기 때문이다.

따라서 Swift 동시성을 채택할 때 성능 특성을 이해하기 위해 Instruments 시스템 추적으로 코드를 프로파일링하는 것이 좋습니다.

두 번째로 주의해야 할 것은 기다림에 대한 원자성의 개념이다.

스위프트는 대기 전에 코드를 실행한 스레드가 연속을 선택할 동일한 스레드라는 것을 보장하지 않습니다.

사실, await는 작업이 자발적으로 일정이 해제될 수 있기 때문에 원자성이 깨졌다는 것을 나타내는 코드의 명시적인 지점입니다.

따라서, 당신은 자물쇠를 기다리지 않도록 조심해야 합니다.

마찬가지로, 스레드별 데이터는 대기 중에도 보존되지 않을 것이다.

스레드 지역성을 기대하는 코드의 모든 가정은 대기의 일시 중지 동작을 설명하기 위해 재검토되어야 합니다.

그리고 마지막으로, 최종 고려 사항은 스위프트의 효율적인 스레딩 모델의 기초가 되는 런타임 계약과 관련이 있다.

스위프트와 함께, 그 언어는 우리가 스레드가 항상 앞으로 나아갈 수 있는 런타임 계약을 유지할 수 있게 해준다는 것을 기억하세요.

우리가 스위프트의 기본 실행자가 되기 위해 협력 스레드 풀을 구축한 것은 이 계약을 기반으로 합니다.

스위프트 동시성을 채택할 때, 협력 스레드 풀이 최적으로 작동할 수 있도록 코드에서도 이 계약을 계속 유지하는 것이 중요합니다.

코드의 종속성을 명시적이고 알려진 안전한 프리미티브를 사용하여 협력 스레드 풀 내에서 이 계약을 유지할 수 있습니다.

Await, 액터 및 작업 그룹과 같은 Swift 동시성 프리미티브를 사용하면 이러한 종속성은 컴파일 시간에 알려집니다.

따라서, 스위프트 컴파일러는 이것을 시행하고 런타임 계약을 보존하는 데 도움을 줍니다.

Os_unfair_locks와 NSLocks와 같은 프리미티브도 안전하지만 사용할 때 주의가 필요합니다.

빡빡하고 잘 알려진 중요한 섹션 주변의 데이터 동기화에 사용될 때 동기 코드의 잠금을 사용하는 것이 안전합니다.

이것은 자물쇠를 잡고 있는 스레드가 항상 자물쇠를 해제하는 방향으로 앞으로 나아갈 수 있기 때문이다.

따라서, 프리미티브는 경합에서 짧은 기간 동안 스레드를 차단할 수 있지만, 앞으로 진행의 런타임 계약을 위반하지 않습니다.

스위프트 동시성 프리미티브와 달리, 잠금의 올바른 사용을 돕기 위한 컴파일러 지원이 없으므로, 이 프리미티브를 올바르게 사용하는 것은 당신의 책임입니다.

반면에, 세마포와 조건 변수와 같은 프리미티브는 스위프트 동시성과 함께 사용하기에 안전하지 않다.

이것은 그들이 스위프트 런타임에서 종속성 정보를 숨기지만, 코드에서 실행에 종속성을 도입하기 때문입니다.

런타임은 이 의존성을 알지 못하기 때문에, 올바른 스케줄링 결정을 내리고 해결할 수 없다.

특히, 구조화되지 않은 작업을 만든 다음 세마포어 또는 안전하지 않은 프리미티브를 사용하여 작업 경계를 넘어 종속성을 소급적으로 도입하는 프리미티브를 사용하지 마십시오.

이러한 코드 패턴은 스레드가 다른 스레드가 차단을 해제할 수 있을 때까지 세마포에 대해 무기한으로 차단할 수 있다는 것을 의미합니다.

이것은 스레드에 대한 순방향 진행의 런타임 계약을 위반한다.

코드베이스에서 안전하지 않은 프리미티브의 사용을 식별할 수 있도록, 다음 환경 변수로 앱을 테스트하는 것이 좋습니다.

이것은 순방향 진행의 불변성을 강제하는 수정된 디버그 런타임에서 앱을 실행합니다.

이 환경 변수는 여기에 표시된 것처럼 프로젝트 구성표의 실행 인수 창에서 Xcode에서 설정할 수 있습니다.

이 환경 변수로 앱을 실행할 때, 매달린 것으로 보이는 협동 스레드 풀의 스레드가 보이면 안전하지 않은 차단 프리미티브의 사용을 나타냅니다.

이제, 스레딩 모델이 스위프트 동시성을 위해 어떻게 설계되었는지에 대해 배웠으니, 이 새로운 세계에서 상태를 동기화하는 데 사용할 수 있는 프리미티브에 대해 조금 더 알아봅시다.

바룬: 배우에 대한 스위프트 동시성 토크에서 당신은 배우가 동시 액세스로부터 가변 상태를 보호하는 데 어떻게 사용될 수 있는지 보았습니다.

다르게 말하면, 배우들은 당신이 사용할 수 있는 강력한 새로운 동기화 프리미티브를 제공합니다.

배우가 상호 배제를 보장한다는 것을 기억하세요: 배우는 한 번에 최대 하나의 방법 호출을 실행할 수 있습니다.

상호 배제는 행위자의 상태에 동시에 접근하지 않아 데이터 경쟁을 방지한다는 것을 의미한다.

배우들이 다른 형태의 상호 배제와 어떻게 비교되는지 봅시다.

직렬 대기열에 동기화하여 일부 기사로 데이터베이스를 업데이트하는 이전 예를 고려하십시오.

대기열이 아직 실행되지 않았다면 우리는 경쟁이 없다고 말한다.

이 경우, 호출 스레드는 컨텍스트 스위치 없이 대기열에서 새 작업 항목을 실행하기 위해 재사용됩니다.

대신, 직렬 대기열이 이미 실행 중이라면 대기열이 경합 중이라고 한다.

이 상황에서, 호출 스레드가 차단됩니다.

이 차단 동작은 로히니가 대화의 앞부분에서 설명한 것처럼 스레드 폭발을 촉발시켰다.

자물쇠는 같은 행동을 한다.

차단과 관련된 문제 때문에, 우리는 일반적으로 당신이 디스패치 비동기를 사용하는 것을 선호한다고 조언했습니다.

비동기 디스패치의 주요 이점은 차단되지 않는다는 것이다.

그래서 논쟁 속에서도, 그것은 실 폭발로 이어지지 않을 것이다.

직렬 큐와 함께 디스패치 비동기를 사용하는 단점은 경합이 없을 때 호출 스레드가 다른 작업을 계속하는 동안 비동기 작업을 하기 위해 새 스레드를 요청해야 한다는 것입니다.

따라서, 디스패치 비동기의 빈번한 사용은 과도한 스레드 웨이크업과 컨텍스트 스위치로 이어질 수 있다.

이것은 우리를 배우로 데려온다.

스위프트의 배우들은 효율적인 스케줄링을 위해 협력 스레드 풀을 활용하여 두 세계의 최고를 결합한다.

실행되지 않는 액터에서 메소드를 호출할 때, 호출 스레드를 재사용하여 메소드 호출을 실행할 수 있습니다.

호출된 액터가 이미 실행 중인 경우, 호출 스레드는 실행 중인 기능을 일시 중지하고 다른 작업을 선택할 수 있습니다.

예시 뉴스 앱의 맥락에서 이 두 속성이 어떻게 작동하는지 살펴봅시다.

데이터베이스와 네트워킹 하위 시스템에 집중합시다.

스위프트 동시성을 사용하기 위해 애플리케이션을 업데이트할 때, 데이터베이스의 직렬 큐는 데이터베이스 액터로 대체될 것이다.

네트워킹을 위한 동시 대기열은 각 뉴스 피드에 대해 한 명의 배우로 대체될 수 있다.

간단히 말해서, 나는 여기에 스포츠 피드, 날씨 피드 및 건강 피드에 대한 세 명의 피드 배우만 보여줬지만, 실제로는 더 많은 것이 있을 것이다.

이 배우들은 협동 스레드 풀에서 달릴 것이다.

피드 액터들은 데이터베이스를 상호 작용하여 기사를 저장하고 다른 작업을 수행합니다.

이 상호 작용은 한 배우에서 다른 배우로의 실행 전환을 포함한다.

우리는 이 과정을 배우 호핑이라고 부른다.

배우 호핑이 어떻게 작동하는지 논의해 봅시다.

스포츠 피드의 배우가 협동 풀의 스레드에서 실행되고 있으며, 일부 기사를 데이터베이스에 저장하기로 결정했다고 가정해 봅시다.

현재로서는, 데이터베이스가 사용되지 않고 있다는 것을 고려해 봅시다.

이것은 논쟁의되지 않은 사건이다.

스레드는 스포츠 피드 배우에서 데이터베이스 배우로 직접 이동할 수 있다.

여기서 주목해야 할 두 가지가 있다.

첫째, 배우들을 호핑하는 동안 스레드가 차단되지 않았다.

둘째, 호핑은 다른 스레드가 필요하지 않았습니다. 런타임은 스포츠 피드 액터의 작업 항목을 직접 중단하고 데이터베이스 액터의 새로운 작업 항목을 만들 수 있습니다.

데이터베이스 액터가 한동안 실행되었지만 첫 번째 작업 항목을 완료하지 않았다고 가정해 봅시다.

이 순간, 날씨 피드 액터가 데이터베이스에 일부 기사를 저장하려고 한다고 가정해 봅시다.

이것은 데이터베이스 액터의 새로운 작업 항목을 만든다.

배우는 상호 배제를 보장함으로써 안전을 보장한다; 기껏해야, 하나의 작업 항목이 주어진 시간에 활성화될 수 있다.

이미 하나의 활성 작업 항목인 D1이 있기 때문에, 새로운 작업 항목인 D2는 보류 상태로 유지될 것이다.

배우들도 차단하지 않는다.

이 상황에서, 날씨 피드 액터가 정지될 것이고 그것이 실행하고 있던 스레드는 이제 다른 작업을 할 수 있도록 해방될 것이다.

잠시 후, 초기 데이터베이스 요청이 완료되므로 데이터베이스 액터의 활성 작업 항목이 제거됩니다.

이 시점에서, 런타임은 데이터베이스 액터에 대한 보류 중인 작업 항목 실행을 시작하도록 선택할 수 있다.

아니면 피드 배우 중 한 명을 재개하기로 선택할 수도 있다.

또는 그것은 해방된 스레드에서 다른 작업을 할 수 있다.

많은 비동기 작업, 특히 많은 경합이 있을 때, 시스템은 어떤 작업이 더 중요한지에 따라 절충을 해야 한다.

이상적으로, 사용자 상호 작용과 관련된 우선 순위가 높은 작업은 백업 저장과 같은 백그라운드 작업보다 우선할 것이다.

배우들은 재진입의 개념으로 인해 시스템이 작업의 우선 순위를 잘 정할 수 있도록 설계되었다.

하지만 여기서 재진자가 왜 중요한지 이해하려면, 먼저 GCD가 우선순위를 어떻게 처리하는지 살펴봅시다.

시리얼 데이터베이스 대기열이 있는 원본 뉴스 애플리케이션을 고려해 보세요.

데이터베이스가 UI를 업데이트하기 위해 최신 데이터를 가져오는 것과 같은 우선 순위가 높은 작업을 받는다고 가정해 봅시다.

또한 데이터베이스를 iCloud에 백업하는 것과 같은 우선 순위가 낮은 작업을 받습니다.

이것은 어느 시점에서 이루어져야 하지만, 반드시 즉시 이루어져야 하는 것은 아니다.

코드가 실행됨에 따라, 새로운 작업 항목이 생성되고 일부 인터리브 순서로 데이터베이스 대기열에 추가됩니다.

디스패치 대기열은 엄격한 선입선출 순서로 받은 항목을 실행합니다.

불행히도, 이것은 항목 A가 다섯 개의 우선 순위가 낮은 항목을 실행한 후 다음 우선 순위가 높은 항목으로 가기 전에 실행해야 한다는 것을 의미합니다.

이것은 우선순위 반전이라고 불린다.

직렬 대기열은 우선 순위가 높은 작업보다 앞서 대기열의 모든 작업의 우선 순위를 높임으로써 우선 순위 반전을 해결합니다.

실제로, 이것은 대기열에 있는 작업이 더 빨리 끝날 것이라는 것을 의미한다.

그러나, 그것은 주요 문제를 해결하지 못하는데, 이는 항목 B가 실행을 시작하기 전에 여전히 완료해야 한다는 것이다.

이 문제를 해결하려면 엄격한 선입선출에서 의미론적 모델을 변경해야 한다.

이것은 우리를 배우 재진주로 이끈다.

예를 들어 reentrancy가 주문과 어떻게 연결되어 있는지 살펴봅시다.

스레드에서 실행되는 데이터베이스 액터를 고려하세요.

그것이 중단되고, 작업을 기다리고 있고, 스포츠 피드 배우가 그 스레드에서 실행하기 시작한다고 가정해 봅시다.

잠시 후, 스포츠 피드 액터가 데이터베이스 액터에게 전화를 걸어 기사를 저장한다고 가정해 봅시다.

데이터베이스 액터가 논쟁되지 않기 때문에, 스레드는 보류 중인 작업 항목이 하나 있음에도 불구하고 데이터베이스 액터로 이동할 수 있다.

저장 작업을 수행하기 위해, 데이터베이스 액터에 대한 새로운 작업 항목이 생성될 것이다.

이것이 배우 재진행이 의미하는 바이다; 배우에 대한 새로운 작업 항목은 하나 이상의 오래된 작업 항목이 중단되는 동안 진행될 수 있다.

배우는 여전히 상호 배제를 유지한다: 기껏해야 하나의 작업 항목이 주어진 시간에 실행될 수 있다.

얼마 후, D2 항목은 실행을 마칠 것이다.

D2가 D1 이후에 만들어졌음에도 불구하고 D1 이전에 실행을 마쳤다는 것을 주목하세요.

따라서, 배우 재입국에 대한 지원은 배우가 엄격하게 선입선출이 아닌 순서로 항목을 실행할 수 있다는 것을 의미합니다.

시리얼 큐 대신 데이터베이스 액터로 이전 예제를 다시 살펴봅시다.

먼저, 우선 순위가 높기 때문에 작업 항목 A가 실행될 것이다.

일단 그것이 완료되면, 이전과 같은 우선순위 반전이 있다.

배우들은 재진출을 위해 설계되었기 때문에, 런타임은 우선순위가 낮은 항목보다 우선 순위가 높은 항목을 대기열의 맨 앞으로 이동하도록 선택할 수 있다.

이렇게 하면, 우선순위가 높은 작업이 먼저 실행될 수 있고, 우선순위가 낮은 작업은 나중에 실행될 수 있다.

이것은 우선 순위 반전 문제를 직접 해결하여 보다 효과적인 스케줄링과 자원 활용을 가능하게 한다.

나는 협동 풀을 사용하는 배우들이 상호 배제를 유지하고 작업의 효과적인 우선 순위를 지원하기 위해 어떻게 설계되었는지에 대해 조금 이야기했다.

또 다른 종류의 배우, 주요 배우가 있으며, 그 특성은 시스템의 기존 개념인 메인 스레드를 추상화하기 때문에 다소 다르다.

배우를 사용하는 예시 뉴스 앱을 고려해 보세요.

사용자 인터페이스를 업데이트할 때, MainActor와 전화를 걸어야 합니다.

메인 스레드가 협동 풀의 스레드와 분리되어 있기 때문에, 컨텍스트 전환이 필요합니다.

코드 예제와 함께 이것의 성능 영향을 살펴봅시다.

데이터베이스에서 기사를 로드하고 각 기사의 UI를 업데이트하는 MainActor의 기능 updateArticles가 있는 다음 코드를 고려하십시오.

루프의 각 반복에는 적어도 두 개의 컨텍스트 스위치가 필요합니다: 하나는 메인 액터에서 데이터베이스 액터로 건너뛰고 다른 하나는 다시 뛸 수 있습니다.

그러한 루프의 CPU 사용량이 어떻게 생겼는지 봅시다.

각 루프 반복에는 두 개의 컨텍스트 스위치가 필요하기 때문에, 두 개의 스레드가 짧은 시간 동안 차례로 실행되는 반복 패턴이 있습니다.

루프 반복의 수가 적고, 각 반복에서 상당한 작업이 수행되고 있다면, 그것은 아마도 괜찮을 것이다.

그러나, 실행이 주요 배우를 자주 켜고 끄면, 스레드 전환의 오버헤드가 추가되기 시작할 수 있다.

애플리케이션이 컨텍스트 전환에 많은 시간을 소비하는 경우, 메인 액터의 작업이 일괄 처리되도록 코드를 재구성해야 합니다.

루프를 loadArticles 및 updateUI 메소드 호출에 푸시하여 일괄 작업을 할 수 있으며, 한 번에 하나의 값 대신 배열을 처리하도록 합니다.

일괄 처리 작업은 컨텍스트 스위치의 수를 줄인다.

협동 풀에서 배우들 사이를 호핑하는 것은 빠르지만, 앱을 작성할 때 주요 배우와의 홉을 염두에 두어야 합니다.

돌이켜보면, 이 강연에서 당신은 비차단 서스펜션 메커니즘인 협동 스레드 풀의 설계부터 액터가 구현되는 방식에 이르기까지 시스템을 가장 효율적으로 만들기 위해 우리가 어떻게 노력했는지 배웠습니다.

각 단계에서, 우리는 당신의 애플리케이션의 성능을 개선하기 위해 런타임 계약의 일부 측면을 사용하고 있습니다.

우리는 당신이 이 놀라운 새로운 언어 기능을 사용하여 명확하고 효율적이며 즐거운 스위프트 코드를 작성하는 방법을 보게 되어 기쁩니다.

시청해 주셔서 감사드리며 멋진 WWDC를 보내십시오.

♪