10109

안녕하세요, 제 이름은 토니이고, 저는 재단 팀의 엔지니어입니다.

"재단의 새로운 기능"에 오신 것을 환영합니다. 재단 프레임워크는 모든 앱과 프레임워크에 대한 기본 기능을 제공합니다.

그것은 파일 처리에서 네트워킹 및 알림에 이르기까지 모든 것을 포함하여 많은 기능을 가지고 있습니다.

오늘 저는 모든 앱에 필요한 것에 집중하고 싶습니다: 국제화와 현지화.

올해 출시에서, 우리는 이 API에서 가장 큰 발전 중 일부를 가지고 있다.

우리는 낮은 수준에서 시작했고, 스위프트에서 귀속된 문자열이 무엇인지 다시 생각했다.

우리는 Swift용 포맷터를 재구성하여 더 빠르고, 사용하기 쉽고, 새로운 기능을 추가했습니다.

그리고 마지막으로, 우리는 자동 문법 계약이라는 새로운 기능을 가지고 있다.

그것은 당신이 제공해야 하는 현지화된 문자열의 수를 극적으로 줄이는 동시에 코드를 더 간단하게 만듭니다.

귀속된 문자열로 바로 뛰어들자.

귀속 문자열은 문자, 범위 집합 및 사전의 조합이다.

속성 문자열을 사용하면 키-값 쌍인 속성을 문자열의 특정 범위에 연결할 수 있습니다.

가장 일반적인 속성은 SDK에 의해 정의되지만, 자신만의 속성을 만들 수도 있습니다.

리치 텍스트를 지원하는 API에서 속성 문자열을 종종 찾을 수 있습니다.

예를 들어 봅시다.

여기 제가 작업하고 있는 카페라는 앱이 있습니다.

그건 간단한 메뉴야.

나는 내가 원하는 음식, 크기, 양을 고른다.

그리고 마지막에, 그것은 내가 주문한 모든 것의 목록이 있는 영수증을 보여준다.

여기 하단에, 나는 짧은 감사 메모를 추가하기로 결정했다.

이것은 귀속된 문자열이다.

문자열의 일부는 굵게 표시되어 있고 일부는 이탤릭체로 되어 있다.

마지막 단어에도 링크가 있다.

여기서 알 수 있듯이, 속성은 겹칠 수 있습니다.

재단이 시작된 이래로, 우리는 NSAttributedString이라는 참조 유형을 가지고 있었다.

올해, 우리는 스위프트가 제공하는 모든 기능을 최대한 활용하는 새로운 구조체 AttributedString을 소개합니다.

무엇보다도, 그것은 가치 유형이다.

그것은 또한 스위프트 스트링과 같은 문자 계산 동작을 가지고 있다.

포괄적인 소프트웨어를 쉽게 작성하기 위한 노력의 일환으로, AttributedString은 이제 완전히 현지화할 수 있습니다.

마지막으로, 그것은 안전과 보안을 염두에 두고 만들어졌다.

여기에는 강력한 타이핑을 사용하여 컴파일 시간 안전과 Codable을 사용하여 보관하지 않는 동안의 안전이 모두 포함됩니다.

새로운 AttributedString으로 무엇을 할 수 있는지 간략하게 살펴봅시다.

우리는 감사의 메시지를 만들 것입니다.

먼저, 우리는 간단한 이니셜라이저를 사용하여 속성 문자열을 만듭니다.

이 전체 문자열에 속성을 설정하고 싶습니다.

그것은 글꼴 속성을 설정하는 것만큼 간단합니다.

Struct AttributedString에서는 모든 속성을 직접 사용할 수 있으며 올바른 유형을 사용합니다.

예를 들어, 이 속성은 SwiftUI 글꼴이다.

다음으로, 우리는 또 다른 속성 문자열을 만듭니다.

이것은 우리 웹사이트에 대한 참조이므로, 우리는 링크 속성을 URL로 설정했습니다.

여기서 저는 전체 문자열에 글꼴과 링크를 설정하고 있습니다.

우리는 나중에 문자열의 일부만 변경하는 방법을 살펴볼 것이다.

또 다른 유용한 도구는 속성 컨테이너이다.

문자열 없이 속성과 값을 자체적으로 유지할 수 있는 곳입니다.

여기서, 저는 제 메시지의 중요성에 따라 컨테이너를 만들고 몇 가지 속성을 설정합니다.

그리고 마지막으로, 나는 그 속성을 두 속성 문자열로 병합한다.

내가 언급했듯이, 귀속 문자열은 문자, 범위 및 사전의 조합이다.

귀속된 문자열 자체는 그러한 것들 중 하나의 모음이 아니다.

대신, 이러한 속성에 접근하기 위해, 그것은 우리가 견해라고 부르는 것을 가지고 있다.

가장 중요한 두 가지 견해는 문자열에 대한 액세스를 제공하는 문자와 속성에 대한 액세스를 제공하는 실행이다.

이러한 뷰는 스위프트 컬렉션이며, 이는 배열과 같은 유형에서 익숙한 기능을 여기에서도 사용할 수 있음을 의미합니다.

또 다른 예를 살펴봅시다.

디자이너들이 우리에게 모든 구두점을 재미있는 오렌지색으로 만들어 감사 메시지에 약간의 피자를 추가하라고 말했다고 가정해 봅시다.

이렇게 하려면, 먼저 귀속 문자열에서 구두점이 어디에 있는지 찾아야 합니다.

다른 스위프트 컬렉션과 마찬가지로, 속성 문자열 뷰는 단순히 컬렉션의 일부 요소의 위치인 인덱스를 사용합니다.

인덱스로 반복하기 위해, 나는 표준 라이브러리 인덱스 함수를 사용한다.

다음으로, 저는 이 문자가 우리가 변경해야 하는 문자인지 확인하기 위해 isPunctuation 함수를 사용합니다.

마지막으로, 나는 속성 문자열인 슬라이싱의 또 다른 기능을 사용하여 전체 문자열의 하위 범위에만 속성을 적용한다.

범위는 이 인덱스에서 시작하여 그 이후의 다음 인덱스까지 계속되므로, 한 문자입니다.

그리고 이제 구두점은 주황색이다.

다른 관점을 보자, 달린다.

실행은 특정 속성의 시작 위치, 길이 및 값이다.

우리는 메시지의 모든 실행을 세는 것으로 시작할 수 있다.

이것은 문자열에서 속성 값의 각 연속 범위를 반복할 것이다.

이 줄에는 네 번의 실행이 있다.

각 실행에는 각 속성에 대한 값 또는 nil이 있습니다.

문자와 실행의 범위는 서로 교환할 수 있으므로, 속성 또는 그 반대의 경우도 마찬가지입니다.

여기서 저는 문자 보기의 첨자에서 속성 범위를 사용하여 결과를 독립형 문자열로 변환합니다.

특정 속성에 집중하여 달리기를 보는 것이 가장 유용하다.

여기서, 우리는 링크 속성만을 위해 결합하기 위해 키 경로 링크를 사용합니다.

결과 컬렉션의 각 요소는 문자열에서 설정할 수 있는 다른 속성을 고려하지 않고 링크 속성의 값을 제공합니다.

링크만 보면, 세 가지 실행이 있습니다: 첫 번째는 설정되지 않은 곳; 두 번째는 값으로 설정된 곳; 그리고 세 번째는 다시 설정되지 않은 문장의 마지막 마침표입니다.

실행을 반복하는 것은 우리에게 값과 범위의 튜플을 제공한다.

값은 유형이 안전하기 때문에, 잘못된 유형을 갖는 것에 대해 캐스팅하거나 걱정하지 않고 URL에 존재하는 구성표와 같은 API를 사용할 수 있습니다.

여기서 나는 귀속된 문자열의 모든 링크가 https인지 확인하고 있다.

또 다른 유용한 기술은 부분 문자열을 찾고 그 범위를 사용하여 문자나 속성을 편집하는 것이다.

"방문"이라는 단어를 좀 더 후퇴적인 분위기의 무언가로 바꾸고 싶다고 가정해 봅시다.

먼저, 나는 부분 문자열의 범위를 찾아본다.

다음으로, 나는 그 범위를 사용하여 그 하위 범위에서만 속성과 문자를 설정한다.

결과는 이와 같이 여섯 번의 실행이 있는 귀속 문자열이다.

다음으로, 현지화에 대해 이야기해 봅시다.

AttributedString은 완전히 현지화할 수 있다.

우리는 또한 Objective-C에서 NSAttributedString에 현지화 지원을 추가했습니다.

속성 문자열은 일반 문자열과 마찬가지로 앱의 문자열 파일에 있습니다.

Swift에서는 이제 SwiftUI의 텍스트 보기와 마찬가지로 문자열 보간을 사용하여 String 및 AttributedString의 현지화된 서식을 지원합니다.

여기 간단한 예시가 있습니다.

이 함수는 사용자의 문서 이름으로 사용자 정의된 현지화된 문자열을 반환합니다.

%@ 또는 %d와 같은 형식 지정자를 사용하고 형식 함수를 호출하는 대신, 이제 값을 직접 전달할 수 있습니다.

같은 접근 방식이 AttributedString에도 효과가 있다.

Xcode는 컴파일러를 사용하여 이 새로운 이니셜라이저에서 문자열 파일을 생성할 수 있습니다.

그것을 켜려면, 빌드 설정으로 가서, 현지화 설정을 찾고, 컴파일러를 사용하여 스위프트 문자열을 추출하세요.

현지화된 속성 문자열이 어떻게 속성을 얻는지 궁금할 것입니다.

AttributedString에 Markdown에 대한 지원을 추가했다는 것을 알려드리게 되어 기쁩니다.

다음은 SwiftUI 텍스트에서 바로 현지화된 속성 문자열을 사용하는 예입니다.

나는 그냥 평범한 줄로 시작한다.

텍스트 주위에 두 개의 별표를 추가함으로써, 나는 SwiftUI가 굵게 렌더링하는 것을 강하게 강조한다.

SwiftUI가 이탤릭체로 렌더링하는 텍스트를 강조하기 위해 밑줄을 사용할 수 있습니다.

우리는 또한 링크를 지원합니다.

이것은 로컬라이저가 다른 언어에 대한 맞춤형 URL을 제공할 수 있는 좋은 기회이다.

우리는 또한 취소선과 코드 음성과 같은 다른 인라인 스타일을 지원합니다.

마지막으로, 귀속된 문자열을 보관하는 것에 대해 이야기해 봅시다.

먼저, 우리는 NSAttributedString 참조 유형으로 변환할 수 있는 능력이 필요합니다.

속성 문자열은 데이터 모델의 일부가 될 수 있으며, 이는 우리가 그것들을 인코딩하고 디코딩할 수 있어야 한다는 것을 의미합니다.

마지막으로, 우리는 Markdown에서 사용자 지정 속성을 지정하는 방법을 원합니다.

이 작업들은 모두 서로 관련이 있다.

전환을 살펴보는 것부터 시작합시다.

우리는 모두 NSAttributedString을 사용하는 많은 코드를 작성했기 때문에 구조체에서 클래스 유형으로 쉽게 변환할 수 있도록 했습니다.

다음은 NSAttributedString 속성이 있는 보기입니다.

변환하려면, 구조체 AttributedString을 NSAttributedString 이니셜라이저에 전달하기만 하면 됩니다.

SDK의 일부인 속성의 경우, 이것이 내가 해야 할 전부이다.

이제 인코딩과 디코딩을 살펴봅시다.

여기 카페 앱의 영수증을 보관하고 있는 구조체가 있습니다.

다시 말하지만, 저는 SwiftUI, UIKit, AppKit 및 Foundation에서 제공하는 속성을 사용하고 있습니다.

그것은 AttributedString의 기본 코딩 가능한 구현이 내가 필요한 전부라는 것을 의미한다.

난 그냥 영수증에 코딩 가능한 적합성을 추가했고, 난 끝났어.

조금 더 나아가 사용자 지정 속성 인코딩에 대한 지원을 추가해 봅시다.

우리는 속성 자체에 대해 이야기하는 것으로 시작할 것이다.

속성은 두 부분이다: 키와 값.

키는 새로운 AttributedStringKey 프로토콜을 준수하는 유형이다.

그것은 필요한 가치의 유형과 보관을 위한 이름을 정의한다.

이 키는 또한 값이 인코딩되거나 디코딩되는 방법을 사용자 정의하기 위해 다른 프로토콜을 준수할 수 있습니다.

여분의 색상을 갖도록 귀속된 문자열의 범위를 정의하고 싶다고 가정해 봅시다.

이 무지개 효과는 세 단계로 나선다: 평범하거나, 재미있거나, 극단적이다.

우리는 열거형을 사용하여 그 값을 나타내고 이름을 무지개로 설정할 것이다.

유형과 이름을 정의하는 것이 이 프로토콜의 유일한 요구 사항이다.

이제, 인코딩된 속성 문자열의 일부가 되도록 이 속성을 코딩할 수 있다고 가정해 봅시다.

내가 해야 할 일은 이렇게 코딩 가능한 적합성을 추가하는 것뿐이다.

마지막으로, 무지개 레벨이 현지화된 문자열의 일부가 되기를 원한다고 가정해 봅시다.

그것은 그것이 어디에 있든, 어떤 언어로든 문자열의 오른쪽 부분에 적용될 수 있다는 것을 의미한다.

우리가 필요한 것은 선택할 수 있는 프로토콜 적합성을 하나 더하는 것이다.

속성이 마크다운을 디코딩할 수 있다고 말할 때, 마크다운에서 바로 디코딩하고 속성 문자열에 삽입할 수 있습니다.

필요한 것은 그 가치가 코딩 가능하다는 것이다.

다음으로, 마크다운의 사용자 지정 속성 구문을 살펴봅시다.

이 첫 번째 예에서, 우리는 링크에 대한 참조가 있다.

링크 텍스트에는 대괄호를 사용하고 링크 대상 URL에는 괄호를 사용합니다.

이 두 번째 예에서, 우리는 이미지에 대한 참조가 있다.

느낌표로 시작한 다음, 이미지 설명에는 대괄호를 사용하고 이미지 소스에는 괄호를 사용합니다.

이 처음 두 가지 예는 마크다운에서 일반적이다.

세 번째 예는 사용자 지정 속성에 대한 구문을 보여줍니다.

그것은 대괄호로 시작한 다음, 텍스트에는 대괄호를 사용하고, 속성에는 괄호를 사용합니다.

속성은 JSON 5로 표시됩니다.

JSON 5는 JSON과 호환되며 인용되지 않은 키, 주석 및 기타 몇 가지 기능을 허용합니다.

이것은 이와 같은 인간 친화적인 끈과 잘 어울린다.

우리는 또한 재단의 다른 JSON API에 JSON 5 지원을 추가했습니다.

사용자 지정 속성은 JSON을 사용하기 때문에, JSONDecoder로 디코딩할 수 있는 모든 것은 새로운 사용자 지정 마크다운 구문과 자동으로 호환됩니다.

여기에는 하나의 속성, 두 개의 속성, 하나의 문자열과 하나의 숫자, 그리고 여러 속성이 있는 단일 속성이 있습니다.

여기에 한 가지 추가 조각이 있는데, 이는 Markdown에서 이 이름들을 Swift 유형에 연결하는 방법입니다.

그 작품은 속성 범위라고 불린다.

범위는 속성 키의 그룹이다.

범위는 우리가 찾을 것으로 예상되는 속성, 이름 및 디코딩 방법을 알려주기 때문에 JSON 또는 Markdown에서 디코딩할 때 유용합니다.

우리는 Foundation, UIKit, AppKit 및 SwiftUI에 대해 각각 하나의 범위를 정의합니다.

당신은 또한 자신의 속성의 범위를 정의할 수 있습니다.

카페 앱의 범위를 정의해 봅시다.

우리는 AttributeScopes 내부의 범위를 중첩하고 AttributeScope 프로토콜에 준수할 것입니다.

그런 다음 우리가 해야 할 일은 범위 내의 속성을 "let"로 나열하는 것입니다. 지금까지, 우리는 우리의 무지개 속성을 가지고 있다.

다음으로, 우리는 우리 안에 SwiftUI 범위를 포함할 것이다.

그것은 우리 자신 외에도 그 모든 속성을 허용한다.

스코프는 재귀적으로 둥지를 틀기 때문에, 이것은 또한 기초 속성을 포함한다.

우리의 새로운 범위에 대한 속성을 정의하는 것은 유용하다.

그것은 우리가 범위를 인수로 사용하는 함수에서 키 경로 구문을 사용할 수 있게 해준다.

마지막으로, 이제 사용자 지정 마크다운에서 현지화되고 다채로운 속성 문자열을 로드할 수 있습니다.

또한 NSAttributedString으로의 보관 및 변환을 위한 범위 수행 기능을 찾을 수 있습니다.

이것은 모든 단계에서 행동을 맞춤화할 수 있게 해준다.

다음은 제목에서 사용자 지정 무지개 속성을 볼 수 있는 카페 앱의 첫 번째 화면입니다.

현지화된 문자열이 Markdown에서 속성 문자열로 변환된 후, 앱은 속성을 찾고 문자열의 범위에 재미있는 효과를 적용합니다.

속성은 현지화된 문자열 파일에서 나오기 때문에, 이것은 스페인어와 같이 Caffé가 지원하는 모든 언어에서 올바르게 작동합니다.

하지만 우리는 이제 막 시작했어.

우리는 또한 완전히 새로운 Formatter API를 가지고 있습니다.

포맷터는 또 다른 오랜 재단 기능이다.

그들은 숫자, 날짜, 시간 등과 같은 데이터를 지역화되고 사용자가 제시할 수 있는 문자열로 변환할 책임이 있다.

포맷터는 꽤 많은 구성 데이터로 뒷받침되므로, 캐시하고 재사용하는 일반적인 패턴이다.

그러나, 앱은 많은 뚜렷한 코드로 구성되어 있다.

그들 모두 사이에 포맷터를 공유하는 것이 항상 말이 되지 않을 수도 있다.

또한, 사람들이 날짜와 시간을 읽는 다양한 방법, 그리고 앱 작성자로서 우리의 디자인에 맞는 방식으로 이 데이터를 제시하고자 하는 우리의 열망 때문에, 엣지 케이스에 대한 많은 기회가 있습니다.

올해, 우리는 Formatter API를 처음부터 재고하여 성능과 유용성을 모두 개선했습니다.

간단히 말해서, 우리의 새로운 API는 형식에 초점을 맞추고 있다.

캐싱 패턴이 작동하는 것을 볼 수 있는 지진 샘플 앱에서 이 코드를 살펴봅시다.

그것은 2단계 과정을 가지고 있다.

먼저, 포맷터를 만들고 구성하세요.

다음으로, 포맷터에게 우리의 날짜를 주고 문자열을 받으세요.

어떻게 그게 더 간단할 수 있어?

음, 우리만의 날짜 포맷터를 만들기 위한 요구 사항을 제거하는 것으로 시작합시다.

이것이 캐시되어야 한다는 것을 잊기 정말 쉬웠고, 이는 테이블의 모든 셀에 대해 동일한 포맷터를 다시 만들 수 있었다.

다음으로, 포맷 단계.

포맷터를 통해 날짜를 전달하는 대신, 날짜 자체를 사용합시다.

이제 그것은 단지 한 줄의 코드일 뿐이다.

원하는 형식을 지정하면, 그게 다야.

이 숫자 형식에 대해 더 이야기해 봅시다.

그것은 많은 코드는 아니지만, 약간의 복잡성을 숨기고 있으며 알아야 할 몇 가지 함정이 있다.

인수가 부동 소수점 숫자가 아니라면, 여기서 완전히 잘못된 출력을 얻을 수 있습니다.

독자는 문자열 상수인 수정자 집합과 함께 부동 소수점 숫자를 포맷하기 위한 특별한 경우 구문을 알고 있어야 합니다.

우리는 이 코드가 이해하고, 유지하고, 읽기가 더 쉽다고 생각한다.

그것은 일반 스위프트 함수를 사용하여 숫자를 어떻게 포맷할지 정확히 지정합니다.

당신은 또한 자동 완성과 유형 안전을 얻을 수 있습니다.

우리는 이 새로운 접근 방식을 재단의 모든 10명의 포맷터에게 적용했습니다.

우리는 인터페이스를 정리하고 단순화했으며, 일반적인 함정을 피하기 위해 변경했으며, 그 과정에서 많은 새로운 기능을 추가했습니다.

가장 인기 있는 두 가지 형식 유형인 날짜와 숫자를 자세히 살펴봅시다.

날짜 포맷은 달력과 시간대를 사용하여 절대 시점을 인간이 날짜로 이해하는 것으로 변환하는 것이다.

그리고 그 이상으로, 그것은 인간이 자신의 데이트가 어떻게 보이는지 좋아하는지에 대한 모든 선호도를 고려한다.

우리는 그 선호도를 로케일이라고 부른다.

날짜를 포맷하는 데 필요한 소량의 코드를 살펴봅시다.

먼저, 나는 Date.now를 사용하여 현재 시점을 얻을 것이다.

다음으로, 나는 포맷된 함수를 부른다.

그게 다야.

물론, 우리가 방금 예시에서 보았듯이, 날짜 포맷은 많은 옵션이 있는 것이다.

그러니 이것을 조금 확장해 봅시다.

포맷된 기능은 날짜 또는 시간만 표시하도록 구성할 수 있습니다.

두 주장 모두 선택할 수 있는 몇 가지 옵션이 있다.

이 새로운 서식 API의 중요한 목표는 올바른 형식을 만드는 데 가능한 한 많은 컴파일 시간을 제공하는 것입니다.

마법의 문자열 값을 사용하여 포맷하는 것은 함정을 만드는 것으로 악명이 높으며, 정상적인 상황에서는 형식이 올바르게 보이지만 연말과 같이 가장자리의 경우 완전히 잘못된 값을 생성합니다.

여기 다시 우리의 기본 형식이 있습니다.

이것은 이와 같이 날짜와 시간 스타일을 묻는 짧은 버전이다.

논픽과 간단한 스타일 버전 모두에 대해, 우리는 당신을 위한 기본 형식을 선택합니다.

하지만, 정말로 날짜를 사용자 정의하고 싶다면, 여기서 가서 관심 있는 필드를 추가하세요.

이 예시에서, 나는 스타일에 필드를 추가하여 형식을 구축한다.

나는 해, 일, 달만 원해.

다른 가능성은 시간, 분, 초 등을 포함한다.

출력 형식은 사용자의 로케일에 따라 자동으로 조정됩니다.

이 필드들도 구성할 수 있다.

이 경우, 나는 월을 넓은 형식으로 변경하는데, 이는 전체 월 이름이 인쇄된다는 것을 의미한다.

이 API를 사용하면 날짜의 일부만 포맷하는 것도 쉽습니다.

여기서 나는 그냥 평일을 보내고 싶어.

날짜도 다른 스타일로 포맷할 수 있다.

여기서 저는 ISO 8601 형식과 iso8601을 사용하기로 선택하지만, 연도, 월, 일만 사용하고 대시로 구분합니다.

이러한 예시로, 서식 패턴이 명확해진다.

우리는 포맷하고 싶은 값으로 시작한다.

우리는 포맷된 함수를 부르고 인수는 스타일이다.

각 유형마다 하나 이상의 스타일이 있을 수 있다.

예를 들어, 날짜에는 dateTime과 iso8601이 모두 있다.

스타일은 기본 구성에서 사용하거나 사용자 정의할 수 있습니다.

이 포맷 API는 필드 목록을 지정하여 작동하며, 그 중 일부는 추가 옵션이 있습니다.

당신이 제공하는 필드의 순서는 중요하지 않습니다.

각 필드는 포맷터에게 최종 출력 어딘가에 어떤 값이 포함되어야 하는지 알려줍니다.

우리는 인수가 없거나 스타일 이름만 있는 가장 짧은 버전의 API에 대해 합리적인 기본값을 선택합니다.

필드를 추가하기 시작하면, 출력은 사용자 정의되고 UI의 자리 표시자 텍스트와 같이 표시하기로 선택한 것만 반영합니다.

또한 서로 상대적인 두 날짜를 포맷하기 위한 새로운 API가 있다.

여기 몇 가지 예가 있습니다.

먼저, 범위 내에서 두 개의 날짜를 포맷하세요.

두 개의 날짜와 함께 일반 스위프트 범위 구문을 사용할 수 있습니다.

포맷 범위는 우리가 단일 날짜로 했던 것처럼 날짜와 시간을 표시하는 구성을 허용합니다.

이 범위를 기간이나 구성 요소 또는 현재에 대한 단일 날짜로 포맷할 수 있습니다.

포맷의 또 다른 새로운 기능은 출력에 기인한다.

이를 통해 사용자의 선호도에 맞게 재정렬한 후 포맷터가 포맷된 값의 특정 부분을 넣은 위치를 찾을 수 있습니다.

물론, 이것은 우리의 새로운 구조체 AttributedString을 사용한다.

포맷된 출력에 스타일링을 적용하는 것은 모든 종류의 장소에 나타난다.

watchOS에서, 많은 합병증은 포맷된 문자열이다.

Apple Watch는 개인용 장치이기 때문에 사용자의 선호도를 고려하는 것이 중요하지만, 날짜의 일부에 사용자가 선택한 색상을 제공하는 것과 같은 특정 종류의 디자인 언어를 적용하고 싶은 곳이기도 합니다.

이것을 설정하는 것은 실제로 SwiftUI에서 꽤 재미있다.

데모에서 함께 살펴봅시다.

여기 당신의 다음 무료 커피가 언제인지 보여주는 카페 컴패니언 앱의 출발점이 있습니다.

포맷된 날짜를 보여주는 SwiftUI 보기가 있습니다.

여기서 SwiftUI 미리보기로 제어할 수 있도록 포맷에 로케일을 설정했습니다.

꽤 좋은 시작이지만, 조금 더 커스터마이징하고 싶습니다.

이것을 내 앱에 좀 더 구체적으로 만드는 것으로 시작합시다.

나는 분, 시간, 그리고 평일에만 신경을 쓴다.

그래, 꽤 좋아 보여. 이제 약간의 색을 더해 봅시다.

먼저, 우리는 반환 유형을 AttributedString으로 변경하고 귀속된 출력을 요청할 것입니다.

다음으로, 우리는 속성 컨테이너를 사용할 것이다.

이것들은 문자열의 특정 문자에 첨부되지 않고 속성을 저장할 수 있다.

우리는 날짜 형식이 출력에 넣는 평일 속성에 대해 하나를 만들 것입니다.

그것은 평일을 포함하는 문자열의 범위에 설정되어 있다.

다음으로, 우리는 설정하고 싶은 색상 속성을 위한 컨테이너를 만들 것입니다.

그리고 마지막으로, 우리는 첫 번째 컨테이너의 속성과 일치하는 속성을 속성 문자열의 두 번째 값으로 대체하기 위해 속성 문자열 함수를 사용할 것입니다.

AttributedString은 값 유형이고 교체는 돌연변이 함수이기 때문에, 우리는 "let"을 "var"로 변경해야 합니다. 좋아 보인다.

더 좋은 것은, 그것은 모든 지역에서 작동한다.

다시 확인하기 위해 미리보기에 몇 개를 더 추가해 봅시다.

이 로케일의 형식이 지정된 날짜가 어디에 있든 평일이 주황색이라는 것을 알 수 있습니다.

더 많은 새로운 포맷터 API에 대해 계속 배워봅시다.

이제 날짜를 문자열로 바꾸는 방법을 보았으니, 문자열을 날짜로 바꾸는 방법에 대해 이야기해 봅시다.

날짜에는 이제 전략 논쟁을 하는 이니셜라이저가 있다.

이 전략은 파서에게 입력에서 어떤 필드를 기대할 수 있는지 알려주는 데 사용된다.

날짜의 경우, 형식은 일종의 전략이기도 하다.

그것은 출력을 표시하고 사용자가 새 날짜를 입력할 수 있는 텍스트 필드와 같이 라운드 트립 날짜에 유용합니다.

여기 왕복 여행의 예가 있습니다.

당신은 구문 분석이 던질 수 있다는 것을 알게 될 것입니다.

이것은 입력에 따라 구문 분석이 실패할 수 있기 때문이다.

일부 전략에는 구문 분석을 위한 고급 옵션이 있다.

여기서, 우리는 날짜 형식이 서버에서 받은 것일 때 유용한 고정 형식을 구문 분석합니다.

그것을 사용하려면, 형식 문자열로 전략을 초기화하세요.

하지만, 마법의 문자열 값을 사용하는 대신, 우리는 문자열 보간을 사용합니다.

이 경우, 우리는 년-월-일 형식의 문자열을 예상한다.

각 보간은 필드로 명확하게 식별되며, 각각은 예상되는 형식을 정확히 지정합니다.

이것에 대한 한 가지 정말 좋은 점은 자동 완성 경험이다.

다른 날짜 형식을 사용하고 싶다면, 자동 완성은 각각의 의미에 대한 문서와 함께 유효한 옵션을 보여줍니다.

아니요, 1년에 얼마나 많은 Y 문자를 사용해야 하는지 더 추측하세요.

숫자로 넘어가자.

숫자 포맷은 정수 또는 부동 소수점 값을 인간이 읽을 수 있는 것으로 변환하는 것이다.

모든 포맷과 마찬가지로, 숫자가 어떻게 표시되어야 하는지에 대한 선호도를 고려합니다.

여기에는 사용된 숫자의 종류부터 숫자를 그룹화하는 데 사용되는 문자에 이르기까지 모든 것이 포함됩니다.

날짜 포맷과 마찬가지로, 추가 매개 변수 없이 훌륭한 출력을 쉽게 얻을 수 있습니다.

지원되는 많은 종류의 옵션과 출력이 있다.

여기서 우리는 백분율, 과학적 표기법, 그리고 통화를 보여준다.

마지막으로, 몇 가지 형식을 합치자.

목록 포맷은 이제 배열을 포맷하는 것이다.

이 멤버 스타일 인수는 배열의 각 요소의 형식 스타일을 지정합니다.

이것들은 숫자이기 때문에, 나는 백분율을 사용하고 싶다.

출력은 모든 사용자의 로케일에 대해 정확합니다.

지금까지 우리는 값을 직접 포맷하는 데 집중했다.

SwiftUI는 또한 TextField에 포맷 스타일을 첨부하는 것을 지원합니다.

형식 스타일에는 포맷하는 값의 종류에 대한 유형 정보가 있기 때문에, 여기 영수증의 팁 비율에 대해 읽을 수 있지만 안전한 구문을 사용할 수 있습니다.

카페 앱을 다시 살펴보고 서식이 얼마나 많은 장소가 나타나는지 봅시다.

우리는 재료에 대한 목록 형식을 사용합니다.

우리는 가격을 위해 통화 형식을 사용합니다.

우리는 수량에 대한 숫자 형식을 사용하고 주문 버튼에서 수를 현지화합니다.

우리는 당신이 항상 여기 구석에서 볼 수 있는 날짜 형식을 잊을 수 없습니다.

당신은 모든 곳에서 포맷된 출력을 찾을 수 있으며, 우리는 이 새로운 API가 당신의 앱에서도 쉽고 심지어 재미있게 만들 것이라고 생각합니다.

현지화된 문자열과 포맷터를 도울 수 있는 더 많은 리소스가 있습니다.

"SwiftUI 앱 현지화"와 "현지화된 문자열 간소화"라는 두 개의 세션이 더 있습니다. 다음으로, 자동 문법 계약이라는 새로운 기능에 대해 이야기해 봅시다.

스페인어와 같은 언어의 로컬라이저는 자연스러운 번역을 표현하는 능력이 제한되어 있으며, 때로는 어색한 대화로 이어진다.

이 언어들은 언어의 다른 부분 간의 성별과 복수화 합의를 달성하기 위해 변형이 필요하며 때로는 사용자가 선호하는 주소 용어에 대한 지식도 필요합니다.

영어도 단수형과 복수형의 형태가 다른 명사와 함께 이 특징을 가지고 있다.

나는 거기에 많은 언어 전문 용어를 버렸으니, 예를 들어 보자.

내 카페 앱에서, 나는 음식 품목, 크기, 그리고 수량을 고를 수 있다.

나는 작은 샐러드 1개를 선택한다.

이제 내 친구가 나와 함께 할 거라고 해서, 나는 수를 2로 늘렸어.

영어로, "샐러드"라는 단어는 숫자 2와 일치하도록 바뀌어야 한다.

이것은 합의라고 불린다.

그 모든 것은 이 문장의 단어들이 서로 일치해야 한다는 것이다.

영어에서, 복수화로 인해 단어를 고치는 것은 일반적인 종류의 합의이다.

이제 앱을 스페인어로 바꾸고 ensalada pequeña 1개 또는 작은 샐러드 1개를 주문합시다.

내가 친구를 위해 주문할 때, 이 주문 버튼은 영어와 같은 복수형이 필요하지만 반전이 있다.

스페인어로 형용사 pequeña와 명사 ensalada는 모두 백작 dos와 일치해야 한다.

그래서 ensalada pequeña 대신에, 버튼에는 ensaladas pequeñas라고 쓰여 있다.

다음으로, 나는 술을 마시러 넘어간다.

이 문장의 경우, 버튼은 올바른 복수화뿐만 아니라 이 단어들의 문법적 성별에 대한 합의가 필요하다.

주스, jugo는 남성적이다.

형용사 pequeño도 일치해야 한다.

이와 같은 텍스트를 올바르게 현지화하기 위해, 우리는 조합 폭발로 끝난다.

음식, 크기 및 수의 각 조합에 대해 다른 현지화된 문자열이 필요합니다.

코드에서, 그것은 종종 다음과 같이 끝나며, 각 항목을 전환한 다음 각 크기를 전환해야 합니다.

카운트를 위해 각 문자열을 올바르게 복수화할 수 있는 stringsdict 파일도 있습니다.

이제, 키보드의 제안을 지원하는 동일한 기술을 활용하여, 우리는 이러한 모든 경우 등을 쉽게 처리할 수 있는 새로운 API를 만들었습니다.

시스템이 올바른 문법을 갖도록 지역화된 문자열을 자동으로 수정하기 때문에 우리는 이 기능을 자동 문법 계약이라고 부릅니다.

이제 코드가 훨씬 더 간단해졌다.

수량, 크기, 음식을 한 줄로 결합할 수 있습니다.

자동 문법 계약은 굴절이라는 프로세스를 사용하여 문자열을 수정할 것입니다.

그걸 분해하자.

굴절하기 위해, 우리는 문자열의 어느 부분을 고정해야 하는지 알아야 한다.

운 좋게도, 우리는 그것을 할 수 있는 스위프트 유형, AttributedString, 그리고 Markdown의 사용자 지정 속성이 있습니다.

이 문자열에서, 나는 그 구문을 사용하여 음식, 크기, 그리고 우리의 굴절 속성으로 수를 감싼다.

속성의 가치는 사실이다.

이 프로젝트의 현지화를 내보낼 때, 주석이 달린 문자열과 음식의 이름과 크기와 같은 소스 코드의 다른 현지화된 문자열이 포함된 문자열 파일을 얻을 수 있습니다.

여기 라틴 아메리카 스페인어의 문자열이 있습니다.

로컬라이저는 "small" 또는 "large"와 같은 형용사가 스페인어로 명사 앞에 있기 때문에 구문 %1, %3, %2를 재정렬하는 인수를 사용했다.

그들은 문자열의 이 영역을 굴절하기 위한 사용자 지정 속성 구문을 유지하고 음식과 크기에 대한 번역을 제공합니다.

자동 문법 엔진은 나머지 부분을 해결한다.

일부 언어는 현지화된 텍스트 자체의 단어뿐만 아니라 그 텍스트와 그것을 읽는 사람 사이의 합의를 특징으로 한다.

자동 문법 합의도 도움이 될 수 있다.

예를 들어, 노트에 대한 이 환영 화면을 살펴봅시다.

영어로, 우리는 "메모에 오신 것을 환영합니다"라고 말한다. 스페인어로, 우리는 "Te damos la bienvenida a Notas" 또는 "Notes에 오신 것을 환영합니다"라고 말합니다. 우리는 영어로 하는 것과 같은 스페인어 경험을 하고 싶다.

그러나, 스페인어로 "bienvenido"라는 단어는 사용자가 선호하는 주소 용어와 일치해야 합니다.

이 용어는 몇 가지 선택 중 하나일 수 있으며, 그 선택은 텍스트를 바꾼다.

올바른 주소 용어를 사용하면 더 개인적이고 포괄적인 경험을 할 수 있습니다.

올해의 릴리스에서, 우리는 스페인어를 사용하는 사람들이 주소 기간을 지정할 수 있도록 했습니다.

언어 및 지역 설정에는 새로운 주소 기간 옵션이 있습니다.

당신이 그것을 선택할 때, 당신은 당신의 선호도를 선택하고 모든 앱과 공유하도록 선택할 수 있습니다.

여기서, 당신은 여성 용어의 주소에 대한 노트에서 새로운 환영 화면을 볼 수 있습니다.

그리고 여기는 남성적인 주소 용어입니다.

우리가 모르거나 사용자가 지정하지 않는 것을 선호한다면, 우리는 원래 문자열을 대안으로 유지합니다.

이전에 본 것과 동일한 굴절 속성은 사용자를 참조하는 현지화된 문자열에도 사용됩니다.

우리의 "환영"의 경우, 우리는 bienvenido라는 단어에 굴절 속성을 적용합니다.

영어 문자열은 바꿀 필요가 없다.

또한 사용자의 선호도가 무엇인지에 대한 정보가 없는 경우 엔진이 사용할 대체 문자열인 굴절 대안을 추가할 수 있습니다.

올해, 우리는 스페인어와 영어에 대한 자동 계약을 지원합니다.

우리는 노트의 환영 화면과 같이 OS 전역의 여러 곳에서 그것을 채택했습니다.

앱에서도 그것을 채택할 수 있습니다.

필요한 코드 변경은 대부분 다른 문자열을 선택하기 위해 많은 논리를 삭제하는 것이다.

무엇을 굴절할지에 대한 지침은 현지화된 문자열 자체의 일부이며, 로컬라이저가 문자열이 그들의 언어로 어떻게 나타나는지 더 잘 제어할 수 있게 해준다.

카페 앱에 대한 자동 문법 합의를 살펴봅시다.

영어로 실행되는 카페 앱을 살펴봅시다.

주문에 피자를 추가하는 것으로 시작하겠습니다.

나는 큰 것을 가질 것 같아. 그리고 그냥 1.

버튼의 텍스트가 큰 피자 0개에서 큰 피자 1개로 어떻게 바뀌었는지 주목하세요.

그건 자동으로 끝났어.

내가 2개를 고르면, 다시 고쳐진다.

난 그냥 하나 가질 거야.

이 화면 하단의 주문 버튼이 1개의 항목으로 변경되었습니다.

마실 것 어때?

작은 것은 괜찮고, 이것들 중 하나만.

버튼이 "항목" 대신 "항목"으로 어떻게 바뀌었는지 알아?

그 끈은 자동으로 바뀌었다.

확인해 보자.

여기 우리의 영수증이 있습니다.

그것은 포맷된 가격과 함께 우리의 피자와 주스를 나열합니다.

하단에는 사용자 지정 글꼴과 웹사이트 링크가 있는 우리의 속성 문자열이 있습니다.

Xcode로 돌아가서 소스를 살펴봅시다.

음식 상세 보기에서 시작하겠습니다.

이것은 크기 선택 화면을 보여주는 보기입니다.

각 종류의 음식, 각 크기 및 각 카운트에 대해 하나가 아닌 스페인어에 대한 하나의 현지화된 문자열만 추가하면 된다는 것을 알 수 있도록 새로운 크기를 추가합시다.

이 줄은 목록을 보여준다.

그 목록은 우리의 모델 객체에서 나온 것이다.

거기로 가자.

크기 열거형은 이미 작고 크다.

나는 "거대한"이라고 불리는 가장 굶주린 고객을 위해 새로운 사이즈를 추가할 것이다. 그렇게 하기 위해, 나는 현지화된 문자열과 함께 새로운 케이스를 추가할 것이다.

이제 나는 거대한 크기에 대한 가격을 추가하기만 하면 된다.

이 데모를 위해, 나는 그것들을 이니셜라이저에 넣었다.

이제 나는 거대한 크기에 대한 가격을 추가하기만 하면 된다.

이 데모를 위해, 나는 방금 그것들을 이니셜라이저에 넣었다.

우리의 견해를 다시 확인해 봅시다.

여기 미리보기에는 우리의 새로운 사이즈가 있습니다.

우리의 출처에는 이미 영어 문자열이 포함되어 있다.

난 그냥 지금 스페인어가 필요해.

새로운 문자열을 생성하기 위해, 나는 컴파일러를 사용하여 "거대한"에 대한 새로운 현지화된 문자열을 찾을 것이다. 그렇게 하기 위해, 나는 제품 > 수출 현지화를 선택하고, 스페인어 문자열을 저장한다.

이제 스페인어 번역을 추가해 봅시다.

나는 우리의 새로운 문자열을 필터링하고 스페인어 단어를 입력할 수 있다.

다음으로, 나는 이 현지화를 가져와서 내 앱에 넣는다.

이제 나는 스페인어로 우리 앱을 다시 실행할 거야.

그렇게 하기 위해, 저는 제품 > 계획 > 계획 편집을 선택합니다.

옵션에서, 나는 시험하고 싶은 언어를 선택할 수 있다.

그리고 뛰어.

당신은 우리의 헤더에서 우리가 지금 스페인어로 달리고 있다는 것을 알 수 있습니다.

샐러드부터 시작해서 다른 주문을 하자.

수량을 변경하면 주문 버튼이 고정되어 있습니다.

우리의 새로운 거대한 크기는 2개의 샐러드를 위해 정확하게 복수화되었다.

게다가, 그것은 단 하나의 문자열로 "ensalada"의 문법적 성별과 일치한다.

올해 재단에는 많은 훌륭한 새로운 기능이 있으며, 오늘 앱에서 시도해 볼 준비가 되어 있습니다.

AttributedString은 문자열 범위에 키-값 쌍을 추가하기 위한 빠르고 사용하기 쉬운 스위프트 우선 인터페이스를 제공합니다.

텍스트에서 SwiftUI와 함께 사용하고 현지화된 문자열에서 마크다운을 사용할 수 있습니다.

우리의 새로운 포맷터 API는 형식에 초점을 맞추고, 코드를 단순화하고 성능을 향상시킵니다.

앱에서 데이터를 표시하는 모든 장소에서 형식을 사용하세요.

마지막으로, 자동 문법 계약은 문법 성별, 수 및 사용자 자신의 주소 용어와 일치하도록 현지화된 문자열을 지능적으로 수정할 것입니다.

네가 이 새로운 기능들을 좋아하길 바라.

우리는 당신의 앱에서 그것들을 찾기를 기대하고 있습니다.

고마워.

[음악].