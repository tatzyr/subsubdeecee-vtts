10095

♪ 베이스 음악 연주 ♪

♪

Guoye Zhang: 안녕하세요, 저는 Guoye입니다.

내 동료 Zhenchao와 나는 HTTP 프레임워크에서 일한다.

나는 네가 지금까지 스위프트 동시성에 대해 많이 들었을 거라고 확신해.

아직 하지 않았다면, "Swift에서 async/await"를 확인하세요.

나는 async/await가 URLSession에서 어떻게 작동하는지에 대해 뛰어들 것이다.

내가 스위프트 동시성에 대해 가장 좋아하는 것은 코드를 선형적이고 간결하게 만들고 네이티브 스위프트 오류 처리를 지원한다는 것이다.

네트워킹은 본질적으로 비동기적이며, iOS 15와 macOS Monterey에서는 Swift 동시성 기능을 활용할 수 있도록 URLSession에 새로운 API 세트를 도입했습니다.

당신에게 우리의 새로운 API를 보여주기 위해, 여기 우리가 async/await를 채택하기 위해 노력하고 있는 앱이 있습니다.

그것은 개 애호가들만을 위한 사진 공유 앱이며, 우리는 이 사진들을 좋아할 수 있다.

여기 개 사진을 가져오는 기존 코드가 있습니다.

그것은 URLSession에서 completionHandler 기반 편의 방법을 사용하고 있다.

그 코드는 간단해 보이며, 내 제한된 테스트에서 작동했다.

하지만, 적어도 세 가지 실수가 있다.

뛰어들자.

먼저, 제어 흐름을 따라가자.

우리는 데이터 작업을 만들고 그것을 재개한다.

그런 다음 작업이 완료되면, 우리는 완료 핸들러로 뛰어들고, 응답을 확인하고, 이미지를 만들고, 제어 흐름이 끝나는 곳입니다.

흠, 우리는 앞뒤로 뛰고 있어.

스레딩은 어때?

이 작은 코드는 놀라울 정도로 복잡하다.

우리는 총 세 가지 다른 실행 맥락을 가지고 있다.

가장 바깥쪽 계층은 호출자의 스레드나 대기열에서 실행되며, URLSessionTask completionHandler는 세션의 대리자 대기열에서 실행되며, 최종 완료 핸들러는 주 대기열에서 실행됩니다.

컴파일러가 여기서 우리를 도울 수 없기 때문에, 우리는 데이터 경쟁과 같은 스레딩 문제를 피하기 위해 극도의 주의를 기울여야 한다.

이제, 나는 뭔가 잘못된 것을 알아차렸다.

completionHandler에 대한 호출은 주 대기열에 일관되게 파견되지 않는다.

이건 버그일 수도 있어.

또한, 우리는 여기서 일찍 돌아오는 것을 놓치고 있다.

오류가 발생하면 completionHandler를 두 번 호출할 수 있습니다.

이것은 발신자의 가정을 위반할 수 있다.

마지막으로, 이것은 그다지 분명하지 않을 수도 있지만, UIImage 생성은 실패할 수 있다.

데이터가 잘못된 형식이라면, 이 UIImage 이니셜라이저는 nil을 반환하므로, 우리는 nil 이미지와 nil 오류로 completionHandler를 호출했을 것입니다.

이것은 예상되지 않을 것 같다.

이제 이것은 async/await를 사용하는 새 버전입니다.

와, 훨씬 더 간단해!

제어 흐름은 위에서 아래로 선형이며, 우리는 이 함수의 모든 것이 동일한 동시성 컨텍스트에서 실행된다는 것을 알고 있으므로 더 이상 스레딩 문제에 대해 걱정할 필요가 없습니다.

여기서, 우리는 URLSession에서 새로운 비동기 데이터 방법을 사용했습니다.

차단하지 않고 현재 실행 컨텍스트를 일시 중지하고, 성공적으로 완료되면 데이터와 응답을 반환하거나 오류를 발생시킵니다.

우리는 또한 응답이 예기치 않을 때 오류를 발생시키기 위해 throw 키워드를 사용했다.

이를 통해 발신자는 스위프트 기본 오류 처리를 사용하여 오류를 포착하고 처리할 수 있습니다.

마지막으로, 이 함수에서 선택적 UIImage를 반환하려고 하면 컴파일러가 짖을 것이므로, 본질적으로 nil을 올바르게 처리하도록 강요합니다.

다음은 네트워크에서 데이터를 가져오는 데 사용한 방법의 서명입니다.

URLSession.data 메소드는 URL 또는 URLRequest를 허용합니다.

그것들은 기존의 데이터 작업 편의 방법과 동등하다.

우리는 또한 당신이 데이터를 업로드하거나 파일을 업로드할 수 있는 업로드 방법을 제공합니다.

그것들은 기존의 업로드 작업 편의 방법과 동등하다.

기본 메서드 GET이 업로드를 지원하지 않기 때문에 요청을 보내기 전에 올바른 HTTP 메서드를 설정해야 합니다.

다운로드 방법은 응답 본문을 메모리가 아닌 파일로 저장합니다.

다운로드 작업 편의 방법과는 달리, 이 새로운 방법은 파일을 자동으로 삭제하지 않으므로, 직접 삭제하는 것을 잊지 마세요.

이 예에서, 우리는 추가 처리를 위해 파일을 다른 위치로 옮기고 있습니다.

스위프트 동시성의 취소는 URLSession 비동기 메소드와 함께 작동합니다.

취소하는 한 가지 방법은 Concurrency Task.Handle을 사용하는 것이다.

여기서, 우리는 두 개의 리소스를 하나씩 로드하는 동시성 작업을 만들기 위해 비동기를 호출합니다.

나중에, 우리는 Task.Handle을 사용하여 현재 실행 중인 작업을 취소할 수 있습니다.

동시성 작업은 "작업"이라는 이름을 공유하더라도 URLSessionTask와 관련이 없다는 점에 유의하십시오.

우리가 방금 이야기한 방법 - 데이터, 업로드, 다운로드 - 돌아오기 전에 전체 응답 본문이 도착할 때까지 기다린다.

만약 우리가 응답 본문을 점진적으로 받고 싶다면?

URLSession.bytes 메소드를 소개하게 되어 기쁩니다.

그들은 응답 헤더가 수신되면 반환하고 응답 본문을 바이트의 AsyncSequence로 전달합니다.

그것이 어떻게 작동하는지 보여주기 위해, 제 동료 Zhenchao는 Dogs 앱에서 그것을 어떻게 채택하고 있는지 시연할 것입니다.

Zhenchao Li: 고마워, Guoye! 안녕하세요, 저는 젠차오입니다.

나는 얼마나 많은 사람들이 개 사진을 좋아했는지 보여주는 개 앱의 새로운 기능을 연구하고 있다.

지금 당장, 스크롤 보기를 아래로 당겨서 즐겨찾기 카운트를 새로 고칠 수 있습니다.

저는 이 가장 좋아하는 카운트를 실시간으로 업데이트하고 싶습니다.

그렇게 하면, 앱은 훨씬 더 인터랙티브하게 느껴진다.

그렇게 하기 위해, 우리의 백엔드 엔지니어들은 사진에 대한 실시간 업데이트를 제공하는 실시간 이벤트 엔드포인트를 구축했습니다.

나는 응답을 검토하기 위해 엔드포인트를 확인할 것이다.

응답 본문의 각 줄은 업데이트된 즐겨찾기 수와 같은 사진에 대한 업데이트를 설명하는 JSON 데이터입니다.

새로운 비동기 시퀀스 API를 사용하여 엔드포인트의 응답을 소비하고 실시간 이벤트가 구문 분석됨에 따라 즐겨찾기 카운트를 업데이트합시다.

사진 컬렉션 보기가 나타날 때 호출되는 작업인 onAppearHandler 기능에서 실시간 업데이트를 시작할 수 있습니다.

함수 내에서, 나는 새로운 URLSession.bytes API를 호출하여 새로운 엔드포인트에서 데이터를 가져올 것이다.

여기에 반환된 바이트에는 URLSession.AsyncBytes 유형이 있습니다.

이것은 우리에게 반응체를 점진적으로 소비할 수 있는 방법을 제공한다.

나는 또한 우리가 서버로부터 성공적인 응답을 받았는지 확인하기 위해 여기에 오류 확인을 추가했다.

우리는 응답의 각 줄을 JSON 데이터로 구문 분석하고 싶습니다.

그렇게 하기 위해, 우리는 AsyncBytes에서 라인 메소드를 사용할 수 있다.

이것은 우리가 데이터가 수신될 때 응답 라인을 한 줄씩 소비할 수 있게 해준다.

루프 내에서 JSON 데이터를 구문 분석하고 updateFavoriteCount를 호출하여 UI를 업데이트할 수 있습니다.

UI 업데이트는 메인 액터에서 발생해야 하며, 이것이 제가 비동기 함수인 updateFavoriteCount를 호출하기 위해 await 구문을 사용하는 이유입니다.

좋아. 이제 이 가장 좋아하는 카운트는 실시간으로 업데이트됩니다.

너에게 돌아가, Guoye.

Guoye: Zhenchao는 방금 AsyncSequence 내장 변환 -- 라인을 사용하여 응답 바디 라인을 한 줄씩 구문 분석하는 방법을 보여주었습니다.

AsyncSequence는 많은 편의 변환을 지원하며, FileHandle과 같은 다른 시스템 프레임워크 API와 함께 AsyncSequence를 사용할 수도 있습니다.

AsyncSequence에 대해 자세히 알아보려면, "Meet AsyncSequence" 비디오를 보는 것이 좋습니다.

URLSession은 인증 문제, 메트릭 등과 같은 이벤트에 대한 콜백을 제공하는 대리자 모델을 중심으로 설계되었습니다.

새로운 비동기 메서드는 더 이상 기본 작업을 노출하지 않으므로, 작업과 관련된 인증 문제를 어떻게 처리합니까?

네, 이러한 모든 메서드는 작업별 대리자라는 추가 인수를 사용하여 이 데이터 업로드, 다운로드 또는 바이트 작업과 관련된 대리자 메시지를 처리하는 객체를 제공할 수 있습니다.

우리는 또한 당신이 동일한 기능을 활용할 수 있도록 Objective-C의 NSURLSessionTask에 위임 속성을 도입하고 있습니다.

대리인은 완료되거나 실패할 때까지 업무에 의해 강하게 유지된다.

작업별 대리인은 백그라운드 URLSession에서 지원되지 않는다는 점은 주목할 가치가 있다.

세션 대리자와 작업 대리자 모두에서 방법이 구현되면, 작업 대리자가 호출됩니다.

이제, Zhenchao는 인증 문제를 처리하기 위해 작업별 대리인을 사용하는 방법을 보여줄 것이다.

젠차오: 고마워, 궈예!

우리의 Dogs 앱에는 새로운 비동기 API로 작성된 간단한 데이터 가져오기 레이어가 있습니다.

사진을 즐겨찾기로 표시하거나 모든 즐겨찾기 사진을 가져오는 것과 같은 일부 데이터 가져오기 작업의 경우, 사용자는 인증을 받아야 합니다.

지금 당장, 사진을 즐겨찾기로 탭하면, "승인되지 않은" 오류가 발생합니다.

작업별 대리인을 사용하여 사용자 인증을 추가하는 방법을 살펴봅시다.

먼저, URLSessionTaskDelegate를 작성해 봅시다.

그것을 AuthenticationDelegate라고 부르자.

AuthenticationDelegate는 URLSessionTaskDelegate 프로토콜을 준수하며, 이니셜라이저에서 signInController의 인스턴스를 허용합니다.

우리가 구현한 signInController 클래스에는 이미 사용자에게 자격 증명을 요청하는 데 사용할 수 있는 몇 가지 좋은 도우미 기능이 포함되어 있습니다.

다음으로, URLSession didReceive 챌린지 위임 방법을 구현해 봅시다.

위임 방법 내에서, 우리는 사용자에게 자격 증명을 요청하여 HTTP 기본 인증 문제에 응답하도록 선택할 수 있습니다.

물론, 우리는 오류 처리를 잊어서는 안 된다.

이제 이 AuthenticationDelegate 클래스를 작업별 대리인으로 사용합시다.

그렇게 하기 위해, 나는 그것의 인스턴스를 인스턴스화하고 URLSession.data 메소드의 대리자 매개 변수로 구문 분석할 수 있다.

위임 객체는 인스턴스 변수가 아니며, 작업이 완료되거나 실패할 때까지 작업에 의해 강력하게 유지된다는 점에 유의하십시오.

여기서 새로운 점은 대리자가 URLSession 작업의 인스턴스와 관련된 이벤트를 처리하는 데 사용할 수 있다는 것입니다. 이는 대리자 메서드 내부의 논리가 다른 작업이 아닌 특정 URLSession 작업에만 적용될 때 편리합니다.

좋아. 이제 우리가 좋아하는 사진을 탭할 때...

...로그인 양식이 나타납니다.

우리가 로그인하면, 사진은 즐겨찾기로 표시되며, 우리가 가장 좋아하는 사진 컬렉션에 추가되었습니다.

너에게 돌아가, Guoye.

Guoye: 데모 고마워, Zhenchao.

우리는 당신이 URLSession으로 비동기/대기를 시도하기를 기다릴 수 없으며, 함수 변경, 완료 핸들러를 비동기 함수로 전환, 반복 이벤트 핸들러를 AsyncSequences로 변경하는 것을 포함하여 코드를 개선하기 위해 동일한 비동기 개념을 적용하는 것이 좋습니다.

URLSession의 발전에 대해 자세히 알아보려면, 앱의 HTTP 트래픽을 검사하는 멋진 새 도구에 대한 비디오와 URLSession의 HTTP/3 지원에 대한 비디오가 있습니다.

고마워 그리고 멋진 WWDC 보내!

♪