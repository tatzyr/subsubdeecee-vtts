10216

♪ 베이스 음악 연주 ♪

♪

메가나 굽타: 안녕하세요, 제 이름은 메가나입니다.

오늘, 나는 너에게 스위프트의 ARC에 대해 이야기할 거야.

스위프트는 구조체와 열거형과 같은 강력한 값 유형을 제공한다.

참조 유형과 함께 제공되는 의도하지 않은 공유의 위험을 피하기 위해 가능한 경우 값 유형을 사용하는 것을 선호해야 합니다.

클래스는 스위프트의 참조 유형이며, 사용하기로 결정한 경우, 스위프트는 자동 참조 카운팅 또는 ARC를 통해 메모리를 관리합니다.

효과적인 스위프트를 작성하려면, ARC가 어떻게 작동하는지 이해하는 것이 중요하다.

이 세션에서, 우리는 바로 그것을 할 것이다.

나는 스위프트에서 객체 수명과 ARC에 대한 검토로 시작할 것이다.

그런 다음, 나는 관찰 가능한 물체의 수명이 무엇인지 설명할 것이다.

나는 어떤 언어 기능이 물체의 수명을 관찰할 수 있게 하는지, 관찰된 물체의 수명을 의존하는 결과, 그리고 그것들을 고치기 위한 몇 가지 안전한 기술을 자세히 설명할 것이다.

시작하자.

스위프트에서 객체의 수명은 초기화에서 시작하여 마지막 사용에서 끝납니다.

ARC는 수명이 끝난 후 객체를 할당 해제하여 자동으로 메모리를 관리합니다.

그것은 참조 수를 추적하여 물체의 수명을 결정한다.

ARC는 주로 유지 및 릴리스 작업을 삽입하는 스위프트 컴파일러에 의해 구동된다.

런타임에, 참조 수를 증가시키고 릴리스 감소를 유지하세요.

참조 수가 0으로 떨어지면, 객체는 할당 해제될 것이다.

그것이 예시로 어떻게 작동하는지 봅시다.

우리가 여행 앱을 만들고 싶다고 상상해 보세요.

여행자를 대표하기 위해, 이름과 선택적 목적지 속성이 있는 수업을 작성해 봅시다.

Test() 함수에서 먼저 Traveler 객체가 생성되고, 참조가 복사되고, 마지막으로 목적지가 업데이트됩니다.

Traveler 객체의 메모리를 자동으로 관리하기 위해, Swift 컴파일러는 참조가 시작될 때 유지 작업과 참조의 마지막 사용 후 릴리스 작업을 삽입합니다.

여행자1은 여행자 객체에 대한 첫 번째 참조이며, 마지막 사용은 복사본이다.

여기서, 스위프트 컴파일러는 traveler1 참조를 마지막으로 사용한 직후에 릴리스 작업을 삽입합니다.

초기화가 참조 수를 1로 설정하기 때문에 참조가 시작될 때 유지 작업을 삽입하지 않습니다.

여행자2는 여행자 객체에 대한 또 다른 참조이며, 마지막 사용은 목적지 업데이트이다.

여기서, 스위프트 컴파일러는 참조가 시작될 때 유지 작업을 삽입하고 참조를 마지막으로 사용한 직후 릴리스 작업을 삽입합니다.

코드를 살펴보고 런타임에 무슨 일이 일어나는지 봅시다.

먼저, 여행자 객체는 힙에 생성되고 하나의 참조 수로 초기화됩니다.

그런 다음 새로운 참조를 준비하기 위해, 작업 실행을 유지하여 참조 수를 2로 증가시킨다.

이제 여행자2는 여행자 객체에 대한 참조이기도 하다.

Traveler1 참조를 마지막으로 사용한 후, 릴리스 작업이 실행되어 참조 수가 1로 감소합니다.

그런 다음 Traveler 객체의 목적지가 Big Sur로 업데이트됩니다.

그것이 traveler2 참조의 마지막 사용이었기 때문에, 릴리스 작업이 실행되어 참조 수를 0으로 감소시킨다.

참조 수가 0으로 떨어지면, 객체를 할당 해제할 수 있습니다.

스위프트의 객체 수명은 사용 기반이다.

객체의 보장된 최소 수명은 초기화 시 시작되어 마지막 사용 시 끝납니다.

이것은 객체의 수명이 닫는 중괄호에서 끝나도록 보장되는 C++와 같은 언어와는 다르다.

이 예에서, 우리는 그 물체가 마지막 사용 직후에 할당 해제된 것을 보았다.

그러나, 실제로, 객체 수명은 스위프트 컴파일러에 의해 삽입된 유지 및 릴리스 작업에 의해 결정된다.

그리고 시작되는 ARC 최적화에 따라, 관찰된 물체의 수명은 보장된 최소값과 다를 수 있으며, 물체의 마지막 사용을 넘어 끝날 수 있다.

그러한 경우, 객체는 마지막 사용 이외의 프로그램 지점에서 할당됩니다.

대부분의 경우, 물체의 정확한 수명이 무엇인지는 중요하지 않다.

그러나, 약하고 소유되지 않은 참조와 deinitializer 부작용과 같은 언어 기능으로, 객체의 수명을 관찰할 수 있다.

그리고 보장된 객체 수명 대신 관찰된 객체 수명에 의존하는 프로그램이 있다면, 미래에 문제가 발생할 수 있습니다.

관찰된 물체의 수명에 의존하는 것은 오늘날 효과가 있을 수 있지만, 그것은 단지 우연의 일치일 뿐이다.

관찰된 객체 수명은 스위프트 컴파일러의 긴급 속성이며 구현 세부 사항이 변경됨에 따라 변경될 수 있습니다.

이러한 버그는 개발 중에 발견되지 않을 수 있으며 오랫동안 숨겨져 있을 수 있으며, 이전에 제한된 ARC 최적화를 가능하게 하는 개선된 ARC 최적화 또는 관련 없는 소스 변경으로 컴파일러 업데이트에 의해서만 발견될 수 있습니다.

나는 물체의 수명을 관찰할 수 있게 하는 언어 기능을 살펴보고, 관찰된 물체의 수명에만 의존한다면 어떤 일이 일어날 수 있는지 살펴보고, 그것들을 고칠 수 있는 몇 가지 안전한 기술을 살펴볼 것이다.

강력한 참조인 기본 참조와 달리, 약하고 소유되지 않은 참조는 참조 계산에 참여하지 않으며, 이러한 이유로 일반적으로 참조 주기를 깨는 데 사용됩니다.

내가 그들의 세부 사항에 들어가기 전에, 참조 주기가 무엇인지 보자.

이것은 우리의 여행 앱의 확장이다.

우리는 이제 선택적 포인트 시스템을 도입하고 싶습니다.

여행자는 계좌를 가지고 포인트를 적립할 수 있다.

이것을 나타내기 위해, 우리는 포인트 속성이 있는 새로운 계정 클래스를 가지고 있습니다.

계정 클래스는 여행자 클래스를 의미하고, 여행자 클래스는 계정 클래스를 의미합니다.

Test() 함수에서, 우리는 여행자와 계정 객체를 만든 다음, 여행자 참조를 통해 printSummary() 함수를 호출합니다.

코드를 살펴보고 ARC에서 무슨 일이 일어나는지 봅시다.

먼저, 여행자 객체는 하나의 참조 수로 힙에 생성됩니다.

그런 다음 계정 객체는 하나의 참조 수로 힙에 생성됩니다.

계정 객체는 여행자 객체를 참조하기 때문에, 여행자 객체의 참조 수는 두 개로 증가한다.

이제 여행자 객체가 계정 객체를 참조하기 시작하므로, 계정 객체의 참조 수도 2로 증가합니다.

이것은 계정 참조의 마지막 사용이다.

이 후, 계정 참조는 사라지고 계정 객체의 참조 수는 하나로 감소합니다.

그런 다음, printSummary() 함수는 이름과 포인트를 인쇄하기 위해 호출됩니다.

이것은 여행자 참조의 마지막 사용이다.

이 후, 여행자 참조는 사라지고 여행자 객체의 참조 수는 하나로 감소한다.

물체에 도달할 수 있게 하는 모든 참조가 사라지더라도, 물체의 참조 수는 하나로 남아 있다.

이것은 참조 주기 때문이다.

결과적으로, 물체는 절대 할당 해제되지 않아 메모리 누수가 발생한다.

당신은 약하거나 소유되지 않은 참조로 참조 주기를 깰 수 있습니다.

그들은 참조 계산에 참여하지 않기 때문에, 약하거나 소유되지 않은 참조가 사용되는 동안 참조된 객체가 할당될 수 있다.

이런 일이 발생하면, 스위프트 런타임은 약한 참조에 대한 액세스를 nil로, 소유되지 않은 참조에 대한 액세스를 함정으로 안전하게 바꾼다.

참조 주기에 참여하는 모든 참조는 참조 주기를 깨기 위해 약하거나 소유되지 않은 것으로 표시될 수 있습니다.

그건 지원서에 따라 달라.

우리의 예에서, 계정 클래스의 여행자 참조를 약한 것으로 표시해 봅시다.

약한 참조는 참조 계산에 참여하지 않기 때문에, 여행자 객체를 마지막으로 사용한 후, 참조 수는 0으로 떨어집니다.

여행자 객체의 참조 수가 0이 되면, 할당 해제될 수 있다.

여행자 객체가 사라지면, 계정 객체에 대한 참조가 사라지고, 참조 카운트가 0이 된다.

이제 계정 객체를 할당 해제할 수 있습니다.

이 예에서, 우리는 참조 주기를 깨기 위해 약한 참조를 사용했다.

보장된 객체 수명이 종료된 동안 약한 참조가 객체에 액세스하는 데 사용되고, 객체를 사용할 수 있도록 관찰된 객체 수명에 의존하고 있다면, 관찰된 객체 수명이 관련 없는 이유로 변경될 때 미래에 버그가 발생할 수 있습니다.

예를 들어 보자.

여기서, printSummary() 함수는 Traveler 클래스에서 Account 클래스로 이동됩니다.

그리고 test() 함수는 이제 계정 참조를 통해 printSummary() 함수를 호출합니다.

printSummary() 함수가 호출되면 정확히 어떻게 되나요?

그것은 오늘 여행자의 이름과 포인트를 인쇄할 수도 있지만, 이것은 단지 우연의 일치일 뿐이다.

이것은 Traveler 객체의 마지막 사용이 printSummary() 함수를 호출하기 전이기 때문이다.

이 후, 컴파일러가 마지막 사용 직후 릴리스를 삽입하면 Traveler 객체의 참조 수는 0으로 떨어질 수 있습니다.

참조 수가 0으로 떨어지면, 약한 참조를 통해 여행자 객체에 대한 접근은 0이 될 것이며, 여행자 객체는 할당 해제될 수 있습니다.

따라서 printSummary() 함수가 호출되면, 약한 여행자 참조의 강제 언랩이 트랩되어 충돌을 일으킬 것이다.

포스 언랩이 여기서 충돌의 원인인지, 그리고 선택적 바인딩이 그것을 막았을 수도 있는지 궁금할 수도 있습니다.

선택적 바인딩은 실제로 문제를 악화시킨다.

명백한 충돌 없이, 관찰된 물체의 수명이 관련 없는 이유로 바뀔 때 눈에 띄지 않을 수 있는 조용한 버그를 만듭니다.

약하고 소유되지 않은 참조를 안전하게 처리할 수 있는 다양한 기술이 있으며, 각각은 초기 구현 비용과 지속적인 유지 보수 비용의 정도가 다양합니다.

우리의 예를 들어 그것들을 하나씩 탐구해 봅시다.

스위프트는 객체의 수명을 명시적으로 연장할 수 있는 확장된Lifetime() 유틸리티를 제공합니다.

withExtendedLifetime()을 사용하면 printSummary() 함수가 호출되는 동안 Traveler 객체의 수명을 안전하게 연장하여 잠재적인 버그를 방지할 수 있습니다.

기존 범위의 끝에 withExtendedLifetime()을 빈 호출하여 동일한 효과를 얻을 수 있습니다.

더 복잡한 경우, 우리는 컴파일러에게 defer를 사용하여 객체의 수명을 현재 범위의 끝까지 연장하도록 요청할 수 있습니다.

withExtendedLifetime()은 객체 수명 버그에서 벗어나는 쉬운 방법처럼 보일 수 있다.

그러나, 이 기술은 깨지기 쉽고, 당신에게 정확성에 대한 책임을 전가합니다.

이 접근 방식을 사용하면 약한 참조가 버그를 일으킬 가능성이 있을 때마다 withExtendedLifetime()이 사용되도록 해야 합니다.

제어되지 않으면, withExtendedLifetime()은 코드베이스 전체에 상승하여 유지 보수 비용을 증가시킬 수 있습니다.

더 나은 API로 수업을 재설계하는 것은 훨씬 더 원칙적인 접근 방식이다.

객체에 대한 접근이 강력한 참조로만 제한될 수 있다면, 객체 평생 놀라움을 방지할 수 있다.

여기서, printSummary() 함수는 Traveler 클래스로 다시 이동되고, 계정 클래스의 약한 참조는 숨겨집니다.

테스트는 이제 강력한 참조를 통해 printSummary() 함수를 호출하여 잠재적인 버그를 제거해야 합니다.

성능 비용을 부담하는 것 외에도, 약하고 소유되지 않은 참조는 클래스 디자인에 주의하지 않으면 버그를 노출시킬 수 있습니다.

잠시 멈추고 생각하는 것이 중요합니다. 왜 약하고 소유되지 않은 참고 문헌이 필요한가요?

그것들은 참조 주기를 깨는 데만 사용되나요?

애초에 참조 주기를 만드는 것을 피한다면 어떨까요?

참조 주기는 종종 알고리즘을 재고하고 주기적 클래스 관계를 트리 구조로 변환함으로써 피할 수 있다.

우리의 예에서, 여행자 수업은 계정 수업을 참조해야 한다.

계정 클래스가 여행자 클래스를 참조할 필요는 없다.

계정 클래스는 여행자의 개인 정보에 접근하기만 하면 됩니다.

우리는 여행자의 개인 정보를 PersonalInfo라는 새로운 클래스로 옮길 수 있습니다.

여행자 클래스와 계정 클래스 모두 주기를 피하면서 PersonalInfo 클래스를 참조할 수 있습니다.

약하고 소유되지 않은 참조의 필요성을 피하면 추가 구현 비용이 발생할 수 있지만, 이것은 모든 잠재적인 객체 수명 버그를 제거하는 확실한 방법입니다.

객체 수명을 관찰할 수 있는 또 다른 언어 기능은 deinitializer 부작용이다.

Deinitializer는 할당 해제 전에 실행되며 그 부작용은 외부 프로그램 효과에 의해 관찰될 수 있다.

외부 프로그램 효과로 deinitializer 부작용을 시퀀스하기 위해 코드를 작성하면, 숨겨진 버그로 이어질 수 있으며, 이는 관련 없는 이유로 관찰된 객체 수명이 변경될 때만 발견됩니다.

그런 버그가 어떻게 나올 수 있는지 알아보기 전에, deinitializer가 무엇인지 봅시다.

이것은 이제 deinitializer가 있는 첫 번째 예시의 반복이다.

Deinitializer는 세계적인 부작용이 있다: 콘솔에 메시지를 인쇄한다.

오늘날 deinitializer는 "Done traveling"이 인쇄된 후에 실행될 수 있다.

하지만 Traveler 객체의 마지막 사용은 목적지 업데이트이기 때문에, ARC 최적화에 따라 "Done traveling"이 인쇄되기 전에 deinitializer를 실행할 수 있습니다.

이 예에서, deinitializer 부작용은 관찰할 수 있었지만 의존하지는 않았다.

Deinitializer 부작용이 외부 프로그램 효과에 의존하는 더 복잡한 예를 살펴봅시다.

우리는 이제 여행자 수업에 여행 지표를 소개합니다.

목적지가 업데이트될 때마다, 그것은 TravelMetrics 수업에 기록된다.

결국 여행자 객체를 초기화할 때, 메트릭은 글로벌 기록에 게시된다.

게시된 지표는 여행자의 익명 ID, 조회된 목적지 수 및 계산된 여행 관심 카테고리입니다.

Test() 함수에서, 먼저, Traveler 객체가 생성된 다음, travelMetrics에 대한 참조가 Traveler 객체에서 복사됩니다.

여행자의 목적지는 TravelMetrics에 Big Sur를 기록하는 Big Sur로 업데이트됩니다.

여행자의 목적지는 TravelMetrics에 Catalina를 기록하는 Catalina로 업데이트됩니다.

그런 다음 여행 관심 카테고리는 기록된 목적지를 보고 계산됩니다.

오늘날 deinitializer는 여행 관심사를 계산한 후 실행될 수 있으며, 관심 있는 카테고리를 자연으로 게시할 수 있다.

하지만 트래블러 객체의 마지막 사용은 카탈리나로의 목적지 업데이트이며, 그 직후에 디이니셜라이저가 실행될 수 있다.

Deinitializer가 여행 이자를 계산하기 전에 실행되기 때문에, nil이 게시되어 버그를 일으킨다.

약하고 소유되지 않은 참고 문헌과 마찬가지로, deinitializer 부작용을 안전하게 처리할 수 있는 다양한 기술이 있다.

그들 각각은 다양한 정도의 선행 구현 비용 대 지속적인 유지 보수 비용을 가지고 있다.

그것들을 하나씩 보자.

withExtendedLifetime()은 여행 관심 카테고리가 계산될 때까지 여행자 객체의 수명을 명시적으로 연장하여 잠재적인 버그를 방지하는 데 사용할 수 있습니다.

전에 논의한 바와 같이, 이것은 당신에게 정확성에 대한 책임을 전가합니다.

이 접근 방식을 사용하면 초기화 제거 부작용과 외부 프로그램 효과 사이에 잘못된 상호 작용이 있을 때마다 withExtendedLifetime이 사용되어 유지 보수 비용이 증가하도록 해야 합니다.

그 효과가 모두 국지적이라면 Deinitializer 부작용은 관찰할 수 없다.

내부 클래스 세부 사항의 가시성을 제한하여 클래스 API를 재설계하면 객체 수명 버그를 방지할 수 있습니다.

여기서, TravelMetrics는 비공개로 표시되어 외부 접근으로부터 숨깁니다.

Deinitializer는 이제 가장 관심 있는 여행 카테고리를 계산하고 지표를 게시합니다.

이것은 효과가 있지만, 더 원칙적인 접근 방식은 deinitializer 부작용을 완전히 제거하는 것이다.

여기서, deinitializer 대신 defer는 메트릭을 게시하는 데이니셜라이저 대신 사용되며, deinitializer는 검증만 수행합니다.

Deinitializer 부작용을 제거함으로써, 우리는 모든 잠재적인 객체 수명 버그를 제거할 수 있다.

우리는 ARC, 약하고 소유되지 않은 참조, 그리고 deinitializer 부작용에 대해 배우기 위해 교육 여행 앱 예제를 탐구했습니다.

물체 수명을 관찰할 수 있게 하고 관찰된 물체 수명에 대한 잠재적으로 잘못된 의존도를 제거하는 언어 기능을 철저히 이해하여 놀라운 시간에 버그를 발견하지 않도록 하는 것이 중요합니다.

Xcode 13을 사용하면 Swift 컴파일러에서 "Object Lifetimes 최적화"라는 새로운 실험 빌드 설정을 사용할 수 있습니다.

이것은 강력한 수명 단축 ARC 최적화를 가능하게 한다.

이 빌드 설정을 켜면, 마지막 사용 직후에 객체가 훨씬 더 일관되게 할당되는 것을 볼 수 있으며, 관찰된 객체의 수명을 보장된 최소 수명에 더 가깝게 만들 수 있습니다.

이것은 논의된 예와 유사한 숨겨진 객체 수명 버그를 노출시킬 수 있다.

이러한 모든 버그를 제거하기 위해 이 세션에서 논의된 안전한 기술을 따를 수 있습니다.

네가 이 세션을 즐겼길 바라.

봐줘서 고마워.

♪