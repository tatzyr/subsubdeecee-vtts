10147

안녕하세요, 제 이름은 GPU 소프트웨어 엔지니어링 팀의 Kyle Sanner입니다.

제 동료 알렉스 리와 함께, 우리는 가변 재생률 디스플레이에서 앱에서 최적의 프레임 페이싱을 얻는 방법에 대해 이야기할 것입니다.

우리는 macOS, Adaptive-Sync에 오는 새로운 디스플레이 기술, 그리고 모든 조건에서 iPad Pro에서 사용자 지정 드로잉을 원활하게 구동하는 방법에 초점을 맞출 것입니다.

우리는 현재 Apple 플랫폼에서 지원되는 디스플레이 유형에 대한 간략한 개요로 시작하겠습니다.

Mac의 Adaptive-Sync 디스플레이와 이러한 디스플레이의 전체 화면 앱과 게임에서 부드러운 프레임 속도를 제공하는 데 사용할 수 있는 macOS Monterey의 새로운 도구를 소개합니다.

그런 다음, 우리는 iPad Pro의 ProMotion에 대해 자세히 알아보고, 앱이 다른 프레임 속도로 올바른 프레임 페이싱을 유지하는 데 도움이 되는 몇 가지 CADisplayLink 모범 사례를 살펴볼 것입니다.

먼저 Apple의 장치가 지원할 수 있는 디스플레이 유형을 검토해 봅시다.

Apple 시스템의 대부분의 디스플레이는 고정된 재생률로 작동합니다.

즉, 그들은 전원이 켜질 때마다 일정한 속도로 스스로를 상쾌하게 한다.

예외는 iPad의 ProMotion 디스플레이이며, 이제 macOS의 Adaptive-Sync 디스플레이가 있습니다.

Mac의 Adaptive-Sync 디스플레이의 새로운 기능에 대해 자세히 알아봅시다.

우리는 Adaptive-Sync 디스플레이가 무엇인지, 그리고 Mac에서 어떻게 작동하는지부터 시작할 것입니다.

하지만 먼저, 고정 요금 디스플레이가 어떻게 작동하는지 간단히 살펴봅시다.

다음은 60Hz 디스플레이로 전달되는 프레임을 보여주는 다이어그램입니다.

각 프레임은 디스플레이에 표시되며, 디스플레이가 새로 고쳐지기 전에 16ms 동안 유지됩니다.

프레임버퍼에 Mac이 그린 새 프레임이 있다면, 새 프레임이 표시됩니다.

그렇지 않으면, 이전 프레임이 다시 표시됩니다.

120Hz 디스플레이를 보면, 우리가 재생률을 두 배로 늘렸고, 각 프레임이 화면에 있을 수 있는 간격을 절반으로 줄였지만, 같은 방식으로, 더 빨리 작동한다는 것을 알 수 있습니다.

반면에, 이 적응형 동기화 디스플레이를 보세요.

정적 지속 시간 대신, 각 프레임에는 화면에 있을 수 있는 시간 창이 있다.

이 창은 첨부된 디스플레이에 따라 다릅니다.

이 디스플레이는 40Hz에서 120Hz 사이에서 작동할 수 있으며, 이는 프레임이 8에서 25ms 사이의 화면 어디에나 있을 수 있음을 의미합니다.

최대 시간이 경과되면, 시스템은 패널을 새로 고쳐야 하며, 짧은 시간 동안 새로운 업데이트를 위해 디스플레이를 잠시 사용할 수 없습니다.

좋아요, 그래서 당신의 게임과 앱은 적응형 동기화 디스플레이에서 어떤 이점을 얻을 수 있나요?

대부분 디스플레이의 최대 재생률로 실행되는 애플리케이션의 경우, Adaptive-Sync 디스플레이는 무료로 큰 이점을 제공합니다.

먼저 앱이 대부분 8ms 미만으로 새로운 프레임을 생성할 수 있으므로 120Hz에서 상당히 안정적으로 실행되는 이 시나리오를 살펴보겠습니다.

하지만 장면 복잡성의 순간적인 증가로 인해, 완성된 프레임은 이전 프레임이 처음 표시된 후 프레임버퍼 9ms에 착륙합니다.

고정 프레임 속도 디스플레이에서, 이전 프레임은 당신이 의도한 8ms 대신 16ms로 표시됩니다.

이것은 당신의 앱에 눈에 띄는 차질을 초래합니다.

Adaptive-Sync 디스플레이에서는 프레임이 완료된 후 즉시 디스플레이에 표시되므로 앱에는 1ms의 페널티만 발생합니다.

이 작은 히치는 일반적으로 사용자가 감지할 수 없다.

디스플레이의 최대 프레임 속도에 도달할 수 없는 워크로드의 경우, 앱이 드로어블을 표시하는 방식을 약간 변경하여 부드럽고 균일한 프레임을 제공할 수 있습니다.

이 시나리오를 고려하세요: 복잡한 장면을 실행하는 게임은 약 90Hz에서 업데이트를 생성할 수 있습니다.

그러나, 간헐적인 효과는 복잡성의 큰 도약을 야기하지만, 일관성이 없어 66Hz까지 갑작스러운 스파이크를 일으킨다.

앱의 GPU 작업을 모니터링함으로써, 장면의 복잡성이 지속적으로 낮아질 때까지 나중에 의도적으로 프레임을 제시하여 복잡성의 급증에 대응할 수 있습니다.

이제, Adaptive-Sync 모범 사례에 대해 이야기해 봅시다.

고정 속도 디스플레이에서, 앱의 GPU 작업이 디스플레이의 유리 간격을 지속적으로 초과할 때, 우리는 이전에 디스플레이의 가장 빠른 재생률의 다음 요소에 도달하기 위해 렌더링 속도를 늦추는 것이 좋습니다.

일반적으로, 그것은 이 예와 같이 초당 목표 프레임을 60에서 30으로 낮추는 것을 의미합니다.

그러나 Adaptive-Sync 디스플레이에 제시할 때, 우리는 그 지침을 바꾸고 있다.

대신 앱이 고르게 할 수 있는 가장 높은 속도로 프레임을 제시하려고 시도해야 합니다.

프레임을 고르게 제시하는 것 외에도, 프레임이 디스플레이가 지원하는 최소 속도 미만으로 표시되는 경우, 새 프레임에서 디스플레이를 사용할 수 없게 될 수 있으며, 이는 앱에서 판단자를 유도할 수 있다는 것을 기억하십시오.

하지만 지원되는 범위에 있는 한, 앱에 가장 적합한 요금을 자유롭게 선택할 수 있습니다.

올해 Mac에 출시될 새로운 디스플레이 지원에 대한 높은 수준의 이해를 얻었으니, 게임에서 적응형 동기화를 활성화하는 방법에 대해 이야기해 봅시다.

먼저, 지원되는 Mac이 필요합니다.

Apple Silicon GPU가 장착된 모든 Mac은 잘 작동할 것이며, 우리는 또한 가장 최근의 Intel 기반 Mac도 지원합니다.

둘째, 지원되는 Adaptive-Sync 디스플레이가 필요하며, Adaptive-Sync 모드를 활성화해야 합니다.

이것은 디스플레이 시스템 환경 설정에서 사용할 수 있는 새로운 가변 재생률을 선택하여 수행할 수 있습니다.

그리고 마지막으로, 당신의 앱은 전체 화면 모드에서 실행되어야 합니다.

Adaptive-Sync 스케줄링을 시도해야 하는지 여부를 감지하기 위해 앱에서 어떤 API를 호출할 수 있는지 봅시다.

먼저, 실행 중인 디스플레이가 적응형 동기화 스케줄링을 할 수 있는지 여부를 결정해야 합니다.

이를 위해, 올해 NSScreen, minimumRefreshInterval 및 maximumRefreshInterval에 몇 가지 새로운 속성이 있습니다.

이 값들은 이 디스플레이에 제시된 프레임의 유효한 화면 시간 범위를 알려줍니다.

고정 프레임 디스플레이에서 이러한 값은 동일하므로, 단순하고 동일하지 않은 비교를 통해 이 화면이 적응형 동기화 모드인지 여부를 알 수 있습니다.

다음으로, 당신의 창이 현재 전체 화면인지 알아야 합니다.

창의 스타일마스크를 확인하여 확인할 수 있습니다.

그리고 앱이 Adaptive-Sync 스케줄링을 활용할 수 있도록 이 두 가지 검사를 모두 결합해야 한다는 것을 기억하십시오.

알았어, 좋아. 이제 Adaptive-Sync 디스플레이와 macOS가 이를 감지하기 위해 제공하는 새로운 API를 다룰 수 있으므로, 기존의 금속 프레젠테이션 기술을 Adaptive-Sync 디스플레이에 고르게 적용할 수 있는 방법을 알아봅시다.

presentAfterMinimumDuration 또는 presentAtTime과 같은 프레임 패싱이 내장된 MetalDrawable API를 사용하여 Adaptive-Sync 디스플레이로 큰 효과를 낼 수 있습니다.

또는, 현재 전화와 사용자 지정 타이머로 자신만의 솔루션을 굴릴 수 있습니다.

몇 가지 다른 구현이 어떻게 작동하는지 살펴봅시다.

우리는 간단한 예시로 시작할 것이다.

여기서, 우리는 드로어블을 획득하고, GPU 작업을 설정하고, 화면에 표시할 것입니다.

우리는 프레임 속도를 설정할 수 있는 Drawable의 배압에 의존하고 있습니다.

고정 속도 디스플레이에서, 우리는 GPU 작업이 디스플레이의 재생률에 맞춰질 것이라는 보장이 없기 때문에 이것이 최선의 생각이 아니라는 것을 알고 있습니다.

하지만 Adaptive-Sync 디스플레이에서 찍은 이 악기 캡처에서 볼 수 있듯이, 우리의 장면이 일관성이 있을 때, 이것은 잘 작동하는 것 같습니다.

여기서 문제는 이 장면이 주기적으로 충돌하고 있다는 것이다.

이 히치는 사용자가 볼 수 있는 말더듬으로 번역될 것이다.

고정된, 심지어 비율로 발표함으로써 그것을 고치려고 노력합시다.

이 기술은 게임 플레이어를 위해 사용자 조정 가능한 FPS 슬라이더를 구현하려는 경우에도 사용할 수 있습니다.

여기서, 우리는 우리가 원하는 주파수를 78Hz로 설정했습니다.

그리고 일반 현재 호출 대신, 우리는 이 Drawable에 대해 present afterMinimumDuration을 사용하고 위에서 정의한 간격을 지정할 것입니다.

그리고 여기서, 당신은 우리가 요청한 속도로 부드럽게 제시된 프레임을 볼 수 있습니다.

우리는 이전 예만큼 빠르게 제시하지는 않지만, 사용자는 말더듬이 발생할 가능성이 훨씬 적으며, 앱은 CPU와 GPU 시간을 덜 사용합니다.

좋아, 그래서 여기가 상황이 좀 더 흥미로워지는 곳이야.

단일 고정 속도를 설정하지 않고도 고르게 진행되는 프레임을 생성하는 접근 방식을 시도해 봅시다.

이를 수행하는 한 가지 방법은 각 프레임을 생성하는 데 필요한 GPU 작업의 롤링 평균을 계산하고 그 시간을 현재 Drawable 호출에 공급하는 것입니다.

첫 번째 프레임의 경우, 평균 GPU 시간을 시작 값으로 로드해야 합니다.

나는 낙관적이고 디스플레이가 여기서 지원할 수 있는 가장 빠른 속도를 목표로 할 것이다.

이것은 우리의 평균을 위한 출발점이 될 것이므로, 우리가 하는 합리적인 추측은 괜찮습니다.

이제, CommandBuffer 완료 핸들러를 첨부하여 GPU가 이 프레임을 렌더링하는 데 소비한 시간을 측정하고 그 시간을 롤링 평균에 통합해 봅시다.

첫째, 우리는 GPU가 작업을 완료하는 데 걸린 시간을 얻을 수 있다.

그런 다음, 우리는 다음 프레임을 제시할 때 사용될 롤링 평균에 새로운 시간을 통합할 것입니다.

그리고 여기 결과가 있습니다.

보시다시피, 우리는 이전 예와 비슷한 속도로 제시하고 있지만, 이 제한은 우리가 생성한 이전 프레임에 의해 결정되며, 다양한 Mac GPU에서 프레임 속도를 생성할 것입니다.

여기서, 우리는 추가 코드 변경 없이 덜 강력한 Mac에서 48Hz에서 동일한 프로그램이 원활하게 실행되는 것을 볼 수 있습니다.

좋아요, 이제 Adaptive-Sync 디스플레이를 위해 앱을 최적화하는 데 사용할 수 있는 몇 가지 새로운 도구와 기술이 있습니다.

macOS의 Adaptive-Sync 디스플레이에 대해 더 알고 싶다면, Apple Developer 사이트에서 새로운 Metal 샘플 프로젝트를 확인하세요.

메탈에서 성능 경험을 제공하는 것에 대해 자세히 알아보려면, 지난 몇 년 동안의 WWDC 강연을 확인하세요.

그리고 이제, iPad Pro의 프레임 페이싱에 대해 더 많이 배울 수 있는 알렉스에게 넘겨줄게.

고마워, 카일.

다음으로, ProMotion에 대해 이야기해 봅시다.

2017년부터 모든 iPad Pro에는 최대 120Hz의 재생률을 제공하는 ProMotion 디스플레이가 장착되어 있습니다.

그러나, 사용자가 올해 iPadOS 15와 함께 iPad에 도입된 저전력 모드를 켰을 때를 포함하여 일부 상황에서는 120Hz를 사용하지 못할 수 있습니다.

적절한 프레임 페이싱을 통해 앱은 디스플레이 특성, 사용자 선호도 및 시스템 상태에 관계없이 모션 콘텐츠를 정확하고 원활하게 표시할 수 있습니다.

우리는 ProMotion과 고정 요금 디스플레이의 차이점과 일부 프레임 속도를 사용할 수 없는 상황을 살펴볼 것입니다.

다음으로, 우리는 디스플레이 링크가 무엇인지, 그리고 당신의 앱이 그것을 어떻게 사용하여 사용자 지정 드로잉을 유도할 수 있는지에 대해 논의할 것입니다.

그리고 마지막으로, 우리는 몇 가지 디스플레이 링크 모범 사례를 제공할 것입니다.

바로 뛰어들자.

카일이 앞서 간략하게 제시했듯이, 고정 60Hz 디스플레이는 고정 케이던스인 16ms마다 새로 고쳐진다.

프레임 속도가 60인 콘텐츠의 원활한 프레젠테이션을 지원합니다.

예를 들어, 60Hz, 30Hz, 20Hz 등.

그러나, 콘텐츠가 디스플레이 재생률, 예를 들어 30Hz보다 느릴 때, 디스플레이 자체는 여전히 같은 케이던스로 새로 고쳐져야 하므로, 다른 모든 프레임은 이전 프레임의 반복이며, 이것은 약간의 전력을 소비합니다.

반면에, 프로모션은 최대 120Hz의 재생률로 뛰어난 반응성을 제공한다.

그것은 또한 화면의 콘텐츠에 적응하여 전력 소비를 줄인다.

그게 어떻게 작동하는지 보자.

물론, 최대 재생률 120Hz에서, 디스플레이는 8ms마다 새로 고쳐진다.

120은 60의 배수이기 때문에, 프로모션은 기존의 모든 프레임 속도를 지원합니다.

그것은 120Hz뿐만 아니라 앱에 대한 일부 중간 프레임 속도도 제공합니다.

게다가, ProMotion은 재생률을 동적으로 조정할 수 있으므로, 부드러운 60Hz 콘텐츠로 반복 없이 16ms마다만 새로 고칠 수 있으며, 그렇지 않으면 고정된 120Hz 디스플레이에서 필요합니다.

이것은 24Hz까지 사실이다.

이제, 이러한 프레임 속도를 항상 사용할 수 있는 것은 아닙니다.

사용자는 최대 프레임 속도를 60Hz로 제한하는 접근성 설정에서 프레임 속도 제한 토글을 켤 수 있습니다.

또한, 장치가 뜨거워지면, 시스템은 120Hz의 가용성에 제한을 적용할 수 있다.

iPadOS 15에서는 저전력 모드에서 60Hz 캡을 시행할 것입니다.

그래서, 이 시나리오들은 당신의 앱에 어떤 영향을 미칩니까?

좋은 소식은 대부분의 앱이 아무런 변화 없이 작동한다는 것이다.

하지만 앱이 프레임별 사용자 지정 드로잉을 수행한다면, 이러한 프레임 속도 변경에 주의를 기울여야 하며, 어떻게 하는지 보여드리겠습니다.

사용자 지정 드로잉을 구동하는 데 권장되는 도구는 디스플레이 링크이며, 이는 본질적으로 디스플레이 재생률과 동기화되는 타이머입니다.

앱이 사용자 지정 애니메이션이나 사용자 지정 렌더링 루프를 구동하는 데 도움이 됩니다.

두 개의 디스플레이 링크가 있습니다.

하나는 macOS의 CoreVideo에서 제공하는 CVDisplayLink이고, 다른 하나는 다른 플랫폼의 CoreAnimation과 macOS의 Catalyst가 제공하는 CADisplayLink이며, 각각 약간 다른 특성과 동작을 가지고 있습니다.

오늘, 우리는 CADisplayLink에 대해서만 논의할 것이지만, 높은 수준에서, 이러한 개념은 둘 다에 적용될 것이다.

CADisplayLink는 모든 vsync에서 깨어나 콜백을 호출합니다.

이것은 작업을 완료하기 위해 전체 8ms를 제공한다.

NSTimer와 같은 일반 타이머는 디스플레이와 완벽하게 동기화될 것 같지 않다.

그것은 위상을 벗어나거나 표류할 수 있으므로, 때때로 앱은 작업을 완료할 충분한 시간이 없을 수 있으며 프레임 드롭으로 이어질 수 있습니다.

이제 CADisplayLink가 어떻게 일관된 타이밍을 제공하는지 보았습니다. 여기에 몇 가지 추가 이점이 있습니다.

그것은 디스플레이 재생률보다 느린 속도로 실행될 수 있으며, 그렇게 하기 위해, 당신의 앱은 preferredFramesPerSecond를 통해 힌트를 제공하며 우리는 당신에게 가장 가까운 사용 가능한 프레임 속도를 선택할 것입니다.

앞서 논의한 바와 같이 프레임 속도 가용성이 변경되면, CADisplayLink는 자동으로 후드 아래에서 속도를 조정할 것입니다.

물론, 사용자 지정 도면이 이러한 변경 사항을 알 수 있도록 앱에 필요한 타이밍 정보를 제공합니다.

우리는 사용자 지정 애니메이션이나 사용자 지정 렌더링 루프를 작성하는 방법에 들어가지 않을 것이지만, 사용자 지정 도면이 디스플레이 타이밍과 동기화되고 일반적인 함정을 피할 수 있도록 네 가지 모범 사례를 제공할 것입니다.

먼저, 하드 코딩하는 대신 런타임에 디스플레이 새로 고침 빈도를 쿼리하는 것이 중요합니다.

둘째, 일반적으로 CADisplayLink 자체의 프레임 속도를 사용해야 하는 경우입니다.

다음으로, 타겟 타임스탬프를 사용하여 도면을 준비하면 히치를 줄이는 데 도움이 될 것이다.

마지막으로, 시간 델타를 동적으로 계산하여 예상치 못한 상황에 대비하는 것은 항상 좋은 생각이다.

그것들을 하나씩 살펴보자.

최대 디스플레이 새로 고침 빈도는 저전력 모드가 켜져 있는 것과 같은 상황에서도 ProMotion 디스플레이에서 항상 120Hz를 반환하는 UIScreen을 통해 쿼리할 수 있습니다.

반면에, CADisplayLink는 실제로 기간 속성을 통해 프레임 간의 최단 간격을 제공하며, 현재 장치 상태에 따라 동적으로 업데이트됩니다.

하지만 거의 항상, 디스플레이 링크가 최대 디스플레이 재생률보다 느리게 실행될 수 있기 때문에 CADisplayLink에서 직접 실제 프레임 정보를 사용해야 합니다.

또한, 프레임 속도 가용성은 하드웨어에 따라 다르며, 실제 프레임 속도는 시스템 상태 변경에 대응하여 디스플레이 링크 자체에 의해 동적으로 변경될 수 있습니다.

예를 들어 봅시다.

우리가 40Hz 디스플레이 링크를 요청한다고 가정해 봅시다.

보시다시피, ProMotion 디스플레이에서는 40Hz가 지원됩니다.

그러나, 60Hz 디스플레이에서, 또는 ProMotion이 60Hz로 제한될 때, 디스플레이 링크는 자동으로 30Hz로 조정됩니다.

이것은 각 웨이크업이 각 프레임에 대해 동일한 양의 시간을 제공하려고 시도하는 가능한 vsync에 있는 좋은 케이던스를 보장합니다.

프레임 속도를 인식하지 못하는 일반 40Hz NSTimer를 사용한다면, 웨이크업은 vsync 간격의 중간에 있을 수 있으며, 물론 프레임을 제시할 수 없으므로 사용자 지정 도면에서 히치를 관찰할 수 있습니다.

그래서, 그것은 코드에서 어떻게 보이나요?

음, 여기 당신이 보통 디스플레이 링크를 설정하는 방법이 있습니다.

먼저, 호출할 콜백인 대상과 선택기를 제공해야 합니다.

다음으로, preferredFramesPerSecond를 통해 40Hz의 선호하는 프레임 속도를 암시하세요.

그런 다음 콜백이 호출될 현재 런루프에 표시 링크를 추가합니다.

따라서 콜백에서 targetTimestamp에서 타임스탬프를 빼서 디스플레이 링크 웨이크업 사이의 예상 간격을 얻을 수 있습니다.

디스플레이 링크 자체가 다른 주파수로 실행될 수 있기 때문에 이 간격이 항상 40 이상인 것은 아니다.

다음으로, 이 타임스탬프에 대해 이야기해 봅시다.

CADisplayLink에는 주로 두 개의 타임스탬프, 콜백이 호출될 때를 나타내는 타임스탬프와 다음 프레임이 CoreAnimation에 의해 합성될 때인 targetTimestamp가 있습니다.

우리는 당신이 그림을 준비하기 위해 targetTimestamp를 사용해야 하는 이유를 보여주는 예를 살펴볼 것입니다.

여기 0에서 1까지의 정규화된 시간 영역의 애니메이션이 있습니다.

우리가 가능한 가장 높은 프레임 속도를 목표로 하고 있고 현재 120Hz라고 가정해 봅시다.

CADisplayLink가 깨어나고, 타임스탬프를 사용하여 프레임 프레젠테이션을 준비한다면, 우리는 다음 vsync에서 제시되는 여기에서 직접 샘플링할 것이며, 여기에 있습니다.

같은 과정이 계속되며, 우리는 각 120Hz 프레임에 대해 애니메이션 진행이 0.05 증가하는 좋은 케이던스를 가지고 있다는 것을 알 수 있습니다.

이제, 열 상태가 바뀌고, 120Hz를 더 이상 사용할 수 없다고 가정해 봅시다.

이제 디스플레이 링크가 다시 깨어나고, 앱은 바로 다음 vsync에서 표시되는 진행 0.4에서 애니메이션을 준비합니다.

그리고 같은 패턴이 계속된다.

여기 전환에서 뭔가 옳지 않아.

우리는 진행이 0.05 증가한다는 것을 알지만, 하나는 8ms 이상이고, 다른 하나는 16ms 이상이다.

우리가 진행 상황과 시간을 계획한다면, 우리는 전환에서 바로 딸꾹질을 보게 될 것이며, 이것은 사용자가 인지할 수 있는 히치로 반영될 것이며, 그것은 바람직하지 않다.

이제, targetTimestamp를 시도해 봅시다.

CADisplayLink는 여기서 일어난다.

진행 상황은 0.15를 제공하는 targetTimestamp에서 샘플링됩니다.

같은 패턴이 계속되고, 다시, 우리는 좋은 케이던스를 본다.

이 프레임 속도 전환 지점에서, 디스플레이 링크가 깨어나고, targetTimestamp에서 샘플을 가져오고, 우리는 0.50을 얻는다.

그리고 그것은 같은 방식으로 계속된다.

우리가 동일한 진행률 대 시간 그래프를 플로팅하면, 당신은 그것이 직선이라는 것을 알게 될 것이며, 따라서 프레임 속도가 변경될 때에도 부드러운 콘텐츠를 제공합니다.

따라서, 도면을 준비하기 위해 타임스탬프 대신 타겟 타임스탬프를 사용해야 합니다.

코드에서는 일반적으로 타임스탬프 사용을 targetTimestamp로 교체하는 것만큼 간단해야 합니다.

마지막으로, 시간 델타를 동적으로 계산하는 것에 대해 이야기해 봅시다.

타겟 타임스탬프와 타임스탬프의 차이는 디스플레이 링크 콜백 사이의 예상 시간을 제공하지만, 실제 시간은 보장되지 않습니다.

우선 순위가 높은 스레드가 CPU에서 예약되거나 런루프가 다른 것으로 바쁠 수 있습니다.

극단적인 경우, 콜백은 완전히 건너뛸 수 있으므로, 이러한 상황에서는 최고의 사용자 경험을 위해 사용자 지정 도면에서 올바른 타이밍을 유지하는 것이 특히 중요합니다.

CADisplayLink 콜백이 호출되면, 앱은 다음 프레임에 필요한 업데이트나 렌더링을 준비하기 위해 작업을 수행합니다.

보통, 콜백은 예정된 기상 시간에 바로 호출되지만, 그렇지 않다.

우리는 다음 콜백이 여기서 호출될 것으로 예상한다.

그러나, 디스플레이 링크는 vsync 간격으로 몇 밀리초까지 실행될 기회가 없다.

따라서, 당신은 전체 8ms를 얻지 못할 수도 있습니다.

이 경우, CACurrentMediaTime을 쿼리하고 targetTimestamp와 비교하여 사용 가능한 시간을 알 수 있습니다.

이제, 이 프레임에서 작업이 너무 오래 걸린다고 가정해 봅시다.

다음 콜백은 런루프가 다시 자유로워질 때까지 호출되지 않을 것이다.

이것이 지연되기 때문에, 다음 콜백은 건너뜁니다. 따라서 이 콜백에서 사용자 지정 도면의 진행 상황을 진행할 준비를 할 때, 사용자 지정 도면 상태가 업데이트된 이전 타임스탬프를 추적하려면 사용해야 하는 시간 델타가 8ms가 아니라 16ms라는 것을 명심하십시오.

따라서, 앱이 시간 델타를 사용하여 사용자 지정 드로잉의 상태를 발전시킨다면, 칼백을 건너뛸 때마다 사용자 지정 드로잉이 한 프레임씩 느려집니다.

대신 상태를 올바르게 진행할 수 있도록 이전 타겟 타임스탬프를 추적할 수 있습니다.

그리고 사용자 지정 도면의 작업량이 높은 경우, targetTimestamp를 보고 필요에 따라 마감일을 맞추기 위해 작업량을 줄일 수 있습니다.

모범 사례를 요약하자면, 디스플레이 재생률을 추측하지 마세요.

항상 런타임에 쿼리하세요.

사용자 지정 도면은 지원되는 프레임 속도에서 유연해야 하며 다른 속도에 적응할 준비가 되어 있어야 합니다.

targetTimestamp를 사용하여 히치 없는 프레임 속도 전환을 보장하고, 놓친 디스플레이 링크 콜백과 같은 예상치 못한 상황을 조심하세요.

그럼, 마무리하자.

이 세션의 전반부에서는 macOS의 Adaptive-Sync 디스플레이에서 실행할 때 앱의 프레임 속도를 최적화하는 방법에 대해 논의했습니다.

하반기에는 앱이 iPad Pro의 ProMotion 디스플레이에서 모든 조건에서 사용자 지정 드로잉을 유도하고 부드러운 프레임 속도를 유지하기 위한 모범 사례를 설명했습니다.

디스플레이 기술이 계속 발전함에 따라, 우리는 이 세션이 당신에게 통찰력뿐만 아니라 디스플레이의 점점 더 역동적인 타이밍을 지원하기 위한 도구와 모범 사례를 제공했기를 바랍니다.

우리와 함께 해주셔서 정말 감사드리며, 나머지 WWDC 2021을 즐기세요.

[음악].