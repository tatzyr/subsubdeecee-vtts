10053

♪ 베이스 음악 연주 ♪

♪

Owen Monsma: 안녕하세요, "훌륭한 Mac Catalyst 앱의 품질"에 오신 것을 환영합니다.

제 이름은 오웬 몬스마이고, 저는 코코아 엔지니어입니다.

그리고 나는 나중에 UIKit의 동료 Dave Rahardja와 합류할 것이다.

오늘 우리는 놀라운 카탈리스트 앱을 만들기 위한 세 가지 중요한 고려 사항을 검토할 것입니다.

먼저, Mac Catalyst 앱으로 마이그레이션할 때 발생하는 몇 가지 높은 수준의 변경 사항을 다룰 것입니다.

다음으로, Mac에서 앱 경험을 개선하기 위해 할 수 있는 몇 가지 특정 코드 수정에 대해 알아보겠습니다.

그리고 우리는 앱 배포에 대한 정보로 끝낼 것이다.

그러니 앱을 Mac Catalyst로 마이그레이션하는 것부터 시작합시다.

훌륭한 Catalyst 앱을 향한 첫 번째 단계는 훌륭한 iPad 앱을 갖는 것이며, 앱은 이미 M1이 설치된 Mac에서 추가 변경 없이 실행됩니다.

M1 Mac이 있다면, Xcode에서 Designed for iPad 실행 대상으로 바로 시도해 볼 수 있습니다.

iPad에서 이러한 기능을 채택함으로써, 당신의 Mac 앱은 좋은 출발을 할 것입니다.

앱이 iPad에서 멀티태스킹을 지원하는 경우, Mac에서 자동으로 여러 창 지원을 받을 수 있습니다.

그리고 UIMenuBuilder를 사용하는 경우, 메뉴는 앱의 메뉴 표시줄과 보기를 보조 클릭으로 상황에 맞는 메뉴로 자동으로 선택됩니다.

우리는 또한 복사/붙여넣기 및 드래그 앤 드롭과 같은 시스템 동작을 자동으로 연결합니다.

iPad 앱이 M1 Mac에서 있는 그대로 실행되는 방식에 대해 자세히 알아보려면, "M1이 설치된 Mac에서 훌륭한 iPad 및 iPhone 앱의 품질" 비디오를 확인하세요.

하지만 당신은 더 나아가고 싶기 때문에 여기에 있습니다.

Mac 확인란을 선택하면 모든 Mac에 배포할 수 있으며, 추가 API에 액세스하여 앱을 더욱 구체화할 수 있습니다.

그래서 우리 앱으로 하자, 트립 플래너!

Xcode 프로젝트 설정에서 배포 정보 아래의 Mac 옵션을 확인합니다.

오른쪽에 추가 팝업이 나타나 확장된 iPad 인터페이스와 Mac에 최적화된 인터페이스 중에서 선택할 수 있습니다.

우리는 이 선택을 조금 더 검토할 것이다.

지금은 Xcode 도구 모음에서 빌드를 클릭하고 실행해 봅시다.

그리고 우리의 앱은 빌드되고 실행됩니다!

이제, 앱이 빌드에 실패했다면, 조사해야 할 몇 가지 사항이 있습니다.

더 이상 사용되지 않는 특정 프레임워크와 클래스는 Mac Catalyst에서 사용할 수 없으므로, 이제 현대화할 때입니다.

이것은 당신의 앱을 Mac에서 실행할 뿐만 아니라, 당신의 iOS 앱도 향상시킬 것입니다.

OpenGLES에서 Apple의 자체 Metal 프레임워크로 이동하면 GPU의 모든 기능을 잠금 해제할 수 있습니다.

연락처 프레임워크는 더 이상 사용되지 않는 주소록을 대체했으며 연락처를 처리하는 미래 지향적이고 스레드에 안전한 방법입니다.

그리고 UIWebView는 더 이상 사용되지 않으며 WKWebView로 대체되었습니다.

또한, 제3자 종속성을 확인하세요.

이러한 프레임워크가 XCFramework 번들로 배포되는 경우, 연결할 Mac 바이너리를 제공해야 합니다.

Mac 앱에서 작업을 시작할 때, 프로젝트를 빌드할 때 컴파일러 경고를 주시하고, 콘솔 로그에서 런타임 메시지를 모니터링하세요.

이 경고는 Mac Catalyst 프로세스로 잘 실행되도록 코드를 수정하는 방법을 알려줍니다.

그리고 향후 macOS 릴리스에서 앱이 계속 실행되도록 지원되는 API만 사용하는 것을 잊지 마세요.

Mac에서 실행할 때 앱이 받게 될 수명 주기 이벤트를 인식하는 것도 중요합니다.

앱이 현재 앱 대리자에서 호출된 수명 주기 이벤트에 의존하는 경우, 대신 앱이 데스크톱의 각 창의 콘텐츠와 관련된 이벤트에 응답할 수 있도록 장면 수명 주기를 모니터링해야 합니다.

Mac Catalyst 앱은 iPad 앱만큼 자주 sceneDidEnterBackground 이벤트를 받지 않는다는 것을 기억하십시오.

데스크톱 창이 최소화되거나 닫힐 때 장면은 배경 상태로 들어갑니다.

앱이 sceneDidEnterBackground를 사용하여 문서 자동 저장과 같은 일상적인 작업을 수행하는 경우, 대신 타이머를 사용하면 이 작업을 정기적으로 수행할 수 있습니다.

마지막으로, Catalyst 앱은 장면이 없을 수 있지만 전경에서 계속 실행된다는 것을 기억하세요.

이 상태는 모든 앱의 창이 닫혔을 때 발생하지만, 앱의 이름은 메뉴 표시줄에 표시됩니다.

이제 Mac용 인터페이스를 최적화할지 여부를 결정합시다.

이것은 앱을 처음 가져오기 시작할 때 내려야 할 가장 중요한 결정 중 하나입니다.

Mac 관용구를 사용하면 앱이 Mac에서 가장 편안함을 느낄 수 있도록 하는 것이 권장되지만, 추가 작업이 필요합니다.

Mac 관용구에서, 앱은 100% 스케일로 실행되며, 픽셀처럼 완벽한 텍스트와 이미지, 그리고 기본 AppKit 컨트롤을 제공합니다.

원한다면, 자산 카탈로그에 새로운 Mac 전용 자산을 추가하여 이 추가 세부 사항을 활용할 수 있습니다.

모든 모니터 해상도를 지원하기 위해 1x와 2x 자산을 모두 제공하는 것이 좋습니다.

많은 컨트롤의 크기 지표가 변경되므로, 이를 수용하기 위해 앱의 레이아웃을 조정하는 것이 중요합니다.

앱의 사용자 지정 컨트롤의 경우, 추가 선택이 있습니다.

자동으로, 당신은 Mac 스타일의 제어를 얻을 수 있습니다.

하지만 이제 이 변환에서 버튼과 슬라이더를 선택하여 Mac 컨트롤에서 사용할 수 없는 사용자 지정 API를 사용할 수 있습니다.

UISlider에 엄지손가락을 설정하는 것과 같은 사용자 지정 자산을 사용하는 경우 기본적으로 예상보다 크게 표시되므로 확장하거나 새로운 자산을 제공해야 할 수도 있습니다.

또한 Mac 사용자는 AppKit 스타일의 컨트롤을 기대하므로 사용자 지정 컨트롤을 아껴서 사용해야 합니다.

Mac 관용구에 대한 자세한 내용은 "Mac Catalyst 앱의 인터페이스 최적화" 비디오를 확인하세요.

Mac 관용구의 Catalyst 앱은 AppKit 제어 스타일을 취하기 때문에 일부 컨트롤의 모양과 동작이 모두 바뀔 것입니다.

"Mac Catalyst의 새로운 기능" 비디오에서 우리는 Mac 버튼 유형 제품군을 마무리하는 새로운 팝업 버튼 스타일을 소개했습니다.

무엇이 이러한 컨트롤을 다르게 만드는지, 그리고 시스템이 어떤 것을 사용할지 선택하는 방법에 대해 알아봅시다.

이러한 컨트롤과 일반적으로 발견되는 위치를 이해하면 앱에서의 사용에 대해 정보에 입각한 선택을 하는 데 도움이 될 것입니다.

기본 UIButton 유형은 UIButton 유형 .system입니다.

이 버튼 유형을 사용하면, 버튼은 자동으로 컨텍스트에 대한 예상 모양을 취합니다.

맥 관용구에서, 이것은 테두리가 있는 푸시 버튼이 된다는 것을 의미한다.

풀다운 버튼은 가능한 작업 목록을 제공하는 데 사용되는 Mac 네이티브 컨트롤이며, 단일 화살표 표시기로 그려집니다.

좋은 예는 PDF로 저장 또는 메일로 보내기와 같은 작업을 제공하는 인쇄 대화 상자의 PDF 풀다운입니다.

풀다운 버튼을 받으려면, 메뉴 속성을 통해 버튼에 UI 메뉴를 할당했는지 확인하고, 추가로 showsMenuAsPrimaryAction을 true로 설정하십시오.

당신의 버튼은 풀다운 모양을 취하고 클릭 한 번으로 메뉴를 표시할 것입니다.

그리고 macOS Monterey가 있는 Catalyst의 새로운 것은 팝업 버튼이다.

팝업 버튼은 풀다운 버튼과 비슷해 보이지만 이중 화살표 표시기가 있으며, 약간 다른 일을 한다.

풀다운이 동작을 트리거하는 경우, 팝업 버튼은 상호 배타적인 옵션 세트 중 하나를 선택하는 데 사용됩니다.

예를 들어, 요일을 선택하세요.

그런 다음 버튼의 제목은 선택을 반영하도록 업데이트됩니다.

이것은 앱에서 UIPickerView를 대체할 수 있는 좋은 Mac 친화적인 선택입니다.

이 컨트롤을 얻는 것은 풀다운 버튼과 비슷하지만, 속성 changesSelectionAsPrimaryAction도 참이어야 합니다.

마지막으로, 체크박스는 비독점적인 바이너리 토글을 나타내는 데 사용되며, 스위치에 대한 마우스 친화적인 대안이다.

그리고 알고 보니, 추가 작업 없이 체크박스를 받을 수 있습니다!

스위치에 제목 세트가 있는지 확인하고, 제목 속성은 Mac 관용구에서만 지원된다는 것을 명심하세요.

기본적으로 스위치는 선호하는 자동 스타일을 가지고 있으며, 읽기 전용 스타일 속성을 사용하여 스위치인지 확인란인지 런타임에 확인할 수 있습니다.

이제, 몇 가지 구체적인 코드 변경 사항에 대해 자세히 알아보려면, 제 동료인 데이브에게 넘겨봅시다.

데이브 라하르자: 안녕하세요 여러분, 제 이름은 데이브이고, 저는 UIKit 팀의 엔지니어입니다.

Mac Catalyst 앱을 더 편안하게 만들기 위해 할 수 있는 몇 가지 구체적인 일에 대해 이야기해 봅시다.

Mac Catalyst 앱은 훨씬 더 많은 화면 부동산에 접근할 수 있다.

앱의 창은 iPad보다 Mac에서 훨씬 더 크게 크기를 조정할 수 있으며, 전체 화면으로 표시할 수 있습니다.

잠시 시간을 내어 앱 창의 크기를 조정하고 레이아웃에 주의를 기울이세요.

앱을 더 쉽게 사용할 수 있도록 더 많은 콘텐츠와 컨트롤을 보여주기 위해 추가 공간을 사용하고 있는지 확인하세요.

실시간 크기 조정은 앱의 레이아웃 성능을 테스트할 것입니다.

앱은 크기를 조정하는 동안 앱의 창이 반응할 수 있도록 레이아웃 중에 가능한 최소한의 작업을 수행해야 합니다.

모달 프레젠테이션과 팝오버에 의존하는 앱의 상호 작용에 특별히 주목하세요.

더 큰 디스플레이 영역을 사용하면 어린이 보기로 표시하여 이러한 상호 작용을 항상 사용할 수 있습니다.

이제, 포인터 입력 장치에 대해 이야기해 봅시다.

모든 Mac에 트랙패드가 있는 것은 아니며, 일부 Mac은 스크롤을 지원하지 않는 입력 장치에 연결되어 있다는 것을 기억하십시오.

보기가 핀치 또는 회전 제스처에 의존하는 경우, 스크롤 입력 없이 마우스를 사용하여 모든 기능에 액세스할 수 있는지 확인하십시오.

Mac Catalyst 앱의 보기에 추가 버튼이나 기타 컨트롤을 추가하여 모든 기능에 액세스할 수 있도록 하십시오.

또한, 탭 또는 팬 제스처 인식기에서 키보드 수정자를 감지하면 뷰의 기능에 더 빠르게 액세스할 수 있습니다.

예를 들어, Shift-pan을 확대/축소할 수 있습니다.

키보드 단축키와 메인 메뉴에 대해 이야기해 봅시다.

Mac 앱의 메인 메뉴는 앱에서 사용할 수 있는 모든 작업과 관련 키보드 단축키를 찾을 수 있는 좋은 장소입니다.

앱이 이미 응답자의 키 명령을 반환하여 키보드 단축키를 지원하는 경우, 대신 메뉴 빌더 API를 사용하여 이러한 명령을 메인 메뉴에 추가하십시오.

모든 키보드 단축키를 메인 메뉴로 이동하면 현재 활성화되어 있지 않은 경우에도 검색할 수 있습니다.

게다가, MenuBuilder API를 사용하여 Mac Catalyst에서 단축키를 구성하면 iPad 단축키 오버레이에서도 구성할 수 있습니다.

메인 메뉴를 만들 때, 앱과 상호 작용하는 데 필요한 모든 작업을 추가해야 합니다.

iPad에서 제스처로 수행된 작업은 메인 메뉴에서 항목을 선택하여 액세스할 수 있어야 합니다.

메뉴 항목에 키보드 단축키를 추가하면 이러한 작업에 훨씬 더 빠르게 액세스할 수 있습니다.

메뉴 표시줄과 키 명령 동작은 첫 번째 응답자부터 라우팅되기 때문에, 해당 동작의 대상이 될 뷰가 첫 번째 응답자가 될 수 있고 초점을 받아들일 수 있는지 확인하십시오.

canBecomeFirstResponder와 canBecomeFocused 속성에 대한 견해를 참으로 반환함으로써 이것을 할 수 있습니다.

Mac 앱은 뷰의 직접 조작에 덜 의존해야 하고, 사용자가 뷰를 선택한 다음 메인 메뉴에서 작업을 선택하는 데 더 많이 의존해야 하기 때문에, 더 많은 앱의 뷰가 첫 번째 응답자가 되고 집중할 수 있는 능력은 Mac Catalyst에서 더 중요해집니다.

초점과 첫 번째 응답자에 대한 자세한 내용은 "iPad 키보드 내비게이션에 집중" 비디오를 확인하세요.

우리가 응답자의 주제를 다루는 동안, 앱에서 응답자 체인을 수정하지 않은 채로 두어야 합니다.

즉, nextResponder를 무시하지 마세요.

응답자 체인을 수정하지 않은 채로 두면 Mac Catalyst가 당신의 행동을 적절한 목표로 라우팅할 수 있습니다.

앱이 응답자 체인에 없는 개체를 사용하여 특정 작업을 처리해야 하는 경우, target(for Action:, withSender:) 함수를 사용하여 이러한 작업을 적절한 개체에 대신 위임하십시오.

코드를 검토해 봅시다.

이 예에서, 우리의 견해는 setAsFavorite 작업을 모델 객체에 위임하는 한편, 다른 작업이 응답자 체인을 계속 전파할 수 있도록 합니다.

이제 장면과 그들이 Mac Catalyst 앱에서 어떻게 작동하는지에 대해 이야기해 봅시다.

Mac 앱은 동시에 많은 데스크톱 창을 열 수 있습니다.

Mac Catalyst 앱에서, 이 창들 각각은 UIWindowScene과 페어링됩니다.

당신의 앱은 다른 기능을 가진 창을 제공할 수 있습니다.

예를 들어, 문서 창, 세부 보기 창, 메시지 작곡가 창 등을 가질 수 있습니다.

이러한 다양한 장면 기능을 구성하는 가장 좋은 방법은 각 유형의 창에 대한 장면 구성을 정의하는 것입니다.

장면 구성을 정의하려면, 애플리케이션 장면 매니페스트 항목 아래의 Info.plist에 추가하십시오.

애플리케이션 세션 역할 배열 아래에서, 앱이 지원하는 각 유형의 장면에 대해 하나의 구성을 만드세요.

이러한 각 구성에 이름을 지정하고 장면이 생성될 때 인스턴스화될 장면 클래스, 위임 클래스 및 스토리보드를 선택하십시오.

이제 장면 구성을 정의했으므로, 특정 구성의 새로운 장면을 만드는 데 어떻게 사용할 수 있는지 논의해 봅시다.

이 예에서, 우리는 뷰를 두 번 클릭할 때 새로운 세부 뷰어 장면을 만들고 싶습니다.

우리가 가장 먼저 하는 일은 세부 뷰어 장면을 요청하기 위한 새로운 사용자 활동 유형을 정의하는 것입니다.

우리는 그것을 viewDetailActivityType이라고 부를 것이다.

새로운 사용자 활동을 만들 때, 우리는 자세히 보여주고 싶은 항목에 대한 식별자를 전달하고 싶습니다.

그렇게 하기 위해, 우리는 사용자 정보 사전에 그 정보를 저장할 itemIDKey를 정의합니다.

그런 다음, 더블 클릭 이벤트 핸들러에서, 우리는 적절한 유형의 새로운 NSUserActivity 객체를 만들고, userInfo 속성을 우리가 표시하고 싶은 itemID를 보유하는 사전으로 설정합니다.

마지막으로, 우리는 방금 만든 사용자 활동을 전달하는 UIApplication requestSceneSessionActivation 함수를 호출합니다.

이것은 시스템이 우리의 새로운 장면을 만들게 할 것이다.

그래서 이제 우리는 특정 사용자 활동 유형에 대한 새로운 장면을 요청하는 방법을 알고 있습니다.

이제 그 정보를 사용하여 적절한 장면 구성을 로드하는 방법에 대해 이야기해 봅시다.

우리는 애플리케이션 대리인에 애플리케이션 configurationForConnecting 기능을 구현하여 장면 생성 요청에 응답합니다.

구현에서, 우리는 들어오는 장면 요청에 사용자 활동이 포함되어 있는지 검사합니다.

요청은 여러 사용자 활동을 포함할 수 있지만, 이 코드 예제의 경우, 우리는 첫 번째 것을 검토할 것입니다.

우리가 처리해야 할 활동이 있다면, 우리는 그 활동 유형을 확인합니다.

여기서, 우리는 그것이 viewDetailActivityType과 같은지 테스트합니다.

그렇다면, 우리는 DetailViewer라는 장면 구성을 반환합니다.

이렇게 하면 시스템이 Info.plist에서 해당 이름의 구성을 확인하고, 적절한 장면과 장면 위임 클래스를 로드하고, 지정된 스토리보드를 새 데스크톱 창에 표시합니다.

특정 장면 구성을 로드해서는 안 된다면, 우리는 기본 구성을 반환합니다.

할 일이 하나 더 있어.

우리가 표시할 항목에 대한 itemID를 저장했다는 것을 기억하나요?

우리는 여전히 우리가 방금 만든 장면의 뷰 컨트롤러에 그 값을 설정해야 합니다.

우리는 SceneDelegate 수업에서 그것을 한다.

장면 willConnectTo 세션 기능은 장면이 데스크톱에 표시되기 직전에 호출됩니다.

애플리케이션 대리인에게 전달된 사용자 활동도 장면 대리인의 이 기능으로 전달됩니다.

이제 userInfo 사전에서 itemID를 추출하여 새 뷰 컨트롤러에 설정할 수 있습니다.

NSUserActivity를 사용하여 새로운 장면을 구성하면 앱이 상태 복원을 더 쉽게 지원할 수 있습니다.

장면 대리인이 stateRestorationActivity(장:) 콜백에 응답하면, 반환된 사용자 활동은 앱이 종료될 때 시스템에 의해 저장됩니다.

시스템 환경 설정에서 상태 복원이 활성화된 경우, 다음에 앱이 실행될 때, 시스템은 장면을 다시 만들고 각 장면의 사용자 활동 개체를 앱 대리인의 애플리케이션 구성ForConnecting SceneSession 기능에 전달합니다.

이것은 앞서 다룬 바와 같이 앱이 새로운 장면을 만들 때 호출되는 것과 동일한 기능입니다.

일관된 활동 유형 세트를 사용하면 앱이 새 데스크톱 창을 만들고 상태를 복원하는 동안 동일한 코드를 사용하여 적절한 장면 구성을 선택할 수 있습니다.

앱이 동일한 코드로 새로운 장면 요청과 상태 복원을 모두 처리할 수 있도록 장면 대리인에 추가해야 할 한 가지가 있습니다. 즉, 장면 연결 옵션의 활동이 0인 경우 stateRestorationActivity로 돌아가도록 장면 대리인의 scene willConnect 세션 기능을 수정하는 것입니다.

이제 당신의 앱은 새로운 장면 요청과 상태 복원을 처리할 준비가 되었습니다.

상태 복원에 대한 자세한 내용은 "iPad에서 여러 Windows 소개" 비디오를 확인하세요.

다음으로, 앱의 도구 모음에 대해 이야기해 봅시다.

훌륭한 Mac 앱은 Windows의 도구 모음을 사용하여 자주 사용되는 작업과 빠른 액세스를 위한 기타 탐색 옵션을 제공합니다.

iOS의 도구 모음과 달리, Mac Catalyst 앱의 데스크톱 창의 도구 모음은 뷰 컨트롤러가 분할 보기 컨트롤러 또는 탐색 컨트롤러에 나타나고 사라지면서 변경되지 않습니다.

도구 모음은 장면과 강하게 연관되어 있기 때문에, 도구 모음을 구성하는 가장 좋은 장소는 장면 대리자 하위 클래스입니다.

도구 모음에서 일반적으로 발견되는 중요한 항목 중 하나는 공유 버튼이다.

도구 모음에 NSSharingServicePicker ToolbarItem을 추가하면 앱이 Mac의 표준 공유 메뉴를 사용하여 장면에 표시된 주요 콘텐츠를 공유할 수 있습니다.

macOS Monterey에서, 우리는 버튼이 당신의 장면에서 공유하는 활동 항목 구성을 자동으로 사용할 수 있는 기능을 추가했습니다.

이것은 Siri의 새로운 Share This 기능이 iOS에서 사용하는 것과 동일한 구성입니다.

장면에 대한 공유 구성을 제공하는 좋은 방법은 RootViewController의 activityItemsConfiguration 속성에서 객체를 반환하는 것입니다.

Mac Catalyst에서 앱 도구 모음의 NSSharingServicePicker ToolbarItem은 이 속성을 자동으로 사용합니다.

iOS에서 Siri는 Share This를 사용하여 동일한 속성을 사용하여 데이터를 공유합니다.

물론, 도구 모음은 앱이 공유할 항목을 제공할 수 있는 유일한 장소가 아닙니다.

종종, 당신은 상황에 맞는 메뉴를 통해 이미지나 다른 항목의 공유를 허용하고 싶을 것입니다.

이렇게 하려면, 보기에서 activityItemsConfiguration 객체를 반환한 다음 contextMenuInteraction을 추가하십시오.

다음은 Mac Catalyst와 iPad 모두에서 결과입니다.

Mac Catalyst에서는 복사 작업과 공유 메뉴가 자동으로 추가된다는 점에 유의하십시오.

그리고 앱이 iPad에서 실행되면, 복사 및 공유 작업이 추가됩니다.

공유 작업을 탭하면 공유 시트가 자동으로 표시됩니다.

활동 항목 구성 API를 사용하면 앱이 보기를 공유할 수 있는 것을 선언할 수 있으므로 시스템이 각 플랫폼에 적절한 UI를 표시할 수 있습니다.

이제 앱이 데이터를 공유할 수 있는 방법에 대해 이야기했으므로, 앱이 연속성 카메라를 사용하여 iPhone 또는 iPad에서 이미지를 가져올 수 있는 방법에 대해 이야기해 봅시다.

앱이 UITextView를 사용하여 리치 텍스트를 표시하는 경우, macOS Monterey에서 연속성 카메라 지원이 자동으로 활성화됩니다.

텍스트 보기를 마우스 오른쪽 버튼으로 클릭하면 iPhone 또는 iPad에서 사진을 찍고 자동으로 첨부 파일로 추가할 수 있는 옵션이 있는 상황에 맞는 메뉴가 표시됩니다.

모든 보기에 연속성 카메라에 대한 지원을 추가하려면, 보기의 pasteConfiguration 속성에서 이미지를 받아들이는 UIPasteConfiguration 객체를 반환한 다음 UI contextMenuInteraction을 추가하십시오.

그런 다음 paste(itemProviders:) 기능을 구현하여 들어오는 개체를 로드하고 붙여넣습니다. 이 경우 이미지입니다.

보너스로, 보기에서 붙여넣기 구성을 반환하면 구성이 이미지를 받아들일 때 연속성 카메라가 활성화될 뿐만 아니라 컨텍스트 메뉴에서 붙여넣기 작업을 자동으로 활성화하고 보기가 Mac Catalyst와 iPad 모두에서 들어오는 드래그를 수락할 수 있습니다.

그래서 그것들은 당신의 앱을 훌륭한 Mac Catalyst 앱으로 만들기 위해 할 수 있는 몇 가지 구체적인 것들입니다.

이제 오웬에게 돌아가서 유통에 대해 이야기합시다.

오웬: 고마워, 데이브.

앱을 출시할 때, 기억해야 할 중요한 점은 Mac Catalyst 앱은 Mac 앱이며, 다른 Mac 앱과 동일한 수단을 통해 배포할 수 있다는 것입니다.

기존 iOS 고객이 자동으로 Mac 앱을 받을 수 있도록 유니버설 구매 옵션과 함께 Mac App Store에 앱을 게시할 수 있습니다.

앱의 베타 릴리스를 위해 TestFlight에 액세스하고 새로운 빌드에 대한 초기 피드백을 받을 수 있습니다.

앱 공증을 사용하고 직접 배포할 수도 있습니다.

그리고 프레임워크를 개발하는 경우, XCFrameworks를 사용하여 크로스 플랫폼을 배포하고 모든 플랫폼의 바이너리를 함께 묶으세요.

오늘, 우리는 Mac Catalyst로 Mac용 iOS 앱을 구축하는 과정을 다루었고, 그 과정에서 몇 가지 중요한 결정과 변경 사항을 강조했습니다.

이제 당신 자신의 프로젝트를 고려할 때입니다.

Mac에서 앱을 실행하는 것은 쉽고, 약간의 작업만으로 앱을 집처럼 느끼게 하고 완전히 새로운 흥분된 고객이 사용할 수 있도록 할 수 있습니다.

고마워!

♪