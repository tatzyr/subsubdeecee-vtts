10258

안녕하세요, 제 이름은 아누바브이고, 저는 OS 성능 팀의 엔지니어입니다.

오늘, 저는 당신이 당신의 지원서에서 중단을 이해하고 제거할 수 있는 방법을 공유하게 되어 기쁩니다.

우리는 이 이야기를 "걸림이란 무엇인가?"라는 이해부터 시작하여 이 이야기를 네 부분으로 나눌 것이다.

그런 다음 우리는 교수형의 일반적인 원인과 개발할 때 무엇을 조심해야 하는지에 대해 이야기할 것이다.

그 후, 우리는 당신이 중단을 모니터링하고 진단하는 데 사용할 수 있는 도구에 대해 논의할 것입니다.

마지막으로, 우리는 중단을 없애기 위한 일반적인 전략과 앱에 가장 적합한 것을 선택하는 방법을 배울 것입니다.

바로 뛰어들자.

제가 가장 좋아하는 음료와 디저트를 만드는 방법을 보여주는 앱인 Desserted를 살펴봅시다.

이 망고 탱고 스무디는 멋져 보인다.

내가 그걸 탭해서 어떻게 만들어졌는지 볼게.

흠.

아무 일도 일어나지 않는 것 같아.

와우. 그것은 예상보다 훨씬 오래 걸렸다.

그 앱은 그냥 멈췄고 몇 초 동안 내 손길을 받아들이지 않았다.

이 경험은 "느린", "느린" 또는 "갇힌"으로 묘사될 수 있다.

이것들은 나나 다른 누군가가 그들의 앱을 설명하는 데 사용하고 싶어하는 단어가 아니다.

애플에서, 우리는 이 반응이 없는 시기를 "행"이라고 부른다.

행과 디저트에서 무슨 일이 일어나고 있는지 이해하려면, 우리는 먼저 앱의 주요 런루프가 무엇인지 이해해야 한다.

메인 런루프는 애플리케이션의 메인 스레드가 들어오는 이벤트, 주로 사용자 상호 작용에 응답하여 이벤트 핸들러를 실행하기 위해 입력하는 루프입니다.

사용자가 앱과 상호 작용할 때, 런루프는 이벤트를 수신하고, 처리한 다음, 필요한 경우 UI를 업데이트합니다.

이 모든 것은 런루프의 한 회전과 메인 스레드에서 일어난다.

이 과정은 각 사용자 입력에 대해 반복된다.

이것이 런루프의 한 턴으로 메인 스레드가 어떻게 보일지이다.

이벤트를 처리하는 데 시간이 오래 걸리면, 사용자 입력과 UI 업데이트 사이에 지연이 있을 것이다.

설상가상으로, 이벤트는 버퍼링되며 중단 중에 메인 스레드에 의해 처리될 수 없습니다.

행 중에 앱과 상호 작용하면, 그 이벤트는 현재 행이 먼저 종료될 때까지 처리되지 않습니다... ...복합 행, 하나가 다른 것 위에 있습니다.

일반적으로, 1초 이상의 지연은 항상 중단처럼 보이지만, 더 짧은 지연은 하나로 인식될 수 있다.

예를 들어, 스크롤하는 동안 0.5초 지연은 거슬리지만, 보기에 들어갈 때 같은 지연이 훨씬 덜 눈에 띈다.

중단을 제거함으로써, 당신의 앱은 빠르고, 빠르고, 반응할 것입니다.

이제 우리가 교수형이라는 것을 알았으니, 무엇이 일반적으로 그들을 일으키는지 살펴봅시다.

중단은 메인 스레드에서 너무 많은 작업이 수행될 때 발생한다.

그 작업이 정확히 무엇인지 결정하기 위해, 우리는 이벤트를 처리하는 동안 메인 스레드가 무엇을 하고 있는지 살펴봐야 한다.

이번에는 두 가지 사례로 나눌 수 있다.

메인 스레드 자체는 일을 하느라 바쁘다. 이것은 하나의 긴 작업이나 많은 짧은 작업일 수 있다. 또는 메인 스레드는 다른 스레드나 시스템 리소스에 의해 차단된다.

메인 스레드가 바쁜 일반적인 원인을 살펴보는 것으로 시작합시다.

능동적으로 일을 하는 것은 UI를 업데이트하는 데 필요한 것보다 더 많은 일을 하는 것이며, 메인 스레드를 더 오래 바쁘게 유지한다.

디저트에서, 레시피 보기는 많은 성분 이미지 중 네 개의 이미지 타일만 표시합니다.

메인 스레드가 모든 성분 이미지를 한 번에 로드한다면, 모든 이미지를 읽고, 준비하고, 합성하는 데 시간을 할애할 것이다.

일어나고 있는 대부분의 일은 사용자가 보는 것에도 영향을 미치지 않을 것이다.

보기는 네 개의 이미지만 보여주며, 그 네 개만 즉시 생성해야 합니다.

교수형의 또 다른 원인은 메인 스레드에서 관련 없는 작업을 수행하는 것이다.

메인 스레드 서비스는 메인 디스패치 대기열에서 차단되지만, 디스패치 동기화를 통해 다른 대기열에서 서비스 블록을 제공할 수도 있습니다.

대기열 디스패치가 다른 대기열에 동기화될 때마다, 다른 대기열의 모든 보류 중인 블록은 새로 대기열에 있는 것보다 먼저 실행해야 합니다.

우선 순위가 낮은 직렬 파견 대기열, 아마도 유지 보수 대기열이 있는 앱을 고려해 보세요.

메인 스레드 디스패치가 MaintenanceQueue에 블록을 동기화한 경우, 대기열에 있는 블록이 실행되기 전에 해당 대기열의 모든 보류 중인 블록이 실행될 때까지 기다려야 합니다.

메인 스레드를 위한 일을 하는 데 약간의 시간만 소비되었다.

마찬가지로, 블록이 다른 대기열에서 메인 대기열로 파견되면, 그 블록은 메인 스레드에서 실행해야 한다.

이것은 블록이 디스패치 비동기를 통해 대기열에 있는 경우에도 유지된다.

중단의 또 다른 원인은 최적이 아닌 API를 사용하는 것이다.

임무를 완수하는 방법에는 여러 가지가 있다.

당면한 작업에 가장 적합한 것을 사용할 수 있도록 API 문서를 반드시 읽으십시오.

디저트는 레시피 보기의 모든 이미지에 둥근 모서리를 추가하지만, 이 보기에 들어갈 때 대기 시간도 추가됩니다.

둥근 모서리를 추가하기 위해, Desserted는 비트맵 기반 그래픽 컨텍스트를 사용하여 이미지를 비트맵으로 변환하고, 해당 비트맵에 UIBezier 경로를 적용한 다음, 해당 비트맵을 이미지로 다시 변환합니다.

이 작업 세트는 CPU 집약적이며, 많은 메모리를 사용하며, 시간이 오래 걸릴 수 있습니다.

이것은 잘못된 하드웨어가 작업에 사용되고 있기 때문이다.

CPU를 사용하는 대신, GPU를 활용해야 한다.

레이어에서 CoreAnimation 방법을 사용하면 둥근 모서리를 쉽고 즉각적으로 추가할 수 있습니다.

이것은 당면한 작업에 잘못된 API를 사용하는 한 가지 예일 뿐입니다.

이제 앱의 주요 스레드가 바쁠 수 있는 몇 가지 일반적인 이유를 살펴봤으니, 왜 차단될 수 있는지 조사해 봅시다.

동기 API는 호출된 시간부터 돌아오는 시간까지 실행을 차단합니다.

API가 많은 작업을 하거나 오랜 기간 동안 차단할 가능성이 있는 경우 메인 스레드에서 사용해서는 안 됩니다.

지연 외에도, 이것들은 또한 추가적인 실패 지점을 추가한다.

그러한 경우 중 하나는 앱의 메인 스레드가 네트워크에 동기식 요청을 하는 경우이다.

5G를 사용하는 사람들에게는 지연이 없을 수 있습니다.

네트워크 속도가 느린 사람들에게는 더 오래 걸릴 수 있다.

그리고 신호가 매우 나쁜 사람들을 위해, 이것은 무기한으로 매달릴 수 있다.

이것이 얼마나 오래 걸릴 수 있는지에 대한 보장은 없으며, 이것이 메인 스레드에서 그러한 동기 작업을 피해야 하는 이유입니다.

메인 스레드를 차단하는 또 다른 방법은 종종 제한되기 때문에 시스템 리소스에 있다.

파일 I/O는 가장 일반적으로 사용되고 경쟁적인 시스템 리소스 중 하나이다.

대기 시간은 하드웨어에 의존하며, 다른 읽기와 쓰기는 동시에 발생하며, 이는 앱의 통제를 벗어날 수 없습니다.

그래서, 앱은 메인 스레드에서 I/O를 피함으로써 중단으로부터 방어하기 위해 할 수 있는 일을 해야 한다.

동시성을 지원하지 않는 데이터 저장소는 특히 문제가 있다.

쓰기가 이미 발생하는 동안 메인 스레드가 하나에서 읽으려고 시도한다면, 그 읽기는 모든 작가가 완료될 때까지 밀려날 것이며, 이는 무제한일 수 있다.

중단의 또 다른 원인은 동기화이다.

정의에 따르면, 동기화 프리미티브는 실행을 차단할 수 있으므로, 메인 스레드에서 동기화를 제한하고 주의하는 것이 중요합니다.

동기화하는 스레드는 암시적 또는 명시적 잠금을 해제하는 데 오랜 시간이 걸릴 수 있습니다.

이것들은 @synchronized 지시문, 디스패치 동기화, os 불공정 잠금 및 posix 잠금을 포함하여 조심해야 할 몇 가지 일반적인 기본 사항입니다.

특히, 세마포어 사용은 우선 순위를 전파하지 않고 선점으로 인해 중단을 연장할 수 있기 때문에 주의하십시오.

일반적인 안티패턴은 세마포를 기다리면서 비동기 API를 동기적으로 만들려고 할 때이다.

이것은 항상 메인 스레드에서 피해야 한다.

메인 스레드를 차단하는 또 다른 방법은 작업, IPC 또는 시스템 리소스를 사용하여 자주 변경되지 않는 것의 값을 가져오는 것입니다.

디저트에는 소셜 기능에 대한 아이콘이 있는데, 이는 내가 연락처를 친구로 추가한 경우에만 표시됩니다.

이 보기를 탭할 때마다 모든 연락처를 쿼리하는 것은 확인하는 한 가지 방법이지만, 후드 아래에서 값비싼 작업을 수행하는 프레임워크의 메인 스레드 블록 때문에 불필요한 오버헤드와 지연을 추가합니다.

게다가, 내가 가져오는 가치는 자주 변하지 않기 때문에, 이것을 자주 쿼리하는 것은 불필요하고 시스템 자원에 부담을 더한다.

CPU, 메모리 및 스토리지와 같은 시스템 리소스의 상태는 중단이 발생할 때 큰 역할을 한다.

현장의 다른 하드웨어 및 장치 조건은 실제 시나리오가 책상에서 테스트하는 동안 발생하는 것과 크게 다를 것이라는 것을 의미합니다.

강력한 테스트를 하고 가장 오래된 지원 하드웨어를 벤치마크로 사용하여 이러한 사례를 방어하기 위해 할 수 있는 일을 하는 것이 중요합니다.

교수형에 대한 높은 수준의 원인은 주요 스레드에서 또는 주요 스레드를 대신하여 너무 많은 작업을 수행한다는 것이다.

성능을 보장하기 위해, 애플리케이션의 메인 스레드가 UI를 업데이트하는 데 필요한 것에 초점을 맞추는 것이 중요합니다.

이제 중단의 일반적인 원인을 알았으니, 개발과 생산 중에 앱에서 중단을 모니터링하고 분류하는 데 사용할 수 있는 몇 가지 유용한 도구에 대해 이야기해 봅시다.

중단을 분류하기 위해, 당신은 그 시간 동안 당신의 앱이 무엇을 하고 있는지 알고 싶을 것입니다.

시간 프로파일러 도구를 사용하면 시간이 지남에 따라 애플리케이션의 콜스택을 표시하여 실행 중인 것을 정확히 나타낼 수 있습니다.

시스템 추적 장비는 시스템 호출, VM 오류, I/O, 프로세스 간 및 내부 상호 작용에 대한 데이터와 함께 더 많은 컨텍스트를 추가합니다.

자세한 내용은 2016년의 "System Trace in Depth" 강연을 확인하세요.

이제, 나는 시간 프로파일러와 시스템 추적 도구를 사용하여 디저트가 멈추는 원인을 찾을 것이다.

행의 흔적을 추적한 후, 악기에서 열린 것처럼 보이는 모습은 다음과 같습니다.

시스템 추적 출력에서 빨간색 선은 시스템 호출을 나타내고, 보라색 그래프는 가상 메모리 오류를 나타내며, 수평 파란색 막대는 메인 스레드가 작업 중임을 나타냅니다.

다음 단계는 이 일이 무엇인지 보는 것이다.

타임 프로파일러는 당신이 그것을 할 수 있게 해준다.

4.7초 행 기간 동안 메인 스레드 콜스택을 집계하여 호출 트리를 제공합니다.

트리의 강조된 부분은 이 행의 4.6초가 레시피 보기의 loadAllMessages 메소드 때문이라는 것을 보여준다.

이 패턴은 친숙해 보인다.

디저트는 필요한 것보다 더 많은 이미지를 로드할 수 있다.

애플리케이션이 배송되면, MetricKit을 사용하여 현장에서 중단에 대한 호출 트리를 수집할 수 있습니다.

이를 통해 고객이 가장 일반적으로 제기하는 문제에 따라 수정의 우선 순위를 지정할 수 있습니다.

중단에 MetricKit을 사용하는 방법을 배우려면, 2020년부터 "MetricKit의 새로운 기능" 강연을 확인하세요.

나는 디저트를 배송했고 MetricKit에서 몇 가지 교수형 보고서를 가지고 있다.

우리가 방금 분류한 교수형과 비슷한지 확인하기 위해 그들 중 하나를 살펴봅시다.

MetricKit은 중단 중에 가져온 콜스택을 집계하여 호출 트리를 반환합니다.

이 트리 형식은 시간 프로파일러가 제시하는 것과 비슷하다.

강조 표시된 부분은 이 중단이 우리가 방금 Instruments로 조사한 것과 다르다는 것을 나타냅니다.

이것은 연락처를 쿼리하는 디스패치 대기열을 차단하는 내가 추가한 새로운 소셜 기능 때문입니다.

MetricKit이 없었다면, 나는 이 문제를 발견하지 못했을 수도 있고, 여전히 현장에서 지속될 것이다.

중단을 고칠 때, 앱의 성능을 기준으로 정량화하는 것이 중요합니다.

Xcode 주최자는 앱 버전당 중단률을 표시하는 차트를 포함하여 성능 지표를 표시하여 이를 수행합니다.

이것은 회귀를 분류할 때 특히 유용하다.

Xcode Organizer에 대한 자세한 내용은 이 두 강연을 확인하세요.

이제, 앱에서 중단을 해결하는 데 사용할 수 있는 몇 가지 일반적인 전략을 살펴봅시다.

이러한 각 전략은 중단에 대한 여러 가지 원인을 해결할 수 있다.

어떤 수정이 당신의 앱에 가장 적합한지 알기 위해, 당신은 그들의 측면 영향과 절충을 살펴봐야 할 것입니다.

중단을 제거하고 방어하기 위해, 메인 스레드에서 수행되는 작업의 양을 줄이세요.

이것은 두 가지 방법으로 할 수 있다.

첫 번째는 실행 시간을 줄이기 위해 메인 스레드에서 이미 수행 중인 작업을 최적화하는 것이다.

두 번째는 반응을 유지하기 위해 차단되지 않는 방식으로 메인 스레드에서 작업을 옮기는 것이다.

캐싱부터 시작하여 메인 스레드 실행을 줄이는 방법을 살펴보는 것으로 시작합시다.

캐시는 자주 사용되는 자산이나 이전에 쿼리된 값에 빠르게 접근할 수 있는 좋은 방법입니다.

그것들은 종종 인메모리 저장소이지만, 여러 앱 호출에서 필요한 경우 디스크에 유지될 수 있습니다.

Desserted의 성분 이미지 타일과 같이 나중에 필요할 수 있는 포맷된 자산은 필요할 때마다 이러한 자산을 만드는 데 비용이 많이 들기 때문에 캐싱을 위한 훌륭한 후보입니다.

이것들을 NSCache에 캐싱함으로써, 자산 생성의 오버헤드는 빠른 메모리 읽기로 대체된다.

이것은 우리가 악기에서 보았던 걸림을 없앨 것이다.

오래된 데이터와 지속적으로 캐시를 업데이트하는 것 사이의 균형을 맞추기 위해 정확한 캐시 무효화 메커니즘을 갖는 것이 중요하다.

이 작업은 메인 스레드가 이벤트에 반응하도록 유지하기 위해 2차 디스패치 대기열에서 비동기적으로 이루어져야 한다.

알림 관찰자는 메인 스레드에서 작업을 줄이는 또 다른 방법이다.

그들은 당신의 앱이 값비싼 주문형 계산을 하지 않고도 값이나 상태의 변화에 반응할 수 있게 해준다.

모든 수업은 알림을 게시할 수 있으며, 심지어 당신의 수업도 게시할 수 있습니다.

특정 클래스의 알림을 찾으려면, API 문서를 확인하세요.

관찰 가능한 모든 시스템 알림을 찾으려면, NSNotification.Name의 Apple 개발자 문서 페이지를 확인하세요.

이것에 대한 훌륭한 후보자는 Desserted의 사회적 특징이다.

abDatabaseChangedExternally 알림에 대한 관찰자를 등록함으로써, 메인 스레드는 더 이상 연락처를 쿼리할 때까지 기다릴 필요가 없습니다.

알림이 들어오면, 관찰자가 호출된다.

이 경우, 캐시된 값을 업데이트할 것이다.

메인 스레드를 반응형으로 유지하려면, 이러한 업데이트는 비동기적이어야 하며, 이는 핸들러를 다른 대기열에 dispatch_asyncing하여 달성됩니다.

이제, 나는 이전과 같은 기능을 제공하지만, MetricKit 로그에서 본 중단 없이.

중단을 제거하는 또 다른 방법은 메인 스레드에서 작업을 옮기는 것이다.

먼저, 우리는 이 일이 무엇인지 결정해야 한다.

일반적으로, UI에 중요한 정보를 제공하는 중요한 작업은 메인 스레드에 남아 있어야 한다.

게다가, 모든 뷰와 뷰 컨트롤러는 메인 스레드에서 생성, 수정 및 파괴되어야 합니다.

그러나 UI 요소를 업데이트하는 데 필요한 계산은 메인 스레드에서 실제 업데이트를 수행하기 위한 완료 핸들러와 함께 다른 스레드로 오프로드될 수 있습니다.

이 패턴은 계산이 오랜 시간이 걸리는 것으로 알려져 있을 때 유용하다.

다른 덜 중요한, 유지 보수 또는 시간이 중요하지 않은 작업은 다른 스레드에서 비동기적으로 수행되어야 합니다.

그러면 이것들은 더 낮은 스케줄링 우선 순위로 실행되며 메인 스레드에 있는 작업보다 완료하는 데 더 오래 걸릴 수 있습니다.

이것은 의도적이며 메인 스레드가 중요한 작업만 수행해야 한다는 생각을 반영한다.

메인 스레드에서 비동기 작업을 수행하는 가장 간단한 방법은 동기 API의 비동기 대응을 사용하는 것입니다.

네트워킹을 예로 들어보자.

동기식 네트워킹 API에 비동기 NSURL 대응을 사용함으로써, 앱은 반응할 것이다.

비동기 API는 종종 "비동기"라는 단어 또는 메소드 이름에 완료 핸들러의 존재로 표시됩니다.

그랜드 센트럴 디스패치는 비동기 API 변형이 없거나 메인 스레드에서 이동하려는 코드가 자신의 경우 활용할 수 있는 강력한 멀티 스레딩 메커니즘입니다.

그랜드 센트럴 디스패치는 작업 블록을 동기적으로 또는 비동기적으로 다른 스레드로 이동할 수 있는 간단한 메커니즘을 제공합니다.

이것은 GCD가 교수형에 대한 가장 일반적인 원인을 제거하는 데 믿을 수 없을 정도로 효과적으로 만든다.

다른 스레드에서 비동기적으로 작업 블록을 수행하려면, 그 블록을 다른 디스패치 큐로 디스패치하세요.

완료 핸들러는 기본 대기열로 다시 디스패치하여 비동기 블록 내에 추가할 수 있습니다.

그랜드 센트럴 디스패치(Grand Central Dispatch)를 사용하면 계산을 미리 준비할 수 있습니다.

대기열, 아마도 prefetchQueue에 작업을 비동기화함으로써, 메인 스레드가 다른 작업을 할 수 있는 동안 작업이 실행되기 시작할 것이다.

메인 스레드에서 이러한 결과가 필요할 때, 작업이 완료될 때까지 기다리기 위해 prefetchQueue에 동기화를 파견할 수 있습니다.

우리는 방금 GCD가 할 수 있는 것의 표면을 만졌다.

더 알아보려면, 2017년의 "현대화 그랜드 센트럴 디스패치" 강연을 확인하세요.

우리가 방금 이야기한 해결책에 대한 몇 가지 절충안을 이해합시다.

캐시는 메모리를 사용하므로, 큰 메모리 성장을 피하기 위해 크기를 인식해야 합니다.

값이 오래되지 않도록 정확한 무효화 메커니즘이 있는지 확인하는 것도 중요하다.

알림은 수다스러울 수 있다.

하나를 관찰할 때, 그 알림이 발사되는 빈도를 고려하는 것이 중요하다.

여러 알림을 처리하거나 병합하기 전에 필터를 추가하면 CPU 이탈을 줄일 수 있습니다.

비동기 API를 사용할 때, 운영 체제가 비동기 작업의 우선 순위를 낮추기 때문에, 특히 UI 업데이트에 중요한지 먼저 확인하여 문제의 작업이 비동기화되어야 하는지 여부를 아는 것이 중요합니다.

그랜드 센트럴 디스패치를 사용하여 작업을 비동기적으로 수행할 때, 코드의 작업이 실행되는 순서를 변경합니다.

앱이 고장나지 않도록 다른 사람들에게 어떤 작업을 주문해야 하는지 명심하는 것이 중요합니다.

직렬 대기열과 함께 dispatch_sync를 사용하는 것은 필요할 때 작업을 동기화하는 좋은 방법입니다.

심각한 충격이 사용자 경험에 미치는 것과 비교할 때, 이러한 절충안은 항상 그만한 가치가 있다.

중단을 없애는 동안 명심해야 할 몇 가지 생각은 Apple 프레임워크와 API를 사용하는 것이다.

이것들은 이미 다양한 장치 세트와 호환되며, 성능이 뛰어나며, 더 효율적이고 효과적이도록 지속적으로 업데이트됩니다.

코드에서 개선 사항을 반복하세요.

이렇게 하면, 당신은 목표 수정을 하고, 개별 변화의 영향을 볼 수 있습니다.

시스템 자원을 사용할 때 좋은 이웃이 되세요.

필요한 것보다 더 많은 리소스를 사용하면 앱의 성능이 저하될 뿐만 아니라 시스템에서 다른 속도가 느려질 수도 있습니다.

함께, 우리는 얼마나 거슬리는 행이 될 수 있는지, 그리고 앱에서 행을 방어하는 것이 얼마나 중요한지 경험했습니다.

앞으로, Xcode 주최자를 통해 앱의 성능 기준을 설정하세요.

개발 및 코드 검토 중에, 중단을 일으킬 수 있는 안티패턴을 조심하세요.

우리는 가장 흔한 일곱 가지에 대해 논의했다.

시간 프로파일러와 시스템 추적 기기가 나오는 문제를 진단하고, MetricKit을 사용하여 고객이 가장 자주 제기하는 문제의 우선 순위를 지정하십시오.

캐시를 사용하거나, 알림을 관찰하거나, 비동기 대안을 찾거나, 그랜드 센트럴 디스패치를 활용하여 발견한 중단을 제거하십시오.

이 단계를 따르면, 당신의 앱은 최상의 사용자 경험을 제공하기 위해 훨씬 더 나은 성능을 가질 것입니다.

놀아줘서 고마워.

[음악].