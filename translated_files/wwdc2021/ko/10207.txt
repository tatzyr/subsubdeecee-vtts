10207

♪ 베이스 음악 연주 ♪

♪

윌 아다리오-터너: 안녕하세요, "XCTest에서 예상되는 실패를 받아들이세요"에 오신 것을 환영합니다.

제 이름은 윌이고, 이 세션에서는 프로젝트의 테스트를 실행할 때 얻는 데이터를 개선하는 방법에 대해 논의할 것입니다.

우선, 애초에 코드를 테스트하는 이유를 생각해 봅시다.

물론, 높은 수준에서, 그것은 우리가 제품의 품질을 보장하는 방법이다.

하지만 좀 더 구체적으로 말하자면, 나는 우리가 배송하기 전에 버그를 발견하는 것이지 나중에 발견하는 것이라고 말하고 싶다.

이제, 테스트는 투자이다.

테스트를 만들고, 실행하고, 유지하려면 자원이 필요하다.

모든 투자와 마찬가지로, 우리는 비용을 최소화하면서 수익을 극대화하고 싶습니다.

이 세션은 유지 보수 비용을 줄이기 위한 도구에 초점을 맞추고 있다.

유지 보수를 통해, 저는 주로 테스트 스위트에서 오류가 발생할 때 실패를 처리하는 방법을 언급하고 있습니다.

통과한 시험이 실패하기 시작하면, 그것은 귀중한 새로운 정보이다.

이것은 제품의 결함, 테스트 자체의 문제 또는 종속성 중 하나의 문제, 즉 제품이 있는 모든 프레임워크와 하위 시스템을 나타냅니다.

문제의 유형에 관계없이, 일단 그 실패가 등록되면, 동일한 실패에 대한 후속 보고서는 당신이 이미 가지고 있는 정보를 나타내기 때문에 훨씬 덜 가치가 있습니다.

이상적으로, 새로운 실패는 선별되고 빠르게 수정된다.

그러나, 당신의 팀은 문제를 즉시 해결하지 못할 수 있으며, 이는 실패가 귀중한 새로운 정보에서 시끄러운 산만함으로 빠르게 간다는 것을 의미합니다.

즉시 해결할 수 없는 테스트에서 알려진 실패를 감안할 때, 소음을 관리하는 데 사용할 수 있는 도구는 무엇입니까?

마음에 떠오를 수 있는 두 가지 접근 방식은 비활성화와 건너뛰기이다.

이것들에 대한 절충안을 고려한 다음 최고의 도구와 이 세션의 주제인 XCTest의 ExpectedFailures API에 대해 이야기해 봅시다.

Xcode를 사용하면 테스트 계획이나 계획에서 테스트를 비활성화할 수 있습니다.

알려진 테스트 실패에 이것을 사용할 수 있으며, 한 가지 장점은 테스트 코드가 계속 컴파일된다는 것입니다.

그러나, 코드가 실행되지 않기 때문에, 테스트 보고서에서 볼 수 없습니다.

이러한 가시성 감소는 해결해야 할 문제로 추적하기 어렵게 만든다.

이 기능 - 활성화 또는 비활성화된 테스트를 선택할 수 있는 기능 -은 특정 목적을 위한 테스트 컬렉션을 큐레이팅하기 위한 것입니다.

하지만 그것은 알려진 실패를 다루는 가장 좋은 방법은 거의 없다.

XCTSkip은 실패한 시험을 관리할 수 있는 또 다른 방법입니다.

이 접근 방식을 통해, 코드는 테스트로 계속 구축될 뿐만 아니라, XCTSkip이 호출될 때까지 실행됩니다.

이것은 그것이 시험 보고서에 포함되어 있다는 것을 의미하며, 문제에 대한 훨씬 더 나은 가시성을 제공합니다.

그러나, 그것은 모든 테스트를 실행하지 않으며, 이는 새로운 문제와 기존 문제에 대한 변경의 형태로 잠재적으로 유용한 정보를 잃는다는 것을 의미합니다.

XCTSkip은 특정 OS 버전이나 장치 유형을 요구하는 것과 같은 테스트에 대한 구성 기반 제한을 관리하기 위한 훌륭한 도구입니다.

여기 예시에서, iPad에서 실행되지 않으면 테스트를 건너뛸 것입니다.

이것은 알려진 오류를 관리하기 위해 특별히 설계된 XCTest의 기능 세트인 XCTExpectFailure로 우리를 데려온다.

스위프트에서는 다양한 사용 사례에 대한 많은 과부하가 있으며, Objective-C는 몇 가지 뚜렷한 기능으로 동일한 기능을 제공합니다.

이 API를 사용하면 테스트가 정상적으로 실행되지만 결과는 다음과 같이 변경됩니다. 테스트 실패는 예상 실패로 보고됩니다.

그 테스트가 포함된 테스트 스위트의 실패는 물론 다른 테스트가 실패하지 않는 한 통과로 보고될 것이다.

이것은 실패로 인한 소음을 제거하여 테스트에 다른 문제가 있는지 더 쉽게 확인할 수 있습니다.

물론, 소음을 억제하는 것은 근본적인 문제를 해결하지 못한다.

그래서 당신이 그것을 추적할 수 있도록, API는 실패 이유를 취합니다.

이 문자열은 코드의 문제를 문서화하고 문제 추적 시스템의 URL을 포함할 수도 있습니다.

Xcode의 테스트 보고서 UI는 정상적인 실패나 건너뛰는 테스트와 마찬가지로 예상되는 실패를 보여줍니다.

호버할 때, 실패 이유에 URL이 포함된 경우, 링크로 건너뛸 수 있는 문제 추적 버튼이 나타납니다.

그래서 이게 어떻게 작동하는지 보자!

여기 제 VendorAccount 수업을 위한 몇 가지 단위 테스트가 있는 간단한 프로젝트가 있습니다.

나는 테스트를 실행할 것이고, 그들이 끝나면, 우리는 하나는 실패하고 다른 하나는 통과하는 것을 보게 될 것이다.

각 테스트마다 하나씩 세 개의 테스트 결과 아이콘을 볼 수 있습니다.

실패한 테스트에 대한 빨간색 X와 통과 테스트에 대한 녹색 체크, 그리고 테스트 스위트에 대한 빨간색 X; 스위트의 테스트 중 하나가 실패했기 때문에 우리는 스위트 자체가 실패했다고 생각합니다.

이제 나는 실패한 테스트를 시작할 때 XCTExpectFailure에 전화를 추가할 것이다.

실패 이유가 이 실패를 추적하기 위해 제출한 버그를 참조하는 URL로 시작하는 것을 볼 수 있습니다.

이제 나는 테스트를 다시 실행할 것이고 우리는 이것이 결과에 어떤 영향을 미치는지 볼 것이다.

좋아요, 그래서 실패한 테스트의 빨간색 X 아이콘이 회색 X로 바뀌었고, 이는 예상 실패의 지표입니다.

더 흥미로운 것은 테스트 스위트 아이콘이 빨간색 X에서 녹색 대시로 바뀌었다는 것이다.

이 아이콘은 테스트 스위트가 혼합 상태로 통과했음을 나타내며, 이는 하나 이상의 테스트가 통과하지 못했지만 건너뛰거나 예상되는 실패였다는 것을 의미합니다.

그래서 실패한 테스트를 처리하기 위해 XCTExpectFailure를 사용하는 것이 얼마나 쉬운지.

이제 API를 자세히 살펴봅시다.

XCTExpectFailure를 사용할 때 첫 번째 고려 사항은 호출할 API 변형입니다.

두 가지 접근 방식이 있습니다: XCTExpectFailure를 호출하고 테스트의 후속 실패가 예상대로 처리되는 상태 저장 접근 방식; 대안으로, XCTExpectFailure에 전달된 클로저에서 실패한 코드를 래핑하는 범위 접근 방식을 사용할 수 있습니다.

몇 가지 예를 살펴봅시다.

여기 제 프로젝트에서 몇 가지 기능을 호출하는 매우 간단한 테스트가 있습니다.

함수가 더 이상 true를 반환하지 않기 때문에 테스트가 실패하기 시작합니다.

우리가 데모에서 했던 것처럼, 상태 저장 가능한 예상 실패 접근 방식을 사용하는 것은 다음과 같습니다.

또는, 우리는 XCTExpectFailure에 대한 호출 후 폐쇄에서 실패한 코드를 래핑하여 범위가 지정된 접근 방식을 사용할 수 있습니다.

이것은 폐쇄 외부의 코드의 실패가 정상적으로 보고될 것이라는 것을 의미합니다.

API는 또한 중첩을 지원합니다.

즉, 다른 호출의 폐쇄 내부를 포함하여 테스트에서 API를 두 번 이상 호출할 수 있습니다.

이것은 테스트 라이브러리 코드에서 API를 사용할 때 중요한 고려 사항이다.

예를 들어, 일반적인 유틸리티 기능이 실패하기 시작하면 많은 테스트가 영향을 받을 수 있으며, 그 중 일부는 이미 다른 문제에 대해 XCTExpectFailure를 사용하고 있을 수 있습니다.

XCTExpectFailure에 대한 중첩된 호출의 맥락에서 실패가 발생하면, 문제는 가장 가까운 호출 사이트와 먼저 일치하며, 매처에 의해 거부되면 XCTExpectFailure에 대한 호출에 대한 스택 의미와 함께 다음 호출로 전달됩니다.

이러한 이유로, 공유 코드로, 테스트 상태에 대한 영향을 제한하기 위해 폐쇄 기반 API를 사용하는 것이 가장 좋습니다.

다음으로 고려해야 할 것은 그 문제를 얼마나 정확하게 일치시키는가이다.

기본적으로, 영향을 받는 범위의 모든 실패는 잡히지만, 문제 매칭 필터를 지정하여 더 선택적일 수 있습니다.

이 예에서, 우리는 XCTExpectedFailure.Options 유형의 객체를 구성하고 issueMatcher를 정의합니다.

매처는 실패 세부 사항과 함께 XCTIssue 객체에 전달되므로, 일치 여부를 결정할 때 해당 정보에 완전히 액세스할 수 있습니다.

매처가 실패를 거부하면, 예상되는 실패로 처리되지 않을 것이다.

이것은 테스트 중인 코드에 새로운 문제가 나타날 때 감지하는 데 유용할 수 있다.

옵션 객체에는 또한 특정 구성에서 예상되는 실패를 비활성화하는 데 사용할 수 있는 속성이 있습니다.

예를 들어, 내 테스트는 macOS에서 통과할 수 있지만 iOS에서는 실패할 수 있으므로, iOS에서만 실패를 예상하고 싶습니다.

그것을 달성하기 위해, 나는 옵션을 통해 예상되는 실패를 비활성화하지만, 필요하지 않은 플랫폼에서만 비활성화한다.

그래서 당신의 예상 실패가 실패를 멈추면 어떻게 되나요?

보통 이것은 근본적인 문제가 해결되었다는 것을 의미하며, 이는 훌륭하다.

하지만 XCTExpectFailure는 어떻게 행동하나요?

여전히 API를 호출하고 실패가 발생하지 않는다면, 새롭고 뚜렷한 실패를 생성할 것입니다.

우리는 이것을 "비할 수 없는 예상 실패"라고 부르며 XCTExpectFailure의 기본값인 엄격한 행동의 일부입니다.

이 동작은 API에 대한 불필요한 호출을 제거하라는 메시지를 표시하여 코드를 유지하는 데 도움이 됩니다.

하지만 가끔만 실패하는 시험은 어떤가요?

시험이 가끔 실패할 수 있지만 다른 때는 실패하지 않는 경우가 있다.

이것들은 두 가지 범주로 분류되며, 첫 번째는 결정론적이며 특정 플랫폼에서만 실패하는 테스트의 이전 예와 같은 환경 또는 기타 알 수 있는 조건을 포함한다.

반면에, 몇몇 실패는 본질적으로 비결정적이다.

이것들은 타이밍 문제, 신뢰할 수 없는 주문 종속성 또는 동시성 버그로 인해 발생할 수 있습니다.

비결정적 실패의 경우, 엄격한 행동은 도움이 되지 않는다; 그것은 단지 소음을 발생시킨다.

다시 한번, 옵션 객체는 이것을 제어할 수 있는 방법을 제공한다.

기본값이 true인 isStrict 플래그는 끌 수 있습니다.

그런 다음, XCTExpectFailure가 실패를 포착하지 못하면, 여전히 테스트를 통과할 수 있습니다.

스위프트에서는 엄격한 동작을 XCTExpectFailure의 직접 매개 변수로 지정할 수도 있습니다.

엄격한 행동을 비활성화하는 것은 프로젝트에서 벗겨지거나 비결정적인 테스트를 처리하는 좋은 방법입니다.

제쳐두고, 비결정적 실패를 조사해야 할 때, Xcode는 테스트를 여러 번 쉽게 실행할 수 있게 해주며, 실패하거나 다른 조건이 충족되면 중지합니다.

이것은 벗겨진 테스트에서 실패를 추적하는 데 정말 도움이 될 수 있다.

이에 대한 자세한 내용은 "테스트 반복으로 신뢰할 수 없는 코드 진단" 세션을 시청하세요.

그래서 그것은 XCTExpectFailure입니다 -- 테스트 스위트 결과에서 신호 대 잡스를 개선하기 위한 XCTest의 API입니다.

이것은 새로운 문제를 더 효율적으로 식별하여 더 높은 품질의 코드로 이어지는 데 도움이 됩니다.

봐줘서 고마워!

♪