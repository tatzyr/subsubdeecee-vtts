10086

Nihar: 안녕하세요, "CloudKit의 새로운 기능"에 오신 것을 환영합니다.

제 이름은 Nihar Sharma이고 CloudKit 팀의 엔지니어이며, 제 동료 Qian과 합류할 것입니다.

우리는 Swift 동시성을 활용하는 CloudKit API의 몇 가지 변경 사항을 강조하는 것으로 시작할 것입니다.

그런 다음, Qian은 기록에서 암호화된 필드의 사용을 안내할 것이다.

마지막으로, 우리는 당신이 기록 영역을 쉽게 공유할 수 있는 새로운 기능을 더 깊이 파고들 것입니다.

먼저, 우리는 CloudKit과 Swift 동시성이 있습니다.

약간의 배경으로, CloudKit은 애플리케이션이 iCloud의 데이터베이스에 액세스할 수 있는 프레임워크입니다.

이것은 여러 CKDatabase에 액세스할 수 있는 CKContainer로 API에 노출됩니다.

각 컨테이너에는 모든 사용자가 잠재적으로 레코드를 읽고 쓸 수 있는 하나의 공용 데이터베이스가 있습니다.

장치에 로그인한 iCloud 계정이 있는 경우, 앱은 해당 사용자의 데이터가 포함된 개인 데이터베이스에도 액세스할 수 있습니다.

그리고 앱이 공유를 지원하는 경우, 현재 iCloud 사용자에게 공유된 데이터는 공유 CKDatabase의 앱에서 사용할 수 있습니다.

CloudKit에 대한 코드를 작성할 때, API에는 두 가지 일반적인 영역이 있습니다.

먼저, CKContainer와 CKDatabase에서 사용할 수 있는 기능.

이 API는 CloudKit의 새로운 채택자들에게 유용하며, 낮은 진입 장벽을 제공하기 위한 것이다.

사용 가능한 모든 구성을 제공하는 대신, 프레임워크는 사용자가 상호 작용하는 UI 애플리케이션에 가장 적합한 기본 동작을 선택합니다.

다음은 NSOperation 서브클래스 세트로 노출되는 Operation API입니다.

이 API는 CKContainer 또는 CKDatabase 기능으로 사용할 수 없는 여러 기능을 제공합니다.

여기에는 서버로의 단일 왕복으로 항목의 배치를 보내고 받고, 서버에서 점진적으로 가져와서 큰 결과 세트를 통해 페이징하고, 과거의 어느 시점부터 서버에서 데이터베이스 및 기록 영역 변경을 요청하고, 마지막으로 다른 작업을 함께 그룹화하는 것이 포함됩니다.

이를 통해 그것들을 단위로 기록할 수 있으며 운영에 걸친 작업량의 크기에 대해 시스템에 알릴 수 있습니다.

많은 개발자들은 결국 생산 품질 코드를 작성할 때 이 API를 사용한다.

새로운 Swift 동시성 기능을 활용하여, CloudKit은 몇 가지 개선을 이루었다.

먼저, CloudKit API와 함께 새로운 Swift async/await 기능을 사용하는 방법을 다루겠습니다.

그런 다음, 항목별과 작업별 콜백의 차이점을 명확히 하는 데 도움이 되는 새로운 API와 CloudKit이 Swift.Result 유형을 활용하여 이러한 콜백에 대한 매개 변수의 역할을 명확히 하는 방법에 대해 이야기하겠습니다.

그리고 마지막으로, 이전에 운영 API를 통해서만 사용할 수 있었던 일부 기능과 구성 가능성을 가져오는 데 도움이 되는 컨테이너 및 데이터베이스 기능에 대한 개선 사항을 검토하겠습니다.

CloudKit API는 컨테이너와 데이터베이스의 기능을 위한 비동기 변형을 도입하고 있다.

비동기 함수를 사용하여 동시성을 다루는 코드를 개선할 수 있습니다.

그것은 오류 처리를 더 자연스럽게 만드는 데 도움이 되며, 코드의 시각적 제어 흐름을 단순화합니다.

비동기 기능에 대한 자세한 내용은 "Swift에서 비동기/대기 충족" 세션을 참조하십시오.

예시를 확인해 봅시다.

이 스니펫은 PrivateDatabase 코드 샘플에서 가져온 것입니다.

이것은 Apple이 최근에 GitHub에 게시한 여러 CloudKit 관련 코드 샘플 중 하나이며, 사용할 수 있습니다.

이 특정 기능은 서버에서 기록을 삭제하고 완료되면 발신자에게 알리고자 합니다.

많은 선택 사항과 조건부 포장 해제가 주변에 뿌려져 있다는 점에 유의하십시오.

그리고 이 기능을 처음 이해하려고 할 때, 제어 흐름은 즉시 명확하지 않습니다.

이제, 이것을 CloudKit의 비동기 기능을 사용하기 위해 업데이트된 코드와 비교해 봅시다.

여기서, 옵션과 포장 풀기가 제거되었고, 제어 흐름은 선형적이고 따르기 쉽다.

GitHub 저장소의 각 코드 샘플에는 Swift 동시성을 사용하기 위해 코드를 유사하게 리팩토링할 수 있는 방법을 보여주는 업데이트가 있다고 말하게 되어 기쁩니다.

항목별 콜백에 대해 이야기해 봅시다.

예를 들어, 이상적으로 네 개의 CKRecord 페이로드를 되찾기 위해 네 개의 CKRecord.ID를 서버로 보내는 CKFetchRecordsOperation이 있습니다.

이 수술은 세 가지 다른 방법 중 하나로 갈 수 있다.

첫 번째 경우, 수술은 성공한다.

오류가 없으며, 당신의 기록은 서버에서 성공적으로 가져옵니다.

두 번째 가능성은 당신이 작업 전체 오류를 쳤다는 것입니다.

이것은 전체 작업이 실패하게 만드는 오류이다.

예를 들어, 장치에 네트워크 연결이 부족할 수도 있다.

이 경우, 전체 작업은 networkUnavailable 오류 코드로 실패할 것이다.

여기 세 번째 옵션이 있습니다.

이 시나리오에서, 당신의 작업은 성공적으로 서버로 반올림했습니다.

서버는 네 번째 요청된 레코드가 존재하지 않는다는 오류와 함께 요청된 CKRecords 중 세 개를 성공적으로 반환했습니다.

이 예에서, 항목별 오류는 unknownItem이며, partialFailure라는 작업별 오류로 번들로 제공됩니다.

그래서, 이것은 코드에서 어떻게 처리되나요?

상단에서, CKFetchRecordsOperation은 하단에 이들 각각의 샘플 구현과 함께 perRecordCompletionBlock 및 작업당 완료 블록을 선언합니다.

이 두 콜백 사이의 중복에 주목하세요.

이전의 누락된 레코드 예제에서, 코드는 항목별 오류를 두 번 예상합니다. 한 번은 항목별 콜백에서 최상위 미지 항목 오류로, 다시 작업별 콜백에서 부분 실패 오류 안에 번들로 제공됩니다.

마찬가지로, 그것은 또한 성공적으로 가져온 레코드에 대해 두 곳에서 항목별 성공을 기대합니다. 첫째, 항목별 콜백에 대한 최상위 매개 변수로, 그리고 다시 한 번, 작업별 콜백에서 성공적인 결과의 recordsByRecordID 사전에 래핑됩니다.

Swift.Result 유형을 활용함으로써, CloudKit은 API를 더 명확하게 만들기 위해 이 두 콜백을 모두 대체했습니다.

새로운 결과 기반 콜백에서 블록 매개 변수의 최고 수준의 분리에 주목하세요.

perRecordResultBlock에는 CloudKit이 다시 호출하는 항목을 식별하는 ID가 있습니다.

그리고 그것은 항목당 결과를 가지고 있다.

결과는 이제 강력하게 입력되었으므로, 성공적으로 가져온 CKRecord 페이로드 또는 항목별 오류를 받고 있다는 것을 알고 있습니다.

마찬가지로, 작업 범위 완료 블록은 항목별 결과 블록에 의해 이미 보고된 성공 또는 실패를 더 이상 복제하지 않는 작업 범위 결과 블록으로 업데이트되었습니다.

그래서, CloudKit은 이제 공식적으로 그들의 우려를 분리했다.

한 블록은 항목별 보고에만 사용되며, 다른 블록은 작업별 보고에만 사용됩니다.

누락된 기록 예로 돌아가서, 예상은 CKRecord 페이로드를 성공적으로 가져온 항목별 결과 블록의 세 가지 호출, 알 수 없는 항목 오류가 있는 항목별 결과 블록의 한 가지 호출, 그리고 작업이 전반적으로 성공함에 따라 오류 없이 작업별 결과 블록의 한 가지 호출입니다.

CloudKit의 새로운 개선 사항 중 하나는 모든 곳에서 항목별 및 작업별 콜백을 표시하는 것입니다.

이전에는 강조 표시된 작업만 항목별 오류를 나타내는 항목별 콜백이 있었다.

모든 CKOperations가 이제 적절한 경우 항목별 오류를 되돌리는 항목별 콜백을 노출한다는 것을 발표하게 되어 기쁩니다.

이제, 컨테이너와 데이터베이스 API에 대한 몇 가지 개선 사항과 확장을 살펴봅시다.

개선 사항은 CKContainer와 CKDatabase의 새로운 기능의 형태를 취한다.

이러한 새로운 기능들은 함께 CKContainer와 CKDatabase의 함수로 사용할 수 있는 CKOperation API의 큰 덩어리를 만든다.

중요한 것은, 이것은 운영 API의 일대일 매핑이 아니다.

대신, 우리는 기본 매개 변수와 Swift.Result 유형을 활용하여 접근 가능하고 강력하며 async/await와 함께 작동하는 API를 만들었습니다.

즉, 각각의 새로운 기능은 두 번 노출됩니다. 한 번은 completionHandler를 취하고, 다시 비동기 함수로 노출됩니다.

이 향상된 API를 통해 컨테이너와 데이터베이스의 기능은 이제 여러 항목 일괄 처리, 대용량 데이터 세트를 통한 페이징 및 변경 사항 가져오기와 같은 Operation API의 일부 기능을 지원합니다.

또한 로깅을 위해 기능 호출을 함께 그룹화하고, 결합된 작업량 크기에 대해 시스템에 알릴 수 있습니다.

이제 시간 초과를 설정하여 기능 호출을 구성할 수도 있습니다.

그래서, 이건 어떻게 작동해?

여기, 다시 한 번, 이전에 본 GitHub PrivateDatabase 코드 샘플이 있습니다. 비동기 함수를 사용하여 레코드를 삭제합니다.

아이템 배치를 활용하기 위해 이 코드를 어떻게 업데이트할 수 있는지 봅시다.

데이터베이스의 향상된 기능 API를 활용하여 두 개의 레코드를 원자적으로 삭제하기 위해 이 함수의 동작을 변경할 것입니다.

우려의 분리에 주목하세요.

강조된 영역은 기능 범위에서 작동한다.

그들은 기능을 시작하고 던져진 기능 범위 오류를 포착한다.

그리고 기능이 성공적으로 완료되면, 이 강조 표시된 영역은 항목별 성공 또는 실패를 검사할 것이다.

GitHub의 코드 샘플 저장소에서 이러한 각 기능을 다루는 유사한 예가 있으며, 이 세션의 메모에는 해당 저장소에 대한 링크가 포함됩니다.

우리는 당신이 그것들이 유용하다는 것을 알기를 바랍니다.

그리고 그것으로, 나는 그것을 Qian에게 넘겨서 암호화된 필드를 통해 우리를 안내하고 싶다.

고마워, 니하르.

저는 Qian이고, 사용자의 데이터 개인 정보를 매우 쉽게 보호할 수 있는 CloudKit의 새로운 기능에 대해 이야기할 것입니다.

이를 위해, 먼저 CloudKit이 사용자의 데이터를 보호하는 방법에 대한 개요를 제공한 다음, 새로운 데이터 암호화 기능을 소개하고, 마지막으로 암호화를 위한 사용자 계정의 몇 가지 전제 조건을 소개할 것입니다.

애플에서 개인 정보 보호는 우리가 모든 제품에 구축하는 핵심 가치 중 하나입니다.

많은 Apple 앱과 서비스를 지원하는 프레임워크로서, CloudKit은 CloudKit과 저장되고 동기화된 모든 데이터를 보호하기 위해 개인 정보 보호 기술을 지속적으로 혁신해 왔습니다.

먼저, CloudKit이 사용자의 데이터를 어떻게 보호하는지 살펴보겠습니다.

CloudKit의 접근 방식에는 두 가지 기본 데이터 보호 방법, 계정 기반 보호 및 암호화 보호가 포함됩니다.

CloudKit에 저장된 모든 데이터는 기본적으로 계정 기반 인증으로 보호됩니다.

여기에는 CloudKit 지원 앱과 모든 Apple CloudKit 지원 앱이 포함됩니다.

저장 및 검색 시, CloudKit은 보안 토큰을 사용하여 Apple이나 제3자가 아닌 승인된 사용자만 데이터에 액세스할 수 있도록 합니다.

이미 잘 알고 계시겠지만, 개인 및 공유 데이터베이스의 데이터만 계정 기반 보호가 적용됩니다.

이러한 데이터베이스에서 데이터는 특정 iCloud 계정에 속하거나 공유되며, 공유 데이터에 대한 액세스는 인증이 필요합니다.

그러나 공용 데이터베이스에서는 모든 사용자가 데이터에 액세스할 수 있으므로 계정 기반 데이터 보호는 기본적으로 적용되지 않습니다.

이제, 다른 데이터 보호 기술인 암호화 보호로 넘어가세요.

CloudKit은 Apple 소유의 앱과 서비스에 저장된 민감한 데이터와 CKAsset의 형태로 저장된 모든 사용자 데이터에 대한 암호화 보호를 제공합니다.

이 데이터는 저장을 위해 CloudKit 서버로 전송되기 전에 로컬로 사전 처리되고 암호화되며, 검색 시 로컬로 해독됩니다.

이 암호화 기능은 장치에 로그인한 iCloud 계정에 속한 iCloud 키체인에 저장된 키 자료를 사용합니다.

또한 CloudKit의 공유 기능과 호환되므로 CKShare의 사용자만 관련 암호화된 필드를 해독할 수 있습니다.

암호화 보호는 계정 기반 보호 위에 또 다른 계층을 추가합니다.

허가받지 않은 당사자가 어떻게든 권한을 우회하더라도, 그들은 검색된 데이터를 해독할 수 없기 때문이다.

암호화 보호는 사용자에게 민감하거나 비공개인 데이터에 사용되어야 합니다.

Apple 내의 많은 CloudKit 지원 앱은 두 가지 예로 사진과 메모로 이 기능을 활용합니다.

지금까지 사용자의 비자산 데이터에 대한 CloudKit의 보호는 기본적으로 계정 기반 보호를 제공합니다.

CloudKit은 이제 모든 키 파생, 관리 및 암호화/복호화 프로세스로부터 당신을 보호하는 것 외에도 암호화 보호를 제공하고 있으며, 이는 그 어느 때보다 강력한 개인 정보 보호 약속으로 CloudKit 지원 앱을 구축하는 데 도움이 될 것입니다.

당신이 그것을 하는 데 도움이 되는 새로운 API를 확인해 봅시다.

암호화를 위해 CKRecords의 새 속성 encryptedValues에 키 값 쌍을 추가할 수 있으며, 동일한 속성을 추가하여 해독된 원래 값을 되돌릴 수 있습니다.

encryptedValues API를 통해 CloudKit 서버를 통해 암호화된 데이터를 동기화할 수 있는 방법을 살펴볼 것입니다.

여기에는 두 개의 장치와 하나의 CloudKit 서버가 있습니다.

encryptedValues 키 값 쌍을 설정하면, CloudKit은 CKModifyRecordsOperation의 레코드 값을 로컬로 서버에 자동으로 암호화합니다.

다른 장치에서 서버에서 레코드를 검색한 후 동일한 API를 호출할 수 있으며 CloudKit은 키 값 쌍을 자동으로 해제합니다.

이 과정을 달성하려면 최소 코드만 변경하면 됩니다.

첫 번째 장치에서 encryptedValues API를 사용하여 레코드의 키 값 쌍을 설정할 수 있습니다.

이 경우, 키는 "encryptedStringField"이고 값은 문자열 객체입니다.

그 후, CKModifyRecordsOperation을 호출하여 새 레코드를 서버에 저장할 수 있습니다.

두 번째 장치에서 CKFetchRecordsOperation을 호출하여 암호화된 레코드를 검색할 수 있으며, 동일한 encryptedValues 속성을 사용하여 문자열을 다시 얻을 수 있습니다.

그게 다야.

하나의 간단한 속성은 당신을 위해 모든 암호화 및 암호 해독 프로세스를 처리할 것입니다.

그리고 서버에 표시되어야 하기 때문에 CKReference를 제외한 거의 모든 CKRecord 값 유형을 암호화할 수 있습니다.

앞서 언급했듯이 CKAsset 필드는 이미 기본적으로 암호화를 사용하기 때문에 encryptedValue로 설정할 수 없습니다.

일반 필드와 마찬가지로 CloudKit 데이터베이스 스키마로 이동하여 암호화된 필드를 시각화할 수 있습니다.

콘솔에 대한 다른 변경 사항을 보여주는 CloudKit 콘솔 세션인 "Meet CloudKit Console"이 있으며, 언제든지 확인해 보세요.

콘솔에서 모든 암호화된 필드는 레코드 값 데이터 유형의 드롭다운에 표시됩니다.

그들은 "암호화된 이중", "암호화된 타임스탬프"와 같은 접두사 "암호화"를 가지고 있어 암호화되지 않은 것과 구별할 수 있습니다.

코드 변경 없이 CloudKit 콘솔을 통해 암호화된 필드를 직접 관리할 수도 있습니다.

예를 들어, 개발 데이터베이스 스키마의 새 레코드 유형에 새로운 암호화된 필드를 추가할 수 있습니다.

암호화와 관련된 작업을 위한 계정의 전제 조건으로 넘어가세요.

개인 및 공유 데이터베이스의 다른 작업과 마찬가지로, 유효한 로그인 계정이 필요합니다.

CKContainer accountStatus(completionHandler:)를 호출하여 초기화 로직에서 현재 계정의 상태를 확인해야 합니다.

상기시켜 드리자면, 그 상태는 개인 및 공유 데이터베이스의 운영을 위해 "사용 가능"해야 합니다.

다른 상태는 오류가 발생합니다: 새로운 상태를 포함하여 "CKErrorNotAuthenticated", 일시적으로 사용할 수 없으며, 계정이 로그인되었지만 준비가 되지 않았음을 나타내기 위해 올해 도입되었으며, 사용자에게 설정 앱에서 자격 증명을 확인하도록 지시할 수 있습니다.

사용자의 계정이 "사용 가능한" 상태가 아닌 경우, 계정이 변경될 때마다 게시되는 CKAccountChanged 알림을 듣고 상태가 준비될 때 알림을 받아야 합니다.

그것이 당신이 CloudKit으로 데이터를 암호화하는 것에 대해 알아야 할 전부입니다.

그것은 사용자의 데이터를 보호하고 사용자 지정 솔루션을 구현하는 데 모든 시간과 에너지를 절약할 수 있습니다.

이제, 내 놀라운 동료 니하르에게 돌아가서 구역 공유에 대해 이야기해.

고마워, Qian! CloudKit 공유에 대해 이야기해 봅시다.

CloudKit은 모든 사용자의 장치에서 사용자 데이터를 저장하고 동기화하는 데 도움이 되는 안전하고 개인 정보 보호에 민감한 iCloud 데이터베이스입니다.

iOS 10과 macOS Sierra는 다른 iCloud 사용자와 데이터를 안전하게 공유하는 방법인 CloudKit 공유를 도입했습니다.

공유의 새로운 기능에 뛰어들기 전에, 오늘날 CloudKit 공유가 어떻게 작동하는지 자세히 살펴봅시다.

이미 잘 알고 있듯이, CloudKit 공유는 공유되는 데이터를 공유 관련 세부 사항과 분리하는 CKShare 객체의 생성을 통해 시작됩니다.

무대 뒤에서, CloudKit은 모든 요청에 대해 계정 기반 인증을 요구하는 것 외에도 참가자의 공유 데이터에 대한 암호화 액세스를 설정합니다.

이제, 앱에 공유 지원을 추가할 수 있는 두 가지 주요 방법이 있습니다.

iOS의 UICloudSharingController와 macOS의 NSSharingService를 통해 공유 관리를 위해 시스템 제공 UI를 사용하여 빠르게 시작할 수 있습니다.

또는, 이러한 프레임워크 작업을 사용하여 사용자가 공유 설정과 상호 작용할 수 있도록 자신만의 사용자 지정 UI를 구축할 수도 있습니다.

앞서 언급했듯이, CKShares는 공유되는 것과 공유되는 사람을 분리한다.

오늘, 우리는 그 방정식의 전반부에 초점을 맞출 것이며, 더 구체적으로, 데이터를 모델링할 수 있는 몇 가지 다른 방법과 그것이 CloudKit 공유 API를 활용하는 방식에 어떤 영향을 미치는지 살펴볼 것입니다.

기존 CloudKit 공유 기능을 활용하는 예시부터 시작합시다.

iCloud Drive 폴더 공유는 CloudKit 위에 구축됩니다.

자신의 앱에서 비슷한 것을 어떻게 만들 수 있는지 봅시다.

따라서, 여기에 있는 데이터 모델은 파일 시스템 계층 구조를 나타내므로, "파일" 및 "폴더" 유형의 레코드로 시작하며, 사용자에게 그 안에 포함된 모든 레코드, 파일 또는 폴더와 함께 모든 폴더 레코드를 쉽게 공유할 수 있는 기능을 제공하고자 합니다.

CloudKit에서 이 계층적 관계를 표현하고 공유를 위해 활용하는 방법은 자식에서 부모 레코드로 CKRecord.parent 참조를 사용하는 것입니다.

이를 통해 CloudKit은 결과 계층 구조를 단일 공유 가능한 단위로 취급할 수 있으므로, 여기에 이러한 참조를 추가하고 싶을 것입니다.

이것은 매우 중요하며 CloudKit에서 부모 참조를 특별하게 만드는 것이다.

공유를 지원할 계획이 없다면, 부모 참조를 사용할 필요가 없으며, 자신의 스키마의 일반 CKReference 필드로 충분합니다.

그 설정으로, 이제 폴더 레코드를 CKShare의 루트 레코드로 사용하여 CKShare를 초기화하여 폴더 공유를 지원할 수 있습니다.

폴더를 루트 레코드로 사용하는 것은 CloudKit이 궁극적으로 해당 폴더 레코드를 가리키는 부모 참조 기반 계층 구조의 일부인 모든 레코드를 자동으로 공유한다는 것을 의미합니다.

이것은 또한 나중에 이 계층 구조에서 추가되거나 제거된 레코드가 각각 자동으로 공유되거나 공유되지 않는다는 것을 의미합니다.

그래서 이 간단한 폴더 공유 모델은 코드로 어떻게 설정되나요?

우리의 예를 계속해서, 여기에 개인 데이터베이스의 사용자 지정 영역에서 공유할 폴더 레코드와 함께 두 개의 파일 레코드가 있습니다.

먼저, 상위 참조는 폴더 레코드를 가리키는 두 파일 레코드에 모두 설정되며, 파일 레코드는 저장됩니다.

폴더가 공유될 때 수정해야 하는 레코드의 수를 최소화하기 위해 가능한 한 빨리 부모 참조를 저장하는 것이 좋습니다.

그런 다음, 세 개의 레코드는 모두 CKShare를 폴더를 루트 레코드로 초기화하고 개인 데이터베이스의 폴더 레코드와 함께 CKShare를 저장하여 공유됩니다.

상위 참조가 이전에 서버에 저장되었기 때문에, 공유 시간에 공유와 함께 루트 폴더 레코드만 수정해야 합니다.

그리고 그게 다야, 당신의 앱은 이제 그 아래의 레코드와 함께 폴더 레코드를 공유하고 있습니다.

CloudKit은 기록 계층이 겹치지 않는 한 동일한 영역 내에서 여러 CKShares를 지원할 수 있습니다.

이제, 계층적 폴더 공유 모델 대신, 당신의 영역에 몇 가지 뚜렷한 유형을 나타내는 레코드가 있고, 그들 사이에 논리적 계층 구조가 없다고 가정해 봅시다.

즉, 그 구역은 기록의 양동이로 취급되고 있으며, 당신은 그 안에 있는 모든 기록을 빠르게 공유하고 싶습니다.

이상적으로, 당신은 그 안에 어떤 레코드도 조작하지 않고 전체 레코드 영역을 "공유"로 표시할 수 있을 것입니다.

이제, 구역 공유로, 당신은 그것을 할 수 있습니다.

그래서, 이것을 코드로 설정합시다.

개인 데이터베이스의 기존 영역에 대한 레코드 영역 ID를 사용하는 CKShare의 새로운 이니셜라이저를 사용하기만 하면 됩니다.

이 새로운 영역 전체 공유 레코드가 저장되면, 서버의 이 영역에 존재하는 모든 레코드는 자동으로 공유되며, 새로운 레코드를 공유하거나 앞으로 레코드를 공유하지 않으면 해당 레코드를 추가하거나 제거하면 작동합니다.

전체 레코드 영역은 영역 전체 공유 레코드를 삭제하여 언제든지 공유하지 않을 수 있습니다.

이 새로운 구역 전체 공유 기록에 대해 조금 더 깊이 파고들자.

편의를 위해, 구역 전체 공유 레코드에는 항상 잘 알려진 레코드 이름인 CKRecordNameZoneWideShare가 있으며, 이는 구역 ID와 함께 사용하여 전체 공유 레코드 ID를 만들 수 있습니다.

영역 공유를 사용하는 영역은 해당 영역의 레코드 간에 상위 참조를 설정할 필요가 없습니다.

영역 공유는 영역당 단일 공유 레코드만 허용하기 때문에, 이 공유의 맛은 동일한 영역 내의 계층적 공유와 공존할 수 없습니다.

따라서, 한 구역에서 하나 이상의 계층적 공유 또는 단일 구역 전체 공유 기록을 가질 수 있습니다.

기본이 아닌 레코드 영역에 영역 전체 공유를 저장할 수 있으며, 새로운 영역 기능인 CKRecordZoneCapability ZoneWideSharing으로 표시됩니다.

CKShare 레코드 생성 이후의 모든 기존 CloudKit 공유 메커니즘은 동일하게 유지되며 한 가지 예외를 제외하고 영역 전체 공유에 대해 완전히 지원됩니다.

영역 공유를 사용할 때 더 이상 루트 레코드가 없기 때문에, hierarchicalRootRecordID 및 rootRecord와 같은 CKShareMetadata의 관련 속성은 영역 공유를 수락할 때 0이 됩니다.

마찬가지로, CKFetchShareMetadataOperation을 사용하여 사용자 지정 공유 수락 흐름을 부트스트랩할 때, 영역 전체 공유에 대한 공유 메타데이터를 가져올 때 "shouldFetchRootRecord" 및 "rootRecordDesiredKeys" 속성은 시스템에서 무시됩니다.

그래서, 이제 데이터 모델에 따라 두 가지 버전의 CloudKit 공유를 사용할 수 있습니다.

앱의 스키마가 논리적으로 계층 구조를 형성하고 계층적 트리가 공유 가능한 단위로 의미가 있다면, CKRecord 부모 참조를 계속 사용하여 해당 계층을 나타내고 루트 레코드를 공유하십시오.

Apple에서, 우리는 오늘날 탐구된 것과 비슷한 방식으로 메모, 미리 알림 및 iCloud Drive 폴더 공유를 위해 이것을 합니다.

그리고 다른 모든 경우, 이제 단일 영역 전체 공유 레코드를 만들고 CloudKit 공유를 최대한 활용하여 전체 레코드 영역을 효율적으로 공유할 수 있습니다.

Apple에서는 이미 HomeKit 보안 비디오 공유 및 HomePod 다중 사용자와 같은 여러 기능에 대해 영역 공유를 활용하고 있습니다.

그래서 오늘 우리는 항목별 진행 상황 및 오류 보고 API에 대한 향상을 포함하여 Swift에서 async/await를 사용하여 새로운 방식으로 CloudKit 코드를 작성하는 방법을 탐구했습니다.

우리는 자신의 암호화를 굴리지 않고 사용자 개인 정보 보호에 대한 Apple의 약속을 활용하여 민감한 사용자 데이터에 대한 기록의 암호화된 필드를 활용하는 방법에 대해 이야기했습니다.

그리고 우리는 데이터 모델이 영역 공유와 계층적이지 않을 때 CloudKit 공유를 시작하는 더 빠른 방법에 대해 배웠습니다.

이러한 기능에 대한 훌륭한 새로운 문서와 developer.apple.com에서 사용할 수 있는 더 많은 문서가 있으니, 한 번 보세요.

"Explore CloudKit" 컬렉션에는 CloudKit 위에 구축된 공유 기능을 소개하는 Core Data의 세션을 포함하여 확인할 수 있는 많은 관련 세션이 있습니다.

고마워, 그리고 네가 멋진 WWDC를 보내길 바라.

[쾌활한 음악].