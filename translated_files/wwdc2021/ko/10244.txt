10244

♪ ♪

안녕하세요, "App Attest 및 DeviceCheck로 사기 완화"에 오신 것을 환영합니다.

제 이름은 Xuerui Yan이고, App Store 신뢰 및 안전 팀에서 일하고 있습니다.

App Attest와 DeviceCheck를 사용하여 앱을 보호하는 것에 대해 이야기하게 되어 기쁩니다.

Apple에서는 App Store가 고객과 개발자에게 안전하고 신뢰할 수 있는 장소가 되도록 끊임없이 노력하고 있습니다.

이 비디오에서, 우리는 엔지니어링 세부 사항을 다룰 것이다.

비즈니스 및 개념적 세부 사항은 WWDC 2021의 "계정, 프로모션 및 콘텐츠 보호" 비디오를 참조하십시오.

iOS 11에서, 우리는 DeviceCheck 프레임워크를 도입했다.

DeviceCheck는 프로모션에 대한 사기를 완화하는 데 도움을 준다.

앱에 새로운 기능을 도입한다고 가정해 봅시다.

이 기능을 홍보하기 위해, 당신은 무료 일회용 아이템을 제공합니다.

누군가는 무료 아이템을 청구하기 위해 앱을 반복해서 다시 설치하여 프로모션을 남용할 수 있습니다.

앱을 반복적으로 설치하고 프로모션을 재사용하는 대신 프로모션 항목을 장치당 한 번으로 제한하고 싶을 것입니다.

이제 DeviceCheck는 장치가 프로모션 제안을 받았는지 또는 장치가 사기 활동에 참여했는지 여부를 감지하는 데 도움을 줄 수 있습니다.

Apple 서버의 한 장치와 관련된 두 비트의 정보와 타임스탬프를 지속적으로 저장할 수 있습니다.

이 비트들이 당신의 응용 프로그램에 무엇을 의미하는지 결정하는 것은 당신에게 달려 있습니다.

그 상태는 당신이 업데이트하고 질의할 수 있도록 Apple에 의해 유지될 것입니다.

비트는 개발자의 모든 앱에서 공유됩니다.

비트에 의미를 할당할 때 모든 앱에 적용할 수 있도록 명심하세요.

이 상태는 앱 재설치, 사용자 간의 장치 전송, 심지어 "모든 콘텐츠와 설정 지우기"에서도 지속됩니다.

프로모션 및 비즈니스 전략에 따라 타임스탬프를 사용하여 선택한 기간에 비트를 재설정하는 것을 고려해 보세요.

DeviceCheck에 대한 자세한 내용은 WWDC 2017의 "개인 정보 보호 및 앱" 비디오와 DeviceCheck 프레임워크 문서를 참조하십시오.

그래서 그게 DeviceCheck야.

다음으로, 저는 DeviceCheck 프레임워크에서도 사용할 수 있는 App Attest에 대해 이야기할 것입니다.

당신의 서비스가 요청을 받으면, 그것이 정말로 당신의 앱에서 온 것인지 알기 어려울 수 있습니다.

App Attest를 사용하면 앱이 요청의 일부로 하드웨어 기반 주장을 첨부할 수 있습니다.

서버는 주장을 사용하여 요청이 정품 Apple 장치의 정품 앱에서 왔는지 확인할 수 있습니다.

당신이 수집품을 발견하기 위해 여행을 장려하는 아름다운 앱을 설계했지만, 수정된 앱이 집을 떠나지 않고도 모든 것을 수집할 수 있다는 것을 발견했다고 상상해 보세요.

또는 경쟁적인 멀티플레이어 레이싱 게임에서 무제한 부스트를 얻기 위해 치트를 사용하여 다른 사람들이 리더보드를 경주하는 것을 보는 플레이어의 좌절감을 상상해 보세요.

또는 토요일에 일어나서 서버에서 매우 높은 요청 볼륨을 보는 것을 상상해 보세요. 하지만 조사 후, 전화가 앱에서 전혀 오지 않는다는 것을 알게 됩니다.

App Attest는 앱의 정품 및 수정된 버전을 식별하는 데 도움이 되며, 앱 경험과 비즈니스를 보호할 수 있습니다.

App Attest는 당신과 당신의 고객을 보호하기 위해 활용할 수 있는 세 가지 주요 속성을 제공합니다.

App Attest를 사용하면 서비스가 세 가지 조건을 충족하여 요청이 앱의 합법적인 인스턴스에서 왔는지 확인할 수 있습니다: 요청은 정품 Apple 장치에서 왔으며, 정품 애플리케이션을 실행하며, 페이로드가 변조되지 않았습니다.

App Attest가 이러한 각 속성을 어떻게 제공하는지 살펴봅시다.

App Attest의 중심에는 Apple이 서명한 보안 키 쌍과 증명이 있으며, 키 쌍이 정품 Apple 장치에서 유래했음을 증명합니다.

개인 키는 App Attest API를 사용하여 Secure Enclave를 통해서만 저장되고 액세스할 수 있습니다.

앱은 키로 서비스에 대한 요청에 서명할 수 있으며, 서비스는 서명을 확인하여 요청이 정품 Apple 장치에서 생성되었는지 확인할 수 있습니다.

애플 기기에서 앱을 실행하려면, 서명해야 합니다.

앱을 무단으로 수정하는 사람은 자신이 제어하는 신원으로 다시 서명해야 합니다.

이것은 불가피하게 앱 ID를 수정한다.

우리는 증명에 앱 ID의 해시를 포함합니다.

앱 ID를 증명에 포함된 것과 비교함으로써, 발신자가 수정된 버전을 사용하고 있는지 확인할 수 있습니다.

이제 요청이 정품 장치와 정품 앱에서 왔다는 것을 알았으니, 요청 페이로드에 대해 이야기해 봅시다.

서버로 페이로드를 보내기 전에, App Attest에게 증명된 키를 사용하여 페이로드의 다이제스트에 서명하도록 지시할 수 있습니다.

이것은 페이로드의 주장을 만든다.

당신의 앱은 페이로드와 주장을 서비스에 전송해야 합니다.

페이로드에 대한 주장을 확인함으로써, 페이로드가 운송 중에 변조되지 않았다는 것을 신뢰할 수 있습니다.

그것들은 세 가지 주요 속성이다.

이제 사생활에 대해 조금 이야기해 봅시다.

여기 애플에서, 우리는 사생활에 깊은 관심을 가지고 있다.

우리는 프라이버시가 건강한 앱 생태계를 위한 필수적인 토대라고 믿습니다.

App Attest의 각 요소는 프라이버시를 염두에 두고 만들어졌습니다.

증명은 추적으로부터 보호하면서 정품 장치에 대한 보증을 제공하도록 설계되었습니다.

증명은 익명이며 하드웨어 식별자를 포함하지 않습니다.

앱 증명 키는 앱 설치마다 고유합니다.

이것은 App Attest 키가 앱 재설치에서 살아남지 못하고, 백업되지 않으며, 장치 간에 동기화되지 않는다는 것을 의미합니다.

앱을 디자인할 때 이것을 명심하세요.

이제 App Attest가 제공하는 가치를 이해했으므로, 앱에 통합하는 세부 사항에 대해 자세히 알아보겠습니다.

앱 증명을 앱에 통합하는 세 가지 기본 부분이 있습니다.

앱 증명 키를 만들고, 키를 증명하고 확인하고, 주장을 생성하고 확인합니다.

앱 증명 키를 만드는 것부터 시작합시다.

모든 앱 증명 호출은 isSupported 속성에 의해 보호되어야 합니다.

App Attest는 Secure Enclave가 있는 장치에서 지원되지만, isSupported가 여전히 false를 반환하는 앱 확장과 같은 경우가 있습니다.

당신의 앱은 이러한 경우를 우아하게 처리해야 합니다.

즉시 접근을 차단하는 대신, 실패를 위험 신호로 사용하세요.

먼저, 발신자를 신뢰할 수 없는 것으로 분류하세요.

그런 다음, 위험 평가 논리에 따라, 고객이 민감한 기능을 사용할 수 있도록 허용할지 여부를 평가하십시오.

또 다른 접근 방식은 서비스에 전화할 때 앱 증명을 지원하지 않는다고 주장하는 장치의 갑작스러운 증가를 모니터링하는 것입니다.

앱 증명을 지원하는 장치의 비율이 갑자기 감소하면, 수표를 우회하려는 수정된 앱의 징후일 수 있습니다.

앱 증명 키가 성공적으로 생성되면, 계속해서 키를 증명해 봅시다.

중간자 및 리플레이 공격을 방지하기 위해, 우리는 일회성 서버 도전이 필요하다.

당신의 서버가 앱에 도전하도록 합시다.

증명을 사용자 계정 ID 또는 기타 값과 연결하려면, clientDataHash를 만들기 위한 도전과 함께 해당 값을 해시하십시오.

이전 단계의 keyId와 함께 clientDataHash를 사용하여 이제 attestKey API를 호출할 수 있습니다.

attestKey는 개인 키를 사용하여 장치에 대한 하드웨어 증명 요청을 만들고 확인을 위해 Apple에 요청을 제출합니다.

일단 확인되면, Apple은 익명의 증명 객체를 당신의 앱에 반환할 것입니다.

확인을 위해 사용자 지정 페이로드와 함께 증명을 서버로 다시 보내세요.

좋아요, 이제 앱이 서버에 증명을 보냈으니, 확인해 봅시다.

증명은 웹 인증 표준을 따르며 세 부분으로 구성되어 있습니다: Apple이 서명한 인증서 목록, 인증자 데이터 구조 및 위험 메트릭 영수증.

당신이 확인해야 할 중요한 부분들을 살펴봅시다.

인증서 섹션에는 잎과 중간 인증서가 포함되어 있습니다.

App Attest 루트 인증서는 Apple Private PKI 저장소에서 사용할 수 있습니다.

전체 인증서 체인을 검증하면 장치가 정품 Apple 장치라는 것을 알 수 있습니다.

attestKey를 호출했을 때, nonce로 알려진 일회용 해시가 clientDataHash 및 기타 데이터에서 생성되었습니다.

그 논스는 잎 증명서에 포함되어 있다.

변조를 방지하기 위해, 당신은 서버에서 논스를 재구성하고 그것이 일치하는지 확인할 것입니다.

인증자 데이터 블록에는 앱이 당신을 부르는지 확인하는 데 사용할 수 있는 앱 ID의 해시를 포함한 여러 속성이 포함되어 있습니다.

주요 증명에는 나중에 Apple에 위험 메트릭을 요청하기 위해 저장하고 사용할 수 있는 영수증도 포함되어 있습니다.

나는 나중에 비디오에서 그것에 대한 더 많은 정보를 다룰 것이다.

모든 것이 확인되면, 앱 인증 키는 정품입니다.

후속 요청을 확인하는 데 사용할 클라이언트 데이터와 관련된 키를 저장하십시오.

모든 실패가 잘못된 증명으로 인한 것은 아니다.

isSupported가 거짓을 반환하거나, 램프 업 중에 조절되거나, 일반적인 네트워크 오류와 같은 시나리오를 우아하게 처리하십시오.

그런 다음 전반적인 위험 평가에 실패를 신호로 통합할 수 있습니다.

검증 구현에 대한 자세한 내용은 문서를 참조하십시오.

attest-Key API를 호출하면 앱에서 App Attest 서비스로 네트워크 호출이 생성됩니다.

이것은 앱 인스턴스당 한 번만 발생합니다.

그러나, 설치 기반이 큰 경우, 총체적으로 앱은 App Attest에 많은 요청을 보낼 수 있습니다.

자원을 관리하고 속도 제한을 피하기 위해, 설치 기반에서 이 기능을 점진적으로 활성화해야 합니다.

예를 들어, 매일 백만 명의 활성 사용자가 있다면, 하루 정도 증가할 수 있습니다.

매일 10억 명의 활성 사용자가 있다면, 잘했어!

당신은 한 달 이상 늘려야 합니다.

이제 검증된 키가 있으므로, generateAssertion API 호출을 사용하여 앱과 서버 간의 민감한 통신을 보호할 수 있습니다.

애플 서버가 더 이상 관여하지 않기 때문에, 주장 흐름은 증명보다 간단하다.

키를 사용하는 모든 주장은 장치에서 생성되고 서버에서 검증됩니다.

서버에서 고유한 챌린지를 요청하는 것으로 시작한 다음, 페이로드의 다이제스트를 생성하고 generateAssertion을 호출하십시오.

generateAssertion은 다이제스트를 사용하여 nonce를 계산하고 App Attest 키로 서명합니다.

그런 다음 앱은 페이로드와 어설션을 서버로 보낼 수 있습니다.

마지막으로, 당신의 서버는 페이로드를 확인해야 합니다.

주장 페이로드는 이 높은 수준의 구조를 포함한다.

서명 및 인증자 데이터.

서명을 검증하려면, 프로세스를 뒤집어 서버에서 nonce를 재구성하세요.

그런 다음 공개 키를 사용하여 서명을 확인하세요.

서명이 유효하다면, 페이로드가 수정되지 않은 것을 신뢰할 수 있습니다.

인증자 데이터 섹션에는 앱 ID 해쉬가 포함되어 있습니다.

주장이 정품 앱에서 나오는지 확인하기 위해 해시를 확인하세요.

인증자 데이터는 또한 계속 증가하는 카운터를 포함한다.

리플레이 공격으로부터 보호하기 위해, 서버에 카운터 값을 저장하고, 후속 요청마다 증가할 것으로 예상하십시오.

열쇠로, 당신은 이제 필요한 만큼 이 과정을 반복할 수 있습니다.

주장을 생성하는 것은 애플 서버를 호출하지 않지만, 약간의 대기 시간을 추가하는 암호화 작업이다.

App Attest를 앱에 통합할 때 이것을 디자인에 고려해야 합니다.

주장은 중요하지만 드문 통화와 추가 대기 시간과 필요한 계산을 처리할 수 있는 통화에 적합합니다.

빈번한 실시간 네트워크 명령의 경우, 주장은 적합하지 않을 수 있습니다.

축하해!

이제 App Attest의 기본 구현을 완료했습니다.

이 구현만으로도, 들어오는 서버 요청을 정품 및 수정된 것으로 분류하고, 이 중요한 사기 신호를 비즈니스 논리에 통합할 수 있습니다.

하지만 더 있어.

공격자는 단일 장치를 사용하여 많은 App Attest 키를 만들고, 그 장치를 사용하여 많은 수정된 앱과 서버 간의 통신을 제공하기 위해 App Attest를 우회하려고 시도할 수 있습니다.

그러한 행동을 감지하기 위해, 우리는 앱의 장치에서 생성된 대략적인 키 수를 제공하는 App Attest Risk Metric Service라는 서비스를 제공합니다.

attestKey가 증명과 위험 메트릭 영수증을 모두 반환한다는 것을 기억하세요.

당신의 서버는 그 영수증을 서비스에 제출하고 새 영수증으로 교환할 수 있습니다.

새로운 영수증에는 위험 지표가 포함될 것이다.

주기적으로, 해당 앱/장치 쌍에 대한 업데이트된 메트릭에 대한 최신 영수증을 사용할 수 있습니다.

여기 영수증 구조에 대한 높은 수준의 견해가 있습니다.

그것은 PKCS7 컨테이너이다.

자세한 내용은 DeviceCheck Framework 문서의 "사기 위험 평가"를 참조하십시오.

앱 클립은 iOS의 흥미로운 기능이다.

iOS 15의 앱 클립에 앱 증명 지원을 추가했습니다.

앱 클립에서 전체 앱으로의 원활한 업그레이드를 지원하기 위해, 앱 클립과 전체 앱은 앱 증명 컨텍스트에서 동일한 앱 ID를 공유합니다.

서버 측에서 앱 신원을 확인할 때 이것을 명심하세요.

앱 클립이 수동으로 제거되거나 만료되면, 전체 앱이 제거될 때와 마찬가지로 키는 무효화됩니다.

그래, 그게 앱 클립을 위한 거야.

이제, App Attest의 성공을 위한 이러한 요점을 기억하세요.

장치가 아닌 서버에서 검증하세요.

앱은 유효성 검사 코드를 비활성화하도록 수정될 수 있습니다.

네트워크 리플레이 공격을 방지하기 위해 흐름에 일회성 서버 챌린지를 통합하세요.

isSupported가 거짓을 반환하거나, 램프업 중에 조절되거나, 일반적인 네트워크 오류와 같은 실패 시나리오를 처리하십시오.

위험 평가에 실패를 신호로 포함시키세요.

App Attest와 DeviceCheck는 전반적인 사기 평가에 통합할 수 있는 정보를 제공합니다.

DeviceCheck를 사용하여 프로모션에 대한 사기를 완화하세요.

App Attest를 활용하여 앱의 수정된 버전을 감지하여 콘텐츠와 사용자 경험을 보호하세요.

봐줘서 고마워!

저는 당신의 앱이 App Attest와 DeviceCheck로 보호되는 것을 보기를 기대하고 있습니다.

평화!