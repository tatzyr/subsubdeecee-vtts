10114

♪ 베이스 음악 연주 ♪

♪

로스 르보: 안녕하세요, WWDC21에 오신 것을 환영합니다.

제 이름은 Ross LeBeau이고, StoreKit 팀의 엔지니어입니다.

오늘, 우리는 StoreKit에 대해 이야기할 것이며, 이것은 실제로 클라이언트 측 코드를 구현하고, 인앱 구매를 위한 서버를 구축하고, 고객을 지원하고 환불을 처리하는 데 도움이 되도록 설계된 세 가지 세션 중 하나입니다.

이 세션은 Meet StoreKit 2이며, 여기 WWDC21에서 다른 두 세션을 찾을 수 있습니다.

이 세션은 클라이언트 측 기능과 구현에 초점을 맞출 것이다.

그럼 시작하자!

StoreKit이 iOS 3에 도입되었기 때문에, 당신과 당신의 비즈니스를 위한 훌륭한 기회를 창출했습니다.

오늘날, 그것은 네 개의 애플 플랫폼에 존재하며 게임부터 뉴스 앱, 인디 타이틀, 국제 히트작에 이르기까지 모든 것을 지원합니다.

수년에 걸쳐, 우리는 Xcode에서 제안 코드, 가족 공유 및 StoreKit 테스트와 같은 훌륭한 기능을 도입했습니다.

하지만 올해, 우리는 시작으로 돌아가기로 결정했다.

오늘, StoreKit 2를 소개하게 되어 기쁩니다!

StoreKit 2는 iOS, macOS, tvOS 및 watchOS에서 인앱 구매 작업을 위한 새롭고 현대적인 Swift API 세트입니다.

우리는 스위프트 퍼스트 마인드로 StoreKit을 새롭게 살펴보았습니다.

우리는 단순하면서도 강력한 API를 만들기 위해 비동기/대기 패턴을 사용하는 스위프트 동시성과 같은 최신 언어 기능을 채택했습니다.

우리는 또한 인앱 구매 거래를 크게 업데이트하여 작업하기가 훨씬 쉬워진 동시에 더 많은 정보와 높은 보안을 제공했습니다.

그리고 우리는 당신이 사업을 성장시키는 데 사용할 수 있는 더 깊은 통찰력을 제공하기 위해 구독을 위한 더 강력한 API를 추가했습니다.

StoreKit 2 API는 오늘날 존재하는 동일한 StoreKit 프레임워크 내에 있으며 모든 API를 대체하기보다는 핵심 인앱 구매 경험에 중점을 둡니다.

새로운 StoreKit 2 API는 제품, 구매, 거래 정보, 거래 내역 및 구독 상태의 다섯 가지 주요 영역으로 구성되어 있습니다.

오늘 저는 이러한 각 영역에 대한 개요를 제공할 것이며, 제 동료 Jakob은 실제 코드에서 해당 StoreKit 2 API를 사용하는 방법을 보여줄 것입니다.

그래서 먼저, StoreKit의 빌딩 블록부터 시작합시다: 제품과 구매.

StoreKit 2 제품 구조체는 당신이 익숙한 StoreKit 제품 객체의 과급 버전입니다.

우선, 우리는 제품 유형과 확장된 구독 정보와 같은 추가 데이터를 추가했습니다.

StoreKit 2를 사용하면 고객이 입문 제안을 받을 자격이 있는지 확인하는 것과 같은 일을 더 쉽게 할 수 있습니다.

우리는 또한 StoreKit 2 제품을 새로운 기능과 호환하도록 만들고 있습니다.

우리는 제품을 직접 첨하여 제품에 포함된 데이터를 검색할 수 있는 BackingValue라는 래핑 유형을 추가하여 이를 달성했습니다.

즉, 향후 제품에 데이터를 추가하면 이전 버전의 StoreKit 2가 있는 운영 체제를 실행하는 SDK 및 장치에서도 StoreKit 2에서 항상 액세스할 수 있습니다.

이것은 최신 기능을 사용하여 고객 기반의 더 큰 부분에 새로운 기능을 제공할 수 있다는 것을 의미합니다.

StoreKit 2를 사용하면 제품 유형 자체에서 정적 함수를 호출하여 제품을 요청합니다.

이것은 기존 SKProductsRequest와 마찬가지로 App Store에서 제품 메타데이터를 요청합니다.

하지만 새로운 Swift 동시성 비동기/대기 패턴 덕분에 StoreKit 2 제품 요청은 한 줄의 코드만 필요합니다.

마찬가지로, StoreKit 2에서 제품을 구매하는 것은 또 다른 간단한 한 줄의 작업이다.

구매는 이제 제품 유형에 대한 인스턴스 방법입니다. 즉, 방금 검색한 제품을 가져가서 직접 구매할 수 있습니다.

구매 방법은 또한 비동기/대기를 사용하기 때문에, 코드에서 인라인으로 구매 결과를 얻을 수 있습니다.

이제 우리는 모든 구매가 같은 것은 아니라는 것을 알고 있다.

기본 설정을 넘어 구매 행동을 수정하려면, StoreKit 2에는 구매 옵션이 있습니다.

구매 옵션은 구매의 단일 속성을 설명하는 항목입니다.

구매 옵션을 구매 방법으로 전달하는 세트로 구성할 수 있습니다.

StoreKit 2에는 수량 및 프로모션 제안과 같은 구매 옵션이 포함되어 있습니다.

그리고 StoreKit 2에서는 앱 계정 토큰이라는 새로운 옵션을 추가하고 있습니다.

앱 계정 토큰은 어떤 앱의 사용자 계정이 거래를 시작하고 완료했는지 추적할 수 있는 방법입니다.

앱이 소유한 계정에 연결할 수 있는 불투명한 토큰입니다.

유일한 요구 사항은 UUID 형식을 준수하는 것이기 때문에 앱 계정 토큰을 생성하는 것은 쉽습니다.

구매 옵션으로 구매 시 앱 계정 토큰을 보내면, 이 토큰은 해당 구매에 대한 거래 정보에 반환됩니다.

앱 계정 토큰은 모든 장치에서도 거래 정보에 영원히 유지됩니다.

앱이 자체 계정 시스템을 지원하는 경우, 구매에 사용된 Apple ID 또는 장치에 관계없이 각 앱 내 계정이 어떤 구매를 했는지 추적하는 데 도움이 될 수 있습니다.

그래서, 우리는 App Store에서 제품을 받고 구매를 시작하는 것에 대해 이야기했습니다. 이제 구매가 완료되면 어떻게 되나요?

예상대로, StoreKit은 암호화로 서명된 정보와 함께 성공적인 거래를 반환할 것입니다.

친숙하게 들리죠?

음, StoreKit 2는 인앱 구매 거래에 가장 큰 업데이트를 가져오고 있다.

우선, StoreKit 2는 모든 거래에 대해 개별적으로 서명된 객체를 제공할 것이다.

뿐만 아니라 StoreKit 2부터 인앱 구매 거래 정보는 이제 매우 일반적이고 작업하기 쉬운 형식인 JSON으로 제공됩니다.

그리고 우리는 안전한 암호화 서명이 StoreKit 구매의 중요한 부분이라는 것을 알고 있기 때문에, 우리는 이제 JSON 웹 서명으로 알려진 웹에서 사용되는 공통 표준을 사용하고 있습니다.

게다가, 서명된 객체에 포함된 모든 정보는 이제 네이티브 StoreKit API를 통해 사용할 수 있으므로 앱 코드에서 이 데이터로 쉽게 작업할 수 있습니다.

사실, 우리는 그것이 얼마나 쉬운지 보여줄 것이다.

여기 실제 코드에서 이러한 API를 시연한 Jakob이 있습니다.

제이콥 스웽크: 안녕하세요, 저는 제이콥입니다.

저는 StoreKit 팀의 엔지니어입니다.

오늘 앱에서 StoreKit 2를 시작하고 실행하는 것이 얼마나 쉬운지 보여드리게 되어 정말 기쁩니다.

오른쪽에, 내가 만들고 있는 Pocket Cars라는 앱이 있어.

이 세션의 리소스 섹션에서 이 앱의 샘플 코드를 다운로드하고 따라갈 수 있습니다.

그 앱은 두 가지 주요 견해를 가지고 있다.

내가 수집한 차에 대한 전망과 내 가게에 대한 전망이 있다.

가게로 가자.

현재, 판매할 수 있는 제품이 없기 때문에 제 가게는 비어 있습니다.

나는 지금 그것들을 시행할 것이다.

빠르게 시작하고 실행하기 위해, 저는 Xcode에서 StoreKit 테스트를 사용하고 있습니다.

이를 통해 App Store Connect에서 제품을 정의하기 전에 상점을 구축하고 테스트할 수 있습니다.

내 Xcode 프로젝트에서, 나는 이미 내가 팔고 싶은 제품을 정의하는 StoreKit 구성 파일을 만들었다.

이것은 내가 StoreKit에 사용했던 것과 동일한 구성 파일이다; 나는 아무것도 변경하거나 마이그레이션할 필요가 없다.

여기, 나는 또한 내 모든 제품 식별자를 포함하는 plist를 가지고 있다.

그것은 내 앱에 내장된 리소스 파일로 포함되어 있으므로 런타임에 사용할 수 있습니다.

내 가게에 이 제품들을 전시하려면, 먼저 내가 표시하고 싶은 제품 식별자 세트를 사용하여 제품 요청을 해야 한다.

StoreKit 2를 사용하면 제품 구조체에서 정적 메서드를 호출하여 간단하게 수행할 수 있습니다.

App Store에서 제품을 받은 후, 유형별로 분리하고 싶습니다.

제품 유형이 이제 App Store 서버에 정의된 유형에 대한 속성을 제공하기 때문에 StoreKit 2로 쉽게 할 수 있습니다.

내 앱에서, 나는 세 가지 유형의 제품을 판매하고 있다: 연료, 자동차, 그리고 내비게이션 패키지.

연료는 소모품이다 - 일단 사용하면, 없어진다 - 그래서 나는 모든 소모품을 연료 어레이에 넣을 것이다.

자동차는 비소모성이다.

일단 내가 차를 사면, 나는 그것을 영원히 소유한다.

그래서 나는 모든 비소모품을 자동차 어레이에 넣을 것이다.

내비게이션 패키지는 세 가지 수준의 서비스를 제공하는 구독 제품입니다.

내 고객들은 한 번에 한 수준의 서비스를 구독할 수 있으며, 주기적으로 청구됩니다.

또한, 서비스 수준을 변경하고 싶다면 언제든지 업그레이드하거나 다운그레이드할 수 있습니다.

App Store는 각 서비스 수준에 대한 제품을 반환하므로, 모든 자동 갱신 구독을 구독 배열에 넣을 것입니다.

나는 또한 각 유형 내에서 가장 낮은 가격부터 가장 높은 가격까지 내 제품을 분류하고 싶다.

내 앱을 실행하고 내가 지금까지 뭘 했는지 확인해 보자.

이제 가게로 갈게.

와!

전에는 내 가게가 비어 있었지만, 지금은 내 모든 제품이 전시되어 있어 꽤 멋져 보인다.

한 줄의 코드로 App Store에서 앱의 제품을 요청할 수 있었고, 받은 메타데이터를 기반으로 제품을 그룹화하고 정렬할 수 있었기 때문에 스토어 UI를 쉽게 구축할 수 있었습니다.

이제 내 제품은 멋져 보이지만, 구매 버튼을 누르면 아무 일도 일어나지 않는다.

그건 내 가게의 구매 방법이 아무것도 하지 않기 때문이야.

StoreKit으로 구매를 시작해야 합니다.

우리는 단순히 제품의 구매 방법을 호출하여 이것을 할 수 있습니다.

로스가 언급했듯이, 스토어킷 2는 스위프트의 새로운 동시성 기능을 사용하기 위해 처음부터 만들어졌다.

이것은 내 앱이 내 코드를 읽기 쉽게 유지하기 위해 동일한 컨텍스트 내에서 구매 결과를 구매하고 처리하기 위한 코드를 유지할 수 있게 해준다.

구매가 완료되면, PurchaseResult가 반환됩니다.

이 PurchaseResult는 구매가 성공했는지 또는 사용자가 구매를 취소했거나 구매에 부모의 추가 은행 검증 또는 승인이 필요한 것과 같은 다른 오류가 아닌 상태로 완료되었는지 알려줍니다.

각 사건을 처리하기 위해, 나는 그것들을 바꿀 것이다.

PurchaseResult가 성공 상태에 있다면, 나는 또한 검증 결과를 얻는다.

검증 결과에는 두 가지 사례가 포함되어 있습니다: 검증 및 미확인.

StoreKit 2에서 거래 유형에는 서명된 거래를 나타내는 JWS 페이로드가 포함되어 있습니다.

내 앱이 StoreKit 2로부터 거래를 받을 때마다, 거래는 페이로드가 이 장치에 대한 내 앱에 대해 App Store에 의해 서명되었는지 확인하기 위해 검증 프로세스를 통과했습니다.

너 그거 제대로 들었어.

StoreKit 2는 당신을 위해 거래 확인을 합니다.

물론, 내가 검증 결과를 어떻게 처리하기로 선택하는지는 전적으로 나와 내 사업의 필요에 달려 있다.

내 앱의 경우, StoreKit에서 받은 이 거래가 확인되었는지 확인할 것입니다.

여기 내 가게에서, 나는 모든 VerificationResult에 사용할 수 있는 checkVerified 방법을 만들 것이다.

결과가 확인되지 않으면, 내 앱의 다른 부분에 알리기 위해 내 자신의 failedVerification 오류를 던진다.

결과가 확인되면, 나는 거래를 풀고 발신자에게 돌려준다.

이제 구매 결과에 대해 이 checkVerified 방법을 사용할 수 있습니다.

마지막으로, 내 거래가 확인되면, 나는 내 사용자에게 콘텐츠를 전달한다.

사용자가 콘텐츠를 얻은 후, 나는 StoreKit에게 거래를 완료하라고 말해야 한다.

그런 다음 UI가 업데이트될 수 있도록 반품해야 합니다.

내 앱에는 내가 관리하는 계정 데이터베이스가 있다.

내 앱의 현재 로그인한 사용자를 StoreKit 구매에 포함시키고 싶습니다. 그래서 이 정보는 App Store에 서명된 거래를 받을 때 항상 내 앱에서 사용할 수 있습니다.

로그인한 계정의 토큰화된 버전을 사용하여 appAccountToken 구매 옵션을 만들고 해당 옵션을 구매 방법으로 전달하여 이 작업을 수행할 수 있습니다.

알았어.

우리는 모두 내 구매 방법 구현을 준비했다.

내 앱을 다시 실행하자.

이제 우리는 내 가게로 돌아왔고, 나는 꽤 모험적인 기분이야.

그래서 나는 항상 오토바이를 원했기 때문에 오토바이를 살 거야.

구매가 제대로 시작되었음을 보여주는 StoreKit의 결제 시트가 있습니다.

구매를 확인하기 위해 탭하겠습니다.

그런 다음 StoreKit은 구매가 성공적이라는 경고를 표시합니다.

그 경고를 해제한 후, 내 구매 버튼은 내 앱이 거래를 신뢰하고 내 오토바이가 배달되었음을 보여주는 녹색 체크 표시로 바뀝니다.

여기서 주목하고 싶은 중요한 것이 하나 더 있다.

이전에 말했듯이, 때때로 고객은 계정에 대한 추가 확인을 해야 하거나 구매가 완료되기 전에 부모의 승인이 필요할 것입니다.

이러한 경우, product.purchase()에서 받은 구매 결과는 보류 상태가 될 것입니다.

이것은 고객이 계정 확인을 완료하거나 부모가 승인한 후, 내 앱은 완료된 구매를 반영하기 위해 UI를 업데이트해야 한다는 것을 의미합니다.

이러한 거래 업데이트를 들으려면, 거래 유형에 대한 정적 속성을 반복해야 합니다.

이 속성은 무한한 비동기 시퀀스이다.

그것은 내가 루프를 취소하거나 벗어날 때까지 StoreKit에서 들어오는 거래 업데이트를 계속 반복할 것이라는 것을 의미합니다.

여기서 저는 저장소가 할당될 때 업데이트 리스너를 명시적으로 취소하는 데 사용할 수 있는 작업 핸들을 반환하는 분리 작업을 만들고 있습니다.

StoreKit 2에서 받는 모든 거래와 마찬가지로, 사용자에게 콘텐츠를 전달하기 전에 확인 결과가 확인되었는지 확인하고 싶습니다.

이전에 정의된 checkVerified 방법을 사용할 수 있습니다.

그리고, 구매 응답과 마찬가지로, 일단 확인된 거래를 받으면, 사용자에게 콘텐츠를 전달해야 합니다.

그리고 물론, 나는 항상 내 거래를 끝내야 한다.

앱이 실행되자마자 거래 업데이트 리스너를 시작하는 것이 매우 중요하므로 하나도 놓치지 않습니다.

나는 내 가게가 만들어지자마자 이것을 할 것이며, 이는 앱 출시 바로 주변에서 일어난다.

업데이트 리스너를 테스트하기 위해, Xcode 테스트 환경에서 구매 요청을 활성화하여 보류 중인 상태에서 구매 응답을 시뮬레이션할 것입니다.

이렇게 하려면 StoreKit 구성 파일을 선택하고 편집기 메뉴에서 구매 요청 활성화를 선택합니다.

내 앱을 다시 실행하고 구매하자.

이번에는 결제 시트를 확인한 후, 구매를 완료하려면 허가를 요청해야 한다는 StoreKit의 새로운 경고가 표시됩니다.

내가 가서 물어보기를 탭할게.

구매 응답은 보류 중인 상태로 내 앱으로 반환됩니다.

구매를 승인하려면, Xcode 거래 관리자에서 StoreKit 테스트를 열고 오른쪽 상단 모서리에 있는 승인 버튼을 클릭할 것입니다.

좋아!

거래를 승인한 직후, 업데이트 리스너는 확인 결과를 받았고 UI는 승인된 구매를 보여주기 위해 즉시 변경되었습니다.

이제 나는 순항할 수 있는 새로운 표준 5인승을 가지고 있다.

StoreKit 2를 사용하여 제품을 요청하고, 구매를 시작하고, 다른 구매 결과에 반응하고, 거래의 무결성을 확인하고, 보류 중인 거래에 대해 App Store에서 업데이트를 받는 것이 얼마나 쉬운지 방금 보여주었습니다.

이제 사용자의 거래 내역과 구독 상태에 대한 소개를 위해 로스로 돌아가 봅시다.

로스: 와! 이 새로운 API가 작동하는 것을 보는 것은 꽤 놀랍다.

그리고 자동 검증, 당신은 무엇을 더 원할 수 있나요?

그게 뭐야?

당신은 암호화를 좋아하고 여전히 데이터를 직접 검증하고 싶으신가요?

걱정하지 마.

StoreKit 2의 자동 유효성 검사는 보안 기준을 높이지만, 자체 유효성 검사를 완전히 대체하기 위한 것은 아닙니다.

언제나 그렇듯이, 보안은 힘, 시간 및 복잡성의 스펙트럼에 달려 있다.

조금 이따가 검증에 대한 특종을 줄게.

첫째, 당신이 나처럼 StoreKit 2 거래에 대해 흥분한다면, 우리가 그들과 함께 일할 수 있는 많은 새로운 방법을 제공하고 있다는 소식을 듣고 싶어할 것입니다.

우리는 사용자의 거래 기록에서 완료된 거래를 쿼리하기 위한 새로운 API 세트를 추가하고 있습니다.

StoreKit 2에서는 단일 API 호출로 사용자의 모든 과거 거래에 액세스할 수 있습니다.

당신은 또한 제품에 대한 최신 거래에 접근할 수 있습니다.

그래서 만약 당신이 구독의 가장 최근 갱신을 보고 싶다면, 당신은 할 수 있습니다.

그리고 우리는 당신이 알아야 할 가장 중요한 것은 사용자가 지금 접근하기 위해 지불한 제품이라는 것을 알고 있습니다.

그래서 우리는 그 정보를 CurrentEntitlements라는 단일 함수로 추출했습니다.

현재 자격에는 사용자의 거래 내역에 있는 모든 비소모품과 현재 활성화된 모든 구독 거래가 포함되어 있습니다.

이를 통해 사용자가 앱에서 지불한 모든 것을 잠금 해제하는 데 필요한 모든 정보를 얻을 수 있습니다.

그리고 이것은 사용자가 지금 당장 접근할 수 있어야 하는 것들만을 나타내기 때문에, 취소된 모든 거래는 응답에 포함되지 않습니다.

소모품은 거래 내역의 지속적인 부분이 아니기 때문에 포함되지 않습니다.

이제, 너는 생각하고 있을 거야, "난 기다릴 수 없어!

언제 내 앱에서 이것들을 호출할 수 있나요?"

음, StoreKit 2를 사용하면 사용자가 완료한 모든 거래를 요청하는 즉시 앱에서 사용할 수 있습니다.

즉, 사용자가 새 장치에 앱을 설치할 때, 앱을 처음 열 때 어떤 제품에 액세스할 수 있는지 알 수 있습니다.

게다가, 거래 내역은 사용자의 장치에서 자동으로 업데이트됩니다.

고객이 한 장치에서 구매하면, 앱은 설치된 다른 모든 장치에서 구매를 볼 수 있습니다.

사실, 다른 장치에서 구매할 때 앱이 실행되고 있다면, 새로운 거래에 대한 알림을 받게 될 것입니다.

제이콥은 앱이 시작되자마자 거래를 듣는 것이 중요하다고 언급했으며, 이것이 사실인 또 하나의 이유일 뿐입니다.

따라서, 이 모든 것은 사용자가 앱을 새 장치에 다시 설치하거나 다운로드할 때 완료된 거래를 복원할 필요가 없다는 것을 의미합니다.

모든 것은 StoreKit에 의해 자동으로 가져와지고 최신 상태로 유지되어야 합니다.

하지만 사람들은 수백만 곳에서 수백만 가지 방법으로 Apple 기기를 사용한다.

드물게 사용자가 거래를 해야 한다고 생각하지만 보이지 않는 경우, App Store 동기화 API를 사용할 수 있습니다.

이것은 즉시 모든 StoreKit 2 거래를 재동기화합니다.

이것은 restoreCompletedTransactions API를 대체하며, 사용자가 동기화를 시작할 수 있도록 앱에 UI를 제공해야 합니다.

그러나, StoreKit 2의 자동 동기화 덕분에, 사용자가 수동으로 동기화를 시작해야 하는 경우는 매우 드뭅니다.

자동 동기화는 대부분의 경우를 포함해야 한다.

사용자가 수동 동기화를 시작해야 하는 경우, 계정을 인증해야 합니다.

이러한 이유로, 당신은 사용자 입력에 대한 응답으로만 이 API를 사용해야 합니다.

마지막으로, StoreKit 2 API를 사용하여 이루어진 모든 거래는 원래 StoreKit API에서 사용할 수 있으며, 그 반대의 경우도 마찬가지입니다.

따라서 앱에 기존 거래가 있는 경우, 사용하기 시작하자마자 StoreKit 2 API에서 볼 수 있습니다.

원래 StoreKit API로 이루어진 새로운 구매는 StoreKit 2 API를 통해 즉시 사용할 수 있으며, StoreKit 2로 이루어진 구매는 새로 고침 시 통합 영수증 내에서도 사용할 수 있습니다.

거래 내역 외에도, StoreKit 2는 사용자의 구독 상태에 대한 자세한 정보를 얻을 수 있는 방법을 추가하고 있습니다.

구독 상태는 세 부분으로 구성되어 있다.

첫 번째는 최신 거래이다.

이를 통해 이 구독에 대해 발생한 마지막 거래에 편리하게 액세스할 수 있으며, 이전에 이야기한 최신 거래에 전화한 것과 같습니다.

두 번째는 갱신 상태이다.

이것은 구독의 현재 상태를 알려주는 열거형입니다.

지금 구독에 무슨 일이 일어나고 있는지 알고 싶다면, 이 값을 보세요.

현재 구독, 만료, 유예 기간 등이 있는지 등을 알려줄 것입니다.

우리는 이 값에서 앱 로직을 쉽게 기반으로 할 수 있도록 볼 수 있는 단일 장소를 제공하도록 설계했습니다.

그리고 구독 상태의 마지막 부분은 갱신 정보입니다.

여기에서 사용자의 구독에 대한 모든 세부 사항을 볼 수 있습니다.

이 데이터는 거래 없이 실제로 변경될 수 있기 때문에 거래 정보에 없는 모든 종류의 정보가 포함되어 있습니다.

예를 들어, 갱신 정보에서 사용자가 이 구독에 대해 자동 갱신을 켜거나 껐는지 알려주는 자동 갱신 상태를 찾을 수 있습니다.

자동 갱신이 설정된 제품 ID도 볼 수 있습니다.

따라서 사용자가 최근에 구독을 다운그레이드했다면, 바로 여기에서 볼 수 있으며, 더 높은 계층에 머무를 수 있는 윈백 제안을 제시할 수 있는 기회로 사용할 수 있습니다.

구독이 이미 만료된 경우, 갱신 정보를 사용하여 만료 이유를 확인할 수 있습니다.

그리고 전체 갱신 정보에는 이 모든 데이터와 더 많은 것, 그리고 또 다른 중요한 기능이 있습니다.

맞습니다, 암호화 애호가 여러분, 갱신 정보는 JWS를 사용하여 서명됩니다!

거래 정보와 마찬가지로, 갱신 정보는 서비스를 잠금 해제하고 마케팅 결정을 내리는 데 중요한 부분입니다.

그래서 우리는 당신에게 그것이 유효하고 애플에서 직접 온 것이라는 확신을 주고 있습니다.

그리고, 지금 당신의 머릿속을 맴돌고 있는 질문에 답하기 위해, 네, StoreKit 2는 자동으로 갱신 정보를 검증할 것입니다.

구독 상태 API에 대해 알아야 할 마지막 한 가지는 상태 배열을 반환한다는 것입니다.

이것은 어떤 경우에는 사용자가 같은 제품에 대해 여러 구독을 할 수 있기 때문이다.

예를 들어, 사용자는 제품을 구독한 다음, 가족 공유를 통해 구독을 받을 수도 있습니다.

그들이 받을 수 있는 최고 수준의 서비스가 무엇인지 확인하기 위해 배열을 확인해야 합니다.

이제 앱 코드에서 이러한 거래 내역과 구독 상태 API로 작업하는 것이 어떻게 생겼는지 보여주기 위해 Jakob에게 돌려드리겠습니다.

제이콥: 고마워, 로스.

내가 작업하고 있던 앱으로 돌아가서 Ross가 방금 말한 새로운 거래 내역과 구독 상태 API를 사용하도록 업데이트합시다.

당신은 내가 이전에 구매한 오토바이에 녹색 체크가 없다는 것을 알게 될 것이고, 내가 가게 전망에서 벗어난 후, 표준 5인승에도 녹색 체크가 없다는 것을 알게 될 것이다.

사용자로서, 나는 내가 이미 무엇을 구매했는지 말할 수 없다.

이것은 StoreKit 2로 쉽게 해결할 수 있는 문제입니다.

언제든지, 내 앱은 어떤 제품을 구매했는지 StoreKit을 쿼리할 수 있으므로 앱의 UI를 항상 최신 상태로 유지할 수 있습니다.

내 Store.swift 파일에서 isPurchased 메소드는 현재 false만 반환합니다.

Transaction.latest(for:)에 대한 간단한 호출로 그것을 해결합시다.

그런 다음 가장 최근의 거래를 얻기 위해 내 제품 식별자를 전달하세요.

이 StoreKit 방법은 거래가 StoreKit 2의 확인 확인을 통과했음을 알려주는 또 다른 확인 결과를 반환합니다.

거래가 확인되었는지 확인하고 이전에 작성한 checkVerified 방법을 사용하여 포장을 해제하겠습니다.

그런 다음, 내 앱이 revocationDate가 nil과 같은지 확인하여 환불된 거래에 대한 콘텐츠를 제공하지 않도록 할 것입니다.

또한, 고객이 기간 중반에 더 높은 수준의 서비스로 업그레이드한 구독은 isUpgraded 플래그를 true로 설정합니다.

내 앱이 고객이 구독한 최고 수준의 서비스를 제공하고 있는지 확인하고 싶기 때문에, isPurchased 방법은 업그레이드된 거래를 무시해야 합니다.

구독 제품의 경우, 거래 유형은 이야기의 일부만 알려줍니다.

거래 날짜와 구독 만료일 외에도, 다음 갱신일이 언제인지, 고객이 구독에 대한 자동 갱신을 껐는지 또는 다음 갱신 기간이 구독한 서비스 수준을 변경할지 알고 싶습니다.

이 모든 정보를 얻기 위해, StoreKit 2는 구독 상태 API를 제공합니다.

내 SubscriptionsView.swift 파일에서 updateSubscriptionStatus 방법은 StoreKit에서 구독 상태를 얻고 사용자에게 표시하는 역할을 합니다.

내 모든 구독 제품이 같은 그룹에 속하기 때문에, 나는 그 중 하나를 사용하여 그룹의 현재 상태를 얻을 수 있다.

난 그냥 가게에서 첫 번째 구독 제품을 선택할 거야.

일단 제품을 갖게 되면, 구독에서 상태 속성을 얻을 수 있습니다.

그렇게 쉬워.

로스가 언급했듯이, 사용자는 가족 구성원이 구독을 공유하는 동안 자신의 개인 구독 비용을 지불할 수 있다.

따라서 상태 속성은 각 구독의 모든 상태를 포함하는 배열을 반환합니다.

이제, 그들은 개인적으로 프로 티어를 구독하는 동안 표준 티어를 공유할 수 있다.

나는 내 사용자가 접근할 수 있는 최고 수준의 서비스를 받을 수 있는지 확인하고 싶기 때문에, 각 상태를 반복할 것이다.

다음으로, 상태가 만료되었거나 취소되었는지 확인하겠습니다.

나는 이 사건들을 무시하고 사용자에게 아무것도 표시하지 않고 싶다.

다른 모든 경우, 나는 renewalInfo를 받고 내 가게에서 checkVerified 방법을 사용하여 확인되었는지 확인할 것이다.

갱신정보가 확인되면, 서비스 수준을 이전 제품과 비교할 것입니다.

이 수표는 구독 상태에 대한 해당 제품을 받은 다음, 이전 제품과 비교되며, 더 높은 계층인 경우, 새 구독에 가장 높은 상태와 가장 높은 제품을 설정합니다.

내 모든 상태를 확인하고 최고 수준의 서비스를 결정하면, 내 견해의 상태와 현재 구독을 설정할 것이다.

지금 만들고 달리자.

내 가게 보기에서, 내가 이전에 구매한 제품들은 이제 내가 이미 그것들을 소유하고 있고 다시 살 필요가 없다는 것을 나타내는 녹색 체크 표시를 보여준다.

구독 제품 중 하나를 구매하면 어떻게 되는지 봅시다.

구매를 확인한 후, 상태가 내 가게에 바로 표시됩니다.

StoreKit 2에 내장된 API를 사용하여 사용자가 무엇을 구독하고 언제 구독을 갱신할지 알릴 수 있습니다.

이제 이 내 차 보기는 어때?

그것은 내가 구매한 모든 제품을 보여줘야 하지만, 지금은 비어 있다.

이것을 채우기 위해, 나는 내 모든 제품을 반복한 다음, 각각에 대한 최신 거래를 얻고, 거래의 만료일과 환불되었는지 여부를 확인할 수 있지만, 그것은 많은 것처럼 들린다.

고맙게도, 저는 StoreKit 2의 힘과 새롭고 간단하고 편리한 API를 사용하여 currentEntitlements라고 불리는 모든 사용자의 유효한 거래를 얻을 수 있습니다.

내 자동차 보기에서, 보기가 로드될 때 구매한 제품을 새로 고치는 이 방법이 있습니다.

거래 업데이트와 마찬가지로, 나는 현재 자격을 반복한다.

그러나 거래 업데이트와 달리, 현재 자격의 비동기 시퀀스는 유한하므로 루프에서 영원히 기다리지 않을 것이며, 사용자가 더 많은 구매를 할 때 새로운 자격을 제공합니다.

각 자격에 대해, 저는 다른 모든 거래와 마찬가지로 확인 결과를 확인하고 싶습니다.

그들이 확인되면, 원래 제품 요청과 마찬가지로 productType 속성을 전환하여 자격을 다른 배열로 필터링할 것입니다.

현재 자격은 비소모성 및 자동 재생 제품에 대한 거래만 반환합니다.

스위치 문을 완료하고 스위프트 컴파일러를 행복하게 유지하기 위해 다른 제품 유형을 무시할 수 있습니다.

거래를 하고 나면, 관련 제품을 UI에 표시해야 합니다.

비소모성 거래의 경우, 이 거래와 일치하는 제품 식별자를 찾기 위해 자동차 제품 배열을 검색할 것입니다.

그리고 마찬가지로, 나는 자동 갱신 거래와 일치하도록 구독 제품 배열을 검색할 것이다.

다시 실행해서 내 UI를 확인해 보자.

이제, 내 차 보기에 들어가면, 내가 구매한 모든 것을 볼 수 있다.

내 모든 차는 상단에 함께 그룹화되어 있고 내 구독은 아래에 있다.

이제 내 앱에는 완전히 작동하는 상점이 있고 멋져 보여!

그리고 그것이 거래 내역과 구독 상태 API를 사용하여 앱에서 사용자가 보는 UI에 대한 정보에 입각한 결정을 내릴 수 있는 방법입니다.

이제 JSON 웹 서명 객체에 대해 더 깊이 이야기할 로스에게 돌아가 봅시다.

로스: 환상적인 데모에 다시 한 번 감사드립니다, 제이콥.

새로운 거래와 구독 API가 어떻게 유용한지 알 수 있습니다.

이제 StoreKit 2가 보안을 위해 JWS를 사용하는 두 가지 방법을 보았으므로, 자세히 살펴보고 자신의 검증을 수행하는 방법을 약속했습니다.

JSON 웹 서명은 세 부분으로 구성되어 있다.

첫 번째는 객체에 대한 메타데이터를 포함하는 헤더이다.

여기에는 서명에 사용되는 알고리즘과 서명을 검증하는 데 사용되는 인증서를 찾을 수 있는 위치와 같은 중요한 정보가 포함되어 있습니다.

StoreKit 2는 현재 CryptoKit과 함께 Swift에서 기본적으로 지원되는 ECDSA 알고리즘을 사용합니다.

인증서의 경우, StoreKit 2는 x5c 헤더를 사용하며, 이는 전체 인증서 체인이 JWS 데이터에 포함되어 있음을 나타냅니다.

이것은 이러한 JWS 서명을 검증하기 위해 인터넷 연결이 필요하지 않다는 것을 의미합니다.

JWS 데이터의 다음 부분은 페이로드이다.

이것은 거래 ID, 제품 ID, 구매일 등과 같은 주요 정보입니다.

서명을 확인하면, 거래나 구독에 대해 알고 싶은 모든 데이터를 읽을 수 있습니다.

그리고 JWS 데이터의 마지막 부분은 서명 그 자체이다.

이것은 헤더와 페이로드를 모두 사용하여 생성됩니다.

JWS 서명을 검증하는 것은 표준의 잘 문서화된 부분이므로, 자신의 구현을 작성하는 데 관심이 있다면 원본 소스로 바로 가는 것이 좋습니다.

이 세션과 관련된 자료에 이 문서에 대한 링크를 포함시켰습니다.

JWS 데이터에서 서명을 검증하면, 서명된 정보가 앱과 현재 장치에 유효한지 확인하기 위해 해야 할 일이 몇 가지 더 있습니다.

먼저, 서명된 정보 페이로드에 있는 번들 ID가 앱의 번들 ID와 일치하는지 확인해야 합니다.

보안을 강화하기 위해 API 호출에 의존하지 않고 앱의 번들 ID를 앱 어딘가에 삽입하고 그 값을 사용하여 페이로드의 번들 ID와 비교하는 것이 좋습니다.

그리고 당신이 해야 할 마지막 일은 장치 유효성 검사를 수행하는 것입니다.

이것은 서명된 정보가 현재 켜져 있는 장치에 대해 실제로 생성되었다는 것을 보장합니다.

StoreKit 2 API AppStore.deviceVerificationID를 사용하여 현재 장치 확인 식별자를 검색하십시오.

그런 다음, 서명된 정보에서 장치 인증 논스를 취하고 StoreKit에서 방금 받은 장치 인증 식별자를 추가하십시오.

이 값에 대해 SHA384 해시를 수행하고 서명된 정보의 장치 확인 필드와 결과를 비교하십시오.

그들이 일치한다면, 이 장치에 대해 서명된 정보가 생성되었고 서명된 정보 유효성 검사가 완료되었습니다.

마지막으로 주목해야 할 한 가지는 이 새로운 JWS 객체가 인앱 구매만을 위한 것이라는 것이다.

따라서 앱 영수증을 확인해야 하는 경우, 기존 API와 프로세스를 사용해야 합니다.

그리고 물론, 우리는 이러한 새로운 JWS 객체를 위한 새로운 App Store 서버 API를 제공하고 있으므로, 서버에서 직접 검색하고 검증할 수 있습니다.

음, 우리가 오늘 당신에게 소개했던 것처럼 StoreKit 2를 만나게 되어 기뻤기를 바랍니다.

StoreKit 2는 더 많은 정보를 제공하고 그 어느 때보다 쉽게 사용할 수 있는 새로운 API로 인앱 구매를 더욱 개선하고 있습니다.

여기에는 각 거래에 대한 새로운 JSON 기반 정보 객체와 네이티브 코드에서 거래 세부 사항과 과거 거래 데이터를 제공하는 API가 포함됩니다.

그것을 새로운 구독 상태 API와 결합하면, StoreKit 2는 인앱 구매를 위한 풍부한 가능성을 열어줍니다.

인앱 구매에 대해 더 자세히 알아보려면, 서버 측 코딩 및 고객 지원을 위한 다른 세션을 시청하는 것이 좋습니다.

제이콥과 저는 당신에게 StoreKit 2를 소개할 수 있어서 기쁩니다.

WWDC21에 참여해 주셔서 감사합니다!

♪