10022

♪ 베이스 음악 연주 ♪

♪

Matt Ricketson: 안녕하세요, 저는 Matt이고, 나중에 Luca와 Raj와 합류할 것입니다.

오늘, 우리는 SwiftUI를 신비화할 것이다.

이제, 우리는 SwiftUI가 선언적 UI 프레임워크라는 것을 여러 번 들었다.

그것은 당신이 앱에서 원하는 것을 높은 수준으로 설명하고, SwiftUI가 그것을 실현하는 방법을 정확히 결정한다는 것을 의미합니다.

이제, 대부분의 경우, 이것은 잘 작동한다!

그리고 그것이 SwiftUI가 마법처럼 느껴질 때이다.

하지만 SwiftUI가 당신이 기대하지 않을 수도 있는 일을 하는 순간이 항상 있을 것입니다.

그리고 그 순간에, 당신이 찾고 있는 결과를 얻는 방법에 대한 더 나은 직관을 구축하기 위해 SwiftUI가 무대 뒤에서 무엇을 하고 있는지에 대해 조금 더 이해하는 데 도움이 됩니다.

그래서 오늘의 질문은, SwiftUI가 당신의 코드를 볼 때, 무엇을 보나요?

답은 세 가지이다: 정체성, 수명, 그리고 의존성.

신원은 SwiftUI가 앱의 여러 업데이트에서 동일하거나 뚜렷한 요소로 인식하는 방법입니다.

평생은 SwiftUI가 시간이 지남에 따라 뷰와 데이터의 존재를 추적하는 방법입니다.

그리고 종속성은 SwiftUI가 인터페이스를 업데이트해야 할 때와 그 이유를 이해하는 방법입니다.

이 세 가지 개념은 SwiftUI가 무엇을 어떻게, 어떻게, 언제 변경해야 하는지 결정하는지 알려주며, 그 결과 화면에서 볼 수 있는 동적 사용자 인터페이스가 탄생합니다.

오늘, 우리는 이 세 가지 개념 각각에 대해 더 깊이 이야기할 것이다.

정체성부터 시작하자, 그리고 여기 나를 도와줄 친구들이 몇 명 있어.

이 루비 스패니얼은 사랑스럽지만, 깊은 철학적 질문의 주제이기도 하다.

이 두 개는 다른 개인가요?

아니면 이것들은, 사실, 같은 개의 두 장의 사진인가요?

진실은, 말할 수 없다는 거야!

우리는 단지 충분한 정보를 가지고 있지 않다.

하지만 상황이 같은지 다른지에 대한 이 질문은 우리가 "정체성"이라고 부르는 것의 핵심이다.

하지만 정체성은 개에게만 중요한 것이 아니다.

그것은 또한 SwiftUI가 당신의 앱을 어떻게 이해하는지에 대한 중요한 측면이기도 합니다.

예를 들어 봅시다.

이것은 내가 만든 "Good Dog, Bad Dog"라는 앱으로, 내 털복숭이 친구가 최선의 행동을 했는지 추적하는 데 도움을 준다.

그건 꽤 간단해.

화면의 아무 곳이나 탭하여 좋은 상태와 나쁜 상태 사이를 전환할 수 있습니다.

그래서 정체성이 내 앱과 무슨 상관이야?

음, 그건 사실 우리가 방금 개들에 대해 물어본 철학적 질문과 매우 비슷해.

그 아이콘들을 보면, 그것들은 서로 완전히 다른 두 가지 견해처럼 보이나요?

아니면 다른 장소에서 다른 색으로 같은 전망이 될 수 있을까요?

그 구별은 실제로 매우 중요하다. 왜냐하면 그것은 우리의 인터페이스가 한 상태에서 다른 상태로 전환하는 방식을 변화시키기 때문이다.

그 아이콘들이, 사실, 다른 견해라고 가정해 봅시다.

그것은 아이콘이 퇴색하는 것과 같이 독립적으로 전환되어야 한다는 것을 의미한다.

하지만 만약 그들이, 사실, 같은 견해라면 어떨까요?

그것은 대신 한 위치에서 다른 위치로 이동하는 것과 동일한 보기이기 때문에 전환 중에 보기가 화면을 가로질러 미끄러져야 한다는 것을 의미합니다.

따라서 다른 주에 걸쳐 뷰를 연결하는 것이 중요합니다. 왜냐하면 그것이 SwiftUI가 그들 사이를 전환하는 방법을 이해하는 방법이기 때문입니다.

이것은 관점 정체성의 핵심 개념이다.

동일한 정체성을 공유하는 견해는 동일한 개념적 UI 요소의 다른 상태를 나타낸다.

대조적으로, 뚜렷한 UI 요소를 나타내는 견해는 항상 다른 정체성을 가질 것이다.

나중에, Luca와 Raj는 앱의 데이터와 업데이트 주기에 대한 뷰 아이덴티티의 실질적인 영향에 대해 이야기할 것입니다.

지금은 SwiftUI가 사용하는 두 가지 유형의 신원에 초점을 맞춰 코드에서 신원이 어떻게 표시되는지 살펴봅시다.

첫째, 명시적인 신원: 사용자 지정 또는 데이터 기반 식별자 사용.

그리고 둘째, 구조적 정체성: 뷰 계층 구조에서 유형과 위치에 따라 뷰를 구별하는 것.

이제, 이 개념들을 이해하는 데 도움을 주기 위해, 제 친구들을 좀 더 소개해 드리겠습니다.

좋아, 개를 구별하는 것은 어려울 수 있다는 것을 기억해, 특히 그들이 똑같아 보일 때.

그래서 어떤 종류의 추가 정보가 우리 개를 식별하는 데 도움이 될까요?

한 가지 방법은 단순히 그들의 이름을 묻는 것이다.

만약 두 마리의 개가 똑같아 보이고 같은 이름을 공유한다면, 나는 그들이 사실 같은 개일 가능성이 꽤 높다고 말하고 싶다.

하지만 그들이 다른 이름을 가지고 있다면, 우리는 그들이 사실 다른 개라는 것을 보장할 수 있다.

이와 같은 이름이나 식별자를 할당하는 것은 명시적인 정체성의 한 형태이다.

명시적인 정체성은 강력하고 유연하지만, 누군가가 어딘가에서 그 모든 이름을 추적해야 한다.

이미 사용할 수 있는 명시적 정체성의 한 형태는 UIKit과 AppKit에서 사용되는 포인터 정체성입니다.

이제 SwiftUI는 포인터 ID를 사용하지 않지만, 그것에 대해 배우면 SwiftUI가 어떻게 그리고 왜 다르게 작동하는지 더 잘 이해하는 데 도움이 될 것입니다.

잠깐 살펴봅시다.

이와 같은 UIKit 또는 AppKit 뷰 계층 구조를 고려하십시오.

UIViews와 NSViews는 클래스이기 때문에, 그들은 각각 메모리 할당에 대한 고유한 포인터를 가지고 있다.

포인터는 명백한 정체성의 자연스러운 원천이다.

우리는 포인터를 사용하여 개별 뷰를 참조할 수 있으며, 두 뷰가 같은 포인터를 공유한다면, 우리는 그들이 실제로 같은 뷰임을 보장할 수 있습니다.

하지만 SwiftUI는 SwiftUI 뷰가 일반적으로 클래스 대신 구조체로 표시되는 값 유형이기 때문에 포인터를 사용하지 않습니다.

2019년의 "SwiftUI 필수" 강연에서, 우리는 SwiftUI가 보기를 위해 클래스 대신 값 유형을 사용하는 이유에 대해 논의했기 때문에, 더 많은 것을 배우기 위해 그 강연을 보는 것이 좋습니다.

현재로서는, 알아야 할 중요한 점은 값 유형에는 SwiftUI가 뷰에 대한 지속적인 ID로 사용할 수 있는 표준 참조가 없다는 것입니다.

대신, SwiftUI는 다른 형태의 명시적인 정체성에 의존한다.

예를 들어, 이 구조견 목록을 고려해 보세요.

여기에 사용된 id 매개 변수는 명시적인 정체성의 한 형태이다.

각 구조견의 개 태그 ID는 목록에서 해당 보기를 명시적으로 식별하는 데 사용됩니다.

구조견 컬렉션이 변경되면, SwiftUI는 해당 ID를 사용하여 무엇이 정확히 변경되었는지 이해하고 목록 내에서 올바른 애니메이션을 생성할 수 있습니다.

이 경우, SwiftUI는 다른 섹션 사이를 이동하는 뷰를 올바르게 애니메이션화할 수 있었다.

좀 더 발전된 예시를 살펴봅시다.

여기서, 우리는 ScrollViewReader를 사용하여 하단의 버튼을 사용하여 보기의 맨 위로 이동하고 있습니다.

Id(_:) 수정자는 사용자 지정 식별자를 사용하여 뷰를 명시적으로 식별하는 방법을 제공합니다. 이 경우 페이지 상단의 헤더 뷰입니다.

그런 다음 그 식별자를 스크롤 뷰 프록시의 scrollTo(_:) 메소드에 전달하여 SwiftUI에 특정 뷰로 이동하라고 말할 수 있습니다.

이것의 좋은 점은 헤더 텍스트와 같이 코드의 다른 곳에서 참조해야 하는 모든 보기를 명시적으로 식별할 필요가 없다는 것입니다.

이에 비해, ScrollViewReader, ScrollView, backstory Text 및 Bbutton은 명시적인 식별자가 필요하지 않습니다.

하지만 그들의 정체성이 노골적이지 않기 때문에, 그것이 노골적이지 않더라도 모든 견해에 정체성이 있기 때문에 이러한 견해가 전혀 정체성이 없다는 것을 의미하지는 않습니다.

이것이 구조적 정체성이 들어오는 곳이다.

SwiftUI는 뷰 계층 구조의 구조를 사용하여 뷰에 대한 암시적 ID를 생성하므로 그럴 필요가 없습니다.

이제, 내가 무슨 뜻인지 설명할 수 있도록 내 친구들을 좀 더 데려올게.

우리가 비슷한 두 마리의 개를 가지고 있지만 그들의 이름을 모르지만, 우리는 여전히 각각을 식별해야 한다고 가정해 봅시다.

음, 이것들이 아주 좋은 개들이고 아주 가만히 앉아 있을 수 있다고 가정해 보자.

만약 우리가 그들이 움직이지 않는다고 보장할 수 있다면, 우리는 "왼쪽에 있는 개" 또는 "오른쪽에 있는 개"와 같이 그들이 앉아 있는 위치에 따라 그들을 식별할 수 있다.

우리는 그것들을 서로 구별하기 위해 주제의 상대적인 배열을 사용하고 있다 - 그것은 구조적 정체성이다.

SwiftUI는 API 전반에 걸쳐 구조적 정체성을 활용하며, 고전적인 예는 보기 코드 내에서 if 문과 기타 조건부 논리를 사용할 때입니다.

조건부 진술의 구조는 우리에게 각 견해를 식별할 수 있는 명확한 방법을 제공한다.

첫 번째 보기는 조건이 참일 때만 표시되는 반면, 두 번째 보기는 조건이 거짓일 때만 표시됩니다.

그것은 비록 그들이 비슷하게 보이더라도, 우리는 항상 어떤 견해가 어떤 견해인지 알 수 있다는 것을 의미한다.

그러나, 이것은 SwiftUI가 이러한 뷰가 있는 곳에 머물고 장소를 바꾸지 않도록 정적으로 보장할 수 있는 경우에만 작동합니다.

SwiftUI는 뷰 계층 구조의 유형 구조를 보고 이를 수행합니다.

SwiftUI가 당신의 견해를 볼 때, 그것은 그들의 일반적인 유형을 봅니다 - 이 경우, 우리의 if 문은 참과 거짓 콘텐츠에 대한 일반적인 _ConditionalContent 보기로 번역됩니다.

이 번역은 Swift의 결과 빌더 유형인 ViewBuilder에 의해 구동됩니다.

View 프로토콜은 우리 속성의 논리 문에서 단일 일반 뷰를 구성하는 ViewBuilder에서 본문 속성을 암시적으로 래핑합니다.

우리 몸 속성의 일부 보기 반환 유형은 이 정적 복합 유형을 나타내는 자리 표시자이며, 코드를 어지럽히지 않도록 숨깁니다.

이 일반 유형을 사용하여 SwiftUI는 실제 보기가 항상 AdoptionDirectory인 반면, False 보기는 항상 DogList가 되어 무대 뒤에서 암시적이고 안정적인 신원을 할당할 수 있도록 보장할 수 있습니다.

사실, 이것은 이전의 Good Dog, Bad Dog 앱을 이해하는 열쇠이다.

상단의 코드로, 우리는 각 조건부 브랜치에 대해 다른 견해를 정의하는 if 문이 있습니다.

SwiftUI는 if 문의 각 브랜치가 뚜렷한 정체성을 가진 다른 견해를 나타낸다는 것을 이해하기 때문에 견해가 전환될 것이다.

또는, 우리는 레이아웃과 색상을 변경하는 하나의 PawView를 가질 수 있습니다.

그것이 다른 상태로 전환되면, 시야는 다음 위치로 부드럽게 미끄러질 것이다.

그것은 우리가 일관된 정체성으로 단일 뷰를 수정하고 있기 때문이다.

이 두 전략 모두 효과가 있을 수 있지만, SwiftUI는 일반적으로 두 번째 접근 방식을 권장합니다.

기본적으로, 정체성을 보존하고 더 유동적인 전환을 제공하려고 노력하세요.

이것은 또한 루카가 나중에 더 자세히 이야기할 당신의 견해의 수명과 상태를 보존하는 데 도움이 됩니다.

이제 우리는 구조적 정체성을 이해했으므로, 우리는 그것의 사악한 천적인 AnyView에 대해 이야기할 필요가 있다.

AnyView 사용의 영향을 이해하기 위해, 그것이 당신의 견해 구조에 미치는 영향을 살펴봅시다.

이전에 우리는 AdoptionDirectory와 DogList 사이를 전환하기 위해 이 진술을 썼다.

SwiftUI가 이 코드를 볼 때, 오른쪽에 일반 유형 구조가 보인다.

이제 AnyView를 광범위하게 사용하는 다른 예를 살펴봅시다.

이것은 내가 개의 품종을 나타내는 견해를 얻기 위해 쓴 도우미 기능이다.

함수의 각 조건부 브랜치는 다른 종류의 뷰를 반환하므로, Swift는 전체 함수에 대해 단일 반환 유형이 필요하기 때문에 AnyViews로 모두 래핑했습니다.

불행히도, 이것은 또한 SwiftUI가 내 코드의 조건부 구조를 볼 수 없다는 것을 의미한다.

대신, 그것은 AnyView를 함수의 반환 유형으로 본다.

이것은 AnyView가 "유형 지우기 래퍼 유형"이라고 불리기 때문입니다. 일반 서명에서 래핑하는 뷰의 유형을 숨깁니다.

하지만 아마도 더 중요한 것은, 이 코드는 단순한 인간에게도 읽기가 정말 어렵다는 것이다.

이 코드를 단순화하고 SwiftUI에서 더 많은 구조를 볼 수 있는지 봅시다.

첫째, 이 지점은 근처에 양이 있다면 BorderCollieView와 함께 SheepView를 조건부로 추가하는 것처럼 보인다.

우리는 우리의 뷰 주위에 HStack을 조건부로 추가하는 대신 HStack 내부의 뷰를 조건부로 추가하여 이것을 단순화할 수 있습니다.

그 변화로, 이제 우리가 각 지점에서 단일 보기를 반환하고 있다는 것을 쉽게 알 수 있으므로, 우리의 로컬 dogView 변수는 필요하지 않습니다.

대신, 우리는 그것을 각 지점 내부의 반환 문으로 대체할 수 있다.

앞서 보았듯이, 일반 SwiftUI View 코드는 다른 유형의 뷰를 반환하는 if 문을 사용할 수 있습니다.

하지만 코드에서 반환 문과 AnyViews를 삭제하려고 하면 몇 가지 오류와 경고가 나타납니다.

이것은 SwiftUI가 도우미 함수의 단일 반환 유형을 필요로 하기 때문입니다.

그렇다면 우리는 어떻게 이러한 오류를 피할 수 있을까요?

뷰 프로토콜이 암시적으로 뷰빌더로 감싸기 때문에 뷰의 본문 속성이 특별하다는 것을 기억하세요.

이것은 속성의 논리를 하나의 일반적인 뷰 구조로 변환한다.

이제 Swift는 도우미 함수를 기본적으로 뷰 빌더로 추론하지 않지만, ViewBuilder 속성을 수동으로 적용하여 선택할 수 있습니다.

그리고 그것은 우리가 경고나 오류 없이 반환 진술과 AnyView 래퍼를 제거할 수 있게 해준다.

좋아, 우리 코드는 지금 꽤 좋아 보여!

우리는 모든 AnyViews를 제거하여 이전보다 더 쉽게 읽을 수 있게 만들었습니다.

그리고 결과의 유형 서명을 보면, 이제 조건부 콘텐츠 트리로 함수의 조건부 논리를 정확히 복제하여 SwiftUI에 보기와 구성 요소의 ID에 대한 훨씬 더 풍부한 관점을 제공합니다.

하지만 우리가 할 수 있는 작은 개선이 하나 더 있다.

우리 기능의 최상위 수준은 개 품종의 다른 사례와 일치한다.

이것은 뷰 빌더가 지원하는 스위치 문에 대한 훌륭한 사용 사례처럼 보인다.

이제 우리 관점의 모든 다른 사례를 빠르게 이해하는 것이 훨씬 더 쉬워졌다.

그리고 스위치 문은 실제로 조건부 문에 대한 구문 설탕이기 때문에, 오른쪽에 있는 결과 보기의 유형 서명은 정확히 동일하게 유지됩니다.

뒤로 물러서서, 우리는 방금 AnyViews가 코드에서 유형 정보를 지우는 방법을 보여주었고, 뷰 빌더를 활용하여 불필요한 AnyViews를 제거하는 방법을 살펴보았습니다.

일반적으로, 우리는 가능할 때마다 AnyViews를 피하는 것이 좋습니다.

AnyViews가 너무 많으면 종종 코드를 읽고 이해하기가 더 어려워질 것이다.

If/else 및 switch와 같은 전통적인 제어 흐름 문은 보기의 다른 가능한 상태를 훨씬 쉽게 볼 수 있게 해준다.

그리고 AnyView는 컴파일러에서 정적 유형 정보를 숨기기 때문에, 때때로 유용한 진단 오류와 경고가 코드에 나타나는 것을 방지할 수 있습니다.

마지막으로, 그럴 필요가 없을 때 AnyView를 사용하면 성능이 더 나빠질 수 있다는 것을 명심하세요.

가능한 경우, 코드 주변에 AnyViews를 전달하는 대신 정적 유형 정보를 보존하기 위해 제네릭을 사용하세요.

그리고 그것으로, 우리는 SwiftUI에서 기본 유형의 뷰 ID를 도입하는 것을 마쳤습니다.

명시적인 신원을 통해, 우리는 우리의 견해의 신원을 데이터와 연결하거나, 특정 견해를 참조하기 위해 사용자 지정 식별자를 제공할 수 있습니다.

그리고 구조적 정체성을 통해, 우리는 SwiftUI가 뷰 계층 구조 내의 유형과 위치에 따라 우리의 견해를 식별할 수 있는 방법을 배웠습니다.

그리고 이제 나는 당신의 견해의 정체성이 그들의 삶과 상태와 어떻게 관련되어 있는지 논의하기 위해 루카에게 물건을 넘겨줄 것이다.

루카 베르나르디: 고마워, 매트.

이제 SwiftUI가 당신의 견해를 어떻게 식별하는지 이해했으므로, 신원이 당신의 견해와 데이터의 수명과 어떻게 연결되는지 살펴봅시다.

이것은 SwiftUI가 어떻게 작동하는지 더 잘 이해하는 데 도움이 될 것입니다.

이것을 설명하기 위해, 나는 또한 친구를 데려올 것이다.

이건 테세우스야.

그도 사랑스럽지 않아?

누군가는 더 사랑스럽다고 말하겠지만, 나는 탈선한다.

우리가 가장 좋아하는 애완동물의 이름을 지으면, 그가 다른 주에 있고 하루 종일 움직일 때에도 항상 같은 사랑스러운 고양이가 될 것이라고 생각하는 것은 매우 직관적이다.

우리가 그를 한 순간 볼 때, 그는 졸릴 수도 있고 잠시 후, 적절한 고양이가 되면, 그는 내 존재에 짜증이 난다 - 하지만 그는 항상 테세우스일 것이다.

이것이 정체성을 평생에 연결하는 본질이다.

정체성은 우리가 시간이 지남에 따라 다른 가치에 대한 안정적인 요소를 정의할 수 있게 해준다.

다시 말해서, 그것은 우리가 시간이 지남에 따라 연속성을 도입할 수 있게 해준다.

이것이 SwiftUI에 어떻게 적용되는지 궁금하시겠지만요?

그래서 매트가 작업하고 있던 앱의 고양이 친화적인 버전을 다시 가져오자.

테세우스가 다른 순간에 다른 주에 있을 수 있는 것처럼, 우리의 견해는 평생 동안 다른 주에 있다.

모든 주는 우리의 관점에서 다른 가치이다.

정체성은 시간이 지남에 따라 이러한 다른 가치를 단일 엔티티(보기)로 연결한다.

이것을 명확히 하기 위해 몇 가지 코드를 살펴봅시다.

여기서 우리는 가르랑거리는 강도를 보여주는 간단한 견해를 가지고 있다.

스포일러: 테세우스는 꽤 시끄러워.

신체 평가를 통해, SwiftUI는 이 관점에 대한 새로운 가치를 창출할 것이다; 이 경우, 강도 값은 25이다.

테세우스는 배고프고 더 많은 관심을 원한다.

본문은 더 높은 강도로 다시 호출되며, 뷰에 대한 새로운 값이 생성됩니다.

이것들은 같은 관점의 정의에서 만들어진 두 가지 뚜렷한 값이다.

SwiftUI는 비교를 수행하고 보기가 변경되었는지 알기 위해 값의 복사본을 유지할 것이다.

하지만 그 후에, 그 가치는 파괴된다.

여기서 이해하는 것이 중요한 것은 뷰 값이 뷰 아이덴티티와 다르다는 것이다.

보기 값은 일시적이며 그들의 수명에 의존해서는 안 됩니다.

하지만 당신이 통제할 수 있는 것은 그들의 정체성이다.

뷰가 처음 생성되고 나타나면, SwiftUI는 이전에 논의된 기술의 조합을 사용하여 ID를 할당합니다.

시간이 지남에 따라, 업데이트에 의해, 뷰에 대한 새로운 값이 생성된다.

하지만 SwiftUI의 관점에서 볼 때, 이것들은 같은 견해를 나타낸다.

뷰의 신원이 변경되거나 뷰가 제거되면, 수명이 끝납니다.

우리가 견해의 수명에 대해 이야기할 때마다, 우리는 그 견해와 관련된 정체성의 기간을 언급하고 있다.

뷰의 정체성을 수명과 연결할 수 있다는 것은 SwiftUI가 당신의 상태를 어떻게 유지하는지 이해하는 데 기본입니다.

그러니 State와 StateObject를 그림으로 가져오자.

SwiftUI가 당신의 뷰를 보고 State 또는 StateObject를 볼 때, 뷰의 수명 동안 그 데이터를 유지해야 한다는 것을 알고 있습니다.

즉, State와 StateObject는 뷰의 ID와 관련된 영구 저장소입니다.

뷰의 ID가 시작될 때, 처음 생성되었을 때, SwiftUI는 초기 값을 사용하여 State와 StateObject에 대한 메모리의 저장소를 할당할 것이다.

여기서 우리는 타이틀 상태에 초점을 맞추고 있다.

뷰의 수명 동안, SwiftUI는 변이되고 뷰의 본문이 재평가됨에 따라 이 스토리지를 유지할 것이다.

정체성의 변화가 국가의 지속성에 어떤 영향을 미치는지에 대한 구체적인 예를 살펴봅시다.

이것은 우리가 같은 견해를 가지고 있지만 두 개의 분리된 지점에 있기 때문에 흥미로운 예이다.

만약 당신이 이전부터 기억한다면, 구조적 정체성 때문에, 두 견해는 다른 정체성을 가진 것으로 간주됩니다.

매트는 이것이 애니메이션에 어떤 영향을 미치는지에 대해 논의했지만, 이것은 또한 당신의 주의 지속성에 지대한 영향을 미칩니다.

이걸 실제로 보자.

우리가 처음으로 본문을 평가하고 실제 브랜치를 입력할 때, SwiftUI는 초기 값으로 상태에 대한 영구 저장소를 할당할 것이다.

이 견해의 수명 동안, SwiftUI는 다양한 행동에 의해 변형됨에 따라 상태를 유지한다.

하지만 dayTime의 값이 바뀌고 우리가 거짓 브랜치를 입력하면 어떻게 되나요?

SwiftUI는 이것이 뚜렷한 정체성을 가진 다른 견해라는 것을 알고 있다.

그것은 상태의 초기 값으로 시작하여 잘못된 보기에 대한 새로운 저장소를 만들고, 실제 보기에 대한 저장소는 바로 할당됩니다.

하지만 우리가 진짜 지점으로 돌아가면 어떡하지?

음, 그것은 다시 새로운 관점입니다, 그래서 SwiftUI는 주의 초기 값에서 다시 시작하여 새로운 저장소를 만듭니다.

여기서 요점은 정체성이 바뀔 때마다 상태가 교체된다는 것이다.

잠시 멈추고 이 중요한 점을 이해하도록 할게요: 당신의 상태의 지속성은 당신의 견해의 수명과 관련이 있습니다.

이것은 매우 강력한 개념이다. 왜냐하면 우리는 관점의 본질인 상태를 명확하게 분리하고 그것을 정체성과 묶을 수 있기 때문이다.

다른 모든 것은 그것으로부터 파생될 수 있다.

그리고 당신의 데이터는 매우 중요하기 때문에 SwiftUI는 데이터의 ID를 당신의 견해에 대한 명시적인 ID의 형태로 사용하는 일련의 데이터 기반 구조를 가지고 있습니다.

이것의 표준적인 예는 ForEach이다.

이제 ForEach를 초기화할 수 있는 모든 다른 방법을 살펴봅시다.

이것은 우리가 이 유형에 대해 더 나은 직관을 구축하는 데 도움이 될 것이다.

ForEach의 가장 간단한 형태는 일정한 범위를 취하는 형태이다.

이것은 특히 새로운 UI 프로토타이핑을 시작할 때 매우 편리한 이니셜라이저입니다.

SwiftUI는 뷰 빌더가 생성한 뷰를 식별하기 위해 이 범위의 오프셋을 사용할 것이다.

일정한 범위를 요구함으로써, 우리는 신원이 보기의 수명 동안 안정적이라는 것을 보장합니다.

사실, 이 이니셜라이저를 다이내믹 레인지로 사용하는 것은 오류입니다.

그리고 올해 새로운, 당신은 비일정 범위를 제공할 때 경고를 보게 될 것입니다.

일을 더 흥미롭게 만들고 역동적인 데이터 수집을 가져오자.

이 이니셜라이저는 식별자 역할을 하는 속성에 대한 컬렉션과 키 경로를 가져갑니다.

SwiftUI는 컬렉션의 요소에서 생성된 모든 뷰에 ID를 할당하기 위해 값을 사용할 것이기 때문에 이 속성은 해시 가능해야 합니다.

나중에, Raj는 안정적인 신원을 선택하는 것이 앱의 성능과 정확성에 어떤 영향을 미치는지에 대한 몇 가지 예를 보여줄 것입니다.

데이터에 안정적인 ID를 제공하는 이 아이디어는 매우 중요하기 때문에 표준 라이브러리는 이 기능을 설명하기 위해 식별 가능한 프로토콜을 정의합니다.

그리고 SwiftUI는 이 프로토콜을 최대한 활용하여 키 경로를 생략하고 프로토콜 요구 사항에서 제공하는 식별자를 사용하여 데이터 및 보기와 관련된 ID를 정의할 수 있습니다.

내가 스위프트에 대해 정말 좋아하는 것은 우리가 해결하고 있는 문제의 제약을 정확하게 설명하기 위해 그 유형 시스템을 활용할 수 있다는 것이다.

그러니 우리가 여기서 사용하고 있는 이니셜라이저의 정의를 살펴보세요.

이 짧은 정의에는 흥미로운 것들이 많이 있으니, 그것들을 풀어봅시다.

ForEach는 두 가지 주요 조각이 필요합니다: 컬렉션 -- 여기에 일반적인 인수 데이터로 표시됨 -- 그리고 컬렉션의 각 요소에서 뷰를 생성하는 방법.

이 이니셜라이저의 모양은 ForEach가 데이터 모음과 뷰 모음 사이의 관계를 정의한다는 직관을 제공해야 합니다.

하지만 사실, 여기서 가장 흥미로운 부분은 우리가 컬렉션의 요소를 식별할 수 있도록 제한한다는 것이다.

다시 말하지만, 식별 가능한 프로토콜의 목적은 귀하의 유형이 안정적인 신원 개념을 제공하여 SwiftUI가 평생 동안 데이터를 추적할 수 있도록 하는 것입니다.

사실, 이것은 우리가 이전에 논의한 정체성과 일생의 개념과 매우 유사하다.

식별 가능한 유형과 뷰 빌더를 취하는 SwiftUI 뷰는 데이터 기반 구성 요소입니다.

이 뷰는 당신이 제공하는 데이터의 ID를 사용하여 그것과 관련된 뷰의 수명을 확장합니다.

좋은 식별자를 선택하는 것은 당신의 견해와 데이터의 수명을 통제할 수 있는 기회입니다.

그래서 우리가 이 섹션에서 논의한 것을 요약해 봅시다.

견해의 가치는 일시적이며 당신은 그들의 수명에 의존해서는 안 됩니다.

하지만 그들의 정체성은 그렇지 않으며, 시간이 지남에 따라 그들에게 연속성을 주는 것이다.

당신은 당신의 견해의 정체성을 통제할 수 있으며, 정체성을 사용하여 국가의 수명을 명확하게 확장할 수 있습니다.

그리고 마지막으로, SwiftUI는 데이터 기반 구성 요소에 대한 식별 가능한 프로토콜을 최대한 활용하므로 데이터에 대한 안정적인 식별자를 선택하는 것이 중요합니다.

그리고 이제 전통을 이어가며, 나는 그것을 Raj에게 넘길 것이다. 라지?

라즈 라마머시: 고마워, 루카!

지금까지, 우리는 정체성이 무엇이며 그것이 견해의 생애와 어떻게 연결되는지 설명했다.

다음으로, 저는 SwiftUI가 UI를 업데이트하는 방법에 대해 자세히 알아볼 것입니다.

목표는 SwiftUI 코드를 구성하는 방법에 대한 더 나은 정신 모델을 제공하는 것입니다.

나는 또한 마지막에 모든 것을 요약한 몇 가지 예를 보여줄 것이다.

의존성에 대한 이 논의를 시작하기 위해, 관점을 살펴봅시다.

여기 간단한 견해가 있습니다.

그것은 개에게 간식을 주는 버튼을 보여준다.

미안해, 루카, 하지만 난 개 같은 사람이야.

관점의 구조에 집중합시다.

먼저, 상단을 살펴봅시다.

두 가지 속성이 있다: 하나는 개를 위한 것이고 다른 하나는 간식을 위한 것이다.

이 속성들은 뷰의 종속성이다.

의존성은 단지 뷰에 대한 입력일 뿐이다.

의존성이 바뀌면, 새로운 몸을 만들기 위해 시야가 필요하다.

본문은 뷰의 계층 구조를 구축하는 곳이다.

이 뷰의 계층 구조에 뛰어들면, 우리는 액션이 있는 버튼이 있다.

행동은 뷰의 종속성에 대한 변화를 유발하는 것이다.

코드를 동등한 다이어그램으로 바꾸자.

여기 우리 DogView의 다이어그램이 있습니다.

우리가 버튼을 탭하면, 그것은 개에게 보상하기 위한 행동을 발송한다.

우리 개는 순식간에 간식을 삼킨다.

그리고 그것은 개에게 변화를 가져온다 - 아마도 그는 다른 것을 원할 것이다.

의존성이 바뀌었기 때문에, DogView는 새로운 몸을 생산한다.

SwiftUI의 데이터 흐름의 일반적인 개념에 대해 자세히 알아보려면, WWDC 2020의 "SwiftUI의 데이터 필수 요소"를 확인하세요.

다음으로, 이 다이어그램을 조금 단순화해 봅시다.

뷰 계층에 초점을 맞추면, 우리의 견해가 어떻게 나무와 같은 구조를 형성하는지 주목하세요.

그리고 우리가 개를 추가하고 꼭대기에서 의존성을 다시 치료한다면, 그것은 여전히 나무처럼 보인다.

그러나, DogView는 의존성이 있는 유일한 견해가 아니다.

SwiftUI에서, 각 뷰는 자체 종속성 세트를 가질 수 있다.

지금까지, 이것은 여전히 나무처럼 보인다.

하지만, 같은 상태나 다른 데이터에 의존하는 여러 견해가 있을 수 있습니다.

예를 들어, 후손 중 한 명도 개에게 의존할 수 있다.

그리고 이것은 우리의 다른 의존성 중 하나에서 일어날 수 있다.

그래서 우리는 나무로 시작했지만, 이 구조는 이제 느슨하게 나무를 닮았다.

사실, 우리가 겹치는 선을 피하기 위해 그것을 재배열한다면, 우리는 이 구조로 끝나게 되는데, 이는 이것이 실제로 나무가 아니라 그래프임을 보여준다.

사실, 우리는 이 구조를 "의존성 그래프"라고 부른다.

이 구조는 SwiftUI가 새로운 본문이 필요한 뷰만 효율적으로 업데이트할 수 있기 때문에 중요하다.

예를 들어, 하단의 의존성을 생각해 보세요.

우리가 이 의존성을 조사한다면, 그것은 두 가지 종속적인 견해를 가지고 있다.

그래프의 비밀은 의존성이 바뀌면, 그 견해만 무효화된다는 것이다.

SwiftUI는 각 뷰의 바디를 호출하여 각 뷰에 대한 새로운 바디 값을 생성합니다.

SwiftUI는 무효화된 각 뷰의 본문의 값을 인스턴스화할 것이다.

그것은 더 많은 의존성을 변화시킬 수 있지만, 항상 그런 것은 아니다!

뷰는 값 유형이기 때문에, SwiftUI는 뷰의 올바른 하위 집합만 업데이트하기 위해 효율적으로 비교할 수 있습니다.

이것은 루카가 이전에 논의한 것을 보는 또 다른 방법이다.

뷰의 가치는 수명이 짧다.

구조체 값은 단지 비교를 위해 사용되지만, 뷰 자체는 수명이 더 길다.

그리고 그것이 우리가 중앙의 시야를 위한 새로운 몸을 생성하는 것을 피할 수 있는 방법이다.

정체성은 의존성 그래프의 중추이다.

매트가 말했듯이, 모든 견해는 명시적으로 또는 구조적으로 명시되어 있든 정체성을 가지고 있다.

그 정체성은 SwiftUI 경로가 올바른 보기로 변경되고 UI를 효율적으로 업데이트하는 방법입니다.

많은 종류의 의존성이 있다.

우리는 이전에 치료 속성과 개 바인딩에 대한 몇 가지 예를 보았지만, 환경, 상태 또는 관찰 가능한 객체 속성 래퍼를 사용하여 종속성을 형성할 수도 있습니다.

다음으로, 저는 당신의 견해에서 정체성 사용을 개선하는 방법에 대해 이야기하고 싶습니다.

이것은 SwiftUI가 당신의 코드를 더 잘 이해하는 데 도움이 될 것입니다.

루카가 말했듯이, 견해의 수명은 정체성의 지속 기간이며, 이는 식별자의 안정성이 중요하다는 것을 의미한다.

안정적이지 않은 식별자는 보기 수명이 짧아질 수 있다.

그리고 SwiftUI는 그래프 업데이트를 통해 뷰와 이탈을 위한 스토리지를 지속적으로 만들 필요가 없기 때문에 안정적인 식별자를 갖는 것도 성능에 도움이 됩니다.

앞서 보았듯이, SwiftUI는 지속된 스토리지를 관리하기 위해 수명을 사용하므로, 안정적인 식별자도 상태 손실을 피하는 데 중요합니다.

식별자 안정성의 중요성을 설명하기 위해 코드 예제로 전환해 봅시다.

이 예시에서, 나는 내가 가장 좋아하는 애완동물 목록을 가지고 있다.

우리는 애완동물 구조체에 식별자를 가지고 있다.

하지만 실제로 버그가 있어; 내가 새로운 애완동물을 얻을 때마다, 화면의 모든 것이 깜박인다!

잠시 멈추고 이 코드를 봅시다.

벌레가 어디에 있는지 알 수 있어?

버그는 우리의 식별 가능한 적합성에 있다.

시험에 합격하지 못했다면, 걱정하지 마세요; 이 섹션에는 간식이 없습니다.

문제는 이 식별자가 안정적이지 않기 때문에, 데이터가 바뀔 때마다 새로운 식별자를 얻는다는 것이다.

대신, 우리가 애완동물 배열의 인덱스를 사용한다면 어떨까요?

불행히도, 이것은 비슷한 문제를 가지고 있다.

인덱스를 사용함으로써, 뷰는 이제 컬렉션에서 각각의 애완 동물의 위치에 의해 식별됩니다.

내가 가장 좋아하는 새로운 애완동물이 있다고 결정하면, 다른 모든 애완동물은 그들의 정체성을 바꿀 것이며, 이는 나쁜 버그를 일으킬 수 있다.

이 예에서, 버튼은 인덱스 0에 새 요소를 삽입하지만, 마지막 인덱스가 새 인덱스이기 때문에 시작 대신 끝에 삽입됩니다.

이것은 계산된 무작위 식별자와 마찬가지로 인덱스가 안정적인 형태의 신원이 아니기 때문이다.

이 예에서, 우리는 데이터베이스에서 하나 또는 애완 동물의 안정적인 속성에서 파생된 것과 같은 안정적인 식별자를 사용해야 합니다.

모든 영구 식별자는 훌륭한 선택입니다.

이제 우리 애니메이션은 멋져 보여!

하지만 안정성은 우리가 좋은 식별자에 필요한 유일한 재산이 아니다.

좋은 식별자의 또 다른 속성은 고유성이다.

각 식별자는 단일 보기에 매핑되어야 합니다.

이것은 애니메이션이 멋지게 보이고, 성능이 매끄럽고, 계층 구조의 종속성이 가장 효율적인 형태로 반영되도록 합니다.

또 다른 예를 살펴봅시다.

이 예에서, 나는 내 애완동물이 가장 좋아하는 모든 간식으로 뷰 작업을 하고 있다.

각 간식에는 이름, 이모티콘 및 만료일이 있습니다.

나는 각 간식을 이름으로 식별하기로 선택했다.

이 시점에서 - 나는 네가 추측할 수 있다고 확신해 - 우리는 여기에도 버그가 있어.

우리가 같은 종류의 대접을 하나 이상 받으면 어떻게 되나요?

나는 너에 대해 모르지만, 나는 개 비스킷을 대량으로 사는 것을 좋아해.

내가 그것들을 항아리에 추가하면, 그것들은 나타나지 않을 수도 있어!

문제는 간식의 이름이 고유 식별자가 아니라는 것이다.

대신, 우리는 치료당 일련 번호나 다른 고유 ID를 사용할 수 있습니다.

그리고 이것은 모든 올바른 데이터가 우리의 항아리에 표시되도록 보장합니다.

그것은 또한 더 나은 애니메이션과 더 나은 성능을 보장할 것이다.

SwiftUI가 식별자가 필요할 때, 당신의 도움이 필요합니다!

특히 계산된 속성에서 무작위 식별자를 사용할 때 주의하십시오.

일반적으로, 당신은 모든 식별자가 안정적이기를 원합니다.

식별자는 시간이 지남에 따라 변경되어서는 안 됩니다; 새로운 식별자는 새로운 수명을 가진 새로운 항목을 나타냅니다.

그리고 마지막으로, 식별자는 고유해야 한다.

여러 뷰는 식별자를 공유할 수 없습니다.

SwiftUI는 이러한 속성에 의존하여 앱이 원활하고 버그 없이 실행되도록 합니다.

이제 우리가 명백한 정체성에 대해 이야기했으므로, 나는 구조적 정체성으로 넘어가고 싶다.

이 예에서, 나는 이전부터 간식 항아리를 작업하고 있다.

책임감 있는 반려동물 애호가로서, 나는 반려동물에게 가장 훌륭하고 만료되지 않은 음식만 먹인다.

간식이 언제 나빠졌을지 알려주기 위해, 나는 치료가 만료되었을 때 선택적으로 치료 셀을 어둡게 하는 새로운 수정자를 추가했다.

나는 희미해진 셀을 강조했다.

수정자에 뛰어들자.

수정자에서 볼 수 있습니다. 저는 날짜가 있고 언제 뷰를 어둡게 해야 하는지 알기 위해 현재 날짜와 비교합니다.

이것은 처음에는 괜찮아 보이지만, 여기에는 미묘한 문제가 있다.

조건이 바뀌고 우리의 치료가 만료되면, 여기에 지점이 있기 때문에 우리는 새로운 정체성을 갖게 된다.

매트가 논의했듯이, 가지는 구조적 정체성의 한 형태이다.

이것은 우리가 선택적으로 수정된 단일 사본 대신 두 개의 콘텐츠 사본이 있다는 것을 의미합니다.

여기 지점은 수정자에 있다는 점에 유의하세요.

명확성을 위해, 나는 수정자와 그 사용 사이트를 같은 슬라이드에 넣었지만, 당신의 프로젝트에서, 당신은 그것을 알지도 못한 채 파일 간에 이와 같은 브랜치를 가질 수 있습니다!

물론, 우리가 여기서 논의한 모든 것은 뷰와 뷰 수정자에 적용된다.

그래서 우리가 어떻게 이걸 피할 수 있을까?

음, 한 가지 방법은 가지를 함께 접고 불투명도 수정자 안으로 조건을 옮기는 것이다.

이 지점을 제거함으로써, 우리는 이 견해를 하나의 정체성을 가진 것으로 정확하게 설명했습니다.

게다가, 불투명도 수정자 내부로 조건을 옮기는 것은 성능에 도움이 될 수 있습니다. 왜냐하면 우리는 종속 코드를 엄격하게 범위화했기 때문입니다.

이제 조건이 바뀌면, 불투명도만 바뀌어야 한다.

이것에 대한 비결은 그 조건이 사실일 때, 우리는 이렇게 보이는 1의 불투명도를 가지고 있다는 것이다.

1의 불투명도는 효과가 없다.

우리는 렌더링된 결과에 영향을 미치지 않기 때문에 이와 같은 수정자를 "불활성 수정자"라고 부릅니다.

SwiftUI 수정자는 저렴하기 때문에, 이 패턴에는 고유한 비용이 거의 없다.

결과적인 시각적 효과가 없기 때문에, 프레임워크는 수정자를 효율적으로 잘라내어 비용을 더욱 줄일 수 있다.

브랜치는 훌륭하며, SwiftUI에 존재하는 데는 이유가 있다.

하지만 불필요하게 사용될 때, 그들은 성능 저하, 놀라운 애니메이션, 그리고 루카가 보여준 것처럼, 심지어 상태의 상실을 유발할 수 있다.

브랜치를 소개할 때, 잠시 멈추고 여러 뷰를 나타내는지 아니면 같은 뷰의 두 상태를 나타내는지 고려하세요.

우리가 보았듯이, 종종 단일 뷰를 식별하기 위해 분기 대신 불활성 수정자를 사용하는 것이 더 낫다.

다음은 불활성 수정자의 몇 가지 예입니다.

나는 특히 환경에 조건부로 글을 쓰는 transformEnvironment를 좋아한다.

모든 것을 종합하면, 우리는 오늘 당신에게 정체성이 놀라운 공연의 비밀 중 하나라는 것을 보여주었습니다.

우리는 명시적이고 구조적인 정체성과 앱을 개선하기 위해 각각을 활용할 수 있는 방법에 대해 논의했습니다.

정체성에서, 우리는 관련 저장소, 전환 등을 제어하는 뷰의 수명을 도출할 수 있다.

그리고 우리는 또한 SwiftUI가 ID와 수명을 사용하여 UI를 효율적으로 업데이트할 수 있는 그래프로 표시되는 종속성을 형성한다고 설명했습니다.

SwiftUI를 신비화하는 것과 함께, 우리는 버그를 피하고 앱의 성능을 개선하기 위한 몇 가지 팁과 요령을 제공했습니다.

그리고 이제 이 트릭을 배웠으니, 그들이 당신을 도울 수 있는지 확인하기 위해 코드를 둘러보세요.

감사합니다, 그리고 훌륭한 앱을 계속 만드세요!

♪