10003

- 안녕! WWDC에 오신 것을 환영합니다.

제 이름은 앤 히치콕이고, 저는 워치 프레임워크 팀의 엔지니어입니다.

오늘 Apple Watch의 데이터 전송 전략에 대해 이야기하게 되어 기쁩니다.

도입 이후, 애플 워치는 점점 더 독립적이 되었다.

시리즈 3는 셀룰러 기능을 갖춘 최초의 Apple Watch였다.

watchOS 6의 독립 시계 앱은 iOS 동반자가 필요하지 않고 고객의 시계의 App Store에서 구매할 수 있는 앱을 작성할 수 있는 기능을 제공합니다.

watchOS 7에 가족 설정이 도입됨에 따라, 고객은 동반자 iPhone 없이도 그 어느 때보다 더 독립성을 갖게 됩니다.

그러나 이러한 새로운 기능은 개발자로서 우리가 Watch 앱과 소통하는 것에 대해 생각하는 방식에 새로운 도전을 제시합니다.

다행히도, 우리는 많은 훌륭한 선택지가 있다.

오늘 우리는 그 옵션들과 그 일에 적합한 것을 고르는 방법에 대해 이야기할 것이다.

Watch 앱에서 데이터 통신을 위한 도구에 대한 개요를 제공하고 어떤 것이 당신의 작업에 적합한 선택이 될지 평가하는 방법에 대해 논의할 것입니다.

우리는 도구를 몇 가지 범주로 광범위하게 그룹화할 수 있다.

iCloud를 사용하면 모든 장치와 공유할 수 있으며 서버 저장 공간을 제공합니다.

우리는 이것을 iCloud 동기화와 함께 키체인과 CloudKit과 함께 CoreData를 사용하여 앱에서 사용할 수 있습니다.

페어링된 장치 간에 데이터를 전송해야 하는 경우, Watch Connectivity를 사용할 수 있습니다.

서버와 직접 통신하려면, URL 세션이나 소켓을 사용할 수 있습니다.

하지만 먼저, 우리는 당신이 올바른 것을 고르기 위해 물어볼 수 있는 질문에 대해 이야기할 것입니다.

내 워치 앱에서 어떻게 소통할지 생각할 때, 나는 몇 가지에 대해 생각한다.

그건 어떤 종류의 데이터야?

그리고 데이터는 지금 어디에 있으며, 어디에 있어야 하나요?

상호 작용이 컴패니언 iOS 앱에 의존하나요?

가족 설정을 지원하고 싶나요?

그리고 데이터는 언제 목적지에 있어야 하나요?

시스템이 고객을 위해 성능과 배터리 사용량을 최적화할 수 있도록 기다릴 수 있나요?

데이터가 얼마나 자주 바뀌나요?

이러한 질문에 대한 답변을 바탕으로, 저는 데이터 전송 작업에 적합한 솔루션을 만드는 방법을 평가하기 위해 도구 상자를 살펴보기 시작할 수 있습니다.

iCloud 동기화로 키체인에서 어떤 기능을 얻는지 살펴봅시다.

키체인은 비밀번호, 키 및 기타 민감한 자격 증명을 위한 안전한 저장소를 제공합니다.

그리고 watchOS 6.2에 도입된 iCloud 키체인 동기화를 통해 이러한 키체인 항목은 사람의 모든 장치와 동기화할 수 있습니다.

앱에서 iCloud 동기화의 이점을 누릴 수 있는 두 가지 방법이 있습니다: 관련 도메인 및 공유 키체인 항목으로 비밀번호 자동 채우기를 사용하는 것입니다.

비밀번호 자동 완성을 사용하면 아주 적은 코드로 키체인 동기화를 사용할 수 있습니다.

먼저, 대상에 관련 도메인 기능을 추가하세요.

Watch 앱의 경우, WatchKit 확장 대상에 기능을 추가하세요.

도메인 이름으로 웹 자격 증명 항목을 추가하세요.

웹 서버에 apple-app-site-association 파일을 추가하세요.

그 파일은 리디렉션 없이 HTTPS를 통해 접근할 수 있어야 한다.

이 파일은 파일 확장자가 없는 JSON 형식이며, 서버의 ./well-known 디렉토리에 배치해야 합니다.

자세한 내용은 "관련 도메인 지원"에 대한 온라인 문서를 확인하세요.

텍스트 필드와 보안 필드에 텍스트 콘텐츠 유형을 추가하세요.

자동 완성 옵션은 사용자 이름, 이메일 주소, 비밀번호 및 새 비밀번호입니다.

새 비밀번호의 경우, 시스템은 그 사람에게 저장하라는 메시지를 표시하고, 사이트의 키체인에 레코드가 추가되거나 업데이트됩니다.

자동 완성 제안은 watchOS 6.2부터 사용할 수 있으며 watchOS 8의 새로운 텍스트 편집 경험으로 훨씬 더 좋습니다.

비밀번호 자동 완성 사용에 대한 자세한 내용은 개발자 앱이나 온라인에서 "모든 곳에서 자동 완성" 세션을 확인하세요.

키체인 동기화를 사용하여 데이터를 공유할 수 있는 또 다른 방법은 앱 간에 키체인 항목을 공유하는 것입니다.

우리가 논의했듯이, 키체인은 비밀번호, 키 및 자격 증명과 같은 민감한 데이터를 위한 안전한 저장소입니다.

정보가 자주 변경되지 않는 한, 시작 화면에 대한 사람의 선호도와 같은 다른 작은 공유 데이터를 키체인에 저장할 수도 있습니다.

키체인에 저장된 데이터는 모든 사람의 장치와 동기화됩니다.

키체인에 OAuth 2 토큰을 저장하고 검색하고 앱 그룹과 공유하는 방법을 살펴봅시다.

먼저, 키체인 공유 또는 앱 그룹 기능, 이러한 키체인 항목을 공유하고 싶은 모든 앱을 추가해야 합니다.

이것은 항목을 공유하는 데 필요하며, 다른 앱의 액세스를 방지하여 고객 정보의 보안과 프라이버시를 보장하는 데 도움이 됩니다.

Watch 앱의 경우, Watch Extension 대상에 기능을 추가하세요.

이 예에서, 저는 키체인 공유 기능을 추가하고 제 앱을 키체인 그룹에 추가할 것입니다.

키체인 항목을 공유할 내 모든 앱은 이 그룹도 공유해야 한다.

이제, 키체인에 OAuth 2 토큰을 저장하는 코드를 살펴봅시다.

토큰을 저장하기 위해, 항목이 있으면 업데이트하고, 존재하지 않으면 추가할 것입니다.

토큰 문자열, 만료 및 새로 고침 토큰과 같은 토큰 데이터를 포함하도록 OAuth 2 토큰 구조를 만들었습니다.

나는 쉽게 저장하고 검색할 수 있도록 토큰 구조체가 codable에 적합하도록 만들었다.

우리는 쿼리 사전을 만든다.

이 서버와 계정에 이미 저장된 항목이 있는 경우 기존 항목과 일치하는 속성 세트입니다.

여기서 "true"로 설정된 동기화 가능한 속성에 주목하세요.

항목이 모든 고객의 장치와 동기화되기를 원한다는 것을 나타내기 위해 쿼리에 이 속성을 포함하는 것이 중요합니다.

우리는 토큰을 데이터로 인코딩하고, 그 데이터를 속성 사전에서 키체인 항목의 값으로 설정할 것입니다.

그런 다음, 쿼리와 속성으로 키체인의 항목을 업데이트하세요.

우리는 항상 키체인 API에서 반환된 결과 코드를 확인해야 합니다.

우리는 먼저 키체인이 그 물건을 찾지 못했다고 말했는지 확인할 것이다.

그렇다면, 우리는 키체인에 추가하기 위해 작성한 다른 함수를 호출할 것이다.

우리는 잠시 후에 그것을 볼 거야.

그렇지 않으면, 우리는 오류가 없는지 확인할 것이다.

그렇게 하기 위해, 우리는 성공 결과를 확인한다.

업데이트 기능이 성공한다면, 우리의 토큰은 키체인에서 업데이트되었다.

이제, 추가 기능을 살펴봅시다.

키체인에 토큰을 추가하려면, 모든 속성이 있는 사전을 설정할 것입니다.

여기에는 기존 항목을 찾는 데 사용한 속성과 토큰 데이터가 포함됩니다.

그런 다음, 우리는 속성으로 키체인 API의 추가 함수를 호출할 것입니다.

그리고 그것이 성공했는지 확인하기 위해 반환 코드를 확인하세요.

키체인에서 토큰 정보를 검색하기 위해, 우리는 원하는 항목을 찾기 위해 쿼리 사전을 설정할 것입니다.

우리는 업데이트 기능에서 이전에 항목을 찾기 위해 포함했던 것과 동일한 키와 값 세트를 포함할 것입니다.

게다가, 우리는 키체인 API에 항목 속성이 반환되기를 원하는지(하지 않음)와 항목 데이터가 반환되기를 원하는지 여부를 알려주는 몇 가지 속성을 포함합니다.

키체인 "복사 매칭" 기능은 쿼리를 사용하여 검색하고 우리가 제공한 참조를 "항목"으로 채웁니다.

검색된 항목에 접근하기 전에, 우리는 그것이 발견되었는지 확인하기 위해 반품 코드를 확인할 것입니다.

그런 다음, 언제나처럼, 우리는 성공을 위해 반품 코드를 확인합니다.

항목에 대해 복사된 사전을 가져오고, 사전에서 요청한 토큰 데이터를 가져오고, 데이터를 OAuth 2 토큰 유형으로 디코딩하세요.

그리고 이제, 우리는 키체인에 OAuth 2 토큰을 성공적으로 저장, 업데이트 및 검색했으며, 키체인 공유 그룹의 모든 앱과 공유됩니다.

당신과 공유하고 싶은 키체인 저장 기능이 하나 더 있습니다.

고객의 장치에 무언가를 저장하는 곳과 마찬가지로, 작업을 마치면 제거해야 합니다.

우리는 이제 익숙한 속성으로 검색을 설정할 것입니다.

쿼리로 키체인 API의 삭제 기능을 호출하세요.

그리고, 언제나처럼, 성공을 확인하세요.

삭제의 경우, 찾을 수 없습니다.

이제, 우리는 데이터를 끝낸 후에 정리를 마칩니다.

iCloud 키체인 동기화를 통한 키체인 서비스는 앱이 자주 변경되지 않는 작은 데이터를 공유할 수 있는 좋은 방법이며, 그 데이터는 모든 사람의 장치에 동기화됩니다.

관련 도메인을 사용하여 앱에 비밀번호 자동 완성 기능을 쉽게 추가하세요.

또한 키체인에 직접 값을 저장하고 검색하고 키체인 공유 또는 앱 그룹을 사용하여 다른 앱과 공유할 수 있습니다.

iCloud 키체인 동기화는 iOS 컴패니언 앱에 의존하지 않으며, 가족 설정을 지원합니다.

항목은 네트워크 가용성, 배터리 및 기타 시스템 조건에 따라 가능한 경우 동기화됩니다.

고객이 iCloud 키체인 동기화를 비활성화할 수 있으며 모든 지역에서는 사용할 수 없다는 점에 유의하십시오.

CloudKit이 있는 CoreData는 로컬 데이터베이스를 앱의 CloudKit 컨테이너를 공유하는 고객의 다른 모든 장치와 동기화합니다.

SwiftUI와의 CoreData 통합은 Watch 애플리케이션에서 데이터베이스의 데이터에 액세스하고 표시하는 것을 단순화합니다.

멀티 플랫폼 애플리케이션을 개발하는 경우 이러한 방식으로 Watch에서 너무 많은 데이터를 빠르게 얻을 수 있습니다.

고객이 시계에 실제로 필요로 하는 정보에 대해 신중하게 생각해 보세요.

코어 데이터 모델에서 여러 구성을 사용하여 저장 공간과 배터리 용량이 더 많은 장치에서 실행되는 앱에 적합한 데이터에서 Watch 앱에 있는 데이터를 세분화하는 것을 고려하십시오.

CloudKit과 Core Data는 강력한 도구입니다.

Core Data와 SwiftUI의 통합을 통해 앱에서 Core Data 기능을 더 쉽게 사용할 수 있습니다.

환경 값으로 뷰에 관리되는 객체 컨텍스트를 제공하고, 가져오기 요청 속성 래퍼를 사용하여 데이터베이스에서 결과를 얻을 수 있습니다.

이러한 결과는 SwiftUI 목록 및 기타 보기에서 사용할 수 있습니다.

CloudKit의 Core Data는 사람의 모든 장치와 동기화되고 iCloud에 백업할 수 있는 구조화된 데이터를 공유할 수 있는 방법을 제공합니다.

그것은 동반자 iPhone 앱에 의존하지 않으며 가족 설정을 지원합니다.

핵심 데이터 변경의 동기화는 네트워크 가용성과 시스템 조건에 따라 발생합니다.

그것이 즉각적일 것이라고 기대하지 마세요, 하지만 CloudKit은 앱에 대한 이 동기화의 최적화 성능을 처리할 것입니다.

앱에서 CloudKit과 함께 Core Data를 사용하는 방법에 대해 자세히 알아보려면, 개발자 앱 또는 온라인에서 "CloudKit 및 Core Data를 통해 데이터를 공유하는 앱 빌드"와 "Bring Core Data concurrency to Swift and SwiftUI"를 확인하세요.

당신은 이미 Watch Connectivity에 익숙할 수도 있고, 이전에 그것을 사용했을 수도 있습니다.

하지만 저는 당신이 성공할 수 있도록 더 많은 세부 사항과 모범 사례를 제공하고 싶습니다.

Watch Connectivity를 사용하면 두 장치가 Bluetooth 범위 내에 있거나 동일한 Wi-Fi 네트워크에 있을 때 Watch 앱과 동반자 iPhone 앱 간에 데이터를 보낼 수 있습니다.

휴대폰과 시계 앱이 모두 설치되어 있을 때 고객의 경험을 최적화하고 한 장치에서만 사용할 수 있는 데이터를 공유하는 데 가장 잘 사용됩니다.

예를 들어, 누군가가 iPhone 앱을 실행하고 최신 데이터를 다운로드한 경우, 해당 데이터를 Watch 앱과 공유하여 컴플리케이션을 최신 상태로 유지하고 Watch 앱이 다음에 실행될 때 동일한 데이터로 시작할 수 있도록 할 수 있습니다.

이것은 당신의 고객에게 더 빠르게 반응할 것이며 당신의 앱이 해야 하는 중복 데이터 다운로드를 최소화할 것입니다.

Watch Connectivity에는 다양한 기능이 있으므로, 무엇을 사용할 수 있고 언제 각각을 사용해야 하는지 아는 것이 도움이 됩니다.

하지만 먼저, Watch Connectivity가 당신의 작업에 적합한 도구라고 결정한다면 성공하는 데 도움이 되는 몇 가지 팁을 공유하고 싶습니다.

Watch Connectivity는 두 장치 간에 통신하는 도구이기 때문에, 몇 가지 전제 조건에 대해 알고 몇 가지 오류를 처리해야 합니다.

이것들은 시계 연결 통신이 원활하게 작동하도록 하기 위해 할 수 있는 몇 가지 사항입니다.

가급적이면 앱 또는 확장 위임에서 앱이 실행을 마칠 때 가능한 한 빨리 시계 연결 세션을 활성화하십시오.

이렇게 하면 앱이 가능한 한 빨리 해당 앱에서 정보를 받을 수 있습니다.

접근성을 이해하세요.

백그라운드 통신 중 어느 것도 데이터를 보낼 때 상대방 앱에 연결할 수 있어야 합니다.

하지만 대화형 메시징에는 접근성 요구 사항이 있으며, 우리는 그때 그것에 대해 논의할 것입니다.

그것들을 이해하는 데 시간을 절약할 수 있을 것이다.

모든 시계 연결 세션 위임 기능은 비주요 직렬 대기열에서 호출됩니다.

사용자 인터페이스를 업데이트하기 위해 이러한 기능에서 작업을 수행해야 하는 경우, 기본 대기열에서 해야 합니다.

이제, 다양한 시계 연결 기능과 각 기능을 언제 사용해야 하는지에 대해 이야기해 봅시다.

애플리케이션 컨텍스트는 앱이 깨어날 때 사용할 수 있도록 백그라운드에서 해당 앱으로 전송되는 단일 속성 목록 사전입니다.

이전 사전이 전송되기 전에 응용 프로그램 컨텍스트를 업데이트하면 새 값으로 대체됩니다.

애플리케이션 컨텍스트는 새로운 데이터가 있을 때 대응 앱의 콘텐츠를 최신 상태로 유지하고 자주 업데이트될 수 있는 데이터에 유용합니다.

사용자 정보 전송은 또한 백그라운드에서 상대 앱으로 속성 목록 사전을 전송하지만, 애플리케이션 컨텍스트와는 약간 다릅니다.

업데이트할 때마다 대체되는 단일 사전이 되는 대신, 각 사용자 정보 사전 전송은 대기열에 있는 순서대로 대기하고 전달됩니다.

환승을 취소하기 위해 대기열에 접속할 수도 있습니다.

파일 전송은 사용자 정보 전송과 유사하며, 일단 하나를 완료하면, 다른 하나는 친숙하게 느껴질 것입니다.

파일은 해당 앱으로 전송되도록 대기열에 있으며, 전력 및 기타 조건이 허용될 때 전송됩니다.

환승을 취소하기 위해 대기열에 접근할 수 있습니다.

파일은 전송될 때 수신 앱의 문서 받은 편지함에 배치됩니다.

세션 대리자에서 수신된 파일 콜백에서 돌아오면 각 파일은 받은 편지함에서 삭제됩니다.

이 방법에서 돌아오기 전에 파일을 이동하거나 빠르게 처리해야 합니다.

이것에 대해 기억해야 할 한 가지 유용한 점: 이 콜백은 비주요 직렬 대기열에서 호출되기 때문에, 받은 편지함에서 파일을 처리하기 위해 비동기 메서드를 호출하면 파일이 사라지기 때문에 문제가 발생할 가능성이 높습니다.

파일 전송의 타이밍은 시스템 조건을 기반으로 하며, 물론 더 큰 파일은 전송하는 데 더 오래 걸릴 수 있습니다.

transferCurrentComplicationUserInfo(_:)는 합병증 관련 데이터를 Watch로 보내는 사용자 정보 전송 기능의 특별한 경우입니다.

예산에 복잡한 전송이 남아 있는 한, 다른 사용자 정보 전송보다 앞서 가능한 한 빨리 전송됩니다.

이 즉각적인 전송을 사용하면 휴대폰에서 데이터를 업데이트할 때 고객을 위해 활성 합병증을 최신 상태로 유지할 수 있습니다.

남은 예산을 확인할 수 있으며, 남은 예산 없이 현재 합병증 정보를 전송하면 여전히 전송됩니다.

그것은 단지 일반 사용자 정보 전송 대기열을 사용할 것이다.

sendMessage를 사용하여 상대 앱으로 데이터를 보내고 답장을 받을 수 있습니다.

이것은 상대방 앱에 연결할 수 있을 때 대화형 메시징을 위한 것입니다.

사전이나 데이터를 보내든, 메시지를 작게 유지하세요.

또한 sendMessage 통화에 대한 응답 핸들러를 포함하도록 선택하는 것이 좋습니다.

짧은 답장을 통해 해당 앱이 메시지를 받았고 데이터가 정확한지 확인할 수 있습니다.

sendMessage에 답장 핸들러를 포함할 때, 답장 핸들러가 포함된 대응 앱에서 메시지를 받았거나 데이터 대리자 콜백 기능을 받은 버전을 구현해야 합니다.

그렇지 않으면, 메시지를 보낼 때 오류가 발생할 것입니다.

이제 sendMessage에 대해 들었으니, 접근성의 개념을 다시 살펴봅시다.

메시지를 보내려면 두 앱 모두 연결할 수 있어야 합니다.

Watch Connectivity 세션에서 isReachable 속성을 확인하여 해당 앱이 라이브, 비배경 메시징에 연결할 수 있는지 확인할 수 있습니다.

하지만 닿을 수 있다는 것은 무슨 뜻인가요?

두 장치 모두 블루투스 또는 동일한 Wi-Fi 네트워크를 통해 서로의 범위 내에 있어야 합니다.

WatchKit 확장에 연결할 수 있으려면, 장기 실행 백그라운드 세션을 수행할 때와 마찬가지로 포그라운드에서 실행되거나 우선 순위가 높은 백그라운드에서 실행되어야 합니다.

iOS 앱에는 이 전경 요구 사항이 없습니다.

Watch 앱에서 iOS 앱으로 메시지를 보내고 iOS 앱이 전경에 없는 경우, iOS 앱은 메시지를 받기 위해 백그라운드에서 활성화됩니다.

이것은 당신의 iOS 앱이 그 반대보다 훨씬 더 많은 시간 동안 Watch Extension에서 접근할 수 있다는 것을 의미합니다.

Watch Connectivity는 고객이 iPhone과 Watch 앱을 모두 설치했을 때 시기적절하고 반응이 빠르며 직관적인 경험을 제공할 수 있는 좋은 방법입니다.

시계 연결은 특히 휴대폰과 페어링된 시계 간에 통신하기 때문에, 가족 설정을 위한 앱을 지원하는 데 사용하지 마세요.

데이터 전송은 블루투스 또는 Wi-Fi를 통한 컴패니언 장치의 가용성에 따라 다릅니다.

sendMessage를 사용하는 실시간 통신은 상대방에게 연락할 수 있어야 합니다.

특히 워치 앱과 통신하려고 할 때, 상대방 앱에 자주 연결할 수 없다는 것을 기억하세요.

배경 전송은 즉시 전달되지 않습니다.

그것들을 편지를 게시하는 것처럼 생각하세요: 당신은 그것을 상자에 떨어뜨리지만, 그것이 정확히 언제 거기에 있을지 확신할 수 없습니다.

시계 연결에 대한 자세한 내용은 개발자 앱 또는 온라인에서 "시계 연결 소개"를 확인하세요.

이제, 우리는 서버와 직접 통신하는 몇 가지 방법에 대해 이야기할 것입니다.

대부분의 사용 사례에서, 가장 좋은 옵션은 URL 세션이다.

상호 작용과 데이터 유형에 따라, 통신을 연기할 수 있거나 즉시 해야 할 수도 있습니다.

그래서, 우리는 URL 세션을 백그라운드나 포그라운드에서 실행할 수 있도록 다른 구성을 가지고 있습니다.

이 옵션들 각각을 언제 사용해야 하는지 봅시다.

가능한 한 배경 세션을 사용해야 합니다.

이것은 우리가 바로 데이터를 얻거나 보내고 싶을 수도 있는 개발자로서의 우리의 첫 번째 본능이 아닐 수도 있다.

하지만 정말 그것에 대해 생각해봐.

앱이 전경이나 가장 앞쪽에 있는 동안 전경 세션을 완료해야 하며, 가장 짧은 작업을 제외한 모든 작업에는 시간이 충분하지 않습니다.

고객의 커뮤니케이션 작업이 실패하면 고객의 경험에 대해 생각해 보세요.

그래서, 고객을 배려하고 각 커뮤니케이션 작업을 신중하게 평가하고 "백그라운드에서 할 수 있을까요?"라고 물어보세요.

백그라운드 URL 세션은 언제든지 통신이 지연되고 대규모 데이터 전송을 위한 올바른 선택입니다.

또한 앱에 푸시 알림을 보내 새 데이터를 사용할 수 있음을 알리고 백그라운드 업데이트를 시작할 수 있습니다.

배경 전송의 정확한 타이밍은 시스템 조건에 따라 달라집니다.

백그라운드에서 서버에 데이터를 보내는 예를 살펴보겠습니다.

예를 들어, 웹 서버를 통해 저장하고 싶은 응용 프로그램에 대한 설정이 있다면, 고객이 저장하면 시계에 저장한 다음 백그라운드에서 서버로 보낼 수 있습니다.

그렇게 하기 위해, 나는 서버 통신 작업을 처리하기 위해 백그라운드 URL 세션 클래스를 만들었다.

우리의 URL 세션에는 나중에 찾는 데 사용할 수 있는 고유 식별자가 있는 백그라운드 구성이 있습니다.

세션의 작업을 처리해야 할 때 세션이 백그라운드에서 앱을 실행해야 함을 나타내기 위해 전송 시작 이벤트 속성을 true로 설정하십시오.

많은 양의 데이터를 전송하는 경우, 시스템이 최상의 성능을 위해 장치에 최적의 시간에 전송을 예약할 수 있도록 URL 세션 구성의 isDiscretionary 속성을 true로 설정해야 합니다.

이 경우, 고객에게 Wi-Fi와 전원에 연결될 때까지 다운로드가 이루어지지 않을 수 있음을 알려야 합니다.

데이터를 보낼 준비가 되면, 백그라운드 세션을 예약하기 위해 전송을 대기해야 합니다.

우리는 서버에 대한 설정 업데이트의 내용으로 URL 요청을 만들고 구성할 것입니다.

그런 다음, 우리는 세션에서 우리의 요청에 대한 작업을 만들 것입니다.

이 단순화된 예에서, 저는 제 세션에 하나의 작업만 추가하고 있지만, 효율성을 위해 세션에 여러 요청을 추가할 수 있습니다.

나중에 다운로드를 시작하려면 earliestBeginDate를 설정하세요.

시스템은 백그라운드 예산, 네트워크 및 시스템 조건에 따라 작업이 시작되는 실제 시간을 결정할 것입니다.

활성 시계 페이스에 합병증이 있는 경우 앱은 시간당 최대 4개의 백그라운드 새로 고침 작업을 받을 수 있으므로, 시스템에 의해 지연되지 않도록 최소 15분 간격으로 작업을 예약하십시오.

나는 진행 중인 세션 목록에서 이 세션을 보류하고 있다.

시스템이 내 URL 요청이 완료되었음을 알려주면, 이것은 나중에 중요해질 것이다.

작업에서 "이력서"를 호출하면 실제로 시작되므로, 이것을 호출하는 것이 중요합니다.

마지막으로, 나는 세션에 관찰자가 있을 경우를 대비하여 대기 상태로 설정했다.

시스템은 확장 대리인에게 전송된 백그라운드 작업을 사용하여 백그라운드 요청이 처리되면 앱에 알릴 것입니다.

우리가 그 작업을 처리하려면, WK 확장 위임을 준수하는 클래스를 만들고 handle(_ backgroundTasks:) 함수를 구현해야 합니다.

백그라운드 URL 세션 새로 고침 작업의 경우, 진행 중인 요청 목록에서 세션을 찾을 것입니다.

만약 우리가 그것을 가지고 있다면, 우리는 세션의 백그라운드 새로 고침 작업을 세션 목록에 추가하기 위해 세션의 기능을 호출할 것입니다. 그래서 우리는 데이터 처리를 완료하자마자 시스템에 알릴 수 있습니다.

잠시 후에 이걸 보여줄게.

목록에서 세션을 찾을 수 없다면, 작업을 완료로 표시해야 합니다.

완료하자마자 항상 배경 새로 고침 작업을 완료하는 것이 매우 중요합니다.

백그라운드 작업 호출을 받기 위해 해야 할 일이 하나 더 있습니다: 확장 대리인을 앱에 연결해야 합니다.

이를 위해 우리는 확장 위임 클래스와 함께 WK 확장 위임 어댑터 속성 래퍼를 사용하고 앱에 속성을 추가할 것입니다.

이제, 시스템은 우리의 백그라운드 작업을 처리하기 위해 확장 대리인을 호출할 것이다.

확장 대리인에서, 우리는 기존 세션에 백그라운드 작업을 추가하기 위해 이 기능을 호출했습니다.

이 작업을 백그라운드 작업 목록에 추가하면 URL 데이터 처리를 완료하자마자 완료로 표시할 수 있습니다.

이제, 우리는 전체 왕복 여행을 연결했고, 우리가 해야 할 일은 데이터를 얻고 시스템에 우리가 끝났다는 것을 알리는 것뿐입니다.

우리의 URL 세션 다운로드 대리인은 우리의 요청이 완료되면 호출될 것입니다.

다운로드 작업에서 파일에서 받은 데이터를 처리하세요.

이 항목을 앱에서 액세스할 수 있는 디렉토리로 옮기거나 파일의 데이터를 빠르게 처리하는 것이 중요합니다.

이 작업이 완료되면, 다운로드한 파일이 삭제됩니다.

우리는 확장 대리인으로부터 더 이상 백그라운드 작업을 받지 않을 것이기 때문에 진행 중인 세션 목록에서 이 세션을 제거하고 있으며, 관찰자가 있을 경우를 대비하여 상태를 완료로 설정하고 있습니다.

마지막으로, 우리는 배경 작업을 완료하고 있습니다.

이것은 시스템이 우리가 백그라운드 처리를 완료했다는 것을 알려준다.

당신이 이것을 확실히 하는 것은 단지 좋은 Watch 앱 시민이 되는 것이 아닙니다.

그것은 시스템이 배경 제한을 초과하여 앱을 종료하는 것을 방지합니다.

그리고 그게 다야!

우리는 모두 백그라운드에서 설정을 보내고 업데이트를 받는 것을 마쳤다.

전체 구현에서 오류와 인증 문제를 처리하고 싶지만, 기본 단계를 제공합니다.

사람이 앱과 상호 작용하는 동안 빠른 서버 통신을 위해 포그라운드 URL 세션을 사용하세요.

이것의 좋은 예는 최신 운동 목록이나 오늘의 명상을 얻는 것이다.

포그라운드 URL 세션은 데이터를 가져오고 보내는 전력 효율이 낮은 방법이며, 2분 반의 타임아웃이 시행됩니다.

하지만 실제로, 당신은 그 한계보다 훨씬 빠른 상호 작용에 대한 전경 세션을 목표로 삼아야 합니다.

URL 세션은 서버와 직접 범용 통신을 위한 가장 좋은 방법입니다.

그들은 동반 iPhone 앱에 의존하지 않으며, 가족 설정을 지원하는 앱과 함께 사용할 수 있습니다.

데이터 전송을 지연시킬 수 있는 곳과 항상 더 많은 양의 데이터를 전송하기 위해 백그라운드 세션을 사용하세요.

URL 세션에 대해 자세히 알아보려면, 개발자 앱이나 온라인에서 "컴플리케이션을 최신 상태로 유지" 및 "배경 실행 신비화"를 확인하세요.

URL 세션 외에도, 스트리밍 오디오 앱을 구축하는 경우, 소켓은 서버와 직접 통신하는 또 다른 옵션입니다.

활성 스트리밍 오디오 세션의 맥락에서 Watch 앱에서 HTTP 라이브 스트리밍 또는 웹 소켓을 사용할 수 있습니다.

소켓 사용에 대한 자세한 내용은 개발자 앱이나 온라인에서 "watchOS 6에서 오디오 스트리밍" 세션을 확인하세요.

우리는 많은 것을 다루었으므로, 우리가 본 모든 옵션 중에서 어떻게 선택할 수 있는지 요약해 봅시다.

모든 사람의 장치에 동기화할 수 있는 작은 민감한 데이터의 경우, iCloud 동기화가 있는 키체인을 선택하십시오.

데이터베이스를 iCloud에 저장하고 모든 사람의 장치와 공유하려면, CloudKit으로 Core Data를 선택하세요.

컴패니언 iPhone 및 Watch 앱의 경험을 최적화하거나, 컴패니언 앱의 한 장치에서만 사용할 수 있는 데이터를 공유하려면, Watch Connectivity를 선택하세요.

서버와 직접 통신하려면, URL 세션을 선택하세요.

오디오 앱을 스트리밍하는 경우, 소켓을 사용할 수도 있습니다.

가족 설정을 사용하거나 셀룰러 데이터 전송을 사용하는 고객을 지원하려면, iCloud 동기화가 있는 키체인, CloudKit이 있는 Core Data, URL 세션 또는 소켓을 선택해야 합니다.

작업에 적합한 도구를 선택하는 데 도움이 되는 솔루션을 선택하기 전에 데이터 유형, 소스 및 목적지, 고객 청중에 대해 생각해 보세요.

그리고 실제 조건에서의 동작을 확인하기 위해 배포하기 전에 디버거에 연결되지 않은 장치에서 항상 앱을 테스트하십시오.

Watch 앱에서 데이터 전송을 위한 모든 훌륭한 도구에 대해 배우러 와주셔서 감사합니다.

우리는 네가 다음에 뭘 만드는지 빨리 보고 싶어.

[음악].