102

WWDC2021 플랫폼 연합에 오신 것을 환영합니다.

WWDC는 우리가 개발자 커뮤니티로 모여 가까운 미래에 우리 플랫폼에 대해 무엇을 가지고 있는지 살펴보는 시간이다.

나는 또한 당신이 한 일이 우리 모두가 지난 한 해를 어떻게 이겨낼 수 있도록 도왔는지에 대해 조금 반성하고 싶습니다.

당신의 앱과 창의성은 사람들이 특별한 상황에서 일을 계속 움직일 수 있는 새로운 방법을 찾을 수 있게 해주었습니다.

개발자들이 차이를 만드는 훌륭한 사례가 많이 있으며, 우리는 당신이 세상을 더 빨리 만들 수 있도록 돕기 위해 우리가 할 수 있는 일이 훨씬 더 많다는 것을 알고 있습니다.

그래서 올해 우리는 당신이 더 많은 것을 성취할 수 있도록 설계된 도구, 기술 및 API를 제공하고 있습니다.

그리고 우리는 오늘 우리가 그것을 실현하고 있는 세 가지 큰 영역에 대해 이야기할 것이다.

먼저, 우리는 당신이 훌륭한 앱을 만드는 데 도움이 되는 것들에 대해 이야기할 것입니다: Xcode와 Xcode Cloud, Swift, 그리고 UI 프레임워크.

그런 다음 Apple 기술이 증강 현실과 사용자가 새로운 방식으로 세상을 볼 수 있는 그래픽 기술로 가능한 앱을 구축하는 데 어떻게 도움이 될 수 있는지 살펴보겠습니다.

마지막으로, 포커스, 스크린 타임 API, 위젯 및 공유 플레이와 같은 새로운 기능을 통해, 우리는 당신이 만든 앱이 사용자가 서로 더 잘 연결하고 그들에게 가장 중요한 것의 우선 순위를 정하는 데 도움이 될 수 있는 방법을 보게 될 것입니다.

앱 개발부터 시작합시다.

더 말씀드리기 위해, 여기 앨리슨, 론다, 그리고 앤드류가 있습니다.

오늘날 앱을 개발하는 것은 꽤 정교한 과정이며 집중력을 유지하고 효과적으로 유지하기 위해 도구에 의존합니다.

이 과정의 가장 필수적인 부분은 코딩이지만, 오늘날 양질의 앱을 구축하는 것은 많은 전문 단계와 도구를 포함한다.

다양한 구성에서 코드를 테스트해야 합니다.

당신의 팀은 당신의 코드를 검토하고, 당신은 변경 사항을 공유 저장소에 통합합니다.

당신은 베타 테스터에게 전달합니다.

그리고 그들의 피드백을 바탕으로, 당신은 지속적으로 앱을 다듬습니다.

이 모든 단계들은 중요하며 모든 단계를 올바르게 하는 것이 중요하다.

모든 것을 끝내기 위해 종종 다른 앱, 웹사이트 및 서비스 사이를 이동해야 합니다.

이 모든 컨텍스트 전환은 당신의 초점을 방해하고 코드에서 멀어지게 합니다.

마찰을 제거하고 모든 것을 하나로 모으기 위해 그것에 대해 무언가를 할 때입니다. 그래서 당신과 당신의 팀은 훌륭한 경험을 만드는 데 집중할 수 있습니다.

그것이 우리가 Xcode Cloud를 만든 이유입니다: Xcode에 바로 내장되어 클라우드에서 호스팅되는 새로운 지속적인 통합 및 전달 서비스.

그것은 당신이 개발 과정의 모든 단계를 관리하는 데 도움이 되며, 중요한 것들을 쉽게 바로잡을 수 있게 해준다.

Xcode Cloud는 모든 Apple 플랫폼의 개발을 지원하기 위해 처음부터 설계되고 구축되었습니다.

Xcode에 깊이 통합되어 한 곳에 집중하여 시간을 절약할 수 있습니다.

Apple의 클라우드 인프라를 활용하여 배포를 위한 빌드, 테스트 및 코드 서명을 오프로드합니다.

그것은 Test Flight 및 App Store Connect와 같은 Apple 서비스뿐만 아니라 모든 주요 git 기반 소스 제어 제공 업체와 통합됩니다.

심지어 개발 과정의 다른 측면에 연결하는 데 도움이 되는 REST API도 있습니다.

그리고 그것은 당신과 당신의 프로젝트를 보호하기 위해 고급 보안으로 만들어졌습니다.

이것은 Xcode의 원래 출시 이후 개발자 도구에 대한 가장 큰 투자이며, 이 모든 것은 당신이 이미 알고 있는 경험 안에 있습니다.

Xcode 13에서 Xcode Cloud 워크플로우를 만들고 관리하면 테스트 스위트, 코드 서명 및 TestFlight 배포가 처리되는 동안 코드에 머무를 수 있습니다.

그리고 Xcode Cloud가 빌드를 마치면, 결과는 Xcode 바로 안에 있습니다.

이건 네가 일하는 방식을 바꿀 거야.

그건 이미 우리가 일하는 방식을 바꾸고 있어.

Apple의 많은 팀은 Xcode 자체 뒤에 있는 팀을 포함하여 Xcode Cloud를 개발 프로세스에 통합했습니다.

Xcode Cloud를 시작하는 것은 믿을 수 없을 정도로 쉽다.

제품 선택, 워크플로우 확인, 소스 코드에 대한 액세스 권한 부여, App Store Connect와의 연결 등 네 단계만 거치면 됩니다.

SwiftUI 샘플 앱인 Fruta와 함께 과정을 살펴봅시다.

Xcode Cloud는 내 프로젝트의 제품과 플랫폼을 자동으로 감지하므로, 다음을 클릭하겠습니다.

그런 다음 Xcode Cloud에 무엇을 해야 하고 언제 해야 하는지 알려주는 제안된 워크플로우를 검토할 것입니다.

기본 행동은 내가 만드는 모든 변화를 구축하며, 그것이 바로 내가 원하는 것이다.

이제, Xcode Cloud는 내 소스 코드의 호스팅된 계정에 안전하게 연결할 것이다.

나는 이미 내 자격 증명을 사용하여 접근 권한을 부여했기 때문에, 그냥 넘어갈 수 있다.

마지막으로, Xcode Cloud는 Fruta가 이미 App Store에 존재한다는 것을 인식하고 정보를 확인해 달라고 요청합니다.

만약 당신의 앱이 아직 등록되지 않았다면, Xcode Cloud가 당신을 위해 그것을 할 것입니다.

나는 완료를 클릭하고 클라우드에서 첫 번째 빌드를 시작할 것이다.

빌드가 완료되면, 보고서 네비게이터에서 결과를 볼 수 있을 것이다.

그리고 그렇게, 저는 Xcode 내에서 1분 안에 앱에 대한 지속적인 통합과 배달을 설정했습니다.

결과가 어떻게 제시되는지 자세히 살펴봅시다.

보고서 네비게이터의 클라우드 탭에서 각 워크플로우에 대해 실행된 빌드는 분기 또는 풀 리퀘스트별로 그룹화됩니다.

개별 빌드를 선택하면 언제 어떻게 시작되었는지, 어떤 Xcode 및 macOS 버전이 사용되었는지, 모든 작업의 상태와 같은 정보와 함께 개요를 제공합니다.

출처를 확인하거나 재건을 시작할 수도 있습니다.

기본 워크플로우는 시작하기에 좋지만, Xcode Cloud는 앱을 분석하거나 Test Flight 또는 App Store에 새 릴리스를 배포하는 것과 같은 목표를 달성할 수 있는 더 많은 힘을 제공합니다.

우리 팀은 모든 새로운 풀 리퀘스트에서 iOS 테스트를 실행하기를 원하므로, 지금 그 워크플로우를 설정합시다.

이번에는 Xcode Cloud 제품 메뉴로 돌아가서 워크플로우 관리를 선택하고, 플러스를 클릭하여 새 것을 추가할 것입니다.

워크플로우 풀 리퀘스트의 이름을 지정한 다음, 주요 지점을 대상으로 하는 모든 풀 리퀘스트에서 실행되도록 시작 조건을 편집하겠습니다.

저는 우리의 테스트가 Xcode와 macOS의 공개 베타 버전에서 실행되기를 원하므로, 여기서 설정하겠습니다.

다음으로, 워크플로우의 작업을 살펴보고 테스트 작업을 추가한 다음 프로젝트에서 기존 iOS 테스트 계획을 선택할 것입니다.

내 앱에 대한 광범위한 테스트 범위를 얻기 위해, Xcode Cloud는 내가 사용할 시뮬레이터를 추천한다.

단 두 번의 클릭만으로, 나는 내 작업 흐름을 위해 엄선된 아이폰과 아이패드 세트를 얻는다.

이제 그건 꽤 깔끔해.

우리 팀은 또한 빌드가 성공하거나 실패할 때 통보를 받아야 한다.

그래서 나는 알림 포스트 액션을 추가하고 우리 팀의 슬랙 채널을 추가할 것이다.

저장을 클릭하면, 우리의 워크플로우가 Xcode Cloud의 제품에 추가되었습니다.

이제, 우리 팀은 우리가 만들고 있는 변화에 자신감을 더할 것이다.

사용자 지정 빌드 스크립트를 실행하고 Xcode Cloud의 웹 훅과 API를 사용하여 귀하와 귀하의 팀이 의존하는 다른 시스템과 통합하는 것을 포함하여 워크플로우로 할 수 있는 일이 훨씬 더 많습니다.

그리고 방금 Xcode에서 본 워크플로우 관리 및 빌드 보고서는 웹의 App Store Connect에서도 사용할 수 있습니다.

이를 통해 귀하 또는 팀의 다른 구성원이 어디서나 Xcode Cloud를 쉽게 사용할 수 있습니다.

이제 Xcode Cloud 작업의 기본 사항을 보았으므로, 개발 주기의 각 특정 영역에서 어떻게 도움이 되는지 봅시다.

좋은 테스트를 작성하고 반복적으로 실행하는 것은 양질의 애플리케이션을 만드는 데 매우 중요하다.

Xcode Cloud를 사용하면 코드를 더 철저하고, 더 일관적이며, 더 효율적으로 테스트할 수 있습니다.

여러 플랫폼, 장치 시뮬레이터 및 OS 버전에서 여러 테스트 계획을 병렬로 실행하도록 Xcode 클라우드 워크플로우를 구성할 수 있습니다.

베타를 자신의 컴퓨터에 다운로드하기 전에 베타 OS 릴리스에서 Xcode Cloud에서 테스트를 실행할 수도 있습니다.

따라서 Xcode Cloud는 더 많은 것을 테스트하는 데 도움이 될 것이며 Xcode 13은 더 잘 테스트하는 데 도움이 될 것입니다.

우리의 앱 Fruta는 밝고 어두운 모습, 세로 및 가로 방향을 지원하며, 두 언어로 현지화합니다.

저는 Fruta의 가장 인기 있는 기능을 실행하는 일련의 사용자 경험 테스트를 진행하고 있습니다.

여기 내 테스트 코드에서, 나는 이 간단한 XC 테스트 API를 채택하여 각 변형에서 각 테스트를 자동으로 실행하여 이러한 테스트를 더욱 발전시킬 것이다.

가장 최근의 빌드와 내가 구성한 워크플로우 테스트 작업을 선택하여 Xcode Cloud의 테스트 범위를 살펴봅시다.

결과는 친숙한 Xcode 테스트 보고서에 표시됩니다.

이 테스트는 구성당 한 번씩 iOS 15를 실행하는 권장 iPad 시뮬레이터 세트를 실행하여 그 과정에서 스크린샷을 캡처했습니다.

Xcode 13은 그 결과를 검토하는 훌륭한 새로운 방법을 가지고 있다.

편집기 옵션 메뉴에서 새로운 갤러리 보기를 활성화하겠습니다.

내 테스트의 스크린샷은 함께 제시된 각 테스트의 모든 변형과 이미지에 표시됩니다.

모든 이미지를 보기 위해 더 멀리 축소할 수 있으며, 정말 관심이 있는 이미지를 찾으면 빠른 보기를 사용하여 전체 해상도로 볼 수 있습니다.

갤러리 보기를 사용하면 앱이 모든 조건, 언어 및 레이아웃에서 환상적으로 보이는지 쉽게 확인할 수 있습니다.

내 단위 테스트에서, 나는 네가 공감할 것이라고 확신하는 테스트 실패가 있어.

때때로 시험은 통과하고 때로는 실패한다.

우리 모두 전에 여기 와본 적이 있어.

그리고 Xcode 13이 도와드리겠습니다.

테스트 소스로 이동하고, 테스트 젬을 클릭하고, 테스트 반복 실행을 선택합니다.

그것을 100번 실행하여 더 나은 신뢰성을 얻자.

만약 내가 전에 이것을 하고 싶었다면, 나는 스스로 테스트를 여러 번 실행해야 할 것이다.

이제, 나는 도구가 모든 일을 할 때 가만히 앉을 수 있다.

내가 의심했듯이, Xcode는 이 테스트가 매우 신뢰할 수 없다는 것을 보여주고 있다.

내 코드에 문제가 있는 게 틀림없어.

하지만 내가 그것을 고칠 수 있을 때까지, 나는 새로운 예상 실패 API를 채택하고 나머지 팀원들이 볼 수 있도록 신뢰성에 대한 메시지를 포함할 것이다.

내가 예상한 대로 되는지 확인하기 위해, 나는 제품 메뉴에서 사용할 수 있는 Test Again 기능을 사용할 것이다.

Xcode는 지난번에 한 일을 기억하기 때문에 정말 쉽다.

내 시험은 여전히 주장을 제기하고 있지만, 더 이상 실패하지 않는다.

그리고 나는 길에서 그것을 고치라는 부드러운 알림이 있다.

그게 바로 내가 필요한 거야.

보시다시피, Xcode 13과 Xcode Cloud는 앱이나 테스트에서 그 어느 때보다 빠르게 문제를 찾고 해결할 수 있도록 도와줍니다.

테스트는 당신의 코드에 대한 통찰력의 한 형태입니다.

또 다른 하나는 코드 검토와 풀 리퀘스트를 통해 동료들의 입력입니다.

코드에 집중할 수 있도록, Xcode 13은 팀과의 이러한 토론을 편집기로 직접 가져옵니다.

제가 작업하고 있는 기능 브랜치에서 풀 리퀘스트를 만들었습니다.

내 기능은 사용자가 가장 맛있는 스무디를 좋아할 수 있게 해준다.

왼쪽의 네비게이터에서 새로운 소스 제어 변경 탭을 볼 수 있습니다.

그것은 내가 로컬로 수정한 모든 파일, 내 풀 리퀘스트, 그리고 포함된 변경 사항을 보여준다.

풀 리퀘스트를 선택하면, 진행 중인 모든 활동과 대화에 대한 전체 개요를 얻을 수 있습니다.

그리고 스크롤할 때, 나는 내 설명과 흥미로운 이벤트와 시간, 그리고 내 팀의 코드 피드백과 내가 만든 새로운 커밋을 본다.

하지만 우리는 Xcode Cloud를 사용하고 있으며, Pull Request 워크플로우는 내가 만드는 모든 커밋을 구축하고 테스트하고 있습니다.

맨 위에서, 나는 내 모든 워크플로우에서 라이브 상태를 얻는다.

론다는 내 코드를 더 좋게 만들기 위한 몇 가지 제안이 있다.

소스 코드로 이동하면, 편집자에서 론다의 댓글을 볼 수 있습니다.

이 코드는 사용자가 로그인해야 합니다.

그래서 레시피를 선호하기 전에 로그인할 수 있도록 재작업해야 합니다.

론다에게 내가 변화를 위해 노력하고 있다는 것을 알리고 그녀에게 미리 알려줄게: 그녀가 먼저 로그인하지 않으면 빌드에서 충돌할 수도 있어.

풀 리퀘스트 외에도, Xcode 13은 로컬 변경 사항을 정말 쉽게 검토할 수 있게 해준다.

내가 작업하고 있는 파일로 이동할 때, Xcode는 이 아름다운 새로운 인라인 프레젠테이션에서 최신 개정판에 대한 변경 사항의 차이를 자동으로 표시합니다.

업데이트된 수정 선택기를 사용하여 로컬 변경 사항을 기록의 모든 지점이나 태그와 비교할 수 있습니다.

무엇보다도, 창의 다른 파일에서 여러 편집기 분할을 사용하는 경우에도 모든 편집기에서 코드 검토를 사용할 수 있습니다.

그리고 이제 두 가지 옵션으로 - 인라인 비교와 나란히 - 나는 내가 작업하고 있는 것에 대한 완벽한 프레젠테이션을 선택할 수 있다.

마지막 코드 변경과 코멘트로, 우리 팀의 통찰력을 검토하고 응답하는 것이 더 쉬울 수 없었다.

훌륭한 경험을 제공하는 것의 일부는 앱을 팀과 베타 테스터의 손에 넣는 것입니다.

Xcode Cloud는 그 과정을 수월하게 만든다.

Xcode 13은 이제 클라우드를 사용하여 앱의 코드 서명에 필요한 모든 것을 안전하게 얻고 관리합니다.

이것은 더 이상 Mac에서 인증서와 프로필을 최신 상태로 유지하는 것에 대해 걱정할 필요가 없다는 것을 의미합니다.

Xcode Cloud 워크플로우의 아카이브 작업은 동일한 시스템을 사용하여 배포를 위해 앱에 서명합니다.

그리고 Xcode Cloud 워크플로우에 포스트액션을 추가하면, 새로운 Mac용 Test Flight와 함께 macOS를 포함한 모든 Apple 플랫폼에 Test Flight를 통해 베타를 자동으로 전달할 수 있습니다.

최신 빌드를 전달하면, 베타 테스터로부터 더 많은 통찰력을 얻을 수 있습니다.

Xcode 13에는 App Store Connect에서 찾을 수 있는 것과 동일한 진단과 피드백을 더 잘 연결하기 위한 주요 개선 사항이 포함되어 있습니다.

테스트 비행 앱의 충돌 로그는 이제 몇 분 안에 주최자에게 직접 전달됩니다.

그리고 주최자는 이제 사용자가 충돌 보고서에 첨부한 서면 피드백을 보여줍니다.

이것은 충돌을 분석할 때 귀중한 맥락과 앱 사용에 대한 더 넓은 시각을 제공합니다.

앤드류의 테스트를 통과한 후, Xcode Cloud는 빌드를 Test Flight에 직접 제출했다.

방금 내 휴대폰에서 Fruta의 새로운 iOS 빌드에 대한 알림을 받았고, Mac용 Test Flight의 Mac 버전이 있습니다.

Fruta는 멀티플랫폼 프로젝트이기 때문에, 나는 두 곳에서 동시에 이 새로운 빌드를 얻고 있다.

이 빌드를 설치하고 새로운 기능이 어떤 느낌인지 보게 되어 정말 기쁩니다.

그래서 난 지금 그걸 할 거야.

나는 여전히 몇 개의 거친 가장자리가 있다고 생각한다.

내가 이 스무디를 좋아하려고 하면 앱이 다운될지도 몰라.

그리고 확실히, 그건 그래.

테스트 플라이트의 충돌 피드백 UI를 사용하여 앤드류에게 알릴 수 있습니다.

앱이 충돌했을 때 내가 무엇을 하고 있었는지 설명할 것이고, 그는 문제를 해결하고 다음 번에 더 일찍 잡힐 수 있도록 테스트를 추가할 수 있을 것이다.

저는 주최자에서 가장 최근의 앱 릴리스를 보고 있습니다. 마지막 날로 필터링할 때, 여기 론다가 방금 경험한 충돌이 있습니다. 완전히 상징화되고 조사할 준비가 되었습니다.

새로운 시험 비행 피드백 검사관은 그녀의 의견, 앱 빌드, 버전 및 장치에 대한 정보를 포함합니다.

그리고 나는 심지어 그녀의 경험에 대해 더 알아보기 위해 그녀에게 연락할 수도 있다.

더 좋은 점은: Xcode는 내 코드에서 이 충돌이 어디에서 왔는지 알고 있다.

그래서 한 번의 클릭으로, 나는 내 프로젝트에서 그것을 열 수 있다.

디버그 네비게이터는 전체 백 트레이스이다.

내 소스 편집기는 주장을 강조하고 내 풀 리퀘스트 대화도 표시됩니다.

바로 여기 Xcode에서 이 문제를 해결하는 데 필요한 것을 갖는 것은 믿을 수 없을 정도로 흥미롭다.

우리는 당신이 매일 사용하는 도구에 필요한 모든 것, 즉 테스트 결과, 동료의 의견, 사용자 피드백을 가져왔습니다. 이 모든 것은 당신에게 더 큰 통찰력을 제공하고 앱의 다음 훌륭한 버전을 제공할 수 있도록 도와줍니다.

Xcode Cloud는 개인 정보 보호와 보안을 염두에 두고 구축되었습니다.

소스, 액세스 토큰, 로그인 키 및 빌드 아티팩트를 포함한 데이터는 안전하게 처리됩니다.

그리고 우리는 서비스를 실행하기 위해 가능한 최소한의 데이터를 사용합니다.

올해는 우리의 개발자 도구에 큰 해이다.

Xcode 13과 Xcode Cloud를 사용하면 그 어느 때보다 적은 시간과 노력으로 모든 Apple 플랫폼에서 양질의 앱을 구축하고 제공할 수 있습니다.

Xcode Cloud는 처음에는 무료, 제한된 베타 버전으로 제공될 것이다.

개발자 프로그램 계정 소유자는 developer.apple.com에서 지금 바로 가입할 수 있습니다.

우리는 내년에 모든 개발자가 이것을 사용할 수 있도록 노력하면서 점차 더 많은 팀을 추가할 것입니다.

우리는 이번 가을에 가격과 가용성에 대한 자세한 내용을 제공할 것입니다.

Xcode 13 또는 App Store Connect의 Xcode Cloud 탭에서 등록 상태를 확인할 수 있습니다.

여기에서 본 모든 것 외에도, Xcode의 Swift 지원에 대한 몇 가지 훌륭한 개선 사항을 포함하여 올해 세션에서 배울 수 있는 개발자 도구의 엄청난 개선 사항과 기능 목록이 있습니다.

그것은 올해 스위프트의 흥미진진한 이야기의 시작일 뿐이다.

더 말씀드리면, 여기 조쉬, 홀리, 맷이 있습니다.

스위프트는 애플의 플랫폼과 그 너머의 개발자들에게 중요한 언어가 되었다.

그것은 우리의 가장 현대적인 기술을 가능하게 하며, SwiftUI, CreateML 및 새로운 StoreKit 2와 같은 차세대 프레임워크의 기초 역할을 합니다.

Xcode Previews 및 Swift Package Manager와 같은 강력한 도구로 가장 복잡한 앱을 만들 수 있는 현대적이고 형식에 안전한 언어를 제공하여 개발을 가속화합니다.

그리고 Swift Playgrounds에서 코딩 방법을 배울 수 있는 매력적인 콘텐츠와 수업이 있어 신규 이민자에게 친근하고 접근하기 편리합니다.

이제, 기술이 당신에게 좋은지 확인하는 핵심 부분은 우리가 그것을 채택하는 것입니다.

음악과 같은 유명한 앱은 몇 년 동안 Swift로 작성되었으며, 위젯과 같은 시스템 차원의 기능은 SwiftUI로 처음부터 설계되었습니다.

Learning Swift와 SwiftUI는 모든 플랫폼을 위한 완전한 네이티브 앱을 구축할 수 있는 공통적이고 강력한 도구와 API 세트를 제공합니다.

그리고 스위프트 자체가 오픈 소스이기 때문에, 우리는 지난 몇 년 동안 수많은 새로운 기능과 기능을 제공하기 위해 많은 사람들과 함께 일할 수 있었습니다.

이제, 모든 앱을 구축하는 데 중요한 기능 중 하나는 동시성 지원이다.

그리고 여기 그것에 대해 말해줄 홀리가 있어.

당신이 그것에 대해 생각하든 말든, 당신은 오늘 동시 코드를 작성하고 있습니다.

동시성을 사용하면 앱이 동시에 여러 작업을 수행할 수 있으며, 사용자가 도시를 선택하는 동안 예측 데이터를 가져오는 날씨 앱과 같이 백그라운드에서 작업을 수행하는 동안 앱이 사용자 입력에 반응할 수 있도록 도와줍니다.

그리고 비디오 앱에서 복잡한 시각 효과를 렌더링하는 것과 같이 무거운 계산을 위한 고성능을 달성하기 위해 멀티코어 프로세서를 활용하는 것이 필수적이다.

하지만 언어 지원이 없다면, 동시 코드를 작성하는 것은 정말 어렵다.

그래서 우리는 스위프트에 동시성에 대한 일류 지원을 제공하고 있습니다.

언어로 동시성을 구축하려는 우리의 접근 방식은 스위프트 자체의 동일한 핵심 원칙을 따르며, 전체 클래스의 프로그래밍 실수를 제거하는 현대적이고 안전하며 빠른 코드를 더 쉽게 작성할 수 있도록 합니다.

먼저, 우리가 스위프트에 동시성을 구축하기 위해 어떻게 현대적인 접근 방식을 취했는지에 대해 이야기해 봅시다.

오늘날, 우리는 현대 코드를 당신이 하고 싶은 것을 체계적이고 표현하기 쉽다고 생각합니다.

불행히도, 오늘날의 비동기 코드의 대부분은 구조화되지 않고 표현하기 어려운 완성 핸들러를 사용한다.

비동기 함수를 더 쉽게 표현하기 위해, 우리는 현대적인 비동기/대기 패턴을 스위프트에 구축했습니다.

이제 비동기 키워드로 비동기 함수를 표시할 수 있습니다.

함수가 호출되면, 호출자가 비동기 함수의 결과를 기다리는 동안 다른 작업을 수행할 수 있음을 나타내기 위해 await 키워드를 사용합니다.

비동기/기다림이 완료 핸들러를 가져오는 개선 사항을 이해하기 위해, 예를 살펴봅시다.

내가 스위프트 컴파일러에서 작업하지 않을 때, 나는 춤추는 것을 좋아한다.

쇼를 준비하기 위해, 무용단은 먼저 워밍업을 해야 하고, 승무원들은 창고에서 풍경과 소품을 가져온 다음 무대가 준비된다.

그 모든 것이 끝나면, 댄서들은 오프닝 포지션으로 이동할 수 있다.

다음은 완료 핸들러를 사용하는 "prepareForShow"의 비동기 구현입니다.

이 코드가 달성하려고 하는 것은 정말 간단하지만, 코드는 복잡하다.

그것은 실행 흐름을 부자연스럽게 만드는 중첩된 완성 핸들러를 사용하므로, 코드는 읽기가 정말 어렵다.

이 예제에서 async/await를 채택하면 이제 직선에 있는 코드가 남습니다.

이 코드는 훨씬 이해하기 쉽다.

제어 흐름은 다른 기능과 마찬가지로 위에서 아래로 간다.

스위프트에서 익숙한 것과 같은 방식으로 오류를 처리하고 값을 반환합니다.

모든 일반 제어 흐름 구조도 사용할 수 있습니다.

따라서 조건부 논리를 추가하는 것은 쉽기 때문에, 리허설 중에 기능이 다르게 동작합니다.

Async/await는 이미 알고 있는 도구를 활용하여 비동기 코드를 더 쉽게 작성할 수 있게 해준다.

또한 구조화된 동시성을 사용하여 필요한 곳에 동시성을 도입하는 것이 더 쉽습니다.

구조화된 동시성은 추론하기 쉽게 하기 위해 동시 작업을 구성하는 방법이다.

prepareForShow에 동시성을 도입해 봅시다.

지금, 그 기능은 댄서들이 풍경을 가져오기 시작하기 전에 워밍업을 마칠 때까지 기다리지만, 이러한 작업은 병렬로 수행될 수 있다.

구조화된 동시성을 사용하면 다음과 같은 로컬 변수와 비동기/대기를 사용하여 동시 자식 작업을 쉽게 만들 수 있습니다.

이제, 코드는 'async let' 변수를 사용하여 부모와 동시에 실행되는 자식 작업을 만듭니다.

그래서, 그 회사는 워밍업을 하고 풍경을 가져오는 것은 나머지 prepareForShow와 동시에 운영될 것이다.

우리가 그 아동 과제의 결과가 필요할 때, 우리는 결과를 기다린다.

fetchStageScenery는 동시에 실행되기 때문에, prepareForShow를 사용해야 할 때 결과가 아직 준비되지 않았을 수 있으므로, 결과에 대한 액세스는 비동기적으로 수행되어야 합니다.

스위프트의 동시성 모델은 또한 안전하도록 설계되었다.

스위프트가 선택 사항으로 널 포인터 실수를 제거하는 것처럼, 컴파일러는 이제 공유 상태에 대한 액세스가 동시 작업 간에 안전하게 조정되도록 함으로써 일반적인 동시성 문제를 제거하는 데 도움이 될 것이다.

이 안전한 동시성 모델의 핵심 부분은 배우들을 중심으로 만들어졌다.

배우들은 안전한 동시 프로그래밍을 위한 업계에서 입증된 모델이며, 강력한 동기화 프리미티브이다.

개념적으로, 행위자는 상호 배타적인 접근만을 제공함으로써 자신의 상태를 보호하는 대상이다.

이것은 동시 액세스와 함께 제공되는 낮은 수준의 데이터 경쟁을 완전히 제거합니다.

이 개념은 배우로부터 영감을 받은 파견 대기열이 있는 수업에 이미 사용할 수 있는 패턴과 유사하기 때문에 친숙하게 들릴 수 있습니다.

이 패턴에서, 클래스의 인스턴스 속성은 상호 배제를 유지하기 위해 직렬 디스패치 큐를 사용하여 신중하게 액세스됩니다.

하지만 이 패턴은 실수하기 쉽다.

많은 상용구가 있으며, 수동으로 대기열을 한 번만 사용하고 코드에 경쟁 조건을 도입하는 것을 잊어버리는 것은 너무 쉽습니다.

이러한 문제를 해결하기 위해, 우리는 배우들의 핵심 아이디어로 돌아가서, 그것을 일류 구성으로 스위프트에 구축했다.

이제, 간단한 키워드로 스위프트에서 배우 유형을 선언할 수 있습니다.

그것은 당신이 이미 알고 있는 구조물과 같은 구조를 가지고 있으며, 수동 동기화가 필요하지 않습니다.

스위프트 언어에 내장된 액터를 사용하면 액터 상태에 대한 액세스를 동기화하여 자동으로 관리할 수 있습니다.

액터가 자신의 속성에 직접 접근할 수 있으며, 외부에서 액터와 상호 작용하는 것은 상호 배제를 보장하기 위해 비동기/대기를 사용합니다.

배우 개념은 너무 강력해서 UI 작업과 같은 것에 대한 메인 스레드의 적절한 사용인 동시성 문제의 또 다른 일반적인 원인을 해결합니다.

오늘날, 메인 스레드에서 실행되어야 하는 API를 호출할 때마다 메인 큐로 수동으로 디스패치해야 합니다.

이제, 우리는 API가 항상 메인 액터를 사용하여 메인 스레드에서 실행된다는 것을 명시하는 방법을 소개하고 있습니다.

API가 항상 메인 액터에서 실행되도록 하는 것은 MainActor 속성으로 선언에 주석을 달는 것만큼 쉽습니다.

다른 배우들과 마찬가지로, 메인 배우에서 실행되는 기능을 호출하는 것은 그저 기다리는 것일 뿐이다.

전체적으로, 이것은 당신이 스스로 관리할 필요가 없는 안전한 동시 코드를 작성하는 것이 더 쉽다는 것을 의미합니다.

우리가 언어로 직접 동시성에 대한 지원을 구축할 때, 그것은 우리에게 동시 코드의 성능을 더 잘 최적화할 수 있는 기회를 제공합니다.

Async/await를 통해 컴파일러는 코드의 동시성을 이해하여 보다 효과적인 최적화를 가능하게 합니다.

여기에는 참조 수와 인라인을 줄이고 과도한 컨텍스트 스위치와 같은 동시성 관련 성능 문제를 해결하는 것이 포함됩니다.

그리고 물론, 컴파일러가 앞으로 몇 년 동안 더 똑똑해짐에 따라 동시 코드는 훨씬 더 빨라질 것입니다.

SDK에는 이미 앱에서 사용하는 수많은 비동기 API가 있습니다.

우리는 이러한 비동기 API로 async/await를 활성화하도록 SDK를 개선했으므로, 기존 코드에서 async/await를 즉시 채택할 수 있습니다.

그리고 우리는 거기서 멈추지 않았어.

우리는 URL로 작업할 때, 비동기 I/O를 수행할 때 비동기/기다림을 활용하는 새로운 의도적으로 만들어진 API를 추가했으며, 심지어 파일을 통해 라인별로 비동기적으로 반복하는 지원을 추가했습니다.

Async/await는 비동기 코드를 표현하는 것을 자연스럽게 만들고, 구조화된 동시성은 동시 코드를 더 쉽게 추론할 수 있게 하며, 행위자는 동시 프로그램에서 공유 상태를 안전하게 모델링할 수 있도록 도와줍니다.

스위프트 동시성 모델은 이러한 기본적인 부분을 결합하여 당신을 더 효율적으로 만들고, 더 많은 힘을 주며, 동시 앱을 더 재미있게 만들 수 있도록 합니다.

물론, 그 언어는 퍼즐의 한 조각일 뿐이다.

스위프트로 구축된 프레임워크도 마찬가지로 중요하다.

이제, 조쉬에게 돌아가.

스위프트는 차세대 API의 기초이다.

동시성과 같은 새로운 기능으로, 우리는 언어와 프레임워크를 함께 진화시키고 있으므로, SwiftUI와 같은 주요 기술을 포함하여 SDK 전체에서 즉각적인 이점을 볼 수 있습니다.

2년 전, 우리는 플랫폼에서 UI 개발을 재창조하기 시작했다.

우리는 기존 애플리케이션에서 SwiftUI를 점진적으로 채택할 수 있는 핵심 API로 작게 시작했습니다.

작년에, 우리는 앱의 수명 주기를 설명하기 위해 API를 추가하여 첫 번째 코드 줄에서 SwiftUI로 완전히 앱을 개발할 수 있도록 했습니다.

그리고 올해 SwiftUI는 또 다른 큰 발걸음을 내딛고 있으며, 모든 Apple 플랫폼에서 모든 사용자에게 훌륭한 경험을 제공할 수 있도록 돕고 있습니다.

우리는 또한 우리의 앱을 구축하기 위해 API가 필요했기 때문에 당신의 앱에 중요하다는 것을 알고 있는 API에 집중했습니다.

그리고 당신의 피드백은 우리가 가장 중요한 API를 향상시키는 동시에 개발 경험을 개선하는 데 도움이 되었습니다.

올해, 우리는 지도, 사진 및 단축키와 같은 앱에서 SwiftUI를 사용하기 시작했습니다.

그리고 우리는 날씨와 같은 iOS 앱, Apple Pay 결제 시트와 같은 시스템 인터페이스, Find My와 같은 새로운 watchOS 앱을 완전히 SwiftUI로 재구성했습니다.

이것을 가능하게 하는 몇 가지 개선 사항을 보려면, Fruta를 개선할 수 있는 몇 가지 방법을 살펴봅시다.

우리는 모든 플랫폼에서 가장 유비쿼터스 구성 요소인 List로 시작할 것입니다.

이제 스무디를 가장 좋아하는 것으로 표시하기 위해 스와이프 동작을 쉽게 추가할 수 있습니다.

풀 투 리프레쉬를 추가하는 것은 한 줄에 불과하다.

그리고 스위프트는 이제 수정자를 단일 플랫폼으로 쉽게 제한할 수 있게 해준다-- 이 경우, iOS.

검색 필드를 추가하는 것은 한 줄만 더 하면 됩니다.

이제, 우리는 거기서 멈출 수 있지만, 우리가 입력하는 동안 표시될 몇 가지 검색 제안도 추가합시다.

그리고 바로 여기 Xcode에서 테스트해 봅시다.

우리는 이제 몇 줄의 코드로 스와이프 작업, 풀 투 리프레시, 제안을 포함한 전체 검색 지원이 있습니다.

다음으로, Fruta의 접근성 지원을 개선해 봅시다.

첫째, 접근성 로터를 추가하는 새로운 수정자는 VoiceOver로 앱을 더 빠르게 탐색할 수 있습니다.

그리고 두 번째로 우리는 이 맞춤형 스테퍼 컨트롤의 접근성을 개선할 것입니다.

사용자 지정 컨트롤은 종종 접근성이 좋지 않은 원인이지만, 이제 표준 스테퍼에서 전체 접근성 구현을 단순히 상속받을 수 있습니다.

대부분의 SwiftUI API는 모든 플랫폼에서 사용할 수 있지만, 적절한 경우 개별적으로 플랫폼을 발전시킬 수 있습니다.

macOS 앱에 다중 열 테이블을 추가해 봅시다.

나는 이미 이것에 대한 새 파일을 추가했기 때문에, 우리는 여기에 새로운 테이블 구성 요소를 추가할 것이다.

그리고 그 안에, 우리는 세 개의 데이터 열을 추가할 것이다.

이제 우리 앱의 macOS 버전을 실행해 봅시다.

도구 모음에서 예상하는 바로 위치에 있는 검색 필드를 찾을 수 있으며, 입력하는 동안 바로 아래에 제안이 표시됩니다.

우리가 추가한 새로운 다중 열 테이블로 전환할 수 있으며, 검색 결과도 표시하는 것을 볼 수 있습니다.

그리고 물론, 우리는 그들 모두를 되찾기 위해 검색을 지울 수 있다.

이제 레시피로 전환하고 VoiceOver를 켜봅시다.

VoiceOver를 사용하면 목록에서 스무디를 빠르게 선택하기 위해 추가한 로터에 쉽게 접근할 수 있습니다.

그리고 사용자 지정 스테퍼와의 VoiceOver 상호 작용은 이제 표준 스테퍼와 똑같이 작동하여 모든 사용자가 쉽게 사용할 수 있습니다.

우리는 이러한 새로운 기능을 사용하여 앱을 구축하고 있으므로, 당신도 도움이 될 것이라는 것을 알고 있습니다.

그리고 우리는 방금 새로운 것의 표면을 긁었다.

예를 들어, 당신은 SwiftUI의 새로운 재료 지원을 좋아할 것입니다.

Fruta 앱에서, 이와 같은 보기는 배경 이미지를 추가하여 더 흥미롭게 만들어지며, 콘텐츠 뒤에 새로운 소재 스타일 중 하나를 적용하여 읽을 수 있게 유지됩니다.

콘텐츠는 이 배경에 동적으로 반응하므로, 일반적으로 불투명한 컨텍스트에서 보조 콘텐츠에 사용되는 회색 대신 SwiftUI는 텍스트, 기호 및 구분 기호와 같은 표준 UI에 생생한 렌더링을 자동으로 적용합니다.

따라서 한 줄의 코드만 있으면, 이와 같은 멋진 결과를 자동으로 얻을 수 있습니다.

그리고 훨씬 더 많아.

이러한 모든 개선 사항으로 SwiftUI는 모든 플랫폼에서 모든 사용자에게 훌륭한 경험을 제공할 수 있는 가장 좋은 방법입니다.

그리고 올해, 우리는 Swift Playgrounds의 iPad에 SwiftUI를 사용한 앱 개발을 가져올 것입니다.

정말 재밌어, 그리고 매트가 그게 어떻게 작동하는지 보여줄 거야.

Swift Playgrounds는 코딩 방법을 배울 수 있는 좋은 방법을 제공하며, 수백만 명의 사람들이 Swift에 대한 지식을 넓히는 데 사용되었습니다.

그리고 배울 수 있는 좋은 방법 외에도, 우리는 많은 사람들이 이미 Swift Playgrounds를 사용하여 실험하고, 새로운 아이디어를 스케치하고, iPadOS SDK의 최신 기능을 가지고 놀고 있다는 것을 알고 있습니다.

올해 Swift Playgrounds 4는 앱을 빌드하고 iPad에서 바로 App Store에 제출할 수 있도록 함으로써 큰 진전을 이기고 있습니다.

iPad에서 앱을 만들 수 있는 기능을 사용하면 Swift Playgrounds에서 그 어느 때보다 생산성을 높일 수 있으며, 원하는 장치에서 어디를 가든 아이디어를 작업할 수 있습니다.

그리고 새로운 패키지 기반 프로젝트 형식을 사용하면 Swift Playgrounds와 Xcode 사이에서 작업을 원활하게 가져올 수 있습니다.

들어가서 한 번 보자.

이것은 신속한 놀이터 4입니다.

전 세계의 새로운 개발자들에게 영감을 주는 데 도움이 되는 모든 훌륭한 Learn to Code 콘텐츠가 있으며, 이제 SwiftUI 앱을 구축할 수 있는 프로젝트를 만들 수 있습니다.

이제 새로운 것을 만들고 우리가 무엇을 만들 수 있는지 봅시다.

내가 만든 새 프로젝트를 열 거야.

스위프트 플레이그라운드의 앱 프로젝트에서, 내 코드는 왼쪽에 있고, 내 작업의 결과는 내가 익숙한 것처럼 오른쪽에 있다.

새로운 점은 Xcode에서 사용되는 것과 동일한 기술로 구동되는 라이브 인터랙티브 미리보기와 함께 SwiftUI에 대한 깊이 통합된 지원입니다.

내 새로운 프로젝트 템플릿은 Hello World 자리 표시자와 함께 제공되며, 나만의 텍스트 보기로 쉽게 대체할 수 있습니다.

텍스트를 입력하기 시작하고 바로 코드 완성에서 유용한 제안을 받을 것입니다. 이 릴리스의 새로운 기능은 삽입 지점 바로 아래에 나타납니다.

나는 완성을 수락하고 나만의 인사 메시지를 쓸 것이다.

내가 타이핑하는 동안, 내 앱은 각 키 입력에 대한 변경 사항을 보여주기 위해 실시간으로 업데이트된다.

이제, 조금 재밌게 놀자.

나는 이 정적 텍스트를 버튼으로 바꿀 것이다.

나는 내 텍스트 보기를 선택한 다음, 라이브러리에서 버튼을 추가할 것이다.

여기 라이브러리에서 프로젝트의 자산과 iPadOS에서 제공하는 SwiftUI 뷰, 수정자, 색상 및 SF 기호를 탐색하고 검색할 수 있습니다.

지금은, 그냥 내 버튼을 추가할게.

나는 간단한 인쇄 진술서로 그 행동을 채울 것이다.

몸을 위해, 나는 시스템 이미지가 있는 라벨을 사용할 것이다.

그 문자는 "안녕하세요"가 될 거야.

그리고 그 이미지는 스위프트의 SF 상징이 될 것이다.

이제 내 앱에 인터랙티브 버튼이 있어.

내가 그것을 탭하면, 내가 쓴 인쇄 메시지는 내 화면 하단에 메시지 거품으로 나타난다.

콘솔을 열면, 이 프로젝트를 연 이후로 실행된 인쇄 문의 기록을 볼 수 있으며, 앱과 상호 작용할 때 실시간으로 업데이트됩니다.

이제, 이 버튼은 보라색입니다. 왜냐하면 그것은 제가 프로젝트를 만들 때 Swift Playgrounds가 저를 위해 선택한 앱의 악센트 색상이기 때문입니다.

문서 사이드바를 열면 이름, 악센트 색상 및 아이콘과 같은 앱의 모든 최상위 설정에 액세스할 수 있습니다.

내가 보라색을 좋아하는 만큼, 나는 이 웃는 얼굴이 주황색으로 크고 밝게 보일 것이라고 생각한다. 그래서 나는 여기서 내 악센트 색상을 바꿀 것이고, 내 앱의 아이콘과 내가 방금 만든 버튼의 색조 색상은 변화를 반영하기 위해 업데이트될 것이다.

이것은 정말 재미있었지만, 스위프트 플레이그라운드는 단지 실험을 위한 것이 아니다.

한동안 작업해 온 다른 앱이 있어.

나는 이 앱을 사용하여 내가 가장 좋아하는 취미에 소비하는 시간을 추적하며, 다른 사람들도 유용할 것이라고 생각한다.

나는 설치된 앱이 전체 화면으로 어떻게 보일지 느낄 수 있다.

이제 전폭 2열 또는 3열 레이아웃으로 앱을 탐색할 수 있습니다.

나는 전체 화면에서 뛰어내려 내가 원할 때마다 내 코드로 돌아갈 수 있다.

이것은 기분이 좋고, 나는 내 노력이 TestFlight와 함께 내 친구 및 가족과 공유할 준비가 되었다고 생각한다.

개발자 계정이 있는 사람은 누구나 App Store Connect가 준비되면 앱 설정 영역에서 앱을 업로드할 수 있습니다.

업로드 버튼을 탭하면, Swift Playgrounds는 내 앱을 빌드, 패키지 및 업로드합니다.

그런 다음 App Store Connect 웹사이트로 가서 TestFlight를 통해 앱을 사용할 수 있게 하고, 준비가 되면 App Store에 제출하고 전 세계와 공유할 수 있습니다.

그리고 그것은 iPad에서 바로 SwiftUI를 사용하여 앱을 만들 수 있는 Swift Playgrounds 4를 빠르게 살펴볼 수 있습니다.

스위프트 플레이그라운드 4는 올해 말에 출시될 예정입니다.

우리는 당신이 어디를 가든, 당신이 선호하는 어떤 장치에서든 앱 아이디어를 개발할 수 있는 자유를 가질 수 있다는 것을 알고 있습니다.

그리고 이제, 내가 그걸 수잔에게 돌려줄게.

우리가 세상을 경험하는 방식의 대부분은 시각적 커뮤니케이션을 통해 이루어지며, 이는 Apple 장치 사용의 큰 부분이다.

그래픽, 디스플레이 및 증강 현실에 대한 우리의 기술은 Apple Watch의 Always on Display를 보거나, iPad Pro에서 비디오 도구로 작업할 때 ProMotion을 즐기거나, iPhone에서 게임을 하거나, Mac에서 몰입형 3D 콘텐츠를 만들 때 전면과 중앙에 있습니다.

그리고 이제 Myra와 Eric은 증강 현실을 시작으로 올해 새로운 것을 통해 당신을 안내할 것입니다.

AR은 강력한 기술이며 수천 명의 사람들이 이미 우리 모두가 일하고, 놀고, 표현하는 방식을 변화시키기 위해 앱에서 그것을 사용하고 있습니다.

오늘날 전 세계적으로 10억 개 이상의 AR 지원 iPhone과 iPad를 통해 앱에 AR 경험을 추가하거나 완전히 새로운 경험을 구축하기에 이보다 더 좋은 시기는 없었습니다.

역사적으로, 훌륭한 AR 앱을 구축하려면 3D 모델링에 대한 깊은 지식과 정교한 렌더링 엔진에 대한 숙달이 필요했다.

하지만, 우리는 여러분 모두가 놀라운 AR 경험을 만들 수 있기를 바랍니다.

이것이 우리가 당신이 AR을 쉽게 시작할 수 있도록 기술 제품군을 출시한 이유입니다.

이들 중 하나는 AR을 위해 처음부터 구축된 3D 렌더링, 오디오, 애니메이션 및 물리 엔진인 RealityKit입니다.

RealityKit은 사실적인 렌더링과 노이즈 및 모션 블러와 같은 카메라 효과를 특징으로 하는 몰입형 AR 경험을 간단하게 렌더링합니다.

RealityKit은 또한 LiDAR 스캐너와 같은 최신 하드웨어를 활용하여 가상 물체가 실제로 사람과 물체 폐색과 함께 있는 것처럼 행동할 수 있도록 합니다.

그리고 그것은 모두 스위프트로 쓰여졌다.

오늘, 우리는 더 많은 시각, 오디오 및 애니메이션 제어를 제공하고 훌륭한 AR 앱을 만드는 데 있어 가장 어려운 부분인 3D 모델을 만드는 거대한 업데이트인 RealityKit 2를 발표합니다.

이전에 만든 적이 있다면, 단일 모델을 만드는 데 몇 시간과 수천 달러가 걸릴 수 있다는 것을 알고 있습니다.

이제 Object Capture를 사용하면 iPhone을 사용하여 몇 분 안에 3D 모델을 만들어 물체의 2D 이미지를 캡처하고 Mac의 Object Capture API를 사용하여 이러한 이미지를 AR에 최적화된 생생한 3D 모델로 바꿀 수 있습니다.

이 과정은 정말 간단해.

우리는 물체를 뒤집고 자동 전경 세분화를 지원하기 때문에 하단을 포함한 물체의 모든 각도를 캡처하기 위해 iPhone 또는 iPad로 일련의 사진을 찍는 것으로 시작합니다.

워크플로우를 간소화하는 데 도움이 되는 훌륭한 가이드를 제공하는 Qlone과 같은 앱을 사용할 수 있습니다.

그런 다음, Object Capture API를 사용하여 3D 모델을 생성하는 데 몇 줄의 코드만 있으면 됩니다.

RealityKit에서 캡처한 이미지의 폴더를 가리키는 새로운 사진 측량 세션을 시작합니다.

그런 다음, 프로세스 함수를 호출하여 원하는 세부 수준에서 모델을 생성하세요.

그렇게 쉬워!

오브젝트 캡처를 사용하면 AR 퀵 룩에 최적화된 USDZ 파일을 생성할 수 있으므로 사용자는 메시지, 메일, 사파리 및 기타 앱에서 볼 수 있습니다.

광선 추적 및 기타 포스트 프로덕션 워크플로우에 사용할 수 있는 Object Capture API에서 USD 또는 OBJ 자산 번들을 생성할 수도 있습니다.

실제 물체를 3D 모델로 바꾸는 것이 그 어느 때보다 쉬워졌습니다.

오늘 샘플 코드로 Object Capture를 사용할 수 있으며, 올해 말에 사용할 수 있는 Unity Mars, Cinema 4D 및 Qlone과 같이 이미 사용하고 있는 많은 프로 앱에 이 워크플로우를 도입하기 위해 선도적인 3D 콘텐츠 제작 도구와 협력하고 있습니다.

Object Capture 모델을 Xcode로 가져오고 새로운 RealityKit API를 사용하여 효과를 추가하는 것은 쉽습니다.

우리 팀과 나는 우리가 가장 좋아하는 음식을 스캔하여 오브젝트 캡처를 테스트했고, 요리의 AR 미리보기를 포함한 레시피를 공유하기 위해 AR 앱 클립을 만들었습니다.

우리가 Qlone을 사용하여 캡처한 초콜릿 크루아상은 실제로 우리 팀의 누군가가 구운 크루아상의 가상 복제품이며, 앱 클립에 다른 레시피로 추가하고 싶습니다.

크루아상 3D 모델을 ARApp 프로젝트로 드래그하는 것으로 시작하겠습니다.

다음으로, ARKit을 사용하여 앱 클립 코드에 고정하고 자산의 ModelEntity를 초기화할 것입니다.

앱 클립을 배포하기 전에 프로젝트를 구축하는 동안 언제든지 Xcode Quicklook에서 직접 3D 모델을 완전히 검사할 수 있습니다.

우리는 앱 클립에서 새로운 RealityKit API를 사용하여 각 AR 접시에 효과를 추가하여 더 현실적으로 만들었습니다.

RealityKit은 네이티브 렌더링 엔진이기 때문에, 우리는 여러 AR 장면이나 레시피를 앱 클립에 넣을 수 있습니다.

확인해 보자.

앱 클립 코드를 스캔하면, 앱 클립을 실행한 다음 초콜릿 크루아상을 바로 위에 고정합니다.

크루아상을 더 사실적으로 만들기 위해, 우리는 새로운 RealityKit 사용자 지정 표면 셰이더를 사용하여 방출 빛을 추가하고 주변 폐색을 뒤로 당깁니다.

구운 스테이크와 같은 팀의 요리를 몇 가지 더 살펴봅시다.

여기서 우리는 플립북 셰이더에 레이어링하기 위해 새로운 Procedural Geometry API로 스팀 효과를 만들어 사용자 지정 표면 셰이더에 추가했습니다.

증기는 절차적이기 때문에, 우리는 이 피자와 같은 많은 레시피에 같은 효과를 사용할 수 있다.

스팀 효과가 피자의 크기에 따라 절차적으로 어떻게 확장되었는지 주목하세요.

이 바베큐 치킨 요리를 위해, 우리는 이 요리가 맵다는 것을 나타내기 위해 전체 화면 후처리 화재 효과를 추가했습니다.

그리고 마지막으로, 우리는 불꽃을 떨어뜨리고 대신 새로운 컴퓨팅 셰이더와 기하학 수정자를 사용하여 생일 케이크 주위에 축하 색종이를 추가했습니다.

보시다시피, 우리는 더 많은 사용자 지정을 위해 RealityKit 렌더링을 열었고, 이 새로운 API를 사용하는 방법에 대한 당신의 창의성을 빨리 보고 싶습니다.

이것들은 모든 개발자가 더 몰입감 있고 생생한 AR 경험을 구축하기 위해 3D 모델을 만들 수 있는 AR에 대한 흥미진진한 새로운 개선 사항 중 일부일 뿐입니다.

우리가 ARKit과 RealityKit에서 하는 일의 기본 측면 중 하나는 그래픽 기술이다.

그리고 에릭은 우리에게 새로운 것에 대한 업데이트를 줄 것이다.

우리가 Apple에서 제품을 만드는 방법에 대한 핵심 아이디어는 가장 놀라운 하드웨어와 소프트웨어를 함께 모으는 것이며, 그래픽에 대한 우리의 접근 방식은 그 이상을 반영합니다.

수년 동안, 우리는 당신이 우리의 제품을 최대한 활용할 수 있도록 Metal 그래픽 및 컴퓨팅 API와 페어링된 iPhone 및 iPad용 Apple이 설계한 강력한 GPU를 제공했습니다.

그리고 이제 M1 칩을 통해 최신 Mac과 iPad Pro에서 전례 없는 수준의 그래픽 성능과 전력 효율성을 제공할 뿐만 아니라, iPhone에서 iPad, Mac에 이르는 Metal, Apple GPU 및 통합 메모리를 기반으로 하는 공통 아키텍처를 갖춘 통합 Apple 그래픽 플랫폼을 만들었습니다.

그리고 이 플랫폼은 근본적인 변화를 가능하게 한다.

이전에 고급 워크스테이션이나 개별 GPU 게임 컴퓨터가 필요했던 그래픽 워크로드는 이제 가장 인기 있는 제품에서 가능합니다.

예를 들어, 이 통합 플랫폼의 콘솔 수준의 성능은 Larian과 같은 개발자들이 AAA 게임인 Divinity Original Sin 2를 Mac과 iPad로 가져올 수 있게 했다.

그리고 딥 실버는 M1과 메탈의 최신 셰이더 파이프라인을 사용하여 Mac용 생존 게임 메트로 엑소더스에서 고성능의 몰입형 그래픽을 가능하게 하고 있다.

하지만 이 그래픽 플랫폼은 게임만을 위한 것이 아니다.

메탈 컴퓨팅 API는 이제 OTOY의 완전히 새로운 옥탄 X와 Cinema 4D의 맥슨의 레드시프트 렌더러와 같은 차세대 전문 GPU 렌더러를 가속화하고 있으며, 이제 처음으로 Mac에서 메탈 가속을 실행하고 있다.

따라서 Apple의 모든 강력한 장치에서 그래픽 앱과 게임을 가져올 수 있도록, 우리는 올해 두 가지 큰 영역에 초점을 맞췄습니다: 고급 그래픽 및 게임 기능, 강력한 그래픽 개발자 도구.

첫째, 우리는 현대 하이엔드 게임과 GPU 렌더링 알고리즘에 필수적인 세 가지 주요 기능에 중점을 두었습니다. 복잡한 수학적 작업을 가속화하고, 빛의 동작을 모델링하고, 현실적인 표면을 나타내기 위해, 현대 GPU 렌더러는 동일한 파이프라인에서 메탈 그래픽과 컴퓨팅 명령을 인터리브해야 합니다. 이것이 메탈이 이제 그래픽 셰이더에서 직접 동적 라이브러리와 레이 쿼리 프리

그리고 Metal Ray Tracing API의 새로운 Stochastic Motion Blur 기능으로 훨씬 더 사실적인 렌더링을 만들 수 있습니다.

게임이 더 낮은 대기 시간과 더 적은 저더로 더 높은 프레임 속도를 달성하기 위해, 개발자들은 디스플레이에 대한 더 많은 제어가 필요하다.

이를 달성하고 최신 iPad Pro의 멋진 그래픽 성능을 활용하기 위해, 게임은 Metal 프레젠테이션 시간 API와 ProMotion 디스플레이를 사용하여 렌더링과 입력 사이의 원하는 대기 시간에 따라 앱의 프레임 속도를 동적으로 조정할 수 있습니다.

그리고 macOS Monterey는 적응형 동기화 디스플레이에 대한 지원을 추가합니다.

이것은 이제 Mac 게임을 위한 이러한 초저지연 및 가변 재생률 디스플레이를 활용할 수 있다는 것을 의미합니다.

이제, 고급 그래픽을 갖춘 고급 게임은 종종 게임 컨트롤러를 입력으로 사용하도록 설계되었습니다.

그리고 게임 컨트롤러 지원을 추가하는 것은 일반적인 입력 모델을 사용하여 게임을 통합 그래픽 플랫폼으로 가져오는 강력하고 쉬운 방법입니다.

우리의 게임 컨트롤러 프레임워크는 이제 햅틱 지원과 함께 최신 Xbox 시리즈 X 무선 컨트롤러와 플레이스테이션 5 듀얼센스 컨트롤러에 대한 지원을 포함하여 가장 인기 있는 컨트롤러를 지원합니다.

컨트롤러 기반 게임을 iPhone과 iPad로 더 쉽게 가져올 수 있도록, 몇 줄의 코드로 화면 가상 게임 컨트롤러를 활성화할 수 있도록 새로운 API를 추가했습니다.

그리고 게임 컨트롤러 지원은 그 어느 때보다 가치가 있습니다. 왜냐하면 macOS Monterey와 iPadOS 15에서 플레이어는 친구들이 플레이하고 있는 게임을 찾고, 앱 라이브러리로 직접 이동하여 게임을 시작한 다음, "공유" 버튼을 눌러 컨트롤러가 손을 떠나지 않고도 좋아하는 게임 하이라이트를 기록할 수 있기 때문입니다.

이제, 이러한 새로운 고급 API 및 기능과 함께, Xcode 13은 GPU 코드를 최적화하고 디버깅할 수 있는 강력한 새로운 그래픽 개발자 도구를 추가하며, 각각은 최신 하이엔드 게임과 그래픽 애플리케이션을 다음 단계로 끌어올리도록 설계되었습니다.

첫째, 고급 GPU 렌더러와 게임을 구축할 때, GPU 셰이더는 정말 커질 수 있다.

병렬로 실행되는 수천 개의 작업 그룹에서 10,000줄의 셰이더 코드를 디버깅하는 것은 정말 오랜 시간이 걸릴 수 있습니다.

이 과정을 간소화하기 위해, Xcode 13은 선택적 셰이더 디버깅을 추가합니다.

여기서, 우리는 선택적 셰이더 디버깅을 사용하여 훨씬 더 큰 GPU 셰이더 내에서 디버깅할 기능을 정확히 선택하고 있습니다.

이렇게 하면 가장 큰 셰이더를 반복하고 디버깅하는 데 걸리는 시간을 획기적으로 줄일 수 있으며, 이를 통해 더 빠르게 개발하고 GPU 코드에 기능과 성능을 추가하는 데 집중할 수 있습니다.

다음으로, 하이엔드 AAA 게임은 또한 최신의 최신 텍스처 압축 지원이 필요합니다. 그래서 우리는 강력한 금속 텍스처 변환기 도구를 업데이트하여 텍스처 변환기 압축 파이프라인을 직접 제어하고, 완전히 새로운 감마 인식 픽셀 변환을 추가하고, Mac, PC 및 iOS 게임에서 사용하는 최신 ASTC 및 BC 텍스처 압축 형식에 대한 지원을 크게 확장했습니다.

이를 통해 각 Apple 장치에 대한 게임의 텍스처 자산을 더욱 쉽게 최적화할 수 있습니다.

마지막으로, 가장 진보된 렌더링으로 최고의 성능을 달성할 수 있도록, Xcode 13은 Metal Debugger에 완전히 새로운 GPU 타임라인 보기를 추가합니다.

이 강력한 새로운 보기를 사용하면 강력한 성능 카운터 및 병목 현상 분석 정보 외에도 이벤트 타임라인에서 Metal 명령, 리소스 및 버퍼를 시각적으로 디버깅하는 최고의 기능을 결합할 수 있습니다.

Apple CPU, GPU 및 Metal을 통해 우리는 그래픽, 프로 앱 및 게임을 위한 완전히 새로운 수준의 기능과 성능을 발휘할 수 있도록 최신 기능과 개발자 도구를 갖춘 10억 개 이상의 장치를 갖춘 통합 그래픽 플랫폼을 만들었습니다.

그리고 이제 너에게 돌아가, 수잔.

당신의 앱은 사람들을 아이디어, 서비스, 도구, 그리고 가장 중요한 다른 사람들과 연결하는 데 도움이 될 수 있습니다.

균형을 찾는 것은 연결만큼이나 중요하므로, 올해는 사용자가 적절한 순간에 앱에 집중하고, 개인 정보를 존중하면서 사랑하는 사람의 장치를 관리하고, 앱의 콘텐츠를 Apple 플랫폼에서 구축된 새롭고 공유되고 친밀한 경험의 중심으로 만들 수 있도록 지원합니다.

우리는 당신의 앱이 그러한 종류의 관계를 만드는 데 도움이 될 강력한 새로운 API 세트를 만들었습니다.

Heena와 Matt와 함께 Focus에 대해 이야기해 봅시다.

iOS 15는 사람들이 집중할 수 있도록 도와주는 강력한 새로운 도구 세트를 소개합니다.

이 도구들은 사람들이 그 순간에 있을 수 있도록 산만함을 줄이는 데 도움을 준다.

그리고 그것은 알림에 대한 완전히 새로운 접근 방식으로 시작됩니다.

여기 내 잠금 화면에 쌓인 몇 가지 알림이 있습니다.

그들의 긴급 수준은 분명히 다르다.

하지만 그들은 모두 똑같이 행동했다.

그들은 같은 외모, 같은 햅틱, 같은 명백한 수준의 중요성을 가지고 있었다.

이제, 새로운 인터럽션 레벨 API를 통해, 앱이 다양한 수준의 긴급성을 전달할 수 있는 더 미묘한 방법이 있습니다.

알림은 네 가지 중단 수준 중 하나를 할당할 수 있습니다.

수동적 중단은 조용하며 장치를 깨우지 않습니다.

사람들은 다음에 핸드폰을 받을 때 그들을 볼 것이다.

시간에 민감하지 않은 알림에 이것들을 사용하고 싶을 수도 있습니다.

활성 중단은 오늘 알림과 마찬가지로 소리나 햅틱을 재생할 것이다.

시간에 민감한 중단은 사용자가 탭하지 않은 경우 시각적으로 눈에 띄고 잠금 화면에서 조금 더 오래 놀 수 있도록 설계되었습니다.

누군가가 에어팟을 착용하고 있다면 그들은 또한 Siri에 의해 발표될 것이다.

그리고 당신은 즉각적인 주의가 필요한 알림에 이것을 사용하고 싶을 것입니다.

중요한 경고는 가장 긴급한 범주이다.

그들은 장치가 음소거되더라도 소리를 재생할 것이다.

이것들은 매우 심각한 건강 및 안전 문제만을 위해 예약되어 있으며, 승인된 자격이 필요합니다.

특별한 주의를 기울여야 할 또 다른 범주의 알림이 있다: 사람들의 커뮤니케이션.

통신 앱이 있다면, 메시지와 통화 알림에 대해 시스템에 알리는 것이 중요합니다.

그런 다음 시스템은 이 정보를 사용하여 알림의 모양과 행동을 조정하여 사람들이 더 잘 해석하는 데 도움이 될 것입니다.

일단 구현되면, 알림은 표준 모양에서 앱 아이콘이 겹쳐진 눈에 띄는 아바타를 특징으로 하며, 공유 시트와 같이 시스템의 다른 곳에서 동일한 아바타가 사용됩니다.

그 아바타를 보게 되어 정말 신나!

좋아, 그래서 알림은 사람들의 관심을 끄는 정말 효과적인 방법이야.

하지만 그들은 또한 일종의 일시적일 수 있다.

만약 그들이 시기적절하지 않다면, 사람들은 쉽게 그들을 놓칠 수 있다.

사용자가 자신의 시간에 알림에 참여할 수 있도록, 우리는 사용자가 선택한 시간에 유용한 번들로 알림을 제공하는 알림 요약을 도입하여, 그들에게 가장 적합한 때 빠르게 따라잡을 수 있습니다.

요약은 사용자가 선택한 앱의 수동 및 활성 알림을 번들로 묶고 아름다운 레이아웃으로 제공합니다.

그런 다음 그것이 보일 때까지 잠시 동안 잠금 화면에 붙어 있다.

요약은 또한 각 사용자에 대해 개인화됩니다.

보시다시피, 상단에 두 개의 큰천막 슬롯이 있습니다.

거기에 소개된 것은 몇 가지 요소를 기반으로 합니다: 첫째, 다양성을 제공하기 위해, 그 두 앱은 요약 내부에서 샘플링됩니다.

거기서부터, 우리는 추가적인 가중치를 한다.

큰 썸네일이 있는 알림은 항상 없는 알림보다 선택됩니다.

그리고 당신이 결정하는 가장 높은 관련성 점수를 가진 알림은 같은 앱에서 다른 것들보다 선택될 것입니다.

좋아요, 그래서 당신은 "내 앱이 어떻게 요약으로 끝나나요?"라고 궁금해 할 수도 있습니다. 음, 먼저, 알림 요약을 사용하고 싶다면 전적으로 사용자에게 달려 있습니다.

그리고 그들이 그렇게 한다면, 가장 많은 알림을 보내는 앱이 제안될 것이다.

그런 다음 사용자는 받을 시간과 함께 요약에 들어갈 앱을 사용자 정의할 수 있습니다.

앱이 예약된 요약에 배치된 경우, 실시간으로 사용자에게 연락할 수 있는 방법이 있습니다.

그곳이 시간에 민감한 알림이 들어오는 곳이다.

이 중단 수준을 사용하는 알림은 즉시 전달될 것입니다.

즉각적인 주의가 필요하고 현재와 관련이 있는 경우에만 알림을 시간에 민감한 것으로 표시해야 한다는 것을 기억하십시오.

방해금지 모드보다 더 산만함을 제거하는 기능은 없다.

하지만 방해하지 마세요는 모든 알림을 침묵시키고 우리는 사용자에게 더 많은 유연성을 제공하고 싶었습니다.

포커스를 통해 사용자는 현재 하고 있는 일에 따라 알림을 받아야 하는 앱과 사람들을 선택할 수 있습니다.

그들은 일을 위해 하루를 개척하거나 게임, 독서 또는 피트니스와 같은 활동에 초점을 맞출 수 있다.

포커스에 있는 동안, 사용자는 자신의 상태를 다른 사람들과 공유할 수 있으므로, 방해하지 않을 것을 알 수 있다.

하지만 그것이 정말 긴급하다면, 메시지는 돌파하고 어쨌든 알릴 수 있다.

통신 앱은 또한 사용자의 포커스 상태에 대한 액세스를 요청할 수 있습니다.

승인되면, 시스템은 변경될 때 앱에 알릴 것이므로, 앱은 나머지 시스템과 상태를 동기화할 수 있습니다.

당신의 앱은 심지어 사용자에게 긴급한 통신을 돌파할 수 있는 기능을 제공할 수도 있습니다.

우리는 사용자에게 알림을 관리할 수 있는 그 어느 때보다 더 많은 통제와 유연성을 제공하고 있습니다.

그리고 이러한 도구가 작동하는지 확인하기 위해, 시스템은 주기적으로 설정에 대한 특정 조정이 도움이 될 수 있는지 확인할 것입니다.

그것은 사용자가 당신의 앱과 알림과 상호 작용하는 방식을 기반으로 합니다.

따라서 사용자가 일반적으로 포커스에 있는 동안 앱을 사용하는 경우, 시스템은 해당 포커스 동안 해당 앱의 알림을 허용할 것을 제안할 수 있습니다.

또는 사용자가 앱의 시간에 민감한 알림과 상호 작용하는 경우, 시스템은 활성 알림으로 되돌릴 것을 제안할 수 있습니다.

앱이 알림을 차례로 보내고 사용자가 참여하지 않을 때도 마찬가지입니다.

시스템은 해당 앱의 모든 알림을 음소거하거나 제한된 시간 동안 단 한 번의 대화를 제안할 수 있습니다.

그래서 이러한 새로운 기능을 최대한 활용하기 위해, 당신이 해야 할 몇 가지 중요한 것들이 있습니다.

알림에 관련성 점수를 설정하고 적절한 썸네일을 첨부하여 요약 상단의 큰천막 슬롯에 올바른 콘텐츠가 있는지 확인할 수 있습니다.

어떤 중단 수준이 알림에 적합한지 신중하게 생각해야 합니다.

통신 앱이 있다면, 새로운 사용자 알림 API를 채택하여 시스템에 메시지와 통화 알림을 알려야 합니다.

또한 새로운 포커스 상태 API를 사용하여 앱에 사용자의 포커스를 반영해야 합니다.

우리는 이러한 도구들이 당신의 도움으로 사용자가 산만함을 줄이는 데 큰 도움이 될 것이라고 생각합니다.

다음으로, 마틴은 우리에게 새로운 스크린 타임 API에 대해 말할 것이다.

고마워, 매트.

좋아, 스크린 타임과 자녀 보호에 대해 이야기하기 위해 기어를 바꾸자.

우리는 부모가 자녀가 건강한 디지털 삶을 구축할 수 있도록 현대적이고 혁신적인 솔루션이 필요하다는 것을 알고 있으며, 또한 가족의 사생활을 깊이 소중하게 생각합니다.

그리고 우리는 이러한 사용자 요구를 전달하려는 많은 사람들의 욕구를 보았습니다.

그래서 오늘, 우리는 개인 정보 보호에 대한 깊은 헌신을 기반으로 한 맞춤형 보호자 통제 프레임워크 세트인 Screen Time API를 출시합니다.

우리는 스크린 타임 API로 세 가지 주요 목표를 염두에 두고 있었다.

부모의 통제 앱을 개발하기 위한 현대적인 솔루션을 제공하기 위해.

오늘날 스크린 타임이 제공하는 것 이상으로 역동적인 경험을 구축하고 혁신할 수 있도록 힘을 실어주기 위해.

그리고 사용자 사생활을 보호하기 위해.

이를 위해, 우리는 자녀 보호의 세계에서 혁신할 수 있는 세 가지 새로운 스위프트 프레임워크를 iOS SDK에 추가했습니다: 관리 설정, 가족 제어 및 장치 활동.

먼저, 관리되는 설정에 대해 이야기해 봅시다.

기본적으로, 자녀 보호 앱은 자녀가 장치에서 할 수 있는 일을 제한하고, 부모가 달리 말할 때까지 이러한 제한이 유지되도록 하는 방법이 필요합니다.

관리되는 설정을 통해 앱은 계정 잠금, 비밀번호 변경 방지, 웹 트래픽 필터링, 스크린 타임과 같은 애플리케이션에 대한 액세스 제한과 같은 여러 가지 제한을 설정할 수 있습니다.

앱의 브랜딩과 기능으로 사용자 정의하세요.

이 프레임워크를 활용함으로써, 당신의 앱은 이러한 모든 제한을 관리할 수 있을 것입니다.

제한을 넘어 적절한 경우 앱과 웹사이트에 대한 액세스를 제한하고 사용 사례에 고유한 일련의 작업을 제공할 수 있습니다.

그리고 마지막으로, 우리는 부모의 명시적인 승인이 있어야만 제거할 수 있도록 앱을 제자리에 잠급니다.

이제, Family Controls 프레임워크는 개인 정보 보호 모델의 핵심이며 두 가지 주요 사용자 대면 경험을 제공합니다.

첫째, 부모가 iCloud 자격 증명으로 관리를 위해 앱을 인증하여 장치가 해당 가족의 자녀를 위한 것임을 보장할 수 있습니다.

또한 시스템 앱 및 웹사이트 선택기를 통해 개인화된 경험을 제공하며, 이를 통해 부모는 사용자 개인 정보를 보호하면서 어떤 앱과 사이트를 제한해야 하는지 선택할 수 있습니다.

우리는 부모가 자녀가 사용하는 앱과 웹사이트를 관리하고 제한할 수 있도록 허용하고 싶었지만, 개인 애플리케이션과 웹 브라우징 세부 정보를 공개하지 않는 방식으로 그렇게 하고 싶었습니다.

따라서, 원시 번들 ID와 URL의 선택을 반환하는 대신, 피커는 대신 불투명한 토큰을 반환할 것이다.

이 토큰을 사용하면 앱이 부모가 관리하고자 하는 앱과 웹사이트를 추적할 수 있으며, 부모가 이 매우 민감한 정보에 접근할 수 있는 유일한 사람임을 보장할 수 있습니다.

그리고 이 토큰들은 이 모든 프레임워크에서 기능을 가능하게 한다.

토큰을 사용하여 관리 설정으로 특정 앱이나 웹사이트에 대한 액세스를 제한하거나, 장치 활동 프레임워크를 통해 오늘날까지 iOS에서 불가능했던 앱 및 웹사이트 활동에 대한 통찰력을 얻으십시오.

Family Controls의 Activity Picker가 제공하는 토큰을 사용하면 장치 활동의 힘을 활용할 수 있습니다.

다른 앱과 활동에 대해 고유한 시간 창을 등록할 수 있으며, 각각 "5분 더 남았습니다"와 같은 경고와 완료 이벤트를 보낼 수 있습니다.

앱이 이러한 이벤트를 받으면, 제한을 변경하거나, 관련 앱과 웹사이트에 대한 액세스를 제한하거나...

아이들이 숙제를 하도록 격려하기.

사용자에게 어떤 경험을 제공하려고 하든.

브라우저 활동뿐만 아니라 장치의 모든 앱에서 장치 활동을 보는 이 개념은 완전히 새롭고 자녀 보호의 세계에서 혁신할 수 있는 독특한 기회입니다.

스크린 타임 API를 사용하면 가족 전체의 다운타임을 활성화하거나, 숙제를 한 후 게임 잠금을 해제하는 것과 같은 교육적인 일을 한 후에 재미있는 일을 할 수 있는 인센티브를 만들 수도 있습니다.

우리는 부모와 가족이 우리 장치를 사용하는 방식을 관리할 수 있도록 이러한 API를 어떻게 구축할지 보게 되어 매우 기쁩니다.

그리고 이제 Vi로 가서 위젯의 새로운 기능을 알려주세요.

작년에, 우리는 홈 화면에 위젯을 도입했다.

그리고 사람들은 그들을 사랑했어.

위젯은 앱에서 가장 관련성이 높은 콘텐츠에 대한 즐겁고 시기적절한 보기로 깊은 개인화를 제공합니다.

그것들은 모두 눈에 뛑어보는 것에 관한 것이다.

사람들은 위젯이 앱에서 가장 유용한 정보를 한 눈에 정확하게 적시에 제공하는 방법을 좋아합니다.

탭하면 앱의 오른쪽 부분으로 딥 링크할 수 있습니다.

지난 한 해 동안, 당신은 우리에게 진정으로 영감을 준 놀라운 위젯 경험을 만들었습니다.

최고의 위젯은 집중적이고 역동적이며 하루 종일 앱에 대한 독특한 뷰를 제공합니다.

이것처럼, 첫날부터.

산타크루즈로 여행을 가는 나와 내 아이들이야.

올바른 맥락에서 올바른 콘텐츠를 표면화하는 것은 사용자가 앱의 마법을 발견하는 데 도움이 됩니다.

그리고 우리는 위젯이 사람들이 당신의 앱을 더 많이 사용하도록 장려하는 것을 보았습니다.

올해, 우리는 위젯으로 앱을 더 유용하고 발견할 수 있도록 다음 단계를 밟고 있습니다.

그리고 그것은 사람들이 iPad 홈 화면의 앱들 사이에 위젯을 배치하도록 하는 것으로 시작됩니다.

큰 화면을 활용하기 위해, 우리는 위젯을 위한 새로운 초대형 크기를 도입하고 있습니다.

이것은 iPad에서 가장 잘 작동하는 완전히 새로운 유형의 위젯을 위한 완전히 새로운 기회를 의미합니다.

위젯에 더 쉽게 들어갈 수 있도록, 우리는 iPhone과 iPad의 위젯으로 새로운 기본 홈 화면 레이아웃을 추가하고 있습니다.

여기에는 스마트 스택으로 배열된 사람들이 가장 많이 사용하는 앱의 위젯이 포함됩니다.

스택을 사용하면 여러 개의 위젯을 서로 위에 배치하여 공간을 절약할 수 있습니다.

스마트 스택은 장치 내 지능을 사용하여 현재 가장 관련성이 높은 위젯을 보여줍니다.

작년의 TimelineRelevance API를 기반으로, 우리는 단순히 온디바이스 인텔리전스로 스택을 회전시키는 것을 넘어서고 있습니다.

이제 우리는 그것이 이미 스택에 있지 않더라도 제안함으로써 당신의 위젯에 더 많은 노출을 줄 수 있습니다.

그리고 우리는 이걸 어떻게 해?

위젯 제안을 입력하세요.

사람들이 당신의 앱과 상호 작용하는 방법과 당신이 우리에게 말할 수 있는 것은 우리가 당신의 위젯을 스택에 제안하는 데 도움이 됩니다.

이것이 Fruta 예제 앱에서 어떻게 작동하는지 봅시다.

사용자가 매일 아침 녹색 주스를 주문하면, 온디바이스 인텔리전스는 그것을 제안하는 법을 배울 것이다.

선택하려면, 의도 프레임워크를 채택하고 상호 작용을 기부해야 합니다.

그게 다야!

이제 사람들이 앱을 사용하는 방식에 따라 위젯을 자동으로 제안할 수 있습니다.

사용자에게 새로운 정보를 제공하고 싶을 때, Intents API를 사용하여 기부할 수도 있습니다.

예를 들어, Fruta 앱은 무료 생일 스무디를 제공하기 위해 이것을 채택할 수 있다.

과거의 사용 행동과 새로운 관련 의도 기부는 적시에 스택에 위젯을 제안하는 데 도움이 될 수 있습니다.

그리고 사용자가 위젯이 유용하다고 생각한다면, 길게 눌러 영구적으로 쉽게 추가할 수 있습니다.

그래서 그것은 올해 위젯에 대한 우리의 큰 업데이트이다.

그 어느 때보다 더 유용하고, 발견할 수 있다.

다음은 SharePlay에 대한 뉴스입니다.

라이언과 후안에게.

올해, 우리 모두는 새로운 연결 방법을 찾기 위해 즉흥적으로 해야 했다.

그리고 여러분 중 많은 사람들이 혁신하고, 사람들이 멀리 떨어져 있는 동안 공생감을 느낄 수 있는 멋진 새로운 방법을 만드는 것을 보는 것은 놀라운 일이었습니다.

그리고 사람들이 연결 상태를 유지하기 위해 그 어느 때보다 FaceTime과 iMessage에 의존하기 때문에, 사람들이 떨어져 있을 때 더 함께 느낄 수 있도록 그 경험을 구축하는 것은 당연했습니다.

사람들이 함께 하는 가장 의미 있는 순간 중 일부는 단순히 대화를 공유하는 것 이상의 경험을 공유하는 것이다.

그래서 그 친밀감을 키우기 위해, 우리는 완전히 새로운 것을 만들어야 했다.

그리고 우리는 야심찬 목표를 가지고 있었다.

우리는 페이스타임이 사람들을 가장 친한 친구 및 가족과 같은 공간으로 수송하는 포털처럼 느껴지기를 원했습니다.

그래서 우리는 SharePlay를 만들었다.

그리고 우리는 새로운 GroupActivities 프레임워크로 마법 같은 SharePlay 경험을 만드는 데 필요한 도구를 제공했습니다.

우리는 그룹을 가져오고, 당신은 활동을 가져옵니다.

그리고 그것은 모두 이 활동 개념으로 귀결된다.

FaceTime 통화 중인 누군가가 활동을 시작하면, SharePlay는 그룹을 앱으로 직접 가져와 사용자가 익숙한 것처럼 소통할 수 있는 풍부한 대화형 경험을 제공합니다.

그룹 활동 프레임워크로 탐구할 수 있는 많은 가능성이 있다.

그리고 가장 친한 친구들과 함께 좋아하는 쇼를 보는 것보다 가상 거실에서 할 수 있는 더 좋은 활동이 있나요?

이봐, 후안, 네 팀이 방금 SharePlay를 TV 앱에 통합한 걸 끝냈으니까, 우리한테 구경시켜줄래?

물론이지! 뭐 보고 싶어?

작은 "테드 올가미"는 어때?

좋은 생각이야.

재생을 누르면, 시스템에서 공유 재생을 시작할 것인지, 아니면 로컬에서 재생할 것인지 묻습니다.

여기가 네가 들어오는 곳이야.

우리는 앱의 기존 비디오 경험에 맞게 설계된 재생을 시작할 수 있는 새로운 API를 제공하고 있습니다.

이제 공유 재생을 선택했기 때문에, 시스템은 내 장치와 라이언의 비디오를 코어 미디어 및 그룹 활동과 정확히 동시에 조정하고 있다.

그것은 내가 일시 정지를 눌렀을 때, 후안의 비디오가 정확히 같은 순간에 멈춘다는 것을 의미한다.

나는 심지어 가장 좋아하는 장면으로 뛰어들 수 있고 마치 우리 모두가 같은 방에 있는 것처럼 모두가 나와 함께 온다.

알았어? 내 말은, 이봐, 히긴스와 나는 오늘 점심을 먹을 거야.

난 이 장면이 좋아!

이 재생 조정의 마법은 당신의 미디어가 어떤 식으로든 재전송되지 않는다는 것을 의미합니다.

항상 그렇듯이 앱에서 재생되고 서버에서 스트리밍되기 때문에 모든 사람이 완전 충실도 비디오를 받을 수 있습니다.

이제, 간단한 미디어 앱에서 그룹 활동을 채택하고 프레임워크를 최대한 활용하는 것이 얼마나 쉬운지 봅시다.

공유 재생을 위해 앱을 준비하기 위한 몇 가지 단계가 있습니다.

먼저, 우리는 그룹 활동을 정의해야 한다.

우리는 그룹 활동 프로토콜을 준수하는 새로운 유형을 만들고, 그룹의 모든 사람이 로드할 수 있는 URL을 제공할 것입니다.

앱이 이미 콘텐츠에 대한 딥 링크를 지원한다면, 여기에서 사용할 수 있습니다.

우리는 또한 확인 대화 상자 및 통지와 같은 시스템 UI를 사용자 정의하기 위해 시스템에 몇 가지 기본 메타데이터를 제공할 것입니다.

다음으로, 우리는 플레이 버튼을 연결해야 합니다.

Play() 함수에서 새로운 활동을 만들고 .prepareForActivation()을 호출합니다.

이것은 시스템이 당신이 이전에 본 확인 대화를 제시할 때입니다.

추가 조건 없이 이것을 부를 수 있습니다.

사용자가 FaceTime 통화를 하지 않으면 즉시 돌아올 것입니다.

이제 들어오는 활동을 처리하는 데 관심을 돌봅시다.

개시자는 다른 참가자들과 마찬가지로 세션에 참여하므로, 코드는 모든 사람에게 동일하게 보입니다.

여기서, 저는 전달되는 각 세션과 함께 새로운 모델을 만들기 위해 Swift concurrency를 사용하고 있습니다.

그런 다음 플레이어가 나타나면 새로운 세션에 참여할 것입니다.

그에 따라 UI를 업데이트하기 위해 다른 상태 변경에 대한 세션을 관찰할 수 있습니다.

마지막으로, 우리가 선수들을 동기화하도록 합시다.

1단계: AVPlayer를 잡고 세션에서 .playbackCoordinator.coordinate WithSession을 호출하세요.

2단계: 2단계는 없습니다.

그게 다야!

그것이 그룹 활동 및 AVPlayer와 프레임 정확한 AV 동기화를 얻기 위해 해야 할 전부입니다.

시스템이 나머지를 처리한다.

이제 우리는 공유된 미디어 경험에 대해 많이 이야기했다.

하지만 우리는 그룹 활동이 당신이 꿈꿀 수 있는 가장 야심찬 경험에도 힘을 실어줄 수 있는 기반을 제공하기를 원했습니다.

그래서 우리는 오늘 그룹 페이스타임을 구동하는 패브릭 위에 구축하기 시작하여 앱에 빠르고 신뢰할 수 있는 데이터 채널을 제공합니다.

그룹 리더로 일함으로써, 우리 서버는 전체 그룹을 위한 중앙 집중식 상태를 조율한다.

이 서버들은 모두 종단간 암호화되어 비공개로 유지되기 때문에 사용자의 데이터를 볼 수 없습니다.

그리고 이 빠르고 안전한 데이터 채널을 사용하면 공유 책의 페이지를 넘기는 것부터 누군가가 공유 화이트보드에서 그린 스트로크를 보는 것까지 몰입형 경험을 만들 수 있습니다.

우리는 당신이 우리의 API를 최대한 활용하고 이전과 같은 사용자들을 한데 모을 수 있도록 영감을 주고 싶습니다.

하지만 우리가 당신에게 데모를 보여주기 전에, 우리는 이것에 대해 약간의 추가 도움을 요청해야 할 것입니다.

여러분. 참여해줘서 고마워.

우리는 그룹 활동의 힘을 실제로 보여주기 위해 이 마지막 데모에 당신의 도움이 필요할 것입니다.

좋아요, 그룹 활동으로 무엇을 할 수 있는지 보여주는 화이트보드 데모 앱이 있습니다.

이제, 공유 캔버스를 열어서, 나는 함께 그릴 그룹과 함께 새로운 활동을 시작하고 있다.

이제 우리는 모두 같은 캔버스를 보고 있으며, 완전히 새로운 방식으로 서로 상호 작용할 수 있습니다.

내가 캔버스 어딘가에 그림을 그리면, 모두가 내가 그린 것을 라이브로 볼 수 있다.

이제 이 앱은 이전에 본 것과 동일한 API를 사용하고 있지만, 미디어를 동기화하는 대신 GroupSessionMessenger를 사용하여 내 스트로크를 모든 사람의 장치로 보내고 있습니다.

그리고 이건 화면 공유가 아니야.

이 앱은 모든 사람의 iPad에서 기본적으로 실행되기 때문에, 캔버스에도 그림을 그릴 수 있습니다.

우리 모두 시도해 보자.

그래서 우리는 아무리 멀리 떨어져 있어도 공유 캔버스 주위에 모일 수 있다.

그리고 그것은 우리를 전례 없는 하나로 모으고 있다.

도와주셔서 감사합니다, 여러분.

가장 좋은 점은, 방금 본 모든 것 - SharePlay 활동, 재생 동기화 및 빠르고 안전한 데이터 채널 - 앱을 GroupActivities 프레임워크와 통합하는 것만으로 이러한 모든 이점을 얻을 수 있습니다.

SharePlay는 앱의 콘텐츠를 향상시키고 사용자에게 더 몰입감 있는 경험을 만드는 데 도움이 되는 훌륭한 새로운 방법입니다.

우리는 당신이 그룹 활동을 사용하여 생각해 낼 새로운 공유 경험을 보고 싶습니다.

이제, 일을 마무리하기 위해 수잔에게 가.

우리는 당신이 오늘 본 발전이 당신이 차이를 만드는 앱을 계속 만드는 데 도움이 될 것이라고 믿습니다.

우리는 당신의 워크플로우를 간소화하고 훌륭한 앱을 더 빠르게 만들 수 있는 도구를 만들고 있습니다.

우리는 전문 제작자를 위한 몰입형 콘텐츠, 게임 및 도구를 더 쉽게 만들 수 있도록 만들었습니다.

우리는 당신의 앱이 가장 중요한 것에 집중하면서 사용자가 연결하는 데 어떻게 도움이 될 수 있는지 보여주었습니다.

당신이 오늘 본 것은 시작에 불과합니다.

이번 주에 확인해야 할 것이 너무 많아서 우리는 만질 기회조차 없었다.

우리는 네가 뭔가 멋진 것을 만들 거라는 걸 알아, 그리고 우리는 그걸 빨리 보고 싶어.