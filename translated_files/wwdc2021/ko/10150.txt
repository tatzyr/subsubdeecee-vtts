10150

♪ 베이스 음악 연주 ♪

♪

알리 데 종: WWDC 2021에 오신 것을 환영합니다.

제 이름은 알리 드 종이고, 저는 애플의 GPU 소프트웨어 엔지니어입니다.

그리고 오늘, 제 동료 데이비드 누녜스 루비오와 함께, 우리는 메탈 레이 트레이싱으로 하이브리드 렌더링을 탐구할 것입니다.

우리는 레이 트레이싱이 당신의 비주얼에 가져올 수 있는 몇 가지 개선 사항을 보여주는 것으로 시작할 것입니다. 그런 다음 "하이브리드 렌더링"이라는 기술을 사용하여 레이 트레이싱 패스를 래스터화에 통합하는 방법에 대해 논의합니다. 그런 다음 데이비드는 레이 트레이싱을 구현하는 데 도움이 되는 새로운 도구를 안내할 것입니다.

레이 트레이싱을 위한 몇 가지 훌륭한 사용 사례를 살펴보는 것으로 시작합시다.

게임과 영화는 끊임없이 증가하는 리얼리즘을 추구하고 있으며, 수년 동안 그래픽에 대한 접근 방식은 래스터화에 의한 것이었다.

래스터화는 실시간 속도로 아름다운 이미지를 생성하는 데 탁월하다.

그러나, 우리가 성취할 수 있는 것에는 한계가 있다.

레이 트레이싱은 셰이더에서 세계를 쿼리하여 새롭고 흥미로운 기술의 문을 열 수 있는 메커니즘이다.

그리고 그것을 래스터화와 결합함으로써, 우리는 비주얼을 크게 향상시킬 수 있다.

몇 가지 예를 살펴봅시다.

래스터화에 항상 문제가 있었던 한 영역은 반사이다.

이것은 우리가 래스터화된 픽셀을 음영할 때, 정확한 반사를 위한 나머지 장면의 맥락이 없고 그 정보를 생성하기 위해 추가 작업을 해야 하기 때문입니다.

레이 트레이싱을 통해 우리는 음영 처리된 픽셀에서 배열을 추적하고 세상에 무엇이 있는지 발견할 수 있습니다.

더 좋은 것은, 우리는 반사에 올바른 그림자와 반사를 적용하기 위해 이 과정을 재귀적으로 적용할 수 있다.

레이 트레이싱이 뛰어난 또 다른 영역은 그림자이다.

래스터화, 그림자의 일반적인 흐림 및 오토바이의 곡선 표면의 그림자 지도 해상도로 인한 앨리어싱에 주목하세요.

광선 추적 그림자는 더 선명하며 그림자 편향과 같은 인공 매개 변수 없이 앨리어싱 문제를 해결합니다.

부드러운 그림자는 또한 더 정확하게 근사할 수 있다.

우리는 음영 처리된 지점에 대한 막히는 물체의 근접성에 따라 더 단단하거나 부드러운 그림자를 자연스럽게 만들 수 있다.

래스터화를 통해, 우리는 샘플링 시간에 그림자 지도를 필터링하는 것에 의존해야 할 것이다.

하지만 광선 추적을 통해, 우리는 단순히 원뿔에서 광선을 추적하여 이 결과를 얻을 수 있다.

마지막으로, 레이 트레이싱이 우리의 시각을 높일 수 있는 또 다른 영역은 투명성이다.

이것은 전통적으로 래스터화 기술을 정확하게 다루기가 매우 어렵다.

이 이미지에서, 햇빛이 창문을 통해 어떻게 들어오는지 주목하지만, 유리의 불투명한 글자는 그림자를 내지 않는다.

전통적인 그림자 매핑 기술은 종종 투명한 물체에 문제가 있다.

레이 트레이싱을 통해, 우리는 투명한 재료에 대한 사용자 지정 교차 기능을 만들 수 있습니다.

이를 통해, 우리는 어떤 광선이 물질을 통과할 수 있고 어떤 광선이 통과하지 못하는지 정의할 수 있으며, 자연스럽게 흉상 머리에 있는 글자와 같은 투영된 그림자를 생성할 수 있다.

그리고 물론, 모든 그림자는 전반적으로 더 선명해 보인다.

그렇다면 왜 레이 트레이싱이 우리의 시각을 그렇게 극적으로 향상시킬 수 있을까요?

이것을 이해하기 위해, 전통적인 래스터화 과정이 어떻게 작동하는지 살펴봅시다.

래스터화 과정에서, 메쉬는 렌더링하기 위해 금속으로 보내진다.

그것들은 버텍스 셰이더에 의해 세계와 카메라 앞에 배치되며, 그 프리미티브는 래스터라이저에 의해 픽셀 또는 조각에 배치된다.

그런 다음 이 픽셀들은 조각 셰이더에 의해 음영 처리되며, 결과는 출력 이미지에 혼합됩니다.

아시다시피, 각 픽셀은 독립적으로 음영 처리될 수 있으며, 병렬로 작동하며, 이는 GPU가 래스터화 프로세스를 매우 잘하는 이유입니다.

그러나 절충안은 우리가 셰이딩을 적용할 때, 우리는 나머지 장면의 맥락을 완전히 잃어버렸고 이 픽셀과 관련된 지점을 둘러싸고 있는 물체가 무엇인지 모른다.

고급 게임 엔진은 중간 정보를 생성하는 추가 렌더링 패스를 추가하여 이 상황을 만회합니다.

그런 다음 프래그먼트 셰이더는 그 데이터를 활용하여 포인트가 있는 기하학적 맥락의 세부 사항을 근사할 수 있다.

이것이 어떻게 작동하는지 좀 더 자세히 살펴봅시다.

이 기술의 경우, 장면에 대한 기하학적 정보를 화면으로 직접 하는 대신 중간 텍스처로 래스터화합니다.

이것은 알베도, 깊이 또는 정상과 같은 것일 수 있다.

이것은 일반적으로 기하학 버퍼 패스 또는 줄여서 G-버퍼 패스라고 불린다.

중간 텍스처는 빛이 장면의 물체와 어떻게 상호 작용하는지 근사하기 위해 스마트 트릭을 사용하는 빛 근사치 패스의 입력으로 사용됩니다.

몇 가지 예로는 화면 공간 주변 폐색과 화면 공간 반사가 있다.

마지막 단계에서, 우리의 중간 부착물은 종종 더 부드러운 이미지를 만들기 위해 노이즈가 제거되거나 약간 흐려지며, 모든 것이 함께 결합되어 최종 이미지를 생성합니다.

이러한 정교한 기술은 때때로 이미지를 개선하는 데 도움이 될 수 있지만, 여전히 근사치일 뿐이다.

반면에, 레이 트레이싱은 더 정확한 시각과 단순화된 시각 기술을 가능하게 하는 완전히 다른 접근 방식을 취한다.

레이 트레이싱에서 한 번에 하나씩 메쉬를 처리하는 대신, 우리는 전체 장면을 포함하는 가속 구조를 구축합니다.

일단 우리가 그것을 갖게 되면, 우리는 GPU가 주어진 방향으로 지점에서 광선을 추적하고 교차로를 찾을 수 있다.

이것은 우리에게 모든 문맥 장면 정보에 접근할 수 있게 해준다.

레이 트레이싱은 레이 상호 작용을 모델링하기 때문에, 렌더링 이상의 응용 프로그램도 있다.

오디오 및 물리 시뮬레이션, 충돌 감지 또는 AI 및 경로 찾기에 사용할 수 있습니다.

레이 트레이싱은 매우 강력한 기술이기 때문에, 우리는 레이 트레이싱과 래스터화를 결합하여 각각의 고유한 이점을 얻고자 하며, "하이브리드 렌더링"이라는 기술을 통해 그렇게 할 수 있습니다.

이제 하이브리드 렌더링 프레임을 만드는 방법과 이 기술의 몇 가지 사용 사례를 살펴봅시다.

래스터화된 프레임 다이어그램에서 시작하면, 레이 트레이싱을 사용하여 빛 근사치 패스의 일부 또는 전부를 대체할 수 있습니다.

우리는 여전히 G-버퍼를 래스터화합니다 -- 그것은 우리의 주요 광선의 역할을 합니다 -- 그리고 나서 우리는 레이 트레이싱을 사용하여 나머지 장면을 쿼리하여 빛의 특성을 더 현실적으로 시뮬레이션합니다.

우리는 여전히 노이즈를 빼고 가벼운 구성을 통과하지만, 우리의 결과는 장면 데이터에 훨씬 더 정확하다.

이 프레임 아키텍처는 많은 하이브리드 렌더링 기술을 탐구할 수 있는 좋은 토대를 제공한다.

메탈을 사용하여 이와 같은 프레임을 어떻게 인코딩할 수 있는지 살펴봅시다.

우리는 G-버퍼를 작성하는 것으로 시작합니다.

그렇게 하기 위해, 우리는 렌더링 패스를 만들고 G-버퍼를 작성하고 그 텍스처를 패스의 첨부 파일로 설정합니다.

우리는 렌더링된 콘텐츠를 후속 패스에서 사용할 수 있도록 이미지가 메모리에 저장되도록 합니다.

우리는 패스를 시작하고, 렌더링을 인코딩하고, 렌더링 패스를 끝낸다.

다음으로, 우리는 이것에 광선 추적 컴퓨팅 디스패치를 추가할 것이다.

그래서 우리가 중간 텍스처를 만든 후, 레이 트레이싱 패스를 인코딩합시다.

우리는 동일한 명령 버퍼에서 컴퓨팅 패스를 만들고 G-Buffer 텍스처를 입력으로 설정해야 합니다.

기본적으로 Metal은 쓰기-읽기 종속성을 추적하므로 동기화에 너무 신경 쓰지 않고 알고리즘에 자유롭게 집중할 수 있습니다.

이것은 계산이기 때문에, 우리는 광선 추적 작업의 결과를 쓰기 위해 출력 텍스처를 설정합니다.

우리는 광선 추적 기술을 위해 PipelineState 객체를 설정했다.

컴퓨팅 셰이더의 각 스레드는 픽셀이나 영역에 대한 광선 추적 결과를 계산할 것이다.

마지막으로, 우리는 2D 그리드를 파견하고 이 패스를 끝낸다.

이 패스가 인코딩된 후, 우리는 이제 빛 축적 패스와 같은 더 많은 작업을 계속 인코딩할 수 있거나, 나머지 프레임을 인코딩하는 동안 GPU가 작업을 시작할 수 있도록 명령 버퍼를 제출할 수 있습니다.

우리가 작업을 두 패스로 인코딩했기 때문에, 패스가 서로 통신할 수 있도록 중간 렌더링 첨부 파일을 시스템 메모리에 저장해야 합니다.

이것은 작동하지만, 애플 실리콘과 iOS 기기에서는 이것을 더 좋게 만들 수 있는 기회가 있다.

Apple GPU에서 하드웨어는 타일 메모리를 사용하여 작업할 때 픽셀 데이터를 보관합니다.

패스가 끝날 때, 이 타일 메모리는 시스템 메모리로 구체화되며 다음 패스의 시작 부분에서 다시 로드되어야 합니다.

하지만 이상적으로, 우리는 시스템 메모리로의 왕복을 피하면서 타일 메모리에서 직접 컴퓨팅 패스 작업을 할 것이다.

올해 우리가 렌더링 파이프라인에서 광선 추적 작업을 파견하여 그것을 할 수 있는 능력을 추가한 것을 공유하게 되어 기쁩니다.

이를 통해 한 번에 타일 셰이더를 통해 렌더링과 컴퓨팅을 혼합하여 레이 트레이싱을 위해 타일 메모리를 활용할 수 있습니다.

이것은 대역폭 사용, 메모리 소비를 줄이고 사용자의 장치가 더 시원하게 작동하도록 도울 것입니다.

2019년 "메탈을 사용한 현대 렌더링" 세션을 검토하여 렌더링과 컴퓨팅을 효율적으로 혼합하는 방법을 배우면 렌더링에서 레이 트레이싱에 적용할 수 있습니다. 올해의 "메탈 레이 트레이싱으로 앱 향상" 세션에서 올해 메탈 레이 트레이싱의 다른 개선 사항에 대해 알아보십시오.

이제 하이브리드 렌더링 워크로드를 인코딩하는 방법을 알았으니, 레이 트레이싱으로 개선할 수 있는 몇 가지 기술을 검토해 봅시다.

우리는 그림자, 주변 폐색 및 반사에 초점을 맞출 것이다.

그림자부터 시작하자.

그림자는 장면 내에서 물체의 근접성을 전달하는 데 도움을 준다.

하지만 이것은 래스터화에 대한 도전이다. 왜냐하면 우리는 셰이딩할 때 장면의 맥락을 잃기 때문이다.

그림자 매핑은 이러한 정보 부족을 보완하는 데 도움이 될 수 있지만 각 빛의 관점에서 추가 렌더링이 필요합니다.

이 래스터화 기술은 모든 빛의 관점에서 장면을 렌더링하는 것으로 시작한다.

이것은 각 빛의 변환 매트릭스와 함께 저장해야 하는 일련의 깊이 지도를 생성합니다.

그런 다음 우리는 메인 카메라의 관점에서 렌더링합니다.

각 픽셀을 음영 처리하려면, 우리는 그 점을 빛의 좌표로 변환해야 한다.

우리는 깊이 지도에서 나오는 깊이를 샘플링하고 궁극적으로 이러한 깊이 값을 비교하여 각 광원에 대해 빛에 있는지 그림자에 있는지 결정합니다.

이 기술에는 몇 가지 단점이 있다.

먼저, 우리는 각 빛에 대한 빛의 관점에서 장면을 렌더링해야 할 것이다.

이것은 장면을 여러 번 처리하는 것을 의미한다.

둘째, 그림자 지도는 미리 정해진 해상도를 가지고 있으며, 이는 우리의 그림자가 앨리어싱의 대상이 될 것이라는 것을 의미합니다. 그리고 더 나쁜 것은, 우리는 이미지에 맞지 않는 픽셀에 대한 정보가 없을 것입니다.

이것을 광선 추적 그림자와 비교해 봅시다.

광선 추적으로 그림자를 계산하기 위해, 우리는 단순히 광원의 방향으로 광선을 추적하고 어떤 물체가 그 경로를 막고 있는지 결정할 수 있습니다.

만약 우리가 아무것도 찾지 못한다면, 그것은 음영을 위해 이 광원을 고려해야 한다는 것을 의미한다.

물체가 경로를 막고 있는 경우, 우리는 조명 방정식에서 광원의 기여를 제외합니다.

이것이 어떻게 막는 물체의 실루엣에 해당하는 자연스러운 그림자를 생성하는지 주목하세요.

더 나아가, 우리는 더 이상 깊이 지도에 저장된 정보에 국한되지 않습니다.

우리는 빛의 frustum 또는 카메라의 시야 밖의 점에 대한 그림자를 결정할 수 있다.

레이 트레이싱으로 그림자 기술이 어떻게 단순화되는지 봅시다.

우리는 메인 카메라에서 렌더링하는 것으로 시작한다.

다음으로, 우리는 카메라의 위치에서 렌더링된 가속 구조와 깊이 맵을 취하여 광선 추적 커널에 공급합니다.

픽셀 위치를 계산한 다음, 우리는 단순히 빛의 방향으로 광선을 추적하기만 하면, 교해된 물체와 교차점이 발견되었는지 여부에 따라 그 점이 켜져 있는지 그림자에 있는지를 결정합니다.

이 과정은 최종 이미지를 얻기 위해 렌더링 패스 결과와 결합할 수 있는 그림자 텍스처를 생성합니다.

이것을 하기 위해 메탈 셰이더를 코딩하는 방법을 살펴봅시다.

셰이더 코드에서, 우리는 각 스레드가 깊이와 thread_id에서 처리할 위치를 계산하는 것으로 시작합니다.

우리는 계산된 위치에서 그림자 광선을 만들고 빛의 방향으로 추적하도록 설정합니다.

포인트 조명, 스포트라이트 및 지역 조명과 같은 대부분의 조명 유형의 경우, 우리는 지점에서 광원까지 추적하도록 최소 및 최대를 설정합니다.

방향 그림자의 경우, 우리는 최대를 무한대로 설정하고 싶을 수도 있습니다.

또한, 더 부드러운 그림자를 위해 콘 레이 트레이싱을 구현하기로 결정한다면, 이곳은 섀도우레이에 지터를 추가할 수 있는 좋은 장소입니다.

그런 다음 우리는 섹터 간 객체를 만든다.

만약 우리가 하나의 교차로를 발견한다면, 그것은 우리가 그림자 속에 있다는 것을 의미하므로, 우리는 교차로를 받아들이도록 인터섹터를 구성한다.

마지막으로, 우리는 가속 구조와 교차한다.

그 교차 결과를 바탕으로, 우리는 포인트가 켜져 있는지 여부를 작성하며, 이는 장면에 더 정확한 그림자 텍스처를 만듭니다.

그 그림자 텍스처가 적용되면, 당신은 우리가 훨씬 더 사실적인 그림자를 얻고 앨리어싱을 제거하는 것을 볼 수 있습니다.

레이 트레이싱을 통해 그림자를 결정하는 것은 매우 자연스러운 기술이 된다.

우리는 무언가가 그 지점의 광원을 차단하는지 아닌지를 찾기 위해 광선을 추적한다.

더 이상 중간 깊이 맵을 가질 필요가 없으며, 각 빛에 대해 여러 개의 추가 렌더링 패스를 피할 수 있습니다.

이 기술은 깊이에만 의존하기 때문에 지연 또는 순방향 렌더러로 구현하기 쉽다.

그리고 마지막으로, 그것은 반투명 재료에 대한 사용자 지정 교차 기능을 허용합니다.

다음으로, 주변 폐색을 살펴봅시다.

개념적으로, 기하학으로 둘러싸인 점은 많은 양의 주변광을 받을 가능성이 적다.

주변 폐색은 이웃이 얼마나 바쁜지에 따라 한 지점에서 수신된 주변광을 음소거하는 것으로 구성되며, 이는 자연스럽게 틈을 어둡게 하여 최종 이미지에 더 깊이를 준다.

이를 달성하기 위한 래스터화 기술은 주변과 잠재적으로 그것을 막는 물체가 있는지 결정하기 위해 지점 근처의 깊이와 노멀을 샘플링하는 데 달려 있다.

얼마나 많은 주변 물체가 발견되었는지에 따라, 우리는 주변광을 음소거하고 이미지에 적용할 텍스처를 만들기 위해 감쇠 계수를 계산합니다.

그러나 깊이 버퍼와 표면 법선과 같은 화면 공간 정보에 의존하는 것은 이미지의 경계 밖에 있는 보이지 않는 오클러와 물체에 대한 정보가 누락된다.

레이 트레이싱을 사용하면 화면 공간 정보에 의존하는 대신 장면의 실제 기하학적 데이터에 의존할 수 있습니다.

아이디어는 모든 픽셀을 음영 처리하기 위한 것이며, 우리는 반구에서 임의의 광선을 생성하고 물체에 대한 교차점을 검색합니다.

교차로가 발견되면, 우리는 주변 폐색 요인을 고려합니다.

우리는 가속 구조로 다시 시작한다.

이 기술을 위해, 우리는 일반 데이터와 깊이가 필요하므로, G-버퍼 패스에서 그것들을 수집합니다.

깊이와 법선은 반구에서 무작위 광선을 생성하는 데 사용된다.

다음으로, 우리는 광선을 추적하고 감쇠 계수를 계산한다.

이것은 틈이 자연스럽게 어두워지는 이미지를 생성하여 효과를 낸다.

주변 폐색을 위한 금속 셰이더를 살펴봅시다.

먼저, 우리는 무작위 광선을 생성한다.

이 경우, 우리는 각 스레드의 정상을 따라 cosineWeightedRay를 취합니다.

우리는 작은 동네에만 관심이 있기 때문에, 최대 거리를 작은 숫자로 설정했다.

다음으로, 우리는 인터섹터를 만들고 가속 구조를 교차한다.

결과에 따라, 우리는 감쇠 인자로 축적된다.

여기 나란히 비교가 있습니다.

그리고 우리는 광선 추적 접근 방식이 얼마나 더 좋아 보이는지 즉시 알 수 있다.

나는 화면 공간 효과의 한계를 보여주는 몇 가지 장소를 강조하고 싶다.

다음은 제한된 화면 공간 정보로 인해 이웃이 잘못 표시되는 예입니다.

이것은 실제 기하학이 카메라에 거의 수직이기 때문에, 이 각도의 깊이 버퍼가 아니기 때문이다.

같은 문제가 이미지 전체, 특히 오토바이 아래에서 발생한다.

이 각도에서, 모페드의 바닥은 깊이 버퍼에서 빠져 있다.

그래서 화면 공간 기술은 감쇠를 완전히 놓친다.

반면에, 광선 추적 버전은 바닥 픽셀에 대한 오토바이 바닥과의 교차점을 정확하게 발견한다.

그리고 여기 화면 테두리 주변의 한계에 대한 좋은 예가 있습니다.

차단된 기하학은 오프스크린이므로, 그 기여는 화면 공간 기술에서 손실되지만, 레이 트레이싱에서 설명된다.

우리가 볼 수 있듯이, 하이브리드 렌더링은 장면의 실제 기하학을 사용하여 상당한 품질 개선을 제공하여 화면 공간 정보의 제한으로부터 기술을 해제합니다.

그리고 마지막으로, 반성을 살펴봅시다.

반사는 전통적으로 래스터화에 매우 어려웠다.

반사 프로브는 잘 작동하지만 해상도가 제한되고, 필터링이 필요하며, 동적 기하학으로 고군분투하는 기술이다.

화면 공간 반사 기술은 화면 공간 정보에 의해 제한된다.

반사 프로브는 주변 색상 정보를 캡처하기 위해 전체 장면을 따라 카메라를 전략적으로 배치해야 하는 솔루션입니다.

반사 프로브를 사용하기 위해, 큐브 맵은 장면의 다른 위치에서 캡처됩니다.

이것은 본질적으로 같은 지점에서 여섯 방향으로 장면을 렌더링하는 것이다.

픽셀이 음영 처리되면, 프로브와의 관계를 계산하고 큐브 맵을 샘플링하여 반사된 음영을 생성합니다.

현실적인 결과를 위해, 보통 많은 프로브가 장면 전체에 흩어져야 한다.

그리고 동적 물체가 장면을 가로질러 이동함에 따라, 셰이더는 하나 이상의 큐브 맵에서 샘플링하고 반사된 색상을 수동으로 보간해야 합니다.

큐브 맵은 또한 조도를 정확하게 나타내기 위해 사전 필터링되어야 하며 해상도가 제한되어 있다.

또 다른 래스터화 기술인 화면 공간 반사는 이미 프레임 버퍼에 있는 픽셀에 반사를 기반으로 하여 이러한 문제 중 일부를 피한다.

프래그먼트 셰이더는 노멀을 사용하여 점진적으로 바깥쪽으로 행진하고 잠재적인 주변 물체에 대한 깊이 지도를 확인합니다.

우리가 무언가를 찾으면, 프레임 버퍼에서 직접 색상을 샘플링하고 출력 이미지에 음영처리합니다.

그러나, 그것은 우리가 이전에 논의한 화면 공간 제한으로 고통받고 있다.

이 모페드 예에서 표면의 일부만이 프레임버퍼에 있는 바닥 타일에 해당하는 정확한 반사를 얻을 수 있다는 것을 주목하세요.

그 장면의 나머지 부분은 사라졌다.

더 나쁜 것은, 노란색으로 표시된 펜더 뒤의 아래쪽 부분에는 정보가 누락되어 있다; 우리는 카메라에서 멀리 향하는 표면이 어떻게 생겼는지 알 방법이 없다.

광선 행진은 또한 계산 비용이 많이 들 수 있다.

그러나 광선 추적 반사는 가속 구조의 실제 장면 정보에 의존할 수 있기 때문에 두 가지 문제를 모두 극복하는 데 도움이 된다.

완벽한 거울이 어떻게 작동하는지 살펴봅시다.

먼저, 우리는 카메라의 위치에서 지점까지 사고 광선을 가져간다.

그런 다음, 우리는 이 점을 그 점과 관련된 정상에 반영한다.

이것은 우리가 광선을 추적하고 반사된 물체를 찾을 수 있는 방향을 제공한다.

이를 위해, 우리는 G-버퍼의 법선과 깊이를 가진 반사 광선 추적 커널을 제공합니다.

이 광선 추적 커널은 카메라에서 각 지점까지 뷰 벡터를 계산하고, 이 벡터를 반사하고, 그 지점에서 그 방향으로 광선을 추적한다.

마지막으로, 정확한 반사를 위해, 우리는 광선 추적 커널에서 직접 발견되는 교차로를 음영처리할 수 있다.

이 셰이더를 코딩하는 것을 살펴봅시다.

다시 한번, 우리는 그 지점의 깊이에서 시작하여 그 위치를 재구성한다.

이번에, 우리는 그 위치가 세계 공간에 있기를 원한다.

그래서 우리의 calculatePosition 함수에서, 우리는 뷰 행렬의 역을 곱해야 할 것이다.

그런 다음, 우리는 법선 위에 반사된 입사 벡터를 계산하고 그 방향으로 광선을 만듭니다.

다음으로, 우리는 인터섹터를 만들고 반사 광선을 추적한다.

우리가 물체에 부딪히면, 우리는 이제 반사를 일으키기 위해 그 지점을 음영 처리한다.

교차로가 모든 물체를 놓쳤다면, 우리는 스카이박스를 샘플링하고 색상을 반환하여 하늘을 보여주는 반사를 시뮬레이션할 수 있습니다.

셰이딩은 이 기술을 위한 컴퓨팅 커널에서 직접 수행된다는 점에 유의하십시오.

반사 프로브를 광선 추적 반사와 비교해 봅시다.

오른쪽의 이미지는 하이브리드 렌더링을 사용했으며, 바닥 타일의 세부 사항을 훨씬 더 명확하게 볼 수 있습니다.

건물들이 존재하며, 우리는 심지어 오토바이의 전면 패널에 반사된 그림자를 볼 수 있다.

반사는 레이 트레이싱에 자연스럽게 적합하다.

그것은 거울 같은 반사와 거친 반사를 잘 다룬다.

그것들은 원뿔을 따라 여러 광선을 추적하고 결과를 필터링함으로써 달성될 수 있다.

그들은 가속 구조에서 오는 완벽한 정보에 의존하기 때문에, 광선 추적 반사는 화면 공간 아티팩트가 없으며 장면에서 정적 및 동적 기하학을 모두 처리할 수 있다.

이제, 한 가지 중요한 세부 사항: 우리는 반사를 위해 컴퓨팅 커널에서 직접 포인트를 음영 처리해야 한다고 언급했습니다.

이것 또는 글로벌 조명과 같은 일부 기술은 컴퓨팅 커널에서 정점 데이터와 금속 자원에 직접 액세스해야 합니다.

이러한 경우 우리는 GPU가 셰이딩 방정식을 적용하는 데 필요한 데이터에 접근할 수 있는지 확인해야 합니다.

이것은 금속에서 인수 버퍼로 표현되는 바인드리스 바인딩 모델로 달성된다.

자세한 내용은 올해의 "Bindless rendering in Metal" 강연을 꼭 확인하세요.

우리는 방금 하이브리드 렌더링이 몇 가지 다른 기술로 어떻게 실행될 수 있는지 보았다.

이것은 또한 더 정확한 결과를 산출하는 이점이 있는 더 자연스러운 알고리즘으로 이어진다.

어떤 경우에는, 우리가 전통적인 래스터화 기술과 비교할 때, 어떤 경우에는 렌더링 패스를 제거하고 메모리와 대역폭을 절약할 수 있다는 것을 알 수 있다.

렌더링에서 레이 트레이싱을 추가함으로써, 우리는 전체 작업을 칩에 유지할 수도 있습니다.

레이 트레이싱 채택은 큰 작업이며, 우리는 이러한 기술을 엔진에 도입하는 과정에서 당신을 도울 수 있는 훌륭한 새로운 도구를 가지고 있습니다.

올해, 우리는 당신이 광선 추적 작업을 캡처하고, 가속 구조를 검사하고, 가시 및 교차 기능을 검사할 수 있는 도구를 소개합니다.

이제 데이비드는 우리에게 이 새로운 도구들을 둘러볼 것이다.

데이비드 누녜스 루비오: 고마워, 알리. 제 이름은 데이비드 누녜스 루비오이고, GPU 소프트웨어 엔지니어입니다.

작년에, 우리는 금속에 광선 추적 지원을 도입했다.

그러나, 복잡한 응용 프로그램을 개발하는 것은 어려울 수 있다.

다행히도, 메탈 디버거는 당신을 돕기 위해 여기에 있습니다.

올해, 우리는 금속 디버거에 광선 추적 지원을 도입했다.

하이브리드 렌더링의 채택 덕분에, 우리의 데모는 그 어느 때보다 좋아 보인다.

광선 추적된 부드러운 그림자, 반사, 주변 폐색; 결과는 놀랍다.

데모를 개발하는 동안, 우리는 몇 가지 문제를 겪었다.

이것이 도구가 이러한 문제를 해결하는 데 도움이 될 수 있는 방법입니다.

이 초기 버전의 데모에서, 광선 추적 그림자는 이미 구현되었다.

하지만 주의 깊게 살펴보면, 땅에 있는 나무 잎에서 그림자가 빠진 것을 알 수 있습니다.

우리가 참조 버전과 비교한다면 더 분명하다.

참조 대 광선 추적을 보세요.

Xcode로 뛰어들어 도구가 이 문제를 디버깅하는 데 어떻게 도움이 될 수 있는지 봅시다.

우리는 메탈 버튼을 누르고 캡처를 클릭해야 합니다.

이것은 정적인 문제이기 때문에, 우리는 단지 하나의 프레임이 필요하다.

디버거에서 API 호출은 디버그 네비게이터의 왼쪽에 구성됩니다.

그림자 인코딩을 찾기 위해 오프스크린 명령 버퍼를 펼쳐봅시다.

나는 내 컴퓨팅 명령 인코더를 "Raytrace Shadows"로 분류했다.

금속 디버거에서 쉽게 찾을 수 있도록 금속 물체에 라벨을 붙이는 것이 좋습니다.

썸네일은 또한 이것이 실제로 우리가 찾고 있는 인코더라는 힌트를 준다.

이제 디스패치 Threadgroups API 호출을 클릭하여 밴드 리소스를 표시할 수 있습니다.

이것은 현재 커널 디스패치와 관련된 모든 객체의 목록입니다.

그리고 여기서, 우리는 우리가 편리하게 표시한 구조의 가속화를 볼 수 있다.

우리의 커널은 광선을 던지기 위해 가속 구조를 사용한다.

이것은 일반적으로 광선이 교차할 3D 세계를 나타내는 나무와 같은 데이터 구조인 경계 볼륨 계층 구조 또는 BVH로 구현된다.

이제, 가속 구조 뷰어를 열려면 두 번 클릭하세요.

이것은 금속 디버거에 내장된 훌륭한 새로운 도구입니다.

그것이 어떻게 구성되어 있는지에 대한 개요를 알려드리겠습니다.

오른쪽에는 사용자 지정 기하학이나 교차 기능을 포함하여 3D 장면의 광선 추적 시각화가 있는 3D 보기가 있습니다.

이것은 머리카락이나 알파 테스트를 사용할 때와 같은 사용자 지정 기하학과 잘 작동합니다.

익숙한 컨트롤을 사용하여 카메라를 움직이고 주변을 둘러볼 수 있습니다.

그리고 여기 팁이 있습니다: 스크롤하는 동안 옵션 키를 눌러 확대 및 축소하세요.

우리는 우리의 장면을 더 잘 이해하기 위해 훌륭한 시각화 도구를 만들었습니다.

사용 가능한 다양한 모드를 보려면 강조 표시된 메뉴를 클릭해 봅시다.

예를 들어, 우리는 경계 볼륨 횡단을 시각화할 수 있다.

이것은 단일 광선이 표면에 닿기 전에 얼마나 많은 노드를 통과해야 하는지 보여주는 히트 맵이다.

어두운 색상은 더 많은 노드를 횡단하고 더 느린 교차 테스트를 해야 한다는 것을 의미한다.

우리는 또한 가속 구조를 기반으로 장면을 컬러 코딩할 수 있습니다...

기하학...

사례...

또는 교차로 기능.

이제 우리는 그 도구에 좀 더 익숙해졌으니, 원래의 문제로 돌아갈 수 있다.

3D 뷰 덕분에, 우리는 우리의 기하학이 거기에 있다는 것을 확인했다.

그래서 뭔가 다른 게 있을 거야.

왼쪽에는 네비게이터 구역이 있다.

여기서 우리는 상단 및 하단 가속 구조를 볼 수 있습니다.

우리는 그것이 만들어진 기하학 목록을 보기 위해 모든 가속 구조를 펼칠 수 있다.

우리는 불투명도나 원시 수와 같은 특성을 보기 위해 다시 펼칠 수 있다.

우리는 또한 이 가속 구조의 인스턴스 목록을 볼 수 있다.

나무 잎을 클릭하여 네비게이터에서 인스턴스를 공개하고 속성을 검사해 봅시다.

매트릭스는 정확해 보이고, 플래그가 설정되어 있지 않지만, 마스크에 무언가가 빠진 것 같다.

이 데모에서, 우리는 교차로 마스크를 사용하고 있다.

우리는 그림자를 던지는 물체에 플래그를 지정하기 위해 마스크의 가장 낮은 비트를 사용합니다.

그런 다음 우리의 인터섹터는 비트와 연산을 사용하여 이 마스크를 테스트하고 실패하면 교차점을 거부할 것이다.

우리는 이 행동을 3D 보기에서 직접 시각화할 수 있다.

우리는 부문 간 힌트 메뉴를 열어야 한다.

여기서 우리는 시각화를 위한 레이 트래버스 옵션을 구성할 수 있습니다.

우리는 컬링 작업을 변경하거나, 사용자 지정 교차로를 비활성화하거나, 인터섹터의 마스크를 변경할 수 있습니다.

기본적으로, 그것은 모든 것과 교차할 것이다.

우리가 그림자에 사용하고 있는 값으로 바꾸자.

이것은 우리에게 그림자 마스크를 사용할 때 장면의 정확한 시각화를 보여줄 것이다.

그리고 실제로, 우리는 우리의 나무 잎이 지금 없어졌다는 것을 확인했다.

일단 우리가 문제를 확인하면, 우리는 출처로 돌아가서 올바른 마스크 값을 설정하고 있는지 확인해야 합니다.

이것이 그림자가 전에 보였던 방식이다.

그리고 이것이 그들이 마스크 가치를 고친 후 보는 방식이다.

이것은 레이 트레이싱 애플리케이션을 디버깅하는 데 도움이 될 수 있는 워크플로우의 예입니다.

도구에 대해 더 알고 싶다면, 올해의 "금속 디버깅, 프로파일링 및 자산 생성 도구 발견" WWDC 세션을 확인하십시오.

이 세션에서, 우리는 레이 트레이싱이 어떻게 당신의 시각을 향상시킬 수 있는지 검토했습니다.

하이브리드 렌더링은 래스터화와 레이 트레이싱의 조합이다.

이것은 가벼운 근사치 기술을 더 간단한 더 정확한 기술로 대체할 수 있게 해준다.

우리는 또한 당신의 엔진에서 레이 트레이싱을 채택하는 과정에서 당신을 돕는 새로운 도구를 보았습니다.

우리는 래스터화와 레이 트레이싱을 결합하여 어떤 새로운 가능성을 사용할 수 있는지에 대한 표면만 긁었다.

우리는 당신이 미래의 새로운 혁신적인 그래픽 기술을 개발하기 위해 이러한 기술을 어떻게 실천하는지 빨리 보고 싶습니다.

감사합니다 그리고 나머지 WWDC를 즐기세요.

♪