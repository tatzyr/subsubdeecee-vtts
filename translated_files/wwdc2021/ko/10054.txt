10054

♪ 베이스 음악 연주 ♪

♪

제프 나도: 안녕하세요, "AppKit의 새로운 기능"에 오신 것을 환영합니다.

난 제프 나도야.

저는 AppKit에서 일하고 있으며, 당신과 공유할 몇 가지 훌륭한 업데이트가 있습니다.

macOS Monterey에는 Mac 앱을 위한 몇 가지 훌륭한 새로운 기능과 개선 사항이 포함되어 있습니다.

이 릴리스에는 사용자 인터페이스 디자인 업데이트, 많은 컨트롤의 개선, SF 심볼에 대한 큰 업데이트, TextKit 2라는 완전히 새로운 텍스트 엔진, 강력한 새로운 Swift 언어 기능, 현재 Mac에서 사용할 수 있는 단축키를 통한 자동화를 포함하여 모든 사람을 위한 무언가가 있습니다.

macOS 사용자 인터페이스의 디자인에 대한 몇 가지 업데이트부터 바로 시작해 봅시다.

우리는 macOS Big Sur에서 데뷔한 시스템 차원의 재설계에 대한 반응에 매우 기쁩니다.

우리가 가장 좋아하는 많은 앱들이 단 몇 달 만에 새로운 디자인을 채택하도록 업데이트되었습니다.

macOS Monterey에서, 우리는 이 새로운 디자인을 계속 반복하고 다듬었으므로, 시스템 전반에 걸쳐 몇 가지 새로운 터치를 발견할 수 있습니다.

그들 중 일부는 이제 새로운 애니메이션으로 나타나고 물러나거나 클릭할 때 위치로 부드럽게 미끄러지는 슬라이더와 같이 크고 눈에 띈다.

또한 도구 모음 컨트롤의 세련된 메트릭과 검색 버튼의 스프링 로딩 지원과 같은 훨씬 더 미묘한 변경 사항이 있으므로 텍스트와 토큰을 쉽게 드래그할 수 있습니다.

그리고 명확성을 향상시키기 위해 테이블 섹션 사이의 간격을 늘렸다.

우리는 가장 작은 세부 사항까지 새로운 디자인을 계속 반복하고 향상시켜 왔습니다.

그리고 그것은 당신이 자신의 디자인을 다듬는 데 사용할 수 있는 몇 가지 제어 향상으로 이어집니다.

첫 번째 큰 것은 조절 색조이다.

우리는 개별 버튼, 세분화된 컨트롤 및 슬라이더의 사용자 지정 색조를 활성화했습니다.

이러한 각 컨트롤은 다음 API 중 하나를 사용하여 사용자 지정 색조 색상을 허용합니다: bezelColor, selectedSegmentColor 및 trackFillColor.

우리는 터치 바에서 개별 컨트롤의 색조를 허용하기 위해 macOS Sierra에 이러한 API를 도입했습니다.

그리고 macOS Monterey에서 시작하여, 그들은 윈도우 내 제어에도 기능한다.

요약하자면, 대부분의 컨트롤은 시스템 환경 설정에서 구성할 수 있는 악센트 색상을 사용하여 그립니다.

이것은 사람들이 그들이 가장 좋아하는 색상과 일치하도록 Mac을 테마로 만들 수 있게 해준다.

멀티컬러 옵션을 사용하면 각 앱이 자체 사용자 지정 색상을 정의할 수 있습니다.

널리 퍼진 테마의 경우, 앱의 자산 카탈로그에서 사용자 지정 악센트 색상을 정의할 수 있습니다.

새로운 틴팅 API는 하나의 특정 컨트롤에 대한 색상을 재정의하는 방법을 제공합니다.

이것은 의미적으로 의미 있는 색상을 적용하고 싶은 컨트롤에 적합합니다.

예를 들어, 앱이 선주문과 일반 구매를 구별하기 위해 특정 주황색 음영을 사용하는 경우, 색조 버튼을 사용하여 디자인을 강화할 수 있습니다.

또 다른 예는 통화 시작 및 종료 버튼이 앱에서 가장 의미 있는 두 가지 작업을 수행하는 화상 회의 앱입니다.

녹색과 빨간색으로 색을 칠하는 것은 강조를 더하고 그들의 기능을 즉시 알아볼 수 있게 해준다.

한 가지 중요한 점은 색조 버튼이 흰색이나 회색인 일반 푸시 버튼과 달리 항상 모든 활성 상태에서 색조 색상을 보여준다는 것입니다.

이것은 당신의 색조 색상을 전면과 중앙에 놓습니다.

그러나, 다채로운 외관을 사용하는 기본 버튼과 혼동하지 않도록 디자인에 주의하세요.

마지막으로, 단순한 색상 이상을 사용하여 컨트롤의 목적을 전달하는 것이 중요합니다.

색상을 구별하기 어려운 사람들이 여전히 주어진 컨트롤의 목적을 쉽게 식별할 수 있도록 하고 싶으니, 명확한 라벨이나 아이콘을 제공해야 합니다.

또 다른 중요한 버튼 디자인 변경은 클릭 시 악센트 색상을 사용하여 푸시 버튼이 더 이상 강조되지 않는다는 것입니다.

이것은 분할된 제어 세그먼트, 슬라이더 손잡이 및 스테퍼와 같은 다른 클릭 가능한 요소와 일치합니다.

이것은 중요한 변화입니다. 왜냐하면 강조 표시된 동안 다채로운 모양을 가정하는 사용자 지정 드로잉을 하는 경우 - 예를 들어, 위에 흰색 콘텐츠를 그리기로 선택한 경우 - macOS Monterey에서 올바르게 보이지 않을 수 있기 때문입니다.

하이라이트 상태를 확인하는 대신, interiorBackgroundStyle 속성을 사용하여 그리기 결정을 내릴 수 있습니다.

이 속성은 버튼 베젤의 기본 스타일을 반영하므로, 무색 상태에 대해서는 항상 .normal을 반환하며, 착색된 버튼, 기본 버튼 및 "켬" 상태로 전환된 버튼과 같은 다채로운 강조 상태에 대해 .emphasized를 반환합니다.

마지막으로, 우리는 가변 높이 푸시 버튼 역할을 하기 위해 이전에 레귤러 스퀘어로 알려진 버튼의 유연한 푸시 스타일을 업데이트했습니다.

이제 일반 푸시 버튼과 동일한 구성을 모두 지원합니다. 즉, 기본 버튼 역할을 할 수 있으며 색조를 칠할 수 있습니다.

코너 반경과 콘텐츠 패딩은 이제 각 컨트롤 크기의 표준 푸시 버튼과 일치하므로 다른 컨트롤과 잘 어울리지만, 수직으로 크기를 조정할 수 있는 디자인은 줄 바꿈이 있는 더 큰 아이콘이나 텍스트를 수용할 수 있음을 의미합니다.

대부분의 푸시 버튼은 표준 고정 높이 스타일을 계속 사용해야 하지만, 이 새로 확장된 스타일은 더 큰 콘텐츠를 수용해야 할 때 특별한 경우에 약간의 유연성을 제공합니다.

또 다른 매우 중요한 제어 업데이트는 메뉴 키보드 단축키를 위한 자동 현지화의 형태로 제공됩니다.

세상에는 많은 키보드 레이아웃이 있으며, 이는 키보드 단축키를 현지화하는 것을 상당히 복잡하게 만들 수 있다.

일부 키 조합은 일부 키보드에서 접근하기 어렵고, 다른 키보드는 전혀 입력할 수 없습니다.

게다가, 일부 방향 키보드 단축키는 오른쪽에서 왼쪽 언어로 미러링되어야 한다.

좋은 소식은, macOS Monterey에서 AppKit이 당신을 위해 그것을 할 수 있다는 것입니다.

다음은 현지화의 이점을 얻을 수 있는 단축키의 예입니다: 커맨드 백슬래시.

이것은 미국 영어 키보드에서 잘 작동하지만, 백슬래시 키가 전혀 없는 일본어 키보드로 타이핑하는 것은 실제로 불가능하다.

macOS Monterey에서 시작하여, 시스템은 바로 가기를 자동으로 다시 매핑하여 입력하기에 자연스러운 동등한 바로 가기를 제공합니다.

또 다른 일반적인 경우는 방향적 의미를 가진 키보드 단축키이다.

예를 들어, 사파리는 명령 제곱 괄호를 사용하여 역사에서 앞뒤로 나아간다.

오른쪽에서 왼쪽 언어에서 왼쪽 대괄호를 사용하여 뒤로 가는 것은 그다지 직관적이지 않으므로, AppKit은 이제 오른쪽에서 왼쪽 언어로 실행할 때 자동으로 오른쪽 대괄호로 바뀝니다.

이 동작은 대괄호, 중괄호, 괄호 및 화살표 키에 적용됩니다.

어떤 경우에는, 이 미러링 동작을 비활성화하고 싶을 수도 있습니다.

예를 들어, 메뉴 항목에 절대 방향성이 있다면 - 예를 들어 왼쪽 정렬과 같이 - 오른쪽에서 왼쪽 언어로도 왼쪽 대괄호를 사용하고 싶을 것입니다.

우리는 이와 같은 경우에 대한 옵트아웃을 제공했습니다.

NSMenuItem의 새로운 속성을 사용하여 이 동작을 제어할 수 있습니다.

allowsAutomaticKey EquivalentMirroring을 사용하면 괄호와 같은 방향 키의 미러링 동작을 제어할 수 있으며, allowsAutomaticKey EquivalentLocalization은 키보드 매핑 및 미러링을 포함한 모든 현지화 기능을 제어합니다.

이미 키보드 단축키를 신중하게 현지화했거나, 애플리케이션에 키보드 단축키 바인딩의 사용자 지정 구현이 많이 있는 경우, 전체 앱에 대해 이 기능을 비활성화할 수 있습니다.

이를 위해, 이 애플리케이션 위임 메서드를 구현하고, applicationShouldAutomatically LocalizeKeyEquivalents를 구현하고 false를 반환할 수 있습니다.

대부분의 앱은 이것을 사용할 필요가 없을 것이다.

개별 메뉴 항목 API는 특정 항목을 옵트아웃하는 데 강력히 선호되며, 대부분의 앱은 전혀 옵트아웃할 필요가 없습니다.

다음으로, 상징 이미지에 대한 몇 가지 큰 개선 사항.

우리는 빅서의 macOS에 SF 심볼을 가져와 모든 Mac 앱에 아름답고 타이포그래피적으로 균형 잡힌 심볼 이미지의 방대한 레퍼토리를 열었습니다.

macOS Monterey에서, 우리는 SF Symbols 3이라고 부르는 새로운 세대의 심볼 API와 도구를 구축했습니다.

심볼 이미지 워크플로우의 모든 측면을 아우르는 거대한 업데이트이며, AppKit 애플리케이션에서 모두 사용할 수 있습니다.

SF 심볼 3은 심볼 이미지를 미리 보고, 내보내고, 가져오기 위한 SF 심볼 앱의 기능을 확장합니다.

또한 기호 이미지 내에서 뚜렷한 레이어를 정의할 수 있는 사용자 지정 기호에 주석을 달기 위한 업데이트된 형식이 제공되며, AppKit, UIKit 및 SwiftUI에서 API를 확장하여 기호의 각 레이어를 개별적으로 색칠할 수 있습니다.

빅서에서, 우리는 기호에 대한 두 가지 뚜렷한 렌더링 모드를 제공했다.

첫째, 전체 기호에 단일 색조 색상이나 효과를 사용하여 그리는 전통적인 템플릿 스타일이 있었다.

두 번째는 멀티컬러로, 풀 컬러 이미지처럼 더 많이 그리며, 심볼 이미지 자체에 정의된 색상을 사용하여 각 경로 요소를 그립니다.

SF 심볼 3에서, 우리는 새로운 심볼 이미지 형식에서 제공하는 레이어 정보를 활용하는 두 가지 새로운 렌더링 모드를 추가했습니다.

첫 번째, 계층적, 단일 색상을 사용하여 그리며, 다른 부분을 강조하지면서 상징의 특정 부분을 강조한다.

그리고 두 번째, 팔레트를 사용하면 기호의 각 레이어에 원하는 색상을 할당할 수 있습니다.

NSImage.SymbolConfiguration에서 새로운 API를 사용하여 이러한 렌더링 모드에 액세스할 수 있습니다.

렌더링된 기호와 어떻게 일치하는지 보여주기 위해 NSColor 매개 변수를 점으로 표현하고 있습니다.

계층적 렌더링 모드는 불투명도가 감소하는 기호 레이어에 적용되는 단일 색상을 사용합니다.

팔레트 모드는 레이어에 그대로 적용되는 색상 배열을 허용합니다.

멀티컬러 렌더링 모드를 선호하는 구성을 만들 수도 있습니다.

우리는 또한 하나의 기본 기호에서 변형 중 하나로 매핑할 수 있는 새로운 API를 추가했습니다.

예를 들어, 심장 기호를 채워진 변형이나 원과 같은 새겨진 변형 또는 슬래시가 있는 변형에 매핑할 수 있습니다.

이것은 특정 상황에 대한 특정 스타일의 기호를 선호하는 상황에 정말 유용합니다.

예를 들어, 선택되지 않은 상태에 대한 개요를 선호하는 피커 컨트롤이 있을 수 있지만, 선택에 대한 채워진 스타일이 있을 수 있습니다.

일반적으로, 이 컨트롤은 이미지의 선택된 버전과 선택되지 않은 버전을 지정하기 위해 두 개의 다른 이미지 속성이 필요합니다.

하지만 변형 API를 사용하면 단일 기본 기호를 받아들이고 채워진 상태를 자동으로 도출할 수 있습니다.

이 컨트롤은 이미지(with: .fill)를 호출하여 선택 상태에서 채워진 기호를 선호할 수 있으며, 채워진 변형을 사용할 수 있을 때마다 자동으로 올바른 버전의 기호를 선택합니다.

각 유형의 기호 변형에 대한 상수가 있으며, 그것들을 결합하여 원과 채우기와 같은 여러 변형을 함께 요청할 수 있습니다.

이것은 SF Symbols 3의 특징에 대한 간략한 소개일 뿐입니다.

전체 기호 워크플로우에서 새로운 모든 것에 대한 전체 세부 사항을 얻을 수 있는 새로운 비디오 컬렉션이 있습니다.

그것들을 당신의 감시 목록에 꼭 추가하세요.

macOS Monterey는 또한 TextKit 2의 형태로 텍스트 시스템에 대한 엄청난 업데이트를 제공합니다.

TextKit은 모든 Apple 장치를 위한 텍스트 레이아웃 및 렌더링 엔진이며, 입증된 실적을 가진 훌륭한 텍스트 엔진입니다.

TextKit은 선형 텍스트 레이아웃 엔진으로, 처음부터 끝까지 텍스트 블록을 타이핑한다는 것을 의미합니다.

플랫폼과 기술을 발전시키면서, 우리는 비선형 텍스트 레이아웃이 우리에게 훨씬 더 도움이 될 많은 경우를 발견했습니다.

그래서 우리는 기본으로 돌아가서 TextKit의 새 버전을 만들었고 그것은 TextKit 2입니다.

우리는 TextKit 2에 대한 몇 가지 주요 목표를 가지고 있었다.

언제나처럼, 우리는 모든 스크립트와 레이아웃의 국제 텍스트에 대한 최고의 경험을 제공하고 싶습니다.

우리는 또한 텍스트를 다른 유형의 콘텐츠와 더 쉽게 혼합할 수 있도록 하고 싶습니다.

그리고 마지막으로, TextKit 2는 짧은 라벨이든 방대한 문서를 통해 부분적으로 스크롤된 텍스트를 매우 빠르고 효율적으로 형성하고 렌더링하도록 설계되었습니다.

TextKit 2는 TextKit 1과 공존하므로 주어진 텍스트 보기에 사용할 엔진을 선택할 수 있습니다.

이제 나는 너에게 비밀을 알려줄 거야.

Big Sur에서 시작하여 TextEdit는 일반 텍스트 문서에 사용하고 AppKit 텍스트 필드는 대부분의 구성에 TextKit 2를 사용하기 때문에 이미 Mac에서 TextKit 2를 실행하고 있습니다.

그래서 너는 사실 이 시간 내내 살짝 엿보고 있었어.

TextKit 2의 주요 차이점 중 하나는 항상 비선형 레이아웃 시스템을 사용한다는 것이다.

그것은 불필요한 작업을 피할 수 있도록 더 세분화된 수준에서 텍스트 레이아웃을 수행할 수 있다는 것을 의미합니다.

예를 들어, 텍스트의 일부만 스크롤되어 볼 수 있는 큰 문서가 있다면, 선형 시스템은 여전히 이 영역을 보여주기 위해 이전 텍스트를 모두 배치해야 합니다.

이에 비해, TextKit 2와 같은 비선형 시스템은 가장 가까운 단락 경계에서 레이아웃을 시작할 수 있다.

큰 문서의 경우, 이것은 엄청난 속도이다.

새로운 레이아웃 엔진은 강력한 사용자 지정 포인트 세트를 제공하여 레이아웃 시스템을 확장하고 자신의 동작을 쉽게 추가할 수 있습니다.

비선형 레이아웃 시스템은 또한 비텍스트 요소를 텍스트 레이아웃에 혼합하는 데 적합합니다.

그리고 그것은 심지어 가장 큰 문서의 성능을 향상시키면서 이 모든 것을 한다.

자세한 내용은 새로운 API의 디자인과 사용 방법에 대해 자세히 설명하는 "Meet TextKit 2"를 확인하세요.

다음으로, 동시성으로 시작하는 Swift의 AppKit에 대한 몇 가지 업데이트를 공유하고 싶습니다.

스위프트 5.5는 동시성을 관리하기 위한 몇 가지 중요한 언어 수준의 기능을 소개합니다.

첫 번째, async/await는 코루틴처럼 작동하는 비동기 메서드 호출을 허용합니다.

두 번째, 액터 유형은 단일 실행 스레드에 대한 액세스를 격리하여 데이터 경쟁으로부터 가변 상태를 보호합니다.

AppKit은 이 두 가지 새로운 기능과 잘 작동합니다.

비동기/대기의 경우, AppKit의 많은 비동기 메서드, 즉 완료 핸들러 블록으로 계속하는 메서드는 비동기 변형을 제공하기 위해 SDK에서 변환되었습니다.

한 가지 간단한 예는 사용자가 화면의 어느 곳에서나 색상을 선택할 수 있는 NSColorSampler입니다.

이 호출은 사용자가 원하는 색상을 선택할 때까지 기다린 다음 완료되면 완료 핸들러를 실행하기 때문에 비동기입니다.

Async/await를 사용하면 이것을 비동기 함수 호출로 표현할 수 있습니다.

비동기 작업이 완료되기를 기다리는 동안 실행 스레드를 산출한 다음, 중단한 곳에서 바로 다시 선택합니다.

당신은 심지어 경비 성명서 내에서 그것을 할 수도 있습니다.

이제, 계속 - 다음에 해야 할 작업 -은 더 이상 완료 핸들러 블록 안에 중첩되지 않습니다.

대신, 코드는 자연스럽게 순서대로 읽힌다.

배우들은 단일 실행 스레드로 격리하여 동시 액세스로부터 상태를 보호하기 위해 노력합니다.

그것이 친숙하게 들린다면, 뷰 계층 구조와 응답자 체인과 같은 대부분의 AppKit의 상태도 단일 실행 스레드, 특히 메인 스레드에서 액세스해야 하기 때문입니다.

이 제한은 배우 모델에 잘 맞기 때문에, 우리는 메인 스레드에서 액세스해야 하는 유형인 MainActor의 개념을 도입했습니다.

AppKit에서 우리는 NSView, ViewController, WindowController 및 Application의 하위 클래스와 NSCell, Alert, Document 및 DocumentController를 포함한 NSResponder를 MainActors로 지정했습니다.

MainActor에서 실행되는 코드는 이미 메인 스레드에 있다는 것을 알고 있기 때문에 다른 MainActor 유형의 메소드를 자유롭게 호출할 수 있습니다.

그러나 MainActor에서 실행되지 않는 코드는 MainActor의 맥락에서 UI 작업을 수행하기 위해 새로운 비동기/대기 기능을 사용해야 합니다.

컴파일러 수준에서 이것을 시행함으로써, 스위프트는 동시성과 UI 코드를 혼합할 때 일반적인 버그 소스를 피하는 데 도움을 줄 수 있습니다.

스위프트 동시성 비디오는 이 강력한 새로운 언어 기능에 대해 깊이 있게 들어간다.

넌 그들을 놓치고 싶지 않아.

또한 Swift 5.5의 새로운 기능은 AttributedString의 값 입력 버전입니다.

가치 의미론을 제공하는 것 외에도, 그것은 또한 유형에 안전한 속성과 속성의 범위를 열거하고 조작하기 위한 훌륭한 스위프트 인체 공학을 가지고 있다.

AppKit과 함께 AttributedString을 사용하면 전경색, 단락 스타일 등 텍스트 드로잉 시스템과 관련된 속성에 자동으로 액세스할 수 있습니다.

구조체 AttributedString과 참조 형식의 NSAttributedString 간에 변환할 수 있으므로 NSAttributedString을 사용하는 API와 상호 운용할 수 있습니다.

"What's new in Foundation" 비디오는 AttributedString의 디자인과 사용 방법에 대해 더 자세히 설명합니다.

우리의 마지막 Swift 향상은 NSViews에 대한 업데이트를 유도하는 것과 관련이 있습니다.

스위프트의 속성 래퍼 기능을 사용하여 뷰 속성에서 흔히 볼 수 있는 상용구를 극적으로 줄입니다.

예를 들어 봅시다.

여기 소수의 속성을 통해 구성할 수 있는 사용자 지정 보기가 있습니다.

그리고 이것은 괜찮아 보이지만, 현실은 우리의 견해의 재산 선언이 많은 didSets와 추가 부작용을 포함할 가능성이 훨씬 더 높다는 것입니다. 왜냐하면 너무 흔해서 무언가를 변경할 때 다시 그리거나 레이아웃을 업데이트해야 하기 때문입니다.

이제, 그건 많은 상용구야.

그래서 우리는 이 경우를 위해 새로운 스위프트 속성 래퍼를 만들어 이 시나리오를 더 좋게 만들었습니다.

그것은 무효화라고 불린다.

NSView 아래에 중첩되어 있으며, 래핑된 속성이 변경될 때 무효화할 뷰의 하나 이상의 측면을 지정할 수 있습니다.

모든 didSets와 괄호가 떨어져서 부동산 자체의 정의에 더 쉽게 집중할 수 있다.

AppKit은 디스플레이, 레이아웃, 제약, 본질적인 콘텐츠 크기 및 복원 가능한 상태와 같은 몇 가지 내장 무효화 사례를 제공합니다.

이러한 무효화는 뷰에서만 의미가 있기 때문에, 우리는 NSView의 하위 클래스에서만 작동하도록 속성 래퍼를 제한했습니다.

우리는 또한 그 값이 Equatable을 준수할 것을 요구한다.

우리는 잠재적으로 비싼 다시 그리기 또는 레이아웃 패스를 수행하기 전에 가치의 의미 있는 변화를 확인하기 위해 이 적합성을 사용합니다.

사용자 지정을 하고 싶다면, NSViewInvalidating 프로토콜에 유형을 적용하여 자신의 무효화를 정의할 수도 있습니다.

마지막으로, 지름길.

macOS Monterey에서, 우리는 Mac에 단축키의 모든 기능을 제공하게 되어 기쁩니다. 여기에는 단축키를 AppKit 앱과 통합하는 것이 포함됩니다.

좋은 소식은 앱이 서비스를 지원한다면, 이미 단축키를 지원하며, 단축키는 오늘 서비스에 액세스할 수 있는 모든 장소에 나타난다는 것입니다.

이 기능을 처음 접한다면, 채택하기가 정말 쉽습니다.

AppKit은 응답자 체인을 확인하여 상황에 맞는 단축키를 결정합니다.

각 응답자에게 각 단축키에서 예상되는 데이터 유형을 제공하거나 받을 수 있는지 묻습니다.

우리는 대부분의 경우 균일한 유형 식별자에 해당하는 페이스트보드 유형을 사용하여 이것을 표현합니다.

sendType 및 returnType 메소드에 대한 validRequestor를 구현하기만 하면 됩니다.

그리고 지정된 유형을 수락하거나 제공할 수 있다면, NSServicesMenuRequestor 프로토콜을 준수하는 객체를 반환하십시오.

대부분의 경우, 당신은 그 프로토콜을 직접 구현한 다음 스스로 반환할 것입니다.

단축키가 호출되면, 단축키가 입력 및 출력에 사용하는 특수 페이스트보드에서 데이터를 쓰기 및/또는 읽기 위한 호출을 받게 됩니다.

그리고 그게 다야!

앱을 단축키와 통합하는 것은 매우 쉽습니다.

우리는 또한 Siri Intents를 macOS에 도입했습니다.

이제 Xcode에서 인텐트 확장을 만들어 인텐트를 처리할 수 있습니다.

또는, 메인 애플리케이션에서 처리해야 하는 경우, 애플리케이션 대리인으로부터 인텐트 핸들러를 반환할 수 있습니다.

앱 위임에서, 애플리케이션 handlerFor 인텐트: 메소드를 구현하여 처리할 수 있는 모든 인텐트에 대한 핸들러 객체를 반환합니다.

모든 유형의 인텐트에는 반환된 객체가 준수해야 하는 자체 핸들러 프로토콜이 있으므로, 핸들러 객체 구현에 대한 자세한 내용은 인텐트 프레임워크 문서를 확인하십시오.

이제 이 모든 새로운 정보를 갖추었으니, 다음은 무엇입니까?

먼저, 제어 색조 및 SF 심볼 3과 같은 기능이 앱의 디자인을 향상시키는 데 어떻게 도움이 될 수 있는지 생각해 보세요.

다음으로, 앱이 TextKit을 사용하여 사용자 지정 텍스트 경험을 만드는 경우, "Meet TextKit 2" 비디오를 보고 새로운 API를 사용해 보세요.

TextKit 2로 사용자 지정 레이아웃과 풍부한 콘텐츠를 표현하는 것이 얼마나 쉬운지 좋아할 것입니다.

앱이 동시성을 관리하는 방식은 아키텍처의 핵심 부분이며, 스위프트의 새로운 동시성 기능은 이 분야에서 크게 개선될 것입니다.

이제 async/await와 같은 기능이 앱이 동시 워크로드를 관리하는 방식을 어떻게 형성할지 계획을 시작할 때입니다.

마지막으로, AppKit의 자동화 기능을 채택하여 단축키를 위한 앱을 준비하세요.

당신의 시간과 관심에 감사드립니다.

우리는 당신이 macOS Monterey에서 이러한 모든 훌륭한 개선 사항을 즐기기를 바랍니다.

♪