10252

♪ ♪

안녕하세요, 저는 UIKit 팀의 엔지니어인 Aditya Krishnadevan입니다.

많은 앱의 핵심에는 목록이나 컬렉션 보기가 있다.

매우 부드러운 스크롤을 갖는 것은 그 앱들을 기분 좋게 만드는 데 큰 부분을 한다.

이 비디오는 쏜살같이 빠른 목록과 컬렉션 뷰를 만들 때 성공할 수 있도록 준비할 것입니다.

우리는 컬렉션 뷰를 사용하여 훌륭한 여행지의 이미지 게시물 목록을 표시하는 이 앱을 만들 것입니다.

목적지의 사진과 몇 개의 텍스트 라벨이 있는 언뜻 보기에는 꽤 간단하다.

이 비디오를 통해, 우리는 그것이 어떻게 설정되고 사람들이 기대하는 성과를 어떻게 달성하는지에 대해 이야기할 것입니다.

먼저, 우리는 디파블 데이터 소스 및 셀 등록과 같은 API를 사용할 때 강력한 기초에서 시작하는 방법을 배울 것입니다.

우리는 컬렉션 뷰 셀의 수명 주기에 대한 이해를 새롭게 할 것이다.

그런 다음 완벽하게 부드러운 스크롤을 볼 수 없는 이유와 도움이 될 수 있는 프리페칭의 몇 가지 발전에 대해 이야기할 것입니다.

마지막으로, 패트릭은 콘텐츠가 비동기적으로 들어올 때 셀을 올바르게 업데이트하는 방법과 새로운 UIImage API를 사용하여 모든 장치에서 최고의 스크롤 성능을 얻는 방법을 설명할 것이다.

알았어.

앱이 데이터를 어떻게 구성하는지에 대해 이야기하는 것으로 시작합시다.

샘플 앱은 표시할 게시물 목록을 검색하며, 각 게시물은 이 DestinationPost 구조체로 표시됩니다.

DestinationPost는 식별 가능한 것을 준수하며, 이는 식별자를 저장하는 이 ID 속성을 가지고 있음을 의미합니다.

이것은 다른 속성이 변경되더라도 안정적으로 유지되는 각 DestinationPost의 고유 식별자입니다.

확산 가능한 데이터 소스는 모델 객체 자체가 아닌 모델에 항목의 식별자를 저장하도록 만들어졌습니다.

따라서 샘플 앱에서 Diffable 데이터 소스는 DestinationPost 자체가 아닌 ID 속성을 사용하여 채워집니다.

여기 앱에서 사용되는 다양한 데이터 소스가 있습니다.

방금 논의한 것처럼, 항목 식별자에 DestinationPost.ID 유형을 사용합니다.

앱에는 하나의 섹션만 있기 때문에, 여기의 섹션 유형은 하나의 케이스가 있는 열거형입니다.

데이터 소스를 채우기 위해, 앱은 먼저 빈 스냅샷을 만들고 메인 섹션을 추가합니다.

그런 다음, 백업 저장소에서 모든 게시물을 가져오고 식별자를 추가합니다.

이렇게 하면, DestinationPost의 다른 속성 중 하나가 변경되면, 식별자가 변경되지 않기 때문에 확산 가능한 데이터 소스의 표현은 안정적으로 유지됩니다.

마지막 단계는 스냅샷을 데이터 소스에 적용하는 것이다.

iOS 15 이전에는 애니메이션 없이 스냅샷을 적용하면 내부적으로 reloadData로 변환됩니다.

컬렉션 뷰가 화면의 모든 셀을 버리고 다시 만들어야 했기 때문에 성능에 좋지 않았다.

iOS 15부터 애니메이션 없이 스냅샷을 적용하면 차이점만 적용하고 추가 작업은 수행하지 않습니다.

iOS 15를 사용하면, 분할 가능한 데이터 소스는 또한 눈에 보이는 셀의 내용을 매우 쉽게 업데이트할 수 있는 새로운 재구성 항목 방법을 얻습니다.

우리는 나중에 이 비디오에서 그것이 어떻게 작동하는지 살펴볼 것이다.

먼저, 데이터 소스의 데이터를 셀과 화면으로 가져오자.

셀 등록은 각 유형의 셀에 대한 모든 구성을 한 곳에 보관할 수 있는 좋은 방법이며, 다양한 데이터 소스의 식별자에 편리하게 액세스할 수 있습니다.

UICollectionView는 각 등록 인스턴스에 대한 재사용 대기열을 유지하므로, 각 유형의 셀에 대해 한 번만 등록을 생성해야 합니다.

여기 앱의 셀에 대한 단순화된 등록이 있습니다.

전달된 postID는 DestinationPost와 이미지가 포함된 자산 객체를 검색하는 데 사용됩니다.

DestinationPost의 속성은 셀의 제목과 이미지를 설정하는 데 사용됩니다.

등록을 사용하려면, 데이터 소스의 셀 공급자 내부의 dequeueConfiguredReusableCell을 호출하세요.

등록이 셀 공급자 외부에서 어떻게 생성되고 내부에서 사용되는지 주목하세요.

공급자 내부에 등록을 만드는 것은 컬렉션 뷰가 어떤 셀도 재사용하지 않는다는 것을 의미하기 때문에 이것은 성능에 중요합니다.

이제 셀을 구성하는 방법을 이해했으므로, 셀이 구성될 때와 수명 주기가 어떤 것인지로 넘어갈 것입니다.

세포의 수명은 두 단계로 구성되어 있다: 준비와 전시.

준비를 위한 첫 번째 단계는 작업할 셀을 가져오는 것이다.

UICollectionView는 셀이 필요할 때마다 데이터 소스에서 셀을 요청합니다.

이것이 디피어블 데이터 소스인 경우, 셀 공급자를 실행하고 결과를 반환합니다.

셀 제공자가 실행되면, 컬렉션 보기는 등록을 사용하여 새 셀을 대기열에 추가하라는 메시지가 표시됩니다.

재사용 풀에 셀이 존재하는 경우, UICollectionView는 prepareForReuse를 호출한 다음 셀의 대기열을 해제합니다.

재사용 풀이 비어 있으면, 새 셀을 초기화할 것이다.

그런 다음 그 셀은 등록에서 구성 핸들러로 전달됩니다.

이것은 앱이 주어진 항목 식별자와 인덱스 경로를 표시하기 위해 셀을 설정하는 곳입니다.

구성된 셀은 다음 단계를 위해 컬렉션 보기로 돌아갑니다.

컬렉션 뷰는 선호하는 레이아웃 속성에 대해 셀을 쿼리하고 셀의 크기를 적절하게 조정합니다.

이 시점에서, 셀은 완전히 준비되었고 2단계를 위한 준비가 되어 있다: 디스플레이.

willDisplayCell은 대리자에서 호출되며, 셀은 UICollectionView 내부에 표시됩니다.

그 세포는 이제 화면에 있다.

그것이 보이는 동안 수명 주기에는 더 이상 변화가 없다.

화면에서 스크롤되면, didEndDisplaying은 셀에 대해 호출되며, 재사용 풀로 바로 다시 끝납니다.

재사용 풀에서, 셀은 다시 줄어낼 수 있으며, 이 과정을 반복할 수 있다.

이제 이 기본 사항으로 앱이 어떤 느낌인지 확인해 봅시다.

이 앱은 페루의 쿠스코와 카리브해의 세인트루시아를 특징으로 한다.

앱을 스크롤하고 다른 목적지를 보자, 하지만 어떻게 매끄럽게 스크롤되지 않는지 주목하자.

스크롤 중 이러한 중단은 "히치"라고 불린다.

차질의 원인을 이해하기 위해, 먼저 앱이 디스플레이를 업데이트하는 방법을 알아봅시다.

각 프레임마다 터치와 같은 이벤트가 앱으로 전달됩니다.

이에 대응하여, 그것은 뷰와 레이어의 속성을 업데이트한다.

예를 들어, 스크롤 보기의 contentOffset은 팬 제스처 중에 변경되며, 포함된 모든 보기의 화면 위치를 변경합니다.

이러한 변화의 결과로, 앱의 뷰와 레이어는 레이아웃을 수행합니다.

이 과정은 "커밋"이라고 불린다.

그런 다음, 레이어 트리가 렌더링 서버로 전송됩니다.

각 프레임에는 마감일이 있다.

지금은 그 프레임에 대한 모든 커밋이 완료되어야 하는 시간이다.

앱이 각 프레임에 대해 커밋해야 하는 시간은 디스플레이의 재생률에 따라 다릅니다.

예를 들어, 120Hz의 더 높은 재생률로 실행되는 iPad Pro에서 앱은 60Hz에서 실행되는 iPhone에 비해 각 프레임의 작업을 완료하는 시간이 적습니다.

다음은 컬렉션이나 테이블 뷰에서 셀 목록을 스크롤하는 전형적인 예입니다.

새 셀이 보이면, 새 셀이 구성되고 레이아웃을 수행하는 더 긴 커밋이 있습니다.

그런 다음, 화면에서 기존 셀이 움직이는 몇 개의 프레임이 있습니다.

새로운 셀이 필요하지 않기 때문에 이 프레임의 커밋은 빠르다.

결국, 스크롤 위치는 새로운 셀을 볼 수 있을 만큼 충분히 바뀌고, 이 패턴은 반복된다.

그래서 이전 데모에서와 같은 히치의 원인은 무엇인가요?

프레임에 대한 커밋이 너무 오래 걸리고 마감일을 놓치면, 이러한 업데이트는 의도된 프레임에 통합되지 않습니다.

디스플레이는 커밋이 끝날 때까지 화면에 이전 프레임을 유지하며, 이 지연된 프레임은 렌더링할 수 있습니다.

이것은 커밋 히치이며 스크롤할 때 순간적인 중단으로 인식된다.

이것과 다른 유형의 히치에 대해 자세히 알아보려면, "UI 애니메이션 히치 탐색" 비디오를 보세요.

이러한 문제를 피하기 위해, UICollectionView와 UITableView는 모두 iOS 15에서 새로운 셀 프리페칭 메커니즘을 갖추고 있습니다.

우리는 스크롤하는 동안 문제를 일으키는 값비싼 셀의 예로 돌아왔습니다.

이것의 핵심은 일반적으로 모든 프레임에 셀이 필요하지 않다는 것입니다.

우리는 최소한의 작업을 하는 매우 짧은 커밋을 가진 몇 개의 프레임을 가지고 있다.

iOS 15의 셀 프리페칭은 짧은 커밋을 마친 직후에 다음 셀을 준비함으로써 이 여가 시간을 활용합니다.

그런 다음, 세포가 결국 필요할 때, 그것은 단지 그것을 보이게 하는 문제일 뿐이다.

그렇기 때문에 모든 작업이 더 일찍 완료되었기 때문에 미리 가져온 셀이 보이는 프레임에 대한 커밋이 매우 빠릅니다.

셀을 미리 가져오는 데 소요된 시간은 문제를 일으킬 때와 같다.

하지만 우리가 선두를 시작할 수 있기 때문에, 우리는 차질을 피할 수 있다.

각 커밋을 통해 이것이 왜 작동하는지 이해합시다.

프리페칭이 일어나기 전에, 우리는 이 프레임에 대한 커밋을 수행했다.

세포가 필요하지 않았기 때문에, 그것은 빠른 커밋이었고, 마감일 전에 남은 많은 시간으로 끝났다.

iOS 15에서는 다음 프레임까지 기다리는 대신, 시스템은 상황을 인식하고 여가 시간을 사용하여 다음 셀을 미리 가져오기 시작합니다.

이제, 다음 프레임은 일이 흥미로워지는 곳이다.

미리 가져오는 셀은 비싸기 때문에, 실제로 그 프레임에 대한 커밋이 평소보다 늦게 시작되도록 한다.

그러나, 그 커밋은 늦게 시작하지만, 빠르기 때문에 마감일 훨씬 전에 끝난다.

이것을 프리페치 없이 이전에 본 삽화와 비교하세요.

더 이상 마감일을 놓친 커밋이 없다는 것을 주목하세요, 그래서, 셀 프리페칭에 더 이상 문제가 없습니다.

이것은 당신의 앱이 어떤 문제도 일으키지 않고 각 셀을 준비하는 데 최대 두 배의 시간을 얻는다는 것을 의미합니다.

게다가, 이 훌륭한 새로운 기능을 얻기 위해 해야 할 일은 iOS 15 SDK로 앱을 구축하는 것입니다.

내가 마지막으로 데모를 실행했을 때, 그 앱은 iOS 14 SDK로 만들어졌다.

iOS 15 SDK로 빌드할 때 앱에서 스크롤하는 것을 확인해 봅시다.

이거 멋지다!

프리페칭은 우리가 원하는 것을 정확히 하고 있는 것 같다.

스크롤은 이제 완벽하게 매끄럽고, 우리는 한 줄의 코드를 변경할 필요가 없었다.

기억하세요, iOS 15 SDK를 사용하여 앱을 빌드하기만 하면 됩니다.

UICollectionView의 경우, 이 새로운 프리페칭은 iOS 10에 도입된 것을 확장합니다.

셀 프리페칭은 이제 목록과 다른 모든 구성 레이아웃에 대해 지원됩니다.

이 훌륭한 새로운 프리페칭은 이제 UITableView에서도 활성화됩니다.

프리페칭은 히치를 제거하여 스크롤 성능을 향상시킬 수 있지만, 전력 사용량을 줄이고 배터리 수명을 늘릴 수도 있습니다.

세포가 빨리 준비된다면, 시스템은 더 에너지 효율적인 상태에서 실행하기 위해 추가 시간을 사용할 수 있으며 여전히 히치를 피할 수 있습니다.

따라서, 어떤 히치도 눈치채지 못하더라도, 셀 구성과 레이아웃 구현을 가능한 한 효율적으로 만드는 것은 여전히 매우 중요합니다.

이제 프리페칭이 세포 수명 주기에 어떤 영향을 미치는지에 대해 이야기해 봅시다.

이것은 우리가 이전에 이야기한 수명주기이며, 프리페치 없이, 두 개의 뚜렷한 단계와 함께.

셀이 프리페치될 때, 화면에 필요한 셀보다 먼저 실행되는 준비 단계이다.

프리페칭을 최대한 활용하려면, 이 단계에서 셀을 완전히 구성해야 합니다.

무거운 작업을 수행하기 위해 세포가 보일 때까지 기다리지 마세요.

셀이 컬렉션 보기로 돌아오면, 프리페치의 일부로 선호하는 레이아웃 속성을 얻을 수 있는 크기가 조정됩니다.

미리 가져온 후, 이제 셀이 표시되기를 기다리고 있는 이 중간 상태가 있다.

이 새로운 단계를 감안할 때, 앱에 대한 두 가지 중요한 고려 사항이 있다.

준비된 셀은 절대 표시되지 않을 수 있으며, 이는 사용자가 갑자기 스크롤 방향을 변경하면 발생할 수 있습니다.

그런 다음, 일단 셀이 표시되면, 화면이 꺼진 후 대기 상태로 바로 돌아갈 수 있습니다.

같은 셀은 같은 인덱스 경로에 대해 두 번 이상 표시될 수 있다.

더 이상 셀이 표시가 끝날 때 재사용 풀에 즉시 추가되는 경우가 아닙니다.

프리페칭은 우리가 부드러운 스크롤을 달성하는 데 도움이 되지만, 우리에게 더 많은 시간을 주기 때문이다.

프레임 속도가 더 높은 다른 장치에서는 스크롤하는 동안 앱이 여전히 히치가 발생할 수 있습니다.

패트릭은 이제 앱이 셀을 구성하는 방법에 대해 더 자세히 설명하고, 이미지를 표시할 때 커밋당 시간을 줄이는 전략에 대해 이야기할 것입니다.

고마워, 아디.

안녕하세요, 저는 High-Level Performance 팀의 Patrick입니다.

이제 샘플 앱에서 기존 셀을 업데이트한 다음 iOS 15의 새로운 API를 활용하여 최상의 성능으로 이미지를 표시하는 방법을 안내하겠습니다.

샘플 앱은 디스크의 로컬 이미지 파일로 만들어졌다.

앱을 스크롤할 때, 셀은 화면에서 준비되며, 그 안의 이미지는 파일 시스템에서 즉시 로드됩니다.

이제, 우리는 원격 서버에 저장된 이미지를 표시하고 싶다.

그래서, 셀이 스크롤할 때, 우리는 이미지 보기에 표시할 이미지가 없을 수도 있습니다.

이미지 보기가 처음 표시되면, 비어 있고 서버 요청이 완료된 후에만 채워집니다.

이 새로운 접근 방식을 지원하기 위해 등록의 구성 핸들러를 확장하는 것을 살펴봅시다.

여기 등록의 구성 핸들러에서, 우리는 이미 자산 저장소에서 자산을 가져왔습니다.

가게는 항상 이미지를 반환할 것이지만, 완전한 자산이 아닐 수도 있다.

다운로드해야 할 수도 있습니다.

자산 객체는 이것을 isPlaceholder 속성으로 나타낸다.

이것이 사실이라면, 우리는 자산 저장소에 전체 이미지를 다운로드하도록 요청할 것이다.

로드 작업이 완료되면, 셀의 이미지 보기를 업데이트할 시간입니다.

여기서, 우리는 기존 셀 객체를 가지고 이미지 보기에 자산을 설정합니다.

이건 실수야.

셀은 다른 목적지로 재사용되며, 자산 저장소가 최종 자산을 로드할 때까지, 우리가 캡처한 셀 객체는 다른 게시물에 대해 구성될 수 있습니다.

셀을 직접 업데이트하는 대신, 우리는 수집 뷰의 데이터 소스에 필요한 업데이트를 알려야 합니다.

iOS 15는 재구성 항목 스냅샷 방법을 소개합니다.

준비된 셀에서 재구성 항목을 호출하면 등록의 구성 핸들러가 다시 실행됩니다.

새 셀을 큐링하고 구성하는 대신 항목의 기존 셀을 재사용하기 때문에 reloadItems 대신 이것을 사용하세요.

샘플 앱에서, 우리는 전달된 ID에 대해 reconfigureItems를 호출하는 setPostNeedsUpdate 메소드를 선언할 것입니다.

이제, 등록의 구성 핸들러로 돌아가서, 이미지가 자리 표시자일 때, 우리는 풀사이즈 자산을 다운로드하고 새로운 방법을 호출할 것입니다.

재구성 항목은 이 핸들러를 다시 호출하지만, 이제 fetchByID는 자리 표시자가 아닌 전체 자산을 반환합니다.

이를 통해 모든 보기 업데이트 코드를 한 곳에 보관하고 데이터가 있으면 비동기적으로 셀을 업데이트할 수 있습니다.

준비 시간을 극대화하기 위해, 우리는 또한 prefetchingDataSource 내에서 downloadAsset 방법을 사용할 수 있습니다.

데이터 소스 프리페칭은 컬렉션 보기 항목에 대한 네트워크 다운로드를 시작하기에 좋은 장소입니다.

셀이 표시되기 전에 자산을 다운로드하고 준비할 수 있는 더 많은 시간을 제공하여 사용자가 자리 표시자 콘텐츠를 보는 시간을 줄입니다.

이것이 우리 앱에서 어떻게 보이는지 살펴봅시다.

괜찮아 보이지만, 스크롤하는 동안 눈에 띄는 히치가 있다.

그들은 또한 새로운 이미지가 표시될 때와 일치하는 것으로 보인다.

새 세포가 준비되면, 히칭이 없다.

그것은 이미지가 우리가 히치하는 전체 해상도 이미지로 업데이트될 때만이다.

그것은 모든 이미지가 디스플레이를 위해 디코딩하는 데 시간이 걸리고, 더 큰 비자리 보유자 자산과 같은 일부 이미지는 너무 커서 디스플레이 시간에 디코딩할 수 없기 때문입니다.

셀 등록의 구성 핸들러가 처음 호출되고 자산이 자리 표시자일 때, 코드는 전체 크기 이미지에 대한 비동기 요청을 시작하고 구성을 완료합니다.

자산이 나중에 마침내 다운로드되면, 셀 구성 핸들러는 최종 이미지와 함께 다시 실행됩니다.

이미지 뷰가 새 이미지를 커밋하려고 할 때, 먼저 메인 스레드에 표시할 이미지를 준비해야 합니다.

이것은 오랜 시간이 걸릴 수 있으며, 앱이 커밋 마감일을 놓쳤을 때 문제가 있습니다.

이미지 준비는 모든 이미지가 표시되기 위해 거쳐야 하는 필수 과정이다.

렌더링 서버는 비트맵인 이미지만 표시할 수 있으며, 이는 원시 픽셀 데이터임을 의미합니다.

이미지는 PNG, HEIC 및 JPEG와 같은 다양한 형식으로 제공되며, 압축되어 표시하려면 처리하고 압축을 풀어야 합니다.

이미지 뷰는 새 이미지를 커밋할 때 이 처리를 수행하며, 메인 스레드에서 발생합니다.

이상적으로, 우리는 이미지를 미리 준비하고 마침내 완성되었을 때만 UI를 업데이트할 수 있습니다.

그렇게 하면, 우리는 절대 메인 스레드를 차단하지 않고 히치하지 않는다.

iOS 15는 이미지 준비 API를 도입하여 이미지 준비가 언제 어디서 일어나는지 제어할 수 있습니다.

이 API는 렌더러가 필요로 하는 픽셀 데이터만 포함하는 새로운 UIImage를 생성합니다.

이미지 보기로 설정되면 추가 작업이 필요하지 않습니다.

그것은 두 가지 형태로 제공됩니다: 모든 스레드에서 실행할 수 있는 동기식 것과 내부 UIKit 직렬 대기열에서 실행되는 비동기식.

그것을 사용하기 위해, 우리는 우리가 만든 UIImage를 가지고 이미지 보기에 자리 표시자 이미지를 설정합니다.

그런 다음, 새로운 API를 호출하면 더 큰 이미지의 배경에서 준비가 시작됩니다.

완료되면, 이미지 보기에서 설정할 수 있습니다.

준비된 이미지는 이미지가 많은 앱에서 큰 문제를 해결하지만, 몇 가지 고려 사항도 함께 제공됩니다.

준비된 이미지는 원본 이미지의 원시 픽셀 데이터를 포함합니다.

메모리에 보관되는 한 이미지 보기에 자유롭게 표시할 수 있습니다.

하지만 이것은 또한 많은 메모리를 차지하며, 드물게 캐시되어야 한다는 것을 의미합니다.

마지막으로, 그들의 형식 때문에, 그들은 디스크 저장에 이상적이지 않다.

대신, 원래 자산을 디스크에 저장하세요.

마지막 고려 사항은 이미지 준비가 프리페칭을 어떻게 활용할 수 있는지이다.

프리페칭은 이미지를 다운로드하고 준비할 수 있는 추가 시간을 준다.

프로세스에 더 많은 시간을 준다는 것은 사용자가 자리 표시자를 오랫동안 볼 수 없다는 것을 의미하며, 아마도 전혀 그렇지 않을 것이다.

샘플 앱에는 이미 이미지 검색을 위한 비동기 경로가 있습니다.

다운로드가 완료되면, 완료 핸들러를 호출하기 전에 자산을 준비할 수 있습니다.

이 자산들은 크지만, 또한 가치가 있기 때문에, 일단 이미지가 준비되면, 우리는 그것을 캐시하고 싶다.

우리의 이미지 캐시는 준비된 이미지의 메모리 사용을 추정하기 위해 이미지의 크기를 사용합니다.

이제, 셀이 자산을 요청할 때, 우리는 서버에서 가져오기 전에 캐시를 확인합니다.

만약 우리가 더 작은 이미지를 가지고 있었다면, 우리는 더 많은 것을 캐시할 수 있었을 것이다.

이미지는 클 수 있으며, iOS 15는 이미지의 썸네일을 준비하기 위한 유사한 API를 도입한다.

이것들은 더 작은 크기로 이미지를 확장하고 준비할 수 있다.

대상 크기를 염두에 두고 이미지를 읽고 처리하여 많은 CPU 시간과 메모리를 절약할 수 있습니다.

당신은 그것을 이미지 준비 API처럼 사용합니다.

먼저, UIImage를 찍고 이미지 보기에 자리 표시자 이미지를 설정하세요.

그런 다음, 뷰의 크기를 썸네일의 목표 크기로 사용하여 새로운 크기 조정 API를 호출하세요.

준비되면, 새 썸네일로 이미지 보기를 업데이트하세요.

이미지 준비 API와 함께, iOS 15가 설치된 모든 앱에서 이미지를 가속화하고 문제를 피하는 것이 훨씬 쉽습니다.

이미지로 작업할 때, 이미지가 준비되었을 때 UI를 업데이트할 수 있는 비동기 API를 갖는 데 집중하세요.

그 동안, 동시에 표시할 수 있을 만큼 작거나 저렴한 자리 표시자 이미지를 사용하세요.

프리페칭 및 재구성 항목과 함께 사용할 때, 컬렉션 및 목록 보기에서 비동기 콘텐츠를 보여주는 것이 그 어느 때보다 쉽고 성능이 뛰어난 적이 없습니다.

빠른 수집 및 테이블 보기를 시작하려면, 먼저 iOS 15 SDK로 앱을 빌드하여 많은 새로운 최적화를 잠금 해제하십시오.

특히, 새로운 프리페치로 컬렉션과 테이블 뷰의 동작을 검증해야 합니다.

여기에 시연된 모든 새로운 API는 이 강연의 샘플 코드에서 찾을 수 있습니다.

그것을 확인하고 앱 전체에서 이미지 준비 및 크기 조정 API를 채택해야 합니다.

이것은 당신의 컬렉션과 테이블 뷰가 빠르게 타오르는 것을 보장할 것입니다.

봐줘서 고마워.

[쾌활한 음악].