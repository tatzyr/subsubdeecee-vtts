10286

♪ 베이스 음악 연주 ♪

♪

알레한드로 세고비아 아자피안: WWDC에 오신 것을 환영합니다!

제 이름은 Ale Segovia Azapian이고, 저는 Apple의 GPU 소프트웨어 엔지니어입니다.

이 세션에서, 우리는 메탈에서 바인드리스 렌더링을 탐구할 것이다.

Bindless는 GPU가 현대적인 렌더링 기술을 구현하기 위해 리소스 그룹을 사용할 수 있도록 하는 현대적인 리소스 바인딩 모델입니다.

먼저, 우리는 bindless 뒤에 있는 개념의 필요성을 살펴볼 것이다.

그런 다음, 우리는 바인딩리스 모델을 소개하고 전통적인 바인딩 모델의 문제를 해결하는 데 필요한 유연성을 어떻게 제공하는지 보여줄 것입니다.

우리는 인수 버퍼를 사용하여 Metal에서 장면 리소스를 인코딩하고 사용할 수 있도록 하는 메커니즘과 셰이더에서 GPU 구조를 탐색하는 방법을 요약할 것입니다.

시작하자!

따라서 바인딩리스 렌더링을 통해 셰이더가 모든 장면 리소스를 사용할 수 있도록 하여 그래픽 기술에 놀라운 유연성을 제공합니다.

예를 들어 봅시다.

가속 구조에 대한 교차점을 찾는 레이 트레이싱 커널이 있다고 상상해 봅시다.

광선 추적 그림자와 같은 일부 조명 효과의 경우, 알고리즘은 매우 자연스럽다.

우리는 교차점과 빛 사이의 물체를 찾고 싶다.

그림자 광선을 추적하는 데 필요한 것은 빛으로 향하는 위치와 방향뿐이다.

광선과 교차로의 매개 변수에서 파생할 수 있는 교차로의 세계 공간 위치 외에는 물체 속성이나 금속 자원이 필요하지 않습니다.

그러나 반사와 같은 다른 효과의 경우, 상황은 더 복잡해진다.

금속 셰이딩 언어의 레이 트레이싱 반사 셰이더를 살펴봅시다.

이 새로운 예에서, 우리는 방금 교차로를 찾았고, 픽셀을 올바른 반사 색상으로 칠하려고 노력하고 있습니다.

우리가 교차로를 찾은 후에 단색을 칠한다면, 땅의 반사는 정확해 보이지 않을 것이다.

올바른 결과를 얻으려면, 발견된 각 반사점의 속성을 결정하고 픽셀에 대한 올바른 음영을 계산해야 합니다.

이 문제는 확산 글로벌 조명과 심지어 어떤 경우에는 주변 폐색과 같은 다른 광선 추적 효과에도 존재한다.

문제는 우리가 광선을 추적할 때, 우리의 광선이 가속 구조의 모든 물체에 부딪힐 수 있다는 것이다.

이것은 우리의 레이 트레이싱 셰이더에서 교차된 메쉬와 관련된 정점 데이터와 그 재료를 포함하여 우리 장면의 모든 금속 자원에 잠재적으로 접근해야 한다는 것을 의미합니다.

이 양의 자원을 우리의 파이프라인에 직접 묶는 것은 불가능하다.

이것이 바인딩리스 바인딩 모델이 들어오는 곳이다.

Bindless의 이면에 있는 아이디어는 우리의 자원을 모으고 그것들을 함께 연결하는 것이다.

이를 통해 단일 버퍼를 파이프라인에 바인딩하고 탐색을 통해 모든 참조 리소스를 사용할 수 있습니다.

금속에서, 우리가 이것을 할 수 있는 구조는 인수 버퍼이다.

특히, 바인딩리스의 경우, 인수 버퍼 Tier 2가 필요합니다.

이것들은 Apple6 및 Mac2 GPU 제품군에서 사용할 수 있습니다.

인수 버퍼는 금속의 모든 셰이더 유형에서 사용할 수 있습니다.

이것은 당신이 그것들을 레이 트레이싱과 래스터화에 모두 사용할 수 있다는 것을 의미합니다.

우리가 보았듯이, 특정 레이 트레이싱 효과의 경우, 좋은 시각적 결과를 얻기 위해 바인딩리스를 사용하는 것은 필수입니다.

래스터화를 위해, 사용은 선택 사항이지만 직접 바인딩 모델에 비해 이점을 제공한다.

특히, 그것은 주어진 무승부 호출에 바인딩될 수 있는 리소스 수에 대한 슬롯 제한을 사실상 제거하며, 또한 이 세션의 뒷부분에서 살펴볼 몇 가지 좋은 최적화 기회를 제공합니다.

우리는 Metal API에 대한 단일 호출로 일정한 데이터와 리소스를 한 번에 바인딩할 수 있는 메커니즘으로 Metal 2로 인수 버퍼를 도입했습니다.

인수 버퍼는 매우 유연하며 다른 버퍼를 참조할 수도 있다.

바인드리스 모델의 이면에 있는 아이디어는 이 기능을 활용하여 모든 장면 자원을 함께 연결하는 것이다.

이것은 그것들을 GPU에서 동시에 사용할 수 있게 할 것이다.

장면 리소스를 인수 버퍼와 연결하는 방법의 예를 살펴봅시다.

우리가 이 소방차와 같은 모델을 렌더링하고 싶다고 가정해 봅시다.

이 모델은 텍스처, 정점 데이터 및 인덱스 데이터로 구성되어 있다.

이것들은 전통적인 바인딩 모델의 모든 무승부에 대해 하나씩 바인딩할 수 있는 전형적인 자원입니다.

그러나 우리의 경우 - 모든 텍스처, 정점 데이터 및 장면의 인덱스를 한 번에 사용할 수 있기를 원하기 때문에 - 우리는 이것들을 집계해야 합니다.

여기 그렇게 할 수 있는 잠재적인 방법이 있습니다.

우리는 먼저 자산이 어떻게 구성되어 있는지에 따라 모든 메쉬 또는 서브메시를 포함하도록 메쉬 인수 버퍼를 만들 수 있습니다.

이 인수 버퍼는 우리 장면에서 정점과 인덱스 배열을 참조할 수 있게 해준다.

마찬가지로, 우리는 똑같이 할 수 있고 우리의 자료를 인수 버퍼로 인코딩할 수 있다.

각 재료는 질감을 참조할 수 있을 뿐만 아니라 인라인 상수 데이터를 포함할 수 있다.

좋아요, 하지만 이제 GPU에서 사용할 수 있는 모든 메쉬와 재료를 갖게 되었으니, 어떻게 그것들을 하나로 모을 수 있을까요?

음, 예를 들어, 인스턴스 객체를 만들고 인수 버퍼에 넣을 수도 있습니다.

인스턴스는 하나의 메쉬와 관련 자료를 참조할 수 있다.

이것은 또한 모델 변환 매트릭스를 인라인 상수 데이터로 저장하기에 좋은 장소이다.

하지만 우리는 거기서 멈출 필요가 없어.

이제 하나의 인스턴스를 저장할 수 있으므로, 우리는 이것을 더 나아가 모든 인스턴스를 이 인수 버퍼에 배열로 인코딩할 수 있습니다.

이 다이어그램을 단순화하고 각각 자체 재료가 있는 트럭 인스턴스를 몇 개 더 추가해 봅시다.

보시다시피, 이것으로, 우리는 이제 전체 장면과 리소스를 인코딩하고 인수 버퍼와 연결할 수 있습니다.

나중에, 셰이더에서 이러한 리소스를 참조하고 싶을 때, 인스턴스 버퍼에 대한 포인터만 있으면 됩니다.

우리는 그것을 직접 전달하고 이 버퍼를 배열로 해석하거나, 다른 장면 인수 버퍼를 통해 포인터를 전달할 수 있습니다.

이제, 간접적으로 접근한 자원의 거주에 어떤 일이 일어나는지 주목하는 것이 중요하다.

우리는 현장에 대한 포인터를 파이프라인으로만 전달하고 있기 때문에, 메탈은 이 버퍼 참조에 대해 알 수 있지만, 간접적으로 접근한 자원에 대해서는 알지 못할 것이다.

그 신청서는 간접적으로 접근한 모든 자원의 거주를 선언할 책임이 있다.

리소스를 상주하게 하는 것은 GPU에서 메모리를 사용할 수 있도록 드라이버에게 신호를 보내는 것을 의미합니다.

이것은 우리가 셰이더에서 그것들을 참조할 수 있도록 필요하다.

컴퓨팅 인코더를 위한 useResource:usage: API와 렌더링 명령 인코더를 위한 useResource:usage:stages: API를 호출하여 이를 수행할 수 있습니다.

비거주자 리소스에 액세스하는 것은 GPU 재시작과 명령 버퍼 실패의 일반적인 원인이다.

이 API를 호출하는 것을 잊어버리면 메모리 페이지가 존재하지 않을 수 있기 때문입니다.

따라서 간접적으로 접근한 모든 자원을 금속에 선언하는 것은 매우 중요하다.

이제, 편의를 위한 또 다른 옵션은 MTLHeaps에서 할당된 자원이 이제 useHeap API를 통해 단일 호출로 상주할 수 있다는 것입니다.

이미 힙에서 자원을 재할당하거나 재할당할 계획이라면 이것은 훌륭한 옵션입니다.

이제, 힙은 Metal API의 환상적인 부분이며, 최고의 리소스 생성 성능과 메모리 절약 기회를 위해 사용하는 것이 좋습니다.

그러나, 그것들을 효과적으로 사용하기 위한 몇 가지 고려 사항이 있다.

가장 먼저 물어봐야 할 것은, 우리의 모든 하위 할당된 자원만 읽나요?

리소스에 써야 할 곳의 예로는 컴퓨팅 셰이더의 메쉬 스키닝과 동적 텍스처 등이 있습니다.

이러한 경우, GPU가 리소스에 기록해야 하는 경우, 쓰기 사용 플래그와 함께 개별적으로 거주자로 선언되어야 합니다.

게다가, 우리가 지금 읽으려고 하는 수정되었을 수 있는 모든 자원은 여전히 그들 자신의 useResource 호출이 필요할 것이다.

이것은 메탈 프레임워크가 당신을 위해 자원 전환을 처리하고, GPU 캐시를 플러시하고, 내부 메모리 레이아웃을 조정할 수 있도록 하기 위한 것입니다.

두 번째 고려 사항은, 힙 트랙이 자원 의존성을 하위 할당합니까?

다시 말하지만, 이것은 우리가 같은 힙에서 오는 자원을 읽고 쓸 때 특히 중요하다.

금속은 종속성 추적을 통해 동기화 문제를 피하는 데 탁월하며, 금속 2.3 이후 힙은 자원에 대한 접근의 위험을 추적하도록 구성할 수 있다.

그러나, 힙은 금속에 대한 단일 자원이기 때문에, 동기화는 하위 할당 수준이 아닌 힙 수준에서 처리된다.

이것은 재할당된 자원을 잘못된 공유의 문제로 야기할 수 있다.

한 번 보자.

같은 힙에서 리소스에 액세스하는 두 개의 렌더링 패스가 있다고 상상해 봅시다.

렌더링 패스 A는 추적된 힙에서 할당된 렌더링 텍스처로 렌더링하고 있다.

렌더링 패스 B는 동일한 힙에서 하위 할당된 관련 없는 버퍼에서 읽고 있다.

다른 조건에 따라, 렌더링 패스 A와 B는 GPU에 의해 병렬로 실행될 수 있지만, 동일한 리소스에서 쓰기와 읽기의 잠재적 위험으로 인해 - 힙 - 금속은 경쟁 조건이 없도록 액세스를 직렬화해야 합니다.

이것은 잠재적으로 GPU에 의한 워크로드의 실행 벽시계 시간을 증가시킬 수 있다.

그러나 우리의 경우, 개별 자원이 독립적이라는 것을 안다면, 이 울타리는 피할 수 있다.

이것을 하는 방법은 두 가지가 있다.

한 가지 옵션은 정적 자원에 사용되는 것과 분리된 힙에서 업데이트 가능한 자원을 재할당하는 것이다.

우리가 모든 것을 함께 묶고 싶다면, 다른 옵션은 힙이 하위 할당된 자원을 추적하지 않도록 구성되었는지 확인하는 것이다.

이것은 Metal의 기본 행동이며, 프로그래머로서 우리가 위험을 동기화하는 책임을 진다는 것을 의미합니다.

이제, 이 다이어그램에서 나는 거짓 공유의 문제를 설명하기 위해 약간 단순화했다.

실제로, 겹치는 렌더링 패스 레벨이 아닌 셰이딩 스테이지 레벨에서 발생한다.

결과적으로, 금속은 우리가 무대 입도에서 울타리를 지정할 수 있게 해준다.

이것은 우리가 여전히 정점 단계와 래스터라이저와 같은 파이프라인의 일부를 동시에 실행할 수 있고, 이전 패스의 프래그먼트 스테이지 출력에 의존하는 경우에만 프래그먼트 단계에서만 블록할 수 있기 때문에 훌륭합니다.

가능하다면, 최대 성능을 위해 항상 이것을 하는 것이 좋습니다.

이제, 이것은 기억해야 할 것이 많기 때문에, 이 목록에서 한 가지만 얻는다면, 이것을 기억하세요: 정적 텍스처와 메쉬와 같은 읽기 전용 데이터는 처리하기 가장 쉽습니다.

총 할당 크기와 정렬 요구 사항을 미리 결정하고 앱이 시작될 때 또는 게임의 로딩 섹션 중에 이러한 리소스를 힙에 배치하십시오.

이렇게 하면, 나중에 중요한 경로에서 최소한의 오버헤드로 단일 통화에 상주할 수 있습니다.

이제 바인드리스 바인딩 모델에 대해 알았으니, 리소스를 인코딩하고 이를 실제로 적용하고 인수 버퍼로 GPU에서 전체 장면을 사용할 수 있도록 하는 방법을 살펴봅시다.

인스턴스 버퍼를 인코딩하고 싶다고 가정해 봅시다.

기억하세요, 이 버퍼는 인스턴스 배열로 구성되어 있습니다.

우리가 보았듯이, 인스턴스는 메쉬, 재료를 참조하고, 지역 공간에서 세계 공간으로의 변화를 설명하는 인라인 상수 4x4 매트릭스를 포함한다.

인코딩은 인수 버퍼 인코더를 통해 수행되며, 메탈에서 하나를 만드는 두 가지 뚜렷한 방법이 있습니다.

당신은 반사를 통한 인코딩에 익숙할 것입니다.

인수 버퍼가 셰이더 함수에 직접 매개 변수로 전달되면, MTLFunction 객체에 인코더를 만들도록 요청할 수 있습니다.

이 메커니즘은 잘 작동하지만, 전체 장면을 인수 버퍼로 인코딩할 때, 모든 인코더가 반영될 수 있는 것은 아니다.

특히, MTLFunction 서명은 간접적으로 참조된 버퍼에 대해 알지 못한다.

MTLFunction에서 인코더를 만드는 것이 편리하지 않은 다른 상황도 있을 수 있습니다. 예를 들어, 엔진 아키텍처가 파이프라인 상태 생성과 별도로 인수 버퍼 생성 및 리소스 로딩을 처리하는 경우.

또한, 함수가 배열을 전달할 것으로 예상할 때 인코더를 반영할 수 없습니다.

그래서 이 경우에 우리는 무엇을 할 수 있을까요?

이러한 경우, Metal은 MTLArgumentDescriptor를 통해 인코더를 만드는 편리한 두 번째 메커니즘을 제공합니다.

MTLArgumentDescriptors는 구조체 멤버를 Metal에 설명하고 MTLFunction 없이 인코더를 만들 수 있게 해준다.

우리는 먼저 데이터 유형과 바인딩 인덱스를 지정하여 각 구성원에 대한 설명자를 만들어야 합니다.

다음으로, 우리는 설명자를 가져와서 엔코더를 만들기 위해 MTLDevice에 직접 전달합니다.

결과적으로, 우리는 인코더 객체를 다시 얻는다.

그래서 이것이 코드에서 어떻게 생겼는지 살펴봅시다.

각 구성원에 대해 MTLArgumentDescriptor를 만들어야 했습니다. 구조체에서 구성원의 ID 속성에 해당하는 바인딩 인덱스를 지정하고 MTLDataType을 지정하고 잠재적으로 액세스할 수 있습니다. 마지막으로 모든 구성원을 선언한 후 장치에서 직접 인코더를 만들어 모든 설명자와 함께 배열을 전달할 수 있습니다.

일단 인코더가 있으면, 데이터를 버퍼에 기록하는 것은 간단합니다.

우리는 버퍼의 시작 부분을 가리키며 인코더에 인수 버퍼를 설정합니다.

그런 다음, 우리는 단순히 저장하고 싶은 데이터를 설정합니다.

배열을 인코딩하는 것도 간단하다.

우리가 해야 할 일은 인코더에서 편리하게 검색할 수 있는 encodedLength로 인코더의 인수 버퍼 기록 지점을 오프셋하는 것입니다.

다음 경우, 우리는 두 번째로 오프셋에 encodedLength를 추가합니다.

사실, 우리가 기록해야 하는 각 위치의 오프셋은 인코딩된 길이의 인덱스 시간이 될 것이다.

이 메커니즘은 구조체의 배열을 매우 쉽게 인코딩할 수 있게 해준다.

이제, 언급할 가치가 있는 한 가지 중요한 점은 셰이더 측면에서 이러한 배열에 대한 인덱스까지 특별한 처리가 필요하지 않다는 것이다.

셰이더는 버퍼의 길이를 알 필요가 없으며 배열의 모든 위치에 자유롭게 인덱싱할 수 있습니다.

그건 그냥 작동해!

좋아, 이제 우리가 바인드리스 장면을 인코딩했으니, 내비게이션을 살펴봅시다.

레이 트레이싱의 경우, 내비게이션은 매우 자연스럽다.

먼저, 우리는 바인딩리스 장면의 루트를 포함하는 버퍼를 레이 트레이싱 파이프라인에 바인딩합니다.

이것은 우리가 다른 모든 것에 접근할 수 있는 논쟁 버퍼이다.

다음으로, 우리의 커널에서, 우리는 평소와 같이 광선 추적 교차로를 진행한다.

우리가 교차로를 발견한 후, 교차로 결과 객체는 내비게이션을 설명한다.

우리는 instance_id, geometry_id 및 primitive_id에 대해 이 객체를 쿼리할 수 있습니다.

이 회원들은 우리의 가속 구조를 탐색하기 위해 특별히 설계되었습니다.

그러므로, 앞서 보여준 것과 같이 우리의 가속 구조를 반영하는 구조로 우리의 바인딩리스 장면을 만드는 것이 중요하다.

다시 한 번 살펴보자.

기억하세요, 이것은 장면을 구성하는 방법의 예일 뿐이므로, 제가 어떻게 구성했는지에 따라 탐색할 것입니다.

장면에 대한 특정 세부 사항은 자신의 논쟁 버퍼를 구성하는 방법에 따라 달라질 수 있습니다.

먼저, 우리는 교차로를 찾아야 한다.

일단 우리가 그것을 갖게 되면, 우리는 전략적으로 바인딩리스 장면을 조직했기 때문에, instance_id를 감안할 때 우리는 이제 인스턴스 버퍼에 대한 포인터를 따라 우리가 어떤 것을 쳤는지 결정할 수 있습니다.

다음으로, 우리가 보았듯이, 그 사례는 메쉬와 재료를 알고 있다.

따라서 우리는 단순히 geometry_id를 사용하여 참조된 버퍼 내에서 어떤 지오메트리를 쳤는지 결정할 수 있습니다.

마지막으로, 인덱스 버퍼를 알기 위해 각 메쉬를 준비했다면, primitive_id를 사용하여 우리가 친 정확한 프리미티브를 결정할 수 있습니다.

예를 들어, 삼각형의 경우, 이 배열에서 세 개의 인덱스를 가져와 정점 데이터를 검색하는 데 사용할 수 있습니다.

금속 셰이딩 언어에서 이 내비게이션은 다음과 같습니다.

교차 객체에서, 우리는 instance_id를 검색하여 인스턴스 배열에 동적으로 인덱싱하고 우리가 친 인스턴스를 검색하는 데 사용합니다.

다음으로, 인스턴스를 가지고, 우리는 geometry_id를 사용하여 어떤 기하학이나 서브메시가 맞았는지 결정합니다.

기하학을 결정하면, 인덱스 버퍼에서 인덱스를 직접 가져올 수 있습니다.

삼각형의 경우, 우리는 세 개의 인덱스를 차례로 당긴다.

우리는 이 인덱스를 사용하여 정점 데이터 배열에 액세스하고 기술에 필요한 속성을 검색합니다.

예를 들어, 우리는 각 정점에 해당하는 법선들을 검색할 수 있다.

그리고 마지막으로, 점의 무게중심 좌표를 사용하여, 우리는 교차점에서 올바른 법선에 도달하기 위해 정점 법선을 수동으로 보간합니다.

이러한 변화와 함께, 우리의 찻주전자 예로 돌아가서, 이제 교차점에서 정상을 계산할 수 있는 방법이 있기 때문에, 우리는 반사를 올바르게 음영할 수 있습니다.

우리는 교차점에서 올바른 속성을 찾기 위해 코드를 업데이트했으며, 이제 결과는 시각적으로 정확합니다.

이제 이 프레임워크를 계속 구축하여 일반 매핑을 구현하기 위해 텍스처 좌표 또는 탄젠트 벡터를 적용하는 텍스처 좌표와 같이 원하는 다른 속성을 계산할 수 있습니다.

그래서 여기서 우리는 바인딩리스 장면을 탐색하여 정점 데이터를 검색하고, 수동으로 보간하고, 마지막으로 발견된 모든 교차점을 올바르게 음영 처리하기 위해 적용하는 방법을 보았습니다.

이러한 개념을 자신의 엔진에 가져올 수 있도록, 우리는 이 모든 것의 구체적인 구현을 보여주는 컴패니언 코드 샘플을 출시할 것입니다.

이것은 모델 I/O 프레임워크를 사용하여 로드된 장면에 대한 광선 추적 반사를 계산하는 하이브리드 렌더링 샘플입니다.

이 샘플은 레이 트레이싱 가속 구조와 일치하는 바인딩리스 장면을 인코딩하는 방법을 보여주며, 또한 교차로를 찾고 레이 트레이싱 셰이더에서 직접 관련 픽셀을 올바르게 음영하는 방법을 보여줍니다.

여기서 볼 수 있듯이, 샘플은 또한 광선이 트럭과 교차하는 지점에서 반사 레이 트레이싱 셰이더의 출력을 직접 시각화할 수 있게 해준다.

이것은 반사 알고리즘을 반복적으로 실험하는 데 좋습니다.

이제, 우리는 여기서 많은 것을 다루었고, 지금까지 우리는 레이 트레이싱의 맥락에서 대부분의 토론을 중심에 두고 있다.

하지만 앞서 언급했듯이, 우리는 래스터화의 맥락에서 픽셀을 적절하게 음영 처리하기 위해 동일한 원칙을 적용할 수 있습니다.

물리적 기반 렌더링은 이를 위한 훌륭한 후보이다.

PBR에서, 우리의 프래그먼트 셰이더는 여러 텍스처에서 오는 정보가 필요합니다; 예를 들어, 알베도, 거칠기, 금속 및 주변 폐색.

직접 바인딩 모델에서, 우리는 각각의 무승부 호출을 발행하기 전에 각 슬롯을 개별적으로 바인딩해야 합니다.

바인딩리스 모델은 이것을 크게 단순화한다.

인수 버퍼를 인코딩하면, 장면을 직접 바인딩하고, 그리기 호출에 해당하는 자료로 이동하고, 모든 텍스처에 간접적으로 액세스할 수 있습니다.

사실, 이제 단일 버퍼를 한 번만 바인딩해야 하기 때문에, 이 아키텍처는 드로우 호출 수를 줄이고 대신 인스턴스 렌더링을 사용하여 엔진을 더욱 최적화할 수 있는 훌륭한 기회를 제공합니다.

우리가 접근하려는 모든 텍스처를 거주자로 만드는 것을 잊지 마세요.

여기 전형적인 PBR 셰이더의 예가 있습니다.

전통적인 모델에서, 참조된 각 텍스처는 이 그리기 호출 전에 개별적으로 바인딩되어야 한다.

다음 그리기 호출에 다른 텍스처 세트가 필요한 경우, 이러한 모든 리소스도 하나씩 바인딩되어야 합니다.

바인드리스 모델을 사용할 때, 우리는 이제 루트 인수 버퍼를 전달하고 이전과 마찬가지로 참조된 구조에서 직접 자료를 검색할 수 있습니다.

먼저 인스턴스를 검색합니다. 이것은 정점 셰이딩 단계에서 결정될 수 있습니다. 그런 다음 재료를 검색하고 참조된 텍스처와 상수 데이터를 사용하여 적절한 셰이딩을 계산합니다.

마지막으로, 우리는 그냥 색을 돌려줘.

알았어!

그리고 그것은 금속에서 바인딩리스 렌더링을 효과적으로 구현하는 방법에 대한 투어였습니다!

요약하자면, 우리는 메탈 바인드리스 모델을 탐구했고 그것이 얼마나 유연한지 보았고, 당신이 원하는 방식으로 당신의 장면을 표현할 수 있게 해주었다.

제 추천은 주어진 렌더러의 탐색을 용이하게 하는 구조를 설계하고 구축하는 것입니다.

이렇게 하면 내비게이션이 매우 자연스러워지며, 레이 트레이싱과 래스터화 모두에 동일한 버퍼를 사용할 수도 있습니다.

Bindless는 게임을 완전히 변경하여 GPU에 최신 렌더링 기술을 구현하는 데 필요한 모든 데이터를 제공합니다.

더 나아가 이 아키텍처를 사용하여 GPU를 운전석에 넣고 간접 명령 버퍼와 GPU 컬링을 통해 간접 파이프라인을 채택할 수도 있습니다.

우리는 당신이 차세대 그래픽 애플리케이션과 게임을 제공하기 위해 이것을 어떻게 실천하는지 빨리 보고 싶습니다.

감사합니다 그리고 나머지 WWDC 2021을 즐기세요!

♪