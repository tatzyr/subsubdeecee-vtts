10190

안녕. 제 이름은 백산창이고, 저는 코어 오디오에서 일합니다.

오늘 저는 DriverKit으로 오디오 드라이버를 만드는 새로운 방법에 대해 논의할 것입니다.

하지만 먼저 오늘 오디오 드라이버가 어떻게 작동하는지 검토해 봅시다.

macOS Big Sur 이전에, 오디오 서버 플러그인은 사용자 클라이언트를 통해 커널 확장으로 하드웨어 장치와 통신해야 했다.

macOS Big Sur에서 CoreAudio HAL은 DriverKit 확장 프로그램 위에 구축된 오디오 서버 플러그인을 만들 수 있도록 지원을 제공했습니다.

플러그인과 덱스트 사이의 계층은 kext와 동일했지만, 커널에서 사용자 공간으로 이동하여 보안이 개선되었다.

DriverKit에 대한 자세한 내용은 이전 WWDC DriverKit 비디오를 확인하세요.

현재 솔루션을 통해 오디오 드라이버 개발이 커널에서 벗어날 수 있지만, 기능적인 하드웨어 오디오 드라이버를 구현하려면 두 개의 별도의 구성 요소가 여전히 필요합니다: 오디오 서버 플러그인과 드라이버 확장.

이것은 개발을 복잡하게 만들고, 자원을 증가시키며, 오버헤드와 대기 시간을 증가시킬 수 있다.

macOS Monterey부터, 당신은 더 이상 플러그인 없이 덱스트만 있으면 됩니다.

AudioDriverKit은 USBDriverKit 또는 PCIDriverKit과 함께 오디오 드라이버 확장을 작성하는 데 사용되는 새로운 DriverKit 프레임워크입니다.

이 새로운 프레임워크는 CoreAudio HAL에 대한 모든 프로세스 간 통신을 처리합니다.

덱스트만 있기 때문에, 이제 덱스트와 오디오 서버 플러그인 간에 통신할 필요가 없습니다.

DriverKit 내에서 집중할 수 있습니다.

AudioDriverKit 확장 프로그램은 Mac 앱 내부에 번들로 제공되기 때문에 더 이상 별도의 설치 프로그램이 필요하지 않습니다.

그리고 이제 당신의 드라이버는 즉시 로드되며, 재부팅이 필요하지 않습니다.

이제 AudioDriverKit의 이점을 알았으니, 새로운 오디오 드라이버를 만드는 데 뛰어들겠습니다.

오디오 드라이버와 관련된 구성 요소에 대한 간략한 개요로 시작한 다음, 덱스트를 쓰기 전에 필요한 몇 가지 사항을 다룰 것입니다.

코드 작성을 시작할 준비가 되면, 덱스트를 구성 및 초기화하고, 장치, 스트림 및 기타 오디오 객체를 만들고, IO 경로와 타임스탬프를 처리하는 방법을 살펴보겠습니다.

마지막으로, 구성 변경을 처리하는 방법에 대해 논의하고 마지막에 덱스트 데모를 보여드리겠습니다.

그럼 건축부터 시작합시다.

이 다이어그램은 HAL이 AudioDriverKit 프레임워크를 사용하여 드라이버 확장과 통신하는 방법을 보여줍니다.

AudioDriverKit 프레임워크는 CoreAudio와 오디오 덱스트 간의 모든 통신에 사용될 개인 사용자 클라이언트를 만들 것입니다.

이 사용자 클라이언트는 직접 사용되도록 의도되지 않으며 당신의 덱스트에 노출되지 않습니다.

앱과 덱스트 간에 통신하는 데 필요한 플러그인이나 사용자 지정 사용자 클라이언트가 없다는 점에 유의하십시오.

선택적으로, 앱은 필요한 경우 사용자 지정 사용자 클라이언트를 열어 덱스트와 직접 통신할 수 있습니다.

이제 당신이 필요로 할 자격에 대해 이야기해 봅시다.

모든 DriverKit 드라이버 확장에는 DriverKit 권한이 있어야 합니다.

AudioDriverKit 덱스트에는 모든 사용자 클라이언트 액세스를 허용할 수 있는 권한이 있어야 합니다.

이것은 DriverKit 자격에 대해 승인된 모든 개발자가 사용할 수 있습니다.

또한, 모든 운송 가족 자격은 필요에 따라 추가되어야 합니다.

아직 USB 또는 PCI 전송 자격을 요청하지 않았다면, Apple의 개발자 사이트를 방문하여 요청을 제출하십시오.

제시된 샘플 코드는 순전히 데모 목적을 위한 것이며 하드웨어 장치와 관련이 없는 가상 오디오 드라이버를 생성하므로 그런 종류의 사용 사례에 대한 자격은 부여되지 않습니다.

가상 오디오 드라이버나 장치가 필요한 전부라면, 오디오 서버 플러그인 드라이버 모델을 계속 사용해야 합니다.

이제 당신의 덱스트의 info.plist를 봅시다.

이러한 설정은 덱스의 IOKitPersonalities에 추가되어야 합니다.

AudioDriverKit은 HAL에 필요한 IOUserAudioDriverUserClient의 생성을 처리할 것이다.

HAL은 사용자 클라이언트 연결에 연결하는 데 필요한 권한을 가지고 있다.

다음은 SimpleAudioDriverUserClient를 위한 사용자 지정 사용자 클라이언트의 예입니다.

자세한 내용은 AudioDriverKitTypes.h 헤더 파일을 참조하십시오.

다음으로, 구성과 초기화에 대해 이야기해 봅시다.

오디오 덱스트를 구성하는 첫 번째 단계는 IOUserAudioDriver를 서브클래스하고 가상 메서드를 재정의하는 것입니다.

IOUserAudioDriver는 IOService의 하위 클래스이다.

사용자 지정 동작을 구현하는 데 필요한 모든 IOUserAudio 객체를 서브클래스하세요.

그런 다음 IOUserAudioDriver에 구성하고 추가하세요.

다이어그램은 당신이 만들 IOUserAudio 객체의 개요를 보여줍니다.

SimpleAudioDriver는 IOUserAudioDriver의 하위 클래스이며 덱스트의 진입점이다.

SimpleAudioDriver는 IOUserAudioDevice의 하위 클래스인 SimpleAudioDevice를 만들 것입니다.

오디오 장치는 모든 시작-정지 IO 관련 메시지, 타임스탬프 및 구성 변경을 처리합니다.

SimpleAudioDevice는 다양한 IOUserAudioObjects를 만들 것이다.

장치 객체는 또한 OSTimerDispatchSources, OSActions를 만들고 하드웨어 인터럽트와 IO를 시뮬레이션하기 위해 톤 생성기를 구현합니다.

IOUserAudioStream은 장치가 소유한 스트림이다.

스트림은 HAL에 매핑될 오디오 IO를 위해 IOMemoryDescriptor를 사용할 것이다.

IOUserAudioVolumeLevelControl은 스칼라 또는 dB 값을 취하는 제어 객체입니다.

제어 값은 입력 오디오 버퍼에 게인을 적용하는 데 사용됩니다.

모든 IOUserAudioObjects는 IOUserAudioCustomProperties를 가질 수 있습니다.

SimpleAudioDevice는 사용자 지정 속성과 문자열의 예를 한정자와 데이터 값으로 만들 것입니다.

코드를 살펴봅시다.

SimpleAudioDriver는 IOUserAudioDriver의 하위 클래스입니다.

Start, Stop 및 NewUserClient는 드라이버가 재정의해야 하는 IOService 클래스의 가상 메소드입니다.

StartDevice와 StopDevice는 IOUserAudioDriver의 IO 관련 가상 방법입니다.

이것들은 HAL이 오디오 장치에 대한 IO를 시작하거나 멈출 때 호출될 것이다.

장치, 스트림 및 기타 오디오 객체를 검토한 후 IO 경로에 대해 논의할 것입니다.

이 예제는 사용자 클라이언트 연결을 만들기 위해 NewUserClient를 재정의하는 방법을 보여줍니다.

NewUserClient는 클라이언트 프로세스가 덱스트에 연결하려고 할 때 호출됩니다.

AudioDriverKit 프레임워크는 IOUserAudioDriver 기본 클래스에서 NewUserClient를 호출하여 HAL이 요구하는 사용자 클라이언트 생성을 처리합니다.

이것은 CoreAudio HAL에 필요한 IOUserAudioDriverUserClient를 만들 것이다.

이전에 추가된 드라이버 확장 info.plist 항목에서 사용자 클라이언트 객체를 생성하는 IOService Create를 호출하여 사용자 지정 사용자 클라이언트를 만들 수도 있습니다.

시작을 재정의하고 사용자 지정 IOUserAudioDevice 객체를 만드는 방법을 살펴봅시다.

먼저, 슈퍼 클래스의 시작에 전화하세요.

그런 다음 SimpleAudioDevice를 할당하고 몇 가지 필수 매개 변수로 초기화하십시오.

초기화된 장치는 AddObject를 호출하여 오디오 드라이버에 추가해야 합니다.

마지막으로, 서비스를 등록하면, 운전자는 갈 준비가 되었습니다.

이제 드라이버가 초기화 되었으니, 장치, 스트림 및 몇 가지 다른 오디오 객체를 만들어 봅시다.

사용자 지정 동작을 위한 서브클래스 IOUserAudioDevice.

입력 스트림, 볼륨 제어 및 사용자 지정 속성 객체를 만들어 봅시다.

SimpleAudioDevice의 init 방법은 장치를 구성하고 다양한 오디오 객체를 만드는 방법을 보여줍니다.

장치의 샘플 속도 관련 정보는 장치에서 SetAvailableSampleRates 및 SetSampleRate를 호출하여 구성됩니다.

IOUserAudioStream에 전달될 IOBufferMemoryDescriptor를 만드세요.

메모리는 CoreAudio HAL에 매핑되어 오디오 IO에 사용됩니다.

메모리는 이상적으로 DMA와 하드웨어에 사용되는 IO 메모리와 동일해야 한다.

IOUserAudioStream은 입력 스트림 방향으로 지정하고 위에서 생성된 IO 메모리 설명자를 전달하여 생성됩니다.

작동하기 전에 스트림에서 몇 가지 추가 사항을 구성해야 합니다.

스트림 형식은 IOUserAudio StreamBasicDescriptions의 형식 목록을 만들어 정의됩니다.

샘플 속도, 형식 ID 및 기타 필요한 형식 속성을 지정하십시오.

위에 선언된 스트림 형식 목록을 전달하여 사용 가능한 형식을 설정하세요.

그리고 나서 스트림의 현재 형식을 설정하세요.

마지막으로, AddStream을 호출하여 구성된 스트림을 장치에 추가하세요.

이제 볼륨 레벨 컨트롤을 만들어 봅시다.

볼륨 제어 객체를 만들려면, IOUserAudioLevelControl::Create 메소드를 호출하세요.

컨트롤은 초기 레벨이 -6dB로 설정되고 범위가 96dB인 설정 가능한 볼륨 컨트롤입니다.

컨트롤의 요소, 범위 및 클래스도 지정해야 합니다.

마지막으로, 장치에 제어 개체를 추가하세요.

볼륨 제어 게인 값은 입력 스트림의 IO 버퍼에 게인을 적용하여 IO 경로에서 사용됩니다.

이제 장치에 대한 사용자 지정 속성 객체를 만드는 것을 살펴봅시다.

모든 사용자 지정 속성 객체에 대해 속성 주소를 제공해야 합니다.

글로벌 범위와 주요 요소로 사용자 지정 선택기 유형을 정의하세요.

다음으로, 위에 정의된 속성 주소를 제공하여 사용자 지정 속성 객체를 만드세요.

사용자 지정 속성은 설정할 수 있으며, 한정자와 데이터 값 유형은 모두 문자열입니다.

이제 한정자와 데이터 값에 대한 OSString을 만드세요.

그런 다음 사용자 지정 속성에 설정하세요.

마지막으로, 장치에 사용자 지정 속성을 추가하세요.

이제 오디오 객체를 만들었으니, IO에 대해 이야기해 봅시다.

GetIOMemoryDescriptor 방법은 IOUserAudioStream에서 사용하는 IOMemoryDescriptor를 반환합니다.

IOMemoryDescriptor는 스트림을 만들 때 init 방법으로 전달되며, 스트림은 새로운 메모리 설명자로도 업데이트할 수 있습니다.

메모리는 HAL에 매핑되어 오디오 IO에 사용될 것이다.

스트림에서 사용하는 것과 동일한 메모리 설명자는 이상적으로 DMA에서 하드웨어 장치에 사용되는 것과 같아야 합니다.

IOUserAudioClockDevice는 IOUserAudioDevice의 기본 클래스입니다.

UpdateCurrentZeroTimestamp와 GetCurrentZeroTimestamp는 하드웨어 장치의 타임스탬프를 처리하는 데 사용해야 합니다.

타임스탬프는 원자적으로 처리되며, HAL은 샘플 시간-호스트 시간 쌍을 사용하여 IO를 실행하고 동기화합니다.

하드웨어 시계의 타임스탬프를 가능한 한 가깝게 추적하는 것이 중요하다.

SimpleAudioDevice 수업을 살펴보고 IO 관련 방법에 집중해 봅시다.

StartIO와 StopIO는 HAL이 IO를 실행하려고 할 때 드라이버로부터 호출될 것이다.

IOTimerDispatchSource와 OSAction을 사용하여 하드웨어 인터럽트를 시뮬레이션하는 개인 방법은 입력 IO 버퍼에서 제로 타임스탬프와 오디오 데이터를 생성하는 데 사용됩니다.

이 예제는 하드웨어 장치에 대해 실행되지 않기 때문에, 하드웨어 인터럽트와 DMA 대신 타이머와 동작이 사용됩니다.

HAL이 장치에서 IO를 시작하려고 할 때 StartIO는 장치 객체에서 호출됩니다.

하드웨어에서 IO를 시작하는 데 필요한 모든 통화는 여기서 이루어져야 합니다.

그 후, StartIO는 기본 클래스에서 호출되어야 한다.

다음으로, 입력 스트림의 IOMemoryDescriptor를 가져와 CreateMapping을 호출하여 IOMemoryMap을 만들 수 있습니다.

버퍼 주소, 길이 및 오프셋은 IO 버퍼에서 톤을 생성하기 위해 발생한 작업 핸들러에 사용됩니다.

StartTimers는 타임스탬프를 생성하고 입력 오디오 버퍼를 채우기 위해 시간 소스와 작업을 구성하고 활성화하기 위해 호출됩니다.

UpdateCurrentZeroTimestamp는 IOUserAudioDevice의 샘플 시간-호스트 시간 쌍을 원자적으로 업데이트하기 위해 호출됩니다.

타이머 소스는 mach_absolute_time과 장치에서 구성된 호스트 틱을 기반으로 웨이크업 시간으로 활성화되고 설정됩니다.

ZtsTimerOccurred 작업은 장치에서 새로운 타임스탬프를 업데이트할 수 있도록 기상 시간에 따라 호출됩니다.

여기에 표시되지 않지만, 샘플 코드는 또한 비슷한 방식으로 톤 생성 타이머와 동작을 업데이트합니다.

제로 타임스탬프 동작이 실행되면, GetCurrentZeroTimestamp를 호출하여 장치에서 마지막 제로 타임스탬프 값을 얻습니다.

이것이 첫 번째 타임스탬프라면, 타이머에 전달된 mach_absolute_time을 앵커 시간으로 사용하세요.

그렇지 않으면, 타임스탬프는 제로 타임스탬프 기간과 버퍼당 호스트 틱으로 업데이트됩니다.

UpdateCurrentZeroTimestamp를 호출하면 HAL이 새 값을 사용할 수 있도록 장치의 타임스탬프가 업데이트됩니다.

다음 제로 타임스탬프를 위해 미래에 일어나도록 ZTS 타이머를 설정하세요.

DMA를 시뮬레이션하기 위해, 오디오 데이터는 타이머 동작이 실행될 때 입력 IO 버퍼에 기록될 것이다.

먼저, 시작 IO가 호출되었을 때 할당된 입력 메모리 맵이 유효한지 확인하세요.

메모리 맵 버퍼 길이와 스트림 형식을 사용하여 IO 버퍼 샘플의 길이를 가져오세요.

스트림은 서명된 16비트 pcm 샘플 형식만 지원하기 때문에 버퍼 주소와 오프셋을 가져와 int16_t 버퍼 포인터로 할당하십시오.

이제 사인 톤을 생성하여 입력 IO 버퍼를 채울 수 있습니다.

먼저, 입력 볼륨 제어 게인을 스칼라 값으로 얻으세요.

그런 다음 필요한 샘플 수를 루프하고 볼륨 제어 게인을 적용하여 사인 톤을 생성합니다.

다음으로, 버퍼를 반복하고 채널 수에 따라 사인 톤 샘플을 IO 버퍼로 채우세요.

이제 오디오 덱스가 구성되고 IO를 실행할 수 있으므로, 다음 단계는 장치와 IO 관련 상태를 업데이트하기 위한 구성 변경을 처리하는 것입니다.

표시된 장치 방법은 구성 변경을 요청하고 수행하는 데 사용할 수 있습니다.

IO 또는 그 구조에 영향을 미칠 오디오 장치의 상태를 변경하는 경우, 드라이버는 RequestDeviceConfigurationChange를 호출하여 구성 변경을 요청해야 합니다. HAL은 실행 중인 IO를 중지하고 PerformDeviceConfigurationChange는 드라이버에서 호출됩니다.

그래야만 오디오 장치가 IO 관련 상태를 업데이트할 수 있다.

이것의 일반적인 시나리오는 오디오 장치의 현재 샘플 속도를 업데이트하거나 하드웨어 장치의 변경 사항에 대응하도록 현재 스트림 형식을 변경하는 것입니다.

다이어그램은 장치 구성 변경에 대한 일련의 이벤트를 보여줍니다.

운전자는 먼저 구성 변경을 요청해야 합니다.

HAL은 모든 청취자에게 장치에 대한 설정 변경이 시작될 것이라고 알릴 것이다.

IO가 현재 실행 중이라면 장치에서 중지될 것이다.

장치의 현재 상태가 캡처될 것이다.

PerformDeviceConfigurationChange는 드라이버에서 호출됩니다.

이것은 드라이버가 장치와 하드웨어의 상태를 변경할 수 있는 때이다.

구성 변경이 수행되면 장치의 새로운 상태가 캡처되고 IO 버퍼 또는 샘플 속도와 같은 모든 IO 관련 상태가 업데이트됩니다.

장치의 상태에 대한 변경 사항은 모든 클라이언트 청취자에게 통보될 것입니다.

설정 변경 전에 IO가 이전에 실행되었다면, IO는 장치에서 다시 시작될 것이다.

마지막으로, HAL은 모든 청취자에게 설정 변경이 종료되었음을 알릴 것이다.

하드웨어 상향식 구성 변경 요청을 시뮬레이션하기 위해, 사용자 지정 사용자 클라이언트 명령은 덱스트에서 샘플 속도 변경을 트리거하는 데 사용됩니다.

RequestDeviceConfigurationChange는 오디오 장치의 구성 변경 요청을 HAL에 알릴 것입니다.

변경 정보는 모든 종류의 OSObject가 될 수 있습니다.

이 예제는 사용자 지정 구성 변경 작업과 변경 정보를 OSString으로 제공합니다.

구성 변경 수행을 처리하려면, SimpleAudioDevice 클래스는 PerformDeviceConfigurationChange에서 PerformDeviceConfigurationChange 메서드를 재정의해야 합니다. switch 문에서 구성 변경 작업을 처리합니다.

구성 변경이 요청되었을 때 변경 정보로 제공된 동일한 OSString 객체를 기록하십시오.

다음으로, 현재 샘플 속도를 얻고, 장치에 새로운 속도를 설정하세요.

스트림 객체에서 DeviceSampleRateChanged를 호출하여 샘플 속도 변경을 처리하기 위해 오디오 스트림이 현재 스트림 형식을 업데이트하는지 확인하십시오.

장치가 직접 처리하지 않는 다른 구성 변경 작업은 기본 클래스로 전달될 수 있습니다.

Mac에서 이것을 살펴봅시다.

그래서 SimpleAudio는 드라이버 확장을 번들로 묶는 샘플 코드 응용 프로그램입니다.

오디오 드라이버 확장 프로그램을 설치하려면 드라이버 설치를 누르기만 하면 보안 환경 설정이 필요합니다.

따라서 허용을 누르면 오디오 드라이버 확장을 동적으로 로드해야 합니다.

이전에는 재부팅이 필요했기 때문에 kext에서는 불가능했습니다.

그래서 SimpleAudioDevice에는 사용 가능한 샘플 속도 형식과 톤 선택 데이터 소스가 있습니다.

그리고 우리가 샘플 코드에 추가한 볼륨 컨트롤.

이제 우리는 퀵타임을 열고 오디오 장치에서 오디오 녹음을 할 수 있습니다.

그리고 상향식 구성 변경을 테스트하기 위해, 우리는 덱스트와 직접 통신하여 톤 주파수나 샘플 속도를 전환할 수 있으며, 변경 사항은 오디오 MIDI 설정에도 반영되어야 합니다.

드라이버 확장을 제거하려면, 애플리케이션을 삭제하기만 하면 됩니다.

그리고 오디오 MIDI 설정에서 더 이상 사용할 수 없다는 것을 알 수 있습니다.

마무리하기 위해, 나는 오디오 서버 플러그인과 DriverKit 확장의 상태를 요약했다.

이것은 계속 지원되며 AudioServerPlugIn 드라이버 인터페이스는 더 이상 사용되지 않습니다.

나는 새로운 AudioDriverKit 프레임워크를 소개하고 새로운 드라이버 모델의 이점에 대해 논의했다.

AudioDriverKit 프레임워크를 채택하는 방법에 대한 심층적인 예를 살펴봤고 사용자 공간에서 실행되는 IOUserService 기반 오디오 덱스트를 만들기 위한 샘플 코드를 보여주었습니다.

최신 Xcode와 DriverKit SDK를 다운로드하세요.

DriverKit 지원 하드웨어 장치 제품군이 있는 오디오 장치에 AudioDriverKit을 채택하십시오.

그리고 Apple의 피드백 어시스턴트를 통해 AudioDriverKit에 대한 피드백을 제공해 주세요.

고마워.

[쾌활한 음악].