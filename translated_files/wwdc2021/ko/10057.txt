10057

♪ 베이스 음악 연주 ♪

♪

크리스 도니건: 안녕하세요, 저는 UIKit의 엔지니어인 크리스입니다.

나는 나중에 내 동료 아난트와 모하메드와 합류할 것이다.

아이패드는 그 힘과 기능으로 인해 많은 사람들에게 주요 장치이다.

이 비디오에서는 iPad 앱을 한 단계 끌어올리기 위해 사용해야 하는 몇 가지 흥미로운 새로운 기능에 대해 배우게 될 것입니다.

먼저, 멀티태스킹과 장면의 최신 발전을 보여드리겠습니다.

그런 다음, Anant는 키보드 단축키에 대한 강력한 변경 사항을 안내할 것입니다.

마지막으로, 모하메드는 당신에게 시스템 포인터에 대한 최신 개선 사항을 보여줄 것입니다.

바로 멀티태스킹으로 들어가자.

iPadOS 13은 앱 UI의 여러 인스턴스를 실행할 수 있는 기능을 도입했습니다.

iPadOS 15에서, 우리는 향상된 상태 복원뿐만 아니라 장면 프레젠테이션을 위한 새로운 API로 이 경험을 개선하고 있습니다.

이러한 개선 사항은 기존 UIScene 인프라를 기반으로 합니다.

UIScene을 채택하지 않았다면, "iPad에서 여러 Windows 소개"를 확인하세요.

핵심 개념을 간략하게 살펴봅시다.

장면은 앱 UI의 단일 인스턴스를 나타냅니다.

장면 구성 요소의 구조는 장면 구성에 의해 정의된다.

최소한, 그것은 장면의 역할과 위임 클래스를 정의한다.

이름, 스토리보드 및 장면 하위 클래스를 제공할 수도 있습니다.

장면 구성은 Info.plist에서 선언하거나 UISceneConfiguration 객체를 사용하여 런타임에 만들 수 있습니다.

장면의 내용은 NSUserActivity로 표시됩니다.

이러한 활동은 국가 복원뿐만 아니라 장면을 요청하는 데 사용된다.

장면은 장면 대리인에 의해 관리된다.

대리인은 UI를 설정하고, 수명 주기 이벤트에 응답하고, 상태를 저장하고 복원할 책임이 있다.

마지막으로, 장면은 장면 세션에 의해 추적된다.

장면 자체는 백그라운드에 있을 때 시스템에 의해 연결이 끊어지고 다시 연결될 수 있다.

장면 세션은 연결 상태에 관계없이 장면을 추적하고 실행 사이에 지속됩니다.

그 세션은 시스템 앱 스위처의 표현으로 생각할 수 있다.

스위처의 각 항목은 장면 세션에 해당한다.

시스템에서 장면을 요청할 때, 요청을 사용자 정의하기 위한 옵션 객체를 제공할 수 있습니다.

iPadOS 15에는 윈도우 장면을 위한 새로운 옵션 서브클래스가 있습니다.

이 서브클래스를 사용하면 프레젠테이션 스타일을 지정할 수 있습니다.

윈도우 장면 프레젠테이션 스타일은 작업 공간의 다른 장면에 비해 장면이 표시되는 방식에 영향을 미친다.

세 가지 가능한 값이 있다: 눈에 띄는, 표준, 그리고 자동.

이것은 눈에 띄는 프레젠테이션 스타일을 사용하는 장면이다.

그것은 현재 작업 공간에서 모드로 표시되며 그 뒤의 장면이 흐려졌다.

모달이기 때문에, 취소, 닫기 또는 완료 버튼을 제공해야 합니다.

이 새로운 스타일은 새로운 장면을 위한 무대로 생각할 수 있다.

새로운 멀티태스킹 컨트롤을 사용하여 다른 장면처럼 재배치할 수 있으며, 나중을 위해 앱 선반으로 이동할 수도 있습니다.

이 스타일이 장면에 적합한지 고려할 때, 명심해야 할 몇 가지 지침이 있다.

첫째, 눈에 띄는 장면은 그 자체로 유용해야 한다.

그것들은 다른 장면을 위한 옵션이나 도구를 제공하는 데 사용되어서는 안 된다.

완료 또는 닫기 버튼을 제공해야 하며, 문서나 파일과 같은 앱 내의 특정 콘텐츠에 전념해야 합니다.

이 전용 콘텐츠 범위는 장면의 활성화 조건에서 정의되어야 합니다.

활성화 조건에 대한 자세한 내용은 "여러 Windows로 콘텐츠 타겟팅"을 확인하세요.

이 예시는 사파리가 표준 스타일을 사용하여 새로운 장면을 여는 방법을 보여줍니다.

그것들은 나란히 제시되어 각각과의 상호 작용을 허용하며, 둘 다 주요 장면의 모든 기능을 제공한다.

스타일로 자동을 지정할 수도 있습니다.

이 값은 시스템에 요청된 방법에 따라 최고의 스타일을 선택해야 한다고 알려줍니다.

iPadOS 15는 스타일을 사용하여 프레젠테이션을 사용자 정의할 수 있는 방법을 제공할 뿐만 아니라 사람들이 새로운 장면에서 콘텐츠를 더 쉽게 열 수 있게 해준다.

Mac에서는 컨텍스트 메뉴에서 새 창에서 열기 항목을 찾는 것이 일반적입니다.

UIWindowScene.ActivationAction을 사용하여 이 친숙한 경험을 iPad 앱에 가져와야 합니다.

메뉴, 버튼 및 막대 버튼 항목에서 사용할 수 있는 장면을 요청하기 위한 새로운 UIAction 하위 클래스입니다.

이 기능을 앱에 추가하려면, UIWindowScene.ActivationAction을 초기화하여 시작하세요.

항목이 선택될 때 실행되는 폐쇄로 초기화됩니다.

폐쇄는 새로운 장면의 콘텐츠에 대한 사용자 활동과 함께 활성화 구성을 반환해야 합니다.

마지막으로, 메뉴를 메뉴에 넣으면 갈 수 있습니다.

iPad와 Mac Catalyst에서 메뉴는 새 창에서 열기 항목을 표시하며, 선택하면 새로운 장면을 표시합니다.

iPhone에서는 여러 장면이 지원되지 않기 때문에 항목이 자동으로 숨겨집니다.

그 자리에 다른 항목을 보여주고 싶다면, 대체 액션을 제공할 수 있습니다.

하나를 제공하기 위해 이전 예시를 업데이트합시다.

이렇게 하려면, 대체 액션을 만드는 것으로 시작하세요.

새로운 작업의 제목과 이미지는 여러 창을 사용할 수 없을 때 표시됩니다.

그런 다음, 새로운 액션을 대안으로 전달하여 장면 활성화 액션의 이니셜라이저를 업데이트하세요.

제공된 대체 작업으로, iPad와 Mac Catalyst의 메뉴는 여전히 새 창에서 열기 항목을 표시하지만 iPhone에서는 세부 정보 표시 항목을 볼 수 있습니다. 모두 코드에서 단일 조건 없이 완료됩니다.

이러한 메뉴 항목을 추가하는 것은 사람들이 새로운 장면에서 콘텐츠를 열 수 있는 명확하고 친숙한 방법입니다.

하지만 그게 유일한 방법은 아니야.

iPad는 터치 우선 장치이며 한 번의 제스처로 장면을 쉽게 열 수 있습니다.

노트 앱에서 셀을 꼬집면 새로운 장면에서 노트가 열립니다.

그 장면은 세포에서 최종 위치까지 대화식으로 애니메이션화된다.

앱에서 이 기능을 제공하는 두 가지 방법이 있습니다.

컬렉션 뷰를 사용하는 경우, 새로운 위임 방법이 있습니다.

다른 보기의 경우, UIWindowScene ActivationInteraction을 사용하세요.

이 두 가지 모두 눈에 띄는 스타일의 장면을 보여주기 위한 것이다.

컬렉션 보기에서 이 제스처를 지원하려면, sceneActivationConfiguration ForItemAt indexPath라는 새로운 위임 메소드를 구현하십시오.

그것은 이전의 컨텍스트 메뉴 예시와 매우 유사하다.

새 장면의 콘텐츠에 대한 사용자 활동을 만든 다음, 해당 활동으로 활성화 구성을 반환하십시오.

당신은 모든 셀이 새로운 장면을 여는 것을 지원하는 것을 원하지 않을 수도 있습니다.

제스처가 시작되는 것을 막기 위해, 그냥 nil을 돌려주세요.

다른 보기에서 이 제스처를 지원하려면, UIWindowScene을 만드세요. 활성화 상호 작용.

그것은 두 가지 주장을 받아들이는 폐쇄로 만들어졌다: 상호 작용 자체와 뷰의 좌표 공간에서의 상호 작용 지점.

이것들은 보기의 다른 영역에 대한 특정 사용자 활동을 만드는 데 사용될 수 있다.

폐쇄는 사용자 활동과 함께 활성화 구성을 반환해야 합니다.

상호 작용은 또한 오류 처리기를 취한다.

여러 장면을 지원하지 않는 플랫폼에서는 상호 작용이 비활성화되지만, 구성 문제나 시스템 리소스 부족으로 인해 오류가 여전히 발생할 수 있습니다.

당신은 아마도 창 장면을 제시하는 이러한 모든 방법이 동일한 활성화 구성 객체를 사용한다는 것을 눈치챘을 것입니다.

유일한 요구 사항은 사용자 활동이지만, 장면 요청 옵션과 대상 미리보기도 포함되어 있습니다.

이것들이 제공되지 않는다면, 시스템은 당신을 위해 그것들을 만들기 위해 최선을 다할 것입니다.

그러나, 당신은 경험을 다듬기 위해 그것들을 명시적으로 제공할 수 있습니다.

예를 들어, 이 컬렉션 보기 셀에는 썸네일, 제목 및 캡션이 있습니다.

셀이 끼어지면, 주로 썸네일 콘텐츠의 더 큰 버전을 표시하는 장면이 표시됩니다.

새로운 장면이 세포 전체에서 전환되고 있다는 것을 주목하세요.

썸네일에서 전환하면 더 좋아 보일 것이다.

이 효과를 달성하기 위해, 활성화 구성은 이전과 같이 만들어진다.

그런 다음, 셀이 썸네일 셀인지 확인하세요.

그렇다면, 셀의 썸네일 보기를 사용하여 대상 미리보기를 만들고 구성에서 설정하십시오.

활성화 구성에 대한 사용자 지정 미리보기를 제공함으로써, 전환은 훨씬 더 세련되었다.

좀 더 자세히 살펴보자.

이제, 셀 자체에서 전환하는 대신, 썸네일에서 전환하여 나머지 셀을 제자리에 둡니다.

활성화 구성을 사용하면 앱의 장면을 요청할 수 있습니다.

그러나, 당신은 단순히 장면을 직접 만들 필요 없이 파일을 표시하고 싶을 수도 있습니다.

iPadOS 15는 이것을 매우 쉽게 만든다.

UIWindowScene의 특별한 하위 클래스가 있습니다. "QLPreviewScene ActivationConfiguration"이라고 불리는 ActivationConfiguration.

미리보기 장면 구성을 반환하면 시스템에서 관리되는 미리보기 장면이 요청됩니다.

장면 위임과 걱정할 콜백은 없지만, 앱은 Info.plist에서 여러 창에 대한 지원을 선언해야 합니다.

사람들이 새로운 장면에서 콘텐츠를 열 수 있는 세련되고 편리한 방법을 제공하는 것은 중요하다.

하지만 장면의 상태를 저장하고 복원하는 것도 똑같이 중요하므로 나중에 그들에게 돌아가는 것은 원활한 경험이다.

장면이 배경으로 이동하면, 시스템은 장면의 대리인에게 NSUserActivity가 상태를 나타내도록 요청할 것이다.

이 활동은 핸드오프를 지원하거나 그 자리에서 생성된 루트 뷰 컨트롤러의 활동일 수 있습니다.

여기서, 활동의 사용자 정보 사전에 텍스트 필드의 내용을 저장하는 사용자 활동이 생성됩니다.

최고의 경험을 제공하기 위해, 장면 상태는 단순한 내용을 넘어서야 한다.

또한 스크롤 위치, 커서 위치 및 첫 번째 응답자 상태와 같은 시각 및 상호 작용 상태를 저장해야 합니다.

이들 각각을 독립적으로 저장하는 대신, UITextField와 UITextView는 이제 interactionState 속성을 가지고 있습니다.

이 속성은 모든 상호 작용 상태를 포함하는 단일 객체를 제공한다.

객체는 콘텐츠 자체를 포함하지 않으며, 사용자 활동에 저장할 수 있는 추가 정보입니다.

텍스트 필드의 상호 작용 상태를 저장하여 이전 예제를 업데이트했습니다.

이제, 콘텐츠와 상호 작용 상태를 모두 저장함으로써, 사용자 활동에는 정확하게 복원할 수 있는 충분한 정보가 포함되어 있습니다.

iPadOS 14에서 상태를 복원하는 것은 조금 까다로울 수 있다.

장면이 연결될 때 상태를 복원하려고 하면, 스토리보드와 뷰가 완전히 로드되지 않았다는 것을 알 수 있습니다.

나중에 복원했다면, 장면이 전경으로 전환될 때, 그것이 처음인지 아닌지 추적해야 했습니다.

iPadOS 15는 상태를 복원하기 위한 새로운 위임 방법으로 이 문제를 해결합니다.

장면이 연결되고 스토리보드가 로드된 후, 첫 번째 전경으로 전환하기 전에 호출됩니다.

앱이 스토리보드를 사용하는지 여부에 관계없이, 상태를 복원하기 위해 이 새로운 콜백을 사용해야 합니다.

이전 예제에 저장된 활동의 상태 복원은 시스템이 sceneRestoreInteractionState를 호출하는 것으로 시작됩니다.

그런 다음, 텍스트 필드의 내용을 복원하세요.

마지막으로, 상호 작용 상태를 복원한다.

상호 작용 상태 전에 콘텐츠를 복원하는 것이 중요합니다.

마지막으로, 동기적으로 상태를 복원하는 것은 복잡할 수 있다.

데이터베이스에 액세스하거나 파일을 로드해야 할 수도 있으며 그 시간 동안 빈 UI를 원하지 않을 수도 있습니다.

이를 설명하기 위해, iPadOS 15를 사용하면 앱이 단기 연장을 요청할 수 있습니다.

이 확장 기간 동안, 실행 이미지는 메인 RunLoop가 실행되도록 허용하면서 계속 볼 수 있습니다.

콘텐츠가 로드되면, 앱은 복원을 완료하라는 신호를 보내야 합니다.

이 확장은 짧고 네트워크 액세스와 같은 잠재적으로 오래 지속되는 작업에 사용하기 위한 것이 아닙니다.

앱이 완료 신호를 보내지 못하거나 너무 오래 걸리면, 시스템에 의해 닫힙니다.

확장된 상태 복원을 사용하려면, 현장에서 확장을 요청하는 것으로 시작하세요.

그런 다음, 비동기 작업을 시작하세요.

콘텐츠가 로드되면, 복원하고 장면에 복원을 완료하라고 말하세요.

그러면 그 장면은 새로 복원된 UI를 표시할 것이다.

앱에서 멀티태스킹을 지원하면 빛나지만, 진정한 차세대 iPad 앱이 되기 위해 해야 할 일이 더 많습니다.

그리고 이제, 아난트에게.

아난트 제인: 고마워, 크리스!

제 이름은 아난트이고 UIKit 엔지니어입니다.

사람들은 iPad가 즉시 물리적 키보드에 부착할 수 있는 동안 손에 잡을 수 있을 만큼 가볍다는 것을 좋아한다.

그들은 당신의 앱이 훌륭한 키보드 지원을 통해 그들을 따라잡기를 기대합니다.

iPadOS 15는 앱의 키보드 단축키를 한 단계 끌어올리기 위한 몇 가지 새로운 기능을 소개합니다.

iPadOS 15는 키보드 단축키를 발견하기 위한 완전히 새로운 인터페이스를 갖추고 있습니다.

각 명령을 친숙한 범주로 구성하여 앱의 iPad와 Mac Catalyst 버전 간의 패리티를 증가시킵니다.

이 메뉴는 시스템 전체 어디에서나 가져올 수 있는 편리한 검색 기능을 제공합니다.

단축키를 탭하여 트리거할 수도 있습니다.

명령이 응답자 체인에 전달되는 방법을 포함하여 UIKeyCommand로 키보드 단축키를 지원하는 방법에 대한 재교육이 필요한 경우, "앱에서 하드웨어 키보드 지원"을 확인하십시오.

Mac Catalyst에서 앱은 각각 화면 상단의 메뉴 표시줄에 표시되는 메인 메뉴라는 글로벌 메뉴를 가지고 있습니다.

메인 메뉴는 파일 및 편집과 같은 여러 카테고리 하위 메뉴로 구성되어 있으며, 이러한 카테고리 메뉴에는 모든 앱의 명령이 포함된 추가 하위 메뉴가 포함되어 있습니다.

iPadOS 15에서, 우리는 메인 메뉴 시스템을 iPad 앱에 도입했습니다.

Command 키를 길게 눌러 나타나는 새로운 바로 가기 인터페이스는 이 메뉴를 표시합니다.

이제, 메인 메뉴 시스템은 Mac에 비해 iPad에서 약간 다르게 표현된다.

Mac은 각 범주 내의 전체 하위 메뉴 계층 구조를 표시하는 반면, iPad는 이러한 계층을 평평하게 한다.

비활성화되고 작동하지 않는 명령은 Mac에서 회색으로 나타나는 반면, iPad에는 숨겨져 있다.

게다가, iPad 단축키 메뉴는 앱에서 키보드 단축키를 찾을 수 있도록 설계되었습니다.

Mac 메뉴 표시줄처럼 키 없는 명령을 표시하지 않습니다.

기본적으로, 메인 메뉴에는 파일 및 편집과 같은 모든 시스템 카테고리 메뉴가 포함되어 있습니다.

여기에는 실행 취소 및 다시 실행, 붙여넣기 및 일치 스타일과 같은 모든 시스템 명령이 포함됩니다.

iPadOS 15는 이 시스템 명령 목록에 인쇄 명령을 추가하며, 앱은 UIApplication SupportsPrintCommand 키를 Info.plist에 추가하여 얻을 수 있습니다.

이제 iPadOS 15의 iPad 앱이 메인 메뉴 시스템을 지원하므로, Mac Catalyst 앱과 마찬가지로 UIMenuBuilder API를 사용하여 사용자 정의할 수 있습니다.

사실, 만약 당신이 이미 앱의 Mac Catalyst 버전을 가지고 있다면, 당신은 이미 대부분의 작업을 완료했습니다.

앱은 빌더를 사용하여 지원되는 모든 키 명령을 메인 메뉴에 추가해야 합니다.

이것은 앱이 이전에 키보드 단축키를 선언하는 방식과의 변화입니다: UIResponder에서 keyCommands 속성을 재정의하거나 뷰 컨트롤러에서 addKeyCommand(_:)를 호출하여.

이런 식으로 정의된 명령은 여전히 작동하지만, 새로운 인터페이스의 별도의 분류되지 않은 섹션에 나타날 것이다.

앱은 이와 같은 키 명령 선언을 제거하고 대신 메인 메뉴에 추가해야 합니다.

메인 메뉴를 사용자 정의하려면, AppDelegate에서 buildMenu(withbuilder:)를 재정의하십시오.

UIKit은 앱 실행 시 이 메서드를 호출하고 UIMenuBuilder 객체를 전달합니다.

앱은 빌더가 메인 메뉴 시스템을 수정하고 있는지 확인해야 합니다.

그렇다면, 그들은 빌더를 사용하여 커스터마이징을 할 수 있다.

앱이 탭 작업을 위해 파일 메뉴에서 몇 가지 키 명령을 원한다고 가정해 봅시다.

앱은 UIMenu API를 사용하여 하위 메뉴를 만들고 원하는 키 명령을 메뉴의 자식으로 추가합니다.

그런 다음 앱은 빌더 객체의 insertChild 메소드를 호출하여 하위 메뉴를 파일 메뉴에 삽입합니다.

이 경우 파일 메뉴와 같은 메인 메뉴 시스템의 기존 요소를 참조하려면 앱은 요소의 식별자를 지정해야 합니다.

내장된 시스템 메뉴 식별자는 UIMenu.Identifier에서 상수로 정의됩니다.

앱은 그들만의 메뉴 카테고리도 쉽게 만들 수 있다.

여기서, 앱은 UIMenu API를 사용하여 다시 한 번 북마크 메뉴를 만듭니다.

그런 다음, 앱은 빌더를 사용하여 해당 메뉴를 루트 메뉴에 삽입합니다. 이 경우 시스템 보기 메뉴 뒤에 있습니다.

그게 필요한 전부야!

이제, 빌더는 파일 메뉴와 마찬가지로 북마크 메뉴에 추가로 삽입하는 데 사용할 수 있습니다.

UIKit이 자동으로 생성하는 새 메뉴의 식별자를 전달하기만 하면 됩니다.

이제, 나는 식별자를 계속 언급한다.

UIMenuBuilder는 메인 메뉴 시스템의 각 요소에 개별 명령을 포함한 고유한 식별자가 있음을 강제할 것이다.

앱이 콘텐츠를 목록이나 그리드로 표시하기 위해 키 명령을 삽입한다고 가정해 봅시다.

두 명령 모두 같은 동작을 공유합니다: changeViewMode(_:).

메인 메뉴 시스템에서 명령은 동작에 의해 암시적으로 식별되므로, 두 명령 모두 동일한 식별자를 공유합니다.

UIMenuBuilder는 식별자가 다르지 않는 한 두 명령을 모두 삽입하는 것을 허용하지 않습니다.

이러한 명령을 구별하는 한 가지 방법은 그들에게 다른 propertyList 값을 주는 것이다.

하지만 더 나은 방법은 단순히 각 명령에 그것이 구체적으로 무엇을 하는지 설명하는 독특한 행동을 하는 것이다.

빌더는 또한 메인 메뉴의 키보드 단축키 조합이 독특하다는 것을 시행한다.

앱이 Command-I에 Get Info 키 명령을 삽입한다고 가정해 봅시다.

텍스트 스타일 메뉴의 시스템 이탤릭체 단축키가 동일한 단축키를 공유하기 때문에, 이 삽입도 실패할 것이다.

다시 한번, 두 가지 해결책이 있다.

이 앱은 정보 가져오기 단축키를 Control-Command-I와 같은 기존 단축키와 충돌하지 않는 것으로 변경할 수 있습니다.

또는, 앱은 필요하지 않은 경우 작성기에 텍스트 스타일 명령을 제거하도록 말할 수 있습니다.

삽입에 중복이 포함된 경우, UIMenuBuilder는 삽입에 실패하고 중복된 키 명령이나 공유 식별자를 보여주는 콘솔에 오류를 기록합니다.

삽입이 나타나지 않는 것을 발견한다면, 어딘가에 중복이 있을 가능성이 있으므로, 콘솔에서 이와 같은 로그를 찾아보세요.

buildMenu(빌더 포함:)에 대한 호출이 완료되면, 앱의 메인 메뉴가 Mac 메뉴 표시줄과 iPad 단축키 오버레이에 나타납니다.

하지만 한 가지 문제가 있어.

이 앱은 이름이나 날짜별로 북마크를 정렬하는 명령이 있는 하위 메뉴를 추가했습니다.

하지만 iPad 단축키 오버레이는 하위 메뉴 계층 구조를 표시하지 않기 때문에, 이 단축키가 iPadOS에서 무엇을 하는지 명확하지 않습니다.

이와 같은 상황의 경우, 키 명령에 더 설명적인 발견 가능성 제목을 설정하세요.

iPadOS는 둘 다 제공되는 경우 일반 제목보다 발견 가능한 제목을 선호한다.

이제, 저는 이전에 개별 응답자가 키보드 단축키를 선언하는 것을 피하고 대신 메인 메뉴 시스템에 선언해야 한다고 언급했습니다.

그러나, 응답자들은 여전히 메인 메뉴 명령에 대한 작업 방법을 구현해야 한다.

키 명령이 트리거되면, UIKit은 자동으로 응답자에게 작업을 발송합니다.

UIKit은 앱의 응답자 체인을 통과하여 이를 수행합니다.

작업을 수행할 수 있는 응답자를 찾자마자, 응답자의 작업 방법을 호출합니다.

체인의 어떤 것도 작업을 수행할 수 없다면, 키 명령은 수행할 수 없습니다.

UIResponder 개념을 처음 접한다면, "앱의 하드웨어 키보드 지원"은 어떻게 작동하는지에 대한 환상적인 소개를 제공합니다.

"훌륭한 Mac Catalyst 앱의 품질" 또한 조금 더 자세히 살펴봅니다.

UIKit이 체인을 따라 응답자 검색을 수행할 때, 두 가지 유용한 UIResponder 메소드를 호출합니다.

앱은 키 명령을 개선하기 위해 응답자에서 이러한 방법을 재정의할 수 있습니다.

첫 번째는 UIKit이 응답자가 작업을 수행할 수 있는지 확인하는 데 사용하는 canPerformAction (_:withSender:)입니다.

기본적으로 응답자가 해당 작업 방법을 구현하면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.

응답자들은 사용자 지정 논리를 추가하기 위해 이것을 재정의할 수 있다.

예를 들어, 웹 브라우저는 UIKit에 열린 탭이 없으면 closeTab 명령을 수행할 수 없다고 말할 수 있습니다.

UIKit은 해당 작업에 대한 대상 응답자를 찾을 수 없기 때문에, 명령은 수행할 수 없으며 바로 가기 인터페이스에 표시되지 않습니다.

이 방법에 대한 재정의는 처리되지 않은 경우 슈퍼를 호출해야 합니다.

다른 유용한 방법은 validate(_ 명령:)이다.

UIKit이 키 명령의 대상 응답자를 찾으면, 해당 응답자에서 이 메소드를 호출하고 명령 복사본을 전달합니다.

응답자는 validate(_ command:)를 재정의하여 앱의 현재 상태에 대한 명령 모양을 업데이트할 수 있습니다.

여기서, 앱은 현재 페이지가 북마크되어 있는지 여부에 따라 toggleBookmark(_:) 명령의 제목을 업데이트합니다.

이 방법의 제목은 나타날 때 바로 가기 인터페이스에 반영될 것이다.

iPadOS 15에서 UIKit은 응답자 체인에 큰 변화를 도입하고 있다.

앱이 포커스 시스템으로 키보드 내비게이션을 채택하면, 응답자 횡단은 첫 번째 응답자가 아닌 초점을 맞춘 항목에서 시작됩니다.

이 변화는 키 명령으로 믿을 수 없을 정도로 잘 작동한다.

예를 들어, 사진은 사용자가 키보드만 사용하여 사진 라이브러리로 작업할 수 있게 해준다.

사용자가 그리드의 셀에 초점을 맞추면, 스페이스 바를 눌러 그 사진을 볼 수 있다.

그들은 심지어 Command-C를 눌러 그 사진을 복사하여 다른 앱에 붙여넣을 수도 있다.

각 셀은 다양한 키 명령 동작을 구현하며, 응답자 횡단은 집중된 항목에서 시작되기 때문에 키 명령은 셀을 대상으로 합니다.

간단히 말해서, 포커스 시스템은 키 명령과 응답자 체인을 레벨업한다.

그것을 활용하여 앱에서 강력한 상황별 단축키를 지원하세요.

자세한 내용은 "iPad 키보드 내비게이션에 집중"을 확인하세요.

마지막으로, iPadOS 15와 macOS 12는 키보드 단축키 현지화를 도입한다.

이러한 SDK로 앱을 빌드할 때, 시스템은 각 키보드 레이아웃에 대한 바로 가기 수정자와 입력을 자동으로 현지화합니다.

예를 들어, 명령 백슬래시 단축키를 가져가세요.

바로 가기는 미국 키보드에서 작동하지만, 레이아웃에는 백슬래시 키가 없기 때문에 일본어 키보드에서 수행하는 것은 불가능합니다.

그래서 그 시스템은 일본어 키보드의 단축키를 다시 매핑할 것이다.

이것은 앱이 바로 가기 수정자나 입력을 현지화해서는 안 되며, 대신 시스템이 작업을 수행하도록 해야 한다는 것을 의미합니다.

앱은 또한 앱 전체 수준 또는 단축키별로 자동 현지화를 거부할 수 있습니다.

시스템이 단축키를 현지화할 때, 오른쪽에서 왼쪽 레이아웃을 위해 그것들을 미러링한다.

예를 들어, 명령-왼쪽 괄호로 뒤로 이동하는 단축키는 명령-오른쪽 괄호로 뒤집힌다.

단축키를 미러링해서는 안 되는 경우, 명령의 allowsAutomaticMirroring 속성을 false로 설정하여 자동 현지화를 완전히 비활성화하지 않고 미러링을 비활성화하십시오.

iPadOS 15는 키보드 단축키를 위한 거대한 출시이다.

오늘 우리가 다룬 모든 것 외에도 수많은 다른 개선 사항이 있습니다.

그래서 당신은 모든 새로운 멀티태스킹 기능을 채택했고, 훌륭한 키보드 지원을 구축했습니다.

이제, 모하메드는 당신의 iPad 앱을 최고 수준으로 끌어올릴 수 있는 몇 가지 조언을 줄 것입니다.

모하메드 지스라위: 고마워, 아난트! 안녕하세요, 저는 모하메드입니다.

iPadOS 15가 시스템 포인터에 제공하는 개선 사항에 대해 이야기해 봅시다.

iPadOS 13.4는 iPad의 터치 기반 UI와 마우스 또는 트랙패드의 정밀도를 연결하는 적응형 시스템 포인터를 도입했습니다.

포인터 상호 작용이 처음이라면, 잠시 시간을 내어 그것들을 숙지하고 이 이전 비디오를 확인하세요.

"iPadOS 포인터를 위한 빌드"는 포인터 상호 작용 API를 분해합니다.

"Design for the iPadOS Pointer"는 그 이면의 디자인 철학을 탐구하고 앱에 채택할 때 모범 사례에 대해 논의합니다.

iPadOS 15는 iPad의 디자인 언어와 일치하는 방식으로 친숙한 Mac 사용자 상호 작용을 제공합니다.

그것은 또한 유용성과 명확성을 향상시키는 몇 가지 새로운 개념을 소개한다.

이러한 추가 사항 중 첫 번째는 Mac을 사용하는 모든 사람에게 친숙해야 하는 새로운 포인터별 다중 선택 경험인 밴드 선택이다.

iPadOS 15에서 컬렉션 보기를 클릭하고 드래그하면 포인터가 직사각형으로 늘어나고 컬렉션 보기는 직사각형이 포함하는 항목을 선택합니다.

물론 이것은 자연스럽게 Mac Catalyst 앱의 친숙한 Mac UI로 번역됩니다.

이 상호 작용은 목록이 아닌 UICollectionViews에 내장되어 있습니다.

shouldBeginMultiple SelectionInteraction API를 통해 기존의 한 손가락 및 두 손가락 다중 선택 제스처를 지원하는 UICollectionView는 iPadOS 15에서 자동으로 이 동작을 가져옵니다.

UICollectionView 이외의 경우, 새로운 UIBandSelectionInteraction API를 사용하면 앱에서 이 경험을 쉽게 채택할 수 있습니다.

선택 논리는 전적으로 당신에게 달려 있기 때문에, 사용자 지정 선택 동작을 지원하고 UI가 원하는 방식으로 변경 선택에 반응하도록 할 수 있습니다.

시작하려면, 포인터가 움직이고 상호 작용의 상태가 변경됨에 따라 호출될 선택 핸들러와의 상호 작용을 인스턴스화하십시오.

일단 생성되면, 다른 UIInteraction과 마찬가지로 보기에 상호 작용을 추가하세요.

핸들러에서 상호 작용 상태와 selectionRect의 변화에 응답하여 사용자 지정 선택 논리를 구현할 수 있습니다.

여기에는 포인터가 이동하는 동안 상호 작용의 selectionRect 내의 항목으로 선택을 설정하는 간단한 구현이 있습니다.

그런 다음 기본 마우스 버튼이 해제되고 상호 작용이 끝나면 선택 세션을 완료합니다.

기본 선택 외에도, UICollectionView의 내장 밴드 선택은 즉시 사용할 수 있는 몇 가지 일반적인 키보드 단축키를 지원합니다.

예를 들어, 드래그 시작 시 Shift를 누르면 현재 선택된 항목을 대체하는 대신 기존 선택 항목에 항목이 추가됩니다.

Command를 누르면 선택 rect에서 항목의 선택 상태를 토글합니다.

이것은 드래그 시작 시 키를 제공하는 상호 작용의 initialModifierFlags 속성을 사용하여 사용자 지정 UI에서 구현할 수 있습니다.

모든 눌린 수정자의 집합이기 때문에, 앱에 특정한 사용자 지정 또는 고급 동작을 지원하기 위해 임의의 키 조합에 응답할 수 있습니다.

시스템 포인터에 두 번째로 추가된 것은 액세서리를 부착할 수 있는 능력이다.

액세서리는 2차 모양을 기본 포인터와 결합하여 추가 정보를 전달하고 문맥 힌트를 제공합니다.

예를 들어, 왼쪽의 예에서, 두 개의 화살표는 이 보기를 수평으로 드래그할 수 있음을 나타냅니다.

오른쪽의 예에서, 더하기는 이 장바구니에 추가 버튼에 대한 추가 컨텍스트를 제공합니다.

액세서리와 사용자 지정 포인터 모양을 사용하는 것 사이에는 몇 가지 주요 차이점이 있습니다.

액세서리는 시각적으로 분리되어 있으며 메인 포인터에 부차적이다.

이것은 그들이 다른 모습으로 렌더링되고 메인 포인터와 별도로 애니메이션화될 수 있다는 사실에 의해 강조된다.

그것들은 다른 아이디어를 전달하기 위해 포인터 주위에 결합되고 배치될 수 있는 독립적인 단위이다.

그것들은 독립적이기 때문에, 어떤 포인터 스타일과도 결합될 수 있다.

드래그 가능성을 나타내는 두 개의 화살표와 같은 액세서리 세트가 어떻게 다른 포인터 스타일과 결합될 수 있는지에 대한 데모가 있습니다.

왼쪽에서, 그것들은 포인터가 뷰와 합쳐져 들어 올리는 리프트 효과와 결합된다.

중간에, 그들은 포인트가 둥근 직사각형으로 변하고 시야 아래로 들어가는 하이라이트 효과와 함께 있다.

오른쪽에, 그들은 새로운 UIPointerStyle.system() API를 사용하여 기본 시스템 포인터와 함께 나타납니다.

그래서 우리는 포인터의 생동감을 희생하지 않고 앱의 UI와의 깊은 관계를 유지하면서 상황에 이상적인 효과를 사용하면서 이 추가 컨텍스트를 제공할 수 있습니다.

포인터 스타일 사이에서 움직이는 것처럼, 시스템은 액세서리의 모양과 실종을 자동으로 애니메이션화할 것이다.

그것은 또한 액세서리 모양과 위치 사이에서 매끄럽게 애니메이션화할 것이다.

주어진 효과가 활성화되어 있는 동안 액세서리를 전환하는 행위는 의미가 있을 수 있다.

이러한 전환은 기본 UI의 상태 또는 행동의 변화를 전달하는 데 사용될 수 있다.

왼쪽의 예에서, 더하기에서 노 기호로의 전환은 이전에 가능했던 작업이 더 이상 허용되지 않는다는 것을 나타낼 수 있다.

포인터 액세서리는 UIPointerShape와 UIPointerAccessory.Position으로 구성되어 있으며, 원하는 위치를 포인터의 중간 지점에서 오프셋과 상단 각도로 설명합니다.

편의를 위해, UIKit은 포인터 주변의 위치에 대해 미리 정의된 값을 제공합니다.

미리 정의된 위치가 당신의 필요에 맞지 않는다면, 당신은 그것들을 출발점으로 사용하고 개별 속성을 사용자 정의할 수 있습니다.

이 예제는 topRight 위치에서 시작하여 오프셋을 사용자 정의합니다.

또한 이 예에서와 같이 사용자 지정 오프셋과 각도로 위치를 만드는 완전히 사용자 지정 위치를 정의할 수 있습니다.

이 세그먼트의 시작 부분에서 본 예를 설정하기 위해, 우리는 우리의 보기로 UITargetedPreview를 만들고 그것을 사용하여 리프트 효과가 있는 UIPointerStyle을 만들 것입니다.

그런 다음 우리는 스타일의 새로운 액세서리 속성을 두 개의 화살표 액세서리가 포함된 배열로 설정할 것입니다.

UIKit은 미리 만들어진 화살표 액세서리를 제공하므로, 효과의 왼쪽과 오른쪽에 위치한 두 개를 만들 수 있습니다.

그래서 이제 포인터가 이 뷰를 맴돌 때, 두 개의 화살표는 뷰가 들어 올릴 때 움직이며, 드래그할 수 있음을 암시한다.

포인터 효과가 있는 뷰를 드래그할 수 있는 이런 종류의 상호 작용을 구현하려고 시도한 적이 있다면, 당신은 아마 이와 같은 것을 눈치챘을 것입니다.

포인터가 포인터 영역의 가장자리에 도달하면, 들어 올려진 시야에서 벗어나 효과가 끝납니다.

이것은 포인터가 움직일 때 뷰에 달라붙는 것을 방지하기 때문에 일반적으로 바람직하다.

그러나, 이와 같은 시나리오에서, 이상적인 경험은 포인터 효과가 안정적으로 유지되고 시야에 고정되고 끌릴 때 따라가는 것이다.

이러한 종류의 상호 작용을 더 잘 가능하게 하기 위해, iPadOS 15는 UIPointerRegion에서 latchingAxes의 개념을 소개합니다.

영역이 주어진 축을 따라 걸릴 때, 포인터 효과는 기본 마우스 버튼을 누를 때 축을 따라 포인터를 따른다.

수평 래칭 영역을 사용하면 y축을 따라 고무 밴딩하는 동안 x축을 따라 자유롭게 끌 수 있습니다.

수직 래칭을 사용하면 y축을 따라 자유롭게 끌 수 있습니다.

그리고 둘 다 걸쇠를 걸면 두 축을 따라 자유롭게 끌 수 있습니다.

이 새로운 도구들은 정말 강력한 새로운 경험을 구축하는 데 사용될 수 있다.

여기서 그것들은 Pages나 Keynote와 같은 문서 편집 앱에 결합되어 있습니다.

이 이미지는 밴드 선택을 사용하여 선택할 수 있습니다.

이미지를 선택하면 드래그 표시기가 나타나고, 포인터가 표시기 위에 마우스를 올려놓으면 액세서리가 드래그하면 이미지의 크기가 어떻게 조정되는지 암시하는 것처럼 나타납니다.

그리고 마지막으로, 래칭은 포인터 효과와 액세서리가 축으로 잠겨 있는 크기 조정 제스처를 따를 수 있게 해준다.

이것들은 iPadOS 15가 iPad에 제공하는 개선 사항 중 일부일 뿐입니다.

앱의 유용성을 극대화하기 위해 해당되는 경우 그것들을 활용하세요.

눈에 띄는 장면을 채택하여 사람들에게 앱의 콘텐츠에 대한 집중적이고 중단 없는 시각을 제공하세요.

새로운 키보드 단축키 메뉴로 복잡한 작업을 빠르게 수행할 수 있도록 권한을 부여하고, 새로운 포인터 기능으로 생산성을 높이세요.

봐줘서 고마워!

♪