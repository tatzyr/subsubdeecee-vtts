10021

안녕하세요, 저는 제이콥입니다. "SwiftUI 앱에 풍부한 그래픽 추가"에 오신 것을 환영합니다.

저는 동료 몇 명과 함께 그라디언트를 만들기 위한 앱을 개발하고 있습니다.

올해, 색상은 우리 팀에서 가장 인기 있는 것이다.

대부분의 구현은 이미 완료되었다.

이제 나는 풍부한 그래픽을 추가하여 끝내야 한다.

앱을 사용자 정의할 때, 우리는 몇 가지 다른 영역을 보게 될 것입니다: 사용자 지정을 포함한 안전 영역 작업; 새로운 전경 스타일 지원; 풍부한 새로운 재료 세트; 그리고 강력한 새로운 보기인 캔버스로 그리기.

그럼 시작하자.

지금까지 앱에 뭐가 있는지 보여줄게.

우리는 그라디언트 라이브러리를 가지고 있고, 나는 그 그라디언트를 볼 수 있다.

이건 내가 정말 좋아하는 게 있어.

난 그냥 그것에 손가락을 댈 수 없어.

그라디언트를 편집할 수도 있어...

그건 내가 색 정지를 바꿀 수 있게 해준다.

그리고 나는 새로운 그라디언트를 추가할 수 있다.

나는 또한 몇몇 비주얼라이저에서 이 그라디언트를 사용할 수 있다...

하지만 한 번에 한 걸음씩. 우리는 그것들을 조금 나중에 볼 거야.

지금은, 이 그라디언트 디테일 뷰에 집중합시다.

그것은 기능적이지만, 우리의 실제 콘텐츠는 크롬과 빈 공간에 비해 꽤 작다.

나는 그라디언트가 정말로 이 화면을 대신하기를 원한다.

그러니 Xcode에서 편집을 시작합시다.

이것은 우리의 주요 세부 사항 보기이며, 편집 모드에도 사용됩니다.

isEditing false로 시작하고, 나중에 편집 모드를 살펴보겠습니다.

이 프레임을 삭제하여 그라디언트가 가능한 한 많은 공간을 사용하도록 합시다.

그리고 이제 그라디언트가 모든 높이를 차지하고 있기 때문에, 우리는 더 이상 이 스페이서가 필요하지 않습니다.

우리는 이것을 ZStack으로 변경하여 이 그라디언트 위에 컨트롤을 올려서 더 나아갈 수 있습니다.

이전에 ZStack을 본 적이 없다면, 서로 옆에 있는 대신 서로 위에 요소를 배치합니다.

편집 컨트롤을 하단으로 옮겨봅시다.

그리고 우리는 그라디언트가 아니라 컨트롤에 패딩만 있으면 됩니다...

그러니까 이걸 옮기자.

패딩을 제거한 후에도 그라디언트의 상단과 하단에 왜 여전히 빈 공간이 있는지 궁금할 것입니다.

기본적으로 SwiftUI는 안전한 영역 내에 콘텐츠를 배치하여 홈 표시기 또는 표시되는 막대와 같이 보기를 흐리게 하거나 클립하는 것을 피합니다.

안전 영역은 전망이 표시되는 가장 바깥쪽 전체 영역에서 삽입된 영역으로 표시됩니다.

안전 영역의 콘텐츠는 가려질 영역을 피하기 위해 적절한 삽입물 내에 자동으로 배치됩니다.

안전한 영역은 또한 SwiftUI가 키보드 아래에 콘텐츠를 그리는 것을 피하는 데 도움이 되는 방법입니다.

그래서 우리 앱에서, 우리의 컨트롤은 자동으로 키보드의 길에서 벗어날 것이다.

이것은 같은 방식으로 작동하며, 우리가 어떻게 하는지 더 자세히 살펴본다면, 그것은 여러 개의 다른 안전 영역이 있기 때문이다.

가장 일반적인 것은 컨테이너 안전 영역으로, 컨테이너에 의해 구동되며 뷰가 표시되며 바와 장치 크롬과 같은 것을 포함합니다.

게다가, 키보드를 피할 수 있는 키보드 안전 구역이 있다.

그리고 키보드 안전 영역은 항상 컨테이너 안전 영역 내의 영역이라는 점에 유의하십시오.

그것은 키보드 외에도 컨테이너 안전 영역과 같은 영역에서 콘텐츠를 안전하게 유지합니다.

안전한 구역에서 탈퇴할 수 있다.

대부분의 콘텐츠는 클리핑되지 않도록 안전 영역 내에 있어야 하기 때문에 일반적으로 이것을 할 필요가 없습니다.

그건 결국 안전해.

하지만 안전한 영역을 무시하는 것은 당신이 완전히 가고 싶은 배경이나 다른 콘텐츠에 대해 말이 될 수 있습니다.

이 코드를 사용하여 모든 안전 영역을 선택 해제하거나 키보드 영역을 지정하여 키보드 안전 영역을 선택 해제할 수 있습니다.

전체 출혈 효과를 얻기 위해 선형 그라디언트에 ignoresSafeArea를 추가합시다.

이 편집 버튼은 그라디언트 위에 잘 보이지 않으므로, 하단 가장자리의 안전 영역만 무시합시다.

이제, 이 하단 텍스트가 그라디언트에서 읽을 수 없는 것과 같은 문제가 발생하지 않도록 하기 위해, 그 뒤에 배경을 추가해 봅시다.

우리는 1분 안에 배경을 사용자 정의할 것이지만, 다크 모드에서 자동으로 변경되는 흰색 배경을 제공하는 가장 간단한 기본값으로 시작합시다.

그리고 이 배경은 또한 자동으로 안전 영역을 넘어 확장된다.

이 버전의 배경과 그 동작은 iOS 15와 정렬된 OS 릴리스에서 새로운 것이다.

그게 어떻게 작동하는지 보자.

컨테이너 뷰와 안전 구역부터 시작합시다.

그런 다음 우리는 읽을 수 있도록 안전한 영역 내에 있는 콘텐츠 보기를 가지고 있습니다.

만약 우리가 적용된 뷰에 같은 경계를 가진 배경을 순진하게 추가한다면, 우리는 이것을 얻을 것이다.

하지만 우리가 ignoresSafeArea 수정자를 배경 보기에만 적용하면, 주요 콘텐츠를 멋지고 안전하게 유지하면서 안전한 영역 너머로 확장될 것입니다.

새로운 배경 수정자는 당신에게 이 동작을 자동으로 제공합니다.

배경으로 돌아가서 커스터마이징을 시작합시다.

우리는 그라디언트와 같은 색상이나 다른 스타일이 될 수 있는 특정 스타일로 전달할 수 있습니다.

이 앱에서는 정말 말이 되지 않지만, 파스텔 색의 것을 살펴봅시다.

나는 또한 이 배경을 클립하기 위해 모양을 전달할 수 있다...

예를 들어, 둥근 직사각형.

사용자 지정 모양을 사용할 때, 배경이 더 이상 안전한 영역 밖으로 확장되지 않아 모양이 콘텐츠의 경계와 일치한다는 점에 유의하십시오.

내 생각에 우리 앱에 더 잘 맞을 것 같은 것은 우리의 배경에 대한 흐림이다.

우리는 그것을 하기 위해 또 다른 새로운 API를 사용할 수 있다: 재료.

재료는 적용할 수 있는 표준 블러 스타일의 집합입니다.

그리고 이 배경을 전체 영역을 차지하는 것으로 돌아가도록 합시다.

재료는 우리가 이와 같은 다채로운 콘텐츠를 통해 보여주고 싶은 장소에 아주 좋습니다.

매우 얇은 것부터 매우 두꺼운 것까지 선택할 수 있는 다양한 재료 세트가 있습니다.

그리고 이 모든 것은 모든 플랫폼에서 올바른 디자인을 자동으로 보여줍니다.

나는 여기서 얇은 재료를 사용할 거야.

다음으로, 나는 우리의 텍스트를 사용자 정의하고 싶다.

이름이 여기서 주요 정보라는 것을 보여주기 위해 색상의 수를 조금 덜 두드러지게 합시다.

나는 보조의 전경 스타일을 설정함으로써 그것을 할 수 있다.

당신은 2차 콘텐츠가 그 뒤에 있는 색상을 혼합하는 Vibrancy라는 효과로 자동으로 표시되는 것을 눈치챘을 것입니다.

SwiftUI에는 이 효과에 대한 추가 API가 없습니다.

물질적 맥락에서 새로운 2차에서 4차 스타일을 사용할 때 자동으로 발생합니다.

그것은 우리가 방금 했던 것처럼 자료로 배경을 명시적으로 추가하거나, 콘텐츠가 당신을 위해 자료를 추가하는 사이드바와 같은 시스템 구성 요소에 있을 때 발생할 수 있습니다.

그리고 이 스타일들은 많은 자동 지능을 가지고 있다.

그들은 생동감 넘치는 효과를 사용하지 않는 흐릿하지 않은 상황에서도 자동으로 옳은 일을 한다.

그들은 또한 색상을 설정할 때 자동으로 행동을 변경하여 각 레벨의 색상 버전을 설정합니다.

그리고 동일한 지원은 기본 전경 스타일, 심지어 그라디언트와 같은 것을 설정하는 데 작동합니다.

세련되게 사용하세요.

주목해야 할 한 가지: 주어진 텍스트는 단일 전경 스타일을 적용할 수 있지만, 범위 내에서 여러 색상을 적용할 수 있습니다.

예를 들어, 문자열 보간을 사용하여 내부 텍스트를 삽입할 수 있습니다...

그리고 나서 빨간색의 전경색을 적용하세요...

"색상"이라는 단어로.

그리고 그것은 그 범위의 활기를 자동으로 선택하지 않고 그 색을 보여줄 것이다.

더 중요한 것은, 이러한 전경 스타일로, 사상 처음으로, 당신은 그들이 작동하는 임베디드 이모티콘으로 올바른 행동을 얻을 수 있다는 것입니다.

이거 좋아 보인다.

다시 실행하고 이러한 변경 사항으로 편집 모드도 시도해 봅시다.

그건 이미 대부분 작동해.

그리고 이 색들은 흐림 아래에 들어가는데, 그것은 훌륭하다.

하지만 당신이 자세히 본다면, 그것은 꽤 옳은 일을 하고 있지 않습니다.

내가 끝까지 스크롤할 때, 흐림 뒤에 숨겨진 목록이 조금 있다.

무슨 일이 일어나고 있는지 좀 더 자세히 살펴봅시다.

크롬을 없애고 여기서 관련 견해만 살펴봅시다.

우리가 이 뷰들을 약간 수평으로 밀어 넣으면, 바가 우리 콘텐츠 위에 ZStacked되어 있기 때문에 이것을 볼 수 있습니다.

이제 우리는 뒤에 있는 모든 시야를 보고 싶으니, 그것은 올바른 행동이 아니다.

여기서 VStack으로 변경할 수 있지만, 흐림 아래의 목록이 없으면 아래로 스크롤할 때 표시되는 색상을 얻을 수 없습니다.

우리는 목록의 배경과 스크롤 가능한 영역이 바 아래로 확장되기를 원하지만 주요 내용은 확장되지 않기를 바랍니다.

그리고 이것이 바로 안전한 지역을 위한 것이다.

만약 우리가 이 바에 의해 안전한 구역을 삽입한다면, 어떤 중요한 내용도 눈에 띄지 않을 것이다.

우리 자신의 견해의 안전한 영역을 사용자 정의하기 위해, 우리는 새로운 수정자를 사용할 수 있습니다: safeAreaInset.

이를 통해 주요 콘텐츠 위에 바와 같은 보조 콘텐츠를 추가할 수 있습니다.

내가 우리 ZStack을 교체할게...

안전한 지역 삽입물과 함께...

하단의 가장자리를 사용하여...

그리고 그것에 우리의 통제를 넣어.

다시 실행해서 확인해 봅시다.

이 전망은 여전히 똑같아 보이는데, 좋다.

그건 안전 구역을 무시하고 있기 때문이야.

그리고 편집 모드에서...

우리는 여전히 그 흐림을 얻기 위해 바 아래로 스크롤할 수 있다.

하지만 우리가 아래로 스크롤할 때, 아무것도 가려지지 않는다.

좋아.

다음으로, 우리의 비주얼라이저를 살펴봅시다.

이미 작성된 셰이프 비주얼라이저부터 시작합시다.

그것은 많은 수의 무작위 모양 기호를 보여주며, 각각은 앱의 그라디언트 중 하나로 그려집니다.

기호를 탭해서 확대할 수 있어...

또는 모든 기호를 재배치하려면 배경을 탭하세요.

그리고 이전에 SwiftUI 애니메이션 데모를 본 적이 있다면, 항상 상호 작용적이고 중단할 수 있다는 것을 알고 있습니다.

그래서 나는 계속 재배치할 수 있어...

그리고 그것이 일어나는 동안 모양을 선택하고 선택 해제하기 위해 탭할 수도 있습니다.

내가 코드를 보러 간다면...

그것은 SwiftUI에서 그래픽을 그리기 위한 일반적인 기술을 사용하고 있다.

GeometryReader가 있어서 이 모든 그래픽을 배치하기 위해 뷰의 크기를 읽을 수 있고 ZStack을 배치하는 데 도움이 됩니다.

그리고 몸의 끝에, 당신이 전에 보았을 수도 있는 수정자가 있습니다: drawingGroup.

drawingGroup은 SwiftUI에게 포함된 모든 뷰를 단일 레이어로 결합하여 그리도록 지시합니다.

이것은 이와 같은 그래픽 요소에서 잘 작동하지만 텍스트 필드와 목록과 같은 UI 컨트롤과 함께 사용해서는 안 됩니다.

이것은 우리가 여기서 하는 것처럼 많은 그래픽 요소를 보여주고 싶을 때 사용할 수 있는 훌륭한 기술입니다.

그리고 drawingGroup의 이점 중 하나는 이러한 뷰가 다르게 그려지더라도 앱의 다른 모든 곳에서 사용하는 SwiftUI의 동일한 기능을 여전히 사용할 수 있다는 것입니다.

예를 들어, 여기서는 탭하기 위해 각 기호에 적용된 제스처와 선택을 변경하거나 재배치할 때 적용되는 애니메이션이 있습니다.

이러한 견해에 포함된 접근성 정보도 정상적으로 전달됩니다. 예를 들어, 각 기호에 대한 이러한 접근성 작업입니다.

그러나, 이러한 모든 기능을 지원하기 위해, 각 보기에 필요한 부기와 저장 공간이 있습니다.

만약 당신이 충분한 수의 요소를 가지고 있다면, 그 여분의 오버헤드조차도 너무 많을 수 있습니다.

그리고 그러한 경우를 위해, 우리는 새로운 캔버스 뷰를 도입했습니다.

우리의 다음 비주얼라이저는 복잡한 입자 시스템을 보여줄 것이며, 아직 작성되지 않았습니다.

가서 짓자.

그것을 그리기 위해 캔버스 보기부터 시작합시다.

이를 통해 캔버스가 그려질 때마다 실행되고 그리기 명령이 포함된 클로저를 만들 수 있습니다.

UIKit 또는 AppKit의 drawRect에 익숙하다면, 이것은 꽤 비슷하게 작동합니다.

이 폐쇄는 우리가 그리기 명령을 보내는 맥락과 전체 캔버스의 크기를 얻는 데 사용할 수 있는 크기를 제공합니다.

그냥 이미지를 그리는 것으로 시작합시다.

나머지 SwiftUI 코드에서 사용하는 것과 동일한 이미지 유형을 사용하여 하나를 만들 수 있습니다.

그리고 우리의 이미지를 그릴 맥락을 말합시다.

우리가 그것을 0,0으로 그릴 때, 그것은 잘 보이지 않는 원점을 중심으로 여기에 있다.

전체 캔버스의 크기를 사용할 수 있기 때문에, 대신 중간에 그리기 위해 그것을 사용합시다.

그리고 내가 미리보기를 다크 모드로 바꾸면 네가 볼 수 있는 한 가지...

우리가 이전에 본 것과 같은 전경 스타일을 사용하고 있기 때문에, 우리의 이미지가 자동으로 뒤집혀서 흰색으로 그려지는 것입니다.

우리가 입자 시스템을 만들고 싶기 때문에, 이 이미지를 몇 번 더 그려봅시다.

이 폐쇄는 필수 코드를 위한 것입니다.

그건 뷰빌더가 아니야.

그래서 난 그냥 루프를 위해 일반을 사용할 수 있어.

그리고 우리가 실제로 볼 수 있도록 각 이미지를 조금 바꾸자.

이제, 우리는 이 이미지를 여러 번 그리고 있지만, 매번 같은 이미지임에도 불구하고, 컨텍스트는 현재 환경과 같은 것을 기반으로 평가하기 위해 그것을 해결해야 합니다.

우리는 그것을 그리기 전에 이미지를 스스로 해결함으로써 이것을 개선할 수 있다.

이제 우리는 동일한 해결된 이미지를 공유하기 때문에 더 나은 성능을 가지고 있지만, 해결된 이미지는 또한 우리가 다른 일을 할 수 있게 해준다.

우리는 이제 그것의 크기와 기준선을 요청할 수 있다.

우리의 경우, 우리는 각각을 적절한 양으로 옮기기 위해 그 크기를 사용할 것이다.

다음으로, 우리의 반짝임 뒤에 타원을 추가합시다.

나는 그것들을 같은 지역에 그릴 거야.

그러니 둘 다 그리기 위해 프레임을 꺼내자.

나는 같은 X와 Y 값으로 CGRect를 만들고 너비와 높이에 대한 이미지 크기를 사용할 것이다...

그런 다음 그 프레임에 우리의 이미지를 그리세요.

각 그리기 작업이 순서대로 이루어지기 때문에, 우리의 타원을 이미지 뒤에 두려면, 우리는 그것을 먼저 그려야 한다.

그리고 우리는 그것을 문맥으로 그릴 수 있다. 채우기...

길과 음영을 취하는 것.

표준 베지어 곡선으로 경로를 구성할 수 있지만, 여기에 팁이 있습니다: 타원과 같은 모양을 사용하여 주어진 직사각형에서 경로를 요청할 수도 있습니다.

다른 주장은 우리의 길을 채워야 할 음영이다.

그리고 이것은 SwiftUI 앱의 나머지 부분과 같은 스타일을 사용할 수 있습니다.

청록색을 사용하자.

그리고 타원이 있어.

하지만, 이미지와 대조가 많지 않다.

그걸 고치자.

그래픽 컨텍스트에는 불투명도, 혼합 모드, 변환 등과 같은 많은 표준 그리기 속성이 있습니다.

여기에 불투명도를 설정하자.

그리고 우리는 이 맥락이 당신이 익숙한 것과 조금 다르게 행동하는 영역을 볼 수 있습니다.

내가 문맥에 불투명도를 설정하면, 그것은 당신이 예상한 대로 작동합니다.

그것은 나중에 일어나는 모든 작업에 영향을 미친다.

과거에, 내 드로잉 작업 중 일부에만 적용되는 그래픽 컨텍스트를 변경하고 싶다면, 저장 및 복원 호출에서 해당 작업을 대괄호로 묶어야 할 것이다.

하지만 SwiftUI 컨텍스트에서, 내가 해야 할 일은 복사본을 변경하는 것뿐이다.

그리고 이러한 변경 사항은 수정된 컨텍스트에서 완료된 도면에만 영향을 미칩니다.

원래 문맥에서 그려진 그림은 영향을 받지 않는다.

우리 이미지에도 색을 더하자.

우리가 해결된 이미지로 할 수 있는 또 다른 한 가지는 기호가 그려지는 방식을 제어하기 위해 음영을 설정하는 것이다.

여기에 파란색을 설정하자.

그것은 내가 기대했던 것보다 조금 덜 밝아 보인다.

때때로 당신이 그림을 그릴 때, 올바른 혼합 모드는 큰 차이를 만들 수 있습니다.

혼합 모드는 여기에 있는 것처럼 색상이 어떻게 결합되는지, 특히 부분 불투명도를 제어합니다.

화면 혼합 모드를 설정해 봅시다.

그것은 색상이 항상 더 밝아지도록 결합한다.

그게 더 좋아 보여.

당신이 할 수 있는 더 많은 드로잉 작업이 있습니다.

가능한 모든 것을 보려면 GraphicsContext 유형을 확인하세요.

이제, 이것을 시뮬레이션처럼 만들려면, 실제로 움직여야 한다.

SwiftUI에는 시간이 지남에 따라 무언가를 바꿀 수 있는 몇 가지 도구가 있다.

애니메이션이 가장 일반적이며, 일반적으로 변경할 때 자동으로 발생합니다.

올해, 우리는 시간이 지남에 따라 무언가가 어떻게 변하는지 정확히 제어하고 싶을 때 TimelineView라는 새로운 낮은 수준의 도구를 소개합니다.

내가 바꾸고 싶은 뷰를 감싸서 TimelineView를 사용할 수 있습니다.

그리고 얼마나 자주 업데이트해야 하는지 알려주는 일정으로 구성할 수 있습니다.

타이머와 같은 것들에 대한 일정이 있지만, 우리는 애니메이션 일정을 사용하여 가능한 한 빨리 업데이트를 받을 것입니다.

디스플레이 링크에 익숙하다면, 이것은 매우 비슷하게 작동합니다.

그리고 네가 그렇지 않다면, 그건 완전히 괜찮아.

우리는 우리가 무엇을 보여줘야 하는지에 대한 정보를 제공하는 타임라인 컨텍스트를 통과한다.

나는 우리가 이미지를 애니메이션화하는 데 사용할 시간을 몇 초 안에 꺼낼 수 있다.

우리의 이미지를 회전 진동으로 움직이게 합시다.

그래서 나는 현재 시간으로부터 각도를 만들 것이다.

나머지를 사용하여 3초마다 반복합시다...

그리고 360도를 얻기 위해 120을 곱하세요.

그리고 우리는 코사인으로 X 값을 얻을 것이다.

아니면 사인이었어?

네가 삼각법을 기억하길 바라.

이제 그 값을 사용하여 오프셋을 변경합시다...

그리고 우리의 미리보기를 라이브로 보고 그것이 어떻게 보이는지 보세요.

좋아. 그들이 겹칠 때, 어떻게 더 밝아지는지 보세요?

그것은 직장에서 우리의 스크린 블렌드 모드이다.

다음으로, 상호 작용을 추가해 봅시다.

이전에, 우리는 개별 견해에 제스처를 추가하여 할 수 있는 몇 가지 상호 작용을 살펴보았다.

캔버스를 사용하는 것의 절충안 중 하나는 그 안의 개별 요소가 하나의 그림으로 결합된다는 것을 기억하세요.

그래서 예를 들어, 우리는 이러한 개별 이미지에 제스처를 첨부할 수 없었다.

그러나, 우리는 여전히 전체 보기에 제스처를 추가할 수 있다.

표시된 스파클의 수를 늘릴 수 있는 능력을 추가해 봅시다.

우리는 얼마나 많은 것을 보여줄지에 대한 주를 추가할 것이다.

그리고 두 개로 시작하자.

우리의 루프를 제어하기 위해 카운트를 사용합시다.

그런 다음 우리는 수를 늘리기 위해 TapGesture를 추가할 것입니다.

미리보기를 업데이트합시다.

그리고 이제 우리는 스파클을 추가하기 위해 탭할 수 있다.

캔버스 사용의 또 다른 중요한 측면은 단일 그래픽이기 때문에 접근성에 사용할 수 있는 콘텐츠에 대한 정보가 없다는 것입니다.

이것을 접근하기 위해, 우리는 표준 접근성 수정자를 사용하여 우리의 견해에 대한 정보를 추가할 것입니다.

그리고 고급 사례의 경우, 뷰에 대한 접근성 정보를 생성하는 데 사용할 임의의 SwiftUI 뷰 계층 구조를 지정할 수 있는 강력한 새로운 .accessibilityChildren 수정자가 있습니다.

사용 방법에 대한 자세한 내용은 "SwiftUI 접근성: Beyond the Basics"를 참조하십시오.

우리는 캔버스의 비교적 간단한 사용을 구축했지만, 훨씬 더 복잡한 사용을 지원하도록 설계되었으므로, 조금 더 양념을 합시다.

내 동료 중 한 명이 여기에 있는 것과 같은 방식으로 작동하는 시뮬레이션 코드를 작성했지만, 더 많은 요소가 더 흥미로운 일을 하고 있다.

나는 그가 나에게 보낸 파일을 가지고 있어. 나는 그냥 우리 보기에 붙여넣을 거야.

이 코드는 우리가 방금 했던 것과 같은 구조를 가지고 있다.

우리는 이제 모든 입자를 추적하는 시간이 지남에 따라 업데이트하는 수명이 긴 모델 객체를 가지고 있습니다.

우리는 콘텐츠를 애니메이션화하고 그릴 수 있는 동일한 타임라인뷰와 캔버스를 가지고 있습니다.

우리는 새로운 날짜로 모델을 업데이트하고, 화면 혼합 모드를 설정하고, 각 활성 입자에게 우리가 방금 가진 타원과 같은 방식으로 그리라고 말하고 있습니다.

그리고 마지막으로, 우리는 약간 더 복잡한 제스처로 동일한 수정자를 적용했습니다.

그래서 그게 어떻게 생겼는지 보자.

그것은 주기적으로 새로운 불꽃놀이를 일으키며, 우리는 또한 더 많은 폭발을 추가하기 위해 탭할 수 있다.

그리고 그들은 앱의 그라디언트의 색상과 함께 타원을 사용하여 만들어졌다.

캔버스에서 그리는 것의 또 다른 좋은 점은 watchOS, tvOS 및 macOS에서도 작동한다는 것입니다.

모든 SwiftUI 플랫폼에서 사용할 수 있습니다.

알았어. 우리는 앱을 끝냈어.

그리고 그 과정에서, 우리는 안전한 영역으로 작업하고 수정하는 방법, 콘텐츠가 그려지는 방식을 제어하기 위해 전경 스타일을 사용하는 방법, 흐림과 활기를 얻기 위해 재료를 사용하는 방법, 그리고 캔버스와 타임라인뷰를 사용하여 복잡한 애니메이션 그래픽을 구축했습니다.

나는 네가 앱에서 어떤 놀라운 그래픽을 만드는지 빨리 보고 싶어.

[음악].