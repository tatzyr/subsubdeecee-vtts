10182

♪ ♪

안녕.

저는 클라우드 파일 제공자 팀의 요하네스 포트만이며, macOS에서 파일 제공자를 보여주기 위해 왔습니다.

만약 당신이 사용자의 파일을 macOS와 동기화하는 클라우드 스토리지 공급업체라면, 당신은 올바른 이야기를 하고 있습니다.

소개 후, 우리는 동기화 파일과 관련된 사용자 흐름에 대해 이야기할 것입니다.

그런 다음 Xcode의 흐름 중 하나를 살펴보고 각 흐름에 대한 지원을 구현할 순서에 대해 논의할 것입니다.

우리는 추가적인 선택적 통합 지점과 다음 단계에 대한 간략한 개요를 가질 것입니다.

우선, 파일 제공자가 당신을 위해 무엇을 할 수 있는지에 대해 이야기해 봅시다.

파일 공급자 프레임워크를 사용하면 클라우드 스토리지를 macOS의 파일 시스템에 통합할 수 있습니다.

새로운 APFS 기능을 사용하여 사용자 파일과 폴더의 주문형 다운로드를 허용합니다.

API는 전적으로 사용자 공간에 있다.

우리는 macOS에서 커널 확장을 더 이상 사용하지 않으므로, syscalls를 가로채거나 필요에 따라 파일을 다운로드하기 위해 FUSE 또는 KAUTH에 의존하는 경우 이것은 당신에게 좋은 대안입니다.

업로드, 다운로드를 처리하고 원격으로 변경된 것을 알려주기만 하면 됩니다.

그 시스템은 지역적으로 무엇이 바뀌었는지 알려주고 나머지는 모두 처리할 것이다.

이 모든 기능은 시스템, 특히 파인더와 잘 통합되어 있다.

당신의 공급자는 사이드바에 나타날 것입니다.

파일 상태는 파인더에 표시되고 추적되며, UI와 몇 가지 사용자 정의 가능한 통합 지점이 있습니다.

당신은 시스템과 통합되는 앱 확장을 구현합니다.

그것의 수명 주기는 사용자 행동에 의해 주도된다.

처음에는 사용자가 클라우드 스토리지에서 액세스할 수 있는 파일 트리를 나타내는 도메인을 만듭니다.

시스템은 파인더 사이드바에서 해당 도메인을 노출하고 파일 시스템의 도메인에 대한 루트 디렉토리를 만듭니다.

이 시점에서, 실제 데이터는 장치에 없지만, 사용자는 이미 루트와 상호 작용을 시작할 수 있다.

이건 어떻게 작동해?

루트는 우리가 데이터리스 디렉토리라고 부르는 것이다.

그것은 APFS의 새로운 종류의 객체이며, 그것들을 인식하고 상호 작용하는 API가 있다.

하지만 더 중요한 것은, 데이터가 없는 객체는 준비되지 않은 프로세스에 대해 완전히 투명하다는 것이다.

읽기는 다운로드를 트리거하고, 파일은 읽기가 재개되기 전에 데이터가 없는 속성을 잃습니다.

이 프레젠테이션에서, 우리는 파일 제공자 프레임워크를 통해 데이터가 없는 파일을 읽을 때 호출되는 콜백을 어떻게 구현할 수 있는지 볼 것입니다.

동기화하고 실행하기 위해 몇 가지 사용자 흐름을 살펴봅시다.

우리는 동기화와 동기화를 모두 포함하는 네 가지 주요 흐름을 살펴볼 것이다.

각 흐름에서, 당신은 시스템이 새로운 데이터가 필요할 때마다 내선 번호를 호출하는 것을 보게 될 것입니다.

우리는 당신이 그 데이터를 가져오기 위해 클라우드 서버와 이야기할 수 있다는 것을 보여줄 것이며, 마지막으로 완료 핸들러에 전화하여 회신할 수 있습니다.

먼저, 우리는 데이터 없는 파일을 읽을 때 어떤 일이 일어나는지 살펴볼 것이다.

커널이 데이터리스 파일에 대한 읽기 액세스를 감지하면, 파일의 내용을 가져오기 위해 확장자가 호출되는 동안 syscall이 일시 중지됩니다.

확장 프로그램의 fetchContents 메소드가 호출됩니다.

일반적으로, 당신은 다운로드를 수행하기 위해 그것을 구현할 것입니다.

다운로드가 완료되면, 완료 핸들러를 호출합니다.

파일의 내용은 열린 파일 설명자를 무효화하지 않고 이전에 데이터가 없는 파일을 채우는 시스템에 전달됩니다.

그런 다음 시스템은 읽기 액세스를 일시 중지합니다.

이제 파일이 더 이상 데이터가 없기 때문에, 후속 읽기는 확장자를 포함할 필요가 없습니다.

디렉토리를 열거하는 것은 매우 유사하게 작동한다.

커널은 readdir 호출을 감지하고 일시 중지합니다.

그것은 그 디렉토리의 항목을 열거하기 위해 당신의 확장자를 호출합니다.

서버에서 이 항목의 메타데이터를 가져옵니다.

그리고 당신은 많은 항목으로 답장합니다.

열거는 페이지가 매겨졌다.

전체 항목 세트보다 적게 반품할 수 있으며, 시스템은 중단한 부분부터 열거할 것입니다.

모든 페이지가 열거되면, 시스템은 원래 호출을 통과할 수 있도록 허용할 것이다.

파일 케이스와 마찬가지로, 디렉토리가 열거되면, 후속 readdir 호출은 디스크의 내용을 사용하며 확장자를 포함할 필요가 없습니다.

하지만 그 내용이 원격으로 바뀌면 어떨까요?

음, 당신은 원격 변경을 시스템에 알려야 할 것입니다.

그게 어떻게 작동하는지 보자.

원격 변경이 있는 경우, 서버는 Mac에 푸시 알림을 보낼 수 있습니다.

그 푸시 알림에 응답하여, 당신은 특별한 열거자인 .workingSet에서 열거해야 하는 변경 사항이 있다는 것을 시스템에 알립니다.

시스템은 돌아서서 .workingSet에서 변경된 항목을 열거할 것이다.

syncAnchor라고 불리는 연속 토큰은 새로운 변경 사항만 열거하는 데 사용됩니다.

이 토큰은 당신의 확장에 의해 정의됩니다.

이 시스템은 마지막으로 열거된 syncAnchor를 추적한다.

enumerateChanges(from syncAnchor:) 메소드로 열거자를 호출합니다.

이에 대한 응답으로, 당신은 변경된 물품을 반품하고, 완료되면, 다음에 사용할 수 있는 새로운 syncAnchor를 주세요.

그 시스템은 비동기적으로 가서 사용자가 볼 수 있는 파일을 업데이트할 것이다.

우리는 그 과정에서 로컬 변경 사항이 손실되지 않도록 하는 APFS 비교 및 스왑 기능을 사용합니다.

게다가, 이 시스템은 응용 프로그램과 조정하기 위해 파일 조정 및 기타 자문 잠금 메커니즘과 통합됩니다.

이 세 가지 메커니즘을 통해, 우리는 클라우드에서 파일을 동기화하고 원격 변경 시 동기화를 유지할 수 있습니다.

마지막 흐름은 로컬 변경 사항을 클라우드에 동기화하는 것을 다룬다.

시스템은 로컬 항목이 변경되었을 때 감지하고 확장에서 modifyItem 메소드를 호출하여 변경된 정확한 필드 집합을 전달합니다.

그것은 낮은 수준의 이벤트를 동기화에 의미 있는 이벤트로 집계한다.

예를 들어, 커널은 안전한 저장을 감지하고 항목 식별자를 새 파일 ID로 투명하게 다시 매핑합니다.

일관된 패키지 수준 변경 사항을 요청하고 제시하면 시스템은 패키지 파일도 압축할 것입니다.

modifyItem 호출에 대한 응답으로, 당신은 아이템 서버 측의 상태를 업데이트할 것입니다.

파일의 내용이 변경된 경우, 시스템은 변경된 파일의 복제본을 건네줄 것이므로 추가 변경이 있을 경우에도 일관된 버전을 업로드할 수 있습니다.

완료되면, 당신은 완료 핸들러를 호출합니다.

완료 핸들러는 항목의 버전 식별자를 업데이트하고 확장에 대한 변경 사항의 전달을 확인하는 데 사용됩니다.

완료 핸들러는 또한 항목의 최종 상태를 매개 변수로 취한다.

클라우드에서 항목을 업데이트하면 예를 들어 원격 변경과 충돌하는 경우 상태가 변경될 수 있습니다.

최종 상태를 다시 통과하기 때문에, 시스템은 클라우드의 진실과 일치하도록 항목의 로컬 상태를 업데이트할 수 있습니다.

다섯 번째 흐름은 퇴거이다.

이 시스템은 디스크 공간이 긴급하게 필요할 때 파일 제공자 확장자를 포함하지 않고 로컬 파일을 자동으로 퇴거시킬 것입니다.

예를 들어, 사용자가 비디오를 녹화하거나 소프트웨어 업데이트를 다운로드할 때 발생할 수 있습니다.

이 시스템은 새 파일을 작성하는 데 필요한 디스크 공간을 확보하는 데 필요한 가장 최근에 사용된 최소 파일 세트를 제거할 것이다.

전환을 검토해 봅시다.

퇴거는 로컬 파일을 데이터 없는 파일로 만들고, 다운로드는 데이터 없는 파일을 로컬 파일로 바꾼다.

파일은 원격으로 생성되거나 로컬로 생성되지 않은 경우 데이터 없이 시작할 수 있습니다.

하지만 모든 파일이 쫓겨날 수 있는 것은 아니다.

시스템은 업로드된 것으로 보고한 파일만 제거하여 다시 다운로드할 수 있습니다.

그래서 실제로 두 종류의 로컬 파일이 있습니다: 업로드된 파일과 업로드되지 않은 파일.

로컬 편집 후, 새 버전의 파일을 업로드해야 하므로, 우리는 되돌릴 수 없는 상태로 돌아왔습니다.

지금까지 이 프레젠테이션에서, 우리는 액세스 시 파일을 다운로드하고 로컬 편집 후 파일을 업로드하기 위해 시스템에서 파일 공급자 확장자를 호출하는 방법을 보았습니다.

디스크 압력으로 인한 퇴거에는 관여하지 않지만, 연장에서 퇴거를 유발하거나 방지하는 방법이 있습니다.

이것은 많은 이론이었다.

실제로 흐름 중 하나를 살펴봅시다.

우리는 작은 로컬 파일 서버를 실행하고 해당 서버에 대해 작동하는 파일 공급자 확장자를 포함하는 앱을 작성했습니다.

그것은 FruitBasket이라고 불린다.

저는 이미 그 서버에 로그인했기 때문에, 여기 사이드바에 루트 폴더에 대한 항목이 있습니다.

나는 또한 시스템이 그 폴더의 항목에 대해 데이터 없는 항목을 만들게 만든 루트 폴더를 선택했다.

파일 이름 옆에 있는 클라우드 다운로드 아이콘에서 항목이 데이터가 없다는 것을 알 수 있습니다.

우리는 파일을 읽기 위해 명령줄에서 'cat'을 사용할 것이다.

파일이 데이터가 없기 때문에, 이것은 우리의 확장자에서 콘텐츠 가져오기를 일으킬 것이다.

저는 이미 Xcode의 확장 프로그램에 첨부했고 이 콘텐츠 가져오기를 가로채기 위해 중단점을 설정했습니다.

'고양이'가 달리고 있고, 우리의 중단점이 맞았다.

콘텐츠 가져오기 완료를 차단하고 있기 때문에 터미널 창의 읽기도 차단됩니다.

파인더 창에서 클라우드 아이콘이 진행률 표시기로 대체되었다는 점에 유의하십시오.

그 시스템은 다운로드 상태에 대한 일관된 견해를 가지고 있다.

물론, 우리는 실제로 다운로드가 바쁘기보다는 디버거에서 차단되어 있기 때문에, 진행 상황이 업데이트되지 않습니다.

계속하자.

나는 우리가 완료 핸들러를 부르기 직전에 두 번째 중단점을 설정했다.

현재, 우리 공급자는 파일의 내용을 디스크의 로컬 URL로 다운로드했습니다.

우리가 완료 핸들러를 호출하면, 시스템은 사용자가 볼 수 있는 파일의 내용을 우리가 다운로드한 내용과 바꿀 것이다.

Xcode에서 계속하여 시스템 차단을 해제합시다.

파인더의 상태는 파일을 로컬로 표시하기 위해 업데이트되며, 고양이 프로세스가 차단되었다는 읽기가 성공합니다.

나는 여전히 중단점을 설정했지만, 이제 파일이 로컬이기 때문에 중단점을 누르지 않고 'cat'을 다시 실행할 수 있다.

그 읽기는 일반 로컬 파일에 반대하고 있으며 우리의 확장자를 포함하지 않습니다.

물론, 이것은 샘플 파일 제공자의 기능 세트의 작은 부분일 뿐입니다.

우리는 API의 전체 기능 세트를 다루었고, 이 세션의 일환으로 소스 코드를 게시하고 있습니다.

우리가 이야기한 흐름을 구현하는 방법에 대해 이야기해 봅시다.

우선, 우리는 시스템에 동기화할 준비가 되었다고 말하고 싶을 것이다.

이것은 파인더의 사이드바에 항목이 표시될 것이다.

우리는 이 항목들을 도메인이라고 부르며, 보통 클라우드 서버의 로그인 세션에 해당합니다.

각 도메인에는 고유 식별자가 있으며, 이를 표시하려면 새 인스턴스를 만들고 관리자 객체를 통해 추가합니다.

도메인을 제거할 수도 있습니다.

당신은 보통 사용자가 로그아웃할 때 이것을 할 것이지만, 초기 개발과 테스트 중에도 유용할 것입니다.

도메인이 파인더에 표시되면, 시스템은 항목으로 이동하자마자 항목의 열거를 요청할 것입니다.

그럼 다음에 그걸 실행하자.

여기서 우리의 첫 번째 단계는 아이템 클래스를 구현하는 것이다.

그 사례는 우리가 열거할 개별 항목을 나타낸다.

그런 다음 우리는 시스템이 요청할 때 항목으로 시스템을 호출하는 열거자를 구현합니다.

이 시점에서, 우리는 사이드바 항목으로 이동하여 디렉토리를 볼 수 있습니다.

물론, 그 디렉토리의 모든 파일은 데이터가 없을 것이다.

콘텐츠 가져오기를 구현하여 그것을 바꾸자.

fetchContents 메소드는 데이터가 없는 파일 중 하나를 열 때 시스템에 의해 호출됩니다.

우리의 임무는 파일 내용을 디스크의 위치에 다운로드한 다음, 그 위치의 URL로 완료 핸들러를 호출하는 것입니다.

시스템은 내용을 사용하여 데이터 없는 파일을 채우고 우리를 위해 정리할 것이다.

디렉토리 구조를 동기화할 수 있도록, 우리는 다른 유형의 열거자를 구현할 것이다.

이것은 원격 변경 사항을 동기화한다.

시스템은 동기화 앵커를 얻기 위해 currentSyncAnchor 메서드를 먼저 호출합니다.

데이터베이스의 변경 커서를 설명하는 데이터 객체를 반환합니다.

무언가가 바뀌었다는 신호를 보낼 때마다, 시스템은 당신이 제공한 마지막 앵커 이후 변경을 요청할 것입니다.

그런 다음 변경 사항을 반환하고 마침내 새로운 앵커를 반환할 수 있습니다.

마지막 단계는 변경 사항을 동기화하는 것이다.

시스템이 로컬 파일의 변경 사항을 감지하면, 기존 항목을 생성, 수정 또는 삭제하는 세 가지 방법 중 하나를 호출합니다.

우리는 만드는 방법을 빠르게 살펴볼 것이다.

시스템은 당신에게 만들라고 요청하는 새로운 아이템을 건네줍니다.

이것은 시스템 항목이지만, 당신의 항목과 동일한 프로토콜을 따릅니다.

그 시스템은 또한 당신에게 그 항목에 관심이 있는 일련의 필드를 줄 것이다.

예를 들어, 그 항목에는 확장된 속성이 첨부되어 있을 수도 있고 그렇지 않을 수도 있으며, 그것을 설명할 필드가 있다.

콘텐츠 필드가 설정되면, 시스템은 당신에게 내용과 함께 파일 URL을 전달할 것입니다.

폴더나 심볼릭 링크를 설명하는 항목에는 내용이 없습니다.

당신의 임무는 새로운 로컬 항목의 데이터를 서버에 업로드한 다음 결과 원격 항목으로 완료 핸들러를 호출하는 것입니다.

그리고 그게 다야.

이 시점에서, macOS에 주문형 파일을 제공하는 기능 파일 공급자가 있으며, 클라우드에 대한 로컬 변경 사항과 Mac에 대한 원격 변경 사항을 전파합니다.

파일 제공자 프레임워크에는 시스템과의 더 정밀한 통합을 허용하는 많은 추가 옵션 API가 있습니다.

한 번 보자.

아이콘 장식은 파인더에서 항목을 시각적으로 장식하는 데 사용할 수 있습니다.

파일 아이콘에 배지를 부여하거나, 폴더를 엠보스하거나, 공유 상태를 표시할 수 있습니다.

앱에서 선언된 UTType을 통해 장식을 위한 사용자 지정 아트워크를 제공합니다.

상황에 맞는 메뉴 작업을 통해 사용자는 상황에 맞는 메뉴를 통해 파일에 대한 사용자 지정 작업을 실행할 수 있습니다.

UI와 비UI 변형이 있다.

확장자의 Info.plist에 선언된 NSPredicates로 이러한 작업이 적용되는 파일을 정의할 수 있습니다.

비행 전 경고를 사용하면 의도하지 않은 결과를 초래할 수 있는 조치를 취하기 전에 사용자에게 경고할 수 있습니다.

경고 UI와 경고를 활성화하기 위한 기준은 Info.plist에도 구성되어 있습니다.

그래서 네 다음 단계는 뭐야?

음, 우선, 세션의 샘플 코드를 다운로드할 수 있습니다.

그것은 매우 포괄적이며, 당신에게 많은 조언을 줄 것입니다.

새로운 확장을 위해 기존 앱에 대상을 추가하세요.

당신이 가는 데 도움이 될 Xcode 템플릿이 있습니다.

거기에서, 당신이 해야 할 일은 우리가 논의한 순서대로 메소드 스텁을 구현하는 것뿐이며, 당신은 곧 실행될 것입니다.

이 세션을 봐주셔서 감사합니다.

우리는 macOS에서 당신의 파일 제공자 확장자를 보기를 기대합니다.