10149

♪ 베이스 음악 연주 ♪

♪

후안 로드리게스 쿠엘라: 안녕하세요, WWDC에 오신 것을 환영합니다.

제 이름은 후안 로드리게스 쿠엘라이고, 저는 애플의 GPU 컴파일러 엔지니어입니다.

이 세션에서, 우리는 메탈 레이 트레이싱 API를 향상시키기 위해 올해 추가한 새로운 기능에 대해 이야기할 것입니다.

하지만 먼저, 레이 트레이싱에 대한 간략한 요약을 해봅시다.

광선 추적 응용 프로그램은 광선이 장면과 상호 작용할 때 취하는 경로를 추적하는 것을 기반으로 한다.

레이 트레이싱은 오디오, 물리 시뮬레이션 및 AI와 같은 많은 영역에 적용되지만, 주요 응용 프로그램 중 하나는 사실적인 렌더링이다.

렌더링 응용 프로그램에서 레이 트레이싱은 반사, 부드러운 그림자 및 간접 조명과 같은 효과를 시뮬레이션할 수 있는 개별 광선을 모델링하는 데 사용됩니다.

그것은 레이 트레이싱의 일반적인 정의일 뿐이다.

그것에 대한 메탈의 접근 방식에 대해 이야기해 봅시다.

우리는 컴퓨팅 커널로 시작한다.

우리의 커널에서, 우리는 장면으로 방출되는 광선을 생성한다.

그런 다음 우리는 인터섹터와 가속 구조로 장면의 기하학에 대한 교차로를 위해 그 광선을 테스트합니다.

각 교차점은 표면에서 튀는 빛을 나타낸다; 얼마나 많은 빛이 튀고 어떤 방향으로 물체가 어떻게 생겼는지 결정한다.

그런 다음 각 교차로의 색상을 계산하고 이미지를 업데이트합니다.

이 과정은 셰이딩이라고 불리며 추가 광선을 생성할 수 있으며, 그 광선은 또한 교차로에 대해 테스트됩니다.

우리는 장면 주변에서 튀는 빛을 시뮬레이션하고 싶은 만큼 그 과정을 반복합니다.

올해, 우리는 세 가지 주요 영역에 새로운 기능을 집중했다.

먼저, 레이 트레이싱과 렌더링을 혼합할 수 있는 렌더링 파이프라인에 레이 트레이싱 지원을 어떻게 추가했는지에 대해 이야기하겠습니다.

그런 다음 유용성과 휴대성에 중점을 둔 새로운 기능을 소개하겠습니다.

이러한 기능은 금속 광선 추적 API의 사용을 용이하게 할 것이다.

마지막으로, 저는 당신이 더 현실적인 콘텐츠를 만드는 데 도움이 될 올해 추가한 프로덕션 렌더링 기능을 다룰 것입니다.

렌더링 파이프라인에서 레이 트레이싱부터 시작합시다.

단일 렌더링 패스가 있는 렌더링의 기본 사례를 고려해 봅시다.

렌더링 파이프라인의 레이 트레이싱에 대한 새로운 지원을 통해 렌더링에 레이 트레이싱을 매우 쉽게 추가할 수 있습니다.

그러나, 이 지원이 없다면, 작년의 메탈 레이 트레이싱 API로 이 렌더링에 레이 트레이싱을 추가하려면, 우리는 컴퓨팅 패스를 추가해야 합니다.

렌더링된 이미지를 보강하기 위해 렌더링 후 추가하는 것으로 시작합시다.

이 추가 컴퓨팅 패스를 추가하는 것은 컴퓨팅 패스가 레이 트레이싱에 사용할 수 있도록 메모리에 더 많은 출력을 쓰는 것을 의미합니다.

이제, 픽셀당 섀도잉과 같은 값을 계산하기 위해 렌더링 패스 중간에 레이 트레이싱을 사용하고 싶다면 어떨까요?

이것은 우리가 렌더링을 분할하고 컴퓨팅 패스를 도입해야 한다는 것을 의미한다.

이것이 무엇을 의미하는지 더 생각해보면, 우리는 픽셀 위치와 노멀을 레이 트레이싱에 대한 입력으로 메모리에 기록한 다음, 교차 결과를 다시 읽어야 합니다. 아마도 여러 번.

하지만 렌더링 단계에서 레이 트레이싱에 대한 새로운 지원으로, 우리는 렌더링 패스를 떠날 필요가 없으며 출력을 메모리에 쓰기만 하면 됩니다.

우리가 새로운 API를 어떻게 사용하는지 봅시다.

레이 트레이싱을 위한 렌더링 파이프라인을 준비하는 것은 컴퓨팅 파이프라인과 비슷하다.

가속 구조를 구축하고 사용자 지정 교차 기능을 정의하는 것으로 시작합니다.

사용자 지정 교차로를 지원하기 위해, 우리는 교차로 함수 테이블이 필요하며 교차로 함수로 채워야 합니다.

이 부분은 작년의 API와 비교했을 때 약간의 차이가 있다.

우리가 그걸 어떻게 할 수 있는지 살펴봅시다.

몇 가지 간단한 교차 함수를 고려해 봅시다.

구, 원뿔 또는 토러스와 같은 물체를 분석적으로 교차할 수 있는 몇 가지 기능이 있습니다.

우리가 파이프라인을 만들 때, 우리는 이 기능들을 우리가 호출할 수 있는 연결된 함수로 추가한다.

이 경우, 우리는 그것들을 파이프라인의 조각 단계에 추가하고 있다.

함수를 사용하려면 파이프라인 상태와 단계에서 교차 함수 테이블을 만들어야 합니다.

테이블이 있으면, 파이프라인 상태와 스테이지에서 함수 핸들을 만들고 테이블을 채울 수 있습니다.

프래그먼트 단계의 기능을 지정하면 작년에 도입한 linkedFunctions 객체를 재사용합니다.

각 단계에는 렌더링 파이프라인 설명자에 대한 자체 연결 기능 세트가 있습니다.

교차 함수 테이블을 만드는 것은 컴퓨팅 파이프라인을 위해 수행될 때와 거의 같다.

유일한 변화는 무대 논쟁의 추가이다.

테이블을 채우기 위해, 우리는 함수 핸들을 만든다.

다시 말하지만, 핸들은 단계에 따라 다르기 때문에 핸들을 요청할 때 단계를 지정해야 합니다.

함수 핸들이 있으면, 함수 테이블에 삽입하기만 하면 됩니다.

그리고 그것이 렌더링 파이프라인에서 함수 테이블을 준비하기 위해 해야 할 전부입니다.

이제 우리는 교차하기 위해 지금까지 구축한 모든 것을 사용해야 한다.

실제 사용은 간단하다.

accelerationStructure와 교차 함수 테이블은 모두 렌더링 인코더의 버퍼 인덱스에 바인딩됩니다.

그런 다음 셰이더는 이러한 리소스를 사용하여 컴퓨팅 커널에서와 같은 방식으로 인터섹터와 광선을 교차할 수 있습니다.

레이 트레이싱을 위한 파이프라인을 준비하는 방법에 대한 자세한 내용은 작년 프레젠테이션에서 확인할 수 있습니다.

그 강연에서, 당신은 가속 구조를 구축하고, 함수 테이블을 만들고, 셰이딩 언어에서 인터섹터를 사용하는 것에 대해 배우게 될 것입니다.

렌더링 파이프라인의 레이 트레이싱 지원을 통해, 우리는 단일 렌더링 패스 내에 레이 트레이싱을 추가하고, 하이브리드 렌더링에서 레이 트레이싱과 래스터화를 혼합하고, Apple Silicon의 타일 기능과 같은 최적화를 활용하는 것과 같은 더 많은 기회를 위한 문을 열고 있습니다.

사실, 우리는 곧 WWDC 2019의 "Modern Rendering in Metal" 세션에서 시연한 샘플 앱에 레이 트레이싱을 추가할 것입니다.

렌더링 파이프라인의 레이 트레이싱을 통해 타일 함수를 사용하여 타일 메모리에 모든 것을 유지하도록 코드를 업데이트할 수 있습니다.

이에 대한 자세한 내용은 올해의 "메탈 레이 트레이싱으로 하이브리드 렌더링 탐색" 프레젠테이션을 참조하십시오.

다음으로, 메탈 레이 트레이싱 API의 유용성과 이식성을 개선하기 위해 올해 추가한 새로운 기능을 소개하고 싶습니다.

이러한 기능은 금속 레이 트레이싱의 더 간단한 사용을 제공할 뿐만 아니라, 다른 레이 트레이싱 API의 이식성도 제공합니다.

이러한 새로운 기능 중 하나는 교차 쿼리이다.

교차로 쿼리를 통해 교차로 프로세스를 더 잘 제어할 수 있습니다.

교차로 쿼리는 인터섹터가 오버헤드를 만들 수 있는 간단한 사용 사례를 목표로 한다.

인라인 사용자 지정 교차로 테스트를 수행할 수 있는 옵션을 제공하는 가속 구조를 가로지르는 새로운 방법입니다.

작년의 인터섹터를 사용하여 현재 사용자 지정 교차로를 어떻게 처리하는지 살펴봅시다.

작년의 레이 트레이싱과 금속 프레젠테이션의 알파 테스트 예로 돌아가서, 우리는 여기 체인과 나뭇잎에서 볼 수 있듯이 알파 테스트가 장면에 많은 기하학적 디테일을 추가하는 데 어떻게 사용되는지 시연했습니다.

우리는 또한 삼각형 교차 함수를 사용하여 인터섹터를 사용자 정의하여 알파 테스트를 구현하는 것이 얼마나 쉬운지 배웠습니다.

이 삼각형 교차 함수 내부의 논리는 광선이 가속 구조를 통과할 때 교차를 받아들이거나 거부하는 역할을 한다.

이 경우, 테스트 로직은 첫 번째 교차로를 거부할 것이지만, 불투명한 표면이 교차되었기 때문에 두 번째 교차로를 받아들일 것이다.

교차 함수가 어떻게 사용되는지 봅시다.

Intersector를 사용할 때, intersect()를 호출할 때, 우리는 교차로를 찾고 intersection_result를 채우기 위해 가속 구조를 횡단하기 시작합니다.

인터섹터 내에서, 교차 함수는 잠재적인 교차가 발견될 때마다 호출된다.

그리고 교차점은 교차점 함수 논리에 따라 받아들여지거나 거부된다.

이것은 성능이 뛰어나고 편리하기 때문에 인터섹터를 사용하는 훌륭한 프로그래밍 모델이지만, 새로운 교차 기능을 만들고 파이프라인에 연결해야 합니다.

알파 테스트 논리의 경우와 마찬가지로, 교차 함수 내부의 논리가 몇 줄의 코드에 불과한 경우가 있을 수 있습니다.

이것은 알파 테스트를 하기 위한 논리를 포함하는 교차 함수이다.

교차 쿼리를 통해, 우리는 이 교차 함수 없이 이 논리를 인라인으로 배치할 수 있습니다.

이게 방법이야.

교차 쿼리를 사용하면 교차 프로세스를 시작할 때 광선이 가속 구조를 통과하고 쿼리 객체는 횡단 상태와 결과를 포함합니다.

광선이 사용자 지정 기본 또는 비투명 삼각형과 교차할 때마다, 교차로 후보를 평가할 수 있도록 제어가 셰이더로 반환됩니다.

현재 후보자가 사용자 지정 교차로 논리를 통과하면, 현재 커밋된 교차로를 업데이트한 다음 교차로 프로세스를 계속하도록 커밋합니다.

반면에, 후보자가 사용자 지정 교차 논리에 실패하면, 그냥 무시하고 계속할 수 있습니다.

교차 쿼리를 사용하여 알파 테스트를 수행하는 코드를 보여드리겠습니다.

먼저, 당신은 횡단을 시작합니다.

우리는 모든 후보 교차로를 평가하기 위해 옆에서 반복한다는 점에 유의하세요.

둘째, 후보자 유형을 확인하여 각 후보자를 평가합니다.

알파 테스트 예제의 경우, 삼각형 유형의 교차점에 관심이 있습니다.

유형을 확인한 후, 후보자에 대한 교차점 정보를 쿼리하고 싶을 것입니다.

우리는 현재 인라인된 알파 테스트 로직에 필요한 정보에 대한 세 가지 쿼리를 수행합니다.

마지막으로, 후보 교차로가 알파 테스트를 통과하면, 현재 커밋된 교차로가 되도록 커밋할 것입니다.

지금까지, 당신은 후보 교차로를 평가하는 전체 가속 구조를 통과하고 알파 테스트 논리를 통과한 교차로를 커밋했습니다.

이제, 셰이딩을 하기 위해 커밋된 교차로 정보를 쿼리해야 합니다.

먼저, 커밋된 유형을 쿼리할 것입니다.

후보 교차로 중 어느 것도 커밋된 교차로가 되기 위한 조건을 충족하지 못했다면, 커밋된 유형은 없음이 될 것이며, 이는 현재 광선을 놓쳤다는 것을 의미합니다.

반면에, 커밋된 교차로가 있다면, 교차로 유형에 적용 가능한 교차로에 대한 정보를 쿼리한 다음 셰이딩에 사용하고 싶을 것입니다.

그것이 교차 쿼리를 사용하여 알파 테스트를 수행하는 데 필요한 모든 코드입니다.

교차 쿼리의 도입과 파이프라인을 렌더링하기 위한 인터섹터의 도입으로, 우리는 당신에게 당신의 앱에 메탈 레이 트레이싱을 도입할 수 있는 더 많은 기회를 제공하고 있습니다.

인터섹터 객체와 인터섹터 쿼리 중에서 선택할 때 고려해야 할 몇 가지 사항이 있습니다.

컴퓨팅에서 인터섹터를 사용하고 해당 코드를 포팅할 계획과 같은 기존 코드가 있는지 고려하는 것으로 시작하세요.

다른 API의 기존 쿼리 코드가 있다면, 교차 쿼리는 해당 코드를 이식하는 데 도움이 될 수 있습니다.

다음으로, 당신은 사용자 지정 교차로를 처리하는 복잡성을 가지고 있습니다.

인터섹터는 교차 함수와 테이블이 필요하며, 교차 쿼리를 사용하여 사용자 지정 교차를 직접 처리하는 것이 더 쉬울 수 있습니다.

마지막 질문은 공연이다.

더 간단한 경우, 교차 쿼리는 레이 트레이싱을 위한 파이프라인을 구축할 때 오버헤드를 피할 수 있지만, 사용자 지정 교차 처리는 횡단 중에 코드로 돌아가야 하며, 이는 사용 사례에 따라 성능에 영향을 미칠 수 있습니다.

또한, 여러 쿼리 객체를 사용하려면 더 많은 메모리가 필요할 것이다.

반면에, 인터섹터는 모든 교차 작업을 캡슐화함으로써 더 복잡한 사례를 지원할 수 있다.

기회가 있다면, 두 솔루션의 성능을 비교하는 것이 좋습니다.

그것은 모두 교차로 쿼리에 관한 것이다.

이제 다른 새로운 기능으로 넘어가자.

우리가 이야기할 다음 두 가지 기능은 사용자 인스턴스 ID와 인스턴스 변환입니다.

이러한 기능은 가속 구조에 더 많은 정보를 추가하고 이미 있는 더 많은 데이터에 액세스하는 데 도움이 될 것입니다.

이것이 우리가 이것들이 정말 유용한 기능이라고 생각하는 이유입니다.

작년 프레젠테이션의 샘플 코드를 되돌아보면, 커널 박스의 여러 인스턴스가 있습니다.

이 아래에는 인스턴스에 도달할 때까지 분기하는 노드 세트가 있는 인스턴스 가속 구조가 있습니다.

이 사례들 중 두 개를 보면, 그것들은 인스턴스 가속 구조의 가장 낮은 수준에 있다.

현재, 이러한 인스턴스 중 하나를 교차할 때, 교차 결과에서 시스템의 인스턴스 ID만 얻을 수 있습니다.

이것으로, 당신은 당신만의 데이터 테이블을 유지할 수 있지만, 우리가 당신을 돕기 위해 가속 구조에 노출할 수 있는 데이터가 있습니다.

먼저 사용자 정의 인스턴스 ID에 대해 이야기해 봅시다.

이 기능을 사용하면 각 인스턴스에 대한 사용자 지정 32비트 값을 지정한 다음 교차 결과의 일부로 이 값을 얻을 수 있습니다.

이것은 자신의 데이터 구조에 인덱싱하는 데 정말 유용하지만, 사용자 지정 데이터를 인코딩하는 데에도 사용할 수 있습니다.

예를 들어, 여기서 우리는 사용자 ID를 사용하여 각 인스턴스에 대한 사용자 지정 색상을 인코딩하고 있습니다.

추가 자료 정보를 찾아볼 필요 없이 더 간단한 반영을 위해 이것을 사용할 수 있습니다.

이것은 단지 하나의 예일 뿐이지만, 기회는 무궁무진하다.

인스턴스당 재료 ID 또는 인스턴스당 플래그와 같은 것들을 어떻게 인코딩하고 싶은지 알 수 있습니다.

우리는 이러한 ID를 지정하는 데 사용되는 인스턴스 설명자 유형의 확장 버전을 만들었습니다.

인스턴스 가속 구조 설명자에서 사용하는 설명자 유형을 지정해야 합니다.

셰이딩 언어에서, 현재 사용자 인스턴스 ID의 값은 인스턴스 태그와 교차 함수의 입력으로 사용할 수 있습니다.

교차 후 값을 얻기 위해, 인터섹터 객체를 사용할 때 교차 결과에서 사용자 정의 인스턴스 ID를 사용할 수 있습니다.

그리고 교차 쿼리 객체를 사용할 때, 후보와 커밋된 교차 모두에 대한 사용자 정의 인스턴스 ID에 액세스하는 해당 쿼리가 있습니다.

사용자 인스턴스 ID와 마찬가지로, 우리는 당신의 인스턴스 변환 매트릭스에 접근하기 위한 지원을 추가했습니다.

이 데이터는 이미 인스턴스 설명자에 명시되어 있으며, 가속 구조에 저장됩니다.

올해, 우리는 셰이딩 언어에서 이러한 매트릭스를 노출시켰다.

인스탠싱 및 world_space_data 태그를 적용할 때 교차 함수에서 인스턴스 변환에 액세스할 수 있습니다.

마찬가지로, 인스턴스 변환은 인스턴스와 world_space_data 태그가 있는 인터섹터를 사용할 때 교차 결과에서 제공됩니다.

인스탠딩 태그와 교차점 쿼리를 사용할 때, 후보와 커밋된 교차점 모두에 대한 인스턴스 변환에 액세스하기 위한 해당 쿼리가 있습니다.

요약하자면, 올해 우리는 세 가지 새로운 기능을 도입하여 금속 광선 추적 API의 유용성과 휴대성을 개선하고 있습니다.

교차로 쿼리는 교차로 프로세스에 대한 더 많은 제어를 제공하는 인터섹터의 대안으로 제공됩니다.

그리고 사용자 인스턴스 ID와 인스턴스 변환 기능의 도입으로, 우리는 코드에서 외부 매핑을 처리하는 대신 가속 구조에서 데이터에 액세스할 수 있는 기능을 제공하고 있습니다.

또한, 이 세 가지 기능은 다른 레이 트레이싱 API의 이식성을 제공하여 크로스 플랫폼 개발을 더 쉽게 만든다.

지금까지 세션에서, 우리는 렌더링 파이프라인의 레이 트레이싱에 대한 새로운 지원과 올해 추가한 다양한 유용성과 이식성 기능에 대해 이야기했습니다.

이제, 프로덕션 렌더링을 향상시키기 위해 우리가 도입하고 있는 기능을 보여드리겠습니다.

작년에 메탈 레이 트레이싱 API가 도입된 이후로, 사람들은 놀라운 고품질 콘텐츠를 렌더링하기 위해 그것을 사용해 왔다.

올해, 우리는 더 나은 콘텐츠를 렌더링할 수 있도록 두 가지 새로운 기능을 추가했습니다.

확장된 한도부터 시작합시다.

메탈 레이 트레이싱 API를 출시한 이후, 일부 사용자는 특히 생산 규모의 사용 사례에서 가속 구조의 내부 한계에 도달하기 시작했습니다.

그래서 우리는 더 큰 장면을 지원하기 위해 확장 제한 모드에 대한 지원을 추가하고 있습니다.

작년에, 우리는 전형적인 장면 크기와 성능을 선호하기 위해 가속 구조 크기의 균형을 맞추기 위해 이러한 한계를 선택했습니다.

이 기능을 켜는 데는 잠재적인 성능 절충점이 있으므로, 어떤 모드가 애플리케이션에 가장 적합한지 결정해야 합니다.

확장 제한 모드는 프리미티브, 기하학, 인스턴스의 수와 인스턴스를 필터링하는 데 사용되는 마스크의 크기에 대한 제한을 증가시킨다.

그것을 켜려면, 가속 구조를 구축할 때 먼저 확장 제한 모드를 지정하십시오.

그런 다음 셰이딩 언어의 intersector 객체에 extended_limits 태그를 지정하십시오.

그게 네가 확장된 한도를 켜기 위해 해야 할 전부야!

다음으로, 움직임에 대해 이야기해 봅시다.

컴퓨터 그래픽에서, 우리는 종종 카메라 노출이 즉각적이라고 가정한다.

그러나, 실생활에서, 카메라 노출은 0이 아닌 기간 동안 지속된다.

그 시간 동안 물체가 카메라에 상대적으로 움직이면, 이미지에서 흐릿하게 보일 것이다.

이 극단적인 예에서, 중앙에 있는 사람은 다른 모든 사람들이 움직이는 동안 전체 노출 동안 가만히 서 있었고, 그들을 흐리게 만들었다.

이 효과는 컴퓨터로 생성된 이미지를 더 사실적으로 보이게 하는 데 큰 도움이 될 수 있다.

이 예에서, 구체는 여러 프레임에 걸쳐 애니메이션되지만, 각 프레임은 여전히 즉각적인 노출로 인해 고르지 못한 애니메이션이 발생한다.

모션 API를 사용하여, 우리는 0이 아닌 시간 동안 지속되는 카메라 노출을 시뮬레이션할 수 있습니다.

이것은 더 매끄럽고 더 사실적으로 보이는 애니메이션을 만든다.

비디오를 고정하면, 구의 경계가 실제 카메라처럼 움직임의 방향으로 흐려지는 것을 볼 수 있습니다.

게임과 같은 실시간 애플리케이션은 종종 화면 공간에서 이 효과를 근사한다.

하지만 레이 트레이싱을 통해 물리적으로 정확한 모션 블러를 시뮬레이션할 수 있으며, 이는 그림자와 반사와 같은 간접적인 효과까지 확장됩니다.

모션 블러 버전이 어떻게 렌더링되었는지 살펴봅시다.

모션 블러는 레이 트레이싱의 간단한 확장이다.

대부분의 광선 추적 응용 프로그램은 이미 간접 조명을 위한 들어오는 빛 방향과 같은 물리적 차원을 무작위로 샘플링한다.

모션 블러를 추가하기 위해, 우리는 각 광선에 대한 임의의 시간을 선택할 수 있습니다.

금속은 각 광선과 관련된 시점과 일치하도록 장면과 교차할 것이다.

예를 들어, 이 광선은 이런 장면을 보게 될 것이다.

또 다른 레이는 이런 장면을 볼 것이다.

우리가 점점 더 많은 샘플을 축적함에 따라, 우리는 움직임이 흐릿한 이미지에 수렴하기 시작할 것이다.

사용자 지정 교차 함수를 사용하여 오늘 이미 이것을 구현할 수 있습니다.

전체 노출에 걸쳐 각 프리미티브의 경계 상자를 계산한 다음 이 경계 상자를 사용하여 가속 구조를 구축할 수 있습니다.

그러나, 이것은 비효율적일 것이다; 경계 상자는 너무 커서 일부 광선은 실제로 교차하지 않을 원시인과의 교차점을 확인해야 할 것이다.

대신, 우리는 이와 같은 케이스를 효율적으로 처리하도록 설계된 모션 블러에 대한 메탈의 내장 지원을 사용할 수 있습니다.

우리가 해야 할 첫 번째 일은 메탈 셰이딩 언어 코드의 각 광선과 임의의 시간을 연관시키는 것이다.

우리는 노출 간격 내에서 임의의 시간을 생성하는 것으로 시작한 다음, 그것을 인터섹터에 전달합니다.

다음으로 우리가 해야 할 일은 메탈에 애니메이션 기하학을 제공하는 것이다.

우리는 키프레임 애니메이션이라고 불리는 일반적인 애니메이션 방법을 사용하여 이것을 한다.

애니메이션은 키프레임이라고 불리는 주요 지점에서 공을 모델링하여 만들어집니다.

이 키프레임은 애니메이션의 시작과 끝 사이에 균일하게 분포되어 있다.

광선이 가속 구조를 통과할 때, 그들은 시간 값에 따라 모든 키프레임에서 데이터를 가져올 수 있다.

예를 들어 레이 A는 시간이 키프레임 11과 일치하기 때문에 키프레임 11에서 모델링된 장면을 볼 것이다.

대조적으로, 레이 B의 시간은 키프레임 3과 4 사이에 있다.

따라서, 두 키프레임의 기하학은 레이 B를 위해 보간된다.

모션은 인스턴스와 원시 수준 모두에서 지원됩니다.

인스턴스 애니메이션은 전체 객체를 엄격하게 변환하는 데 사용될 수 있다.

이것은 원시 애니메이션보다 저렴하지만 물체가 변형되는 것을 허용하지 않는다.

반면에, 원시 애니메이션은 더 비싸지만, 스킨 캐릭터 애니메이션과 같은 것에 사용할 수 있다.

인스턴스와 원시 애니메이션은 모두 키프레임 애니메이션을 기반으로 합니다.

먼저 인스턴스 모션에 대해 이야기해 봅시다.

인스턴스 가속 구조에서, 각 인스턴스는 변환 매트릭스와 관련이 있다.

이 매트릭스는 장면에서 기하학을 어디에 배치할지 설명한다.

이 예에서, 우리는 두 개의 원시 가속 구조를 가지고 있다: 하나는 구를 위한 것이고 다른 하나는 정적 기하학을 위한 것이다.

각 원시 가속 구조는 하나의 인스턴스를 가지고 있다.

구체를 애니메이션화하기 위해, 우리는 애니메이션의 시작점과 끝점을 나타내는 두 개의 변환 행렬을 제공할 것이다.

금속은 각 광선의 시간 매개 변수에 따라 이 두 행렬을 보간할 것이다.

이것은 두 개의 키프레임을 사용하는 구체적인 예이지만, 메탈은 임의의 수의 키 프레임을 지원한다는 것을 명심하세요.

우리는 가속 구조 설명자를 사용하여 이러한 행렬을 제공합니다.

표준 금속 인스턴스 설명자는 단일 변환 행렬을 위한 공간만 있다.

그래서 대신, 우리는 새로운 모션 인스턴스 설명자를 사용할 것이다.

이 설명자를 사용하면, 변환 행렬은 별도의 버퍼에 저장됩니다.

그런 다음 인스턴스 설명자는 변환 버퍼의 변환 행렬 범위를 나타내는 시작 인덱스와 카운트를 포함합니다.

각 매트릭스는 단일 키프레임을 나타낸다.

새로운 모션 인스턴스 설명자 유형으로 인스턴스 설명자를 설정하는 방법을 봅시다.

우리는 일반적인 인스턴스 가속 구조 설명자를 만드는 것으로 시작합니다.

그런 다음 우리는 새로운 모션 인스턴스 설명자 유형을 사용하고 있다고 명시합니다.

그런 다음, 모션 인스턴스 설명자를 포함하는 instanceDescriptorBuffer를 지정합니다.

마지막으로, 우리는 각 키프레임에 대한 정점 버퍼를 포함하는 transformsBuffer를 바인딩해야 합니다.

나머지 속성은 다른 인스턴스 가속 구조와 동일하며, 다른 가속 구조도 마찬가지로 구축할 수 있습니다.

셰이딩 언어를 한 번만 변경하면 됩니다. 즉, instance_motion 태그를 지정하는 것입니다.

이것은 인터섹터에게 인스턴스 모션이 있는 가속 구조를 기대하도록 말한다.

그리고 그것이 우리가 인스턴스 모션을 설정하기 위해 해야 할 전부입니다.

다음으로, 원시적인 움직임에 대해 이야기해 봅시다.

원시적인 움직임으로, 각 원시적인 것은 별도로 움직일 수 있으며, 이는 스킨 캐릭터 애니메이션과 같은 것에 사용될 수 있다는 것을 의미한다.

각 키프레임에 대해 별도의 3D 모델을 제공해야 하며, Metal은 그들 사이에 보간할 것입니다.

우리는 각 키프레임에 대한 정점 데이터를 제공해야 할 것이다.

이걸 어떻게 설정하는지 보자.

우리는 각 키프레임의 버텍스 버퍼를 배열로 모으는 것으로 시작할 것이다.

MTLMotionKeyframeData 객체를 사용하면 버퍼와 오프셋을 지정할 수 있습니다.

우리는 각 키프레임의 정점 버퍼를 지정하는 데 사용할 것이다.

다음으로, 우리는 모션 삼각형 기하학 설명자를 만들 것이다.

이것은 우리가 약간 다른 유형을 사용하는 것을 제외하고는 다른 지오메트리 설명자를 만드는 것과 같다.

그리고 단일 버텍스 버퍼를 제공하는 대신, 우리는 버텍스 버퍼 배열을 제공할 것입니다.

마지막으로, 우리는 일반적인 원시 가속 구조 설명자를 만들 것이다.

다음으로, 우리는 기하학 설명자를 제공합니다.

그런 다음 우리는 키프레임의 수를 지정할 것이다.

인스턴스 모션과 마찬가지로, 우리는 primitive_motion 태그를 지정하기 위해 셰이딩 언어를 약간 변경해야 합니다.

그리고 그게 우리가 원시적인 움직임을 설정하기 위해 해야 할 전부야!

훨씬 더 역동적인 장면을 위해 두 가지 유형의 애니메이션을 동시에 사용할 수 있다는 것을 명심하세요.

다음으로, 이 모든 것을 실제로 살펴봅시다!

이것은 고급 콘텐츠 팀이 만든 경로 추적 렌더링입니다.

이 비디오는 AMD 라데온 프로 베가 II GPU가 장착된 맥 프로에서 렌더링되었다.

닌자 캐릭터는 각 원시인이 별도로 움직일 수 있는 피부 골격 애니메이션 기술을 사용하여 애니메이션되었다.

각 프레임은 원시 모션 API를 사용하여 찍은 256개의 무작위 시간 샘플을 결합하여 렌더링되었다.

우리는 그 차이를 더 명확하게 보기 위해 속도를 늦출 수 있다.

왼쪽 버전은 모션 블러가 없지만, 오른쪽 버전은 있다.

그리고 우리는 긴 노출을 시뮬레이션하기 위해 노출 시간을 더 늘릴 수 있다.

모션 블러는 리얼리즘에 큰 차이를 만들 수 있으며 이제 새로운 모션 API로 쉽게 추가할 수 있습니다.

그래서 그게 모션을 위한 거야.

이 강연을 봐줘서 고마워.

우리는 앱을 향상시키는 데 필요한 도구를 제공하기 위해 Metal ray tracing API에 많은 노력을 쏟아 부었습니다.

우리는 당신이 그것으로 만들 놀라운 콘텐츠를 빨리 보고 싶습니다.

고마워, 그리고 멋진 WWDC 보내!

♪