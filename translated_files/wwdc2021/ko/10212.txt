10212

환영해! 제 이름은 캐퍼입니다.

저는 Apple의 성능 도구 엔지니어이며, 오늘 Sergio와 함께 Instruments 13에서 사용할 수 있는 새로운 HTTP Traffic Instrument에 대해 이야기할 것입니다.

네트워크 템플릿에 포함된 이 도구를 사용하면 Apple 네트워킹 스택을 통해 애플리케이션에서 오는 HTTP 트래픽을 검사할 수 있습니다.

이 접근 방식은 여러 가지 이점이 있다.

그것은 모든 Apple 기기에서 작동합니다.

URL 로딩 시스템을 통과하는 전체 트래픽은 새로운 HTTP/3 프로토콜이나 VPN을 통해 전송된 트래픽도 노출됩니다.

시스템 통합으로 인해, 그것은 트래픽을 실행 중인 프로세스에 돌리고, 애플 네트워킹 프레임워크를 계측하고 있기 때문에, 심지어 디스크 캐시나 네트워킹 오류에 부딪히는 요청을 드러낸다.

이 모든 것은 URLSessions 및 URLSessionTasks와 같이 익숙한 더 높은 수준의 API 개념의 맥락에서 노출되었습니다.

이 도구는 API 사용이 네트워크 요청의 수명으로 어떻게 변환되는지 이해하는 데 도움이 될 것입니다.

이 실습 세션에서, 우리는 먼저 Instruments UI가 당신이 사용하고 있는 API 개념을 어떻게 반영하는지에 익숙해질 것입니다.

이 빠른 소개 후, 우리는 이 도구를 사용하여 성능과 정확성 문제를 모두 감지할 수 있는 방법을 보여주는 네 가지 데모로 전환할 것입니다.

그리고 당신의 앱이 완벽하게 작동하는 것처럼 보일지라도, 당신은 그것으로부터 오는 트래픽을 감사함으로써 당신이 생각하는 것을 하는지 확인하는 방법을 배우게 될 것입니다.

네트워킹 API가 인스트루먼트 시각화에 매핑되는 방법을 시작합시다.

이것이 네트워크 템플릿을 사용하여 시스템 트래픽을 기록할 때 인스트루먼트에 HTTP 트래픽 추적이 표시되는 방식입니다.

내비게이션은 트랙 계층 구조를 중심으로 구성되어 있으며, 그것이 우리가 먼저 자세히 다룰 것이다.

최상위 수준에 위치한 HTTP 트래픽 도구는 주어진 시간에 얼마나 많은 URLSession 작업이 추적에서 실행되었는지에 대한 개요를 보여주며, 앱의 수명 동안 HTTP 트래픽 활동이 증가한 지점을 감지하는 데 이상적입니다.

다음 계층 수준은 프로세스별 활동 내역을 보여준다.

모든 디버깅 가능한 프로세스의 트래픽 외에도, 그들에 의해 시작된 백그라운드 트래픽을 검사할 수 있습니다.

각 프로세스 아래에는 사용되는 모든 URLSessions가 포함되어 있습니다.

그리고 이것들은 당신이 코드에서 만든 URLSession 객체에 해당합니다.

이 수준의 그래프를 사용하면 모든 개별 작업 간격을 검사할 수 있습니다.

세션 객체와 시각화 간의 더 나은 매핑을 얻으려면, 세션 인스턴스에서 sessionDescription 속성을 설정하여 코드로 이름을 지정할 수 있습니다.

마지막 수준에서, 트래픽은 요청된 도메인에 따라 세분화됩니다.

이 수준의 그래프는 작업과 상태를 구성하는 개별 거래를 포함하여 작업에 대한 자세한 내용을 보여줍니다.

작업과 거래가 무엇인지 더 잘 이해하기 위해, 예를 분석해 봅시다.

다음은 선택한 도메인에서 데이터를 로드하는 몇 가지 작업입니다.

작업의 구조를 분석하기 위해 그들 중 하나에 집중합시다.

이 단일 작업 간격은 많은 정보를 가지고 있다.

우리는 Instruments 시각화가 사용되는 API에 어떻게 매핑되는지 이해하기 위해 이것을 더 추상적인 방식으로 표현할 수 있다.

최상위 수준에서, 우리는 작업 객체를 가지고 있다.

작업은 하나 이상의 거래로 구성되어 있다.

거래는 한 쌍의 HTTP 요청과 해당 응답이다.

작업 수준은 코드가 URL 로딩 시스템의 API와 어떻게 상호 작용하는지를 나타냅니다.

작업을 만들고 이력서를 호출하면 작업 간격이 시작됩니다.

그리고 그것은 당신의 완료 블록이 호출되기 직전에 끝납니다.

각 작업에는 Instruments의 간격에 레이블을 지정하는 데 사용되는 taskDescription 속성을 사용하여 의미 이름을 지정할 수 있습니다.

우리는 또한 작업 라벨의 일부로 작업 식별자를 보여줍니다.

당신은 그것을 사용하여 작업을 다른 데이터와 상호 참조할 수 있습니다.

작업이 오류로 끝나면, 더 쉬운 디버깅을 위해 간격 라벨에 설명이 표시됩니다.

우리가 전에 언급했듯이, 작업은 여러 거래로 구성될 수 있다.

이제 이것들에 대해 이야기해 봅시다.

여기 apple.com의 시작 페이지를 로드하는 작업이 있습니다.

그러나, 이 URL은 표준 URL이 아니다.

그 작업은 apple.com을 요청하지만, 선호하는 도메인은 www.apple.com이다.

이 작업을 만들 때, URL 로딩 시스템은 처음에 apple.com에 대한 요청을 생성합니다.

얼마 지나지 않아, 서버로부터 선호하는 URL이 실제로 www.apple.com이라는 리디렉션 응답을 받습니다.

기본적으로, 우리는 리디렉션을 따르므로, 301 응답을 반환하는 대신, URL 로딩 시스템은 이제 선호하는 URL을 로드하는 새로운 트랜잭션을 생성합니다.

이 두 번째, 성공적인 거래의 반응은 작업으로 돌아가는 것이다.

앞서 언급했듯이, 거래는 HTTP 요청과 응답의 조합을 나타낸다.

그것은 URLSession이 작업을 처리하기 위해 후드 아래에서 수행하는 것과 일치하며 요청된 URL, 전송된 데이터에 대한 정보 등과 같은 HTTP 계층의 모든 정보를 포함합니다.

작업과 마찬가지로, 거래 라벨은 거래에 대한 개요를 제공합니다.

주로, 당신은 요청과 응답에 대한 정보를 얻을 수 있습니다.

트랙 계층 구조는 요청된 도메인을 알려주며, 라벨 자체에서 경로와 쿼리를 찾을 수 있습니다.

그 외에도, 간격 라벨은 HTTP 버전, HTTP 메소드, 그리고 요청이 인증 또는 쿠키 헤더를 보냈는지 여부를 표시합니다.

이것들은 종종 인증 흐름을 한 눈에 이해하는 데 유용하다.

응답의 경우, 응답에 쿠키가 포함되어 있는지 여부와 응답의 콘텐츠 유형에 대한 상태 코드를 얻을 수 있습니다.

요청과 응답이 얼마나 걸렸는지, 그리고 거래의 일부인 다른 작업에 대한 더 자세한 타이밍 정보는 거래 상태에 의해 캡처됩니다.

포함된 작업의 맥락에서 그것들을 분석해 봅시다.

거래의 시작은 URL 로딩 시스템이 이 요청을 하기 위한 거래를 생성하는 시점이다.

그것은 먼저 우리가 이미 유효한 캐시된 응답을 가지고 있는지 확인합니다.

그리고 만약 그렇지 않다면, 그것은 연결에 대한 요청을 예약하려고 시도할 것이다.

다음으로, 거래는 차단된 상태에서 사용 가능한 연결을 기다려야 할 수도 있습니다.

전송 요청 상태는 거래가 마침내 연결에 의해 처리될 때 시작됩니다.

요청의 마지막 바이트를 네트워크로 보내면 끝납니다.

다음으로, 트랜잭션은 응답 대기 대기 유휴 상태로 들어가고, 응답 수신은 서버에서 수신된 첫 번째 바이트에서 마지막 바이트까지의 스팬을 추적합니다.

URL 로딩 시스템이 이것이 성공적인 응답인지 여부를 결정하면, 마지막 바이트가 수신된 직후에 전체 거래가 완료될 것입니다.

실제로, GET 요청에 대한 캐시 조회 및 전송 상태는 일반적으로 훨씬 짧기 때문에 이렇게 나타날 가능성이 더 큽니다.

당신에게 몇 가지 실용적인 예를 보여주기 위해, 저는 제 동료인 세르지오에게 넘겨주고 싶습니다.

그는 HTTP 악기가 성능과 정확성 문제를 해결하는 데 어떻게 도움이 될 수 있는지 설명하기 위해 최근에 개발하기 시작한 앱을 안내할 것입니다.

고마워, 캐퍼. 안녕하세요, 여러분.

제 이름은 세르지오 로페즈이고, 저는 개 애호가들을 위한 이 앱을 개발하고 있습니다.

소셜 미디어 플랫폼처럼 생각하지만 개 사진을 위해...

오직!

사람들은 개 이미지를 게시할 수 있고 당신은 가장 최근의 업로드 스트림을 얻을 수 있습니다!

그래서 앱을 열면, 몇 개의 새로운 개 이미지가 로드되지만, 로딩을 완료하는 데 꽤 시간이 걸린다는 것을 알아차렸다.

이 상황을 개선하는 데 도움이 되도록 새로운 HTTP 트래픽 도구로 앱을 프로파일링합시다.

"제품" 메뉴에서, 나는 악기에서 내 앱을 프로파일링하기 위해 "프로필" 옵션을 선택할 것이다.

이것은 모든 최적화를 켠 상태에서 사용자를 위해 실행되는 것처럼 앱을 프로파일링할 수 있도록 릴리스 구성에서 내 앱을 구축할 것입니다.

빌드가 완료되면, 악기는 자동으로 실행될 것이다.

시작하면, 악기의 표준 템플릿 선택기가 표시됩니다.

우리의 경우, 저는 왼쪽 하단에 있는 네트워크 템플릿을 선택하고 싶습니다. 이는 제 앱이 만드는 일반적인 네트워크 연결에 대한 더 많은 정보를 제공하지만 새로운 HTTP 추적 기능도 포함합니다.

트랙 영역에는 이제 각 악기마다 하나씩 두 개의 트랙이 있다.

하단 트랙은 기존 네트워크 연결 기기이며, 상단 트랙은 새로운 HTTP 트래픽 기기입니다.

우리는 오늘 이 새로운 악기에 집중할 것이다.

내가 지금 해야 할 일은 "레코드"를 누르는 것뿐이야.

그러면 악기는 내 앱을 시작하고 녹음을 시작할 것이다.

이 도구를 사용하기 전에, 네트워킹 트래픽 캡처의 의미를 이해했는지 확인해야 합니다.

특히 모든 프로세스를 기록한다면, 그것은 매우 강력하다.

캡처된 데이터에는 전송된 모든 것이 포함되며, 이는 사용자 자격 증명까지 개인적이고 민감한 정보일 수 있습니다.

그래서, 당신은 결과 추적 파일에 대해 매우 조심해야 하며, 우리는 당신이 알고 있기를 바랍니다.

그래서 내가 이걸 확인할게.

앱이 실행되었고 이미지 로딩 속도가 느렸다.

나는 이제 녹음을 중단할 것이다.

Option-클릭을 사용하여 HTTP 트래픽을 다루는 영역을 드래그하여 기록한 데이터를 확대해 봅시다.

왼쪽 상단의 "HTTP 트래픽" 트랙에서 공개 표시기를 클릭하면 Kacper가 이전에 설명한 전체 트랙 계층 구조가 표시됩니다.

나는 또한 모든 간격을 보여주기 위해 트랙 높이를 늘릴 것이다.

상단에는 앱의 "최신" 섹션에 나타나는 이미지 목록을 서버에 쿼리하는 첫 번째 작업이 있습니다.

이 작업이 완료되면, 우리는 우리가 받은 목록의 모든 이미지에 대한 썸네일을 로드하는 새로운 작업을 만듭니다.

이제 이미지 목록을 가져오는 데 걸린 기간을 다루는 영역을 클릭-드래그한 다음 각 개별 이미지를 검색하기 위한 많은 요청을 할 것입니다.

이 영역을 클릭하여 드래그하면 선택한 시간 범위의 기간을 보여주는 도구 팁이 표시됩니다.

전반적으로, 초기 화면 로딩을 완료하는 데 7초 이상이 걸렸다.

처음 몇 개의 이미지는 꽤 빨리 로드된다.

하지만 내가 아래로 스크롤할 때, 보라색의 차단 상태가 증가함에 따라, 나중에 시작된 작업은 완료하는 데 더 오래 걸렸다.

병렬로 요청이 너무 많은 혼잡 문제인 것 같다.

나중의 작업 중 하나를 조사해 봅시다.

작업 위에 맴돌면, 도구 팁은 우리에게 작업의 지속 시간과 우리가 맴돌고 있는 자식 간격을 보여줍니다.

이 작업은 대부분의 시간 동안 차단되었다.

왜 차단되었는지 이해하려면, 트랙 디스플레이를 "연결에 의한 HTTP 트랜잭션" 보기로 전환합시다.

왼쪽의 트랙 사이드바의 도메인 이름 아래에 트랙 디스플레이를 전환하기 위해 클릭할 수 있는 아래쪽 화살표가 있습니다.

현재, 우리는 "작업"을 그리고 있다.

"연결에 의한 HTTP 트랜잭션" 표시로 전환합시다.

이 보기는 거래만 표시할 것이며, 작업별로 그룹화하는 대신, 우리는 이제 그들이 어떤 연결을 예약했는지 알아낼 수 있습니다.

거래는 그들이 사용한 연결에 따라 그룹화된다.

전반적으로, 이러한 거래를 처리할 수 있는 여섯 개의 연결이 있었다.

연결 1에서 발행된 거래를 분석하고 썸네일 로딩 거래를 더 조사해 봅시다.

위에서 아래로, 각 거래가 완료되는 데 더 오래 걸린다는 것이 눈에 띈다.

각 연속 거래에 대한 보라색 차단 상태가 증가하고 있다.

사실, 여기에는 꽤 명확한 계단 패턴이 있다.

각 거래는 동일한 연결에서 이전 거래가 완료될 때까지 차단됩니다.

그래야만 요청을 보낼 수 있다.

이 패턴은 각 후속 거래에 대해 반복된다.

이것은 "헤드 오브 라인 블로킹"이라고 불리며 HTTP/1을 사용하는 문제 중 하나이다.

실망스러운 부분은 이러한 거래가 대부분의 시간 동안 아무것도 하지 않는다는 것이다.

대신, 그들은 대부분의 시간을 차단하거나 서버의 응답을 기다리는 데 보낸다.

동일한 연결에서 이전 거래의 응답을 기다리는 동안 다음 거래에 대한 또 다른 요청을 보낼 수 있지만, HTTP/1에서는 지원되지 않습니다.

헤드 오브 라인 차단은 HTTP/1의 주요 제한 사항 중 하나이며, HTTP/2의 주요 개선 사항 중 하나는 동일한 서버에 대한 여러 요청을 단일 연결로 다중화하여 그 효과를 피하는 것입니다.

HTTP/2에서, 우리는 실제로 첫 번째 요청이 응답을 기다리는 동안 두 번째 요청을 보내기 시작할 수 있습니다.

당신의 앱은 그것을 지원하기 위해 아무것도 할 필요가 없습니다.

모든 Apple 플랫폼은 HTTP/2를 지원하며, iOS 15와 macOS Monterey부터 HTTP/3도 지원됩니다.

클라이언트는 서버가 지원하는 가장 최신 HTTP 버전을 선택할 것이다.

HTTP/1과 HTTP/2의 차이점과 HTTP/3이 제공하는 추가 혜택에 대해 더 알고 싶다면, "HTTP/3 및 QUIC로 네트워킹 가속화" 세션을 시청하세요.

나는 이 추적을 가져갔고, 우리 서버 사람들에게 보여주었고, 우리가 정말로 HTTP/2를 지원해야 한다고 그들을 설득할 수 있었다.

이제, 새로운 서버 개선 사항으로 내 앱을 실행해 봅시다.

와, 이건 이미 더 빨리 느껴져!

이것을 악기로 확인해 봅시다.

그래서 여기 우리가 HTTP/2에 대한 서버 지원을 켠 후 내가 기록한 흔적이 있다.

도메인별 트랙에서, 우리의 썸네일 로딩 작업 중 어느 것도 더 이상 오랜 시간 동안 차단되지 않는 것 같습니다.

그거 좋네!

"연결에 의한 HTTP 트랜잭션" 보기로 다시 전환해 봅시다.

우리가 가장 먼저 알아차린 것은 오직 하나의 연결만 있다는 것이다.

이는 더 이상 동시 요청을 보내기 위해 여러 연결이 필요하지 않기 때문입니다. 즉, 연결 설정 비용을 한 번만 지불하면 됩니다.

개별 썸네일 로딩 거래에 초점을 맞추면서, 우리는 그들이 기본적으로 "차단된" 상태에서 시간을 보내지 않는다는 것을 알아차렸다.

사실, 시간이 너무 작아서 이 줌 수준에서는 보이지 않는다.

결국 모든 거래는 요청을 보내고 응답을 기다리게 된다.

내가 아래로 스크롤할 때, 우리는 응답이 동시에 진전되고 있다는 것을 알 수 있다.

대체로, 우리는 모든 요청을 3초 이내에 완료했습니다.

이것은 이전보다 두 배 빠르다.

이제 서버 사람들과 이야기하고 HTTP/1.1에서 HTTP/2로 전환했기 때문에, 우리의 이미지는 훨씬 더 빨리 로드되고 있다.

앱을 다시 실행해서 우리가 뭘 더 할 수 있는지 보여줄게.

이미지를 탭하면, 앱은 전체 해상도 사진을 로드하고 이 사진이 나에게서 얼마나 멀리 찍혔는지 보여줍니다.

오른쪽 상단에는 특정 사진을 좋아할 수 있는 하트 아이콘도 있습니다.

그렇게 하려면, 나는 계좌가 필요해.

사람들이 앱을 사용하고 계정 없이 사진을 검색할 수 있도록 허용하지만, 즐겨찾는 이미지를 저장하고, 장치 간에 동기화하고, 새 사진을 업로드하려면 계정이 필요합니다.

그럼 내가 여기에 로그인할게.

좋아. 내가 다른 사진을 좋아하게 해줘.

오, 이 개는 귀여워 보여! 내가 가장 좋아하는 것에 추가할게.

잠깐, 내가 방금 했다면 왜 다시 로그인해야 해?

이건 옳지 않아.

내 앱은 내 로그인을 기억해야 한다.

이건 전에 효과가 있었어.

다시 로그인하고 싶지 않아서 로그인 화면을 해제할 거야.

나는 이전에 그 문제를 재현한 후 추적 파일을 기록했다.

녹음을 분석하기 위해 악기로 열어보겠습니다.

왼쪽에는 내가 처음 좋아하는 버튼을 눌렀을 때 해당하는 작업이 있다.

그것의 오른쪽에, 내가 최신 탭으로 돌아간 후에 발행된 작업이 있고, 이미지 스트림이 새로 고쳐졌다.

그런 다음, 다른 개 사진을 탭한 후 전체 해상도 이미지를 로드하는 작업이 있습니다.

그리고 맨 오른쪽에, 내가 좋아하는 버튼을 두 번째로 탭한 것에 해당하는 작업이 있다.

첫 번째 작업 간격은 실제로 두 개의 거래를 포함한다.

첫 번째 거래는 401 상태 코드를 받았다.

우리가 로그인하지 않았기 때문에 이것은 예상되었다.

거래는 이것이 HTTP 수준에서 성공하지 못했다는 것을 나타내기 위해 주황색으로 그려져 있다.

그런 다음, 작업에는 사용자 이름과 비밀번호를 입력하는 데 보낸 시간을 나타내는 크고 빈 영역이 있습니다.

내가 이 자격 증명을 입력하자마자, 우리는 거래를 다시 시도한다.

간격의 녹색과 201 상태 코드는 이번에 성공했음을 나타냅니다.

인증 챌린지, 비밀번호 입력 및 트랜잭션 재시도의 상호 작용은 URL 로딩 시스템이 처리하는 또 다른 경우이므로, 이 두 트랜잭션은 동일한 작업 객체에 속합니다.

축소하면, 우리는 오른쪽에 있는 이미지를 선호하는 두 번째 시도를 찾을 수 있다.

로그인 화면을 해제하면 작업이 취소되었기 때문에 작업 개체가 회색으로 표시되며, 이는 라벨에서도 볼 수 있습니다.

서버에서 401 응답을 다시 받았기 때문에 거래 간격이 주황색으로 표시됩니다.

이 작업은 내가 다른 개 사진을 좋아하려고 시도한 후에 발생했고 두 번째로 로그인하라는 메시지가 표시되었다.

우리는 사용자가 처음으로 자격 증명을 보내는 매우 기본적인 로그인 시스템을 사용하지만, 서버가 사용자 자격 증명을 확인하면 다음 요청에 자격 증명을 제공할 필요가 없는 사용자를 식별하는 쿠키를 설정합니다.

그래서 나는 이 작업이 적절한 쿠키를 보냈을 것이라고 예상했을 것이다.

그런 일이 일어났는지 확인해 봅시다.

Kacper가 앞서 설명했듯이, 이 거래가 쿠키 헤더를 보냈다면, HTTP 방법 옆에 작은 쿠키 아이콘이 있어야 합니다.

하지만 여기에는 그런 아이콘이 없으며, 이는 쿠키가 전송되지 않았다는 것을 의미합니다.

그래서 그 부분은 작동하지 않아.

이제 질문은, 서버가 우리에게 쿠키를 제공하지 않았나요, 아니면 클라이언트가 쿠키를 가지고 있음에도 불구하고 쿠키를 보내지 않았나요?

알아내기 위해, 우리는 이전 거래를 조사하고, 서버에서 쿠키를 받았는지 확인해야 합니다.

여기 첫 번째 로그인 요청에서 성공한 이전 거래가 있습니다.

이것은 거래 라벨의 응답 부분에 쿠키 아이콘이 있으므로 서버가 쿠키를 보냈습니다.

그거 흥미롭네.

그렇다면 왜 우리는 다음 거래에서 쿠키를 보내지 않았나요?

이 거래에 대한 더 많은 정보를 얻고 쿠키를 자세히 조사하려면, 하단의 상세 보기에서 "거래" 목록으로 전환할 것입니다.

시간 커서가 트랙 뷰에서 그 안에 배치되기 때문에, 거래는 이미 여기에서 선택되었다.

오른쪽 하단의 확장된 세부 정보 보기는 현재 선택된 거래의 모든 요청 및 응답 헤더를 보여줍니다.

그리고 여기 우리가 기대하는 Set-Cookie 헤더가 있습니다.

언뜻 보기에, 이 쿠키는 괜찮아 보인다.

하지만 오, 잠깐, 만료일이 보이니?

2020년 3월이야. 그건 과거의 일이야!

그래서 서버는 쿠키를 보냈지만, 만료된 쿠키입니다.

아무도 만료된 쿠키를 좋아하지 않아!

이것은 여전히 유효한 쿠키만 보내기 때문에 URLSession이 쿠키를 보내지 않도록 합니다.

이것은 서버 측 버그입니다.

나는 그 문제를 조사하고 해결할 수 있도록 추적 파일을 우리 서버 직원들에게 보낼 수 있다.

이제 쿠키 문제를 해결했으므로 로그인하라는 메시지가 표시되지 않고 몇 장의 사진을 더 좋아할 수 있습니다.

"최신" 탭 외에도, 사용자가 즐겨찾은 모든 개 이미지 목록을 표시하는 "즐겨찾기" 탭도 있습니다.

그 탭으로 바꾸자.

좋아요, 제가 어제 추가한 몇 가지 즐겨찾기가 있지만, 어떤 이유에서인지, 제 최근 즐겨찾기가 나타나지 않습니다.

다시 해보자.

목욕을 즐기고 있는 것 같은 이 개를 골라서 내가 좋아하게 하자.

내가 가장 좋아하는 것으로 돌아가서 그것이 나타나는지 확인해 보자.

흠, 아직 거기 없어.

무슨 일이 일어나고 있는지 알아내기 위해 악기를 다시 사용합시다.

나는 이미 이것을 위한 추적 파일을 준비했다.

트랙 뷰에서 즐겨찾기 목록을 로드하는 작업을 찾을 것으로 예상하지만, 언뜻 보기에는 보이지 않습니다.

해당 도메인에 발행된 요청만 표시하기 위해 내 서버 도메인의 트랙을 선택하겠습니다.

그런 다음 이 도메인의 모든 작업 목록이 포함된 하단의 세부 보기로 갈 수 있습니다.

여기에 꽤 많은 요청이 있다.

왼쪽 하단의 세부 필터를 사용하여 "즐겨찾기"와 관련된 모든 요청을 검색하여 우리가 요청을 했는지 확인할 수 있습니다.

필터링 시, 결과는 우리가 여기에 즐겨찾기 목록을 로드하기 위해 몇 가지 요청을 보냈다는 것을 보여준다.

트랙 뷰에 집중하자.

커서는 내가 세부 보기에서 선택한 작업의 시작 부분에 위치했기 때문에 위의 트랙 보기에서 꽤 쉽게 찾을 수 있다.

다시 확인하기 위해 확대해 봅시다.

그래서 우리가 초기 앱 출시에서 즐겨찾기 목록을 로드한 것은 이번이 처음이었다.

이건 괜찮아.

여기서, 나는 새로운 이미지를 좋아했고, 그 후, 우리는 즐겨찾기를 다시 로드했다.

음, 여기에는 작업 간격이 있지만, 매우 짧습니다.

응, 이 GET 요청은 몇 밀리초밖에 안 걸렸어.

서버 응답을 받기에는 너무 빠르다.

자세한 내용을 보려면 "연결에 의한 HTTP 트랜잭션" 보기로 다시 전환합시다.

우리가 가장 먼저 알아차린 것은 이 거래가 연결에서 실행되는 것이 아니라 "로컬 캐시"에서 실행된다는 것이다.

이것은 요청이 네트워크에서 전송되지 않았고, 오히려 로컬 캐시에서 로드되었다는 것을 보여준다.

이것은 또한 거래가 서버를 기다리지 않았기 때문에 "응답 대기 중" 상태가 없는 이유를 설명한다.

그래서 그것이 문제입니다: 우리의 요청은 캐시되어 있으므로, 우리는 실제로 서버에 묻지 않고, 항상 캐시된 응답을 다시 받는다.

이것을 고치는 한 가지 방법은 서버에 이 응답을 캐시하지 않고 캐시 제어 헤더를 설정하라고 말하는 것이다.

우리가 원하는 것은 사용자가 즐겨찾기 탭으로 이동하고 새로운 이미지가 추가될 때마다 이미지를 다시 로드하는 것입니다.

우리가 원하지 않는 것은 그러한 변화가 없다면 전체 이미지 목록을 로드하는 것이다.

우리가 서버에게 물어볼 수 있다면 좋은 절충안일 거야, "이봐, 바뀐 거 있어?

만약 그렇다면, 제게 알려주세요."

그것은 실제로 요청에 대한 캐시 정책을 설정함으로써 우리가 할 수 있는 것이다.

코드를 업데이트하려면, 작업 보기로 돌아가서 문제의 작업을 선택하겠습니다.

여기에서 실행된 각 URLSession 작업에 대해...

우리는 그 작업에서 "재작업"이 호출된 오른쪽에 백트레이스를 표시합니다.

그것은 ImageCollection 유형의 방법 동기화에서 재개되었다.

여기서 변경하기 위해 Xcode에서 이것을 열겠습니다.

여기, 저는 URLRequest가 있고, 이제 캐시 정책을 설정하고 싶습니다.

내가 원하는 캐시 정책은 reloadRevalidatingCacheData입니다. 즉, 로컬 캐시를 무시하고 캐시가 여전히 유효한지 확인하기 위해 서버에 요청할 것입니다.

그렇다면, 서버는 로컬 캐시를 사용하도록 알려주기 위해 304 응답 코드를 보낼 것이다.

그렇지 않다면, 그것은 새로운 데이터를 다시 보낼 것이다.

한 번 해보자.

그래서 이것들은 내가 현재 가장 좋아하는 이미지이며, 목욕하는 개가 추가되었다.

하나 더 추가하자.

이제, "즐겨찾기" 탭을 확인해 봅시다.

내가 방금 좋아했던 이미지가 이제 제대로 나타난다.

그래, 좋아! 그것도 지금 고쳐졌어.

당신의 앱과 종속성이 예상대로 작동하는지 확인하기 위해 제 동료 Kacper에게 돌아가세요.

세르지오가 전에 보여준 것처럼, 로그인하지 않고 "즐겨찾기" 탭을 클릭하면 로그인 보기가 표시됩니다.

우리는 이미 원활한 로그인 경험을 위해 Apple에 로그인을 추가했습니다.

그러나, 우리 회사는 여러 애완 동물 테마 앱을 가지고 있으며, 다른 팀은 사용자가 애플리케이션 간에 계정을 재사용할 수 있도록 공유 로그인 SDK를 개발하고 있습니다.

이 SDK는 현재 개발 중이며, 다른 팀은 클래식 로그인 화면을 대체할 수 있는지 물었다.

나는 모든 플랫폼에서 사용할 수 있도록 xcframework로 배포되는 Pets라는 SDK 바이너리를 얻었다.

내 Xcode 프로젝트에 통합하는 것은 임베디드 프레임워크 섹션에 드래그 앤 드롭하는 것만큼 쉽다.

이제, 남은 것은 우리의 기존 보기에 버튼을 추가하는 것이다.

Log-inView의 소스 코드로 이동하겠습니다.

먼저 프레임워크를 가져온 다음, Apple로 로그인 바로 아래에 있는 SwiftUI VStack에 버튼을 추가할 것입니다.

스위프트 UI 미리보기를 새로 고쳐봅시다.

여기 있어.

"애완동물과 함께 로그인" 버튼이 미리보기에 정확히 내가 원하는 곳에 나타났다.

그것은, 정말로, 정말 쉬운 통합이었다.

이 새로운 로그인 방법이 얼마나 빠를지 궁금합니다.

그리고 이것을 측정하기 위해, 나는 제품 프로필 액션을 사용하여 악기로 내 애플리케이션을 프로파일링할 것이다.

나는 네트워크 템플릿을 선택하고 있어.

그리고 도구 모음에서 "기록" 버튼을 클릭하여 앱을 실행하세요.

내 앱이 이제 실행됐어.

이제 로그인 보기로 전환할 수 있습니다.

악기는 그 동안 발생하는 모든 네트워킹 트래픽을 보여주고 있다.

내 앱의 URL 세션을 검사하기 위해 확장할 것이다.

여기 있어.

하지만 기다려.

나는 내 주요 앱 URLSession만 여기에 있을 것으로 예상하지만, 우리가 방금 통합한 Pets 프레임워크는 로그인 버튼을 클릭하지 않고 자체 세션에서 요청을 하는 것 같습니다.

그건 예상치 못한 일이야.

더 자세히 조사하기 위해 지금 당장 녹음을 중단합시다.

옵션 클릭과 드래그를 사용하여 몇 가지 첫 번째 요청을 확대할 것입니다.

일부 분석 엔드포인트에 대한 많은 요청이 있으며, 자세한 내용을 보려면 이 "Pets Sign On Network" 세션을 클릭하고 세부 보기에서 모두 나열할 수 있습니다.

그것들은 모두 POST 요청이며, 하나를 클릭하면, 요청이 코드의 어느 부분에서 비롯되었는지 알려주는 오른쪽의 백트레이스를 볼 수 있습니다.

그래서 그 요청은 예상대로 Pets에 의해 호출된 CFNetwork를 통해 진행되고 있는 것 같다.

하지만 우리가 더 깊이 탐색할 때, CoreLocation이 관여하고 있는 것처럼 보인다.

그것은 정말 의심스럽다, 특히 내가 그것을 촉발시키기 위해 어떤 행동도 하지 않았기 때문이다.

내 위치가 서버로 다시 전송되고 있는지 궁금합니다. 그래서 CoreLocation과 CFNetwork가 같은 추적에 있습니다.

나는 이러한 작업에 대한 해당 HTTP 트랜잭션을 검사하여 그것을 확인할 것이다.

이를 위해, 나는 작업 목록에서 거래 목록으로 세부 사항을 전환할 것이다.

그리고 그들 중 하나를 선택하세요.

오른쪽 하단의 확장된 세부 사항에서, 이 요청에는 걱정할 필요가 없는 꽤 표준 헤더가 포함되어 있다는 것을 볼 수 있습니다.

하지만 잠시만요, 요청 본문을 보세요.

그건 내 위치 좌표를 포함하고 있어, 그리고 그건 정말 안 좋아.

이 정보를 보내는 것은 사용자의 사생활을 침해한다.

우리는 그들의 동의와 정당한 이유 없이 그들의 위치를 수집하고 싶지 않다.

지금까지, 우리 앱은 사용자 경험을 개선하는 합법적인 목적으로만 이 허가를 요청합니다.

이 시점에서, 나는 이 SDK 통합으로 더 이상 진행하지 않을 것이다.

대신, 나는 내가 감지한 이 용납할 수 없는 행동에 대해 알리기 위해 다른 팀에 버그 보고서를 제출할 것이다.

그리고 나는 심지어 이 인스트루먼트 추적을 사용하여 버그 보고서에 필요한 정보를 생성할 수도 있다.

먼저 내 데스크톱에 저장하자.

나는 그것을 "PrivacyViolation"이라고 부르고 "저장"을 누를 것이다.

Instruments와 함께 번들로 제공되는 명령줄 도구인 xctrace는 이 추적을 HTTP 트래픽에 대한 정보 교환을 위한 업계 표준인 HTTP 아카이브 형식으로 내보내는 데 사용할 수 있습니다.

이렇게 하려면, 추적과 HAR 내보내기 플래그를 입력하여 xctrace 내보내기 명령을 실행할 수 있습니다.

지금 실행하자.

이 명령은 이제 버그 보고서에 첨부할 수 있는 파일을 생성합니다.

그것을 받는 사람은 기계에 악기가 설치되어 있지 않더라도 HAR을 지원하는 모든 도구에서 기록된 정보를 검사할 수 있습니다.

HAR 자체는 JSON 기반 형식이므로 텍스트 편집기에서 열거나 스크립트를 사용하여 쉽게 처리할 수 있습니다.

그리고 URLSessions 또는 역추적과 같은 도구별 세부 사항이 포함되어 있지 않더라도, 다른 팀이 이 문제를 조사하기에 충분할 것이다.

그리고 그것이 HTTP 트래픽 인스트루먼트를 사용하여 애플리케이션에서 오는 트래픽의 소스와 콘텐츠를 진단하여 런타임에 앱이 수행하는 작업을 제어할 수 있도록 하는 방법입니다.

이제 새로운 HTTP Traffic Instrument 사용에 익숙해졌으니, 오늘 우리가 보여준 것과 같은 문제를 감지하기 위해 앱을 타겟팅하세요.

더 쉽게 디버깅하고 더 많은 컨텍스트를 가지기 위해, URLSession과 작업 객체의 이름을 지정하십시오.

항상 최신 네트워킹 프로토콜을 채택하는 것을 목표로 하세요.

그리고 앱에서 성능이나 정확성 문제를 찾지 못하더라도, 불필요한 트래픽을 없애기 위해 얼마나 많은 데이터를 보내고 있는지 확인하세요.

오늘 시청해 주셔서 감사드리며, 앱의 HTTP 트래픽을 추적하는 데 즐거운 시간을 보내시기 바랍니다.

[쾌활한 음악].