10233

♪ 베이스 음악 연주 ♪

♪

조나단 호그: 안녕하세요, 가속 및 관련 프레임워크에 대한 이 세션에 오신 것을 환영합니다.

저는 Apple의 Vector & Numerics 팀의 Jonathan입니다. 오늘은 기계 학습 라이브러리인 BNNS의 새로운 기능을 말하기 전에 Accelerate 프레임워크에 대해 간략하게 이야기하겠습니다.

그런 다음 simd.h의 개선 사항을 다루고, Apple Archive와 새로운 Apple Encrypted Archive 컨테이너를 소개하겠습니다.

그러니 Accelerate 프레임워크에 대한 간략한 개요로 시작합시다.

Accelerate는 MacOS, iOS, iPadOS, watchOS 및 tvOS와 같은 모든 Apple 플랫폼에서 고성능 수치 계산을 제공합니다.

Accelerate는 또한 Apple Silicon Mac과 최신 iPhone 및 iPad 장치의 기계 학습 가속기에 대한 액세스를 제공합니다.

이 하드웨어를 활용하는 유일한 방법은 직접 또는 Core ML과 같은 더 높은 수준의 프레임워크를 통해 Accelerate를 호출하는 것입니다.

가속은 여러 부분으로 구성되어 있다.

vDSP는 DFT 및 FFT 루틴과 같은 신호 처리를 위한 기본을 제공한다.

vImage는 형식 변환 및 컨벌루션과 같은 이미지 처리를 위한 루틴을 제공합니다.

vForce는 사인과 코사인과 같은 초월 함수의 벡터화된 버전을 제공한다.

BLAS와 LAPACK은 표준 고밀도 매트릭스 대수학 루틴의 고성능 이식을 제공하는 반면, 스파스 BLAS와 스파스 솔버는 스파스 매트릭스에 대해 유사한 기능을 제공합니다.

마지막으로, BNNS는 기계 학습을 지원합니다.

나는 또한 오늘 몇 가지 관련 프레임워크에 대해 당신과 이야기할 것입니다.

Simd.h는 그래픽 프로그래밍에서 다루는 것과 같은 계산용 작은 벡터와 행렬을 제공하는 반면, 압축과 애플 아카이브는 무손실 데이터 압축을 지원합니다.

이러한 프레임워크를 사용하려면, 관련 포함 또는 가져오기 문을 코드에 추가하고 Xcode 프로젝트에 프레임워크를 추가하기만 하면 됩니다.

이제, BNNS에 대해 더 자세히 말씀드리겠습니다.

BNNS는 Basic Neural Network Subroutines의 약자로 CPU에서 기계 학습을 위한 성능 프리미티브를 제공합니다.

애플의 기계 학습 생태계에 익숙하지 않은 사람들을 위해, 이 다이어그램은 땅의 위치를 보여줍니다.

세 가지 주요 하드웨어 블록이 있습니다: 앞서 언급한 기계 학습 가속기를 포함하는 CPU; GPU; 그리고 별도의 신경 엔진.

BNNS는 MPS가 GPU에서 성능 프리미티브를 제공하는 것과 같은 방식으로 CPU에서 성능 프리미티브를 제공합니다.

이 레이어 위에, 이러한 백엔드 중 하나 이상에서 실행되는 많은 프레임워크가 있다.

여기에는 Apple의 높은 수준의 기계 학습 프레임워크인 Core ML 및 Create ML과 Vision 및 Natural Language와 같은 전문 프레임워크가 포함됩니다.

BNNS는 다양한 레이어 유형에 대한 교육과 추론뿐만 아니라 하단에 표시된 옵티마이저에 대한 지원을 제공합니다.

이 릴리스에서, 우리는 몇 가지 새로운 레이어 유형에 대한 지원을 추가했습니다: 임베딩, 랜덤 채우기 및 양자화; 그리고 AdamW 옵티마이저에 대한 지원.

우리는 또한 기존 레이어를 개선하여 두 가지 새로운 활성화 기능을 추가했습니다: SiLU와 HardSwish, 그리고 새로운 산술 함수에 대한 지원: 삼진수 선택, 곱하기 추가, 요소별 최소 및 최대.

레이어 퓨전은 한 레이어의 출력을 후속 레이어에 대한 입력으로 즉시 소비할 수 있는 기능을 제공하여 메모리에 쓰고 다시 읽을 필요가 없습니다.

우리는 새로운 양자화 레이어와 함께 컨벌루션의 레이어 융합과 완전히 연결된 레이어뿐만 아니라 산술과 정규화 레이어 간의 융합을 추가했습니다.

다른 개선 사항에는 독립형 기능으로도 사용할 수 있는 옵티마이저의 그라디언트 클리핑에 대한 향상된 지원과 아담 기반 옵티마이저에 대한 AMSGrad 지원이 포함됩니다.

함께, 이러한 개선은 우리가 훨씬 더 가속화할 수 있는 범위와 네트워크 아키텍처를 확장했다.

이제, simd.h에 대한 몇 가지 개선 사항에 대해 말씀드리겠습니다.

Simd.h는 사인과 코사인과 같은 함수에 대한 지원과 쿼터니언에 대한 지원을 포함한 유용한 기하학적 연산을 포함하여 CPU의 레지스터에 맞는 작은 벡터와 행렬에 대한 계산 프리미티브를 제공합니다.

내가 simd.h에 대해 정말 좋아하는 것은 우리가 뛰어들어 10퍼센트의 노력으로 벡터화 혜택의 90퍼센트를 얻을 수 있다는 것이다.

여기, 내가 보여줄게.

여기 제가 방금 발명한 신경망 활성화 기능이 있습니다.

보시다시피, 그것은 세 개의 다른 지점을 가지고 있습니다.

입력이 마이너스 파이보다 작으면, 나는 그냥 0을 반환한다.

만약 그것이 마이너스 파이와 파이 사이에 있다면, 나는 x의 지수의 두 배를 반환하고, x 더하기 파이를 둘로 곱한다.

그렇지 않으면, 그것이 파이보다 크면, 나는 지수의 두 배를 반환한다.

훌륭하지만, 많은 양의 데이터가 있다면, 스칼라 루프가 허용하는 것보다 더 빨리 실행하고 싶을 수도 있습니다.

그래서 내가 그것을 simd에서 구현하는 방법을 보여줄게.

나는 이미 몇 가지 상용구, 버퍼에 벡터를 쉽게 쓸 수 있는 확장, 그리고 한 번에 하나의 길이 8개의 벡터 단위로 출력 배열을 반복하는 간단한 루프를 가지고 있다.

흥미로운 부분은 우리의 스칼라 함수를 simd 등가물로 변환하는 방법이다.

스칼라 코드를 다시 살펴보는 것으로 시작합시다.

나뭇가지가 몇 개 있는 것 같아.

이것들은 벡터화에 잘 작동하지 않는다.

대신, 마스크를 기반으로 병합할 수 있는 부품으로 이것을 구성합시다.

더 자세히 살펴보면, x가 마이너스 파이보다 작다면, 나는 그냥 0을 반환한다.

만약 그것이 더 크다면, 나는 x의 두 배 지수를 포함하는 표현을 반환한다.

그걸 꺼내자.

이제, 우리는 그 y에서 벡터를 구성하고 싶고, x가 빼기 pi보다 적은 모든 곳에서 0으로 대체하고 싶습니다.

다음으로, 우리는 케이스보다 더 큰 것을 볼 수 있다.

여기서, 우리는 높은 영역에서 1을 곱하거나, 중간 영역에서 x 더하기 pi를 2로 곱하고 있다.

그러니 그걸 같은 방식으로 쓰자.

우리는 두 개의 표현식에 x 더하기 파이를 취하고 이번에는 x가 요소적으로 파이보다 크거나 같은 모든 곳에서 하나로 대체하고 있습니다.

이제 남은 것은 이 두 양을 함께 곱하는 것이다.

분명히, 0 원소라면, b의 값 중 하나를 곱하면 여전히 0을 반환한다.

그래서 그것을 실행하고 그것이 어떻게 보이는지 봅시다.

이제, 나는 콘솔을 내려다보며 내 새로운 simd 버전이 이전 스칼라 코드보다 거의 3배 더 빠르다는 것을 알 수 있다.

그래서 이 릴리스에서 simd는 어떻게 개선되나요?

우리는 템플릿을 사용하여 C++ 프로그래머의 유용성을 개선했습니다.

복잡한 코드 구조나 유사한 유형을 직접 구현할 필요 없이 기본 스칼라 유형과 벡터 길이와 구체적인 simd 유형 사이를 이동할 수 있도록 유형과 특성 구조를 추가했습니다.

그들의 사용을 단순화하기 위해, 우리는 또한 C++ 상용구에 대한 필요성을 줄이기 위해 편리한 별칭을 추가했습니다.

여기 그들이 어떻게 사용되는지에 대한 예가 있습니다.

벡터 및 매트릭스 유형을 사용하면 float 또는 int와 같은 기본 유형과 벡터 길이에서 구체적인 유형으로 이동할 수 있으며, 비교로 인한 정렬되지 않은 버전 및 마스크 유형과 같은 관련 유형에 대한 액세스를 제공하는 구성원도 있습니다.

Vector_t와 Matrix_t 별칭은 이전과 동일한 정의에 접근할 수 있는 단순화된 구문을 제공한다.

Get_traits 구조체는 우리가 다른 방향으로 갈 수 있게 해주며, 콘크리트 심드 유형에서 일반 유형으로 이동할 수 있게 해준다.

그리고 다시, 일반적인 사용 사례에 대한 구문을 단순화하기 위한 별칭이 있다.

우리는 또한 템플릿 코드에서 사용할 수 있도록 만들기 및 변환 함수의 템플릿 버전을 추가했습니다.

이것들은 기존 함수와 동일하게 작동하지만, 대상 유형은 이제 함수 이름의 일부가 아닌 템플릿 매개 변수입니다.

C++ 개선 외에도, 우리는 모든 언어에서 지원되는 몇 가지 새로운 기능을 추가했습니다.

이것들은 libm에서 스칼라 함수의 벡터 버전뿐만 아니라 감마 함수를 계산하기 위한 새로운 함수와 simd 행렬의 추적을 제공하는 isfinite 및 isinf와 같은 분류 함수입니다.

이제, 애플 아카이브와 우리의 새로운 애플 암호화 아카이브 형식을 소개합니다.

애플 아카이브는 10년 동안 시스템 업데이트에 전력을 공급해 왔다.

macOS 11 릴리스에서, 우리는 당신에게 압축된 컨테이너와 아카이브 형식에 대한 액세스를 제공했습니다.

macOS 12의 새로운 기능, 우리는 이 지원에 암호화를 위한 API를 추가했습니다.

아카이브 형식 자체는 현대적인 모듈식 접근 방식을 제공하여 저장할 파일 속성과 메타데이터를 정확히 선택할 수 있습니다.

스트리밍이 가능합니다. 즉, 전체 데이터를 메모리에 한 번에 맞추는 것에 대해 걱정할 필요가 없습니다.

또한 파일 시스템 이미지와 같은 대규모 아카이브로 인덱싱하기 위한 별도의 매니페스트 파일을 지원합니다.

새로운 애플 암호화 아카이브는 압축, 인증된 암호화 및 디지털 서명을 단일 보안 패키지로 결합하여 이를 기반으로 합니다.

그것은 당신에게 우리의 보안 팀과 외부 전문가들에 의해 설계되고 감사된 최첨단 암호화를 제공합니다.

데이터 기밀성은 당신의 데이터가 비밀로 유지된다는 것을 의미합니다.

데이터 신뢰성은 전송 중에 손상되지 않았다고 확신할 수 있다는 것을 의미합니다.

발신자 인증은 누가 그것을 보냈는지 확신할 수 있다는 것을 의미합니다.

서명 개인 정보 보호는 공개 키 맥락에서 당신과 발신자만이 누가 서명했는지 알고 있다는 것을 의미합니다.

우리는 또한 파일 길이와 같은 메타데이터를 난독화하고 사임 공격 보호를 포함합니다.

함께, 이것은 당신의 데이터가 비공개로 안전하게 유지된다는 것을 확신할 수 있다는 것을 의미합니다.

올바른 배포를 용이하게 하기 위해, 우리는 다양한 사용 사례에 대해 다양한 프로필을 제공합니다.

기본 프로필은 암호화 없이 디지털 서명을 갖는 것이다.

이것은 내용이 비밀이 아닌 소프트웨어 업데이트와 같은 것에 사용될 수 있지만, 데이터가 변조되지 않았는지 확인하고 싶습니다.

다음으로, 우리는 안전하게 공유된 바이너리 키를 사용하여 서명 유무에 관계없이 대칭 암호화를 사용합니다.

이것은 이진 키가 아닌 비밀번호를 사용하는 다음 옵션과 유사합니다.

마지막으로, 우리는 서명 유무에 관계없이 완전한 공개 키 암호화를 가지고 있습니다.

모든 프로필에서 압축은 선택 사항이며 데이터는 항상 인증됩니다.

이러한 형식으로 작업하기 위해, 우리는 많은 명령줄 도구를 제공합니다.

형식의 압축된 아카이브 부분으로 작업하려면 compression_tool이 있고, 암호화된 아카이브의 경우 aea가 있습니다.

Aa 도구는 전체 컨테이너를 처리한다.

물론 스위프트와 C 모두에서 애플 아카이브 프레임워크에서 제공하는 API도 있다.

그것은 스트림 기반이며, 순차적 및 무작위 액세스를 모두 허용합니다.

그것의 구현은 놀랍도록 빠른 성능을 위해 멀티스레드이다.

그래서, 이 API가 작동하는 것을 봅시다.

여기, 우리가 함께 만든 간단한 데모 앱이 있습니다.

창의 상단 부분은 우리가 암호화하고 싶은 것들의 드래그 앤 드롭 대상 역할을 하는 반면, 하단 부분은 간단한 상태 창이다.

이 TopSecret 디렉토리를 암호화하고 싶다고 가정해 봅시다.

난 그냥 이걸 앱에 끌어다 놓는다.

그리고, 오 안 돼! 우리는 실수를 한다.

우리는 아직 이 기능을 구현하지 않았어!

지금 그렇게 하자.

그래서, 애플 아카이브로 이것을 암호화하려면 어떻게 해야 하나요?

먼저, 우리는 암호화 비밀과 함께 사용할 알고리즘과 프로필을 설명하는 암호화 컨텍스트가 필요합니다.

우리는 또한 아카이브를 작성할 파일 스트림이 필요합니다.

우리는 이것들을 결합하여 암호화 스트림을 만듭니다.

암호화 스트림은 바이트 스트림을 암호화하므로, 암호화하려는 디렉토리를 변환할 어댑터가 필요합니다.

이것은 인코더 스트림입니다.

물론, 데이터는 객체 생성과 반대 방향으로 흐른다.

우리는 아카이브 항목을 인코더 스트림에 공급하여 암호화 스트림의 바이트로 변환한 다음 암호화된 데이터를 파일 스트림으로 출력합니다.

그게 코드에서 어떻게 보이는지 보자.

여기서, 우리는 대칭 프로필을 사용하고 있다고 명시합니다.

그리고 "없음"은 우리가 디지털 서명을 사용하지 않을 것이라고 말한다.

열거형의 초기 부분은 우리가 사용하고 싶은 특정 알고리즘을 지정한다.

여기서, 우리는 데이터를 압축하기 위해 "lzfse"를 사용할 것이다.

컨텍스트가 생성되면, 대칭 암호화 키를 지정하기만 하면 됩니다.

다음으로, 우리는 그 세 개의 스트림을 만든다.

먼저, 파일 스트림을 만든 다음 컨텍스트와 결합하여 encryptionStream을 만듭니다.

마지막으로, 우리는 인코더스트림을 도출한다.

이제, 우리가 이 스트림을 올바른 순서로 닫는 것을 기억하는 것이 중요하다.

특히, encryptionStream을 닫는 것은 아카이브에 서명하고 봉인하기 때문에 무대 뒤에서 많은 일을 한다.

마지막으로, 남은 것은 우리가 파일을 encoderStream에 공급하는 것뿐입니다.

인코딩할 파일 속성을 지정한 다음 writeDirectoryContents 메소드를 호출합니다.

남은 것은 암호화 키로 콘솔에 상태 메시지를 인쇄하는 것뿐입니다.

그게 효과가 있는지 보자.

TopSecret 디렉토리를 앱에 드롭하면, 성공하고, 암호화하고, 암호화 키를 출력합니다.

이제, 암호화된 아카이브를 앱으로 끌어다 놓으면, 암호를 해독하려고 시도하고 암호화 키를 요청합니다.

그러니 그 암호화 키를 복사하여 붙여넣고 안에 무엇이 있는지 봅시다.

음, 맛있어!

그게 내가 애플 암호화 아카이브에 가지고 있는 전부야, 그러니 마무리하자.

오늘, 저는 BNNS의 새로운 레이어 유형에 대한 지원과 simd.h의 확장된 C++ 지원 및 기타 기능을 포함하여 Accelerate 프레임워크의 개선 사항에 대해 이야기했습니다.

그런 다음 Apple 아카이브와 새로운 Apple 암호화 아카이브 형식과 프레임워크에 대한 지원을 소개했습니다.

감사합니다 그리고 나머지 WWDC를 즐기세요.

♪