10253

♪ 베이스 음악 연주 ♪

♪

베카 로얄-고든: 안녕하세요, 저는 스위프트 컴파일러 팀의 베카입니다.

나는 오늘 스위프트에서 DSL을 어떻게 구현할 수 있는지에 대해 이야기할 것이다.

만약 당신이 그 용어를 들어본 적이 없다면, DSL은 도메인별 언어이며, 그 이름이 당신에게 새로운 것이더라도, 당신은 아마 전에 그것을 사용한 적이 있을 것입니다.

나는 DSL이 실제로 무엇이고 스위프트에서 어떻게 생겼는지 설명하는 것으로 시작할 것이다.

그러면 나는 결과 빌더가 어떻게 작동하는지 설명할 것이다.

그것들은 스위프트 DSL을 구현하는 데 사용되는 주요 기능 중 하나이다.

그 후, 샘플 앱인 Fruta의 일부를 위한 간단한 DSL을 설계하는 과정을 안내해 드리겠습니다.

그리고 마지막으로, Fruta 샘플 코드에 있는 구현을 작성하는 방법을 보여드리겠습니다.

하지만 그 약어를 조금 더 잘 설명하는 것으로 시작합시다.

DSL은 "도메인"이라고 불리는 특정 영역에서 작동하는 프로그램을 위해 설계된 일종의 소형 프로그래밍 언어이다.

언어는 특정한 종류의 작업을 염두에 두고 설계되었기 때문에, 그런 종류의 작업을 더 쉽게 할 수 있는 특별한 기능을 가질 수 있다.

따라서 범용 언어 대신 DSL에 대한 코드를 작성할 때, 정확한 문제에 특정한 것만 작성하면 됩니다.

많은 DSL은 선언적이다.

즉, 당신은 문제를 해결하기 위한 정확한 지침을 쓰고 있지 않습니다; 그것은 당신이 그 언어로 문제를 설명하고, 그리고 나서 당신을 위해 그것을 해결하는 것과 같습니다.

이것을 하는 전통적인 방법은 "독립형 DSL"이라고 불립니다.

당신은 처음부터 전체 언어를 디자인하고 그것을 위한 인터프리터나 컴파일러를 작성할 것입니다.

임베디드 DSL은 더 현대적인 대안이다.

임베디드 DSL에서는 Swift와 같은 호스트 언어의 내장 기능을 사용하여 DSL의 암시적 동작을 코드의 일부 부분에 추가하여 호스트 언어를 도메인에 맞게 효과적으로 수정합니다.

이것은 이미 구문의 기초를 결정하고 이미 컴파일러가 있는 기존 언어에서 시작하기 때문에 전체 언어를 설계하고 컴파일러를 작성하는 것보다 분명히 훨씬 쉽습니다.

또한 DSL 코드를 비DSL 코드와 더 쉽게 혼합할 수 있습니다.

종종 당신은 훨씬 더 큰 앱의 한 부분인 문제를 해결하기 위해 DSL을 사용하고 싶습니다.

독립형 DSL을 작성하고 있다면, 한 언어에서 다른 언어로 전화하는 방법을 설계해야 합니다.

임베디드 DSL을 사용하면 DSL에 작성된 부분이 나머지 앱의 일반 코드처럼 보이기 때문에 상호 운용 시간이 훨씬 쉬워집니다.

임베디드 DSL은 또한 호스트 언어를 위해 설계된 도구를 사용할 수 있다.

당신은 이미 스위프트를 위한 디버거와 편집기를 가지고 있으며, 그것들은 스위프트 DSL에서 잘 작동합니다; 독립형 DSL을 원한다면, 직접 작성해야 합니다.

그리고 당신이 호스트 언어에서 시작하기 때문에, 이미 그 언어를 알고 있는 고객들은 배울 것이 훨씬 적습니다.

그들은 이미 변수를 선언하는 방법이나 "else if"에 공백이 있는지 알고 있습니다. 그들이 배워야 할 것은 언어를 어떻게 사용자 정의했는지입니다.

스위프트는 임베디드 DSL을 지원하도록 설계되었습니다.

그리고 사실, 만약 당신이 SwiftUI를 사용했다면, 당신은 이미 하나를 사용했습니다.

SwiftUI 뷰 DSL은 장치 화면의 뷰 레이아웃을 설명하고 싶다고 가정합니다.

따라서 SwiftUI DSL로 작성할 때, 사용자 지정 코드는 단순히 뷰를 만들고, DSL은 SwiftUI가 처리할 트리를 구축할 책임이 있습니다.

DSL의 가치를 이해하려면, 대신 일반 Swift로 뷰를 작성한다면 SwiftUI가 어떨지 생각해 보세요.

뷰를 만들고, 수정하고, 다른 뷰에 추가하고, 마지막에 하나를 반환해야 합니다.

당신은 개별 뷰를 보유하기 위해 모든 곳에서 임시 변수를 만들 것이며, 그 결과는 DSL과 같은 방식으로 뷰가 중첩되는 방식을 실제로 전달하지 않을 것입니다.

당신은 더 많은 코드를 쓸 것이지만 그것은 더 적은 의미를 전달할 것이다.

대조적으로, SwiftUI DSL은 그 모든 지루한 세부 사항을 암시적으로 만든다.

견해를 설명하는 것은 당신의 일입니다; 당신이 설명하고 있는 견해를 수집하고 그것들을 보여주는 방법을 알아내는 것은 DSL의 일입니다.

하지만 DSL은 구현하기 위해 추가적인 노력이 필요하며, 사용하기 위해 추가적인 노력이 필요하다.

그래서 언제 만들고 싶어?

음, 어렵고 빠른 규칙은 없지만, 여기에 당신이 하나를 사용하고 싶을 수도 있다는 몇 가지 징후가 있습니다.

바닐라 스위프트를 사용하는 메커니즘이 코드의 의미를 모호하게 하는 곳을 찾으세요.

무언가를 변경할 때마다 쉼표와 대괄호와 괄호를 재정렬하거나 제어 흐름을 수용하기 위해 임시 배열에 추가해야 하는 시간의 절반을 소비하는 곳.

가장 좋은 접근 방식이 코드로 무엇을 해야 할지에 대한 지침을 직접 작성하는 대신 코드의 다른 부분에 무언가를 설명하는 것입니다.

예를 들어, 서버 측 웹 프레임워크에는 지원하는 URL에 대한 핸들러를 등록하는 영역이 있을 수 있습니다.

핸들러 메소드를 반복해서 호출하는 대신, 클라이언트가 각 URL과 핸들러를 선언할 수 있도록 DSL을 설계한 다음 프레임워크가 자동으로 등록할 수 있습니다.

주요 직업이 프로그래밍이 아닌 사람들이 유지할 코드의 일부를 찾으세요.

예를 들어, 당신이 텍스트 어드벤처 게임을 쓰고 있다고 상상해 보세요; 소수의 개발자만이 대부분의 코드에서 작업할 것이지만, 객실 지도는 게임 디자이너에 의해 업데이트될 것이며, NPC 대화는 작가에 의해 추가될 것입니다.

아마도 DSL은 그들의 일을 더 쉽게 만들 것이다.

그리고 DSL에서 많은 마일리지를 얻을 수 있는 상황을 찾으세요.

도서관은 많은 다른 고객들이 사용하기 때문에 좋은 예이다.

하지만 좋은 DSL은 또한 당신이 많이 정의하는 프로젝트에서 무언가를 처리할 수 있으며, 심지어 자주 읽거나 업데이트해야 하고 가능한 한 쉽게 만들고 싶은 것을 처리할 수 있습니다.

DSL을 만드는 이유가 무엇이든, 설계하고 구현하는 데 약간의 노력이 필요할 뿐만 아니라 고객이 배우는 데 약간의 노력이 필요하다는 사실과 균형을 맞춰야 합니다.

방법과 배열 리터럴이 DSL만큼 좋다면, 그것들은 종종 정답이다. 왜냐하면 스위프트 프로그래머들은 이미 그것들을 어떻게 사용하는지 정확히 알고 있을 것이기 때문이다.

하지만 때때로, SwiftUI처럼, DSL이 정답이다.

그래서 넌 어떻게 하나 만들어?

음, SwiftUI DSL을 구축하기 위해 Swift 기능이 어떻게 함께 사용되는지 분석해 봅시다.

스위프트의 일반적으로 깨끗한 구문 외에도, SwiftUI DSL은 네 가지를 활용한다.

부동산 포장지.

이것들은 고객이 DSL 동작과 관련된 변수를 선언할 수 있게 해준다.

후속 폐쇄 논쟁.

이를 통해 DSL은 언어에 추가된 사용자 지정 구문과 거의 같은 기능이나 이니셜라이저를 제공할 수 있습니다.

결과 건축업자.

이것들은 DSL 코드에서 계산된 값을 반환 값으로 수집하여 처리할 수 있습니다.

그리고 마지막으로, 수정자 스타일의 방법.

이것들은 기본적으로 호출된 값의 래핑되거나 수정된 버전을 반환하는 방법일 뿐입니다. 결과 빌더는 코드로 계산된 값을 수집하기 때문에, 이 패턴은 그들과 정말 잘 작동합니다.

이제, 부동산 포장지는 이미 2019년부터 이 세션의 마지막 절반에서 다루어졌기 때문에, 나는 오늘 그들에 대해 많이 이야기하지 않을 것이다.

하지만 이 다른 세 가지, 특히 결과 빌더들은 이 세션의 주요 주제가 될 것이다.

후행 클로저와 수정자 스타일 방법은 많은 스위프트 프로그래머들이 익숙한 것이지만, 결과 빌더는 더 비하인드 스토리 기능이다.

그래서 우리가 그들과 함께 DSL을 만들기 시작할 수 있도록 그들이 어떻게 작동하는지에 대해 이야기해 봅시다.

결과 빌더는 DSL에서 생성된 값을 수집하고 언어가 원하는 데이터 구조로 결합하는 데 사용됩니다.

그것들은 특별한 유형을 선언한 다음 그 유형을 속성으로 사용할 수 있다는 점에서 속성 래퍼와 비슷합니다.

특히, 함수나 메서드, 계산된 속성의 게터 또는 클로저와 같은 반환 값을 가진 거의 모든 함수 본문에 결과 작성기를 적용할 수 있습니다.

결과 빌더를 함수 본문에 적용할 때, 스위프트는 결과 빌더의 정적 메서드에 대한 다양한 호출을 삽입합니다.

이것들은 결국 폐기되었을 진술의 결과를 포착하게 된다.

그래서 스위프트가 일반적으로 반환 값을 무시하는 경우, 대신 결과 작성기에 전달됩니다.

이러한 호출은 궁극적으로 함수 본문에서 반환되는 값을 계산한다.

따라서 함수를 호출할 때, 그 함수의 모든 문을 정상적으로 실행하고, 생성된 값을 수집하고, 클로저의 결과가 되는 단일 값으로 결합합니다.

결과 빌더는 컴파일 타임 기능이므로, 앱이 실행될 모든 OS에서 작동합니다.

오픈 소스 스위프트 에볼루션 제안 289의 이 기능의 최종 버전은 스위프트 5.4에 포함되었으므로 4월에 Xcode 12.5로 출시되었다.

하지만 그 전에 기능의 프로토타입을 사용할 수 있었기 때문에, 프로토타입을 사용하는 오래된 튜토리얼이나 라이브러리를 볼 수 있습니다.

그들은 "결과 빌더" 대신 "기능 빌더"라고 말할 것이며, 최종 기능과 일치하지 않을 수도 있습니다.

그래서 저는 이전에 SwiftUI DSL에 사용된 기능을 지적했지만, 이제 그것들이 어떻게 작동하는지에 대해 이야기해 봅시다.

일부 SwiftUI 유형의 관련 없는 부분을 제거하고 컴파일러에서 생성된 변수에 대해 v0과 같은 가짜 변수 이름을 보여주는 것과 같은 몇 가지 세부 사항을 단순화할 것입니다. 하지만 이것은 기본 사항을 이해하는 데 도움이 될 것입니다.

가장 먼저 깨달아야 할 것은, 최상위 수준에서, 새로운 구문처럼 보이는 블록이 있는 이 VStack은 실제로 후행 폐쇄 인수라는 것이다.

VStack이 무엇인지 찾아보면, 그것이 SwiftUI의 구조체라는 것을 알 수 있다.

그래서 후행 폐쇄 인수는 그 구조체에서 이 이니셜라이저로 전달된다.

이제, 클로저가 전달되는 매개 변수를 볼 때, ViewBuilder 속성이 있다는 것을 알 수 있습니다.

그 속성은 컴파일러에게 ViewBuilder라는 결과 빌더를 클로저에 적용해야 한다고 알려줍니다.

하지만 뷰빌더가 뭐야?

음, 우리는 그 이름으로 유형을 찾고, SwiftUI에서 이 유형을 다시 찾습니다.

컴파일러에게 결과 빌더라고 알리기 위해 어떻게 @resultBuilder 속성을 가지고 있는지 주목하세요.

이제 스위프트가 결과 빌더 유형을 찾았으므로, 클로저에 적용하기 시작합니다.

가장 먼저 하는 일은 결과를 생성하는 모든 진술에 대한 변수를 만드는 것이다.

이러한 변수가 생성되면, ViewBuilder의 buildBlock 메소드에 대한 호출을 작성하고 모든 변수를 전달합니다.

buildBlock의 임무는 모든 매개 변수를 단일 값으로 처리하거나 결합하여 반환하는 것입니다.

그런 다음 컴파일러는 클로저에서 buildBlock의 결과를 반환하는 반환 문을 작성합니다.

그래서 기본적으로, 컴파일러는 당신의 코드를 가지고 노란색으로 코드를 추가하여 ViewBuilder가 당신이 만든 모든 값을 VStack이 콘텐츠로 사용할 단일 값으로 조립할 수 있도록 했습니다.

이제, 저는 수정자 스타일의 방법이 이것에 어떻게 맞는지 지적하고 싶습니다.

수정자 스타일의 메서드는 수정된 자체 복사본 또는 새로운 동작을 추가하는 다른 유형으로 래핑된 자체 복사본을 반환합니다.

그리고 그것은 애초에 자아를 창조한 것과 같은 진술 내에서 이것을 한다.

그래서 그것은 결과 작성기가 그것을 보기 전에 값을 바꾸게 된다.

그리고 그 메소드의 결과에 대해 다른 수정자 스타일의 메소드를 호출할 수 있으므로, 결과 빌더가 값을 보기 전에 여러 변경 사항을 적용하고 함께 구성할 수 있습니다.

수정자를 구성하는 능력과 결과 빌더가 보기 전에 값을 수정한다는 사실이라는 두 가지는 스위프트 DSL이 종종 수정자를 사용하는 이유입니다.

그 둘은 그냥 잘 어울려.

이제, 우리가 결과 빌더를 설계할 때 걱정했던 한 가지는, 그들이 당신이 스위프트의 행동을 너무 급진적으로 바꾸도록 한다면, 고객은 DSL의 어떤 것도 일반 스위프트 코드처럼 작동한다는 것을 믿을 수 없다는 것입니다.

그래서 우리가 결과 빌더를 설계했을 때, 우리는 유용한 DSL을 만들기에 충분한 전력을 갖는 것과 스위프트의 기능이 여전히 고객이 기대하는 대로 작동하는지 확인하는 것 사이에서 균형을 맞추려고 노력했습니다.

결과 빌더는 고객이 작성한 코드를 근본적으로 재해석하지 않는다.

문은 여전히 줄 바꿈으로 끝나고, 호출은 여전히 괄호를 사용하며, 중괄호는 여전히 일치해야 합니다. 스위프트 구문의 모든 기본은 고객이 기대하는 방식으로 작동합니다.

그들은 또한 같은 장소에 쓰여진 일반 코드에서 볼 수 없는 새로운 이름을 소개하지 않는다.

결과 빌더를 사용할 때 별로 의미가 없는 몇 가지 언어 기능이 있습니다. 대부분 캐치 또는 브레이크와 같은 것들은 문 결과를 캡처하고 사용하는 아이디어에 잘 맞지 않는 방식으로 제어 흐름을 방해합니다.

결과 빌더를 사용할 때 이러한 기능은 비활성화됩니다.

그리고 결과 빌더가 이를 구현하는 데 사용되는 추가 방법을 제공하지 않는 한 비활성화된 경우, 스위치 및 for-in 문과 같은 몇 가지 기능이 있습니다.

하지만 스위프트가 키워드를 사용할 수 있다면, 평소처럼 작동할 것이다.

참 블록과 거짓 블록을 모두 실행하는 if-else 문이나 일부 요소를 건너뛰는 루프로 끝나지 않을 것입니다.

결과 빌더들은 그렇지 않았다면 버려졌을 진술 결과를 포착할 뿐, 그 이상은 아니다.

그래서 고객들은 그들에게 의지할 수 있다, 알다시피, 말이 된다.

좋아. 이제 우리는 결과 빌더가 무엇이고 어떻게 작동하는지 알 수 있게 되었으니, 우리는 그것들을 사용할 DSL을 설계하기 시작할 수 있어.

이전에 언어를 사용해 본 적이 없다면, 그 생각이 위협적일 수도 있지만, 스위프트 DSL을 설계하는 것은 실제로 스위프트 API를 설계하는 것과 매우 비슷합니다.

스위프트 API와 마찬가지로, 스위프트 DSL은 처음부터 시작하지 않습니다. 스위프트의 구문과 기능을 사용하여 해결하려는 문제와 관련된 아이디어와 행동을 표현합니다.

DSL은 API가 일반적으로 사용하지 않는 추가 기능을 사용하고 있다.

스위프트 API와 마찬가지로, 스위프트 DSL은 문제를 해결할 수 있는 여러 가지 다른 방식으로 설계될 수 있으므로, 당신의 임무는 대안을 생각하고 가장 좋다고 생각하는 것을 선택하는 것입니다. DSL은 잠재적인 솔루션의 훨씬 더 큰 공간을 가지고 있습니다.

그리고 스위프트 API와 마찬가지로, 스위프트 DSL의 가장 좋은 경험 법칙은 일반적으로 가장 명확한 사용 사이트를 만드는 디자인을 선택하는 것입니다.

DSL은 고객이 언어를 배우는 데 약간의 시간을 투자할 것이라고 가정하기 때문에, 이전에 한 번도 본 적이 없는 사람들에게 명확해지는 것을 덜 우선시한다.

따라서 이전에 API를 설계한 적이 있다면, DSL을 설계할 수 있는 좋은 출발점이 있습니다.

그리고 그 문제에 대해, 내가 DSL에 사용할 제안과 기술 중 일부는 API 설계로 정말 잘 전달된다.

이 강연에서, 우리는 Fruta 앱을 위한 DSL을 설계할 것이다.

Fruta 샘플 코드에서 이것의 작동 구현을 찾을 수 있습니다.

Fruta는 소스 코드에 15개의 스무디 레시피를 포함하고 있으며, DSL 이전에는 멤버와이즈 이니셜라이저를 호출하고 정적 상수에 할당하여 각 스무디를 만들었습니다.

그리고 나서 우리는 모든 스무디의 배열을 다른 정적 상수로 저장했고, 특정 보기가 인앱 구매가 필요한 레시피를 포함하기를 원하는지 여부에 따라 전체 목록을 반환하거나 유료 목록을 필터링합니다.

이제, 이것은 완벽하게 배송 가능하며 당신이 원한다면 그것을 고수할 수 있습니다.

하지만 스무디 레시피는 꽤 자주 업데이트되며, 나머지 앱과 달리 디자이너와 마케팅 담당자 및 관리자에 의해 업데이트되므로 DSL을 조금 덜 복잡하게 만들 수 있습니다.

그리고 우리가 지금 그것을 하는 방식을 보면, 나는 몇 가지 단점을 알아차리지 않을 수 없다.

유료 스무디를 목록에서 필터링해야 할 필요성은 이 코드를 왜곡시켰다.

allSmoothies와 hasFreeRecipe는 이 기능에서만 사용됩니다; 그렇지 않으면 존재할 필요가 없습니다.

그러나 당신이 그들 없이 이것을 구현하는 것을 상상하려고 한다면, 왜 우리가 그렇게 하지 않았는지 알 수 있습니다.

배열을 만들고 요소를 추가하는 메커니즘은 이 기능의 요점인 스무디의 실제 목록을 모호하게 하기 시작한다.

마찬가지로, 스무디 목록이 스무디 정의와 분리되어 있다는 사실은 조금 어리석다.

이러한 상수 중 일부는 미리보기에서 사용되지만, 대부분은 이 목록에만 나타납니다.

그리고 한 곳에서 스무디를 정의하고 다른 곳에서 목록에 추가하기 때문에, 실수할 수 있는 기회를 만듭니다.

새로운 스무디 상수를 선언하지만 목록에 추가하는 것을 잊어버리면 어떨까요?

아니면 스무디를 두 번 추가하면 어떡해?

개별 스무디의 정의를 되돌아보면, 나는 또한 나를 괴롭히는 다른 두 가지를 본다.

하나는 재료 목록이 믿을 수 없을 정도로 장황하다는 것이다.

예를 들어, 각 항목은 "측정"이라는 단어의 일부 버전을 세 번 반복한다.

이 줄에서, 우리가 신경 쓰는 실제 정보는 1.5컵의 오렌지이다.

나머지 줄은 유용한 것을 말하지 않는다; 그것은 단지 시각적 혼란일 뿐이다.

필연적으로 중요한 정보에 대한 지원 구문이 있을 것이지만, 이렇게 많을 때, 그 주변의 상용판은 우리가 전달하려고 하는 정보를 압도한다.

내가 알아차린 또 다른 것은 실제로 존재하는 정보의 양에 비해 각 스무디에 할당된 줄의 수이다.

나는 여기서 범인이 논쟁의 길이의 차이라고 생각한다.

이러한 주장 중 일부는 매우 짧고 한 줄에 맞을 수 있다.

다른 사람들은 더 길고 정말로 그들만의 라인이 필요하다.

이제, 짧은 인수를 한 줄로 결합한 다음 긴 줄에 대해 별도의 줄을 사용할 수 있지만, 대부분의 스타일 가이드는 그것에 눈살을 찌푸립니다.

우리는 그것들을 다르게 스타일링하는 것이 자연스러운 구문을 원합니다.

이것들을 모두 합치면 스무디 목록을 더 쉽게 유지할 수 있도록 DSL이 달성하기를 바라는 많은 목표가 있습니다.

이제, 다음으로 해야 할 일은 이러한 목표를 달성하기 위해 DSL을 설계할 수 있는 다양한 방법을 살펴보는 것이다.

이 점들 각각을 다룰 수 있는 수많은 다른 디자인들이 있다.

나는 내가 처음 세 가지 목표를 위해 무엇을 하기로 결정했는지 빠르게 설명할 것이고, 그리고 나서 우리는 마지막 목표를 더 자세히 살펴볼 수 있다.

나는 우리가 모든 방법으로 스무디 목록을 정의하기로 결정했다.

스무디는 정적 변수를 사용하지 않고 몸에서 직접 정의되므로, 누군가가 스무디를 정의하고 나열하는 것을 잊어버리는 것에 대해 걱정할 필요가 없습니다.

우리는 "SmoothieArrayBuilder"라는 결과 빌더를 사용하여 DSL을 활성화하고 스무디를 배열로 수집할 것입니다. 그렇게 하면 배열 리터럴을 사용하거나 임시 변수로 수집할 필요가 없습니다.

그리고 우리는 전에 했던 것처럼 목록을 필터링할 필요가 없도록 스무디를 넣을 수 있도록 할 것이다.

스위프트를 이미 알고 있는 고객은 if 진술이 어떻게 사용되는지 알 것이고, 그렇지 않은 고객은 아마도 "유료를 포함하는 경우"를 거의 문제도 이해하지 못할 것이기 때문에 이것은 훌륭하다.

나는 수정자 스타일의 방법을 사용하여 성분 양을 지정하기로 결정했다.

성분은 단위를 취하고 그 단위 중 하나로 측정된 성분을 반환하는 "측정(with:)"이라는 방법을 가질 것이다.

그 단위의 다른 양을 원한다면, 측정된 성분의 스케일링된(by: ) 수정자는 당신이 통과한 숫자를 곱한 양으로 반환합니다.

그래서 오렌지 한 컵은 1.5컵의 오렌지가 되고, 아보카도 한 컵은 아보카도 0.2컵이 된다.

이제, 왜 스케일링(by: ) 별도의 수정자인가요?

Fruta의 스크린 중 하나는 스무디 레시피에서 성분 양을 확장하는 데 사용할 수 있는 컨트롤을 가지고 있다.

우리는 이전에 수량을 곱한 각 성분 행에 승수를 전달했다.

하지만 나는 실제로 scaled(by: ) 수정자를 사용하여 행으로 전달되기 전에 재료를 스케일링할 수 있다는 것을 깨달았고, 이를 통해 행 보기를 단순화할 수 있었다.

그래서 내 스무디 DSL 디자인을 조금 조정함으로써, 나는 프로젝트의 다른 부분에서 그것의 일부를 재사용할 수 있었다.

그래서 우리의 처음 세 가지 목표를 달성하기 위한 변화와 함께, 우리는 새로운 DSL이 구체화되는 것을 보기 시작했다.

이제 마지막 목표에 집중합시다: 개별 스무디 항목을 재설계하여 더 컴팩트하게 만들고, 고객이 넘어질 수 있는 혼란스러운 구두점도 덜 있기를 바랍니다.

그것을 돕기 위해 이 정보를 정리할 수 있는 몇 가지 다른 방법을 살펴봅시다.

우리가 할 수 있는 한 가지는 수정자 스타일의 방법을 사용하여 설명과 재료를 추가하는 것이다.

이것은 효과가 있지만, 좀 장황하고 누군가가 설명을 잊어버리거나 두 번 또는 무언가를 지정하는 것은 쉬울 것이다.

우리가 할 수 있는 또 다른 일은 각 필드에 마커 유형을 부여하고 결과 빌더 폐쇄에 넣는 것이다.

하지만 이것은 우리가 피하려고 하는 ID와 제목을 그들 자신의 라인에 둔다.

그래서 우리는 ID와 제목을 매개 변수 목록으로 다시 옮기고, 다른 두 필드에 마커 유형을 사용할 수 있습니다.

하지만 나는 이것이 여전히 우리가 정말로 필요로 하는 것보다 조금 더 많은 의식이라고 느낀다.

나는 레시피의 사용자 인터페이스를 보았을 때 그것을 깨달았다.

그것들은 항상 특정 순서로 표시됩니다: 상단의 제목, 중간의 설명, 하단의 재료 목록.

그리고 우리는 제목이나 설명에 라벨을 붙이는 것을 귀찮게 하지 않는다.

우리는 그들의 시각적 계층 구조 - 제목이 설명보다 더 두드러지게 제시된다는 사실 -이 말을 하도록 내버려 두었다.

그래서 나는 그것에서 영감을 얻었고 우리의 스무디 DSL도 똑같이 해야 한다고 결정했다.

그것은 제목을 맨 위에, 설명은 중간에, 재료 목록을 맨 아래에 둔다.

그리고 그것은 설명이 아래에 있고 제목보다 더 들여쓰기되어 있다는 사실이 - 시각적으로 덜 두드러진다 - 설명 문자열의 의미를 전달하므로 라벨을 붙일 필요가 없습니다.

나는 그 결과가 불필요한 합병증 없이 즉시 이해할 수 있다고 생각한다.

그리고 우리가 그것을 DSL 전체의 맥락에 넣었을 때, 나는 우리가 꽤 편안한 착용감을 가지고 있다고 생각한다.

하지만 넌 동의하지 않을 수도 있고, 그건 괜찮아.

DSL은 프로그래밍 언어이며, 개인적인 취향과 주관적인 절충안은 모든 프로그래밍 언어 설계의 큰 부분이다.

그게 네가 엄격해서는 안 된다는 뜻은 아니야.

당신은 언어에서 원하는 것에 대한 명확한 생각으로 시작해야 합니다.

당신은 당신의 문제를 해결할 수 있는 if 진술과 같은 기존 해결책이 있는지 조사해야 합니다. 왜냐하면 당신이 친숙한 해결책을 채택할 수 있다면, 사람들은 새로운 해결책을 배울 필요가 없기 때문입니다.

당신은 언어의 각 부분이 나머지 부분과 어떻게 상호 작용하는지 생각해야 합니다.

스위프트 DSL에서, 그것은 또한 다른 곳에서 사용할 수 있기 때문에 스케일링된 수정자를 골랐을 때와 같이 DSL이 일반 스위프트 코드와 어떻게 상호 작용하는지 생각하는 것을 의미합니다.

컴파일 타임에 감지할 수 있거나 쓰기가 완전히 불가능한 실수를 할 수 있는 해결책을 찾아야 합니다.

당신이 기억한다면, 그것이 우리가 설명을 수정자로 만들지 않은 이유입니다; 당신은 우연히 그것을 빠뜨릴 수 있었습니다.

그 모든 것을 염두에 두고, 당신은 몇 가지 다른 가능성을 생각해내야 합니다.

그들 각각이 어떻게 사용될지 상상해 보세요, 작은 모형을 쓰세요; 알다시피, 서로 무게를 달아 보세요.

하지만 결국, 당신은 보통 다른 사람들이 분명히 틀린 곳에서 분명히 옳은 것을 찾지 못할 것입니다.

당신이 할 수 있는 일은 당신의 언어 고객에게 가장 적합하다고 생각하는 것을 고르는 것뿐입니다.

어느 것이 가장 좋은지 확실하지 않다면, 가장 읽기 쉬운 것을 선호해야 할 것이다.

그리고 그 후에도 여전히 확실하지 않다면...

음, 개인적으로, 나는 더 대담한 옵션을 선택하는 것을 좋아한다.

나는 그것을 시도하지 않고 궁금해하는 것보다 효과가 없다면 차라리 무언가를 시도하고 다시 걸어가는 것이 낫다.

이제 DSL이 어떻게 보일지 결정했으니, Fruta에 추가해 봅시다.

나는 이전의 스무디 정의를 DSL을 사용하는 최종 모든 방법으로 대체했지만, 아직 DSL을 구현하지 않았다.

놀랍지 않게도, 우리는 많은 오류가 있다.

하지만 그건 괜찮아.

우리가 이것을 해결하면서, 나는 이 오류들이 내가 해결해야 할 문제들로 나를 안내하도록 할 것이고, 결국 우리는 오류 없이 무언가를 만들 것이다.

그래서 이 첫 번째 오류로 함수의 상단에서 시작합시다: "알 수 없는 속성 'SmoothieArrayBuilder'."

결과 빌더는 아직 실제로 존재하지 않기 때문에, 물론 그것은 작동하지 않을 것이다.

그거 고치러 가자.

결과 빌더 속성으로 표시된 "SmoothieArrayBuilder"라는 유형을 만드는 것으로 시작하겠습니다.

이제, 스위프트는 실제로 이러한 유형의 인스턴스를 만들지 않을 것이다; 그것은 단지 많은 정적 방법을 위한 컨테이너일 뿐이다.

그래서 나는 그것을 열거형으로 만들었고 어떤 사례도 정의하지 않을 것이다.

사례가 없는 열거형의 인스턴스를 만드는 것은 불가능하기 때문에, 이것은 사람들이 그것을 잘못 사용하는 것을 방지한다.

이것만 빌드하면, 결과 빌더에 buildBlock(_:) 메소드가 필요하다는 오류가 발생할 것이다.

그것은 하나를 삽입할 수정을 가지고 있으므로, 나는 그 수정을 받아들일 것이고 우리는 그것을 구현하는 방법을 알아낼 것이다.

이제, 이전부터 기억한다면, buildBlock(_:)이 작동하는 방식은 이와 같은 코드가 많은 개별 문이 있는 경우, 각 문이 변수에 할당되고, 변수는 모두 buildBlock(_:)에 전달되고, buildBlock(_:)에 의해 반환된 값은 클로저에 의해 반환된다는 것입니다.

그래서 우리의 buildBlock(_:) 메소드는 많은 스무디를 매개 변수로 받아들이고 스무디 배열을 반환해야 한다.

원하는 수의 스무디를 방법으로 전달할 수 있도록 가변 매개 변수를 사용하여 구현한다면...

...그리고 짓다...

...글쎄, 우리가 얻는 것은 조금 더 나아.

여전히 많은 오류가 있지만, 스무디 배열 빌더가 유효하지 않은 속성이라고 말하는 것은 사라졌고 속성은 알려진 유형임을 나타내기 위해 색상을 변경했습니다.

그럼 다음 오류, 스무디 이니셜라이저를 위한 오류로 넘어가자.

하나는 우리가 문자열 매개 변수에 후행 폐쇄를 전달하고 있다고 말한다.

다른 하나는 우리가 측정된 재료 논쟁을 놓치고 있다고 말한다.

그래서 분명히 우리는 설명과 재료를 매개 변수로 기대하는 오래된 이니셜라이저를 사용하고 있습니다.

우리는 새로운 것을 만들어야 할 거야.

따라서 ID, 제목 및 설명과 재료를 반환하는 후행 클로저로 이니셜라이저를 구현합시다.

지금 당장 말해줄게, 우리는 나중에 이 이니셜라이저로 돌아와야 할 거야.

내가 지금 당장 만들면, 그것은 스무디 이니셜라이저의 모든 오류를 제거하므로, 당신은 이것이 완벽하게 작동하고 있다고 생각할 수도 있습니다.

하지만 그건 사실 약간 오해의 소지가 있어.

보시다시피, 스무디 어레이 빌더가 완료되지 않아 발생하는 if 문에 또 다른 오류가 있습니다.

그리고 그 오류가 있기 때문에, 스위프트는 아직 폐쇄의 내부를 확인하지 않고 있다.

예를 들어, 내가 이 클로저에 들어가서 존재하지 않는다는 것을 알고 있는 임의의 변수 이름을 쓴 다음 빌드하면, 스위프트는 오류를 표시하지 않습니다.

무슨 일이 일어나고 있는지는 스위프트가 결과 빌더가 올바르게 적용되지 않았다는 것을 알고 있기 때문에, 이러한 클로저에서 발견된 어떤 오류도 실제로 정확할 것이라고 믿지 않는다.

그래서 아직 거기서 오류를 찾고 있지 않아.

나중에, 우리가 스무디 어레이 빌더를 끝내면, 우리는 갑자기 그 오류를 보기 시작할 것이고 그 시점에서 그것들을 고칠 수 있다.

하지만 지금은 스무디 어레이 빌더에서 계속 작업하는 것이 더 쉽기 때문에, 그 폐쇄를 제쳐두고 다음 오류로 넘어가자.

이 오류를 보면, 스위프트는 스무디 배열 빌더와 함께 if 문을 사용할 수 없다고 말하지만, 이를 지원하기 위해 추가할 수 있는 방법이 있습니다.

만약 문이 이와 같은 몇 안 되는 스위프트 기능 중 하나라면; 결과 빌더가 이를 지원하기 위한 추가 방법을 구현하지 않는 한 비활성화됩니다.

그래서 이것을 구현하기 시작하려면, 여기서 수정하고 무엇이 추가되는지 봅시다.

그래서 분명히 우리는 선택적 스무디 배열을 취하고 스무디 배열을 반환하는 buildOptional(_:)이라는 메소드를 구현해야 합니다.

그래서 이 방법은 어떻게 사용되나요?

음, 다른 것이 없는 if 문이 있는 모든 방법의 단순화된 예를 들어 보세요.

If 문이 없는 이전 예제와 마찬가지로, 이것은 각 문의 결과를 변수로 캡처하고, 그 변수를 buildBlock(_:)에 전달하고, 클로저에서 buildBlock(_:)의 결과를 반환할 것입니다.

유일한 질문은, if 진술의 결과를 어떻게 포착할 것인가?

음, 가장 먼저 할 일은 if 문 본문의 모든 문을 변수로 캡처한 다음, 최상위 수준에서 하는 것처럼 buildBlock(_:)을 사용하여 해당 변수를 함께 결합하는 것입니다.

하지만 이것이 buildOptional(_:)이 들어오는 곳이다.

내부 buildBlock(_:) 호출의 결과를 반환하는 대신, Swift는 그것을 buildOptional(_:)에 전달하고, buildOptional(_:)에 의해 반환된 값은 전체 if 문의 값이 됩니다.

하지만 이것은 if 조건이 거짓이면 변수가 초기화되지 않은 채로 남겨둔다.

그것이 buildOptional의 매개 변수가 선택적 스무디 배열인 이유입니다.

스위프트는 if 문의 결과 값을 buildOptional(nil)의 반환 값으로 설정하는 다른 브랜치를 추가할 것이다.

SmoothieArrayBuilder의 경우, 이것의 결과는 buildOptional(_:)이 buildBlock(_:)에서 전달된 배열을 반환하거나 매개 변수가 nil인 경우 빈 배열을 반환하기를 원한다는 것입니다.

우리가 지금 그것을 짓는다면, 우리는...

...정말 이상하게 생긴 실수야.

유형 스무디 배열을 가변적인 인수로 전달할 수 없나요?

뭐?

음, 우리가 생성한 코드로 돌아가자.

If 문은 결국 일련의 스무디를 생산하게 된다.

하지만 사실, buildBlock(_:)은 스무디 배열을 원하지 않는다; 그것은 단일 스무디를 원한다.

우리는 그걸 바꿔야 할 거야.

그래서 우리는 buildBlock(_:) 스무디 배열을 인수로 만든 다음 flatMap(_:)을 사용하여 많은 스무디 배열을 단일 스무디 배열로 연결할 수 있습니다.

좋아! 그걸 만들어, 그리고...

...아니.

이제 우리의 if 진술은 효과가 있지만, 모든 스무디 라인이 깨졌다.

우리는 그것들이 좀 필요해.

스무디 유형의 값을 스무디 배열로 변환할 수 없습니다.

무슨 일이 있었나요?

음, 우리는 buildOptional(_:)에서 반환된 스무디 배열과 일치하도록 buildBlock(_:)을 변경했습니다.

하지만 우리는 그것이 일반 진술에 의해 반환된 개별 스무디와 일치해야 한다는 것을 잊었다.

이런.

기본적으로, 정교한 제어 흐름을 허용하려면, buildBlock의 반환 유형은 buildBlock(_:)에 매개 변수로 전달될 수 있는 것이어야 합니다.

당신이 이것을 성취할 수 있는 두 가지 방법이 있습니다.

한 가지 방법은 buildBlock(_:)과 다른 결과 작성기 메서드가 결과 작성기에서 허용된 문과 호환되는 유형을 반환하는지 확인하는 것입니다.

예를 들어, 이것이 SwiftUI의 ViewBuilder가 작동하는 방식이다.

SwiftUI DSL에서는 buildBlock(_:) 및 기타 뷰 빌더 메서드에서 반환된 유형을 포함하여 모든 것이 View 프로토콜을 준수합니다.

하지만 그것은 스무디 DSL에 적합하지 않습니다. 왜냐하면 SwiftUI 뷰와 달리, 당신은 다른 스무디 안에 스무디를 집어넣지 않기 때문입니다.

당신이 할 수 있는 또 다른 일은 결과 작성기가 일반 문 값을 buildBlock(_:)에서 반환한 것과 동일한 유형으로 변환하도록 하는 것입니다.

그게 이 DSL에 더 잘 맞아.

우리는 buildExpression(_:)이라는 메소드를 추가하여 그것을 할 수 있다.

buildExpression(_:) 메소드를 추가할 때, 스위프트는 변수로 캡처하기 전에 각 베어 표현식을 해당 메소드에 전달합니다.

그것은 우리에게 그것들을 배열로 변환할 수 있는 기회를 줄 것이다.

그러나 buildOptional(_:) 및 buildBlock(_:)에 의해 생성된 것과 같은 다른 결과 빌더 메서드에서 오는 값은 이러한 호출에 래핑되지 않으므로 이 변환이 적용되지 않습니다. 이는 이미 배열을 반환하고 있기 때문에 좋습니다.

그래서 우리가 할 일은 buildExpression(_:) 방법을 구현하는 것이다.

Xcode의 코드 완성은 결과 작성 방법에 대한 모든 것을 알고 있으므로, 서명을 작성하도록 요청할 수 있습니다.

그런 다음 매개 변수 유형을 스무디로 변경하고 배열 리터럴로 래핑된 표현식 매개 변수를 반환합니다.

그래서 이제 우리의 단일 스무디는 buildBlock(_:)이 필요로 하는 스무디 배열로 바뀔 것이다.

그걸 만들어, 그리고...

...환상적이야!

우리의 if 진술은 작동하고 스무디 이니셜라이저도 작동한다.

그러나, 우리가 미니맵을 보면, 여기에 작동하지 않는 두 번째 if 문이 있다는 것을 알 수 있을 것이다.

왜냐하면 이것은 다른 조항이 있기 때문이다.

buildOptional(_:)은 실제로 일반 if 문에서만 작동합니다.

Else 문이나 else-if 또는 스위치가 있는 경우, buildEither(first:)와 buildEither(second:)라는 한 쌍의 메서드를 구현해야 합니다.

Fix-it을 사용하여 이것들을 만든 다음 그들이 어떻게 작동하는지 이야기합시다.

그래서 if-else 문으로 이 단순화된 예시를 살펴봅시다.

대부분의 변환은 buildOptional(_:)과 같다.

buildOptional(_:)과 마찬가지로, 전체 if-else 문은 결국 하나의 변수를 채울 것이다.

그리고 buildOptional(_:)과 마찬가지로, if 문의 각 블록은 그 안에 있는 문이 변수로 캡처된 다음 buildBlock이 그것들을 하나의 값으로 결합하는 데 사용됩니다.

일반 if 문과 다른 점은 buildOptional(_:)을 사용하여 최종 값을 생성하는 대신 buildEither 방법 중 하나를 사용한다는 것입니다.

If와 else와 같은 두 개의 브랜치가 있다면, 첫 번째는 buildEither(첫 번째:)를 사용하고 두 번째는 buildEither(두 번째:)를 사용합니다.

그것은 당신이 그들을 구별하기 위해 어떤 지점을 가져갔는지 신경쓰는 결과 빌더를 허용합니다.

이제, 세 개 이상의 사례가 있다면 우리가 무엇을 할지 궁금하다면, 그것에 대한 답은 실제로 꽤 멋지다.

우리는 각 가지를 잎 중 하나로 균형 잡힌 이진 트리를 만든 다음, 비리프 노드를 우리가 해야 하는 호출로 취급하며, 가장자리는 buildEither(첫 번째:) 또는 buildEither(두 번째:)를 사용할지 여부를 알려줍니다.

우리는 각 지점이 어떤 호출 시퀀스를 사용해야 하는지 기록한 다음, 그 호출 시퀀스로 변수에 할당하는 코드를 생성합니다.

그래서 비록 우리가 두 가지 방법만 가지고 있지만, 결과 작성자는 여전히 세 가지를 구별할 수 있다.

그렇게 나쁘지 않아.

어쨌든, 이제 우리는 buildEther 메소드가 어떻게 작동하는지 알았으니, 우리는 계속해서 그것들을 쓸 수 있다.

그리고 SmoothieArrayBuilder는 실제로 당신이 어떤 브랜치를 가져갔는지 신경 쓰지 않기 때문에, 우리가 해야 할 일이 별로 없습니다. 그냥 배열 인수를 반환하세요.

그래서 이제 우리는 이것을 만들고, 그리고...

그건 여전히 잘 작동하지 않아.

하지만 우리는 가까워!

당신은 우리가 스무디 배열 문제가 있었을 때의 이런 종류의 오류를 기억할 것입니다. 지금은 스무디 유형에 대해 불평하지 않고 '()' 유형입니다.

그것은 빈 튜플이며, 당신이 아마 공허하다고 생각하는 유형이다.

우리가 생성된 코드에 대해 생각한다면, 이것이 왜 문제인지 이해가 된다.

우리는 buildExpression(_:)을 호출하고 있지만, 전달되는 표현식은 스무디가 아닌 Void를 반환하는 logger.log를 호출하는 것입니다.

그래서 우리는 Void 매개 변수를 취하고 빈 배열을 반환하는 buildExpression(_:)의 오버로드를 작성할 것입니다.

그런 다음 우리는 재구축하고, 이제 로그 호출이 제대로 작동합니다!

우리는 엄청나게 더 많은 오류가 있지만, 이것은 사실 좋은 소식이다.

보세요, 이 오류 중 첫 번째는 스위프트가 후행 클로저에서 오류를 찾지 못했다는 것을 보여주기 위해 처음에 추가한 가짜 변수에서 나온 것입니다.

이제 그것은 우리가 스무디 어레이 빌더를 끝냈다는 것을 의미합니다!

그래, 실수야!

그 가짜 변수를 삭제하고 남은 것을 봅시다.

자세히 살펴보면, 보이는 것보다 여기서 할 일이 적다는 것을 알게 될 것이다.

모든 설명 라인에는 동일한 경고가 있으며, 모든 성분 라인에는 동일한 두 가지 오류가 있습니다.

그래서 비록 우리가 100개의 오류와 12개의 경고를 가지고 있지만, 이것은 실제로 반복해서 일어나는 동일한 몇 가지 문제이다.

이 성분 라인 중 하나의 오류를 자세히 살펴봅시다.

컴파일러는 두 가지 불만이 있다: 어떤 유형의 컵을 찾아야 하는지 알아낼 수 없으며, 성분이 "측정"이라고 불리는 구성원을 가지고 있다고 생각하지 않는다.

음, 그건 말이 된다; 우리는 측정(with:) 또는 scaled(by:) 수정자를 구현하지 않았기 때문에, "측정"이라고 불리는 것을 찾을 수 없다.

그리고 그것은 컵이 무엇인지 전혀 모른다. 왜냐하면 측정된(with:)이 부피 단위를 취해야 한다는 것을 모르기 때문이다.

그러니 MeasuredIngredient.swift로 가서 이 두 수정자를 구현해 봅시다.

측정(with:)은 성분에 들어가서 발신자가 통과한 단위 중 하나로 측정된 성분을 반환합니다.

그리고 scaled(by:)는 측정된 성분에 가서 호출자가 통과한 척도를 곱한 측정으로 새로운 측정된 성분을 반환합니다.

스무디로 돌아가세요. 스위프트 그리고 만드세요...

...그리고, 알았어.

우리는 더 많은 경고와 몇 가지 오류만 보고 있다.

그리고 우리가 자세히 살펴보면, 우리는 한 종류의 경고만 볼 수 있습니다 - 클로저의 각 표현이 무시되고 있다는 것과 한 종류의 오류는 클로저에 반환 진술이 없다는 것을 알려주는 것입니다.

이유를 이해하기 위해, 이러한 후행 폐쇄와 결과 빌더가 그들과 어떻게 상호 작용하는지에 대해 이야기해 봅시다.

이 예에서, SmoothieArrayBuilder는 우리가 전에 본 것처럼 외부 문에 영향을 미칠 것이다.

그것들은 buildExpression(_:)에 전달되고, 변수에 저장되며, 변수는 buildBlock에 전달됩니다.

하지만 이 폐쇄는 어때?

결과 작성자는 그들에게 무엇을 할 것인가?

음, 그건 그래...

...클로저는 실제로 결과 빌더를 적용한 함수 내부에 중첩된 별도의 함수이기 때문에 절대 아무것도 아닙니다.

결과 빌더는 하나의 함수에만 적용됩니다; 그들은 그 안에 중첩된 함수나 폐쇄에 영향을 미치지 않습니다.

만약 당신이 그들이 결과 빌더의 영향을 받기를 원한다면, 당신은 그것을 다른 방식으로 그들에게 적용해야 합니다.

결과 빌더를 기능 본문에 적용하는 세 가지 방법이 있습니다.

첫 번째는 우리가 SmoothieArrayBuilder에서 했던 것처럼 함수나 속성에 직접 속성을 쓰는 것이다.

결과 빌더를 적용하는 두 번째 방법은 프로토콜의 함수 또는 속성 요구 사항에 작성하는 것입니다. 그런 다음 모든 준수 유형의 구현에 자동으로 적용됩니다.

그것이 SwiftUI Views의 본문 속성이 작동하는 방식입니다: ViewBuilder 속성은 View의 본문 요구 사항에 적용되므로 View의 본문 속성에도 자동으로 적용됩니다.

결과 작성기를 적용하는 세 번째 방법은 폐쇄 매개 변수 전에 작성하는 것입니다.

그렇게 하면, 스위프트는 그 매개 변수에 전달된 모든 클로저가 결과 빌더를 적용해야 한다고 추론할 것이다.

스위프트가 프로토콜이나 매개 변수에서 결과 빌더를 추론했고 실제로 적용되는 것을 원하지 않는다면, 반환 문을 사용하여 값을 명시적으로 반환하여 비활성화할 수 있습니다.

하지만 이 경우, 우리는 클로저를 사용하고 있기 때문에, 우리는 그 세 가지 옵션 중 마지막을 원합니다: 클로저 매개 변수에서 결과 빌더를 추론합니다.

우리는 인수 라벨 앞에 속성을 작성함으로써 그것을 한다.

이제, 우리는 여기에 SmoothieArrayBuilder를 쓸 수 있지만, 그것은 아마도 이것을 하는 가장 좋은 방법은 아닐 것이다.

SmoothieArrayBuilder는 다양한 스무디를 생산하지만, 우리는 이 폐쇄가 스무디를 생산하는 것을 원하지 않습니다. 우리는 그것이 문자열과 다양한 재료를 생산하기를 원합니다.

그리고 우리는 이 폐쇄에서 진술이나 무효 반환 호출도 필요하지 않습니다.

그래서 정말로, 우리는 이 폐쇄에 별도의 언어 규칙 세트를 적용하고 있으며, 두 번째 규칙 세트를 SmoothieArrayBuilder에 혼합하는 대신, 이러한 새로운 규칙을 구현하는 새로운 결과 빌더를 만드는 것이 더 합리적입니다.

그것을 SmoothieBuilder라고 부르고 새로운 유형을 만들고, buildBlock(_:) 메소드를 작성하기 시작합시다.

이제, 이건 조금 특별해.

우리는 많은 측정된 재료를 받아들이고 싶지만, 앞쪽에 끈을 가져가고 싶다.

그래서 우리는 그걸 어떻게 할 거야?

음, 기억하세요, buildBlock 방법만 있는 간단한 결과 빌더인 SmoothieBuilder가 어떻게 확장될지 생각한다면, 각 라인은 다른 매개 변수로 전달될 것입니다.

그래서 buildBlock의 시작 부분에 문자열 매개 변수를 쓸 수 있을 것 같고, 첫 번째 문은 MeasuredIngredient 대신 문자열을 생성해야 할 것 같습니다.

그러니까 그렇게 해보자.

문자열 매개 변수를 앞에 추가하고, 문자열의 튜플과 재료 배열을 반환하도록 합니다.

그리고 만약 우리가 짓는다면...

야, 그거 봐! 오류 제로!

우리 DSL이 작동해!

이제 결과 빌더는 for-in 루프와 최종 반환 결과 처리와 같은 몇 가지 기능을 더 지원합니다.

그것들을 사용하고 싶다면, 그것들은 스위프트 프로그래밍 언어 책에 설명되어 있습니다.

하지만 우리가 끝내기 전에, 나는 언어 디자인의 가장 중요한 부분 중 하나인 좋은 오류 메시지에 주목하고 싶다.

언어를 디자인할 때 배우는 것 중 하나는 유효한 코드보다 유효하지 않은 코드를 작성하는 방법이 더 많기 때문에 유효하지 않은 코드에 대해 방출할 오류에 대해 생각하는 데 시간을 할애해야 한다는 것입니다.

코드가 틀렸을 때 당신의 행동은 코드가 맞을 때만큼이나 중요합니다.

이제 스위프트 DSL의 경우, 스위프트의 오류 처리를 무료로 받을 수 있습니다.

하지만 클라이언트가 받을 오류 메시지는 일반적인 스위프트 코드를 위해 설계되었습니다.

그것들은 당신의 언어 규칙의 관점에서 표현되지 않았기 때문에, 그들은 당신의 고객에게 문제를 명확하게 전달하지 못할 수도 있습니다.

예를 들어, 누군가가 이 스무디 중 하나에 설명을 넣는 것을 잊었다고 상상해 보세요.

스위프트는 오류 메시지를 보낼 것이지만, 조금 불분명하다.

그것은 첫 번째 성분을 문자열로 변환할 수 없다고 불평한다.

그렇다면 이 코드는 어떻게 이 오류를 발생하게 되나요?

음, 스위프트 컴파일러는 스무디 DSL의 의미를 이해하지 못하고, 결과 빌더를 사용하기 위해 생성된 스위프트 코드의 의미만 이해합니다.

그래서 이 오류를 진단하려고 할 때, 이 값을 스무디나 첫 번째 성분에 대한 설명으로 생각하지 않는다.

그것은 그것을 빌드블록의 첫 번째 주장으로 생각한다.

buildBlock(_:)의 첫 번째 인수인 v0은 MeasuredIngredient이지만, 문자열 매개 변수로 전달되고 있다.

그래서 스위프트는 이 오류를 "MeasuredIngredient를 문자열 매개 변수에 전달하려고 하지만 MeasuredIngredient를 문자열로 변환할 수 없습니다."라고 생각합니다.

오류 메시지는 기술적으로 잘못된 것은 아니지만 별로 도움이 되지 않는다.

컴파일러 엔지니어는 이것에 대한 트릭을 가지고 있습니다: 우리는 컴파일러가 유효하지 않은 것을 지원하도록 하지만 당신이 그것을 할 때 오류가 발생합니다.

예를 들어, 스위프트의 함수 문법에는 던지기, 재던지기 또는 아무것도 쓸 수 있는 슬롯이 있습니다.

지원되지 않는 다른 단어를 작성하면, 컴파일러는 그것이 다른 문장의 일부여야 한다고 추측하고 세미콜론을 추가하거나 새 줄을 사용하라는 오류를 제공합니다.

하지만, "시도"를 구체적으로 쓰면, 다른 오류가 발생합니다.

컴파일러는 그것을 throws로 대체한 다음 대신 throws를 쓴 것처럼 파일의 나머지 부분을 구문 분석할 것을 제안합니다.

이것은 우리가 스위프트 파서에 추가한 특별한 경우이다.

우리는 개발자들이 때때로 던지기를 작성하려고 할 때 여기에 다른 오류 처리 키워드를 입력한다는 것을 알아차렸고, 그래서 우리는 언어의 공식 문법에 대한 작고 문서화되지 않은 확장을 만들었습니다.

우리는 여기서 잘못된 키워드를 구문 분석한 다음 특정 실수에 맞게 평소와 다른 오류를 진단합니다.

오류 동작을 개선하기 위해 결과 작성기에서 비슷한 일을 할 수 있기 때문에 이것을 지적합니다.

특히, 잘못된 코드와 일치하는 결과 작성 방법의 오버로드를 만든 다음 그 오버로드를 사용할 수 없는 것으로 표시하면, 진단할 때 사용할 오류 메시지를 지정할 수 있습니다.

그래서 문제를 잘 전달하지 못할 수도 있는 일반적인 오류를 얻는 대신, 고객은 그 실수에 맞는 더 구체적인 오류 메시지를 받게 될 것이다.

우리가 할 일은 buildBlock(_:)을 복사하고, 설명 매개 변수를 삭제하여 블록을 성분 목록과 일치시키고, 본문을 fatalError()로 대체하여 반환 값을 위조할 필요가 없습니다.

그 방법은 결코 성공적으로 호출되지 않을 것이므로, 몸은 유효한 것이 되어야 한다.

그런 다음 우리는 이 과부하를 사용할 수 없는 것으로 표시하고 문제를 더 명확하게 설명하는 메시지를 제공할 것입니다.

이 사용할 수 없는 주석은 그 방법을 실제로 사용할 수 없다는 것을 의미한다.

만약 당신이 그것에 전화를 쓴다면, 그것은 오류입니다.

그래서 이제, 내가 다시 맨 위로 올라와서 재건한다면, 나는 무엇이 잘못되었는지에 대해 훨씬 더 명확한 설명을 얻을 수 있다는 것을 알게 된다.

첫 번째 성분이 문자열이어야 한다고 말하는 대신, 설명 문자열이 누락되었다고 말한다.

그래서 고객은 그 성분이 틀렸다고 생각하기 시작하거나 그 문자열이 무엇을 위한 것인지 궁금해할 필요가 없다; 그 오류는 그들에게 그것을 바로 앞세워준다.

그건 훨씬 더 나은 경험이야.

그리고 DSL을 구현하는 것에 대해 기억해야 할 가장 중요한 것은 고객의 경험을 개선하는 것에 관한 것이라는 것이다.

DSL은 고객이 정의를 조립하는 메커니즘에 대해 걱정하지 않고 정의할 수 있도록 함으로써 매우 복잡하고 반복적인 코드를 훨씬 더 깨끗하게 만들 수 있다.

결과 빌더는 DSL이 정의된 값을 수집할 수 있는 강력한 도구입니다.

그리고 수정자 스타일의 메서드는 결과 작성자가 값을 캡처하기 전에 값을 변경할 수 있는 구성 가능한 방법을 제공합니다.

하지만 당신이 DSL을 작성한다면, 고객들은 그것을 사용하는 방법을 배워야 한다는 것을 기억하세요.

시간과 노력의 가치가 있을 때만 DSL을 제공하세요.

시간 내주셔서 감사합니다, 그리고 작은 언어를 만드는 것을 즐기세요.

♪