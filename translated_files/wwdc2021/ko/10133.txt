10133

♪ 베이스 음악 연주 ♪

♪

다리오 렉신: 안녕하세요, 제 이름은 다리오 렉신이고, 저는 여기 애플의 스위프트 팀의 엔지니어입니다.

오늘, 제 동료 더그와 저는 스위프트의 배우들과 그들이 동시 스위프트 애플리케이션에서 가변 상태를 보호하는 데 어떻게 활용되는지에 대해 이야기할 것입니다.

동시 프로그램을 작성할 때 근본적으로 어려운 문제 중 하나는 데이터 경쟁을 피하는 것이다.

데이터 경쟁은 두 개의 개별 스레드가 동시에 동일한 데이터에 액세스하고 그 중 적어도 하나는 쓰기일 때 발생한다.

데이터 경쟁은 구성하기에는 사소하지만 디버깅하기 어려운 것으로 악명이 높다.

여기 카운터를 증가시키고 새로운 값을 반환하는 하나의 작업이 있는 간단한 카운터 클래스가 있습니다.

우리가 계속해서 두 개의 동시 작업에서 증가하려고 노력한다고 가정해 봅시다.

이건 나쁜 생각이야.

실행 타이밍에 따라, 우리는 1과 2 또는 2와 1을 얻을 수 있습니다.

이것은 예상되며, 두 경우 모두 카운터는 일관된 상태로 남겨질 것이다.

하지만 우리가 데이터 경쟁을 도입했기 때문에, 두 작업 모두 0을 읽고 1을 쓰면 1과 1을 얻을 수도 있습니다.

또는 반환 진술이 두 증가 작업 후에 발생한다면 2와 2도.

데이터 경쟁은 피하고 디버깅하기 어려운 것으로 악명이 높다.

그들은 경쟁을 일으키는 데이터 접근이 프로그램의 다른 부분에 있을 수 있기 때문에 비지역적 추론이 필요하다.

그리고 운영 체제의 스케줄러가 프로그램을 실행할 때마다 다른 방식으로 동시 작업을 인터리브할 수 있기 때문에 그것들은 비결정적입니다.

데이터 경쟁은 공유된 가변 상태에 의해 발생한다.

데이터가 변경되지 않거나 여러 동시 작업에서 공유되지 않으면, 데이터 경쟁을 할 수 없습니다.

데이터 경쟁을 피하는 한 가지 방법은 값 의미론을 사용하여 공유 가변 상태를 제거하는 것이다.

값 유형의 변수로, 모든 돌연변이는 국부적이다.

게다가, 가치 의미 유형의 "let" 속성은 정말 변경할 수 없으므로, 다른 동시 작업에서 액세스하는 것이 안전합니다.

스위프트는 처음부터 가치 의미론을 홍보해 왔습니다. 왜냐하면 그들은 우리 프로그램에 대해 더 쉽게 추론할 수 있게 해주고 같은 것들이 동시 프로그램에서 안전하게 사용할 수 있게 해주기 때문입니다.

이 예에서, 우리는 몇 가지 값을 가진 배열을 만든다.

다음으로, 우리는 그 배열을 두 번째 변수에 할당한다.

이제 우리는 배열의 각 복사본에 다른 값을 추가합니다.

마지막에 두 배열을 모두 인쇄할 때, 두 복사본 모두 배열이 초기화된 값을 포함하고 있지만, 추가된 각 값은 우리가 추가한 각각의 복사본에만 존재한다는 것을 알 수 있습니다.

스위프트의 표준 라이브러리에 있는 대부분의 유형은 사전이나 이 예에서와 같이 배열과 같은 컬렉션 유형을 포함하여 가치 의미론을 가지고 있다.

이제 가치 의미론이 모든 데이터 경쟁을 해결한다는 것을 확립했으므로, 카운터를 구조체로 바꾸어 값 유형으로 만들어 봅시다.

우리는 또한 증가 함수를 돌연변이로 표시해야 하므로, 값 속성을 수정할 수 있습니다.

우리가 지금 카운터를 수정하려고 할 때 카운터가 let이기 때문에 컴파일러 오류가 발생하여 변형을 방지할 수 있습니다.

이제, 그것을 변경할 수 있도록 카운터 변수를 var로 바꾸는 것은 매우 유혹적인 것 같다.

하지만 그것은 카운터가 두 개의 동시 작업에 의해 참조될 것이기 때문에 다시 경쟁 조건을 남길 것이다.

운 좋게도, 컴파일러는 우리가 이 안전하지 않은 코드를 컴파일하는 것을 허용하지 않는다.

대신 각 동시 작업 내부의 로컬 가변 변수에 카운터를 할당할 수 있습니다.

우리가 지금 예시를 실행할 때, 그것은 항상 두 개의 동시 작업에 대해 1을 인쇄할 것이다.

하지만 우리의 코드는 이제 인종이 없지만, 그 행동은 더 이상 우리가 원하는 것이 아니다.

이것은 여전히 공유된 가변 상태가 필요한 경우가 있다는 것을 보여준다.

동시 프로그램에서 가변 상태를 공유했을 때, 공유 가변 상태의 동시 사용이 데이터 경이를 일으키지 않도록 하기 위해 어떤 형태의 동기화가 필요합니다.

원자 및 잠금과 같은 낮은 수준의 도구부터 직렬 디스패치 큐와 같은 더 높은 수준의 구성에 이르기까지 동기화를 위한 많은 프리미티브가 있습니다.

이 원시인들 각각은 다양한 강점을 가지고 있지만, 모두 같은 중요한 약점을 공유한다: 그들은 매번 정확하게 사용하기 위해 신중한 규율이 필요하다. 그렇지 않으면 우리는 데이터 경쟁으로 끝날 것이다.

여기가 배우들이 들어오는 곳이다.

배우들은 공유 가변 상태를 위한 동기화 메커니즘이다.

배우는 자신의 상태를 가지고 있으며 그 상태는 프로그램의 나머지 부분과 분리되어 있다.

그 주에 접근할 수 있는 유일한 방법은 배우를 통과하는 것이다.

그리고 배우를 통과할 때마다, 배우의 동기화 메커니즘은 다른 코드가 배우의 상태에 동시에 접근하지 않도록 합니다.

이것은 우리가 수동으로 잠금이나 직렬 디스패치 대기열을 사용하여 얻는 것과 동일한 상호 배제 속성을 제공하지만, 배우와 함께 Swift가 제공하는 근본적인 보증입니다.

당신이 시도하면 스위프트가 컴파일러 오류를 일으킬 것이기 때문에, 동기화를 수행하는 것을 잊을 수 없습니다.

배우들은 스위프트의 새로운 유형이다.

그들은 스위프트의 모든 명명된 유형과 동일한 기능을 제공한다.

그들은 속성, 방법, 이니셜라이저, 첨자 등이 있을 수 있다.

그들은 프로토콜을 준수하고 확장으로 증강될 수 있다.

수업과 마찬가지로, 그것들은 참조 유형이다; 왜냐하면 배우들의 목적은 공유된 가변 상태를 표현하는 것이기 때문이다.

사실, 액터 유형의 주요 특징은 인스턴스 데이터를 프로그램의 나머지 부분과 분리하고 해당 데이터에 대한 동기화된 액세스를 보장한다는 것이다.

그들의 모든 특별한 행동은 그 핵심 아이디어에서 비롯된다.

여기서, 우리는 카운터를 배우 유형으로 정의했습니다.

우리는 여전히 카운터에 대한 인스턴스 속성 값과 그 값을 증가시키고 새 값을 반환하는 증가 방법을 가지고 있습니다.

차이점은 배우가 동시에 가치에 접근하지 않도록 할 것이라는 것이다.

이 경우, 그것은 증가 메서드가 호출될 때 액터에서 실행되는 다른 코드 없이 완료될 것이라는 것을 의미합니다.

그 보증은 배우의 상태에 대한 데이터 경쟁의 가능성을 제거한다.

우리의 데이터 경쟁 예시를 다시 가져오자.

우리는 다시 같은 카운터를 증가시키려는 두 개의 동시 작업이 있다.

액터의 내부 동기화 메커니즘은 하나의 증가 호출이 다른 호출을 시작하기 전에 완료까지 실행되도록 합니다.

그래서 우리는 둘 다 유효한 동시 실행이기 때문에 1과 2 또는 2와 1을 얻을 수 있지만, 액터의 내부 동기화가 액터 상태에 대한 데이터 경쟁의 가능성을 제거했기 때문에 같은 카운트를 두 번 얻거나 어떤 값도 건너뛸 수 없습니다.

두 개의 동시 작업이 동시에 카운터를 증가시키려고 할 때 실제로 어떤 일이 일어나는지 생각해 봅시다.

하나는 먼저 거기에 도착할 것이고, 다른 하나는 차례를 기다려야 할 것이다.

하지만 두 번째 작업이 배우의 차례를 참을성 있게 기다릴 수 있도록 어떻게 보장할 수 있을까요?

스위프트는 그것을 위한 메커니즘을 가지고 있다.

외부에서 배우와 상호 작용할 때마다, 당신은 비동기적으로 그렇게 한다.

배우가 바쁘면, 실행 중인 CPU가 다른 유용한 작업을 할 수 있도록 코드가 일시 중지됩니다.

액터가 다시 자유로워지면, 실행을 재개하는 코드를 깨워서 액터에서 통화를 실행할 수 있습니다.

이 예제의 await 키워드는 배우에 대한 비동기 호출이 그러한 정지를 포함할 수 있음을 나타냅니다.

불필요하게 느린 재설정 작업을 추가하여 반례를 조금 더 늘려 봅시다.

이 작업은 값을 0으로 다시 설정한 다음, 새로운 값에 대한 카운터를 얻기 위해 적절한 횟수 증가를 호출합니다.

이 resetSlowly 방법은 카운터 액터 유형의 확장으로 정의되므로 액터 안에 있습니다.

즉, 카운터 값을 0으로 재설정하기 위해 배우의 상태에 직접 액세스할 수 있습니다.

그것은 또한 증가 호출과 같은 액터의 다른 메소드를 동기적으로 호출할 수 있다.

우리는 이미 우리가 배우를 달리고 있다는 것을 알고 있기 때문에 기다릴 필요가 없다.

이것은 배우들의 중요한 재산이다.

배우의 동기 코드는 항상 중단되지 않고 완료된다.

그래서 우리는 동시성이 액터 상태에 미치는 영향을 고려할 필요 없이 순차적으로 동기 코드에 대해 추론할 수 있습니다.

우리는 동기 코드가 중단 없이 실행된다는 것을 강조했지만, 배우들은 종종 서로 또는 시스템의 다른 비동기 코드와 상호 작용한다.

몇 분 동안 비동기 코드와 배우에 대해 이야기해 봅시다.

하지만 먼저, 우리는 더 나은 예시가 필요하다.

여기서 우리는 이미지 다운로더 배우를 만들고 있습니다.

그것은 다른 서비스에서 이미지를 다운로드할 책임이 있다.

또한 동일한 이미지를 여러 번 다운로드하지 않도록 다운로드한 이미지를 캐시에 저장합니다.

논리적 흐름은 간단합니다: 캐시를 확인하고, 이미지를 다운로드한 다음, 돌아오기 전에 캐시에 이미지를 기록하세요.

우리가 배우에 있기 때문에, 이 코드는 낮은 수준의 데이터 경주가 없습니다; 원하는 수의 이미지를 동시에 다운로드할 수 있습니다.

액터의 동기화 메커니즘은 한 번에 하나의 작업만 캐시 인스턴스 속성에 액세스하는 코드를 실행할 수 있음을 보장하므로 캐시가 손상될 수 있는 방법은 없습니다.

즉, 여기서 기다리는 키워드는 매우 중요한 것을 전달하는 것이다.

대기가 발생할 때마다, 그것은 이 시점에서 기능이 중단될 수 있다는 것을 의미한다.

그것은 CPU를 포기하여 프로그램의 다른 코드를 실행할 수 있으며, 이는 전체 프로그램 상태에 영향을 미친다.

당신의 기능이 재개되는 시점에서, 전체 프로그램 상태가 바뀔 것입니다.

기다림 후에 유지되지 않을 수 있는 기다림 전에 그 상태에 대해 가정하지 않았는지 확인하는 것이 중요합니다.

같은 이미지를 동시에 가져오려고 하는 두 개의 다른 동시 작업이 있다고 상상해 보세요.

첫 번째는 캐시 항목이 없다는 것을 보고, 서버에서 이미지 다운로드를 시작한 다음, 다운로드가 시간이 걸리기 때문에 일시 중지됩니다.

첫 번째 작업이 이미지를 다운로드하는 동안, 새로운 이미지가 동일한 URL로 서버에 배포될 수 있습니다.

이제, 두 번째 동시 작업은 그 URL 아래의 이미지를 가져오려고 시도한다.

또한 첫 번째 다운로드가 아직 완료되지 않았기 때문에 캐시 항목이 보이지 않으며, 이미지의 두 번째 다운로드를 시작합니다.

그것은 또한 다운로드가 완료되는 동안 중단된다.

잠시 후, 다운로드 중 하나가 - 그것이 첫 번째라고 가정해 봅시다 - 완료되고 그 작업은 액터에 대한 실행을 재개할 것입니다.

그것은 캐시를 채우고 고양이의 결과 이미지를 반환합니다.

이제 두 번째 작업은 다운로드가 완료되어 깨어납니다.

그것은 캐시의 동일한 항목을 슬픈 고양이의 이미지로 덮어씁니다.

그래서 캐시가 이미 이미지로 채워졌음에도 불구하고, 우리는 이제 같은 URL에 대해 다른 이미지를 얻는다.

그건 좀 놀랍다.

우리는 이미지를 캐시하면 항상 동일한 URL에 대해 동일한 이미지를 다시 얻을 수 있으므로 적어도 캐시를 수동으로 지울 때까지 사용자 인터페이스가 일관되게 유지될 것으로 예상했습니다.

하지만 여기서, 캐시된 이미지는 예기치 않게 바뀌었다.

우리는 낮은 수준의 데이터 경쟁이 없지만, 대기 중에 상태에 대한 가정을 수행했기 때문에, 우리는 잠재적인 버그로 끝났다.

여기서의 해결책은 기다림 후에 우리의 가정을 확인하는 것이다.

우리가 재개할 때 캐시에 이미 항목이 있다면, 우리는 원래 버전을 보관하고 새 버전을 버릴 것이다.

더 나은 해결책은 중복 다운로드를 완전히 피하는 것이다.

우리는 이 비디오와 관련된 코드에 그 해결책을 넣었다.

배우 재진적은 교착 상태를 방지하고 앞으로의 진행을 보장하지만, 각 대기에 걸쳐 당신의 가정을 확인해야 합니다.

재진주를 위해 잘 설계하려면, 동기 코드 내에서 액터 상태의 돌연변이를 수행하세요.

이상적으로, 모든 상태 변경이 잘 캡슐화되도록 동기 함수 내에서 수행하세요.

주 변화는 일시적으로 우리의 배우를 일관성 없는 상태로 두는 것을 포함할 수 있다.

기다리기 전에 일관성을 회복하세요.

그리고 기다림이 잠재적인 정지 지점이라는 것을 기억하세요.

코드가 일시 중지되면, 코드가 재개되기 전에 프로그램과 세계가 진행될 것입니다.

글로벌 상태, 시계, 타이머 또는 배우에 대한 모든 가정은 기다린 후에 확인해야 합니다.

그리고 이제 내 동료 더그가 배우의 고립에 대해 더 말해줄 거야. 더그?

더그 그레고르: 고마워, 다리오.

배우의 고립은 배우 유형의 행동의 기본이다.

다리오는 배우 외부의 비동기 상호 작용을 통해 스위프트 언어 모델에 의해 배우 격리가 어떻게 보장되는지에 대해 논의했다.

이 섹션에서는 액터 격리가 프로토콜 적합성, 폐쇄 및 클래스를 포함한 다른 언어 기능과 어떻게 상호 작용하는지에 대해 이야기할 것입니다.

다른 유형과 마찬가지로, 행위자들은 프로토콜의 요구 사항을 충족시킬 수 있는 한 프로토콜을 준수할 수 있다.

예를 들어, 이 LibraryAccount 액터가 Equatable 프로토콜을 준수하도록 합시다.

정적 평등 방법은 ID 번호를 기반으로 두 개의 도서관 계정을 비교한다.

그 방법은 정적이기 때문에, 자기 인스턴스가 없기 때문에 배우에게 고립되지 않는다.

대신, 우리는 배우 유형의 두 가지 매개 변수를 가지고 있으며, 이 정적 방법은 둘 다 외부에 있다.

구현이 액터의 불변 상태에만 접근하고 있기 때문에 괜찮습니다.

라이브러리 계정이 해셔블 프로토콜을 준수하도록 예시를 더 확장해 봅시다.

그렇게 하려면 우리가 이렇게 할 수 있는 해시(into) 작업을 구현해야 한다.

그러나, 스위프트 컴파일러는 이 적합성이 허용되지 않는다고 불평할 것이다.

무슨 일이 있었나요?

음, 이런 식으로 Hashable을 준수한다는 것은 이 함수가 액터 외부에서 호출될 수 있다는 것을 의미하지만, hash(into)는 비동기가 아니므로 액터 격리를 유지할 방법이 없습니다.

이것을 고치기 위해, 우리는 이 방법을 분리하지 않게 만들 수 있다.

Nonisolated는 이 방법이 배우에게 문법적으로 설명되어 있음에도 불구하고 배우 외부에 있는 것으로 취급된다는 것을 의미한다.

이것은 Hashable 프로토콜의 동기 요구 사항을 충족시킬 수 있다는 것을 의미합니다.

고립되지 않은 방법은 배우 외부에 있는 것으로 취급되기 때문에, 그들은 배우의 가변 상태를 참조할 수 없다.

이 방법은 불변의 ID 번호를 언급하기 때문에 괜찮습니다.

만약 우리가 대출된 책의 배열과 같은 다른 것을 기반으로 해시를 시도한다면, 외부에서 가변 상태에 대한 접근이 데이터 경쟁을 허용하기 때문에 오류가 발생할 것이다.

그것은 프로토콜 적합성으로 충분하다.

폐쇄에 대해 이야기해 봅시다.

클로저는 한 함수 내에서 정의된 작은 함수이며, 얼마 후에 호출될 수 있는 다른 함수로 전달될 수 있다.

기능과 마찬가지로, 폐쇄는 배우로 격리되거나 격리되지 않을 수 있다.

이 예에서, 우리는 대출받은 각 책의 일부를 읽고 우리가 읽은 총 페이지 수를 반환할 것입니다.

감소에 대한 요구는 독서를 수행하는 폐쇄를 포함한다.

ReadSome에 대한 이 호출에는 기다림이 없다는 점에 유의하십시오.

그것은 배우 격리 기능 "읽기" 내에서 형성되는 이 폐쇄 자체가 배우 격리되기 때문이다.

우리는 감소 작업이 동기적으로 실행될 것이기 때문에 이것이 안전하다는 것을 알고 있으며, 동시 액세스를 유발할 수 있는 다른 스레드로 클로저를 탈출할 수 없습니다.

이제, 조금 다른 것을 해보자.

나는 지금 읽을 시간이 없어, 그러니 나중에 읽자.

여기서, 우리는 분리된 작업을 만든다.

분리된 작업은 배우가 하고 있는 다른 작업과 동시에 폐쇄를 실행한다.

따라서, 폐쇄는 배우에게 있을 수 없거나 우리는 데이터 레이스를 도입할 것이다.

그래서 이 폐쇄는 배우에게 고립되지 않는다.

읽기 메소드를 호출하고 싶을 때, await에 표시된 대로 비동기적으로 해야 합니다.

우리는 코드의 배우 격리에 대해 조금 이야기했는데, 이는 그 코드가 배우 내부에서 실행되는지 아니면 외부에서 실행되는지 여부이다.

이제, 배우 격리와 데이터에 대해 이야기해 봅시다.

도서관 계정 예시에서, 우리는 책 유형이 실제로 무엇인지 말하는 것을 신중하게 피했다.

나는 그것이 구조체와 같은 값 유형이라고 가정해 왔다.

그것은 도서관 계정 액터의 인스턴스에 대한 모든 주가 독립적이라는 것을 의미하기 때문에 좋은 선택입니다.

우리가 이 방법을 호출하여 읽을 임의의 책을 선택한다면, 우리는 읽을 수 있는 책의 사본을 얻을 것이다.

우리가 책의 사본을 변경하는 것은 배우에게 영향을 미치지 않을 것이며 그 반대도 마찬가지입니다.

하지만, 책을 수업으로 바꾸면, 상황은 조금 다르다.

우리 도서관 계정 배우는 이제 책 수업의 사례를 참조한다.

그건 그 자체로 문제가 아니야.

하지만, 우리가 임의의 책을 선택하는 방법을 부르면 어떻게 되나요?

이제 우리는 배우의 외부에서 공유된 배우의 가변 상태에 대한 참조를 가지고 있다.

우리는 데이터 경쟁의 잠재력을 창출했다.

이제, 우리가 가서 책의 제목을 업데이트하면, 수정은 배우 내에서 접근할 수 있는 상태에서 일어난다.

방문 방법은 배우가 아니기 때문에, 이 수정은 결국 데이터 경쟁이 될 수 있다.

가치 유형과 행위자는 둘 다 동시에 사용하기에 안전하지만, 수업은 여전히 문제를 일으킬 수 있다.

우리는 동시에 사용하기에 안전한 유형의 이름을 가지고 있습니다: Sendable.

전송 가능한 유형은 다른 행위자들 간에 가치를 공유할 수 있는 유형이다.

한 장소에서 다른 장소로 값을 복사하고, 두 장소 모두 서로를 방해하지 않고 해당 값의 복사본을 안전하게 수정할 수 있다면, 그 유형은 전송 가능할 수 있습니다.

다리오가 앞서 언급했듯이, 각 사본이 독립적이기 때문에 가치 유형은 보낼 수 있다.

액터 유형은 가변 상태에 대한 액세스를 동기화하기 때문에 전송 가능합니다.

수업은 보낼 수 있지만, 신중하게 시행되는 경우에만 가능합니다.

예를 들어, 클래스와 모든 하위 클래스가 불변의 데이터만 보유하고 있다면, Sendable이라고 부를 수 있습니다.

또는 클래스가 안전한 동시 액세스를 보장하기 위해 내부적으로 동기화를 수행하는 경우, 예를 들어 잠금으로 동기화를 수행하는 경우, 보낼 수 있습니다.

하지만 대부분의 수업은 이것들 중 어느 것도 아니며, 보낼 수 없습니다.

기능이 반드시 보낼 수 있는 것은 아니므로, 배우를 가로질러 전달하기에 안전한 기능을 위한 새로운 종류의 기능 유형이 있습니다.

우리는 곧 그것들로 돌아갈 거야.

당신의 배우들 - 사실, 당신의 모든 동시 코드 -은 주로 전송 가능한 유형 측면에서 소통해야 합니다.

전송 가능한 유형은 데이터 경쟁으로부터 코드를 보호합니다.

이것은 스위프트가 결국 정적으로 확인하기 시작할 속성이다.

그 시점에서, 배우의 경계를 넘어 보낼 수 없는 유형을 전달하는 것은 오류가 될 것이다.

유형이 전송 가능하다는 것을 어떻게 알 수 있나요?

음, Sendable은 프로토콜이며, 당신은 당신의 유형이 다른 프로토콜과 같은 방식으로 Sendable을 준수한다고 말합니다.

그런 다음 스위프트는 당신의 유형이 전송 가능한 유형으로 의미가 있는지 확인할 것입니다.

저장된 모든 속성이 전송 가능한 유형인 경우 책 구조체를 보낼 수 있습니다.

저자가 실제로 클래스라고 가정해 봅시다. 즉, 저자의 배열은 보낼 수 없습니다.

스위프트는 책을 보낼 수 없다는 컴파일러 오류를 생성할 것이다.

일반적인 유형의 경우, 그들이 보낼 수 있는지 여부는 일반적인 인수에 따라 달라질 수 있다.

우리는 적절할 때 Sendable을 전파하기 위해 조건부 적합성을 사용할 수 있다.

예를 들어, 쌍 유형은 일반 인수가 모두 전송 가능할 때만 전송 가능할 수 있습니다.

같은 접근 방식은 Sendable 유형의 배열 자체가 Sendable이라는 결론을 내리는 데 사용된다.

값을 동시에 공유하기에 안전한 유형에 Sendable 적합성을 도입하는 것이 좋습니다.

배우들 내에서 그 유형들을 사용하세요.

그런 다음 스위프트가 액터 전반에 걸쳐 Sendable을 시행하기 시작하면, 당신의 코드가 준비될 것입니다.

함수 자체는 전송 가능할 수 있으며, 이는 액터 간에 함수 값을 전달하는 것이 안전하다는 것을 의미합니다.

이것은 데이터 경쟁을 방지하기 위해 폐쇄가 할 수 있는 일을 제한하는 폐쇄에 특히 중요하다.

예를 들어, Sendable 클로저는 지역 변수에 대한 데이터 경쟁을 허용하기 때문에 변경 가능한 지역 변수를 캡처할 수 없습니다.

클로저가 캡처하는 모든 것은 클로저가 액터 경계를 넘어 보낼 수 없는 유형을 이동하는 데 사용할 수 없도록 하기 위해 전송 가능해야 합니다.

그리고 마지막으로, 동기식 Sendable 폐쇄는 외부에서 배우에서 코드를 실행할 수 있기 때문에 배우로 격리할 수 없습니다.

우리는 실제로 이 강연에서 Sendable 폐쇄에 대한 아이디어에 의존하고 있다.

분리된 작업을 만드는 작업은 함수 유형의 @Sendable과 함께 여기에 쓰여진 Sendable 함수를 사용합니다.

이야기의 시작부터 우리의 반례를 기억하시나요?

우리는 가치 입력 카운터를 만들려고 노력하고 있었다.

그런 다음, 우리는 동시에 두 개의 다른 폐쇄에서 그것을 수정하려고 노력했다.

이것은 가변적인 지역 변수에 대한 데이터 경쟁이 될 것이다.

그러나, 분리된 작업의 폐쇄는 전송 가능하기 때문에, 스위프트는 여기서 오류를 일으킬 것이다.

전송 가능한 함수 유형은 동시 실행이 발생할 수 있는 곳을 나타내기 위해 사용되며, 따라서 데이터 경쟁을 방지합니다.

여기 우리가 전에 본 또 다른 예가 있습니다.

분리된 작업의 폐쇄는 전송 가능하기 때문에, 우리는 그것이 배우에게 고립되어서는 안 된다는 것을 알고 있다.

그러므로, 그것과의 상호 작용은 비동기적이어야 할 것이다.

전송 가능한 유형과 클로저는 가변 상태가 액터 간에 공유되지 않으며 동시에 수정할 수 없는지 확인하여 액터 격리를 유지하는 데 도움이 됩니다.

우리는 주로 배우 유형과 그들이 프로토콜, 폐쇄 및 전송 유형과 어떻게 상호 작용하는지에 대해 이야기해 왔습니다.

논의할 배우가 한 명 더 있다 - 우리가 주연 배우라고 부르는 특별한 배우.

앱을 만들 때, 주요 스레드에 대해 생각해야 합니다.

그것은 핵심 사용자 인터페이스 렌더링이 일어나는 곳뿐만 아니라 사용자 상호 작용 이벤트가 처리되는 곳이다.

UI로 작동하는 작업은 일반적으로 메인 스레드에서 수행되어야 합니다.

하지만, 당신은 메인 스레드에서 모든 일을 하고 싶지 않습니다.

메인 스레드에서 너무 많은 작업을 하면, 입력/출력 작업이 느리거나 서버와의 상호 작용을 차단하기 때문에 UI가 멈춥니다.

따라서, UI와 상호 작용할 때 메인 스레드에서 작업하도록 주의해야 하지만 계산 비용이 많이 들거나 오래 기다리는 작업을 위해 메인 스레드에서 빠르게 벗어나야 합니다.

그래서, 우리는 할 수 있을 때 메인 스레드에서 작업한 다음 메인 스레드에서 실행해야 하는 특정 작업이 있을 때마다 코드에서 DispatchQueue.main.async를 호출합니다.

메커니즘의 세부 사항에서 물러나면, 이 코드의 구조는 어렴풋이 친숙해 보인다.

사실, 메인 스레드와 상호 작용하는 것은 배우와 상호 작용하는 것과 매우 같다.

이미 메인 스레드에서 실행되고 있다는 것을 알고 있다면, UI 상태에 안전하게 액세스하고 업데이트할 수 있습니다.

메인 스레드에서 실행되지 않는다면, 비동기적으로 상호 작용해야 합니다.

이것이 바로 배우들이 일하는 방식이다.

우리가 주요 배우라고 부르는 주요 실을 설명하는 특별한 배우가 있다.

주요 배우는 주요 실을 대표하는 배우이다.

그것은 두 가지 중요한 면에서 평범한 배우와 다르다.

먼저, 메인 액터가 메인 디스패치 큐를 통해 모든 동기화를 수행합니다.

이것은 런타임 관점에서 볼 때, 주요 배우가 DispatchQueue.main을 사용하는 것과 교환할 수 있다는 것을 의미한다.

둘째, 메인 스레드에 있어야 하는 코드와 데이터는 어디에나 흩어져 있다.

SwiftUI, AppKit, UIKit 및 기타 시스템 프레임워크에 있습니다.

그것은 당신의 견해, 뷰 컨트롤러 및 데이터 모델의 UI 대면 부분에 퍼져 있습니다.

스위프트 동시성을 사용하면 메인 액터 속성으로 선언을 표시하여 메인 액터에서 실행되어야 한다고 말할 수 있습니다.

우리는 여기서 체크 아웃 작업으로 그것을 했기 때문에, 그것은 항상 주요 배우에서 실행된다.

메인 액터 외부에서 호출하는 경우, 메인 스레드에서 호출이 비동기적으로 수행되도록 기다려야 합니다.

메인 스레드에서 실행되어야 하는 코드를 메인 액터로 표시함으로써, DispatchQueue.main을 언제 사용해야 하는지에 대한 추측은 더 이상 없습니다.

스위프트는 이 코드가 항상 메인 스레드에서 실행되도록 보장합니다.

유형은 메인 배우에게도 배치될 수 있으며, 이는 모든 멤버와 서브클래스를 메인 배우로 만든다.

이것은 대부분의 모든 것이 메인 스레드에서 실행되어야 하는 UI와 상호 작용해야 하는 코드 베이스의 부분에 유용합니다.

개별 방법은 일반 배우와 익숙한 것과 동일한 규칙으로 격리되지 않은 키워드를 통해 옵트아웃할 수 있습니다.

UI 대면 유형 및 운영에 주요 액터를 사용하고 다른 프로그램 상태를 관리하기 위해 자신의 액터를 도입함으로써, 동시에 안전하고 올바른 사용을 보장하기 위해 앱을 설계할 수 있습니다.

이 세션에서, 우리는 액터가 동시 액세스로부터 가변 상태를 보호하는 방법, 액터 격리를 사용하고 실행을 직렬화하기 위해 액터 외부에서 비동기 액세스를 요구하는 방법에 대해 이야기했습니다.

액터를 사용하여 스위프트 코드에서 안전하고 동시적인 추상화를 구축하세요.

당신의 배우와 비동기 코드를 구현할 때, 항상 재진화를 위해 설계하십시오; 당신의 코드에서의 기다림은 세상이 앞으로 나아가고 당신의 가정을 무효화할 수 있다는 것을 의미합니다.

가치 유형과 행위자는 데이터 경쟁을 없애기 위해 함께 일한다.

자체 동기화를 처리하지 않는 클래스와 공유 가변 상태를 다시 도입하는 다른 보낼 수 없는 유형에 유의하십시오.

마지막으로, UI와 상호 작용하는 코드의 메인 액터를 사용하여 메인 스레드에 있어야 하는 코드가 항상 메인 스레드에서 실행되도록 하십시오.

자신의 애플리케이션 내에서 배우를 사용하는 방법에 대해 자세히 알아보려면, 스위프트 동시성 앱 업데이트 세션을 확인하세요.

그리고 배우를 포함한 스위프트의 동시성 모델의 구현에 대해 자세히 알아보려면, "비하인드 더 씬" 세션을 확인하세요.

배우들은 스위프트 동시성 모델의 핵심 부분이다.

그들은 정확하고 효율적인 동시 프로그램을 더 쉽게 구축할 수 있도록 비동기/대기 및 구조화된 동시성과 함께 작동합니다.

우리는 네가 그들과 함께 무엇을 만드는지 빨리 보고 싶어.

♪