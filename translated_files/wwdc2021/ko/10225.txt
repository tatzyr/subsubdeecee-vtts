10225

G'day.

"그룹 활동과 미디어 경험 조정" 세션에 오신 것을 환영합니다.

제 이름은 헤이든이고, 저는 여기 애플의 그룹 활동 팀의 엔지니어입니다.

오늘, 우리는 사용자가 여러 장치에서 함께 콘텐츠를 보고 들을 수 있는 동기화된 미디어 앱을 만드는 방법에 대해 이야기할 것입니다.

목표는 사용자가 어디에 있든 물리적으로 함께 있는 것처럼 느끼는 것입니다.

GroupActivities API는 공유 경험을 만들기 위한 스위프트 프레임워크이다.

재생 조정 및 그룹 세션 관리를 위한 API를 통해 미디어를 조정합니다.

그리고 그것은 iOS, iPadOS, macOS 및 tvOS와 같은 광범위한 Apple 플랫폼에서 지원됩니다.

동료인 모리츠에게 전화하고 이 강연에 첨부된 샘플 앱의 비디오를 공유하여 GroupActivities API의 데모로 시작합시다.

모리츠가 가능한지 보자.

안녕, 모리츠!

이봐, 헤이든!

나는 집에 가서 샘플 앱을 열 거야.

애플 파크의 드론 영상 목록을 볼 수 있습니다.

나는 모리츠에게 극장 영상을 보여줄 거야.

그건 어떻게 생겼어, 모리츠? 그거 보고 싶어?

그거 좋아 보인다. 난 그게 정말 좋아.

근데 내가 지난주에 링에서 업로드한 새 거 봤어?

오, 좋아 보인다!

나는 재생을 시작할 것이고, 우리의 비디오는 우리 장치 간에 동기화될 것이다.

내가 멈추면 볼 수 있어, 모리츠를 위해서도 멈출 거야.

그리고 그가 앞으로 나아간다면, 그것은 또한 나를 위해 앞으로 나아갈 것이다.

멋져 보여. 알았어, 고마워, 모리츠!

응, 그거 좋았어. 안녕, 헤이든.

조정된 미디어 재생 앱을 만들 때 생각해야 할 세 가지 주요 부분이 있습니다.

첫 번째는 새로운 GroupActivities API를 구현하는 것이다.

두 번째는 가능한 한 원활하게 경험을 공유할 수 있도록 Picture-in-picture를 활용할 수 있는 방법입니다.

그리고 셋째, 제 동료인 모리츠는 재생 조정이 어떻게 작동하는지와 새로운 재생 조정 객체의 특징에 대해 자세히 알아볼 것이다.

GroupActivities 앱의 수명 주기를 살펴보고 GroupActivities API에 익숙해지자.

여기, 첫 번째 데모와 마찬가지로 FaceTime 통화에 두 대의 iPhone이 있습니다.

내 장치는 왼쪽에 있고, 내 동료인 모리츠는 오른쪽에 있다.

내 장치에서, 나는 공유 앱을 연다.

그런 다음 앱에서, 나는 그룹과 활동을 공유한다.

GroupActivities 프레임워크는 활동에 대한 세션 객체를 만든 다음 내 앱에 전달합니다.

한편, 세션 객체는 프레임워크가 그의 장치에서 동일한 앱을 여는 것을 처리하는 모리츠와 공유된다.

마지막으로, 프레임워크는 모리츠의 앱인 GroupSession을 통과한다.

이제, 우리는 같은 GroupSession을 통해 통신할 수 있는 두 개의 앱이 있습니다.

이제, GroupActivities 프레임워크를 채택하기 위해 취해야 할 단계를 살펴봅시다.

첫 번째 단계는 메타데이터와 함께 GroupActivity를 만드는 것이다.

그래서, GroupActivity가 무엇이고 어떻게 정의하는지에 대해 이야기해 봅시다.

GroupActivity는 사용자가 함께 경험하고 있는 항목을 나타내는 Swift 프로토콜입니다.

이것은 영화나 노래와 같은 하나의 콘텐츠가 될 것이다.

경험을 설정하는 데 필요한 이 유형의 속성을 포함해야 합니다.

예를 들어, 여기에 비디오에 대한 URL을 포함할 수 있으므로, 세션을 준비하기 위해 비디오를 로드할 수 있습니다.

프레임워크가 네트워크를 통해 데이터를 보내기 위해서는 Codable을 준수한다.

이것은 당신의 재산이 Codable을 준수해야 한다는 것을 의미합니다.

두 가지 필수 속성이 있다는 것을 알게 될 것입니다.

ActivityIdentifier는 고유한 유형 식별자이므로 시스템은 이 활동을 참조하는 방법을 알고 있습니다.

GroupActivityMetadata에는 원격 장치의 시스템 UI에서 이 활동을 보여주는 정보가 포함되어 있습니다.

이것이 올해 Swift Concurrency와 함께 도입되는 새로운 비동기 효과적인 읽기 전용 속성 기능의 예라는 것을 알게 될 것입니다.

자세한 내용은 올해 WWDC에서 "Meet async/await in Swift" 세션을 참조하십시오.

그래서, 당신은 그룹 활동을 정의했습니다.

이제 GroupActivity에서 활성화 방법을 호출하여 통화에 공유하고 싶습니다.

GroupActivity를 활성화하면, 프레임워크는 로컬 및 원격 장치 모두에 전달되는 GroupSession 객체를 생성합니다.

시스템은 앱 실행을 담당하며, 시스템 UI는 활동 메타데이터를 보여줄 것이다.

하지만 먼저, 우리가 간과한 것이 있다.

당신의 앱은 당신이 FaceTime 통화 중이라는 것을 어떻게 알 수 있나요?

그리고 사용자가 콘텐츠를 선택할 때, 그룹에 공유하려는 것이 아니라 로컬에서 보고 싶다면 어떨까요?

PrepareForActivation 기능은 시스템이 사용자 의도를 해결하도록 함으로써 이러한 문제를 해결합니다.

다음은 prepareForActivation API의 예입니다.

스위치 진술에는 우리가 처리해야 할 세 가지 사례가 있다.

첫 번째, activationDisabled는 사용자가 FaceTime 통화를 하지 않거나 시스템이 로컬로 사용하기로 결정했을 때 사용됩니다.

두 번째, activationPreferred는 사용자가 FaceTime 통화 중일 때 촬영되며, 그룹과 공유하고자 합니다.

사용자가 공유 작업을 취소할 때 취소됩니다.

이것은 이미 활동을 공유하는 GroupActivities 앱을 만들기에 충분한 지식이다.

그래서, Xcode로 넘어가자, 그리고 내가 실제로 보여줄게.

GroupActivities 지원을 추가하기 전에, 프로젝트를 빠르게 진행하겠습니다.

영화를 선택하고 볼 수 있는 간단한 영화 감상 앱입니다.

그것은 당신에게 비디오 플레이어를 보여주는 영화 세부 정보 페이지와 함께 볼 영화 목록으로 구성되어 있습니다.

지금 당장, 이 앱은 당신이 혼자 영화를 볼 수 있게 해주므로, 그것을 바꾸자.

당신은 우리가 그룹 활동 자격이 설정되어 있다는 것을 알게 될 것입니다.

그리고 나서, 우리는 Movie.swift에 GroupActivity를 추가할 것이다.

가장 먼저 해야 할 일은 그룹 활동을 가져오는 것이다.

그리고 나서, 우리는 GroupActivity, MovieWatchingActivity를 추가할 것입니다.

당신은 그것이 영화 속성을 가지고 있다는 것을 알게 될 것이며, 메타데이터를 채우기 위해 그 속성을 사용합니다.

지금 이 활동을 공유합시다.

우리는 CoordinationManager로 가서 prepareToPlay 기능을 찾을 것입니다.

현재, 이 기능은 영화를 대기열에 매김하여 즉시 재생을 시작합니다.

대신, 우리는 이것을 슬라이드에서 보여준 prepareForActivation 기능으로 대체할 것입니다.

당신은 우리가 활성화 비활성화된 경우에 영화를 즉시 대기열에 쥰 수 있는 것을 볼 수 있습니다.

그리고 activate()는 사용자가 FaceTime 통화에 공유하고 싶을 때 호출됩니다.

나중에 이야기에서, 우리는 재생을 시작하기 위해 영화를 대기열에 둘 것이지만, 지금은 앱을 있는 그대로 실행하면 어떻게 되는지 봅시다.

나는 모리츠의 장치를 잡았고, 두 아이폰 사이에서 페이스타임 통화를 시작했다.

나는 집에 가서 내 핸드폰에서 샘플 앱을 실행할 거야.

나는 우리가 이전에 본 링 비디오를 공유하고 모리츠의 장치에서 앱을 실행할 것이다.

당신은 그것이 GroupActivity를 받았다는 것을 알 수 있습니다.

그러나, 그것은 올바른 비디오를 로드하지 않았고, 재생 동기화도 없다.

그래서, 지금 그것을 앱에 추가하는 방법을 배워봅시다.

그룹 활동을 받는 것에 대해 배워야 할 가장 중요한 것은 GroupSession 객체와 GroupSession, GroupSessions 비동기 시퀀스를 받는 방식입니다.

다음은 전형적인 GroupSession 수명 주기를 보여주는 높은 수준의 다이어그램입니다.

로컬 및 원격 장치 모두 그룹 세션을 받습니다.

그런 다음 앱은 재생을 준비하기 위해 설정되어야 합니다.

그리고 마지막으로, 준비가 되면, 그룹 세션에 참여하세요.

GroupSession은 그룹 활동의 장치 간의 실시간 세션을 나타내는 객체이다.

최신 그룹 활동, 연결 상태 및 세션에 연결된 활성 참가자 세트와 같은 세션에 대한 상태를 제공합니다.

잠시 후에 볼 수 있듯이, 그것은 재생을 동기화하는 데에도 사용됩니다.

GroupSession AsyncSequence는 GroupSessions를 앱에 제공합니다.

당신의 앱은 GroupSession 객체를 직접 인스턴스화하지 않으므로, 이것이 GroupSessions를 받을 수 있는 유일한 방법입니다.

로컬 및 원격 장치 모두에서 이 시퀀스에서 최신 GroupSession을 받아야 한다는 점에 유의하는 것이 중요합니다.

AsyncSequence는 앞서 언급한 Swift Concurrency 토크에서 다룹니다.

Code에서 GroupSessions AsyncSequence에서 기다리는 모습은 다음과 같습니다.

GroupActivity가 활성화되면, 시스템은 AsyncSequence에서 Await 루프로 GroupSession을 반환합니다.

이제 GroupSession을 받았으니, 재생 동기화를 설정하는 방법을 알아봅시다.

AVFoundation의 최신 릴리스는 AVPlaybackCoordinator라는 새로운 유형을 소개합니다.

모리츠는 나중에 대화에서 이 객체에 대한 더 많은 정보를 제공할 것이지만, 지금은 동기화된 재생을 가능하게 하는 재생 코디네이터에 GroupSession을 첨부하는 방법을 보여 드리겠습니다.

재생 코디네이터에 액세스하는 방법은 AVPlayer의 playbackCoordinator 속성입니다.

그런 다음, groupSession을 코디네이터에게 첨부하기 위해, 우리는 coordinateWithSession을 호출하고 GroupSession을 전달합니다.

그리고 그게 다야.

후드 아래에서, 프레임워크는 재생 조정과 실시간 네트워킹의 모든 복잡성을 처리합니다.

세션 관리에 대한 마지막 단계가 하나 있는데, 그것은 마침내 세션에 참여하는 것이다.

처음에, GroupSession은 연결되지 않고 대신 "대기" 상태에 있다.

"Join()"을 호출하면 GroupSession을 그룹에 연결하고 실시간 연결을 시작하여 그룹의 다른 장치에서 메시지를 보내고 받을 수 있습니다.

GroupSession이 성공적으로 가입되면, 재생 동기화가 시작됩니다.

이 세션 관리 코드를 샘플 앱에 추가합시다.

CoordinationManager에서 세션의 비동기 시퀀스를 대기 루프에 추가해 봅시다.

기억하세요, 이것은 로컬 또는 원격 장치에서 활성화되었을 때 앱 GroupSessions를 제공합니다.

이 groupSession을 CoordinatorManager에 저장하여 변경 사항을 MoviePlayerViewController로 전파합시다.

설정되면, 우리는 playbackCoordinator .coordinateWithSession을 통해 세션 객체를 AVPlayer에 첨부할 것입니다.

그런 다음, 우리의 대기 루프로 돌아가서, 우리는 세션 객체에서 영화를 가져올 것이다.

활동이 세션 내내 바뀔 수 있기 때문에, 우리는 활동을 얻기 위해 결합 게시자를 사용합니다.

그런 다음, 우리는 재생을 시작하기 위해 영화를 대기시킨다.

그리고 마지막으로, 우리는 세션에 참여한다.

이제 GroupSession을 받고 재생을 동기화하기 위한 코드를 설정했으니, 장치에서 앱을 실행하고 무슨 일이 일어나는지 봅시다.

다시 말하지만, 두 장치는 FaceTime 통화 중이며, 첫 번째 장치에서 샘플 앱을 열고 링 비디오를 공유할 것입니다.

모리츠의 장치가 그룹 활동을 받은 것을 볼 수 있으므로, 우리는 앱을 실행할 것입니다.

그리고 이번에는, 두 장치 모두 올바른 비디오를 보여준다.

그런 다음, "재생"을 누르면 재생 동기화가 작동하는 것을 볼 수 있습니다.

그리고 내가 한 쪽에서 멈추면, 다른 쪽에서 멈출 것이다.

아니면 내가 앞으로 나아갈 수 있고, 둘 다 앞으로 나아갈 거야.

그리고 재생은 완벽하게 동기화된다.

GroupSession에 대해 마지막으로 주목해야 할 한 가지는 세션이 어떻게 끝났는지이다.

그룹세션을 끝내는 방법은 두 가지가 있다.

첫 번째는 휴가()입니다.

이것은 세션에서 로컬 사용자의 연결을 끊지만, 통화의 나머지 참가자를 위해 세션을 활성 상태로 둡니다.

두 번째는 끝이다.

이것은 지역 참가자뿐만 아니라 전체 통화에 대한 세션을 끝낸다.

고급 GroupActivities 앱 생성에 대한 자세한 내용은 다음 WWDC 세션인 "그룹 활동으로 사용자 지정 경험 구축"을 참조하십시오.

GroupSession의 활동을 변경하는 방법, GroupSession의 상태를 관찰하는 방법, 그룹 간에 임의의 메시지를 보낼 수 있는 GroupSessionMessenger와 같은 고급 기능을 사용하는 방법을 다룹니다.

난 그걸 강력히 추천해.

기어를 바꾸고 사진 속 사진을 활용하여 비디오 그룹 활동을 가능한 한 원활하게 공유할 수 있는 방법을 살펴봅시다.

GroupActivities 앱에 대해 생각할 가치가 있는 이유는 무엇인가요?

음, Picture-in-picture를 지원하면 콘텐츠가 공유된 후 즉시 재생을 시작할 수 있습니다.

현재 컨텍스트에서 사용자를 빼내지 않기 때문에, 재생을 시작하기 위해 노골적인 사용자 상호 작용이 필요하지 않습니다.

이것은 사용자에게 추가 단계를 절약하고 콘텐츠를 공유할 수 있는 마찰 없는 경험을 제공합니다.

화면 속 화면 설정에 대한 자세한 내용은 "AVKit으로 직관적인 미디어 재생 전달"에 대한 2019 WWDC 세션을 참조하십시오.

그러나, Picture-in-picture가 GroupActivitities와 어떻게 작동하는지에는 몇 가지 뉘앙스가 있으므로, 이제 그것들을 살펴봅시다.

GroupActivities 프레임워크는 백그라운드에서 미디어 앱에 세션을 제공하여 앱에 화면 속 화면을 설정할 수 있는 기회를 제공합니다.

GroupSession이 백그라운드에서 재생을 시작할 수 있음을 나타내는 경우, Picture-in-picture를 설정한 다음 일반 GroupActivities 흐름을 진행해야 합니다.

이 시스템은 앱을 전체 화면으로 실행하지 않고 화면 속 화면의 콘텐츠를 재생하기 시작하므로 사용자는 원활한 경험을 얻을 수 있으며 현재 컨텍스트에서 벗어나지 않습니다.

하지만 경우에 따라, 사용자가 앱에 로그인해야 할 수도 있고, 사용자의 추가 단계 없이는 콘텐츠를 사용할 수 없을 수도 있기 때문에 Picture-in-picture를 설정할 수 없습니다.

이러한 경우, GroupSession은 앱이 포그라운드를 요청할 수 있는 API를 제공합니다.

우리가 Picture-in-picture에 내장한 또 다른 편리한 점은 시스템 대화 상자를 통해 GroupSession을 떠나고 종료하는 것을 처리하므로 Picture-in-picture가 활성화되어 있을 때 세션을 떠나거나 종료하는 것에 대해 걱정할 필요가 없습니다.

그리고 이제, 나는 재생 코디네이터 객체에 대해 깊이 파고들기 위해 그것을 내 동료인 모리츠에게 넘길 것이다.

안녕하세요, 제 이름은 Moritz Wittenhagen이고, AVFoundation 팀의 엔지니어입니다.

헤이든은 AVPlaybackCoordinator를 여러 장치에서 자동으로 재생을 동기화하는 객체로 소개했으며, 데모에서 작동하는 것을 보았습니다.

이야기의 이 부분에서, 나는 코디네이터가 실제로 하는 일과 그것이 당신의 코드와 어떻게 상호 작용하는지를 신비화할 것이다.

대부분의 경우, 저는 코디네이터가 AVPlayer와 상호 작용하는 방법, 조정된 재생을 위해 자산을 선택하는 방법, 개별 참가자가 조정을 일시적으로 중단할 수 있는 방법에 초점을 맞출 것이며, AVPlayer를 사용하지 않을 때 조정을 구현하는 방법에 대한 간략한 통찰력을 제공할 것입니다.

AVPlaybackCoordinator는 장치 간에 재생 상태를 공유하는 객체이며, 아무도 콘텐츠를 놓치지 않기 위해 해당 장치에서 재생 시작을 조정합니다.

코디네이터에는 두 개의 하위 클래스가 있다.

AVPlayerPlaybackCoordinator의 인스턴스는 항상 특정 AVPlayer에 연결되어 있으며, 모든 원격 상태 관리를 처리합니다.

이것은 조정된 재생에 뛰어드는 가장 쉬운 방법이며, 여기서 시작하는 것을 강력히 추천합니다.

우리는 AVDelegatingPlaybackCoordinator에 대해 많이 이야기하지 않을 것이지만, 이 하위 클래스는 AVPlayer가 아닌 다른 재생 객체를 제어할 수 있는 유연성을 제공합니다.

장치 설정을 다시 살펴봅시다.

나머지 이야기 동안, 우리는 GroupSession을 통해 GroupActivities 객체를 대표할 것이다.

우리는 또한 당신의 UI가 AVPlayerItem을 재생하는 AVPlayer를 제공한다고 가정하며, 이것이 새로운 AVPlayerPlaybackCoordinator가 들어오는 곳입니다.

Hayden이 이전에 보여준 것처럼 코디네이터 coordinateWithSession에 전화할 때, 우리는 두 AVPlayer를 효과적으로 연결했고, 그들은 서로에게 영향을 미치기 시작합니다.

기본 규칙은 코디네이터가 전송 제어 API를 가로챌 것이므로 속도나 현재 시간을 변경하는 모든 API입니다.

그 명령이 필요하고, 다른 사람과 조정해야 하는지 파악한 다음, 적절한 시간에 AVPlayer에 적용할 수 있습니다.

예를 들어 봅시다.

여기, Hayden과 저는 GroupSession에 함께 있으며, GroupActivity가 어떤 URL을 로드해야 할 것인지 알려줬기 때문에 동일한 AVPlayerItem을 수열에 넣었습니다.

이제, 내 장치가 AVPlayer의 속도 속성을 변경하면, 재생 코디네이터는 그 명령을 가로채고 플레이어가 즉시 재생을 시작하지 않을 것이다.

대신, 플레이어에게 WaitingToPlayAtSpecifiedRate의 timeControlStatus를 입력하도록 요청할 것이다.

UI는 일반적으로 대기 중인 스피너로 이 timeControlStatus를 나타낼 것이다.

그러면 코디네이터는 헤이든의 아이패드로 명령을 보낼 것이다.

AVPlayerPlaybackCoordinator는 명령을 받고 마찬가지로 Hayden의 AVPlayer에게 속도를 변경하고 대기 상태를 입력하도록 요청합니다.

코디네이터는 모든 사람이 콘텐츠를 놓치지 않고 동시에 재생을 시작하는 것을 목표로 재생을 준비할 시간을 준다.

모두가 갈 수 있을 때, 모든 장치가 함께 재생을 시작합니다.

세션의 모든 코디네이터는 동등하며, 이는 헤이든도 명령을 시작할 수 있다는 것을 의미한다.

그가 이번에 찾게 하자.

다시 말하지만, 검색 API가 차단되고, 코디네이터는 AVPlayer가 연결된 코디네이터와 명령을 공유하는 동안 기다리도록 강요한다.

모든 사람에게 탐색을 완료할 시간이 주어지며, 모든 장치가 다시 갈 준비가 되면, 모두가 함께 재생을 재개합니다.

AVPlayers가 다른 아이템을 플레이할 때 어떻게 되는지 스스로에게 물어볼 수 있습니다.

그리고 대답은 코디네이터가 두 플레이어가 동일한 콘텐츠를 재생할 때만 다른 플레이어에게 상태를 적용한다는 것이다.

나는 나중에 정체성의 개념에 대해 자세히 설명할 것이다.

현재로서는, 같은 URL에서 항목을 만들 때 콘텐츠가 동일하다고 생각하세요.

이것이 의미하는 바는 항목 A에 대해 보내는 모든 명령은 수신기가 항목 A를 재생하는 경우에만 적용된다는 것입니다.

그리고 항목을 B로 변경하면 항목 A의 모든 상태가 무시됩니다.

우리는 항목별 명령을 구별하면 참가자의 안전한 참여와 항목 간의 전환을 허용하기 때문에 이것을 합니다.

내 말이 무슨 뜻인지 보여줄게.

여기 다시 우리의 예가 있지만, 이번에는 헤이든이 이미 놀고 있는 것으로 시작합니다.

재생 코디네이터를 같은 세션에 연결하고 연결할 때, 내 AVPlayer에는 아무 일도 일어나지 않습니다. 왜냐하면 나는 Hayden과 같은 현재 아이템을 재생하고 있지 않기 때문입니다.

같은 아이템을 만드는 것조차도 그 아이템이 내 플레이어에 현재 있지 않기 때문에 영향을 미치지 않는다.

이것은 내가 다른 누구에게도 결과 없이 그 물건을 찾을 수 있다는 것을 의미한다.

항목이 AVPlayer에서 현재 상태가 될 때만 코디네이터가 작업을 시작하고 올바른 상태를 적용하려고 합니다.

규칙은 코디네이터가 있다면 항상 그룹 상태로 시작한다는 것이다.

그리고 헤이든은 이미 그룹세션에서 놀고 있었기 때문에, 코디네이터는 아이템을 주문하기 전에 내 자신의 구성보다 자신의 상태를 선호한다.

이것은 내 코디네이터가 Hayden의 장치와 일치하도록 AVPlayer와 AVPlayerItem의 모든 구성을 재정의한다는 것을 의미합니다.

그리고 그것으로, 우리는 둘 다 같은 상태에 있고 함께 놀 수 있다.

아이템 전환으로 이것을 반복합시다.

우리 둘 다 아이템 A의 끝에 접근함에 따라, 내 AVQueuePlayer는 다음 아이템을 플레이할 준비를 하고 있다.

보통, 우리는 헤이든도 준비할 것으로 예상하지만, 이 예에서는 헤이든의 아이패드가 나쁜 네트워크에 있고 아직 다음 항목을 로드할 수 없다고 가정해 봅시다.

그래서, 이제 내가 아이템 A의 끝에 있기 때문에, 나는 이미 아이템 B를 줄에 넣고, 플레이할 준비가 되었다.

하지만 그 항목이 최신이 아니기 때문에, 코디네이터는 아직 아무것도 하지 않고 있다.

내 플레이어가 새로운 아이템으로 전환할 때만, 코디네이터는 그 일을 다시 할 것이다.

그리고 이번에는 아이템 B에 대한 기존 상태를 찾을 수 없으므로, 내 플레이어가 제안하는 상태로 계속됩니다.

코디네이터가 이 새로운 상태를 헤이든과 공유하지만, 그는 여전히 항목 A를 표시하고 있기 때문에 영향을 받지 않는다.

하지만 그가 결국 내 아이템과 일치하도록 전환할 때, 그의 코디네이터는 그의 플레이어에게 기존 상태를 다시 적용할 것이다.

그리고 그것으로, 모두가 다시 동기화되어 놀고 있다.

이 모든 것 후에, 여기 나의 첫 번째 행동 촉구가 있다.

물품 변경 순서와 운송 제어 명령에 주의하세요.

아이템을 큐에 넣고 자동으로 재생을 시작하는 beginPlayback 기능이 있다고 가정해 봅시다.

이 코드는 사용자가 재생할 것을 선택하거나 GroupSession이 새로운 활동을 알려줄 때마다 호출됩니다.

우리가 먼저 시작 시간을 찾는 것이 중요하며, 마찬가지로, 우리의 초기 구성이 다른 누구에게도 영향을 미치지 않도록 아이템이 매겨지기 전에 플레이어 비율을 변경해야 합니다.

우리가 이 순서대로 한다면, 재생 코디네이터는 우리가 첫 번째이고 우리의 상태를 다른 모든 사람들과 공유해야 하는지, 아니면 다른 상태가 이미 존재하는지 결정할 수 있으며, 대신 우리의 상태를 무시해야 합니다.

또한, 전송 제어 명령을 감사하고 그룹의 모든 사람에게 영향을 미치는지 고려하십시오.

일반적으로, API 호출은 재생 UI에서 비롯된 경우 그룹에 영향을 미쳐야 한다.

그래서 사용자가 일시 중지하면, 다른 모든 사람들도 일시 중지해야 합니다.

이 경우, 평소와 같이 AVPlayer API를 호출하세요.

그래서, 재생 UI에서 오지 않는 다른 API 호출은 어떻게 해야 하나요?

보통, 이것들은 당신의 앱이 일부 시스템 이벤트에 발생했기 때문에 자동 일시 정지입니다.

이와 같은 자동 일시 정지는 보통 다른 참가자들에게 영향을 미치지 않아야 한다.

사용자가 다른 사람들과 함께 놀고 있는 그러한 상황에서, 당신은 먼저 전혀 멈추지 않는 것을 고려해야 합니다.

다른 모든 사람들이 계속 플레이하기 때문에, 사용자들은 일시적으로 콘텐츠를 볼 수 없는 것과 같은 일종의 단점이 있더라도 종종 그룹을 고수하는 것을 선호할 것이다.

일시 중지하는 것 외에 다른 선택의 여지가 없다면, 두 가지 옵션이 있습니다: 먼저 항목을 제거하거나, 조정된 재생 중단을 시작하십시오. 이 이야기의 뒷부분에서 다루겠습니다.

이제 재생 코디네이터가 어떻게 작동하는지 알게 되었으니, 조정된 재생을 위한 콘텐츠에 대해 이야기해 봅시다.

앞서 언급했듯이, 우리는 자산이 동일한 URL에서 생성되었을 때 서로 다른 장치의 두 플레이어 항목이 동일하다고 생각합니다.

이 기본값은 잘 작동할 수 있지만, 이 행동을 바꾸고 싶은 상황이 있습니다.

예를 들어, 앱은 사용자에게 장치에서 콘텐츠를 다운로드하고 캐시할 수 있는 선택권을 제공할 수 있습니다.

그래서, 내가 자산을 로컬 캐시에 다운로드했고, 헤이든이 여전히 클라우드에서 콘텐츠를 스트리밍하고 있다면, 우리는 더 이상 동일한 URL을 사용하지 않습니다. 즉, 재생 코디네이터가 재생 상태를 동기화하지 않을 것입니다.

마찬가지로, 여러분 중 일부는 URL 표현이 전혀 없는 AVMutableMovies 또는 AVCompositions의 상태를 조정하기 위한 흥미로운 사용 사례가 있을 수 있습니다.

다시 말하지만, 재생 코디네이터는 여기서 무엇을 해야 할지 모른다.

이 문제를 해결하기 위해, AVPlayerItem의 식별자로 사용자 지정 문자열을 제공할 수 있습니다.

이 문자열이 존재한다면, 코디네이터는 그것을 사용하여 두 항목이 동일한 내용을 나타내는지 결정하고 URL을 무시할 것이다.

AVPlayerPlaybackCoordinator Delegate 프로토콜과 playbackCoordinator identifierFor playerItem 기능을 구현하여 이를 수행합니다.

코디네이터는 플레이어의 아이템을 대기열에 쥄할 때마다 대리인에게 식별자를 요청할 것이다.

재생 코디네이터가 두 항목을 동일하다고 생각할 때마다, 한 장치의 시간이 다른 장치의 시간과 일치하는 것이 중요합니다.

이것은 서버에 의해 재생 스트림에 자동으로 주입되는 콘텐츠에 주의해야 한다는 것을 의미합니다.

그래서, 헤이든과 내가 같은 URL을 요청하지만, 서버가 내 스트림에만 광고를 삽입하기로 결정한다면, 내가 광고를 재생할 때 장치는 이제 동기화되지 않으며, 헤이든은 주요 콘텐츠를 계속한다.

이 문제에 접근하는 올바른 방법은 광고와 기타 중간 광고를 별도의 플레이어로 옮기는 것이다.

그것은 주요 자산에 영향을 받지 않는다.

이제, 내가 광고에 참여하면서, 내 핸드폰은 광고 기간 동안 다른 플레이어로 전환된다.

그리고 광고가 끝나면, 코디네이터는 다른 모든 사람들의 타이밍에 쉽게 다시 참여할 수 있으며, 우리는 다시 동기화됩니다.

HLS 콘텐츠를 재생하는 경우, AVPlayer는 새로운 AVPlayerInterstitialEvent API를 통해 이를 도울 수 있습니다.

자세한 내용은 HLS 토크에서 역동적인 프리롤과 미드롤을 확인하세요.

요약하자면, URL이 올바른 정보를 포함하지 않는 경우 사용자 지정 식별자를 사용하여 콘텐츠를 일치시키세요.

모든 사람에게 시간이 같은지 확인하세요.

그리고 개인화된 인터스티셜을 플레이하고 싶다면, 주요 콘텐츠가 영향을 받지 않도록 다른 플레이어를 통해 플레이하세요.

그리고 마지막으로, 코디네이터가 다른 사람들과 정확한 타이밍을 공유할 수 있도록 라이브 콘텐츠를 조정할 때 날짜 태그를 사용하세요.

지금까지, 우리는 모든 사람이 항상 동기화할 수 있는 완벽한 재생 사례만 처리했습니다.

불행하게도, 그것이 항상 가능한 것은 아니다.

헤이든과 내가 함께 놀고 있다고 가정해 봅시다. 하지만 내 고양이 조로에게 먹이를 주라는 알람이 울립니다.

AVAudioSession의 규칙에 따라, 내 앱은 이제 일시 중지되어야 하며, 그룹에서 플레이할 때에도 그 규칙은 여전히 적용됩니다.

그러나, 우리는 나의 일시 정지가 다른 모든 사람들에게 영향을 미치는 것을 원하지 않는다.

모든 사람의 작은 일시 정지를 전체 그룹에 전달하는 것은 너무 많은 성가심을 야기할 것이다.

그래서, 대신, 우리는 헤이든의 아이패드가 계속 재생되기를 원한다.

그리고 내가 알람을 해제할 때, 재생은 따라잡아야 하고, 모두가 다시 동기화하여 재생해야 한다.

그렇다면, 우리는 어떻게 이런 행동을 구현할 수 있을까요?

AVCoordinatedPlaybackSuspension이라는 새로운 객체를 사용합니다.

그러한 정지는 한 참가자의 코디네이터와 다른 참가자의 코디네이터 사이의 분리를 나타낸다.

참가자는 그룹과 분리되어 있으며, 플레이어 비율이 변경되거나 더 이상 다른 누구에게도 영향을 미치지 않습니다.

마찬가지로, 그룹에서 오는 요금 변경은 AVPlayer의 요금이나 시간을 변경하지 않습니다.

예를 들어, 이것은 알람이 여전히 재생되는 동안 헤이든이 내 플레이어를 시작할 수 없다는 것을 의미한다.

서스펜션에는 두 가지 종류가 있습니다: 자동 서스펜션과 직접 추가하는 서스펜션.

자동 정지는 플레이어가 자동으로 일시 중지될 때 AVPlayerPlaybackCoordinator에 의해 추가됩니다.

우리는 이미 오디오 세션 중단의 예를 보았지만, 이것은 네트워크 스톨이나 새로운 AVPlayer 인터스티셜 API를 통해 인터스티셜을 재생하는 데에도 적용됩니다.

재생 코디네이터가 추가한 서스펜션은 플레이어가 재생을 재개할 때 종료되며, 플레이어가 타이밍을 현재 그룹 상태와 일치하게 합니다.

예를 들어, 이것은 내 앱이 알람을 해제하는 종료 중단 알림을 처리한 후 플레이어 비율이 다시 변경되면 자동으로 그룹에 다시 합류한다는 것을 의미합니다.

시스템이 조정된 재생 서스펜션을 어떻게 사용하는지에 대한 두 가지 예를 보여드리겠습니다.

여기 반지의 드론 영상을 재생하는 샘플 앱이 있습니다.

우리가 전에 논의했던 중단 예시를 살펴봅시다.

나는 몇 초 안에 꺼지도록 타이머를 설정했으니, 그것을 기다리자.

아, 여기 있어.

이것은 내 왼쪽에 있는 iPad를 일시 중지했지만, 보시다시피, 다른 장치는 여전히 행복하게 재생되고 있습니다.

그리고 타이머를 해제할 때, 왼쪽에 있는 장치의 재생은 다른 장치에 다시 합류하기 위해 앞으로 점프하고 완벽하게 동기화됩니다.

이것이 시스템이 정지를 사용하는 유일한 방법은 아니다.

AVKit은 그것들을 사용하여 스크러빙하는 동안 모든 사람 앞에서 임의의 비디오 프레임이 깜박이지 않도록 합니다.

스크러빙이 내가 상호 작용하는 장치에서만 중간 프레임을 보여준다는 것을 이미 눈치챘을 것입니다.

그래서, 내가 스크러버를 만질 때, 오른쪽의 장치는 계속 재생되는 반면, 왼쪽 장치는 스크러빙 프레임을 보여준다.

내가 스크러버를 놓을 때만 새로운 시간이 다른 장치와 공유되고, 모두를 위해 재생이 재개된다.

이것들은 시스템이 서스펜션을 어떻게 사용하는지에 대한 예이다.

이제, 당신이 어떻게 입양할지 살펴봅시다.

그래서, Xcode로 뛰어들어 실제로 그렇게 합시다.

한 참가자가 방금 놓친 것을 다시 볼 수 있는 기능을 구현하고 싶다고 가정해 봅시다.

아마도 우리가 보고 있는 드론 영상에서 특히 흥미로운 순간이 있었을 것이다.

우리가 지금까지 논의한 모든 코디네이터 행동과 함께, 다시 찾고 다시 노는 것은 모두에게 영향을 미칠 것이다.

그리고 나는 이것이 옳은 일이 될 수 있다는 것을 강조하고 싶다.

가능한 한 많은 사용자들을 함께 유지하도록 노력하세요.

하지만 모두를 위해 다시 찾는 것이 선택 사항이 아니라고 가정해 봅시다.

그래서, 우리가 대신 구축할 것은 우리가 모두와 다시 합류할 때까지 몇 초 후에 다시 찾고 두 배의 속도로 콘텐츠를 재생하는 방법입니다.

나는 이미 내 UI에 사용자가 무언가를 놓쳤다는 것을 나타내는 데 사용할 수 있는 버튼을 추가했다.

그것은 우리의 MoviePlayerViewController에서 이 기능과 연결되어 있다.

그걸 채우자.

여기 플레이어 논리가 있습니다.

우리는 몇 시에 찾아야 할지 알아내고, 다시 찾고, 플레이어 비율을 2로 설정합니다.

우리가 따라잡았을 때, 우리는 1번 속도로 재생을 재개합니다.

지금까지, 재생 코디네이터가 API 호출을 가로챌 것이기 때문에 이 모든 일이 모두에게 일어날 것이다.

여기가 정션이 들어오는 곳이다.

우리가 돌아오기 직전에, 나는 우리 선수를 다른 사람들과 분리하고 싶다.

그리고 우리는 코디네이터의 시작 중단 기능으로 그것을 한다.

그것은 이유가 필요하며, 그 이유를 제공하기 위해, 우리는 새로운 문자열 상수로 Reason 구조를 확장합니다.

이 경우, 무슨 일이 있었는지.

이제, 우리는 시작 서스펜션 콜에서 그것을 사용할 수 있습니다.

코디네이터가 이제 정지되었기 때문에, 우리는 우리 선수만을 위해 요금을 안전하게 찾고 설정할 수 있습니다.

우리가 다른 사람들과 만날 준비가 되면, 우리는 코디네이터에게 그룹의 말을 다시 듣기 위해 신호를 보내야 해, 그래서 우리는 suspension.end()라고 불러.

우리는 실제로 더 이상 플레이어 비율 변경이 필요하지 않다는 점에 유의하십시오.

정학을 끝내는 것은 항상 다른 모든 사람들과 다시 합류할 것이기 때문에, 우리의 선수 비율 변경은 현재 그룹 비율이 무엇이든 간에 다시 바뀔 것이다.

이제, 이걸 시도해 보자.

모두 함께 놀아.

나는 링에 대한 접근 방식과 같은 흥미진진한 이벤트가 그립고, 우리의 새로운 무슨 일이 있었는지 버튼을 탭한다.

그래서, 보시다시피, 제가 상호 작용하고 있는 장치는 콘텐츠를 반복하기 위해 다시 점프합니다.

다른 장치는 영향을 받지 않는 반면, 따라잡기 위해 더 빨리 재생된다.

그리고 이제, 우리는 이미 다시 완벽하게 동기화되었다.

그래서, AVPlaybackCoordinator에서 정지를 시작할 때, 당신은 그 플레이어를 그룹에서 분리하고, 이제 다른 사람에게 영향을 미치지 않고 요금 변경이나 추구를 발행하는 것이 안전합니다.

정학을 끝내면 그룹의 현재 시간과 비율에 다시 합류할 것이다.

그리고, 이 슬라이드의 새로운 기능, 정지를 끝낼 때 선택적으로 그룹에 새로운 시간을 제안할 수 있습니다.

이것이 재생 제어를 놔둘 때만 모든 사람의 시간을 변경하는 스크러빙 서스펜션을 구현할 수 있는 방법입니다.

다음은 AVPlayer 전송 제어 명령이 실제로 다른 참가자들과 공유되는 시기에 대한 요약입니다.

먼저, Hayden이 연설 초반에 보여준 것처럼 그룹 세션을 통해 AVPlayerPlaybackCoordinator를 다른 참가자들과 연결해야 합니다.

둘째, AVPlayer의 현재 AVPlayerItem은 다른 참가자의 플레이어 아이템과 동일한 URL을 가져야 합니다.

또는 자신의 식별자를 제공하는 경우, 동일한 사용자 지정 식별자가 있어야 합니다.

항목이 매겨지면, 모든 검색 및 속도 변경은 조정된 재생 정지를 시작할 때를 제외하고 그룹의 모든 사람에게 영향을 미칩니다.

그리고 AVPlayerPlaybackCoordinator에 대한 논의를 마무리하기 위해, 조정된 재생과 관련된 다른 API의 빠른 둘러보기입니다.

한 사용자의 정지 동안 다른 참가자가 기다리기를 원한다면, 코디네이터의 정지Reasons ThatTriggerWaiting 속성을 사용하여 이것을 구성할 수 있습니다.

이것이 참가자들이 다른 길이의 광고를 가지고 있다면 아무도 콘텐츠를 놓치지 않도록 요청할 수 있는 방법입니다.

다른 참가자의 상태에 대해 자세히 알아보려면, 코디네이터의 다른 참가자 재산과 해당 알림을 살펴보세요.

AVCoordinatedPlaybackParticipant는 특히 위의 정지 ReasonsThatTriggerWaiting을 사용하는 경우 UI를 알리는 데 유용할 수 있는 suspensionReasons 목록을 제공합니다.

코디네이터가 AVPlayer에게 대기를 요청할 때마다, 그것은 새로운 대기 ForCoordinatedPlay 이유와 함께 플레이어 reasonForWaitingToPlay에 반영됩니다.

대기를 재정의하고 즉시 재생을 시작하려면, 다른 참가자의 상태에 관계없이, 플레이어의 playImmediately atRate 기능을 사용하세요.

이로 인해 다른 참가자들이 콘텐츠를 놓칠 수 있으므로, 이 API를 사용할 때 유의하십시오.

AVPlayer는 또한 다른 참가자가 발생했을 때를 포함하여 요금 변경에 대한 더 많은 정보를 제공하는 새로운 rateDidChangeNotification을 가지고 있습니다.

그리고 마찬가지로, AVPlayerItem의 TimeJumpedNotification은 시간 점프가 다른 참가자로부터 비롯되었는지 알려줍니다.

AVPlayerPlaybackCoordinator와 함께 사용할 수 없는 AVPlayer API가 있습니다.

iOS의 기본 시간 피치 알고리즘은 낮은 품질의 제로 레이턴시였다.

이 값은 이제 iOS 15에서 더 이상 사용되지 않습니다.

LowQualityZeroLatency는 조정된 재생에 지원되지 않으며, 이제 더 이상 사용되지 않는 값으로 코드 재설정을 주의해야 합니다.

대신 다른 알고리즘 중 하나를 사용하세요.

또한, AVPlayer의 setRate(time:atHostTime:) 기능을 AVPlayerPlaybackCoordinator와 함께 사용하지 마십시오. 왜냐하면 재생 코디네이터가 외부 시작 동기화와 호환되지 않는 플레이어 타이밍을 담당하는 것이 중요하기 때문입니다.

AVPlayer에 대한 이 모든 이야기 후에, AVPlaybackCoordinator의 두 번째 하위 클래스인 AVDelegatingPlaybackCoordinator에 빠르게 들어가 봅시다.

우리가 논의한 많은 개념은 여전히 재생 코디네이터를 위임하는 데 적용되지만, 당신을 위해 플레이어를 관찰하는 대신, 위임 코디네이터는 재생 상태에 대한 정보를 제공하고 재생 객체에 상태를 직접 적용하도록 요구합니다.

사용자 지정 재생 객체 설정은 다음과 같이 보일 것이다.

UI는 아래의 다른 시스템 렌더링 API 중 하나를 사용하는 플레이어를 제어합니다.

위임 재생 코디네이터는 UI와 플레이어 구현 사이에 적합합니다.

이름에서 알 수 있듯이, AVDelegatingPlaybackCoordinator는 재생, 일시 정지, 탐색 및 버퍼링을 위한 재생 명령을 수신하는 대리자 프로토콜을 구현해야 합니다.

플레이어에게 직접 플레이 명령을 보내는 대신, UI는 코디네이터에게 먼저 말할 것입니다.

그런 다음 코디네이터는 재생 객체의 시간이나 속도를 변경하기 전에 다른 연결된 플레이어와 먼저 협상해야 하는지 결정할 것입니다.

또한 플레이어가 새로운 현재 아이템으로 전환할 때마다 코디네이터에게 알려야 코디네이터가 어떤 명령을 보낼지 알 수 있습니다.

이전과 마찬가지로, 항목은 임의의 문자열로 식별됩니다.

코디네이터가 명령을 보낼 때, 그것은 원래 UI와 수신기 UI에 영향을 미쳐야 한다.

그리고 플레이할 시간이 되면, 그것은 모든 플레이어에게 같은 방식으로 영향을 미쳐야 한다.

재생 객체를 따라가고 명령에 대한 UI를 적절하게 업데이트하는 것은 당신의 책임입니다.

나는 당신의 장치가 이미 준비되었더라도 위임 코디네이터가 종종 당신에게 버퍼링을 시작하라고 말할 것이라고 특별히 말하고 싶습니다.

이것은 코디네이터가 여전히 다른 연결된 참가자를 기다리고 있다는 것을 의미하며, 당신의 UI는 당신이 할 일이 없더라도 그것을 반영해야 합니다.

마지막 경고의 말.

플레이어를 잠시 일시 중지하고 재개하는 경로 변경과 같은 이벤트에 주의하세요.

요청한 타이밍을 고수하고 필요에 따라 그룹 타이밍을 다시 적용하는 것은 당신의 책임입니다.

어떤 이유로든 따라갈 수 없다면, 정지를 사용하여 코디네이터에게 전달해야 합니다.

위임 재생 코디네이터는 또한 자동 정지를 추가하지 않습니다.

이것은 당신이 관련 시스템 이벤트에 대한 중단을 시작하고 끝내야 한다는 것을 의미합니다.

적절한 경우 AVFoundation에서 제공한 이유를 사용하세요.

그리고 한 장치의 위임 재생 코디네이터를 다른 장치의 플레이어 재생 코디네이터에 연결할 수 있지만, 플레이어 재생 코디네이터 끝에서 사용자 지정 식별자를 사용해야 합니다.

마무리하자.

조정된 미디어 재생 앱을 만들려면, GroupActivity를 사용하여 재생 중인 콘텐츠를 정의하고 그룹에 제안하십시오.

앱이 시작되자마자 GroupSessions를 추적하여 사용자가 FaceTime 통화 중이고 함께 놀고 싶을 때를 알아보세요.

그리고 마지막으로, 재생 코디네이터를 GroupSession에 연결하여 모든 사람을 위해 콘텐츠를 동기화하세요.

감사합니다, 그리고 나머지 WWDC를 즐기세요.

[음악].