10049

♪ 베이스 음악 연주 ♪

♪

다니엘 리: "위젯에 인텔리전스 추가"에 오신 것을 환영합니다.

제 이름은 다니엘이고, 저는 애플의 프로액티브 인텔리전스 팀의 엔지니어입니다.

이 세션에서는 위젯이 시스템과 함께 작동하여 사용자에게 지능형 경험을 제공하여 위젯이 필요할 때 바로 나타날 수 있도록 하는 방법을 보여 드리겠습니다.

위젯은 많은 곳에 산다.

iOS의 홈 화면에서 macOS의 알림 센터에 이르기까지, 위젯은 사용자에게 한 눈에 빠르게 볼 수 있는 정보를 제공합니다.

iPadOS 15에서는 위젯이 iPad 홈 화면에도 나타납니다.

이제 위젯이 집으로 전화할 수 있는 장소가 그 어느 때보다 많아졌습니다.

먼저 시스템에서 위젯이 지능적이라는 것이 무엇을 의미하는지에 대해 이야기한 다음, 사용 가능한 API로 관련 정보를 기부하여 위젯에 대한 인텔리전스를 활성화할 수 있는 방법을 보여드리겠습니다.

먼저 위젯 인텔리전스를 살펴봅시다.

iPhone과 iPad에서 위젯은 스마트 스택에 함께 배치할 수 있으며, 한 곳에서 다양한 종류의 정보를 제공하기 위해 스크롤할 수 있습니다.

사용자가 스택을 편집할 때 위젯을 추가, 제거 또는 재정렬할 수 있을 뿐만 아니라 스택의 지능형 동작을 보고 관리할 수도 있습니다.

iOS 14는 스마트 회전을 도입했다.

스마트 회전은 시스템이 적시에 이미 스택에 있는 위젯으로 자동으로 스크롤할 수 있게 해준다.

위젯으로 언제 회전해야 하는지 알기 위해, 시스템은 위젯이 타임라인 항목과 함께 제공하는 관련성 신호를 사용합니다.

또한 사용자의 행동 패턴을 학습하여 위젯으로 회전할 수 있습니다.

사용자가 위젯에 해당하는 정보를 볼 때마다 앱에서 기부를 받아 그렇게 합니다.

스마트 회전을 사용하면, 날씨 위젯, 미리 알림 위젯 및 캘린더 위젯이 스택에 있는 경우, 날씨 위젯은 아침에 일어나면 시스템에 하루를 요약할 수 있도록 스스로를 제안하도록 말할 수 있습니다.

9시 30분에, 달력 위젯은 내가 10시에 회의가 있다는 것을 시스템에 알려줄 수 있으므로, 내 스택이 달력으로 회전할 수 있다.

오후에, 내 리마인더 중 하나는 마감일이 오후 3시이므로, 위젯은 스택에 리마인더로 회전하라고 말할 수 있다.

그리고 저녁에, 날씨 위젯은 방금 비가 내리기 시작했기 때문에 시스템에 날씨를 다시 보여주라고 말할 수 있습니다. 그래서 나는 저녁을 먹으러 나가면 우산을 가져가야 한다는 것을 알고 있습니다.

iOS 15는 사용자가 위젯을 발견하고 사전 예방적이고 관련 있는 정보를 받을 수 있는 새로운 방법인 위젯 제안이라는 새로운 기능을 소개합니다.

위젯 제안이 활성화된 스마트 스택의 경우, 시스템은 아직 포함되지 않은 스택에 새 위젯을 삽입할 수 있습니다.

당신의 앱에서 명시적인 기부를 하면 시스템은 이것을 할 수 있습니다.

그리고 스마트 회전과 마찬가지로, 시스템은 앱에서 사용자의 행동 패턴을 학습하여 위젯 제안을 할 수도 있습니다.

위젯 제안으로, 내 스택에 날씨 위젯과 미리 알림 위젯만 있다면, 나는 여전히 하루 종일 이 위젯에 대한 스마트 회전을 볼 수 있을 것이다.

하지만 나는 10시에 회의가 있고, 내 스택에 캘린더 위젯이 없기 때문에, 캘린더 앱은 시스템에 9시 30분에 위젯을 내 스택에 능동적으로 삽입하라고 말할 수 있으므로 잊지 않는다.

위젯이 더 이상 관련이 없는 후, 시스템은 내 스택에서 그것을 제거할 것이다.

저녁 운동을 마치면, 시스템이 피트니스 위젯을 보여줄 수 있으므로 링을 닫는 데 있어 하루의 진행 상황을 빠르게 요약할 수 있습니다.

그리고 그 후에, 스택은 다시 원래 상태로 돌아갈 것이다.

앱은 유용할 때 일시적으로 위젯을 삽입하도록 시스템에 알려주기 때문에, 사용자가 존재조차 모를 수도 있는 위젯을 발견하는 데 도움을 줄 수 있다.

이제 사용 가능한 API를 사용하여 스마트 회전 및 위젯 제안을 모두 채택하여 관련 신호를 시스템에 기부하는 방법을 알아봅시다.

기부할 때, 위젯이 보여줄 수 있는 모든 가능한 정보를 고려하고 어떤 유형이 다른 유형보다 제안에 더 적합한지 결정해야 합니다.

시스템에 기부하는 방법을 선택할 때 최종 목표는 사용자에게 명백한 가치를 지닌 시기적절하고 눈길을 수 있는 정보를 제공하는 것이므로, 사용자가 다른 사람들보다 더 흥미로울 수 있는 상황을 강조하는 것을 고려해야 합니다.

예를 들어, 날씨 위젯은 임박한 강우량이 눈에 띄지 않게 온도만 변한 시점과는 반대로 제안에 적합한 상황으로 간주할 수 있다.

세 가지 방법으로 위젯에 대한 스마트 회전 및 위젯 제안을 채택할 수 있습니다.

먼저, 앱은 위젯 중 하나에 대한 위젯 제안을 언제 만들어야 하는지 시스템에 알리기 위해 INRelevantShortcut을 기부할 수 있습니다.

둘째, 위젯은 위젯이 스택에 있을 때 스마트 회전을 활성화하기 위해 TimelineEntryRelevance를 통해 관련성 점수를 제공할 수 있습니다.

셋째, 위젯을 구성할 수 있는 경우, 앱이 INInteraction을 사용하여 구성 의도를 기부할 때, 시스템은 스마트 회전과 위젯 제안을 모두 통해 위젯을 홍보하기 위해 사용자의 행동 패턴을 배울 수 있습니다.

이러한 각 API는 강력한 방식으로 위젯의 존재를 향상시키지만 모두 약간 다르게 작동하므로, 분해해 봅시다.

위젯 제안을 위한 INRelevantShortcuts를 기부하는 것으로 시작합시다.

위젯을 구성하기 위해 의도를 사용하든 사용하지 않든, 앱이 사용자에게 위젯을 보여주기 위해 관련성이 높은 상황을 알게 되면, INRelevantShortcut을 기부하면 시스템이 홈 화면에 위젯이 없는 경우 사용자의 스택 중 하나에 위젯을 사전에 삽입할 수 있습니다.

관련 단축키는 관련 있는 기간을 지정하거나 시스템이 사용자의 행동 패턴에 따라 위젯을 삽입할 시기를 결정하도록 할 수 있습니다.

INRelevantShortcut은 정적 및 의도 구성 위젯을 모두 지원하지만 기부는 각 구성 유형에 따라 약간 다르게 보일 것이므로 두 유형을 모두 채택하는 방법을 살펴봅시다.

위젯이 StaticConfiguration을 지원하는 경우, 의도 없이 새로운 INRelevantShortcut을 만들고 widgetKind 속성을 위젯의 종류 문자열로 설정하기만 하면 됩니다.

이것은 어떤 앱의 위젯을 제안해야 하는지 시스템에 알려줍니다.

그런 다음, 선택적으로 relevanceProviders 속성을 INRelevanceProviders 배열로 설정하십시오.

이것은 언제 위젯을 제안해야 하는지 시스템에 알려줍니다.

나는 이것을 조금 더 자세히 설명할 것이다.

위젯이 IntentConfiguration을 지원하는 경우, 필요한 매개 변수로 구성에 사용되는 인텐트의 인스턴스를 만드세요.

그런 다음 의도를 INShortcut으로 전달하여 INRelevantShortcut을 만드세요.

그리고 물론, 정적 위젯과 마찬가지로 widgetKind와 relevanceProviders 속성을 설정하세요.

관련 단축키를 기부하려면, 기본 INRelevantShortcutStore에서 설정할 관련 단축키 배열에 포함시키세요.

기부된 단축키를 업데이트하려면, 상점의 관련 단축키 배열을 새 배열로 바꿀 수 있습니다.

이것은 이전에 기부된 관련 단축키를 새 배열에서 생략하여 무효화할 수 있다는 것을 의미합니다.

그리고 의도가 포함된 관련 단축키를 기부하면 Siri 시계 페이스에 의도를 드러낼 수 있습니다.

위젯을 언제 삽입할 수 있는지 시스템에 알리려면, 관련 단축키에 INRelevanceProviders 배열을 설정하십시오.

여기에는 두 가지 옵션이 있습니다.

먼저, INDateRelevanceProvider를 사용하여 다가오는 이벤트나 속보와 같은 고정된 알려진 관련 기간에 대한 시작 및 종료 날짜를 제공할 수 있습니다.

여러 공급자를 사용하여 하나 이상의 관련 기간을 지정할 수도 있습니다.

둘째, 위젯에 표시할 새로운 것이 있다는 것을 시스템에 알리기 위해 빈 관련 공급자 배열을 제공하도록 선택할 수 있으며, 시스템은 사용자가 일반적으로 앱을 사용하는 시기에 따라 위젯을 제안할 시간을 선택할 것입니다.

다른 모든 관련 제공 업체는 Siri 시계 페이스에 대한 INRelevantShortcuts를 지원하며 위젯 제안에서 지원되지 않습니다.

이제 예시 앱을 사용하여 입양이 어떻게 생겼는지 안내해 드리겠습니다.

우리는 모든 신용 카드의 거래와 잔액을 볼 수 있고 최근 구매를 보여주는 위젯을 포함하는 카드라는 앱을 만들었습니다.

앱에서 INRelevantShortcuts를 기부하여 최근 구매 위젯에 대한 위젯 제안을 어떻게 활성화할 수 있는지 봅시다.

우리는 최근 구매가 우리 카드 중 하나에서 이루어진 후 위젯을 제안하고 싶습니다.

위젯은 의도로 구성되어 있기 때문에, 위젯 제안을 허용하기 위해, 우리는 먼저 우리의 의도가 의도 정의 파일에서 기부를 지원하는지 확인할 것입니다.

여기 ViewRecentPurchases 인텐트에 대한 인텐트 편집기가 있습니다. 이 인텐트 편집기는 위젯에 표시할 신용 카드와 구매를 필터링할 판매자 카테고리를 알려줍니다.

우리는 "의향은 Siri 제안에 대한 자격이 있다"가 체크되어 있는지 확인하고 싶습니다.

이것은 우리가 기부하기로 선택한 경우 iOS 주변의 다른 장소의 제안뿐만 아니라 홈 화면의 위젯에 대한 제안을 가능하게 하지만, 나중에 INInteractions를 통해 그렇게 할 수 있습니다.

그런 다음 의도를 형성하는 데 필요한 매개 변수를 포함하는 매개 변수 조합을 만들어야 합니다.

위젯을 구성하려면 신용 카드와 판매자 카테고리가 모두 필요하기 때문에, 카드와 카테고리 매개 변수 모두에서 지원되는 조합을 만들 것입니다.

이제 우리는 코드에서 의도를 만들 수 있다.

이 코드에서, 우리 앱은 사용자가 방금 구매했다는 알림을 받았습니다.

기부를 하기 위해, 우리는 여러 단축키를 기부하고 싶을 경우를 대비하여 빈 INRelevantShortcuts 배열을 만드는 것으로 시작합니다.

우리는 최근 구매 위젯을 구성하는 데 사용한 의도를 초기화하고 필요한 매개 변수를 설정합니다.

여기서, 우리는 최근 구매가 이루어진 카드를 참조하는 카드 객체에 대한 인텐트에 대한 카드 매개 변수를 설정하고, 위젯이 해당 카드의 모든 구매를 표시하도록 범주를 모두 설정하려고 합니다.

그런 다음 우리는 의도로 INShortcut을 만들고 그것으로 INRelevantShortcut을 만듭니다.

사용자가 위젯에서 정보를 보기 때문에 바로 가기 역할을 정보 바로 가기 역할로 설정하고 widgetKind를 설정합니다.

우리는 지금 시작하여 30분 또는 1800초 후에 끝나는 INDateRelevanceProvider를 제공하여 시스템이 구매 후 30분 후에 제거할 수 있도록 합니다.

그런 다음 관련 단축키 배열에 단축키를 추가합니다.

마지막으로, 우리는 기본 INRelevantShortcutStore에서 관련 단축키 배열을 설정하여 단축키를 기부하고 완료 핸들러의 오류를 처리합니다.

이제 최근 구매가 이루어질 때마다, 시스템은 스마트 스택에 사전에 삽입하여 위젯으로 위젯 제안을 할 수 있습니다.

이제 TimelineEntryRelevance에 대해 이야기해 봅시다.

위젯이 WidgetKit에 타임라인을 제공할 때, 각 타임라인 항목에 TimelineEntryRelevance를 제공하여 위젯의 관련성을 지정할 수 있습니다.

관련성이 있는 항목에 주석을 달면 위젯이 항목 당시 스마트 회전의 가치가 있음을 나타냅니다.

이러한 회전의 가치는 위젯이 제공하는 타임라인의 다른 모든 항목과 관련이 있으므로, 어떤 항목이 다른 항목보다 사용자와 더 관련이 있는지 결정해야 합니다.

TimelineEntryRelevance는 입력 날짜와 함께 TimelineEntry의 선택적 구조체 속성입니다.

관련성 구조체는 점수와 기간을 포함한다.

구조체의 부동 점수는 이 항목이 다른 항목과 얼마나 관련이 있는지를 나타낸다.

점수가 높을수록, 시스템이 위젯으로 회전할 가능성이 높아진다.

반환할 점수를 결정할 때, 긍정적인 점수는 Smart Rotate를 받을 수 있는 타임라인 항목을 나타낸다는 것을 알아두세요.

0점은 위젯에 표시할 정보가 없을 때와 같이 위젯을 회전해서는 안 된다는 것을 시스템에 알려주고 위젯으로 회전하는 것은 사용자에게 긍정적인 경험이 아닐 것이다.

제공된 점수의 중요성은 위젯의 타임라인에서 다른 사람들과 관련이 있다는 것을 기억하세요.

관련성 점수에 사용하기로 결정한 스케일링이 무엇이든, 반환하는 타임라인에서 일관성이 있는지 확인하세요.

우리는 잠시 후에 예시를 검토할 것이다.

관련성 구조의 기간은 관련성 점수가 유효한 기간을 지정합니다.

시스템은 이것을 항목의 날짜와 함께 사용하여 스택을 위젯으로 회전할 유효한 기간을 결정합니다.

기간이 지나면, 시스템은 향후 항목에서 관련성이 다시 제공될 때까지 점수를 0으로 취급할 것이다.

관련성을 제공하는 다음 항목까지 점수를 유효하게 유지하기 위해 0의 기간을 지정할 수 있습니다.

이것이 코드에서 어떻게 생겼는지 살펴봅시다.

여기 TimelineEntry 프로토콜을 준수하는 CardRecentPurchasesEntry 구조체가 있습니다.

프로토콜은 선택적 관련성 속성을 요구하기 때문에, 우리는 구조체에서 관련성 속성을 선언할 수 있다.

이제 타임라인 항목을 만들 때, 타임라인을 만들 때 항목에 TimelineEntryRelevance 인스턴스를 첨부할 수 있습니다.

이제 최근 구매 위젯의 타임라인이 어떻게 생겼는지 살펴보고 타임라인 관련성에 대해 제공할 수 있는 점수에 대한 몇 가지 예를 살펴봅시다.

다음은 최근 구매 위젯이 하루 종일 돌아올 수 있는 예시 타임라인입니다.

우리는 아마도 사용자가 더 높은 지출을 포함하는 구매에 더 관심이 있다고 생각할 수도 있다.

그런 다음 우리는 지출된 금액으로 구매에 대한 점수를 선형적으로 조정할 수 있습니다.

지금은 관련 기간을 0으로 남겨두자.

8시 15분에, 우리는 보여줄 구매가 없기 때문에 0점을 돌려줄 것이다.

9시 41분에, 우리의 52달러와 60센트 구매는 우리의 점수가 52.6이 될 것이라는 것을 의미한다.

그래프에 플로팅하면, 우리는 우리의 쇼핑이 다른 점수에 비해 상대적으로 높은 점수를 가지고 있다는 것을 알 수 있으므로, 시스템은 다른 항목보다 이 항목으로 위젯으로 더 많이 회전하는 것을 우선시할 것이다.

다른 항목들은 여전히 긍정적인 점수를 가지고 있기 때문에, 시스템은 더 낮은 우선 순위로 여전히 그 시간에 위젯으로 회전할 수 있다.

그리고 기간을 0으로 설정했기 때문에, 관련성 점수는 관련성 업데이트가 있는 다음 타임라인 항목까지 유효합니다.

우리는 또 다른 채점 메커니즘을 선택할 수도 있었다.

구매가 50달러 이상인 경우 50점을 반환하고, 아래에서 구매 시 1점을 반환한다고 가정해 봅시다.

다시 한번, 우리는 구매가 전혀 없다면 0을 반환합니다.

식료품과 쇼핑 구매를 위해 우리는 50을 돌려주었고, 수프 다이너와 영화관에서의 지출을 위해 우리는 1을 돌려주었다.

점수 그래프를 통해, 우리는 점수가 9시 41분에 50으로 올라가고 6시 52분까지 거기에 머무르는 것을 볼 수 있다.

50이 우리 타임라인에서 가능한 가장 높은 점수이기 때문에, 시스템은 현재 우리의 위젯을 보여줄 가능성이 가장 높다.

우리의 위젯은 최근 구매를 보여주기 때문에, 우리는 시스템이 오래 전에 구매한 위젯으로 회전하는 것을 원하지 않습니다.

따라서 구매 후 30분 이내에 시스템이 위젯으로 회전할 수 있도록 합시다.

이를 달성하기 위해, 우리는 관련성 구조체에 기간 속성을 사용할 수 있다.

우리는 각 항목에 대해 30분 또는 1800초의 관련 기간을 설정했습니다.

관련 기간을 30분으로 설정함으로써, 우리는 시스템에 항목을 30분 동안 로테이션 자격이 있는 것으로 표시한 다음, 그 후에 로테이션 자격이 없는 것으로 표시하라고 말하고 있습니다.

이 예에서, 우리는 구매 금액의 점수를 기반으로 하고 있지만, 실제로, 타임라인 관련성 점수는 당신이 원하는 무엇이든 될 수 있습니다.

우리는 또한 어떤 신용 카드인지, 구매가 이루어진 곳, 구매가 이루어졌을 때, 또는 완전히 다른 것을 사용할 수 있었다.

그걸 할 수 있는 올바른 방법은 하나도 없어.

이제 INInteractions를 기부합니다.

앱에서 INInteractions를 통해 스마트 회전과 위젯 제안을 모두 활성화하도록 위젯을 구성하는 데 사용되는 인텐트를 만들고 기부할 수 있습니다.

앱은 사용자가 위젯이 보여주는 정보에 해당하는 앱의 정보를 볼 때마다 INInteraction을 기부합니다.

각 기부는 사용자가 앱에서 정보를 보는 경향이 있을 때를 배우는 시스템의 행동 모델의 데이터 포인트입니다.

모델이 사용자가 상호 작용을 다시 수행하고 싶어할 것이라고 예측할 때마다, 시스템은 의도에 대한 제안을 만든다.

그리고 기부된 의도가 위젯을 구성하는 데 사용된 것과 동일한 한, 시스템은 시스템 주변의 다른 제안과 함께 예측에서 스마트 회전과 위젯 제안을 자동으로 생성합니다.

카드 프로젝트에서 INInteraction을 기부하기 위해, INRelevantShortcuts를 기부하는 것과 마찬가지로, 우리는 우리의 의도가 제안을 받을 자격이 있는지 확인하고, 위젯을 구성하는 데 필요한 매개 변수와 지원되는 조합을 만들고 싶습니다.

여기서, 또한 결국 당신의 기부가 시스템의 다른 위치에 나타날 때를 위한 제안 UI를 설계해야 합니다.

카드 앱에서, 사용자가 카드에 대한 모든 최근 구매를 볼 때마다, 우리는 사용자가 현재 위젯이 보여주는 정보에 관심이 있다는 것을 시스템에 알리기 위해 위젯의 의도를 기부할 수 있습니다.

먼저, 우리는 우리의 의도를 초기화한다.

우리는 사용자가 현재 보고 있는 카드로 카드 매개 변수를 설정하고, 사용자가 현재 이 카드의 모든 거래를 보고 있기 때문에 카테고리를 모두로 설정합니다.

그런 다음 우리는 INInteraction으로 우리의 의도를 마무리하고 기부 방법을 호출할 것입니다.

이제 시스템은 사용자가 우리 앱에서 이 카드에 대한 최근 구매를 보았다는 것을 알게 될 것이다.

잠시 후, 시스템은 사용자가 언제 이것을 하는 경향이 있는지 알 수 있으며, 가장 적절한 시기에 일치하는 위젯을 제안할 수 있다.

INInteraction 기부는 스마트 회전과 위젯 제안을 활성화할 뿐만 아니라, 시스템이 잠금 화면, 스포트라이트 및 Siri 단축키 제안 위젯에서 Siri 제안으로 의도를 표시할 수 있도록 합니다.

위젯이 의도를 채택하지 않더라도 이것은 사실입니다.

INInteractions 기부가 앱을 위해 무엇을 할 수 있고 온디바이스 인텔리전스에서 더 많은 것을 얻을 수 있는지에 대해 자세히 알아보려면, "기부 의도를 기부하고 앱의 존재를 확장하세요"라는 강연을 확인하십시오. 따라서 INRelevantShortcut, TimelineEntryRelevance 및 INInteraction은 위젯에 대한 스마트 회전 및 위젯 제안을 지원할 수 있는 세 가지 방법입니다.

성능 고려 사항과 함께 시스템의 다른 기부로 인해, 기부는 위젯이 표면화될 것이라는 보장이 아닙니다.

그러나 이러한 API를 응집력 있는 방식으로 채택함으로써, 당신은 시스템과 협력하여 위젯을 보여줄 수 있는 최고의 기회를 제공할 수 있습니다.

개발하는 동안, 설정 앱의 개발자 설정에서 찾을 수 있는 WidgetKit 개발자 모드를 켜서 위젯을 표면화하는 시스템의 한계를 우회하는 것도 도움이 될 수 있습니다.

그래서 마무리하기 위해, 위젯 제안은 위젯이 존재했다는 사실조차 모를 수도 있는 사용자가 필요할 때 위젯을 능동적으로 표시할 수 있는 새로운 방법입니다.

그리고 이미 스택에 추가된 위젯의 경우, Smart Rotate를 사용하면 사용자 하루의 안정적이고 신뢰할 수 있는 부분이 될 수 있습니다.

시스템과 함께 작업하고 온디바이스 인텔리전스를 활용함으로써, 이러한 기능을 통해 위젯을 더 발견할 수 있고 능동적으로 사용할 수 있으며, 지능형 홈 화면 경험에 기여할 수 있습니다.

우리는 당신이 위젯에 지능을 추가하는 방법을 보게 되어 매우 기쁩니다.

고마워 그리고 멋진 WWDC를 보내.

♪