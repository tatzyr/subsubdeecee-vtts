10194

♪ 베이스 음악 연주 ♪

♪

벤 코헨: 안녕하세요, 저는 스위프트 팀의 벤입니다. 이 비디오에서는 스위프트의 새로운 동시성 기능을 사용하기 위해 기존 애플리케이션을 포팅하는 과정을 살펴보려고 합니다.

우리는 이러한 새로운 기능이 어떻게 당신이 더 명확한 비동기 코드를 작성하고, 가능한 경쟁 조건으로부터 보호하는 데 어떻게 도움이 되는지 볼 것이며, 코드를 이 새로운 운영 방식으로 점진적으로 옮기는 몇 가지 기술을 살펴볼 것입니다.

저는 커피 트래커라는 앱을 사용할 것이며, 이는 시계 컴플리케이션을 만들고 업데이트하는 것에 대한 WWDC 2020의 이야기를 기반으로 합니다.

이것은 오늘 마신 모든 커피를 추적할 수 있는 간단한 앱이며, 시계 페이스에 현재 카페인 수치를 보여주는 합병증도 있습니다.

작은 앱이지만, 동시성이 SwiftUI와 어떻게 작동하는지, 워치 SDK의 위임 콜백, 일부 I/O, Apple SDK의 비동기 API와의 인터페이스를 포함하여 우리가 생각하고 싶은 많은 것들을 보여주기 때문에 우리의 목적을 위해 사용하기에 좋은 예입니다.

이제 앱을 빠르게 둘러보자.

그것은 대략 세 층으로 나뉘어져 있다.

먼저, UI 레이어가 있습니다.

이것은 대부분 SwiftUI 뷰이지만, 여기서 우리는 또한 UI 계층의 일부로 합병증 데이터 소스와 같은 것을 고려할 수 있습니다.

다음으로 카페인 음료를 나타내는 몇 가지 간단한 가치 유형과 "커피 모델"이라는 모델 유형으로 구성된 모델 레이어가 있습니다.

이제, 이것이 당신이 UI 모델이라고 부를 수 있는 것입니다.

즉, UI 레이어로 표시할 데이터를 보관하는 곳입니다.

그것은 우리의 SwiftUI 뷰를 공급하는 관찰 가능한 객체이며, 그것에 대한 모든 업데이트는 메인 스레드에서 이루어져야 합니다.

모든 애플리케이션 데이터의 전체 모델이 아닐 수도 있기 때문에 UI 모델로 언급하고 있습니다.

그것은 단지 당신의 데이터 모델이나 그것의 하위 집합의 투영일 수 있습니다; 지금 UI에 표시해야 하는 것입니다.

마지막으로, 우리는 당신이 백엔드 레이어로 생각할 수 있는 것을 가지고 있습니다: 아마도 백그라운드에서 모델을 채우거나 앱 외부의 세계와 이야기하기 위해 일어나는 처리.

우리의 경우, 그것은 사용자의 카페인 섭취량을 저장하고 로드하기 위해 HealthKit과의 통신을 관리하는 이 HealthKitController 유형으로 표시됩니다.

이제, 코드를 보기 전에, 앱에서 동시성이 어떻게 관리되는지에 대해 이야기해 봅시다.

이 아키텍처는 꽤 깨끗해 보이지만, 동시성이 어떻게 처리되는지 레이어링할 때, 우리는 훨씬 더 지저분한 그림을 얻는다.

이 앱은 본질적으로 코드를 실행할 수 있는 세 개의 동시 대기열로 나뉩니다.

UI와 모델에서의 작업은 메인 큐에서 이루어집니다.

이 앱에는 또한 백그라운드에서 작업을 하기 위한 디스패치 대기열이 있다.

그리고 마지막으로, HealthKit에서 결과를 반환하는 것과 같은 완료 핸들러에 대한 특정 콜백은 임의의 대기열에서 수행됩니다.

이건 꽤 흔한 상황이야.

간단한 애플리케이션 아키텍처처럼 보이는 것은 동시성을 처리하는 방법에 대한 많은 숨겨진 복잡성을 무시한다.

이제, 빠른 스포일러를 위해.

스위프트 동시성을 채택할 때, 우리는 이 임시 동시성 아키텍처에서 이렇게 보일 무언가로 갈 것이다.

우리는 주요 배우라고 불리는 것에 UI 뷰와 모델을 넣을 것이다.

우리는 백그라운드에서 작동할 새로운 액터를 만들 것이며, 이러한 유형은 비동기/대기 기능을 사용하여 서로 간에 스레드 안전 값을 전달할 것입니다.

우리가 끝나면, 동시성 아키텍처는 유형 아키텍처만큼 명확하고 설명하기 쉬워야 한다.

이제 우리는 "async/await"와 "actors"와 같이 익숙하지 않을 수 있는 몇 가지 용어를 사용했으며, 코드에서 사용할 때 간략하게 설명할 것입니다.

하지만 이러한 기능에 대한 더 심층적인 설명을 위해, 훨씬 더 자세하게 설명할 수 있는 몇 가지 다른 대화가 있다.

그래서 이제 우리는 전체 아키텍처를 보았으니, 코드에 대해 자세히 알아봅시다.

여기 다른 파일들이 있습니다.

첫째, 일부 스위프트 UI 뷰.

그리고 나서 우리는 시계 컴플리케이션 컨트롤러의 확장 대리인이 있습니다.

우리는 카페인 음료를 나타내는 간단한 모델 유형과 이러한 음료 배열을 보유하고 있는 CoffeeData UI 모델을 가지고 있습니다.

그리고 마지막으로, 우리는 HealthKitController를 가지고 있습니다.

그리고 이 레이어에서 저는 스위프트의 새로운 동시성 기능 중 일부를 앱에 도입하기 시작할 것입니다.

HealthKitController에는 완료 핸들러를 받는 HealthKit SDK에 대한 몇 가지 다른 호출이 포함되어 있습니다.

이 컨트롤러의 저장 작업을 살펴보는 것으로 시작합시다.

그래서 나는 방금 Control-6을 눌렀고, 그것은 이 파일의 기능 목록을 가져오고, 우리는 저장 작업으로 갈 것이다.

이제, 새로운 동시성 기능에 들어가기 전에, 오늘 스위프트의 스레드 안전에 대해 조금 이야기해 봅시다.

이 코드는 일부 변수에 액세스하고, 사용할 수 있으며 저장합니다.

이제, 우리는 이 함수에서 이 변수들만 읽고 있는 것 같다.

그거 안전해?

음 아니, 다른 코드가 동시에 그들에게 쓸 수 있다면 아니야.

이 코드가 스레드로부터 안전한지 아닌지 알기 위해, 나는 이 기능을 보는 것보다 더 많은 정보가 필요하다.

디스패치 대기열이나 잠금을 사용하지 않으므로, 이 코드를 스레드로 안전하게 만드는 것은 무엇이든 다른 곳에 있어야 합니다.

아마도 발신자는 대기열을 통해 저장하기 위해 모든 통화를 직렬화할 것이다.

아니면 앱이 어떤 식으로든 구성되어 있다는 것은 괜찮다는 것을 의미할 수도 있다.

하지만 나는 이 기능을 보는 것만으로는 이것을 알 수 없다.

내 프로그램의 다른 부분을 볼 필요 없이 이 기능을 보고 특정 사항을 알 수 있다는 것은 우리가 지역 추론이라고 부르는 것이며, 스위프트에게 정말 중요한 목표입니다.

예를 들어, 가치 유형에 대한 스위프트의 강조는 지역 추론에 관한 것이다.

참조 유형과 달리, 전달된 값 유형이 프로그램의 다른 곳에서 변형되고 있다고 걱정할 필요가 없습니다.

Swift 5.5에서 동시성을 위해 도입된 많은 언어 기능은 코드에 대해 로컬에서 추론할 수 있는 더 많은 기회를 제공하는 것입니다.

이제, 우연히도, 이 기능은 완전히 스레드로부터 안전하지만, 나는 그것을 스스로 알아냈다; 컴파일러는 내가 이러한 문제를 발견하는 데 도움이 되지 않는다.

그래서 여기 아래, 우리는 사용자의 건강 데이터에 카페인 샘플을 저장하기 위해 HealthKit SDK에 전화합니다.

그리고 이것은 완료 핸들러를 필요로 하고, 그 완료 핸들러는 두 가지 값을 취한다: 성공 또는 오류.

작업이 성공하면, 오류가 없습니다; 오류는 0이 될 것입니다.

이것은 우리가 상태를 확인하는 것을 기억해야 한다는 것을 의미하며, 적절한 경우, 여기에 선택적 오류를 풀어야 합니다.

이제, 이것은 일반적으로 우리가 스위프트에서 오류를 처리하는 방식이 아니다.

이것은 실패할 수 있는 방법으로 훨씬 더 나을 것이다.

하지만 그 접근 방식은 완료 핸들러와 함께 작동하지 않는다.

하지만 이제, 비동기 메서드를 사용하면, 우리는 던질 수 있는 비동기 함수를 가질 수 있습니다.

이 HealthKit 저장 방법은 이제 정확히 그렇게 하는 비동기 등가물을 가지고 있으므로, 그것을 사용하는 것으로 전환해 봅시다.

그렇게 하기 위해, 먼저 우리는 완료 핸들러를 제거하고, 메소드 호출 앞에 "await"를 씁니다.

이것은 비동기 함수 호출이며, 코드는 이 시점에서 일시 중지되고 다른 코드가 실행되도록 허용한다는 것을 상기시켜줍니다.

우리는 이것이 왜 중요한지 조금 나중에 다시 돌아올 것이다.

그래서 우리가 컴파일한다면, 이제 우리가 이것을 했기 때문에, 우리는 컴파일러가 우리에게 "시도"가 필요하다고 말하고 있다는 것을 알 수 있다.

그리고 이것은 비동기 함수의 큰 이점이다; 그들은 던질 수 있다.

선택적 오류를 확인하는 것을 더 이상 기억할 필요가 없습니다.

그래서 우리는 이 메소드 호출 앞에 "시도"를 추가할 수 있으며, 오류를 즉시 처리하고 싶습니다.

그래서 우리는 이 통화를 할 블록으로 마무리합니다...

그리고 나서 오류를 잡아.

우리는 이 경비원을 제거할 수 있다.

그리고 이제 우리가 오류를 포착하고 있기 때문에, 그것은 더 이상 선택 사항이 아니므로, 우리는 언랩을 제거할 수 있습니다.

이것은 또한 우리가 행복한 경로를 맨 위에 유지하기 위해 코드를 재정렬할 수 있다는 것을 의미하므로 성공 로깅 라인을 저장 바로 아래로 이동한 다음 캐시에서 오류 로깅을 처리할 수 있습니다.

저장은 더 이상 값을 반환하지 않습니다.

성공/실패를 되돌리는 것은 오류와 정말 중복되기 때문에, 우리의 새로운 기능은 던지거나 성공했다.

이제 try-catch를 추가했으므로 컴파일러에서 오류가 하나 더 발생합니다.

우리는 비동기 함수를 호출하고 있지만, 동기 함수 내에서 호출하고 있습니다.

이건 안 돼.

비동기 함수는 동기 함수가 가지고 있지 않은 기능을 가지고 있다: 기다리는 동안 실행 중인 스레드의 제어를 포기할 수 있는 능력.

이를 위해, 그들은 스택 프레임을 처리하는 별도의 방법을 가지고 있으며, 이것은 동기 기능과 호환되지 않습니다.

그래서 한 가지 옵션은 대신 이 기능을 비동기적으로 만드는 것이다.

그래서 우리는 함수 정의 뒤에 비동기 키워드를 추가할 수 있습니다.

그리고 이제, 이 파일이 컴파일됩니다.

하지만 전체 프로젝트는 아직 컴파일되지 않았다.

이 기능을 비동기화로 만드는 것은 문제를 호출되는 수준으로 끌어올렸다.

여기 내 데이터 모델에서, 나는 지금 이 함수가 비동기가 아니기 때문에 같은 컴파일러 오류가 발생하고 있다.

이제 나는 체인을 계속 올라갈 수 있지만, 지금은 변화를 지역화할 수 있는 또 다른 기술을 보자.

비동기 함수를 호출하기 위해, 나는 비동기 함수를 호출할 수 있는 새로운 비동기 작업을 스핀오프할 것이다.

이 비동기 작업은 글로벌 디스패치 대기열에서 비동기를 호출하는 것과 매우 유사하다.

블록이 동시에 실행되기 때문에 외부 함수로 값을 되돌릴 수 없습니다.

그래서 당신이 분리된 폐쇄로 무엇을 하든 독립적이어야 합니다.

이 경우, 우리는 값을 반환하지 않는 저장을 호출하고 있으므로 괜찮습니다.

또한 다른 스레드에서 동시에 돌연변이될 수 있는 글로벌 상태를 건드리지 않도록 주의해야 합니다.

그리고 이것은 저장이 완전히 스레드로부터 안전하다는 것과 관련이 있는 곳입니다. 그렇지 않으면 우리는 이 새로운 작업을 추가하여 실수로 새로운 경쟁 조건을 도입할 수 있습니다.

이제 우리는 그것을 비동기 작업 안에 넣었고, 우리가 기다리던 함수가 컴파일되고, 이 앱에서 비동기/기다림의 첫 번째 사용을 마쳤으므로, 지금 바로 실행할 수 있습니다.

리팩토링 중 하나를 하나 더 하고 이번에는 비동기로 마이그레이션할 때 다른 기술을 살펴봅시다.

그래서 사용자의 건강 데이터에 대한 접근 권한을 요청하는 전화를 살펴봅시다.

이것은 비슷하게 완료 핸들러와 함께 HealthKit을 부른다.

하지만 이전과 달리, 이 함수는 그 자체로 완성 핸들러를 필요로 한다.

내가 할 일은 완성 핸들러 버전을 유지하면서 비동기가 될 함수의 두 번째 버전을 만드는 것이다.

그렇게 하면 완료 핸들러로 호출하는 코드의 다른 부분이 리팩토링하는 동안 계속 작동할 수 있습니다.

"Async Alternative 만들기" 리팩토링 작업을 사용하여 이것을 쉽게 할 수 있습니다.

그것은 Command-Shift-A로 불러올 수 있는 코드 액션 메뉴에서 사용할 수 있으며 비동기 대안을 추가하는 옵션을 선택합니다.

그래서 이것은 원래 호출의 두 번째 비동기 버전을 추가했다.

그리고 그것은 원래의 완성 핸들러 코드를 새로운 비동기 작업을 만드는 코드로 대체했습니다...

...그리고 나서 함수의 비동기 버전을 기다립니다.

비동기 리팩토링이 원본에 사용 중단 경고를 추가했다는 점에 유의하십시오.

이것들은 이 새로운 비동기 버전을 호출하기 위해 리팩토링으로 이익을 얻을 수 있는 내 코드의 일부를 안내하는 데 도움이 될 것이다.

실행 취소하고 잠시 원래 완료 핸들러 버전으로 돌아가자.

이 requestAuthorization 콜백 내에서, 이 콜백은 임의의 스레드에서 발생할 수 있습니다.

그래서 당신은 그 안에 있는 코드가 스레드로부터 안전하다는 것을 알아야 합니다.

하지만 난 그렇게 생각하지 않아.

이 할당은 다른 스레드에서 이 값을 읽는 다른 코드와 동시에 발생할 수 있습니다.

그리고 이 코드에는 지역 추론이 부족한 또 다른 예가 있다.

그 할당 후, 이 완료 핸들러가 호출되고, 나는 그 완료 핸들러 내부의 코드가 스레드로부터 안전한지 전혀 모른다.

나는 이것이 괜찮다는 것을 알기 위해 그들의 완료 핸들러가 어떻게 쓰여지는지 보기 위해 이 기능에 대한 모든 호출 사이트를 살펴봐야 할 것이다.

이제, 다시 하고 리팩토링된 버전을 봅시다.

이제 비동기 작업은 디스패치 콜백과 유사한 임의의 스레드에서도 실행된다는 것을 기억하세요.

그래서 이 포워딩 버전은 우리가 전에 가지고 있던 완료 핸들러 버전과 비슷한 문제가 있다.

우리는 아직 우리의 코드를 더 안전하게 만들지 않았다.

우리는 우리의 코드에 배우를 도입함으로써 곧 이것을 고칠 것이다.

하지만 현재로서는, 우리가 이 함수를 비동기적으로 변환했다고 해서 우리가 경쟁 조건으로부터 자유롭다는 것을 의미하지는 않는다는 점에 유의해야 합니다.

사실, 비동기 함수를 도입하기 위해 리팩토링만 수행하는 경우 코드에 새로운 경쟁 조건을 도입할 위험을 알고 있어야 합니다.

이제 이 새로운 비동기 기능을 살펴봅시다.

리팩토링 작업은 이미 이 SDK API의 새로운 비동기 버전을 호출하기 위해 완료 핸들러로 호출을 변환했습니다.

하지만 이 기능을 비동기화로 변환하는 것은 흥미로운 것을 강조했다.

여기서, 우리가 완료 핸들러 기술을 사용할 때, 우리는 완료 핸들러를 호출하지 않고 반환했다.

그리고 이건 아마 버그였을 거야.

발신자는 매달려 있었을 것이다.

하지만 비동기 함수를 사용하면 값을 반환해야 하므로, 이제 컴파일 오류가 발생하며, 실패에 대해 false를 반환하기만 하면 해결할 수 있습니다.

그리고 이전과 마찬가지로, 이 새로운 비동기 버전의 requestAuthorization은 실제로 값을 반환하지 않으며, 성공하거나 던집니다.

그래서 우리는 이 반환 값을 삭제하기만 하면 됩니다.

그리고 대신 이 길에서, 우리는 그것이 성공했다고 가정해야 한다...

...그리고 실패 경로에서, 우리는 거짓을 반환해야 한다.

내가 지금 컴파일하려고 하면, 다른 곳의 오래된 코드가 여전히 완료 핸들러 버전을 계속 호출할 수 있기 때문에 프로젝트가 컴파일됩니다. 그리고 우리는 이제 우리가 그것을 할 때 이러한 사용 중단 경고를 보고 있으며, 이는 우리가 리팩토링하고 싶을 수도 있는 다음 장소로 이어질 수 있습니다.

좋아, 비동기 변환을 한 번 더 하자.

HealthKit에서 데이터를 로드하는 기능을 찾아봅시다.

우리는 이전과 마찬가지로 이전 코드가 호출할 수 있는 스텁을 만드는 것으로 시작할 것이다.

그런 다음 비동기 버전으로 이동하면, 덧붙여서, 이것은 선택적 완료 핸들러를 사용합니다. 이것과 동등한 비동기 버전은 이 함수가 폐기 가능한 결과를 갖도록 하는 것입니다.

그래서 다음으로, 우리는 완료 핸들러의 사용을 반환으로 대체하면서 아래로 이동하기 시작합니다.

예를 들어, 우리는 이 완료 핸들러를 삭제하고 false를 반환할 수 있습니다.

하지만 우리가 조금 더 나아가면, 우리는 걸림돌에 부딪히기 시작하고, 그것은 HealthKit 쿼리 API가 어떻게 배열되는지와 관련이 있다.

여기, 완료 핸들러가 있지만 이 쿼리 객체에 있습니다. 사실, 제가 기다리고 싶은 것은 여기 함수 하단에 있는 쿼리의 실행입니다.

덧붙여서, 이 기능 주위를 위아래로 뛰는 것은 비동기/기다림이 해결을 돕는 데 좋은 또 다른 것이다.

그래서 내가 하고 싶은 것은 쿼리를 만든 다음 실행하는 단일 비동기 함수를 만드는 것이다.

우리는 이제 연속이라고 불리는 기술을 사용하여 그것을 할 것이다.

그래서 저는 이 기능의 맨 위로 돌아가서 "queryHealthKit"이라는 도우미 기능을 만들 것입니다.

기존 기능 내에서 이 모든 작업을 할 수 있지만 조금 지저분해질 수 있으므로 도우미 기능에서 분리하고 싶습니다.

이 함수는 비동기적일 것이므로, 우리는 그것을 기다릴 수 있으며, 쿼리 작업이 실패할 수 있기 때문에 던질 것이다.

그리고 이 함수는 현재 쿼리의 완료 핸들러로 전달되고 있는 유용한 값을 반환할 것이다.

그래서 나는 쿼리를 수행하기 위한 논리를 취하고, 자르고, 도우미 함수로 옮길 것이다.

그리고 나는 또한 질의를 실행하고 그것을 옮길 것이다.

이제, 완료 핸들러를 기다리고 새로운 비동기 함수에서 완료 핸들러로 전달된 값을 반환할 수 있도록 어떻게든 이 코드를 반전해야 합니다.

그리고 여기가 내가 계속 사용하는 곳이야.

그래서 이 함수에서, 우리는 withCheckedThrowingContinuation 함수에 대한 호출을 기다리는 결과를 반환할 것입니다.

그리고 이것은 계속되는 블록을 필요로 한다.

그리고 우리는 이 코드를 그 블록 내부로 이동한 다음 블록 내에서, 여기에 오류를 다시 던지는 것을 재개하기 위해 연속을 사용하여 이 함수에서 데이터를 다시 전달하기 위해 연속을 사용할 것입니다...

...또는...

...우리가 받은 값을 완료 핸들러로 다시 반환하기 위해.

이제 우리는 이 기다릴 수 있는 기능을 가지고 있으므로, 원래 코드에서 사용할 수 있습니다.

그래서 우리는 함수를 호출한 결과를 할당합니다.

그리고 우리는 던져질 수 있는 오류를 처리해야 한다.

사실, 사실, 나는 여기로 올라가서 이 약간의 로깅을 하고 핸들러에서 그것을 할 것이다.

그리고 나서 우리는 이 모든 성공 코드를 행복한 길로 옮겨야 한다.

마지막으로, 우리는 이 폐쇄를 다룰 필요가 있다.

여기서, 우리는 메인 스레드로 디스패치 비동기를 사용하고 있습니다.

하지만 우리는 완료 핸들러를 버렸기 때문에, 이 정보를 메인 스레드로 다시 전달할 방법이 없습니다.

우리는 다른 방법이 필요해.

이 문제를 해결하기 위해, 우리는 배우들을 처음 사용할 것이다.

스위프트의 동시성 모델에는 메인 스레드에서 모든 작업을 조정하는 메인 액터라고 불리는 글로벌 액터가 있다.

우리는 디스패치 main.async 호출을 메인 액터의 실행 기능에 대한 호출로 대체할 수 있습니다.

그리고 이것은 메인 배우에서 실행하기 위해 코드 블록이 필요하다.

실행은 비동기 함수이므로, 우리는 그것을 기다려야 한다.

이 기능은 메인 스레드가 이 작업을 처리할 준비가 될 때까지 중단해야 할 수도 있기 때문에 기다리는 것이 필요합니다.

하지만 우리가 그것을 기다리고 있기 때문에, 우리는 완료 핸들러를 제거하고 대신 값을 반환할 수 있습니다.

좋아, 마침내, 컴파일러는 이제 캡처된 변수에 대한 오류를 주고 있어.

이것은 비동기 함수 내에서만 발생하는 새로운 오류이다.

스위프트의 클로저는 참조로 변수를 캡처하기 때문에, 가변 변수(이 경우, 우리의 newDrinks 배열)를 캡처할 때 공유 가변 상태에 대한 가능성을 만들 수 있으며, 이는 경쟁 조건의 원천이 될 수 있습니다.

그래서 이것을 할 때, 당신은 이 값의 복사본을 만들고 있는지 확인해야 합니다.

이것을 하는 한 가지 방법은 이와 같이 폐쇄의 캡처 목록에 새로운 음료수를 추가하는 것이다.

하지만 종종 애초에 가변 변수를 갖지 않음으로써 이 문제를 피하는 것이 더 낫다.

여기서, 우리는 대신 위의 코드를 변경하여 이것을 할 수 있습니다.

샘플은 선택 사항이기 때문에 이렇게 쓰여졌다.

하지만 대신 우리가 할 수 있는 일은 newDrinks를 불변의 값으로 변경하고 여기 if 브랜치에서 값을 설정하거나 "else"를 추가하여 빈 배열로 설정하는 것입니다.

우리가 원한다면 우리는 또한 nil coalescing 연산자와 함께 이것을 할 수 있었다.

이 값은 이제 var 대신 let로 선언되기 때문에, 변경할 수 없으며 추가 캡처를 할 필요 없이 문제를 해결합니다.

이제 메인 스레드에서 호출해야 하는 이 기능을 살펴봐서 메인 배우에 대해 계속 이야기해 봅시다.

이 기능의 상단에는 정말 좋은 아이디어가 있습니다: 기능이 메인 스레드에서 올바르게 실행되고 있다는 주장이 있습니다.

실수를 하고 메인 스레드에 비동기 디스패치로 래핑하지 않고 이 함수를 호출한 적이 있다면, 디버그 빌드에서 오류가 발생할 것이며, 기존 코드 중 일부에서 이 관행을 반드시 채택해야 합니다.

하지만 이 접근 방식에는 몇 가지 한계가 있다.

필요한 모든 곳에서 주장을 하는 것을 잊어버릴 수 있으며, 저장된 속성에 대한 액세스에 대해 주장할 수 없으며, 적어도 많은 상용구 없이는 주장할 수 없습니다.

컴파일러가 당신을 위해 이러한 규칙 중 일부를 시행할 수 있다면 훨씬 더 좋기 때문에, 당신은 이와 같은 실수를 전혀 할 수 없습니다.

그리고 그것이 우리가 주연 배우를 사용하는 방법이다.

저는 "@MainActor"로 기능에 주석을 달 수 있습니다.

그리고 이 기능이 실행되기 전에 발신자가 메인 액터로 전환해야 합니다.

이제 내가 이것을 했으니, 컴파일러가 이 함수가 메인 스레드가 아닌 다른 곳에서 호출되는 것을 허락하지 않기 때문에 주장을 제거할 수 있다.

우리는 발신자에게 돌아가서 이 통화를 이 MainActor.run 블록 외부로 이동하여 이것이 작동하고 있다는 것을 증명할 수 있습니다.

그리고 컴파일러가 우리에게 말하는 것을 보시다시피, 아니요, 우리는 여기서 그것을 부를 수 없습니다. 왜냐하면 우리는 주연 배우가 아니기 때문입니다.

여기 이 기능에 대해 생각하는 방법이 있습니다: 그것은 선택적 가치와 매우 비슷합니다.

우리는 포인터와 같은 값을 가지고 있었고 nil에 대한 검사를 기억해야 했지만, 잊기 쉬웠고, 컴파일러가 이 검사가 항상 언어 구문 설탕과 함께 이루어지도록 하는 것이 훨씬 낫다.

여기서, 우리는 비슷한 일을 하고 있습니다. nil 검사를 시행하는 대신, 당신이 달리고 있는 배우를 시행하고 있습니다.

이제 우리는 이 기능을 주요 배우에게 맡게 했기 때문에, 엄밀히 말하면, 이 MainActor.run이 더 이상 필요하지 않습니다.

만약 당신이 배우 밖에 있다면, 당신은 항상 그 배우를 기다리면서 기능을 실행할 수 있습니다.

그리고 사실, 그것이 컴파일러가 여기서 우리에게 말하고 있는 것이다.

이 기능을 실행하기 위해 주요 배우로 전환하기 위해 await 키워드가 필요하다고 말하고 있다.

그래서 우리가 그것을 추가하면, 이 호출이 실행 블록 안에 있지 않아도 코드가 컴파일될 것이다.

여기서, 우리는 동기 함수에서 await를 사용하고 있습니다 -- updateModel은 동기식입니다 -- 하지만 await는 우리가 있는 함수가 메인 액터에 합류하기 위해 중단해야 할 수도 있음을 나타냅니다.

이것을 DispatchQueue.sync 호출을 하는 것과 비슷하다고 생각하십시오. await를 제외하고, 함수는 차단 대신 중단되고 메인 스레드에 대한 호출이 완료된 후 재개됩니다.

그래서, 우리는 더 이상 여기에 필요하지 않지만, 이 MainActor.run 기술은 또 다른 이유로 여전히 중요합니다.

대기할 때마다, 당신의 기능이 일시 중지되고 다른 코드가 실행될 수 있습니다.

그것이 기다리는 요점이다: 차단하는 대신 다른 코드를 실행하도록 하는 것.

이 경우, 우리는 기다려야 할 기능이 하나밖에 없었기 때문에, 실제로는 중요하지 않지만, 때로는 메인 스레드에서 여러 호출을 실행하고 싶을 수도 있습니다.

예를 들어, 테이블 뷰에서 항목을 업데이트하는 것과 같은 UI 업데이트를 작업하는 경우, 수행하는 작업 사이에 주 실행 루프가 전환되는 것을 원하지 않을 수 있습니다.

이 경우, MainActor.run을 사용하여 메인 액터에 대한 여러 통화를 그룹화하여 각각이 그 사이에 가능한 정지 없이 실행되도록 하고 싶을 것입니다.

그래서, 우리는 이제 메인 스레드에서 실행해야 하는 코드를 보호하기 위해 메인 액터를 사용하고 있습니다.

하지만 이 수업의 다른 코드는 어떤가요?

특히, 여기에 할당된 쿼리 앵커와 같은 지역 변수를 변형시키는 코드.

그들이 경쟁 조건으로부터 자유롭다는 것을 어떻게 보장할 수 있을까요?

또는 한 가지 방법은 HealthKitController의 모든 것을 주요 배우에게 두는 것이다.

HealthKit 컨트롤러 정의로 가서 개별 메서드 대신 클래스에 "@MainActor"를 쓰면 이 유형의 모든 메서드를 보호할 수 있으며, 저장된 모든 속성은 메인 스레드에서 조정됩니다.

그리고 이와 같은 간단한 응용 프로그램의 경우, 그것은 아마도 괜찮은 선택일 것이다.

하지만 그것도 조금 잘못된 것 같아.

이 HealthKitController는 정말 우리 앱의 백엔드입니다; 메인 스레드에서 모든 작업을 하는 것은 불필요해 보입니다.

우리는 UI 중심 활동을 하기 위해 그 스레드를 자유롭게 남겨두고 싶습니다.

그래서 대신, 우리는 이 수업을 그 자체로 배우로 바꿀 수 있다.

글로벌 배우인 주요 배우와 달리, 이 배우 유형은 여러 번 인스턴스화할 수 있다.

내 프로젝트에서, 나는 여전히 그들 중 하나만 만들 것이지만, 같은 배우의 여러 복사본을 인스턴스화할 수 있는 배우의 다른 많은 용도가 있다.

예를 들어, 채팅 서버의 각 방을 자체 배우로 만들 수 있습니다.

이제 우리가 이 수업을 배우로 만들었으니, 컴파일러가 뭐라고 하는지 봅시다.

알았어. 그래서 우리는 편집 오류가 좀 있어.

이제 여기서 잠시 멈추고 컴파일러 오류에 대해 이야기해 봅시다.

이러한 오류는 코드를 새로운 동시성 모델로 마이그레이션할 때 업데이트해야 하는 코드의 장소로 안내합니다.

이러한 오류가 발생하면, 그들이 당신에게 말하는 것을 이해했는지 확인하세요.

어떻게 또는 왜 문제를 해결할지 확실하지 않을 때 fix-it 버튼을 으깨려는 유혹에 저항하세요.

조심해야 할 한 가지는 오류의 연속에 빠지는 것이다.

때때로 당신은 우리가 방금 했던 것처럼 클래스를 배우로 변환하거나, 메소드 비동기 방식을 만드는 것과 같은 변경을 할 것입니다. 그리고 그것은 몇 가지 컴파일러 오류를 생성할 것입니다.

그래서 당신은 그 오류의 사이트로 가서, 그 방법을 비동기화하거나 주요 배우에 넣는 것과 같이 그 오류를 수정하기 위해 더 많은 변경을 하는 것이 유혹적이다.

문제는 이것이 더 많은 오류로 이어질 수 있고, 빠르게 압도당할 수 있다는 것이다.

대신, 우리가 이 연습에서 사용하는 것과 같은 기술을 사용하고, 프로젝트를 컴파일하고 실행하면서 한 번에 한 단계씩 변경 사항을 격리하고 완료하십시오.

나중에 삭제할 수도 있지만, 이전 코드가 계속 작동할 수 있도록 심을 추가하세요.

그렇게 하면, 당신은 한 지점에서 점차적으로 이동할 수 있으며, 진행하면서 코드를 정리할 수 있습니다.

덧붙여서, 내가 여기서 한 일은 먼저 HealthKitController의 방법을 비동기로 변환한 다음 배우로 만드는 것이다.

그리고 나는 배우 전환으로 시작하는 것보다 그렇게 하면 가장 쉽게 작동한다는 것을 알았다.

좋아, 그럼 그것들로 뛰어내려 이 오류들을 살펴보자.

그들은 우리가 주연 배우에게 맡긴 기능에 대해 여기에 있다.

그리고 이것은 말이 됩니다. 왜냐하면 이 기능에서 우리는 새로운 HealthKitController 액터의 저장된 속성인 모델 속성을 만지고 있기 때문입니다.

배우는 상태를 보호하고 우리가 메인 배우에 명시적으로 배치한 이 기능과 같은 배우가 아닌 기능이 저장된 속성을 건드리지 못하게 할 것이다.

이제 이 기능을 보면, 그것이 만지는 배우의 유일한 상태는 모델 객체처럼 보인다.

다른 모든 것은 함수 인수로 전달된다.

그리고 나에게, 이것은 이 기능이 모델에 속한다는 것을 시사한다; 여기의 모델은 실제로 자체여야 한다.

그럼 그걸 모델로 옮기자.

그래서 우리는 이 기능을 가지고, 자르고, CoffeeData UI 모델로 가서, 붙여넣을 수 있습니다.

그것은 비공개가 아닌 내부일 것이므로, HealthKitController에서 호출할 수 있습니다.

그리고 우리는 모델에 대한 모든 참조를 검토하고 제거해야 합니다. 왜냐하면 그것은 이제 그 자체이기 때문입니다.

마지막으로, 우리는 그것이 불렸던 곳으로 가야 해...

...그리고 여기서 자신을 모델에 대한 호출로 대체하세요.

그래서 이제, 이 HealthKitController 파일이 컴파일되고, 나는 다른 파일에서 새로운 오류 세트를 얻는다.

그 오류들을 살펴봅시다.

그래서 여기서 우리는 이 함수를 비동기로 다시 작성했음에도 불구하고 완료 핸들러를 계속 전달할 수 있도록 이전에 호출한 완료 핸들러 심을 호출하고 있습니다.

이 기능들은 이제 배우에 의해 보호되고 있어서 나는 그것들을 직접 부를 수 없다.

하지만 우리가 그들을 본다면 그들은 배우의 상태의 다른 부분을 건드리지 않는다.

그들이 하는 일은 작업을 회전시킨 다음 함수의 비동기 버전에 대한 호출을 기다리는 것뿐이다.

그들은 배우의 내부 상태의 어떤 부분도 건드리지 않기 때문에, 나는 그들을 "nonisolated"라고 부르는 것으로 표시할 수 있다.

여기서도 똑같이 해.

비고립된 것으로 표시하면 컴파일러에게 격리된 상태를 건드리지 않을 것이며, 따라서 이 함수는 어디에서나 호출될 수 있습니다.

액터로의 전환은 실제로 비동기 버전의 함수에 대한 호출을 기다릴 때 자동으로 발생합니다.

컴파일러는 이 비고립적인 주장이 사실인지 확인할 것입니다.

만약 내가 액터의 일부 상태에 접근하려고 한다면 - 예를 들어, 인증 상태를 인쇄하는 것과 같이 - 컴파일러가 나를 막을 것이다.

그래서 이제, 저는 HealthKitController를 인종 조건으로부터 내부 상태를 보호하는 배우로 전환하는 작업을 완료했습니다.

다음으로, 우리의 CoffeeData 모델 유형인 작업할 다음 파일로 그 사용 중단 빵 부스러기를 따라가자.

이제 이 클래스는 ObservableObject를 구현하며, 게시된 속성을 가지고 있다.

SwiftUI 뷰에 게시된 속성에 대한 모든 업데이트는 메인 스레드에서 수행되어야 하므로, 이 클래스는 아마도 메인 액터에 넣을 수 있는 좋은 후보일 것입니다.

하지만 백그라운드에서 작업을 하기 위한 이 배경 DispatchQueue도 있습니다.

그것이 어떻게 사용되는지 살펴봅시다.

그리고 그것은 단지 두 가지 기능에 있습니다: 로드와 저장.

그것은 말이 됩니다; 당신은 아마도 메인 스레드에서 로딩과 저장을 하고 싶지 않을 것입니다.

이와 같은 패턴을 볼 때 - 대기열이 특정 활동을 조정하는 데 사용되지만 나머지 수업은 메인 스레드에 있어야 합니다 - 그것은 배경 코드를 별도의 액터로 고려하고 싶다는 신호입니다.

그럼 그렇게 하자.

그러니 파일 맨 위로 가서 새로운 개인 배우를 만들자...

...우리는 "CoffeeDataStore"라고 부를 것이다.

그리고 다른 창에서 CoffeeData를 열자.

그리고 우리의 새로운 배우로 코드를 옮기기 시작하세요.

그래서 우리는 그것에 자체 로거를 줄 수 있다.

그리고 배우가 언제 사용되는지 알 수 있도록 카테고리를 조정해 봅시다.

그리고 다음으로, 이 DispatchQueue 대신, 우리는 새로운 배우의 사본을 인스턴스화할 것입니다.

다음으로, 저장 작업으로 가서, 그것을 옮기자.

그래서 우리는 이 기능을 할 수 있어...

...여기서 잘라서 배우로 옮기세요.

컴파일하고 어떤 문제가 발생하는지 보는 것으로 시작합시다.

그래서 먼저, 현재 음료 재산이 있습니다.

이것은 우리가 이 방법을 모델에서 액터로 옮기기 전에 모델 유형의 속성이었다.

그래서 우리가 지금 어떻게 그것에 접근할 수 있을까?

음, 배우들이 정보를 전달하는 방식은 서로 간에 가치를 전달하는 것이다.

그래서 우리는 이 함수가 currentDrinks를 인수로 받아들여야 한다.

저장할 이 인수는 모델 유형에 의해 전달된 저장할 currentDrinks 목록을 받습니다.

그래서 그게 그걸 해결해.

다음으로, 저장된 음료.

이것은 아무것도 변경되지 않았을 때 불필요하게 저장하지 않기 위해 마지막으로 저장된 값의 복사본입니다.

이 값은 저장과 로드 기능 모두에 의해 변형되므로, 확실히 액터에 의해 보호되어야 한다.

그러니까 우리 모델에서 찾아보자...

...그리고 옮기세요.

알았어, 다음은 뭐야?

좋아요, 이 속성 dataURL은 실제로 로드 및 저장 작업에 의해서만 사용되고 있으므로, 액터의 개인 도우미로 옮길 수 있습니다.

알았어, 해결해야 할 마지막 문제야.

이제, 여기서 우리는 오류가 발생하고 있으며, 우리가 본다면, 배우로부터 어떤 상태를 포착하는 폐쇄가 있는 것으로 보인다, 그래서 우리는 그것을 고쳐야 한다.

그래서 왜 여기에 폐쇄가 있나요?

음, 아래를 내려다보면, 같은 코드가 두 곳에서 호출되고 있기 때문입니다.

그리고 컴파일러가 우리에게 정말 흥미로운 것을 표시한 것으로 밝혀졌다.

이 코드가 하는 일은 시계 확장 프로그램이 백그라운드에서 실행되고 있는지 확인하는 것이다.

그리고 아이디어는, 이미 백그라운드에서 실행되고 있다면, 백그라운드 대기열에 들어가지 마세요; 그냥 메인 스레드에 머물면서 동기적으로 저장하는 작업을 수행하세요.

하지만 이건 옳지 않은 것 같아.

앱이 백그라운드에서 실행되는 경우에도 저장과 같은 I/O 작업을 수행하기 위해 메인 스레드를 차단해서는 안 됩니다.

그 앱은 왜 이걸 해?

음, 우리는 저장 작업이 호출되는 곳으로 거슬러 올라갈 수 있습니다.

그것은 여기 currentDrinks의 didSet에서 호출되고 있다.

그리고 그것은 재산이 할당될 때마다 새로운 가치를 저장하도록 발사한다.

이제, didSets는 매우 편리하지만, 너무 유혹적일 수 있다.

현재 음료 자산의 모든 발신자를 살펴봅시다.

우리가 여기까지 드릴을 한다면...

...우리는 WatchKit 확장에서 백그라운드 작업을 처리하기 위한 호출인 이 함수에서 호출되는 방식 때문에 저장 작업이 궁극적으로 동기적이라는 것을 알게 되었습니다.

이제 이 핸들 API는 계약을 맺었다.

당신은 모든 일을 해야 하고, 모든 일이 끝나면, 이 setTaskCompletedWithSnapshot 메소드를 호출하세요.

그리고 시계 앱이 일시 중지될 것이기 때문에 이것을 호출할 때 모든 작업이 완료되도록 보장해야 합니다.

당신은 우리의 저장 작업과 같은 I/O 작업을 할 수 없으며, 당신이 끝났다고 말할 때 여전히 실행 중입니다.

이것은 비동기성이 어떻게 코드 전반에 걸쳐 글로벌 추론을 강요하는지에 대한 완벽한 예입니다.

여기서 무슨 일이 일어나고 있는지 시각화해 봅시다.

우리는 HealthKit 함수에서 부하를 호출하는 handle(backgroundTasks:)에서 시작합니다.

이것은 완료 핸들러가 필요하다.

하지만 우리는 동기적으로 수행되는 updateModel()로 전환하고, 동기적으로 저장되는 didSet을 동기적으로 호출합니다.

이것이 완료되면, 완료 핸들러가 호출되고 WatchKit에 모든 것이 완료되었다고 알립니다.

메인 스레드에서 동기식 I/O를 수행하도록 강요하는 것은 동기식 부품이다.

우리가 이걸 어떻게 고칠 수 있을까?

완료 핸들러로 수정하려면, 현재 각 동기 방식을 업데이트하여 이제 완료 핸들러를 취해야 합니다.

하지만 당신은 didSet으로 그것을 할 수 없습니다; 그것은 인수를 받지 않으며, 속성을 업데이트할 때 자동으로 실행됩니다.

하지만 좋은 소식은 우리의 모든 비동기 리팩토링이 이제 갚을 것이라는 것입니다. 왜냐하면 동기식에서 비동기식으로 기능을 업데이트하는 것이 훨씬 쉽기 때문입니다.

그래서 먼저, 게시된 속성인 currentDrinks로 가서 모든 돌연변이가 이 파일에서만 일어나고 있다는 것을 알 수 있도록 private(set)로 변경합시다.

그리고 나서 이 didSet 작업을 하고 대신 그 논리를 새로운 함수로 옮기자...

..."drinksUpdated()라고 불린다.

우리는 그것을 비동기적으로 만들 것이다, 왜냐하면 그것은 우리의 배우에 대한 저장 작업을 부를 것이기 때문이다.

그리고 그건 기다려야 해...

...CoffeeData 스토어에서, 우리는 새로운 currentDrinks 값을 전달할 것이다.

그런 다음, 우리는 현재 음료가 업데이트되는 곳으로 가서 나중에 음료 업데이트라고 불러야 합니다.

이제 이 기능에서, 주목해야 할 한 가지가 있다.

currentDrinks의 복사본을 가져와서 변형시킨 다음 다시 쓰는 이 작업이 모든 것이 원자적으로 일어나는 것이 중요합니다.

그리고 이것이 await 키워드가 중요한 이유입니다. 이 시점에서 이 작업이 중단될 수 있고, currentDrinks를 업데이트할 수 있는 다른 기능이 실행될 수 있음을 나타냅니다.

그래서 우리는 우리의 전체 돌연변이와 쓰기백이 기다리기 전에 일어나는지 확인해야 합니다. 그렇지 않으면 다른 기능이 오고 현재 음료가 변이하는 것은 일관성 없는 상태로 이어질 수 있습니다.

그래서 이 기능은 비동기여야 한다.

우리는 저장 작업으로 가서 이 불필요한 배경과 전경 브랜치를 제거하고 매번 액터에 대한 작업을 수행할 수 있습니다.

좋아. 마지막으로, 로드 작업을 살펴보자.

이제 여기서, 논리는 백그라운드에서 실행해야 하는 코드와 메인 스레드에서 실행해야 하는 코드로 나뉩니다.

그래서 먼저 전반부 - 배경 부분 - 그리고 그것을 배우로 옮기자.

이제 이것을 하면서, 우리는 또 다른 가능한 인종 조건을 알아차렸다.

여기 savedValues는 기본 대기열에서 돌연변이를 일으키고 있었지만, 저장 작업을 기억한다면, 백그라운드 대기열에서 읽고 썼습니다.

이제, 공교롭게도, 앱이 구성된 방식, 로드는 시작에서만 발생했기 때문에, 이것은 괜찮았다.

하지만 다시 말하지만, 그것은 세계적인 추론에 의존하고 있으며, 미래의 변화를 만들 때 미묘한 방식으로 깨질 수 있는 일종의 가정이다.

배우가 프로그램이 항상 정확할 수 있도록 하는 것이 훨씬 낫다.

그래서 우리는 지금 그걸 고칠 거야.

그래서 먼저, 이 대기열 관리를 제거합시다...

...기능을 다시 실행하고, 이 다른 대기열 관리를 제거하세요.

그리고 저장과 마찬가지로, 우리는 액터의 이 로드 함수에서 값을 반환함으로써 로드된 값을 되돌려주는 방법이 필요합니다.

이제, 원래 부하로 돌아가자.

그리고 우리는 이 논리를 옮겼기 때문에, 그냥 삭제할 수 있습니다...

그리고 그것을 기다리라는 전화로 바꾸세요...

...배우의 음료를 싣고 있어.

이제, 우리가 배우를 기다리고 있기 때문에, 그것은 이 기능이 비동기적이어야 한다는 것을 의미합니다.

그리고 우리가 여기 있는 동안, 우리는 이러한 사용 중단 경고를 정리할 수 있다.

그리고 마지막으로, 이 부하가 이제 비동기이기 때문에, 우리는 여기서 기다려야 한다.

그리고 우리가 여기서 그것을 기다리고 있기 때문에, 우리는 작업을 만들어야 한다.

하지만 이 시점에서, 우리가 비동기 작업을 사용한다면, 우리는 잠재적으로 새로운 경쟁 조건을 도입하고 있다.

배우 밖에서, 이 새로운 작업은 임의의 스레드에서 실행된다는 것을 기억하세요.

우리는 임의의 스레드에서 currentDrinks와 같은 공유 상태를 변경해서는 안 됩니다.

이제, 이것을 해결하는 한 가지 방법은 메인 액터에 로드 기능을 두는 것이지만, 전체 모델 유형을 메인 액터로 옮기는 것이 훨씬 낫다.

그래서 우리는 CoffeeModel 정의로 가서 모델 유형에 "MainActor"를 추가합니다.

모델을 메인 액터에 배치함으로써, 우리는 이제 CoffeeData의 속성에 대한 모든 접근이 메인 스레드에서 이루어질 것이라고 보장하고 있습니다.

그리고 이것은 우리가 앞서 언급했듯이, 그것은 관찰 가능한 물체이고 출판된 속성을 가지고 있기 때문에 좋다.

그리고 SwiftUI에 게시된 속성은 메인 스레드에서만 업데이트되어야 합니다.

그것은 또한 배우의 비동기 호출도 배우에게 실행될 것이라는 것을 의미한다.

그래서 우리는 이전에 추가한 것과 같은 다른 "MainActor" 주석을 제거할 수 있습니다.

그래서 이제 당신은 우리가 컴파일할 때 이전에 다른 것들을 배우로 옮겼을 때와 달리 컴파일 오류가 발생하지 않는다는 것을 알 수 있습니다.

그리고 그것은 우리가 모델로 부르고 있는 장소가 SwiftUI 뷰와 같은 것들이기 때문이다.

예를 들어, DrinkListView로 가자.

이제, 이 유형은 화면에 버튼 목록을 표시합니다.

그리고 나서 그것은 우리의 모델 유형에 있는 addDrink라고 부른다.

하지만 이 DrinkListView 자체는 주요 배우이기도 하다.

그래서 그 방법들...

...기다림 없이 CoffeeData 모델을 호출할 수 있습니다.

이 SwiftUI 뷰가 주연 배우에 있다고 결정하는 것은 무엇인가요?

음, 그것은 여기서 EnvironmentObject의 사용에서 추론되었다.

환경 객체나 관찰된 객체와 같은 공유 상태에 액세스하는 모든 SwiftUI 뷰는 항상 메인 액터에 있습니다.

다른 곳에서...

...우리는 또한 이 확장 대리인 호출에서 우리의 모델에 접근하고 있습니다.

이 확장 대리인은 메인 스레드에서 호출되도록 보장되기 때문에, WatchKit에 의해 메인 액터에서 실행되는 것으로 주석을 달았기 때문에 모델 유형을 직접 호출할 수도 있습니다.

마지막으로, 이제 우리가 여기 왔으니, 이 방법을 리팩토링하고 더 이상 사용되지 않는 완료 핸들러 사용을 제거합시다.

우리는 대신 이 섹션을 새로운 비동기 작업으로 포장할 수 있다.

기억하세요, 이 핸들러는 메인 스레드에서 실행되고 있으므로, 우리가 작업을 만들 때, 그 작업은 메인 스레드에서도 실행될 것입니다.

그리고 이 새로운 작업 안에서, 우리는 이제 기다릴 수 있다...

...HealthKit에서 새로운 데이터를 로드하기 위한 우리의 전화.

그리고 완료 핸들러를 제거하는 것에 대한 정말 좋은 점은 이제 기능을 함께 구성할 수 있다는 것입니다.

그래서 당신이 원한다면, 당신은 이것을 if 진술로 직접 옮길 수 있습니다.

이 함수 호출이 반환되면, 우리는 그 안에서 저장 작업을 기다릴 것이기 때문에 모든 작업이 완료되었다는 것을 알고 있습니다.

그래서, 우리는 이제 우리가 모든 I/O 작업을 마쳤다는 것을 알고 자신 있게 background.Task.setTaskCompleted에 전화할 수 있습니다.

우리는 이제 더 이상 작업을 완료하기 전에 비동기 작업을 기다리는 멋지고 체계적이며 하향식 접근 방식을 가지고 있습니다.

덧붙여, 동시성에 대한 이 구조화된 접근 방식은 스위프트의 동시성 기능의 또 다른 정말 중요한 부분이다.

자세한 내용을 보려면, 이 기능을 활용하여 계속하기 전에 여러 비동기 작업이 완료되기를 기다리는 것과 같은 더 복잡한 예제를 구성하는 방법을 다루는 관련 강연을 시청하십시오.

이 강연을 보는 동안, 이러한 새로운 기능 중 일부가 정확히 어떻게 작동하는지 궁금하다면, 기술 중 일부를 자세히 탐구하는 우리의 언더 더 후드 강연을 확인해 보세요.

그럼 요약하자.

우리는 사운드 유형 아키텍처를 가지고 있지만 발견하기 정말 어려운 숨겨진 경쟁 조건을 가진 복잡한 동시성 아키텍처를 가지고 있는 코드를 취했습니다.

그리고 새로운 동시성 기능의 도움으로, 우리는 동시성과 유형 아키텍처가 잘 정렬되도록 그것을 다시 설계했습니다.

그리고 컴파일러는 우리가 그 과정에서 숨겨진 잠재적인 인종 조건을 찾는 데 도움을 주었다.

작업 그룹과의 구조화된 동시성, 비동기 시퀀스 및 SDK의 몇 가지 훌륭한 새로운 비동기 API와 같이 우리가 다루지 않은 Swift 5.5에는 더 많은 것이 있습니다.

또한 당신이 직접 시도해보고 싶을 수도 있는 이 프로젝트에서 우리가 하지 않은 몇 가지 리팩토링이 더 있습니다.

이러한 기술을 배우는 가장 좋은 방법은 자신의 앱에서 사용해 보는 것이므로, 재미있고 더 깨끗하고 안전한 코딩 방법을 즐기세요.

♪