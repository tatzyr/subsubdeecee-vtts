10211

♪ 베이스 음악 연주 ♪

♪

알레한드로 루세나: 안녕하세요, 여러분.

상징에 관한 이 세션에 참석해 주셔서 감사합니다.

상징화는 모호한 용어처럼 보일 수 있지만, 버그, 충돌 및 성능 병목 현상의 근본 원인을 빠르게 식별하는 데 도움이 되는 중요한 역할을 볼 수 있습니다.

우리는 상징이 어떻게 작동하는지에 대한 더 깊은 직관을 얻고 당신이 직접 따라갈 수 있는 몇 가지 도구를 다룰 것입니다.

그 과정에서, 우리는 풍부한 상징화 경험에 필요한 다양한 디버그 정보 소스와 이 정보를 가장 잘 활용하도록 앱을 구성하는 방법에 대해 논의할 것입니다.

상징화의 구체적인 정의와 예에 익숙해지는 것으로 시작합시다.

기본적으로, 상징화는 메모리 주소와 지침 측면에서 런타임에 장치가 앱을 보는 방식을 함수, 이름 및 파일 측면에서 개발자로서 앱을 보는 방식으로 변환하거나 번역하는 메커니즘입니다.

이 브리징 레이어가 없으면, 몇 줄의 코드에서도 버그를 진단하는 것을 매우 복잡하게 만든다.

예를 들어, 이 스위프트 코드를 고려해 봅시다.

여기에 후보 번호 목록에서 특정 숫자를 선택하는 `generateMagicNumber()` 함수가 있습니다.

이를 위해, 우리는 먼저 무작위로 생성된 숫자 10개의 배열을 반환하는 `numberChoices()`를 호출합니다.

그런 다음, 우리는 그 배열을 `selectMagicNumber(choices:)`로 전달하며, 이는 특정 인덱스의 숫자를 반환합니다.

이것은 합리적인 프로그램처럼 보이지만, 처음 실행했을 때 충돌이 발생했다.

나의 첫 번째 수단은 다소 열매가 없는 충돌 로그를 확인하는 것이다.

스레드 추적에서 내가 알 수 있는 것은 내 MagicNumbers 앱이 어딘가에 추락했다는 것이다.

고마워, 하지만 난 이미 알고 있었어.

나는 그 등록부들 중 어느 것도 무엇을 언급하고 있는지 전혀 모른다.

디버거로 앱을 살펴보고 충돌을 식별할 수 있지만, 재현할 수 없는 특정 상황에서만 이런 일이 발생한다면 어떨까요?

디버거를 사용하는 것이 반드시 그 경우에 문제를 정확히 찾아내는 것은 아니다.

또는 분해를 시도해 볼 수 있지만, 상황을 추적하는 것은 훨씬 더 어렵다.

이것은 분명히 문제를 진단하는 실행 가능한 방법이 아니며, 더 중요한 것은, 상징화의 도움으로, 우리는 이 출발점에서 디버깅할 필요가 없다.

Xcode 주최자는 충돌 로그를 재처리할 이 앱의 dSYM을 다운로드할 수 있다고 말합니다.

그렇게 함으로써, Xcode는 상징화의 개념을 적용하여 훨씬 더 좋은 충돌 로그로 문제를 진단할 수 있습니다. 여기서 내 모든 기능이 실제로 호출되는 것을 볼 수 있을 뿐만 아니라 내 코드에서 다시 참조할 파일과 줄 번호를 결정할 수 있습니다.

이 업데이트된 충돌 로그는 또한 우리가 범위를 벗어난 인덱스에 접근하려고 시도했다는 것을 말해준다.

또는, 이미 dSYM을 가지고 있다면, `atos` 명령을 사용하여 동일한 정보를 얻을 수 있습니다.

내 코드를 되돌아보면, 나는 `MAGIC_CHOICE`가 우리의 10요소 배열의 범위를 훨씬 벗어난다는 것을 깨닫게 되었다.

이런.

또 다른 예로, 저는 가장 빠른 사용자 경험을 제공하기 위해 앱을 프로파일링하는 데 관심이 있습니다.

여기서, Instruments는 앱이 높은 사용률과 낮은 사용률의 기간을 순환한다는 것을 보여준다.

만약 우리가 활용도가 낮은 기간에 집중한다면, 인스트루먼트는 앱이 파일에 일부 콘텐츠를 쓰고 있다고 말한다.

그러나, 내가 높은 활용 기간을 검사할 때, 나는 똑같은 정확한 추적을 얻는다.

이게 어떻게 가능해?

이것은 정확히 같은 코드를 실행하고 있지 않나요?

보시다시피, 이 악기 추적은 부분적으로만 상징화되어 있습니다.

예를 들어, 업데이트된 충돌 로그에서 그랬던 것처럼 역추적에 파일 이름이나 줄 번호가 보이지 않습니다.

결과적으로, 몇 가지 정보가 누락되었다.

그것을 염두에 두고, 나는 악기에서 내 dSYM을 비슷하게 찾을 수 있다.

이것을 한 후, 나의 새로운 인스트루먼트 추적은 활용도가 높은 영역이 실제로 파일에 쓰고 있다는 것을 보여주지만, 그것들은 특히 내가 프로그램에 남긴 디버그 코드 경로 내에 있었다.

활용도가 낮은 영역은 이것을 피하고 내 앱이 프로덕션에서 어떻게 작동하는지 나타낸다.

Xcode가 dSYM을 활용하여 다소 비정보적인 충돌 로그를 상징화한 것처럼, Instruments는 또한 dSYM을 사용하여 부분적으로 상징화된 추적을 풍부하게 하고 성능 문제의 정확한 원인을 알려주었다.

이제, 이 도구들이 내 코드에서 문제 영역을 정확히 찾아내기 위해 상징을 활용하는 것은 좋지만, 자연스럽게 몇 가지 질문을 불러일으킨다.

이 모든 것이 어떻게 작동하나요?

이걸 또 어디에 적용할 수 있나요?

그리고 이게 다 dSYM에 관한 거야?

이러한 질문에 답하고 상징의 기능을 잠금 해제하려면, 우리는 세부 사항에 대해 더 깊이 파고들어야 할 것이다.

이것은 약간 압도적으로 보일 수 있지만, 이것들은 이해해야 할 중요한 개념이다.

상징화를 기반으로 하는 디버깅과 프로파일링을 돕는 많은 도구가 있다.

`atos`만으로도 이미 우리에게 충돌의 정확한 근본 원인을 주었고, Xcode에는 더 많은 도구가 내장되어 있다.

게다가, 우리는 `o`, `l`, `i`와 같은 플래그를 `atos`로 지정했지만, 그게 무슨 뜻이야?

우리는 항상 같은 깃발 세트를 사용하나요?

우리가 사용할 수 있는 값 중 하나가 없다면 어떨까요?

당신은 또한 우리가 인스트루먼트 케이스에서 본 것처럼, 당신의 백트레이스가 완전히 상징화되지 않을 수 있는 시기와 그 이유를 이해하는 데 좋은 기초를 얻게 될 것입니다.

마지막으로, 상징화의 풍요로움에 영향을 미치는 많은 빌드 설정이 있습니다.

우리는 당신이 그것들이 어떻게 활용되는지에 대한 확실한 직관을 가질 수 있도록 이러한 빌드 설정을 살펴볼 것입니다.

이를 위해, 저는 상징화를 위한 2단계 과정을 소개하고 싶습니다.

1단계는 파일로 돌아가고, 2단계는 디버그 정보를 참조하는 것이다.

보시다시피, 파일로 돌아가는 것은 런타임 메모리 주소를 더 안정적이고 사용 가능한 형태로 변환하거나 변환하는 것입니다.

이를 통해 디버그 정보와 통신하여 원시 메모리 주소와 소스 코드 사이에 의미 있는 연결을 만들 수 있습니다.

파일로 돌아가서 1단계에 대해 논의하는 것으로 시작합시다.

이 단계의 궁극적인 목표는 원래 충돌 로그에서 본 것과 같은 런타임 메모리 주소를 디스크 바이너리의 해당 주소로 변환하는 것입니다.

우리가 런타임 주소를 가지고 있는 것처럼, 당신의 앱과 프레임워크도 디스크에 주소 공간이 있습니다!

디스크 주소 공간은 앱이 런타임에 차지하는 주소 공간과 다르며, 이러한 차이점을 파악하기 위한 메커니즘이 필요합니다.

먼저, 우리는 디스크 주소가 무엇인지 정확히 이해해야 한다.

이 주소들은 앱을 빌드할 때 링커에 의해 할당됩니다.

특히, 링커는 당신의 바이너리를 세그먼트로 그룹화합니다.

각 세그먼트에는 관련 데이터가 포함되어 있으며 이름, 크기 및 할당된 주소와 같은 속성이 있습니다.

예를 들어, 바이너리의 `__TEXT` 세그먼트에는 작성한 모든 함수와 메서드가 포함되어 있으며, `__DATA` 세그먼트에는 글로벌 변수와 같은 프로그램 전체의 상태가 포함되어 있습니다.

이 세그먼트들 각각은 겹치지 않도록 다른 주소가 할당된다.

링커는 Mach-O 헤더의 일부로 실행 파일의 맨 처음에 이 정보를 기록합니다.

Mach-O는 모든 실행 가능한 바이너리와 라이브러리에 사용되는 형식이며, 시스템은 앱을 실행하기 위해 이 헤더를 읽어야 한다는 것을 알고 있습니다.

좀 더 자세히 살펴보면, Mach-O 헤더에는 세그먼트 속성을 유지하는 여러 로드 명령이 포함되어 있습니다.

시스템은 이러한 로드 명령을 사용하여 세그먼트를 메모리에 로드합니다.

앱이 유니버설 2인 경우, 앱에는 각 아키텍처에 대해 하나의 헤더와 세그먼트 세트가 있습니다.

우리는 지정된 파일의 로드 명령을 인쇄하는 `otool -l` 명령을 사용하여 스스로 볼 수 있습니다.

여기서, 우리는 `LC_SEGMENT_64`로 식별된 세그먼트 로드 명령을 찾고 있습니다.

이 로드 명령은 `__TEXT` 세그먼트가 `vmaddr`의 주소에서 시작하며 `vmsize` 바이트 길이라고 말합니다.

따라서 커널이 이러한 로드 명령을 따라 세그먼트를 메모리에 로드한다면, 런타임과 링커 주소의 차이점은 정확히 무엇입니까?

음, 커널이 실제로 세그먼트를 로드하기 전에, ASLR 슬라이드로 알려진 임의의 값을 초기화합니다.

그런 다음 커널은 로드 명령의 주소에 ASLR 슬라이드를 추가합니다.

따라서 주소 A의 `__TEXT` 세그먼트와 주소 B의 `__DATA` 세그먼트를 로드하는 대신 커널은 대신 A+S와 B+S에 로드합니다. 여기서 S는 ASLR 슬라이드입니다.

A+S와 B+S는 시스템이 사용하는 실제 주소이기 때문에 로드 주소라고도 합니다.

그것을 염두에 두고, 우리는 이제 런타임 주소와 링커 주소의 차이가 ASLR 슬라이드라는 것을 알고 있다.

우리는 다음 방정식으로 ASLR 슬라이드를 계산할 수 있습니다: S = L-A, 여기서 S는 ASLR 슬라이드, L은 로드 주소, A는 링커 주소입니다.

우리는 곧 이 방정식의 예를 볼 것이지만, 요점은 우리가 ASLR 슬라이드를 알게 되면 항상 파일 주소 공간으로 돌아갈 수 있다는 것이다.

ASLR 슬라이드 방정식에는 로드 주소와 링커 주소라는 두 개의 주소가 필요했는데, 어디서 구할 수 있나요?

우리는 이미 `otool`을 사용하여 링커 주소를 알기 위해 로드 명령을 쿼리하는 방법을 보았습니다.

런타임 주소를 알기 위해, 시스템은 충돌 지점에서 또는 런타임 주소 공간을 위해 인스트루먼트에 의해 프로파일링되는 앱으로 앱을 쿼리합니다.

이 정보는 충돌 로그의 이진 이미지 목록에 반영됩니다.

또한 프로그램의 활성 메모리 영역을 열거하는 `vmmap` 도구로 로드 주소를 대화식으로 볼 수 있습니다.

원래 충돌 로그에서 ASLR 슬라이드 값을 직접 계산해 봅시다.

이진 이미지 목록에는 `__TEXT` 세그먼트의 로드 주소가 있습니다.

나는 또한 로드 명령을 보았을 때 디스크에 바이너리에 대한 링커 주소를 가지고 있다.

이 두 가지를 빼면 0x45c000의 ASLR 슬라이드 값을 얻을 수 있다.

이것은 내 프로그램의 런타임 `__TEXT` 세그먼트의 모든 주소가 링커 `__TEXT` 세그먼트 주소에서 0x45c000바이트 떨어져 있다는 것을 의미합니다.

그래서 충돌 로그의 백트레이스 주소가 파일에서 무엇에 해당하는지 보려면, 디스크의 주소를 얻기 위해 0x45c000을 뺄 수 있습니다.

이 주소는 이제 디스크 주소 공간의 일부이기 때문에, 나는 거기에 무엇이 있는지 확인하기 위해 내 앱을 검사할 수 있다.

충돌 로그는 이 주소에 있는 모든 것을 실행하는 동안 스레드가 충돌했다고 알려줍니다. 그래서 우리는 문제가 있는 명령을 보기 위해 `otool`을 다시 사용할 수 있습니다.

이번에는 분해를 인쇄할 `otool`에 `-tV` 플래그를 지정했습니다.

제가 또한 아키텍처를 arm64로 지정하고 있다는 것을 주목하세요.

이것은 otool이 앱이 Universal 2로 구축되었기 때문에 어떤 Mach-O 헤더와 세그먼트를 고려해야 하는지 알 수 있도록 하기 위한 것이다.

`otool`의 출력은 주소에서 `brk` 명령을 보여준다.

`brk`는 앱의 예외 또는 문제를 나타냅니다.

'Atos'와 같은 도구는 또한 우리가 함께 겪은 것과 동일한 기술을 사용하여 ASLR 슬라이드를 계산합니다.

`atos`는 `-o` 플래그로 표시된 파일의 로드 명령을 읽고, `-l` 플래그로 로드 주소에 대해 알려줍니다.

내가 언급했듯이, `vmmap`은 또한 실행 중인 앱의 로드 주소에 대해 알려줄 수 있다.

이 계산을 다시 시도해 봅시다. 하지만 이번에는 ASLR 슬라이드를 결정하기 위해 이진 이미지 목록 대신 `vmmap`을 사용할 것입니다.

나는 MagicNumbers 프로그램을 다시 실행했고 프로그램이 충돌하기 전에 `__TEXT` 세그먼트 로드 주소를 얻었다.

이전 공식을 사용하여, 이번에는 ASLR 슬라이드 값이 0x104d14000이라고 결정할 수 있습니다.

다시 말하지만, 파일로 돌아가려면 ASLR 슬라이드 값을 빼야 합니다.

새 충돌 로그의 최상위 항목에서 0x104d14000을 빼면 이전과 동일한 정확한 파일 주소를 얻을 수 있습니다.

그리고 이것은 우연이 아닙니다; 커널은 다른 ASLR 값을 선택했기 때문에 우리의 로드 주소는 충돌 로그 사이에서 변경되었습니다.

그러나, 우리는 여전히 충돌에 책임이 있는 파일 주소를 결정할 수 있다.

여기서 중요한 요점은 런타임 주소에 관계없이 앱이 명령 수준까지 무엇을 하고 있는지 정확히 이해할 수 있는 메커니즘이 있다는 것입니다.

그리고 그 매핑을 통해, 우리는 그 지침에 컴파일된 소스 코드에 대한 디버그 정보를 참조할 수 있습니다.

우리가 넘어가기 전에, 나는 우리가 다룬 것과 우리가 사용한 도구에 대한 요약을 제시하고 싶다.

앱 바이너리와 프레임워크는 Mach-O 파일이다.

이것은 그들이 다른 세그먼트에 관련 콘텐츠를 가지고 있다는 것을 의미한다.

이 세그먼트들은 링커에 의해 만들어진다.

Mach-O 헤더 로드 명령은 주소를 포함한 해당 세그먼트의 속성을 설명합니다.

우리는 로드 명령을 인쇄하기 위해 `-l` 플래그와 함께 `otool`을 사용했다.

다음으로, 우리는 커널이 링커 주소에 ASLR 슬라이드로 알려진 임의의 값을 추가한다는 것을 배웠다.

ASLR 슬라이드와 링커 주소의 추가는 로드 주소로 알려져 있다.

충돌 로그에서 이진 이미지 목록을 확인하여 충돌 시 로드 주소를 보거나, `vmmap`을 사용하여 실행 중인 앱의 로드 주소를 볼 수 있습니다.

마지막으로, 우리는 파일 주소 공간으로 돌아가기 위해 ASLR 슬라이드를 계산하는 몇 가지 예를 살펴보았다.

이제 우리는 파일 주소와 소스 코드 사이의 중요한 링크가 포함된 디버그 정보에 대해 논의할 수 있습니다.

Xcode는 앱을 빌드할 때 디버그 정보를 생성하고 앱 바이너리에 직접 포함시키거나 dSYM과 같은 별도의 파일로 저장합니다.

디버그 정보에는 몇 가지 범주 또는 유형이 있습니다.

각각은 주어진 파일 주소에 대해 다른 수준의 세부 사항을 제공한다.

우리는 오늘 세 가지 유형의 디버그 정보를 살펴볼 것이다.

먼저, 우리는 그 자체로 너무 많은 가치를 추가하지 않는 기능 시작을 다룰 것이지만, 일반적인 출발점이다.

다음으로 우리는 함수와 메소드 이름을 추가하는 nlist 기호 테이블을 볼 것이다.

마지막으로, 우리는 dSYM과 정적 라이브러리에서 온 DWARF를 살펴볼 것이다.

DWARF는 파일 이름, 줄 번호 및 최적화 기록을 포함하여 가장 많은 세부 사항을 추가합니다.

DWARF는 가장 상세한 정보를 제공하기 때문에, 우리는 가능할 때마다 이러한 유형의 디버그 정보를 갖기 위해 노력하고 싶습니다.

우리는 이들 각각에 대해 배우고 완전히 상징적인 충돌 로그를 구축하는 데 어떻게 사용될 수 있는지 배울 것입니다.

기능 시작부터 시작합시다.

표에서 보았듯이, 기능 시작은 최소한의 소스 코드 세부 사항을 제공합니다.

또한 이름에 충실하면서, 이러한 유형의 디버그 정보는 함수의 첫 번째 주소 또는 문자 그대로의 시작에 대해서만 알려줍니다.

예를 들어, 이것은 함수가 특정 주소에서 시작되고 존재한다는 것을 알려줄 것이다.

그러나, 그것은 어떤 기능이 그 주소에서 시작되는지 알려주지 않으며, 단지 그것들이 존재한다는 것만 알려준다.

디버그 정보를 시작하는 함수는 앱의 `__LINKEDIT` 세그먼트의 주소 목록을 인코딩하여 이를 수행합니다.

이것은 앱에 직접 내장되어 있기 때문에, Mach-O 헤더에는 `LC_FUNCTION_STARTS`를 찾을 수 있는 위치를 알려주는 로드 명령도 있습니다.

`기호` 명령과 `-onlyFuncStartsData` 플래그로 이것들을 직접 볼 수 있습니다.

여기서 우리는 주소와 널 자리 표시자 목록을 다시 얻는다.

이 자리 표시자는 이상적으로 null 대신 함수와 메서드 이름을 가질 것이지만, 함수 시작 데이터는 이름을 제공하지 않습니다.

다시 말하지만, 이것은 가장 서술적인 데이터가 아니다.

그러나, 그것은 충돌 로그에 대한 약간의 업데이트를 허용한다.

이제 파일 주소를 함수의 오프셋으로 볼 수 있습니다.

예를 들어, 먼저 ASLR 슬라이드 값을 빼서 파일로 돌아갑니다.

그런 다음 파일 주소를 포함할 수 있는 함수 시작 값을 찾습니다.

이 경우, 다른 모든 값이 주소보다 크기 때문에 첫 번째 값만 주소를 포함할 수 있습니다.

마침내 우리는 우리의 파일 주소가 실제로 이 기능에 264바이트라고 주장할 수 있다.

이것은 이 기능이 어떻게 설정되었고 어떤 레지스터가 수정되었는지에 대한 세부 사항을 이해할 수 있기 때문에 디버거에 주로 유용합니다.

그러나 이것이 당신에게 의미하는 바는 기능 이름이 없는 충돌 로그를 만난다면, 아마도 이 가장 낮은 수준의 디버그 정보를 다루고 있다는 것입니다.

이것은 더 나은 디버그 정보로 충돌 로그를 풍부하게 할 수 있는 기회가 많다는 것을 의미하기 때문에 좋은 소식이다.

당연히, 우리가 보고 싶은 다음 단계의 세부 사항은 함수 이름이다.

이것은 우리에게 충돌 로그나 인스트루먼트 추적을 가지고 소스 코드의 문제를 추적하는 데 사용할 수 있는 첫 번째 진정한 기회를 제공합니다.

이것은 우리를 nlist 심볼 테이블로 이끈다.

심볼 테이블은 기능 시작 아이디어를 기반으로 하며 `__LINKEDIT` 세그먼트의 정보 목록을 인코딩하며, 자체 로드 명령도 있습니다.

그러나, 단순히 주소를 인코딩하는 것이 아니라, 그들은 C 구조를 인코딩한다.

이를 통해 기능 시작과 비교하여 주어진 항목에 대한 자세한 내용을 추가할 수 있습니다.

특히, 그들은 `nlist_64` 구조를 인코딩한다.

여기서 우리는 그 구조의 정의를 가지고 있다.

훑어보는 것은 우리가 이름과 여러 속성에 접근할 수 있다는 것을 보여준다.

이 구조체 필드의 값은 nlist의 `n_type`에 의해 결정됩니다.

우리가 관심이 있는 세 가지 주요 n_유형이 있지만, 지금은 두 가지에만 집중할 것이다.

첫 번째는 직접적인 상징으로 알려져 있다.

이것들은 앱과 프레임워크 내에서 완전히 정의한 기능과 방법입니다.

직접 기호에는 `nlist_64` 구조체에 이름과 주소가 있습니다.

게다가, 그것들은 `n_type` 필드의 특정 비트 패턴으로 표현된다.

특히, `n_type`은 두 번째, 세 번째, 네 번째로 가장 덜 중요한 비트를 설정할 것이다.

이 비트들은 `N_SECT`로도 알려져 있다.

우리는 `nm`로 이것들을 볼 수 있고 `-defined-only`와 `--numeric-sort` 플래그를 지정할 수 있다.

여기서, `nm`는 MagicNumbers 프로그램의 정의된 기호를 살펴보고 주소 순서대로 나열했습니다.

우리가 되찾은 이름들은 비밀스러워 보인다.

그것은 실제로 심볼 테이블에 저장된 이름이 망가진 이름이기 때문이다.

이러한 망가진 이름은 컴파일러와 링커가 함수를 고유하게 식별하는 데 도움이 되지만, 엉키지 않는 한 이해하기 쉽지 않다.

이 이름들의 더 친근한 버전을 얻기 위해, 나는 출력을 'swift-demangle'에 전달했다.

이제 우리는 내 앱에서 직접 정의되기 때문에 `main`과 `numberChoices`와 같은 친숙한 이름을 얻는다.

마찬가지로, `기호` 도구에는 nlist 데이터를 표시하는 옵션이 있으며, 또한 자동으로 이름을 엉키게 한다.

이제 함수 이름을 주소와 연결할 수 있으므로, 충돌 로그를 다시 한 번 업데이트할 수 있습니다.

여기서 우리는 함수 시작 데이터에서 얻은 오프셋 표현이 직접 기호의 항목과 일치하며, 그 항목에는 이름이 있다는 것을 관찰할 수 있습니다.

이 두 가지를 합치면, 우리는 이제 우리의 충돌이 메인 264바이트에서 발생했다고 말할 수 있다.

우리는 메인이 관련된 유일한 기능이 아니라는 사실을 알고 있기 때문에, 이것은 여전히 몇 가지 세부 사항을 남기고 있다.

그리고 그것은 또한 정확한 줄 번호를 갖는 것도 도움이 될 것이다.

우리는 인스트루먼트 추적 예제에서 이것과 비슷한 것을 발견했습니다. 우리는 몇 가지 기능 이름을 사용할 수 있었지만, 다른 것을 놓쳤습니다.

이것의 한 가지 이유는 심볼 테이블이 연결과 관련된 기능에 대한 직접 심볼 항목만 가지고 있기 때문입니다.

이것들은 모듈에서 사용하는 기능이나 프레임워크에서 내보내는 기능입니다.

이것은 API 경계를 식별하는 데 유용하다.

그리고 그것은 또한 `dlsym()` 및 `dladdr()`와 같은 함수로 동적 로딩에 필요한 데이터를 가지고 있다는 것을 의미합니다.

하지만 한 가지 단점은 로컬 또는 정적 함수가 모듈 외부에서 참조되지 않기 때문에 기호 테이블에 표시되지 않는다는 것입니다.

이것은 결국 우리가 앱 로직의 상당 부분을 가질 수 있는 구현 기능을 생략하게 된다.

게다가, 릴리스 모드에 내장된 바이너리는 심볼 테이블을 제거하는 것이 일반적이다.

이것은 불필요한 항목이 심볼 테이블에서 제거된다는 것을 의미하며, 이는 앱의 크기를 줄이는 데 도움이 됩니다.

우리가 그것에 대해 생각한다면, 우리 앱의 주요 드라이버가 어디에서나 기능을 내보내는 것은 다소 드물기 때문에, 우리는 그 기호 테이블 항목을 유지하는 공간을 낭비할 것이다.

프레임워크와 라이브러리의 경우, 우리는 확실히 고객이 사용해야 하는 기능을 내보냈지만, 다른 곳에서는 사용할 수 없기 때문에 로컬 공유 기능을 유지할 필요가 없습니다.

기본 앱 실행 파일을 제거하면 거의 항상 심볼 테이블이 거의 비어 있습니다.

프레임워크와 라이브러리를 제거하면 내보낸 기능만 남깁니다.

Strip Linked Product, Strip Style 및 Strip Swift Symbols와 같은 Xcode의 빌드 설정을 접했을 수 있습니다.

이러한 빌드 설정은 빌드 중에 앱이 제거되는 방법을 제어합니다.

스트립 링크 제품이 활성화되면, 이진법은 스트립 스타일에 따라 제거됩니다.

예를 들어, 모든 기호는 가장 침습적인 제거를 수행하고 필수 요소만 남길 것이다.

비 글로벌은 앱의 다른 모듈 내에서 사용되지만 다른 앱에서 사용하기 위해 내보내지 않는 직접 기호를 제거합니다.

디버깅 기호는 DWARF에 도착하면 나중에 논의할 세 번째 유형의 nlist 유형을 제거합니다.

그러나, 이 스트립 스타일은 직접적인 상징을 보존한다.

예를 들어, 여기에 두 개의 공용 인터페이스와 하나의 내부 공유 구현 기능을 정의하는 프레임워크가 있습니다.

이 모든 기능들이 연결에 중요한 역할을 하기 때문에, 그것들은 모두 직접 기호 항목을 가지고 있다.

만약 내가 비글로벌을 제거한다면, 나는 내 인터페이스만 남게 된다.

공유 구현 기능은 내 프레임워크 내에서만 사용되기 때문에, 글로벌로 간주되지 않는다.

마찬가지로, 다른 앱이 프레임워크를 사용하는 데 필요하기 때문에 모든 기호를 제거하는 것은 여전히 인터페이스를 떠난다.

또한 `symbols --onlyNListData` 출력에서 직접 기호 사이에 산재된 함수 시작 주소가 있다는 것을 알 수 있습니다.

이 주소들은 직접적인 기호에 있지 않거나 제거된 기능을 나타낸다.

원하는 수준의 심볼 테이블 가시성에 맞게 이 스트립 설정을 조정할 수 있습니다.

이 정보로, 우리는 언제 직접 기호로 작업하고 있는지 결정할 수 있습니다.

이것의 몇 가지 징후는 함수 이름을 가지고 있지만 줄 번호나 파일 이름은 없습니다. 또는 프레임워크 예제와 같이 함수 이름과 함수 시작 주소가 혼합되어 있습니다.

우리가 분석할 두 번째 유형의 nlist 구조체는 직접 기호와는 반대로 간접 기호로 알려져 있다.

이것은 `n_type`이 `N_EXT` 비트 패턴과만 일치할 때이다.

이것들은 `print()`와 같은 다른 프레임워크나 라이브러리에서 사용하는 함수와 방법입니다.

당신은 이것들을 `nm`로 볼 수 있습니다, 이번에는 `--defined-only` 대신 `--defined-only`를 지정할 것입니다.

우리는 또한 함수를 찾아야 하는 프레임워크나 라이브러리를 보여주는 `-m` 플래그를 추가할 것입니다.

예를 들어, MagicNumbers 앱은 libswiftCore에 정의된 다양한 Swift 함수에 의존합니다.

이제 세 가지 디버그 정보 범주 중 두 가지를 다루었으니, 그들의 속성을 이해했는지 확인해 봅시다.

함수 시작은 주소 목록이므로 이름이 부족하지만 오프셋을 결정할 수 있습니다.

Nlist 기호 테이블은 정보의 전체 구조를 인코딩하고 이름을 주소와 연관시킬 수 있다.

그들은 앱에 정의된 직접 기호와 종속성에 의해 제공되는 간접 기호를 설명합니다.

직접 기호는 일반적으로 연결과 관련된 기능을 위해 예약되어 있으며, 스트립 빌드 설정은 직접 기호를 사용할 수 있는 것에 영향을 미칩니다.

마지막으로, 함수 시작과 nlist 심볼 테이블은 모두 앱에 직접 내장되어 있습니다.

우리가 아직 보지 못한 것은 파일 이름과 줄 번호와 같은 더 풍부한 수준의 세부 사항이다.

이것은 DWARF가 우리에게 제공한다.

DWARF는 nlist 심볼 테이블의 개념을 완전히 다른 수준으로 끌어올린다.

DWARF는 기능의 하위 집합만 유지하는 대신 모든 것을 설명하기 위해 노력한다.

우리는 nlist 기호 테이블이 기능 시작에 비해 훨씬 더 많은 정보를 추가하는 것을 보았다.

그것은 차원을 추가함으로써 그것을 성취했다.

기억하세요, 우리는 함수 시작을 보았을 때 주소인 단일 차원으로 시작했습니다.

그런 다음 우리는 nlist 기호 테이블에서 정보로 가득 찬 구조를 인코딩하여 2차원으로 업그레이드했습니다.

DWARF는 관계에 관한 3차원을 추가한다.

DWARF는 기능이 고립되어 있지 않다는 것을 인식한다.

그들은 다른 함수를 호출하고, 매개 변수를 가지고 있으며, 의미 있는 데이터를 반환하며, 특정 파일에 정의됩니다.

이러한 관계를 인코딩하는 것은 상징화의 가장 강력한 측면을 열어줍니다.

우리가 DWARF를 분석할 때, 우리는 주로 dSYM 번들을 언급하고 있다.

Plists와 같은 다른 메타데이터 외에도, dSYM 번들은 DWARF가 있는 바이너리를 포함한다.

무엇이 이 바이너리를 그렇게 특별하게 만드나요?

바이너리는 특별한 `__DWARF` 세그먼트에 데이터를 포함한다.

DWARF 사양은 우리가 집중할 세그먼트 내의 세 가지 데이터 스트림을 언급한다.

`debug_info`는 원시 데이터를 포함하고, `debug_abbrev`는 데이터에 구조를 할당하고, `debug_line`은 파일 이름과 줄 번호를 포함합니다.

DWARF는 또한 우리가 먼저 공부할 두 가지 어휘 유형을 정의한다: 컴파일 유닛과 하위 프로그램.

세 번째는 나중에 소개할게.

컴파일 유닛은 제품을 빌드하는 데 들어간 단일 소스 파일을 나타낸다.

예를 들어, 우리는 프로젝트의 각 Swift 파일에 대해 하나의 컴파일 유닛을 가질 것으로 예상할 수 있습니다.

DWARF는 파일 이름, SDK, 기능이 차지하는 `__TEXT` 세그먼트의 부분 등과 같은 컴파일 유닛에 속성을 할당합니다.

Main.swift 컴파일 유닛은 왼쪽의 `debug_info` 스트림에 이러한 속성을 포함하고 있으며, 오른쪽의 `debug _abbrev` 스트림에 해당 항목이 있어 값이 무엇을 나타내는지 알려줍니다.

여기서 우리는 파일 이름, 그것이 쓰여진 언어, 그리고 `__TEXT` 세그먼트 범위를 나타내는 낮은/높은 쌍을 볼 수 있습니다.

하위 프로그램은 정의된 기능을 나타낸다.

우리는 이미 nlist 심볼 테이블에서 정의된 함수를 보았지만, 하위 프로그램은 정적 및 로컬 함수도 설명할 수 있다.

하위 프로그램은 또한 이름과 `__TEXT` 세그먼트 주소 범위를 가지고 있다.

컴파일 유닛과 하위 프로그램 사이의 한 가지 근본적인 관계는 하위 프로그램이 컴파일 유닛에 정의된다는 것이다.

DWARF는 이것을 나무로 나타낸다.

컴파일 유닛은 트리의 루트에 있으며 하위 프로그램 항목이 있습니다.

아이들은 그들의 주소 범위를 따라 검색할 수 있다.

우리는 'dwarfdump' 명령으로 이것들을 더 자세히 검토할 수 있다.

먼저 우리는 컴파일 유닛을 살펴볼 것이다.

이것은 내가 앞서 언급한 컴파일 유닛의 속성 중 일부와 일치한다.

`dwarfdump`는 `debug_ info`와 `debug _abbrev` 내용을 유용하게 결합하여 dSYM의 데이터 구조와 내용을 보여줍니다.

그리고 우리가 출력을 아래로 스크롤하면, 우리는 하나의 하위 프로그램 자식을 만나게 될 것이다.

그것이 차지하는 주소 범위는 컴파일 유닛의 범위 내에 있으며 함수의 이름도 볼 수 있습니다.

나는 DWARF가 데이터를 매우 자세하게 설명한다고 언급했다.

우리는 이 모든 세부 사항에 많은 시간을 할애하지 않을 것이지만, 기능 매개 변수와 같은 세부 사항을 보는 것은 재미있다고 생각합니다.

그들은 매개 변수의 이름과 유형을 설명하는 그들만의 어휘 유형을 가지고 있다.

트리 모델에 따라, 매개 변수는 하위 프로그램의 자식이다.

여기서 우리는 함수에 제공하는 선택 매개 변수에 대한 항목을 발견합니다.

다음으로, 파일 이름과 줄 번호는 `debug_line` 스트림에서 나옵니다.

이 개울은 나무 구조가 없다.

대신, 개별 파일 주소를 정확한 코드 줄에 다시 매핑할 수 있는 라인 테이블 프로그램을 정의합니다.

이것은 결국 파일과 줄을 찾기 위해 검색할 수 있는 소스 코드 세부 사항 목록을 생성합니다.

`debug_info` 트리를 구문 분석하고 `debug_line` 목록을 생성하면, 다음과 같은 구조로 끝납니다.

그래서 파일 주소를 일치시키고 싶다면, 우리는 트리를 통과할 수 있다.

먼저, 우리는 컴파일 유닛에서 시작하여 지점을 따라갈 것이다.

그런 다음 우리는 일치하는 `debug_line` 항목을 선택할 것입니다.

우리는 `atos`로 이것을 다시 자동화할 수 있습니다. 이번에는 특별히 `-i` 깃발을 생략하고 있습니다.

여기서 약간 이상한 거 알아챘어?

네, 우리는 함수 이름과 줄 번호를 가지고 있으므로, 확실히 DWARF를 사용하고 있습니다.

하지만 그 외에는, 이것은 nlist 심볼 테이블 업데이트와 크게 다르지 않다.

사실, 우리가 'atos'를 처음 사용한 것과 비교할 때, 여전히 많은 귀중한 기능과 세부 사항을 놓치고 있는 것처럼 보입니다!

여기서 무슨 일이 있었어?

바뀐 유일한 것은 우리가 이번에 `-i`를 `atos`로 지정하지 않았다는 것이다.

그 깃발은 "인라인 기능"을 의미한다.

인라이닝은 컴파일러가 수행하는 일상적인 최적화이다.

이것은 함수 호출을 함수의 본문으로 직접 대체하는 것을 포함한다.

그것이 가지고 있는 한 가지 멋진 효과는 코드를 사라지게 만드는 것이다.

우리는 `numberChoices()`를 호출하는 대신 `numberChoices()`의 코드 전체가 제자리에 삭제되었다고 생각할 수 있다.

갑자기 더 이상 `numberChoices()`에 대한 함수 호출이 없습니다!

DWARF는 이것을 인라인 서브루틴으로 나타낸다.

이것은 우리가 오늘 논의할 DWARF의 세 번째이자 마지막 어휘 유형이다.

인라인 서브루틴은 하위 프로그램이므로 다른 하위 프로그램에 인라인된 기능입니다.

인라인 함수는 관계 트리의 다른 노드에 의해 완전히 휩싸이기 때문에, 인라인 서브루틴은 그 노드의 자식이다.

이 정의는 재귀적으로도 적용되며, 이는 인라인 서브루틴이 다른 인라인 자식을 가질 수 있다는 것을 의미한다.

다시 말하지만, 'dwarfdump'로, 우리는 인라인 서브루틴을 찾을 수 있다.

그들은 다른 노드의 자식으로 나열되며 이름과 주소와 같은 하위 프로그램과 유사한 속성을 가지고 있다.

그러나, DWARF에서, 이러한 속성은 추상적인 기원으로 알려진 공통 노드를 통해 자주 접근된다.

특정 함수의 인라인 복사본이 많다면, 공통적이고 공유된 속성은 모든 곳에서 중복되지 않도록 추상적인 출처에 보관됩니다.

인라인 서브루틴이 가지고 있는 독특한 속성 중 하나는 콜 사이트이다.

이것은 우리가 실제 함수 호출을 작성한 소스 코드의 위치이지만, 옵티마이저가 그것을 대체했다.

예를 들어, 우리는 main.swift 파일의 36번 줄에서 `generateANumber`를 호출했습니다.

이것은 우리가 새로운 자식 노드로 트리를 업데이트할 수 있게 해준다.

그리고 이제 이것은 우리 프로그램에 대한 훨씬 더 포괄적인 견해처럼 보인다.

인라인 함수에 대한 최적화 세부 사항은 완전히 상징적인 충돌 로그로 우리를 얻는 데 중요한 세부 사항이었다.

'Atos'의 `-i' 플래그는 도구에 상징화 중에 그것들을 고려하도록 지시한다.

그들은 또한 우리의 악기 추적에서 누락된 세부 사항이었다.

악기와 충돌 로그 모두에 dSYM이 필요한 이유는 정확히 이 모든 콘텐츠를 추출할 수 있도록 하기 위해서였다.

DWARF를 찾을 수 있는 또 다른 소스가 있으며, 그것은 정적 라이브러리와 객체 파일입니다.

dSYM이 없는 경우에도 정적 라이브러리 또는 개체 파일에서 연결한 함수에 대해 DWARF를 수집할 수 있습니다.

이러한 경우, 디버깅 기호 nlist 유형을 찾을 수 있습니다.

이것들은 벗겨질 수 있는 상징 유형 중 하나였다.

하지만 그들은 스스로 DWARF를 보유하지 않는다.

오히려, 그들은 그들이 온 파일에 함수를 다시 연관시킨다.

라이브러리가 디버그 정보로 구축되었다면, nlist 항목은 우리에게 그 DWARF를 가리킬 수 있다.

이러한 유형의 nlist 항목은 `dsymutil -dump-debug-map`로 장황하게 볼 수 있다.

여기 우리는 다른 기능 목록과 그것들이 어디에서 왔는지에 대한 목록이 있습니다.

그 위치들은 DWARF를 위해 스캔하고 처리할 수 있다.

요약하자면, DWARF는 심층적인 상징 데이터의 중요한 원천이다.

DWARF는 기능과 파일 간의 중요한 관계를 노출한다.

기능 인라인과 같은 최적화는 상징화의 품질에 엄청난 영향을 미치며, DWARF는 그것을 매우 잘 표현할 수 있다.

우리는 또한 dSYM과 정적 라이브러리가 DWARF를 포함하고 있다는 것을 보았다.

그러나, dSYM을 다른 사람들에게 쉽게 전송할 수 있고 여러 도구에서 내장된 지원을 받을 수 있으므로 선호하십시오.

마지막으로, 저는 당신이 상징화를 촉진하는 데 사용할 수 있는 다양한 도구와 팁을 공유하고 싶습니다.

로컬 개발 빌드의 경우, 디버그 모드로 빌드하면 일반적으로 많은 디버그 정보가 있습니다.

릴리스 모드의 경우, 디버그 정보 형식 빌드 설정을 확인하여 Xcode가 dSYM을 생성하도록 할 수 있습니다.

릴리스가 dSYM 파일로 DWARF로 설정되어 있는지 확인하세요.

App Store에 제출된 앱의 경우, App Store Connect를 통해 dSYM을 다운로드할 수 있습니다.

여기에는 비트코드가 활성화된 모든 앱도 포함됩니다.

특정 dSYM이 이미 장치에 있는지 확인하고 싶다면, `mdfind` 명령을 사용할 수 있습니다.

여기서 영숫자 문자열은 로드 명령에 정의된 고유 식별자인 바이너리의 UUID입니다.

`기호 -uuid`로 dSYM의 UUID를 볼 수 있습니다.

때때로, 툴체인은 잘못된 DWARF를 생성할 수 있다.

당신은 이것을 'dwarfdump -verify'로 확인할 수 있습니다.

보고된 오류가 보이면, 버그를 제출하세요!

DWARF 데이터는 또한 바이너리당 4기가바이트의 상한선을 가지고 있다.

dSYM에 문제가 발생하고 4기가바이트를 초과하는 경우, 각각 더 작은 dSYM을 갖도록 프로젝트를 별도의 구성 요소로 분할하는 것을 고려하십시오.

UUID를 비교하여 사용 중인 dSYM이 관심 있는 앱의 특정 빌드와 일치하는지 확인할 수 있습니다.

앱의 UUID는 충돌 보고서의 이진 이미지 목록 섹션에 있으며 `기호` 명령으로도 볼 수 있습니다.

앱과 dSYM이 모두 동일한 UUID를 가지고 있는지 확인해야 합니다.

또한 `기호` 도구를 사용하면 앱에서 사용할 수 있는 디버그 정보의 유형을 확인할 수 있습니다.

우리는 이미 이것의 예를 보았지만, 대괄호 안의 태그가 정보 출처를 알려준다는 것을 상기시켜줍니다.

어떤 디버그 정보를 다루고 있는지 확실하지 않다면 유용합니다.

사용 가능한 dSYM이 있다고 확신하지만 여전히 인스트루먼트 추적에서 함수의 이름을 얻지 못한다면, 자격과 코드 서명을 확인하십시오.

특히, `codesign` 명령을 사용하면 적절한 코드 서명이 있는지 확인할 수 있습니다.

또한 개발을 위해 로컬로 구축된 앱에 'get-task-allow' 권한이 있는지 확인해야 합니다.

이 자격은 앱을 상징화하기 위해 Instruments와 같은 도구에 권한을 부여합니다.

Xcode는 프로필 작업으로 이 자격을 자동으로 설정해야 하지만, 확인하는 것이 도움이 됩니다.

`get-task-allow` 권한이 활성화되어 있지 않은 경우, Code Signing Inject Base Entitlements 빌드 설정을 확인하고 개발할 때 활성화되어 있는지 확인해야 합니다.

마지막으로, 유니버설 2 앱의 경우, 도구에 관심이 있는 아키텍처를 지정해야 합니다.

`symbols`, `otool` 및 `dwarfdump`는 모두 특정 아키텍처 슬라이스에서만 작동하는 `-arch` 플래그를 가지고 있다.

이것은 "기호화: 기본을 넘어서"를 마칩니다.

다른 것이 아니라면, 나는 정말로 몇 가지 요점을 강조하고 싶다.

UUID와 파일 주소는 ASLR 슬라이드와 독립적이기 때문에 앱이 무엇을 하고 있는지 식별하는 일관되고 신뢰할 수 있는 방법입니다.

그들은 또한 디버그 정보를 쿼리하는 우리의 열쇠이다.

당신은 또한 가능할 때마다 dSYM을 사용해야 합니다.

dSYM은 DWARF의 형태로 가장 풍부한 디버그 정보를 포함하고 있으며 Xcode와 Instruments에서 지원합니다.

마지막으로, 우리는 몇 가지 도구를 다루었다.

이러한 도구는 Xcode에서 쉽게 사용할 수 있으며 강력한 진단과 통찰력을 제공합니다.

디버깅과 최적화를 위해 그것들을 워크플로우에 통합하기 위해 노력해야 합니다.

더 많은 것을 배우고 싶다면, 출시 시 앱이 어떻게 살아나는지 알아보기 위해 WWDC18의 이 두 세션을 추천합니다: "앱 시작 시간 최적화"와 "앱 시작 시간: 과거, 현재, 미래".

상징에 대해 배우기 위해 저와 함께 해주셔서 정말 감사합니다!

남은 한 주 잘 보내.

♪