10134

♪ ♪

こんにちは、私はカボンです。後で同僚のジョーが参加します。

Swift 5.5は、構造化並行性と呼ばれる概念を使用して、並行プログラムを書く新しい方法を導入しています。

構造化並行性の背後にあるアイデアは、構造化プログラミングに基づいており、直感的であるため、めったに考えませんが、それについて考えることは、構造化並行性を理解するのに役立ちます。

では、飛び込みましょう。

コンピューティングの初期には、制御フローがあちこちにジャンプすることを許された一連の命令として書かれていたため、プログラムは読みにくかった。

言語は構造化プログラミングを使用して制御フローをより均一にするため、今日ではそれが見えません。

たとえば、if-then ステートメントは構造化されたコントロールフローを使用します。

ネストされたコードブロックは、上から下に移動している間のみ条件付きで実行されることを指定します。

Swiftでは、そのブロックは静的スコープも尊重します。つまり、名前は囲むブロックで定義されている場合にのみ表示されます。

これはまた、ブロックを離れるときに、ブロックで定義された変数の寿命が終了することを意味します。

したがって、静的スコープを使用した構造化プログラミングにより、制御フローと変数の寿命が理解しやすくなります。

より一般的には、構造化されたコントロールフローを自然にシーケンスしてネストすることができます。

これにより、プログラム全体を上から下に読むことができます。

したがって、これらは構造化プログラミングの基礎です。

ご想像のとおり、今日の私たちにとってとても直感的なので、当然のことと考えるのは簡単です。

しかし、今日のプログラムは非同期および同時コードを特徴としており、そのコードを書きやすくするために構造化プログラミングを使用することができませんでした。

まず、構造化プログラミングが非同期コードをより簡単にする方法を考えてみましょう。

インターネットからたくさんの画像を取得し、順番にサムネイルになるようにサイズ変更する必要があるとします。

このコードは非同期に機能し、画像を識別する文字列のコレクションを取り込みます。

この関数は、呼び出されたときに値を返さないことに気付くでしょう。

これは、関数が結果またはエラーを与えられた完了ハンドラに渡すためです。

このパターンにより、発信者は後で回答を受け取ることができます。

そのパターンの結果として、この関数はエラー処理に構造化制御フローを使用できません。

それは、関数ではなく、関数から投げ出されたエラーを処理することが理にかなっているからです。

また、このパターンは、ループを使用して各サムネイルを処理するのを防ぎます。

関数が完了した後に実行されるコードはハンドラ内にネストする必要があるため、再帰が必要です。

それでは、以前のコードを見てみましょうが、構造化プログラミングに基づく新しいasync/await構文を使用するように書き換えてみましょう。

関数から完了ハンドラ引数を削除しました。

代わりに、その型シグネチャに「async」と「throws」で注釈が付けられます。

また、何もない代わりに値を返します。

関数の本体では、「await」を使用して、非同期アクションが発生し、そのアクションの後に実行されるコードにネストは必要ありません。

これは、サムネイルをループして順番に処理できるようになったことを意味します。

私はまた、エラーを投げてキャッチすることができ、コンパイラは私が忘れていないことを確認します。

async/awaitを詳しく見るには、「Swiftでasync/awaitに会う」というセッションをチェックしてください。だから、このコードは素晴らしいですが、何千もの画像のサムネイルを作成している場合はどうなりますか?

各サムネイルを一度に1つずつ処理することは、もはや理想的ではありません。

さらに、各サムネイルの寸法は、固定サイズではなく、別のURLからダウンロードする必要がある場合はどうなりますか?

今、いくつかの並行性を追加する機会があるので、複数のダウンロードが並行して発生する可能性があります。

プログラムに並行性を追加するための追加のタスクを作成できます。

タスクは、非同期関数と連携するSwiftの新機能です。

タスクは、非同期コードを実行するための新しい実行コンテキストを提供します。

各タスクは、他の実行コンテキストに関して同時に実行されます。

安全かつ効率的な場合は、自動的に並行して実行するようにスケジュールされます。

タスクはSwiftに深く統合されているため、コンパイラはいくつかの並行性のバグを防ぐのに役立ちます。

また、非同期関数を呼び出すと、呼び出しの新しいタスクは作成されないことに注意してください。

タスクを明示的に作成します。

構造化された並行性は柔軟性とシンプルさのバランスに関するものであるため、Swiftにはいくつかの異なる種類のタスクがあります。

したがって、このセッションの残りの部分では、ジョーと私は、トレードオフを理解するのに役立つ各種類のタスクを紹介し、議論します。

これらのタスクの中で最も簡単なものから始めましょう。これは、async-letバインディングと呼ばれる新しい構文形式で作成されます。

この新しい構文形式を理解するために、まず通常のレットバインディングの評価を分解したいと思います。

イコールの右側にイニシャライザ式と左側に変数の名前の2つの部分があります。

許可の前後に他の声明があるかもしれないので、ここにも含めます。

Swiftがletバインディングに達すると、その初期化子は値を生成するように評価されます。

この例では、URLからデータをダウンロードすることを意味し、しばらく時間がかかる可能性があります。

データがダウンロードされた後、Swiftは後続のステートメントに進む前に、その値を変数名にバインドします。

各ステップの矢印でたどられているように、ここには実行の流れが1つしかないことに注意してください。

ダウンロードにはしばらく時間がかかる可能性があるため、プログラムがデータのダウンロードを開始し、データが実際に必要になるまで他の作業を続ける必要があります。

これを実現するには、既存のletバインディングの前にasyncという単語を追加するだけです。

これにより、async-letと呼ばれる同時バインディングに変わります。

同時バインディングの評価は、シーケンシャルバインディングとは大きく異なるので、それがどのように機能するかを学びましょう。

バインディングに遭遇する直前から始めます。

同時バインディングを評価するために、Swiftは最初にそれを作成したサブタスクである新しい子タスクを作成します。

すべてのタスクはプログラムの実行コンテキストを表すため、このステップから2つの矢印が同時に出てきます。

この最初の矢印は子タスク用で、すぐにデータのダウンロードを開始します。

2番目の矢印は親タスク用で、変数の結果をすぐにプレースホルダ値にバインドします。

この親タスクは、前述のステートメントを実行していたタスクと同じです。

データが子によって同時にダウンロードされている間、親タスクは同時バインディングに続くステートメントを実行し続けます。

しかし、結果の実際の値を必要とする式に到達すると、親は結果のプレースホルダを満たす子タスクの完了を待ちます。

この例では、URLSessionの呼び出しもエラーをスローする可能性があります。

これは、結果を待つとエラーが発生する可能性があることを意味します。

だから、私はそれの世話をするために「try」と書く必要があります。

そして、心配しないでください。

結果の値をもう一度読んでも、その値は再計算されません。

Async-letがどのように機能するかを見たので、それを使用してサムネイルのフェッチコードに並行性を追加できます。

単一の画像を独自の関数にフェッチする前のコードの一部を因数分解しました。

この新しい機能は、2つの異なるURLからデータをダウンロードしています。1つはフルサイズの画像自体用、もう1つは最適なサムネイルサイズを含むメタデータ用です。

シーケンシャルバインディングでは、エラーやサスペンションが観察される場所であるため、letの右側に「try await」と書くことに注意してください。

両方のダウンロードを同時に実行するには、これらの両方の許可の前に「非同期」と書きます。

ダウンロードは現在子タスクで行われているため、同時バインディングの右側に「try await」と書かなくなりました。

これらの効果は、同時にバインドされている変数を使用する場合、親タスクによってのみ観察されます。

したがって、式がメタデータと画像データを読み込む前に「try await」と書きます。

また、これらの同時バインドされた変数を使用すると、メソッド呼び出しやその他の変更は必要ないことに注意してください。

これらの変数は、シーケンシャルバインディングで行ったのと同じタイプです。

さて、私が話してきたこれらの子タスクは、実際にはタスクツリーと呼ばれる階層の一部です。

このツリーは単なる実装の詳細ではありません。

それは構造化された並行性の重要な部分です。

キャンセル、優先度、タスクローカル変数などのタスクの属性に影響します。

ある非同期関数から別の非同期関数に呼び出しを行うたびに、同じタスクが呼び出しを実行するために使用されます。

したがって、関数fetchOneThumbnailは、そのタスクのすべての属性を継承します。

Async-letのような新しい構造化タスクを作成すると、現在の関数が実行されているタスクの子になります。

タスクは特定の機能の子ではありませんが、その寿命はそれにスコープされる可能性があります。

ツリーは、各親とその子タスク間のリンクで構成されています。

リンクは、親タスクは、すべての子タスクが終了した場合にのみ作業を完了できるというルールを強制します。

このルールは、子タスクが待たされるのを防ぐ異常な制御フローに直面しても当てはまります。

たとえば、このコードでは、画像データタスクの前に、まずメタデータタスクを待ちます。

最初に待ちに待ったタスクがエラーをスローして終了した場合、fetchOneThumbnail関数はそのエラーをスローしてすぐに終了する必要があります。

しかし、2回目のダウンロードを実行するタスクはどうなりますか?

異常な終了中、Swiftは自動的に未完了のタスクをキャンセルされたものとしてマークし、関数を終了する前に終了を待ちます。

タスクをキャンセルとしてマークしても、タスクは停止しません。

それは単に、その結果がもはや必要ないことをタスクに通知します。

実際、タスクがキャンセルされると、そのタスクの故人であるすべてのサブタスクも自動的にキャンセルされます。

したがって、URLSessionの実装が画像をダウンロードするための独自の構造化タスクを作成した場合、それらのタスクはキャンセルのためにマークされます。

関数fetchOneThumbnailは、直接的または間接的に作成したすべての構造化タスクが完了すると、エラーをスローすることで最終的に終了します。

この保証は、構造化された並行性の基本です。

ARCがメモリの寿命を自動的に管理するのと同じように、ライフタイムの管理を支援することで、誤ってタスクを漏洩するのを防ぎます。

これまでのところ、キャンセルがどのように伝播するかの概要を説明しました。

しかし、タスクが最終的に停止するのはいつですか?

タスクが重要なトランザクションの最中にある場合、またはネットワーク接続が開いている場合、タスクを停止するのは正しくありません。

そのため、Swiftでのタスクのキャンセルは協力的です。

コードはキャンセルを明示的にチェックし、適切な方法で実行を縮小する必要があります。

現在のタスクのキャンセルステータスは、非同期であるかどうかにかかわらず、任意の機能から確認できます。

これは、特に長時間の計算を伴う場合は、キャンセルを念頭に置いてAPIを実装する必要があることを意味します。

ユーザーは、キャンセルできるタスクからコードを呼び出す可能性があり、計算ができるだけ早く停止することを期待します。

協力的なキャンセルを使用するのがどれほど簡単かを確認するには、サムネイルのフェッチ例に戻りましょう。

ここでは、代わりにfetchOneThumbnail関数を使用するように、フェッチするすべてのサムネイルを与えられた元の関数を書き換えました。

この関数がキャンセルされたタスク内で呼び出された場合、無駄なサムネイルを作成してアプリケーションを保持したくありません。

したがって、各ループ反復の開始時にcheckCancellationへの呼び出しを追加できます。

この呼び出しは、現在のタスクがキャンセルされた場合にのみエラーをスローします。

コードにより適切な場合は、現在のタスクのキャンセルステータスをブール値として取得することもできます。

このバージョンの関数では、部分的な結果、一部のサムネイルのみが要求された辞書を返すことに注意してください。

これを行うときは、APIに部分的な結果が返される可能性があることを明確に示す必要があります。

そうしないと、タスクのキャンセルは、キャンセル中でも完全な結果を必要とするため、ユーザーにとって致命的なエラーを引き起こす可能性があります。

これまでのところ、async-letは、構造化プログラミングの本質をキャプチャしながら、プログラムに並行性を追加するための軽量構文を提供することがわかります。

私があなたに伝えたい次の種類のタスクは、グループタスクと呼ばれます。

それらは、構造化された並行性のすべての素晴らしい特性を放棄することなく、async-letよりも柔軟性を提供します。

先に見たように、async-letは、利用可能な一定量の並行性がある場合にうまく機能します。

先ほど説明した両方の機能を考えてみましょう。

ループ内のサムネイルIDごとに、fetchOneThumbnailを呼び出して処理し、正確に2つの子タスクを作成します。

その関数の本体をこのループにインライン化しても、並行性の量は変わりません。

Async-letは、変数バインディングのようにスコープされます。

つまり、次のループ反復が始まる前に、2つの子タスクを完了する必要があります。

しかし、このループがタスクをキックオフして、すべてのサムネイルを同時に取得したい場合はどうなりますか?

次に、配列内のIDの数に依存するため、並行性の量は静的に知られていません。

この状況に適したツールはタスクグループです。

タスクグループは、動的な量の並行性を提供するように設計された構造化された並行性の一形態です。

withThrowingTaskGroup関数を呼び出すことで、タスクグループを導入できます。

この関数は、エラーをスローできる子タスクを作成するためのスコープ付きグループオブジェクトを提供します。

グループに追加されたタスクは、グループが定義されているブロックの範囲よりも長生きすることはできません。

For-loop全体をブロック内に配置したので、グループを使用して動的な数のタスクを作成できるようになりました。

同期メソッドを呼び出すことで、グループに子タスクを作成します。

グループに追加されると、子タスクはすぐに任意の順序で実行されます。

グループオブジェクトがスコープ外になると、その中のすべてのタスクの完了が暗黙的に待たされます。

これは、グループタスクも構造化されているため、先ほど説明したタスクツリールールの結果です。

この時点で、私たちはすでに望んでいた並行性を達成しました。fetchOneThumbnailへの呼び出しごとに1つのタスクで、それ自体がasync-letを使用してさらに2つのタスクを作成します。

それは構造化された並行性のもう一つの素晴らしい特性です。

グループタスク内でasync-letを使用したり、async-letタスク内でタスクグループを作成したりすることができ、ツリー内の並行性のレベルは自然に構成されます。

今、このコードはまだ実行する準備ができていません。

実行しようとすると、コンパイラはデータレースの問題を警告してくれます。

問題は、各子タスクから1つの辞書にサムネイルを挿入しようとしていることです。

これは、プログラムの並行性の量を増やすときのよくある間違いです。

データレースは誤って作成されます。

この辞書は一度に複数のアクセスを処理できず、2つの子タスクが同時にサムネイルを挿入しようとすると、クラッシュやデータの破損を引き起こす可能性があります。

過去には、これらのバグを自分で調査する必要がありましたが、Swiftはそもそもそれらのバグが発生するのを防ぐために静的チェックを提供しています。

新しいタスクを作成するたびに、タスクが実行する作業は、@Sendableクロージャと呼ばれる新しいクロージャタイプ内にあります。

@Sendableクロージャの本体は、タスクの起動後にこれらの変数が変更される可能性があるため、レキシカルコンテキストで変更可能な変数をキャプチャすることが制限されています。

これは、タスクでキャプチャする値が安全に共有できる必要があることを意味します。

たとえば、IntやStringなどの値型であるため、またはアクターなどの複数のスレッドからアクセスするように設計されたオブジェクトであり、独自の同期を実装するクラスであるためです。

「スウィフトアクターで可変状態を保護する」と呼ばれるこのトピックに特化したセッション全体がありますので、ぜひチェックすることをお勧めします。

この例のデータレースを避けるために、各子タスクに値を返すことができます。

この設計は、親タスクに結果を処理する唯一の責任を与えます。

この場合、各子タスクは、サムネイルの文字列IDとUIImageを含むタプルを返さなければならないと指定しました。

次に、各子タスク内で、辞書に直接書き込む代わりに、親が処理するキー値タプルを返してもらいます。

親タスクは、新しいfor-awaitループを使用して、各子タスクの結果を反復処理できます。

For-awaitループは、子タスクから完了順に結果を取得します。

このループは順番に実行されるため、親タスクは各キー値のペアを辞書に安全に追加できます。

これは、for-awaitループを使用して非同期の値のシーケンスにアクセスする一例にすぎません。

独自のタイプがAsyncSequenceプロトコルに準拠している場合は、for-awaitを使用してそれらを反復することもできます。

「Meet AsyncSequence」セッションで詳細を確認できます。

タスクグループは構造化された並行性の一形態ですが、グループタスクと非同期レットタスクのタスクツリールールの実装方法には小さな違いがあります。

このグループの結果を反復処理するときに、エラーで完了した子タスクに遭遇したとします。

そのエラーはグループのブロックからスローされるため、グループ内のすべてのタスクは暗黙的にキャンセルされ、その後待たされます。

これはasync-letと同じように機能します。

違いは、あなたのグループがブロックからの通常の出口を通って範囲外になったときに起こります。

その後、キャンセルは暗黙ではありません。

この動作により、ジョブはキャンセルされず、待たされるため、タスクグループを使用してフォーク結合パターンを表現しやすくなります。

グループのcancelAllメソッドを使用して、ブロックを終了する前に、すべてのタスクを手動でキャンセルすることもできます。

タスクをどのようにキャンセルしても、キャンセルは自動的にツリー下に伝播することを覚えておいてください。

Async-letタスクとグループタスクは、Swiftでスコープ付きの構造化タスクを提供する2種類のタスクです。

さて、私はジョーに物事を手渡します。ジョーは構造化されていないタスクについて教えてくれます。

ありがとう、カヴォン。

こんにちは。私はジョーです。

Kavonは、タスクに明確な階層を持つプログラムに並行性を追加すると、構造化された並行性がどのようにエラー伝播、キャンセル、およびその他の簿記を簡素化するかを示しました。

しかし、プログラムにタスクを追加するときは、常に階層があるわけではないことを知っています。

Swiftは、より多くの手動管理を必要とすることを犠牲にして、より多くの柔軟性を与える非構造化タスクAPIも提供します。

タスクが明確な階層に該当しない可能性がある状況はたくさんあります。

最も明らかに、非非非同期コードから非同期計算を行うタスクを起動しようとしている場合は、親タスクがまったくない可能性があります。

あるいは、タスクの寿命は、単一のスコープや単一の関数の境界に合わないかもしれません。

たとえば、オブジェクトをアクティブな状態にするメソッド呼び出しに応答してタスクを開始し、オブジェクトを無効にする別のメソッド呼び出しに応答して実行をキャンセルすることができます。

これは、AppKitとUIKitにデリゲートオブジェクトを実装するときによく起こります。

UI作業はメインスレッドで行われなければならず、Swiftアクターセッションが議論しているように、Swiftはメインアクターに属するUIクラスを宣言することによってこれを保証します。

コレクションビューがあり、コレクションビューのデータソースAPIをまだ使用できないとします。

代わりに、コレクションビューのアイテムが表示されるように、ネットワークからサムネイルを取得するために書いたfetchThumbnails関数を使用したいと考えています。

ただし、デリゲートメソッドは非同期ではないため、非同期関数の呼び出しを待つことはできません。

そのためにタスクを開始する必要がありますが、そのタスクは実際にはデリゲートアクションに応じて開始した作業の延長です。

この新しいタスクは、UI優先度を持つメインアクターで引き続き実行されることを望んでいます。

タスクの寿命をこの単一のデリゲートメソッドの範囲にバインドしたくないだけです。

このような状況では、Swiftでは非構造化タスクを構築できます。

コードの非同期部分をクロージャに移動し、そのクロージャを渡して非同期タスクを構築しましょう。

さて、実行時に何が起こるかは次のとおりです。

タスクを作成するポイントに達すると、Swiftは、この場合のメインアクターである元のスコープと同じアクターで実行するようにスケジュールします。

一方、コントロールはすぐに発信者に戻ります。

サムネイルタスクは、デリゲートメソッドのメインスレッドをすぐにブロックすることなく、開く開口部がある場合にメインスレッドで実行されます。

この方法でタスクを構築すると、構造化コードと非構造化コードの中間点が得られます。

直接構築されたタスクは、起動されたコンテキストのアクターを継承し、グループタスクやasync-letと同様に、オリジンタスクの優先順位やその他の特性も継承します。

しかし、新しいタスクはスコープ外です。

その寿命は、それが打ち上げられた場所の範囲に縛られていません。

オリジンは非同期である必要さえありません。

スコープなしのタスクはどこでも作成できます。

この柔軟性のすべてのための取引では、構造化された並行性が自動的に処理するものを手動で管理する必要があります。

キャンセルとエラーは自動的に伝播せず、明示的な行動を取らない限り、タスクの結果は暗黙的に待ちられません。

そのため、コレクションビューアイテムが表示されたときにサムネイルを取得するタスクを開始し、サムネイルの準備が整う前にアイテムがビューからスクロールされた場合は、そのタスクをキャンセルする必要があります。

スコープのないタスクで作業しているので、そのキャンセルは自動的にではありません。

今すぐそれを実行しましょう。

タスクを構築した後、得られる値を保存しましょう。

タスクを作成するときに、この値を行インデックスでキー入力された辞書に入れて、後でそのタスクをキャンセルできるようにすることができます。

また、タスクが終了したら辞書から削除して、タスクがすでに完了している場合にタスクをキャンセルしようとしないようにする必要があります。

ここでは、コンパイラによってフラグ付けされたデータレースを取得することなく、その非同期タスクの内外で同じ辞書にアクセスできることに注意してください。

私たちのデリゲートクラスはメインアクターにバインドされており、新しいタスクはそれを継承するので、並行して一緒に実行されることはありません。

データレースを心配することなく、このタスク内のメインアクターバインドクラスの保存されたプロパティに安全にアクセスできます。

一方、デリゲートが後で同じテーブル行がディスプレイから削除されたと言われた場合、値のcancelメソッドを呼び出してタスクをキャンセルできます。

そこで、そのタスクの元のコンテキストから特性を継承しながら、スコープから独立して実行される非構造化タスクを作成する方法を見てきました。

しかし、時には、元のコンテキストから何も継承したくないこともあります。

最大限の柔軟性のために、Swiftは切り離されたタスクを提供します。

名前が示すように、切り離されたタスクはコンテキストから独立しています。

それらはまだ構造化されていないタスクです。

彼らの生涯は、その起源の範囲に縛られていない。

しかし、切り離されたタスクは、元のスコープから他に何も拾うことはありません。

デフォルトでは、同じアクターに制約されず、起動した場所と同じ優先順位で実行する必要はありません。

切り離されたタスクは、優先度などの一般的なデフォルトで独立して実行されますが、新しいタスクの実行方法と場所を制御するためのオプションのパラメータで起動することもできます。

サーバーからサムネイルを取得した後、後で取得しようとするとネットワークに再びヒットしないように、ローカルディスクキャッシュに書き込むとします。

キャッシュはメインアクターで行う必要はなく、すべてのサムネイルの取得をキャンセルしても、取得したサムネイルをキャッシュすることは役に立ちます。

では、切り離されたタスクを使用してキャッシュを開始しましょう。

タスクを切り離すと、新しいタスクの実行方法の設定にも柔軟性が高まります。

キャッシュは、メインUIに干渉しないより低い優先度で行われるべきであり、この新しいタスクを切り離すときにバックグラウンドの優先度を指定できます。

少し前もって計画を立てましょう。

サムネイルで実行したいバックグラウンドタスクが複数ある場合、将来何をすべきですか?

より多くのバックグラウンドタスクを切り離すことができますが、切り離されたタスク内で構造化された並行性を利用することもできます。

さまざまな種類のタスクを組み合わせて、それぞれの強みを活用することができます。

すべてのバックグラウンドジョブの独立したタスクを切り離す代わりに、タスクグループを設定し、各バックグラウンドジョブを子タスクとしてそのグループに生成することができます。

そうすることには多くの利点があります。

将来的にバックグラウンドタスクをキャンセルする必要がある場合、タスクグループを使用すると、その最上位の切り離されたタスクをキャンセルするだけで、すべての子タスクをキャンセルできます。

そのキャンセルは自動的に子タスクに伝播し、ハンドルの配列を追跡する必要はありません。

さらに、子タスクは自動的に親の優先順位を継承します。

この作業をすべてバックグラウンドで維持するには、切り離されたタスクをバックグラウンド化するだけで、すべての子タスクに自動的に伝播されるため、バックグラウンドの優先順位を推移的に設定するのを忘れたり、誤ってUI作業を飢えさせたりすることを心配する必要はありません。

この時点で、私たちはSwiftにあるタスクの主要な形式をすべて見てきました。

Async-letを使用すると、固定数の子タスクを可変バインディングとして生成し、バインディングがスコープ外になった場合のキャンセルとエラーの伝播を自動的に管理できます。

まだスコープに制限されている動的な数の子タスクが必要な場合は、タスクグループに移動できます。

十分にスコープされていないが、元のタスクに関連する作業を中断する必要がある場合は、非構造化タスクを構築できますが、それらを手動で管理する必要があります。

また、最大限の柔軟性のために、オリジンから何も継承しない手動で管理されたタスクであるタスクも切り離されています。

タスクと構造化された並行性は、Swiftがサポートする一連の並行性機能の一部にすぎません。

他のすべての素晴らしいトークをチェックして、それが他の言語にどのように適合するかを確認してください。

「Meet async/await in Swift」は、非同期関数に関する詳細を提供し、同時コードを書くための構造化された基礎を提供します。

アクターは、データレースから安全な並行システムを作成するためのデータ分離を提供します。

方法の詳細については、「Swiftアクターで変更可能な状態を保護する」セッションを参照してください。

タスクグループで「for await」ループを見ましたが、これらは非同期データストリームを操作するための標準インターフェイスを提供するAsyncSequenceの一例にすぎません。

「Meet AsyncSequence」セッションは、シーケンスを操作するための利用可能なAPIをより深く掘り下げます。

タスクはコアOSと統合して低オーバーヘッドと高いスケーラビリティを実現し、「Swift並行性：舞台裏」セッションでは、それがどのように達成されたかについてより技術的な詳細を提供します。

これらすべての機能が組み合わさって、Swiftで並行コードを書くことを簡単かつ安全にし、アプリの興味深い部分に焦点を当てながら、デバイスを最大限に活用するコードを書くことができます。並行タスクを管理する仕組みや、マルチスレッドによって引き起こされる潜在的なバグの心配についてはあまり考えません。

ご覧いただきありがとうございます。

残りの会議を楽しんでください。

[明るい音楽]。