10019

こんにちは、「SwiftUIで並行性を発見する」へようこそ。

SwiftUIチームのエンジニア、カート・クリフトンです。

後で、同僚のジェシカが加わります。

Swift 5.5では、Swiftコードの並行性を管理するためのさまざまな新しいツールが導入されています。

この講演では、ジェシカと私は、これらの改善がSwiftUIアプリとどのように相互作用するかを理解するお手伝いをします。

新しいツールがデータモデルをさらに良くするのにどのように役立つか、SwiftUIが新しいメインアクターとどのように連携するかを紹介します。

その後、ジェシカは、並行データモデルをSwiftUIビューに接続する方法を示し、Swiftの新しい並行性ツールを活用する素晴らしい新しいAPIを紹介します。

ジェシカと私が共有する情報を最大限に活用するには、Swiftの新しい並行性サポートの背景を持つことが重要です。

このビデオの残りの部分に飛び込む前に、「Swiftで非同期/待機する」と「スウィフトで構造化された並行性を探る」を見ることをお勧めします。

子供の頃、私はいつも宇宙飛行士になることを夢見ていました。

私は時々宇宙船で働いていますが、そうでなければ、その特定の子供の頃の夢は実現しませんでした。

それでも、私は宇宙への熱意を失っていません。

そこで、SwiftUIエンジニアとしての実際のスキルを適用して、宇宙関連の写真をダウンロードするアプリを構築することにしました。

私が計画したアプリを見てみましょう。 

このアプリは、ランダムな宇宙写真のリストを表示します。

これらの色はただ美しいです。

私が本当に好きな写真を見たら、後で見るためにそれを保存することができます。

これらの美しい画像を取得するために、私のアプリはREST APIを使用してウェブサービスと対話します。

これは、Swiftで導入された新しい並行性機能の完璧な使い方のように聞こえます。

データモデルから始めましょう。

SpacePhoto構造体を使用して、単一の画像の情報を保持しています。

構造体には、タイトル、写真の説明、画像が投稿された日付、実際の画像を指すURLなどのフィールドがあります。

サーバーの応答からインスタンスを簡単にインスタンス化したり、ディスクに保存したり、ForEachやその他のデータ駆動型ビューで使用できるように識別できるように、タイプをCodableにしました。

次に、これらのエントリのリストを表示します。

そのために、それらのコレクションを取得して保持するモデルが必要です。

私はこのために写真のクラスを使っています。

写真クラスをObservableObjectに準拠させることで、SwiftUIビューはデータが更新されるたびに自動的に更新されます。

公開されたプロパティを使用して、SpacePhotosの配列を保存しています。

RESTエンドポイントから更新されたアイテムを取得するには、Update Itemsメソッドを使用しています。

それについては、すぐに詳しく話します。

しかし、まず基本的なユーザーインターフェイスを大まかにしたいと思います。

これは私が構築したいユーザーインターフェースです。

これまでのところ、タブビューと基本的なPhotoViewがあるだけです。

My PhotoViewはスペース写真を撮り、そのタイトルを表示します。

それは私が動作中の私のデータモデルを見ることができるのに十分な配管です。

次はカタログビューを見てみましょう。

私のカタログビューには、写真のリストが表示されます。

これを行うには、状態オブジェクトを追加し、Photosの観測可能なオブジェクトでインスタンス化します。

私のビューの本文に、NavigationViewを追加します。

ここでナビゲーションビューを使用すると、まもなく大きなナビゲーションタイトルを追加できます。

次に、NavigationViewの中にリストを追加します。

そして、私のリストの中で、私はForEachを使用して私の写真の上にマッピングし、それらのそれぞれにPhotoViewを表示します。

そで、私は自分のサンプルデータを見ることができます。

それは私が今のところ行く必要がある限りですが、ここにもう少し磨きを加えましょう。

まず、これが約束されたナビゲーションタイトルです。

さて、ここでのデフォルトの挿入リストスタイルは素晴らしく見えますが、本当に私の宇宙写真を披露するために、写真が黒い背景に対して本当にポップになるようにプレーンスタイルに切り替えたいです。

ここで新しい列挙型のような静的メンバー構文を使用して、リストスタイルをプレーンにすることができます。

この構文を使用すると、SwiftUIのスタイル修飾子は、Xcode 13のオートコンプリートをよりよくサポートし、より簡潔なスペルを取得します。

最後に、今年のSwiftUIで新しい別の機能を使用させてください。リスト区切りの制御です。

ForEach内では、listRowSeparator修飾子を使用してセパレータを非表示にすることができます。

時々、SwiftUIでユーザーインターフェイスを磨いているとき、私は止めるのは難しいと感じます。

しかし、私は今のところUIを離れます。

ジェシカは、私がデータモデルを終えた後、それを終える予定です。

しかし、データモデルを掘り下げる前に、SwiftUIが観測可能なオブジェクトとどのように相互作用するかについて少しお話ししたいと思います。

そして、Swift 5.5の新しい並行性機能により、このインタラクションがこれまで以上に簡単になります。

Dub Dub 2020の「Data Essentials in SwiftUI」で、同僚のRajがSwiftUIの更新ライフサイクルについて話しました。

このライフサイクルを駆動するコードを「実行ループ」と呼びます。Swift 5.5では、実行ループはメインアクターで実行されます。

一般的な俳優の詳細については、「スウィフト俳優で可変状態を保護する」というトークをチェックしてください。ジェシカと私はこの講演の主役に焦点を当てます。

SwiftUI実行ループは、ユーザーからイベントを受信し、モデルを更新し、SwiftUIビューを画面にレンダリングします。

私はこれらのアップデートを「実行ループのティック」と呼ぶのが好きです。このループを展開して、複数のティックを連続して見てみましょう。

SwiftUIでは、ObservableObjectsはいくつかの興味深い方法でSwiftUI実行ループと対話することができます。

Photos ObservableObjectに戻り、updateItemsメソッドを見てみましょう。

SwiftUIビューからupdateItemsを呼び出すと、メインアクターで実行されます。

この青い長方形を使って、updateItemsが実行されている時刻を表示しましょう。

フェッチした写真を「アイテム」プロパティに割り当てるこのコード行に集中したい。

「アイテム」は公開されたプロパティであるため、この割り当てはobjectWillChangeイベントをトリガーし、すぐにフェッチされた写真を「アイテム」のストレージに書き込みます。SwiftUIがこのobjectWillChangeを見ると、私のアイテムのスナップショットを撮ります。

スナップショットの後の実行ループの次のティックで、SwiftUIはスナップショットを現在の値と比較します。

これらの値は異なるため、SwiftUIは写真に依存するビューを更新することを知っています。

objectWillChange、ストレージの更新、および実行ループティックはすべてメインアクターで発生するため、順番に発生することが保証されていることに注意してください。

2020年の「Data Essentials」トークでは、Rajは、あなたのビューが体内で作業しすぎるときの遅い更新について説明しています。

モデルコードがメインアクターで作業しすぎると、更新が遅くなることもあります。

たとえば、ダウンロードが完了するのを待っている間にfetchPhotos機能がブロックされ、接続が遅いとします。

主演俳優をブロックしているので、このランループのダニが恋しいです。

これは私のユーザーにヒッチとして表示されます。

過去には、高価なfetchPhotosがメインスレッドから発生するように、作業を実行するために別のキューにディスパッチした可能性があります。

これはうまくいくように思えるかもしれませんが、私はここでトリッキーな問題を抱えています。

ObservableObjectを主役から変更しています。

私の変更と実行ループのティックがインターリーブされる可能性があります。

たとえば、「アイテム」に割り当て、SwiftUIがobjectWillChangeスナップショットを取ると、これは実行ループのティックの直前に発生する可能性があります。

状態の変更はまだ起こっていないので、SwiftUIはスナップショットを変更されていない値と比較します。

実際の状態の変化は実行ループのチェックの後に起こりますが、SwiftUIはその変化を見ないので、私のビューは更新されません。

正しく更新するには、SwiftUIはこれらのイベントを順番に実行する必要があります。objectWillChange、ObservableObjectの状態が更新され、実行ループが次のティックに到達します。

これらすべてが主役で起こることを確実にすることができれば、この注文を保証できます。

Swift 5.5より前は、状態を更新するためにメインキューに派遣していたかもしれませんが、今でははるかに簡単です。

ただ待ってください!

Awaitを使用してメインアクターから非同期呼び出しを行うことで、非同期作業が発生する間、メインアクターで他の作業を続行させます。

これは主役の「ielding」と呼ばれています。

updateItemsでは、awaitを使用して、ロングランI/O中にメインアクターをSwiftUIに戻すことができるため、実行ループのカチカチを維持し、UIのヒッチを回避できます。

非同期作業が完了すると、Swiftはmain actorにupdateItemsメソッドを再入力するので、状態を更新できます。

これがどのように機能するか見てみましょう。

別のキューにディスパッチする代わりに、長時間の操作の結果を待つだけです。

awaitを書くと、updateItems関数はメインアクターの制御を生成し、実行ループを続行できます。

待ちに待ったフェッチが完了すると、メインアクターが関数を再入力し、公開されたプロパティを安全に更新し、objectWillChangeをトリガーし、新しい値をSwiftUIで使用できるようにします。

Xcodeに飛び込んで、フェッチを実現できるかどうか見てみましょう。

これは私がスライドで示したupdateItemsメソッドです。

fetchPhotosを実装するには、まず1枚の写真を取得するコードを追加しましょう。

fetchPhotoメソッドに残りのエンドポイントから写真のURLを取得させ、SpacePhotoを返します。

次に、URLSessionのデータ利便性の新しい非同期バージョンを使用して、URLからデータを取得します。

これをスタブするために、私は強制的なトライを使用しています。

すぐに片付けます。

ああ、データメソッドは非同期なので、awaitを使う必要があります。

つまり、fetchPhotoメソッドを非同期にする必要があるということです。

オーケー、いいね。

データがわかったので、Decodable初期化子を使用して写真をインスタンス化して返します。

次はfetchPhotosを見てみましょう。

私は日付をランダムに選択し、それらをループするためにいくつかのコードをスタブしました。

配列を構築したいので、「ダウンロード済み」をvarにし、ループに日付変数を追加します。

ループ内で、特定の日付を取得するための残りのエンドポイントURLをすでに構築する必要があるヘルパーメソッドを呼び出します。

次に、fetchPhotoメソッドを呼び出して、結果を配列に追加します。

そして、構築しましょう。

ああ、fetchPhotoは非同期なので、結果を待つ必要があります。

つまり、fetchPhotosも非同期である必要があります。

シンプルにするために、写真を順番にフェッチするためにこれらの呼び出しをしています。

さらに強力なオプションについては、Swift 5.5のタスクグループをチェックしてください。

今、私はスライドで示したようにフェッチ写真を待つ必要があります。

そして、それで、私の更新ロジックが整っています。

さて、フェッチを実現しようとするこれらの強制的な試みによって、私と同じくらい緊張しているかもしれません。

それを片付けましょう。

今のところ、ダウンロードが失敗したらゼロを返します。

次に、fetchPhotosでは、nil以外の値のみを配列に追加します。

Photosがasync-awaitを使用しているので、メインアクターで実行されている限り、私が議論したトリッキーなobjectWillChangeのバグに遭遇しないと確信できます。

しかし、どうすればそれを保証できますか?

幸いなことに、Swiftコンパイラはここで私を助けることができます。

写真に新しい@MainActorアノテーションを追加することで、コンパイラは写真のプロパティとメソッドがメインアクターからのみアクセスされることを保証します。

それが終わったら、モデルは所定の位置にあります。

次に、ジェシカは私たちの見解をモデルに結びつけ、アプリの並行性を活用するための素晴らしい新しいSwiftUI APIを紹介します。

ジェシカ？

ありがとう、カート。

CatalogViewに切り替えて、Curtが示したupdateItemsメソッドを使用しましょう。

カタログが表示されるたびにupdateItemsを呼びたいです。

過去には、これにonAppearを使用したことがあるかもしれませんが、今年からSwiftUIでは、タスク修飾子を使用します。

タスクを使用すると、非同期タスクをビューに関連付けることができます。

タスクは、ビューの寿命の開始から始まります。

タスクはデフォルトで非同期なので、そのクロージャの中で、myPhotosオブジェクトのupdateItemsを呼び出すことができ、結果を待つことができます。

これはタスクの素晴らしい使い方ですが、この新しい修飾子にはさらに多くのものがあります。

タスクのライフタイムはビューのライフタイムに関連付けられているため、非同期シーケンスを待ち、その値に応答するなどを行うことができます。

そして、ビューの寿命が終了すると、タスクは自動的にキャンセルされます。

ビューライフタイムの詳細については、トーク「Demystify SwiftUI」を必ずチェックしてください。ライブプレビューを使用すると、エントリが更新されていることがわかります。

しかし、私たちはまだ美しい画像が欠けています。

私はすでにCurtが以前に示したPhotoViewを更新しています。

タイトルの後ろにいくつかの背景資料を追加します。

では、画像を追加しましょう。

幸いなことに、新しいAsyncImage APIを使用すると、リモートサーバーからの画像の読み込みがこれまで以上に簡単になります。

私がしなければならないのは、エントリから取得したい画像URLを取得し、それをAsyncImageに渡すことだけです。

さて、これはフルサイズでは少し大きすぎるので、AsyncImageのオーバーロードを使用して、画像を調整し、ユーザーが自分の画像がロードされていることを知らせるようにプレースホルダを表示しましょう。

次に、画像のサイズを変更可能にし、スペースを埋めるためにアスペクト比を設定します。

最後に、画像を柔軟にするために、最小幅と高さを追加します。

ゼロ以外の最小高さを使用すると、プログレスビューがタイトル領域を覗くことも確認できます。

SwiftUIの残りの部分と同様に、AsyncImageにはインテリジェントなデフォルトが組み込まれているため、画像の読み込みにエラーが発生した場合でも、結果はプレースホルダを表示し続けることになります。

エラー処理の動作をカスタマイズすることもできます。

これを行うには、「フェーズを使用するAsyncImageのオーバーロード」をチェックしてください。また、ユーザーが後で表示するためにお気に入りの画像を保存できれば素晴らしいことです。

これを行うには、このタイトルエリアにボタンを追加しましょう。

このボタンは、イメージエントリをディスクに保存するための非同期アクションをトリガーします。

保存されたエントリは、アプリの[保存済み]タブに表示されます。

私はすでにこれを行うためにスタブしました。

ここに追加して、そのコードを見てみましょう。そのコードを見てみましょう。

これが私の保存ボタンのスタブインバージョンです。

写真を保存するアクションを追加しましょう。

SwiftUIのボタンアクションは同期ですが、私の「保存」メソッドは非同期です。

メソッドを呼び出すには、非同期タスクを開始します。

次に、クロージャの中で、「写真」の「保存」メソッドを呼び出します。非同期なので、awaitを使います。

セーブ中にプログレスビューを表示しておくといいと思います。

これを行うには、州のプロパティを追加します。

その後、通話の周りの状態を更新して保存します。

次に、ボタンのラベルを更新して、保存時に進行状況ビューを表示します。

「不透明度」を使用して保存ラベルを非表示にし、オーバーレイを使用して進行状況ビューを表示しています。

この組み合わせは、「保存」という単語のローカリゼーションに基づいて、ボタンが同じサイズのままであることを保証します。最後に、保存中にボタンを無効にします。

これがライブプレビューでどのように機能するか見てみましょう。

それはかなり素晴らしいです!

カタログビューに戻って、すべてをまとめましょう。 

SwiftUIには今年、人々が手動でデータを更新する機能を与えるために使用できる素晴らしい新しい修飾子があります。

更新可能な修飾子をリストに追加することで、このコンテンツが更新可能であることをSwiftUIに伝えます。

更新可能な非同期クロージャを提供し、updateItemsメソッドを呼び出してリストを更新することができます。

先ほど「タスク」で示したように、この非同期メソッドでawaitを使用します。

リフレッシュインジケーターは、非同期作業が完了すると自動的に閉じます。

これで、プルダウンして画像を更新し、[保存]をタップして好きな画像を保存し、[保存済み]タブに切り替えて保存した画像を見ることができます。

Swiftの新機能により、並行データの操作が容易になります。

SwiftUIは、Swiftの並行性機能とうまく統合され、デフォルトで最高の動作を提供します。

多くの場合、並行性の力を活用するためにawaitを使用する必要があります。

ObservableObjectを「@MainActor」としてマークして、ビューとうまく機能する方法でオブジェクトの更新をより堅牢にチェックします。

SwiftUIのAPI追加を利用して、最小限の労力で安全でパフォーマンスの高い同時アプリを作成してください。

AsyncImageを使用して、画像を同時にロードします。

ビュー階層に「更新可能な」修飾子を追加して、ユーザーが手動でデータを更新できるようにします。

保存ボタンで見たように、独自のカスタムビューでSwiftの新しい並行性機能を使用できます。

ご存知のように、並行性は難しいです。

難しい問題ですが、これらの新しい言語機能とSwiftUI APIを使用すると、アプリでその複雑さを管理するためのツールができました。

Swift 5.5とSwiftUIの素晴らしい新しい並行性ツールについて学ぶことを楽しんだことを願っています。アプリのトリッキーな問題に取り組むためにそれらを使用するすべての方法を楽しみにしています。

[音楽]。