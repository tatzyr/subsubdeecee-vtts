10017

♪ ♪

みなさん、こんにちは。

コアデータチームのマイケル・ルヒューです。

そして今日、Core DataとSwiftでの作業を本当に優れた経験にするためにチームが行った機能強化のいくつかについてお話しできることを本当に楽しみにしています。

Core Dataが、すべてのAppleプラットフォームで顧客のデータ永続性のニーズに対応する優れたソリューションであるレビューから始めます。

次に、Core DataがSwiftランタイムで新しい並行性の機会を採用した方法についての議論をフォローアップします。

次に、Swiftでコードをより表現力豊かにするために、Core Data APIに対して行った機能強化のいくつかについて説明します。

そして、Core Dataが2020年に導入した既存のSwiftUIサポートに追加している動的な機能の探求で議論を締めくくります。

しかし、あなたが開発しているAppleプラットフォームに関係なく、あなたは単にアプリケーションを持っているので、最初から始めましょう。

ある時点で、アプリケーションは最終的にユーザーデータに遭遇し、どこかに保存する必要があるでしょう。

そのニーズのための素晴らしい選択は、コアデータを使用することです。

Core Dataは、堅牢で機能豊富な方法でユーザーのデータを永続化したいアプリケーション開発者のためのAppleの特徴的なフレームワークです。

このフレームワークは、メモリ内のオブジェクトグラフとして表現される方法から、ストレージでのモデル化方法まで、ユーザーデータを適切に管理する複雑さの多くを処理します。

このフレームワークはまた、メモリの使用やレイテンシなどの重要なランタイムの考慮事項を管理するために多大な努力をしています。

フレームワークによって提供される機能もスケーラブルです。

シンプルでローカルに永続的なストアから始めて、複数の実行コンテキストを使用してパフォーマンスを向上させ、CloudKitを通じて強力な共有データエクスペリエンスを作成することもできます。

Core Dataは、Appleがサポートするすべてのプラットフォームでも機能します。

そして、私は本当にこの最後の点を強調したいと思います。

コアデータを使い始めると、学んだことはすべて、MacからiPhone、さらにはApple Watchまで、各プラットフォームで機能します。

そしてもちろん、Core DataはSwiftでもうまく機能します。

過去数年間、私たちはSwiftで可能な限り表現力豊かになるようにCore Data APIを強化し続けています。

そして、これは言語とランタイムにまったく新しい並行性機能が導入され、Swiftにとってかなりエキサイティングな年です。

創業以来、Core Dataは常にコードを同時に実行することを気にしてきましたが、これには本当に正当な理由があります。

永続的なデータには、一部の外部ストレージメディアへの読み書きが必要であり、これにより、新しい並行性モデルをサポートすることが自然に適合します。

地震サンプルアプリケーションのコンテキストで、これがどのように機能するかを探りましょう。

このアプリケーションは、米国地質調査所からのデータフィードを読み取り、コアデータを使用して、マグニチュード、場所、イベントが発生した日付など、最近の地震に関する情報を保存します。

アーキテクチャ的には、Earthquaksは、UIを駆動するためのビューコンテキストと、USGSが提供するデータを取り込むためのバックグラウンドコンテキストを持つSwiftアプリケーションです。

私たちのサンプルには、アプリケーション用のローカルコンテナがあり、USGSのJSONフィードから地震データを収集します。

データをダウンロードすると、それをJSONパーサーに引き継ぎ、それをバックグラウンドコンテキストにインポートして、管理オブジェクトに変換され、ローカルストアに保存されます。

その後、ビューコンテキストは変更をマージして、UIを魔法のように更新します。

2020年には、バッチ操作を使用してこのデータを効率的に処理する方法に焦点を当てました。

しかし、今、これらの操作を同時に実行する方法に焦点を当てたいと思います。

特に、アプリケーションにデータをインポートするために取る3つのステップに焦点を当てたいと思います。

ステップ1は、生データをダウンロードすることであり、ダウンロードが成功すると、アプリケーションはそれを特定のローカル表現に変換する必要があります。

そして最後に、新しいオブジェクトを永続ストアに保存します。

これを高レベルのコードに変換しましょう。

各操作を独自の機能またはクロージャに抽象化しました。

アプリは最初にサーバーから生データを取得し、それを便利なローカル表現に処理し、バックグラウンド管理オブジェクトコンテキストでバッチ挿入要求を行うことでオブジェクトをコアデータにインポートします。

このように書かれているので、潜在的なボトルネックを視覚化するのは少し簡単です。

ネットワーク経由でデータをロードすることは、非同期に作業を行うことを検討する絶好の機会です。

変換も考慮すべき場所かもしれません。

さらに、永続的なストアにデータをインポートすることは非常に適切なようです。

しかし、歴史的に、これらすべてのケースでは、そのような非同期メカニズムを自分で実装するか、フレームワーク固有の実装に大きく依存する必要があります。

コアデータの特定の抽象化について話しましょう。

Core Dataの場合、performAndWaitを呼び出すと、管理オブジェクトコンテキストは、独自の保護された実行環境内で提供されたクロージャを実行します。

これは、作業が完了するまで呼び出しスレッドを結びつける可能性があります。

これを視覚化すると、前、中、後にラベル付けした3つのコードブロックを想像できます。

コードが実行されると、最初にBEFOREというラベルの付いたコードが、元のスレッドで実行する機会を得ます。

次に、performAndWaitを呼び出し、呼び出しスレッドは、クロージャ中に発生する作業が完了するまでブロックされます。

その作業が完了すると、AFTERで説明されたコードが実行されます。

もちろん、閉鎖が終了するのを待つ必要がない場合は、常に完全非同期バリアントを提供してきました。

しかし、今年新しく、Swiftは、コアデータがAPIの意図をより正確に記述することを可能にする深い言語統合を備えた強力な並行性モデルを獲得しました。

構文は少し異なります。

実行の結果を待つように頼みますが、この新しいAPIを使用するためのメンタルモデルは、管理オブジェクトが常にサポートしてきたものとまったく同じです。

しかし、利点は、並行性がもはや隠された実装の詳細ではなく、代わりにSwift言語に深く統合されていることです。

このため、コンパイラは、データレースやデッドロックなどの多くの一般的な並行性バグを自動的に防止し、タスクが結果を待っていることが知られているときにリソースを効率的に利用することさえできます。

コードに戻って、実際にこれを使うのがどのようなものか見てみましょう。

私たちが見たように、あなたは非同期宣言された関数を待つように頼みます。

これは、非同期関数が返すことによって制御を生成するまで、呼び出し実行コンテキストを一時停止する可能性があります。

また、予想通り、スローされたエラーを呼び出しフレームにルーティングすることで、Swiftの既存の構造化エラー処理とシームレスに連携します。

非同期関数を呼び出す例を見たので、管理オブジェクトコンテキスト内で非同期作業を実行するCore Dataのまったく新しい方法を見て、それらがどのように宣言されているかを見てみましょう。

Swiftコードのこの小さなスタンザにはかなりの機能が詰め込まれていますが、私はいくつかの重要な詳細について話すだけで、実際にそれを使用する方法を示すことに飛びつきます。

新しい実行オーバーロードの宣言から始めます。

返すことができる結果の種類に基づいてジェネリックであり、Swiftの新しい並行性機能にこの機能を選択する新しいasyncキーワードで装飾されていることがわかります。

おそらく、この新しいAPIの最も重要な側面は、提供されたクロージャにより、エラーをスローしたり、値を返したりできるようになり、これらを手動で呼び出しフレームに戻す手間を節約できることです。

いくつかの異なるシナリオを探求して、これがどれほどクールか見てみましょう。

歴史的に、並行性が実装内に隠れていたため、performAndWaitの外部にエラーをルーティングする唯一の方法の1つは、オプションを閉じてからチェックすることでした。

完了ハンドラーを渡し、それらを一貫して使用していることを確認することで、多くの配管を行う必要があるため、完全に非同期バージョンのパフォーマンスを使用している場合、これはより複雑になる可能性があります。

Swiftの新しい並行性モデルでは、その配管のすべてがあなたのために処理されます!

試してみて、あなたの非同期作業を待つだけで、エラーが発生した場合は、それをスローするだけで、物事は自然に呼び出しフレームに巻き戻されます。

だから今、私たちはエラーに焦点を当てましたが、結果はどうですか?

さて、私が説明したものはすべてまったく同じように機能します。

具体的な例を見てみましょう。

コードに飛び込む前に、やりたいことをスケッチしましょう。

この例では、過去5時間に発生した地震の数を識別するためのフェッチ要求を設定したいと思います。

文として、これは説明するのが簡単な作業です。

しかし、コードでは、物事を少し並べ替える必要があります。

まず、5時間前がいつだったかを把握する必要があります。そのため、カレンダーAPIを使用して、これを堅牢な方法で計算できます。

次に、その日付に関する述語でフェッチ要求を設定し、カウント結果タイプを要求します。

コードでは、それは私たちの計画とほぼよく似ています。

カレンダーのオフセットAPIを使用して、今から5時間前に計算し、気になる日付と一致する述語でカウント結果を返すようにQuake FetchRequestを設定します。

歴史的に、結果を返すことは、エラーをキャプチャする方法と同様のパターンに従っていた。

変異する必要がある状態を閉じ、管理対象オブジェクトコンテキストで計算を実行し、後で制御を取り戻した後に結果を使用します。

これで、実行コールの結果を待って、実行結果を呼び出しフレームに直接返すことができます。

残りのコードはまったく同じです。

それは、そのコードが持っていたかもしれない潜在的なバグやニュアンスと一緒に避けるのは、手による値ルーティングだけです。

この新しいコードは非常に簡潔で表現力豊かです。

しかし、注意すべき時があることに言及する価値があります。

別の例を見て、その理由を見てみましょう。

この例では、最新の地震を管理対象として返そうとします。

新しいAPIを使用すると、値を返すのが本当に簡単になりますが、すでに管理オブジェクトコンテキストに登録されている管理オブジェクトを返すのは安全ではありません。

実行する呼び出しの終了中にそのような登録されたオブジェクトを参照することはのみ有効です。

代わりに、異なる実行コンテキスト間で管理オブジェクトを参照する必要がある場合は、オブジェクトIDを使用して必要に応じて再フェッチするか、フェッチ要求の辞書表現オプションを使用します。

もう1つの例を見る前に、まだ話していない詳細を取り上げたいと思います。

そして、その詳細はSchededTaskTypeです。

これまでのところ、私たちが見てきたすべての非同期パフォーマンスは、このオプションのデフォルト値の観点からです: .immediate。

.Enqueuedと呼ばれる2番目のオプションがあり、これら2つのスケジューリングアプローチの違いを理解するために、作業をスケジュールするように依頼するときに、管理オブジェクトコンテキスト内で具体的に何が起こるかを考えるのに役立ちます。

ご覧のとおり、.immediateはSwift-async-awareバージョンのperformAndWaitによく似ています。

別の実行コンテキストで実行していて、バックグラウンドコンテキストで実行される作業を待つように依頼する場合は、スケジュールされて完了するまで待ちます。

ただし、すでに同じ実行コンテキストにいる場合、作業はすぐに楽観的にスケジュールされます。

一方、.enqueuedは少し簡単です。

元のコールサイトの親和性に関係なく、常にコンテキストの作業セットの最後に要求された作業を追加するだけです。

先に進んで、もう1つの例を見てみましょう。

これらの非同期機能はすべて、あなたも採用できます。

ここでは、私たちが話していたインポートロジックを、新しいasyncキーワードで装飾された新しいimportQuakes関数に因数分解しました。

この機能は、順番に、他の非同期機能の観点から実装されています。

今、誰もがSwiftの新しい並行性機能を利用するために、この新しい機能を待つことができます。

これまでに見たものをまとめましょう。

全体として、この新しいAPIは、Swiftの構造化された並行性のサポートをコアデータにもたらします。

実行APIの新しいバリアントは、あなたがすでに知っていて愛している既存のCore Data APIのSwift並行性対応バージョンです。

アプリケーションでこの新しいAPIを利用することを強くお勧めします。

さらに、NSManagedObjectContextは、保護された並行性ドメイン内でタスクの実行をサポートするコアデータの唯一のタイプではありません。

また、NSPersistentContainerとNSPersistentStoreCoordinatorの両方に同様のAPIを追加しています。

これらのAPIの一般的な形状と動作は、私がすでに説明したものと非常によく似ています。

しかし、そのすべての同時パワーで、私はあなたが自由に使える既存のデバッグツールを使用するというアドバイスを提供しないのは怠慢です。

もちろん、Xcodeが提供するアドレスとスレッドサニタイザーは、存在すら知らないかもしれないバグをキャッチするのに非常に役立ちます。

これらは両方とも、スキームエディタの実行設定の診断ペインにあります。

各サニタイザーは、安全なメモリ使用の仮定の検証や、複数のスレッドからのデータの適切な使用など、さまざまな種類の問題を検出します。

ソフトウェアをユーザーのコミュニティにリリースする前に、アプリケーションと関連するテストを両方のサニタイザーで認定することは常に良い考えです。

また、サニタイザーはすべてのコンテキストで役立ちますが、Core Dataは、より多くのドメイン固有のヘルプを得るために有効にできる特別なランタイムフラグを提供していることを強調したいと思います。

このオプションを有効にすると、Core Dataは内部ロックを検証し、さまざまなCore Dataタイプの適切な使用を確認するために、多くの有用なアサーションをオンにします。

今年のコアデータの変更は、Swift並行性サポートの採用だけではありません。

CloudKitの共有から新しいSpotlight統合まで、私たちが導入するすべての新しいAPIは、Swiftでのプレゼンテーションを念頭に置いて作られています。

今年は、これらのトピックごとに別々のセッションがあり、それらをチェックすることをお勧めします。

さらに、Swiftを改善できる他の場所を特定するために、フレームワーク全体を通過しました。私たちがサポートするさまざまな永続的なストアの種類から始めて、これらのいくつかを紹介したいと思います。

リコール、永続的なストアは、顧客のデータを物理的にどのように保存したいかを説明しています。

Core Dataは現在、XML、バイナリ、インメモリ、SQLiteの4つのストアを提供しています。

そして、あなたはこれらの識別子を常に使用します。

今年の新しい、私たちは先に進み、スウィフトでこれらのより自然な名前を与えました。

既存の名前は引き続き機能しますが、これらを消費する新しいAPIは、名前が短く、これらのシンボルをオートコンプリートできるため、はるかに人間工学的になります。

もちろん、コアデータでは、タイプに関係する永続的なストアだけではありません。

結局のところ、フレームワークは型付きデータの保存がすべてであり、そのような型は属性記述で説明されています。

そして今年は、それらのタイプを操作するためのはるかに自然な構文を提供する属性記述に新しい拡張可能な列挙を追加します。

ランタイムモデルがXcodeモデルビルダーで設計したものと一致することを検証できるユニットテストを書いて、これらの動作を見てみましょう。

簡単にするために、地震オブジェクトモデルで定義された単一のランタイムタイプを検証しようとしますが、これがどのように拡大するかを想像できます。

これは書くべき小さなテストのように思えるかもしれませんが、将来的にはより興味深い診断をスピードアップすることができるので、検証するのは良いことです。

このテストを書くために、新しい属性タイプの観点からクイックヘルパー関数を書きます。

さあ、この機能を説明しましょう。

属性名、関心のあるエンティティの説明、および新しいAttributeType列挙の観点から記述されたタイプを期待する署名から始めます。

このユーティリティの定義はかなり簡単です。

まず、提供された名前の属性があることを検証し、見つからない場合はテストに失敗します。

そして、属性のタイプが期待どおりであることを検証します。

そして、それが本当にそれにあるすべてです。

エンティティとプロパティごとにこれを繰り返し、ランタイムの動作が定義したモデルと一致するという安心感を享受できます。

そして、これは、今年Swiftでコアデータの列挙に対して行った人間工学に基づいた改善のほんの一例です。

今まで、私は多くの低レベルのフレームワークインタラクションと、それらがSwiftでどのように現れるかに焦点を当ててきましたが、ユーザーにデータを提示するのはどうですか?

2020年には、SwiftUIでCore Dataを操作するための多くの便利さを導入しました。

そして今、私の同僚のスコットは、私たちが今年導入する新しい機能強化についてあなたと共有したいことがたくさんあります。

スコット？

ありがとう、マイケル！

今年は、フェッチ要求の怠惰なエンティティ解決から始めて、SwiftUIでコアデータを使用する経験に多くの改善があります。これにより、アプリがビューを構築する前にコアデータスタックを設定するという要件が緩和されます。

また、今年、フェッチリクエストは、ソート記述子と述語の動的設定をピックアップします。

そして、町には、セクション化されたフェッチをサポートする新しい種類のフェッチリクエストがあります。

マイケルが講演で先に言及した地震サンプルアプリを使用して、怠惰なエンティティ解決から始めて、これらのそれぞれを歩きます。

おそらくあなたのアプリには、このようなコードがあります。

このコンテナプロパティは、このタイプのコード、さらにはより広範なアプリをサポートするために本当に必要ではありません。

そのすべてのものは、QuakesProviderタイプから直接必要なものを手に入れます。

いいえ、このプロパティは、モデルがロードされる前に、環境内のビューがエンティティを参照しようとする前に、コアデータスタックが設定されていることを確認するために存在します。

ContentViewが初期化された後に環境ビュー修飾子が呼び出されることをここで参照してください。

今年のSDKに対して展開する場合、このトリックはもう必要ありません。

FetchRequestプロパティラッパーは、フェッチ時に名前でエンティティを怠惰にルックアップし、その時点で環境はコアデータスタックが設定されていることを保証しているので、このプロパティを削除しても安全です...

そして、ただ参照してください...

QuakesProviderは、環境コールで直接コンテナを共有しました。

いくつかの新しいAPIに移ると、FetchRequestは動的設定をサポートするようになりました。

ラップされた値には、リクエストの述語とそのソート記述子を直接変更するための2つの新しいプロパティがあります。これは、慣れているNSSortDescriptorsと、自動的に生成された管理オブジェクトサブクラスでエンティティを取得するときに、より利便性と安全性を提供する新しいSortDescriptor値タイプの両方で表現されます。

そして最後に、ビューとの統合を容易にするために、ラップされた値と同じプロパティセットを持つ構成バインディングがあります。

この新しいAPIの前に、ソートと述語のパラメータがビューの初期化子に渡されるようにビューを設計する必要がありましたが、ツールバーのコントロールを使用してフェッチ要求を設定するなどをサポートするのは本当に困難でした。

この摩擦は、これらの新しい動的構成プロパティによって排除され、地震サンプルアプリにソートとフィルタリングを追加して、それらを使用する方法を紹介ししたいと思います。

最初にソート記述子を見てみましょう。

デフォルトでは、地震アプリは最新性で並べ替えますが、大きさで並べ替えたいので、結果の順序を制御できるメニューを追加します。

タプルの静的配列を追加することから始めます...

私がサポートしたいソート記述子とそれらの名前が含まれています。

彼らが新しいSortDescriptorタイプも使用していることをここで確認してください。

また、現在使用しているソート順を追跡するための状態も少し必要です。

私はすでにこのタイプを作成したので、コンテンツビューのプロパティとして追加します。

次に、リストビューにツールバーメニューを追加します...

これは、選択したソートと、フェッチ要求のソート記述子を更新するonChange修飾子を変更します。

プレビューでは、新しいメニューを見ることができ、それを使って地震をマグニチュードで並べ替えることができます。

すごい！

次に、フィルタリングを追加します。

地震の場所に基づいてフィルタリングしたいと思います。 

最初に必要なのは、検索フィールドのテキストの状態です。

そして、私はバインディングプロパティを作ります...

フェッチ要求を更新する検索フィールド。

それらがあれば、必要なのはUIだけです。

便利に...

Searchableは文字列へのバインディングを取るので、ここでそれをドロップすることができます。

さて、プレビューでは、この新しいフィールドに「サンドイッチ」と入力するだけで、サンドイッチに一致する場所の近くのすべての地震を絞り込むことができます。

そして、それはFetchRequestの動的設定です。

もう1つの一般的に要求される機能は、セクションフェッチフェッチと呼ばれる新しいプロパティラッパータイプとして今年到着するセクションフェッチのサポートです。

このタイプは、FetchRequestと同じ新しい動的構成プロパティをサポートしていますが、NSFetchedResultsControllerのように、セクションを識別するプロパティへのキーパスである追加のパラメータで初期化されます。

しかし、フェッチされた結果コントローラとは異なり、セクションを識別するプロパティは、ハッシュ可能である限り、好きなタイプを持つことができます。

これは、SectionedFetchRequestの追加の汎用パラメータを使用して、型システムでエンコードされます。

最後に、この新しいタイプは2次元の結果タイプをラップします。

SectionedFetchResultsはセクションのコレクションであり、それぞれが結果のコレクションです。

各セクションには、セクション識別子を持つプロパティもあります。

これは本当に簡単に採用できるので、Earthquakesアプリにセクションのフェッチを追加します。

まず、FetchRequest宣言を更新します。

Quakeはすでに1日のプロパティを持っているので、私はそれをセクションキーパスに使用するつもりです。

次に、ボディプロパティを更新する必要があります...

新しいセクションの結果タイプに一致させる。

ここの外側のループはセクションを反復するので、私はここでセクションビューを発行しており、各セクション自体はクエイクのコレクションであるため、この内側のForEachは、以前に結果を反復していたのと同じように、セクションを反復します。

プレビューを見ると、地震は時間ごとに注文され、日ごとに分割されています。

また、SwiftUIは、折りたたむセクションの自動サポートも提供してくれます。

この新しい SectionedFetchRequest タイプは、FetchRequest と同じ動的構成プロパティと、セクション識別子キー パスの追加構成プロパティをサポートしています。

ソートを変更することは実際には安全ではないので、これは非常に重要です。

時間と地震のマグニチュードが完全に相関していないため、セクションが不連続になる可能性があり、これはおそらく最善です。

これを修正するには、ソートをトップに更新する必要があります...

それぞれに、対応するセクション識別子キーパスがあります。

次に、ツールバーの下...

ソート記述子を更新するたびに、セクション識別子キーパスを更新する必要があります。

しかし、ここに重要な部分があります。

リクエストの変更は、結果ゲッターが呼び出されるたびにコミットされるので、ソートとセクションの両方を安全に更新するために...

ローカルにプルした結果を参照して設定を更新する必要があります。

プレビューでは、順序を変更するとセクションも変更されることがわかります。

時間順に並べられた地震と、日ごとに並べられた地震と、大きさ順に並べられた地震を切り替えることができます。

そして、そこには、遅延スタックの初期化、動的設定、セクション化されたフェッチがあり、すべてiOS 15とmacOS Montereyを使用して既存のアプリに簡単に適用できます。

要約すると、Core Dataは、Appleのすべてのプラットフォームでアプリのデータ永続性のニーズを管理するためのワンストップショップです。

新しいパフォーマンスAPIを通じてSwiftで利用可能な新しい並行性機能を活用し、強力なスレッド安全デバッグが組み込まれています。

ストアと属性タイプをSwiftで使用するのをさらに自然にする新しい列挙インターフェイスに加えて、CloudKitの共有とSpotlightの統合があります。

また、動的設定とセクション化されたフェッチを備えたSwiftUIを使用して、データをビューに接続するのがこれまで以上に簡単になりました。

これらのトピックに関連して学ぶべき新しいことがたくさんあります。

「SwiftUIで簡素化し、Swiftの並行性を満たす」コレクションをチェックすることをお勧めします。

そして、それだけです!

皆さんがこれらの新しいAPIで何を構築するかを本当に楽しみにしています。

[明るい音楽]。