10067

こんにちは、私はゲームセンターチームのハリソンです。

あなたのゲームで定期的なリーダーボードを使用することについて学ぶために参加してくれてありがとう。

Game Centerは、プレイヤーが多くのゲームでデータにアクセスするために使用できる便利なアイデンティティを提供します。

開発者として、Game Centerでは、アチーブメント、マルチプレイヤー、リーダーボードなどの機能を簡単に追加できます。

これはコードアロングなので、参加するには初期設定を行う必要があります。

次に、Game Centerのリーダーボードタイプを簡単に要約し、提供されたサンプルゲームについて説明します。

最後に、App Store Connectに定期的なリーダーボードを追加し、サンプルゲームで使用するいくつかの異なる方法を紹介します。

いくつかのセットアップから始めましょう。

始めるために、開発者ポータルでXcode 13と互換性のあるプロジェクトを提供しました。

ビデオを一時停止して今すぐダウンロードすることをお勧めします。

ダウンロードしたら、再開して、初期設定をご案内します。

ダウンロードしたフォルダには、The CoastというXcodeプロジェクトがあります。

さあ、今すぐ開けてください。

Game Centerの機能を使用するようにこのアプリを変更するので、チームに登録する必要があります。

必要に応じて一時停止して、フォローしてください。

まず、プロジェクトナビゲーターからTheCoastプロジェクトファイルを選択します。

次に、ターゲットのリストからTheCoastを選択します。

[署名と機能] ペインで、チームメニューからチームを選択します。

Apple IDまたはチームがメニューにない場合は、まず「アカウントを追加」を選択し、Apple ID情報を入力します。

次に、バンドルIDを一意の識別子に設定します。

続行するには、バンドルIDを変更する必要があります。

プロンプトが表示されたら、[デバイスの登録]をクリックしてプロビジョニングプロファイルを作成します。

登録に成功すると、ステータスの下に警告は表示されません。

選択したバンドルIDが登録されたので、App Store Connectにアプリレコードを追加できます。

App Store Connectの右上隅で、バンドルIDの登録時に使用したチームを選択します。

次に、「マイアプリ」セクションに移動します。

左上隅のプラスボタンをクリックし、新しいアプリを選択します。

iOSのみのアプリで作業するので、プラットフォームとしてiOSを選択してください。

適切な名前、主要言語、SKUを選択してください。

バンドルIDについては、Xcodeに登録したバンドルIDを選択してください。

すべての必須フィールドに入力したら、[作成] を選択してアプリレコードを追加します。

あなたは少し後でApp Store Connectに戻ってきます。

しかし、今、私はリーダーボードの簡単な要約を与えるつもりです。

すべてのリーダーボードでは、プレイヤーは世界中の友人やプレイヤーに対してどれだけうまくランク付けされているかを見ることができます。

私たちのリーダーボードの種類は、主にリーダーボードがアクティブである期間によって異なります。

古典的なリーダーボードは常にアクティブで、終わりはありません。

彼らは、毎週および毎日のランキングだけでなく、オールタイムのランキングを維持しています。

獲得した合計経験ポイントや現在のコイン数など、累積スコアに特に役立ちます。

一方、定期的なリーダーボードは、5分ごとや30日ごとなど、開発者が定義したスケジュールで繰り返される短命のリーダーボードです。

現在アクティブなリーダーボードのオカレンスを取得できます。また、終了時間から最大30日間、プレイヤーが提出した最新のオカレンスを取得することもできます。

定期的なリーダーボードは、毎週日曜日の正午に1時間のチャレンジや毎週新しいリーダーボードなど、定期的なタイミングのイベントに役立ちます。

セッション中に定期的なリーダーボードの特定のユースケースを強調します。

しかし、まず、Xcodeで開いたプロジェクトに戻りましょう。

iOSデバイスまたはシミュレーターで構築して実行します。

これはザ・コーストのタイトル画面です。

今のところ、この画面にはゲームを開始するボタンがあるだけです。

先に進んで「PLAY」をタップします。

ゲームプレイはかなり簡単です:船を見たら、それをタップしてポイントを取得します。

各セッションは60秒続きます。

最後に、再試行するか、タイトル画面に戻るかを選択できます。

右上隅のメニューボタンを選択すると、早めに終了できます。

では、これはどのように実装されていますか?

始めるべき主なクラスをいくつか強調します。

TitleScreenViewControllerはタイトル画面を担当します。

しばらくすると、Game Centerで認証するために使用されます。

今のところ、主にPLAYボタンがタップされたときにGameViewControllerを表示する責任があります。

GameViewControllerはとてもシンプルです。

ビューがロードされると、GameSceneと呼ばれるSpriteKitシーンが表示され、タイトル画面に戻るためのendGameというデリゲートメソッドがあります。

すべてのゲームプレイロジックを管理するGameSceneを見てみましょう。

提示されると、いくつかのSpriteKitノードが設定されます。

1つは、背景画像で作成されたノードです。

これはデバイスの画面サイズに基づいてスケーリングされ、他のすべてのノードが子として追加されます。

もう1つは、現在のスコアを表示する画面の左上に配置されたSKLabelNodeであるscoreLabelです。

最後はCountdownNodeで、プレイヤーに残り時間を示し、時間が終わったらGameSceneに通知します。

これらのノードを追加すると、setupBoatNodeWithActions()メソッドが呼び出されます。

これにより、セッション中にボートスプライトをフェードインおよびフェードアウトする一連のSpriteKitアクションが開始されます。

touchesEndedメソッドは、タップしたときにこれらのボートスプライトを削除し、スコアをインクリメントするためにオーバーライドされます。

カウントダウンの最後に、timeIsUpメソッドでは、すべてのノードがバックグラウンドから削除され、最終スコアのメニューが表示されます。

定期的なリーダーボードを活用して、プレイヤーのコーストの経験を向上させる方法はたくさんありますが、今日は3つに焦点を当てます。

まず、24時間の定期的なリーダーボードを作成して毎日の競争を確立する方法と、Game CenterのデフォルトのリーダーボードUIにリンクする方法を紹介します。

これはおそらく定期的なリーダーボードを追加する最も簡単な方法であり、プレイヤーが他の人に対してどのように積み重なるかを知るための素晴らしい方法です。

毎日のケイデンスは、誰もがトップの座を獲得する新鮮な機会を持つことを保証します。

次に、ゲームプレイ中にライブランキングを表示します。

これは、プレイヤーが彼らがどれだけうまくやっているか、そして彼らがトップの座にどれだけ近づいているかをリアルタイムで見ることができるので、ゲームに多くの興奮を追加します。

最後に、現在および以前の出来事のランクを使用して、プレイヤーが時間の経過とともにどのように変化しているかを示します。

これは、プレイヤーにゲームの進歩感を与える本当に簡単な方法です。

始めましょう。

先ほど、毎日の定期的なリーダーボードを使用すると述べました。

ゲームでリーダーボードを使用する前に、App Store Connectで設定する必要があります。

今すぐSafariでそれを引き上げて、アプリを開いてください。

[機能] タブに移動し、Game Center が選択されていることを確認します。

次に、リーダーボードの横にあるプラスボタンをクリックし、定期的なリーダーボードオプションを選択します。

クラシックリーダーボードとリクリーダーボードの両方に、設定するこれらの6つのフィールドがあります。

リーダーボードの参照名は、App Store Connectで内部的に使用されています。

「DailyHighScore」のような説明的なものを選んでください。

リーダーボードIDは、アプリ内のリーダーボードを参照するために使用されます。

簡単にするために、参照名に使用したのと同じ説明値を使用します。

スコアフォーマットタイプは、Game Center UIでスコアがどのようにフォーマットされるかを決定します。

コーストのスコアは単なる整数ですが、他のゲームは時間やお金を使うかもしれません。

プレイヤーが同じリーダーボードに複数のスコアを提出した場合、スコア提出タイプは、どちらがランク付けされるかを決定します。最高のスコアまたは最新のスコアです。

その日のプレーヤーの最高スコアを記録したいので、コーストに最適です。

ソート順は、プレイヤーのスコアが互いにどのようにランク付けされるかを決定します。

コーストでは、ハイスコアの方が良いので、高から低を選択してください。

オプションで有効なスコアの範囲を定義できます。

その範囲外のスコアは拒否されます。

これは不正行為に対する緩和策として役立ちます。

プレイヤーがその範囲外で得点することを合理的に期待していないので、最小0と最大200を設定するつもりです。

定期的なリーダーボードには、これらの追加の必須フィールドがあります。

開始日時は、リーダーボードが最初に発生した日時をUTCで設定します。

過去のスタートは選択できないので、すぐにリーダーボードを使い始めることができるように、1分のように、近い将来の日付と時刻を選択してください。

期間は、スコアをリーダーボードに投稿できる時間の長さです。

もちろん、これは毎日のリーダーボードの1日です。

Restarts Everyは、リーダーボードの新しい出現が作成される頻度を指定します。

発生が重複しないように、頻度は持続時間以上である必要があります。

海岸は発生間のギャップを必要としないので、これを期間に等しく設定してください。

以下は、これらのフィールドがどのように相互作用して発生を生み出すかを示す図です。

選択した開始日、例えば6月11日午前9時に、オカレンスが作成されます。

設定された期間のため、この発生に1日提出できます。

その発生が期限切れになった直後の6月12日午前9時に、再起動が期間と一致するように設定されているため、新しい発生が作成されます。

このプロセスは無期限に続きます。

最後に設定するのはローカリゼーション情報です。

リーダーボードは、Game Center UIに正しく表示するためにこれが必要です。

少なくとも1つの言語を設定する必要があります。

私は英語のために設定するつもりです。

毎日のリーダーボードの「デイリーハイスコア」など、適切な表示名を選択してください。

また、スコア形式を選択する必要があります。

整数型の場合、ピリオドまたはカンマを数千の区切り文字として使用できます。

あなたの言語に意味のあるものを選んでください。

スコア形式の接尾辞は、ポイントやヒットなど、スコアの単位を指定する方法です。

私は海岸のためにこれを空白のままにするつもりです。

リーダーボードの画像はオプションですが、Game Center UIでゲームの外観をカスタマイズできるため、お勧めです。

プロジェクトのアセットディレクトリには、leaderboardImageという名前の画像があります。

それをアップロードしてください。

リーダーボードを保存したら、Game Centerで認証してゲームで使用できます。

では、Game Center認証を有効にすることから始めましょう。

TitleScreenViewController には、authenticateLocalPlayer() というメソッドがあり、本文はコメントアウトされています。

どうぞ、コメントを外してください。

このコードは、ローカルプレーヤーの認証ハンドラを設定し、開始時にGame Centerのログインフローをトリガーします。

詳細情報が必要な場合は、提供されたドキュメントへのリンクをたどってください。

これで、スコアを提出できます。

先ほど、タッチ終了時にスコアを更新するGameSceneで、touchsEndedと呼ばれる方法を紹介しました。

それに移動します。

submitScoreには2つのメソッドがあります。

1つはクラスメソッドで、もう1つはインスタンスメソッドです。

クラスメソッドに提出すると、現在アクティブなイベントが何であれ、提出が送信されます。

アクティブな発生がない場合にのみ失敗します。

インスタンスメソッドを使用するには、まず現在の発生を表すGKLeaderboardをロードします。

次に、完了ハンドラでスコアを送信すると、その発生がまだアクティブである場合にのみ成功します。

1時間ごとの定期的なリーダーボードを使用して、1時間ごとにユニークなチャレンジを提供するゲームを考えてみましょう。

プレイヤーのデバイスとサーバー間のネットワーク遅延など、1つのチャレンジのスコアが次のチャレンジの発生に漏れることを望まないでしょう。

インスタンスの送信スコアメソッドは、それが起こらないことを保証します。

コーストの毎日のリーダーボードは特定のゲームセッションに結びついていないので、どのような出来事がスコアを受け取るかは関係ありません。

クラスメソッドを使いましょう。

これで、スコアは現在アクティブなリーダーボードの出現に提出されます。

コンテキストを0に設定していることに注意してください。

コンテキストを使用して、ゲーム固有の情報をエンコードし、スコアとともに保存できます。

コーストの場合、スコアは追加のコンテキストを必要としません。

毎日のリーダーボードに提出したので、タイトル画面からGame Center UIのリーダーボードを表示するボタンを追加しましょう。

まず、TitleScreenViewControllerに向かいます。

新しいIBActionメソッドを作成する必要があります。

それをshowLeaderboardVCと呼んでください。

GKGameCenterViewControllerをインスタンス化します。

LeaderboardID、playerScope--私はglobalを使っています--とtimeScopeを渡します。

定期的なリーダーボードの場合、timeScopeはallTimeでなければなりません。

gameCenterDelegateを「self」に設定します。

それから、それを提示してください。

また、UIButtonを作成する必要があります。

私はちょうど私のリーダーボードボタンを呼んでいます。

次に、メインストーリーボードですべてを配線します。

アセットディレクトリで使用するリーダーボードグリフを提供しました。

その画像を含むボタンを追加し、テキストを削除します。

グリフが引き伸ばされないように、アスペクト比の制約を設定します。

次に、PLAYボタンの横に配置します。

Touch Up Insideイベントを新しいメソッドに設定します。

そして、新しいボタンに新しい参照アウトレットを設定します。

次に、アプリを構築して実行して、新しいリーダーボードを試してみてください。

Game Centerにログインするように求められる場合があります。

リーダーボードが機能するには認証されたアカウントが必要なので、今すぐそうしてください。

リーダーボードのグリフをタップすると、Game Center UIのリーダーボードに直接移動します。

まだプレイしていない場合、リーダーボードは空になります。

簡単にプレイして、リーダーボードに戻って新しいスコアを確認してください。

リーダーボードがあり、スコアを提出している今、ゲームプレイ中にライブスコアを追加しましょう。

LeaderboardNodeクラスを見てみましょう。

これはSpriteKitノードで、名前とスコアで構成されるリーダーボードエントリのリストを取り、ランクに応じて表示します。

エントリで初期化し、エントリを変更する必要があるときに更新できます。

GameSceneのメンバーとしてオプションのリーダーボードノードを追加します。

setupInitialGameplayでリーダーボードの位置を初期化します。

そのすぐ下にあるノードを初期化します。

5行で設定し、最初のエントリを空白のままにしています。

バックグラウンドノードに追加して、シーンに表示します。

次に、エントリをロードし、リーダーボードを更新する必要があります。

このためにupdateLeaderboardNode関数を作成します。

まず、DailyHighScoreリーダーボードをロードします。

完了ハンドラで、リーダーボードを使用して、グローバルリーダーボードから上位5つのエントリをロードします。

これは定期的なリーダーボードであるため、タイムスコープは常にオールタイムになります。

これらがロードされたら、エントリがnilでない場合、GameKitエントリをLeaderboardNodeが使用するLeaderboardEntry構造体に変換する必要があります。

次に、LeaderboardNodeのupdateEntriesメソッドを呼び出します。

最後のステップは、ゲームプレイ中にLeaderboardNodeを更新することです。

このゲームでは、プレイヤーのスコアは頻繁に変化しており、LeaderboardNodeを同期させる必要があります。

これを行うには、submitScoreの完了ハンドラでupdateLeaderboardNode()を呼び出します。

プレイヤーが得点する前にリーダーボードを正しく表示するには、ノードが作成された直後に呼び出すこともできます。

今、私は再び構築して実行するつもりです。

私と一緒にゲームをしている友達が何人かいます。

スコアが上がるにつれて、リーダーボードが継続的に更新されるのを見ることができます。

私が行っている最後の変更は、プレイヤーの現在のデイリーランクが以前のデイリーランクとどのように異なるかを示すことです。

時間が終わったら、これをGameMenuNodeに入れます。

これを実装するために一連のネストされた完了ハンドラを使用できますが、GameKitの新しい非同期メソッドを使用すると、このコードがより読みやすくなります。

新しい非同期メソッドを作成します。

addRankToGameMenu()と呼びましょう。

GameKitの非同期メソッドはスローできるので、エラーをキャッチしたいと思うでしょう。

私はちょうどそれらを記録するつもりです。

デイリーリーダーボードをロードし、正常に返されたことを確認します。

そのリーダーボードインスタンスでは、2つのことを行います。

まず、async letでエントリを非同期にロードします。

ローカルプレーヤーのスコアしか気にしていないので、forパラメータを空のままにします。

次に、リーダーボードの以前の出現を非同期にロードし、それを使用してエントリをロードします。

この情報を表示するには、gameMenuNodeにメソッドを書く必要があります。

それをaddRankNodeと呼びましょう。

現在と以前のランクで合格する。

あなたは彼らが準備ができているのを待つためにtry awaitを使用する必要があります。

先に進んで、timeIsUpから切り離しブロックで新しい非同期メソッドを呼び出してください。

次に、GameMenuNodeに向かい、addRankNodeを実装します。

addRankNodeは、以前のランクと現在のランクの違いを使用して、いくつかの簡単なテキストを生成します。

両方のランクがゼロであれば、あなたはただ戻ることができます。

ラベルノードにテキストを表示します。

私はそれを作成するためにヘルパー関数を使用しています。

適切に配置してください。

水平方向に中央に、垂直に中央の少し下に追加します。

次に、それを背景に追加します。

では、結果を見てみましょう。

私は昨日プレイしたので、以前のランクが利用可能です。

ご覧のとおり、私のランクは今日少し下がっており、プレーし続ける正当な理由です。

このセッションでは、App Store Connectで定期的なリーダーボードを設定する方法と、スコアを送信し、Game Center独自のリーダーボードUIにリンクし、リーダーボードAPIを使用してライブグローバルランクと以前のランクを表示することで、ゲームでそれを使用する方法を紹介しました。

定期的なリーダーボードの詳細については、昨年のWWDCの「ゲームセンターをタップ：リーダーボード、実績、マルチプレイヤー」を参照してください。

そして、今年のWWDCで「ゲームセンターの新機能」を必ずチェックしてください。

[パーカッシブミュージック]。