10212

ようこそ！私の名前はカッパーです。

私はAppleのパフォーマンスツールエンジニアで、今日はSergioと一緒に、Instruments 13で利用可能な新しいHTTPトラフィックインストゥルメントについて話します。

ネットワークテンプレートに含まれるこのインストゥルメントでは、Apple Networkingスタックを介してアプリケーションからのHTTPトラフィックを検査できます。

このアプローチには複数の利点があります。

それはすべてのAppleデバイスで動作します。

新しいHTTP/3プロトコルまたはVPN経由で送信されたトラフィックでも、URLローディングシステムを通過するトラフィック全体が公開されます。

システム統合のため、トラフィックをその上で実行されているプロセスに帰属させ、Apple Networkingフレームワークをインストルメントしているため、ディスク上のキャッシュやネットワークエラーにヒットする要求を明らかにすることさえできます。

これらはすべて、URLSessionsやURLSessionTasksなど、あなたがよく知っている高レベルのAPI概念のコンテキストで公開されています。

このツールは、APIの使用がネットワーク要求の寿命にどのように変換されるかを理解するのに役立ちます。

このハンズオンセッションでは、まず、Instruments UIが使用しているAPIの概念をどのように反映しているかを把握します。

この簡単な紹介の後、このツールを使用してパフォーマンスと正確性の両方の問題を検出する方法を説明する4つのデモに移行します。

そして、あなたのアプリが完璧に動作しているように見えても、そこから来るトラフィックを監査することによって、あなたが考えていることをすることを確認する方法を学びます。

ネットワーキングAPIがインスツルメンツの視覚化にどのようにマッピングするかから始めましょう。

これは、ネットワークテンプレートを使用してシステムトラフィックを記録したときに、HTTPトラフィックトレースがInstrumentsに表示される方法です。

ナビゲーションはトラック階層を中心に構成されており、最初に詳しく説明します。

トップレベルにあるHTTPトラフィックインストゥルメントは、任意の時点でトレースで実行されていたURLSessionタスクの数の概要を示し、アプリの存続期間中にHTTPトラフィックアクティビティが増加したスポットを検出するのに理想的です。

次の階層レベルは、プロセスごとの活動の内訳を示しています。

デバッグ可能なすべてのプロセスからのトラフィックに加えて、それらによって開始されたバックグラウンドトラフィックを検査することができます。

各プロセスの下には、それで使用されるすべてのURLSessionsが含まれています。

これらは、コードで作成したURLSessionオブジェクトに対応しています。

このレベルのグラフでは、すべての個々のタスク間隔を検査できます。

セッションオブジェクトとビジュアライゼーションの間のより良いマッピングを得るには、セッションインスタンスにsessionDescriptionプロパティを設定することで、コードでそれらに名前を付けることができます。

最後のレベルでは、トラフィックは要求されたドメインによって分類されます。

このレベルのグラフは、タスクとその状態を構成する個々のトランザクションを含む、タスクに関する詳細を示しています。

タスクとトランザクションが何であるかをよりよく理解するために、例を分析しましょう。

選択したドメインからデータをロードするタスクをいくつか紹介します。

タスクの構造を分析するために、そのうちの1つに焦点を当てましょう。

この単一のタスク間隔には多くの情報があります。

インストゥルメントの視覚化が使用されているAPIにどのようにマッピングされるかを理解するために、これをより抽象的な方法で表現することができます。

トップレベルでは、タスクオブジェクトがあります。

タスクは1つ以上のトランザクションで構成されています。

トランザクションは、HTTPリクエストと対応するレスポンスのペアです。

タスクレベルは、コードがURLローディングシステムのAPIとどのように相互作用するかの表現です。

タスクを作成して再開を呼び出すと、タスク間隔が開始されます。

そして、完了ブロックが呼び出される直前に終了します。

各タスクには、instrumentsの間隔にラベルを付けるために使用されるtaskDescriptionプロパティを使用してセマンティック名を付けることができます。

また、タスク識別子をタスクラベルの一部として表示します。

タスクを他のデータと相互参照するために使用できます。

タスクがエラーで終了した場合、その説明はデバッグを容易にするためにインターバルラベルに表示されます。

前に述べたように、タスクは複数のトランザクションで作成できます。

今からこれらについて話しましょう。

ここでは、apple.comのスタートページを読み込むタスクがあります。

ただし、このURLは正規のURLではありません。

タスクはapple.comを要求しますが、優先ドメインはwww.apple.comです。

このタスクを作成すると、URLローディングシステムは最初にapple.comへのリクエストを作成します。

その後まもなく、サーバーからリダイレクト応答を受け取り、優先URLは実際にはwww.apple.comであると述べています。

デフォルトでは、リダイレクトに従うため、301応答を返す代わりに、URLロードシステムは新しいトランザクションを作成し、優先URLをロードします。

この2番目の成功したトランザクションからの応答は、タスクに返されるものです。

前述のように、トランザクションはHTTPリクエストとレスポンスの組み合わせを表します。

URLSessionがタスクを処理するために内部で行うことと一致し、要求されたURL、転送されたデータに関する情報など、HTTPレイヤーのすべての情報が含まれています。

タスクと同様に、トランザクションラベルはトランザクションの概要を示します。

主に、要求と応答に関する情報を取得します。

トラック階層は要求されたドメインを指示しますが、ラベル自体でパスとクエリを見つけることができます。

それに加えて、インターバルラベルには、HTTPバージョン、HTTPメソッド、およびリクエストがAuthorizationまたはCookieヘッダーを送信したかどうかが表示されます。

これらは、認証フローを一目で理解するのにしばしば役立ちます。

応答については、ステータスコード、応答にクッキーが含まれているかどうか、および応答のコンテンツタイプを取得します。

要求と応答にかかった時間、およびトランザクションの一部である他の作業に関するより詳細なタイミング情報は、トランザクション状態によってキャプチャされます。

包含タスクの文脈でそれらを分析しましょう。

トランザクションの開始は、URLローディングシステムがこの要求を行うためのトランザクションを作成する時点です。

まず、すでに有効なキャッシュされた応答があるかどうかを確認します。

そうでない場合は、接続でリクエストをスケジュールしようとします。

次に、トランザクションはブロックされた状態で少し待って、利用可能な接続を待たなければならないかもしれません。

送信要求の状態は、トランザクションが最終的に接続によって処理されたときに開始されます。

リクエストの最後のバイトをネットワークに送信すると終了します。

次に、トランザクションはアイドル状態になり、応答待ち状態になり、続いて応答を受信し、サーバーから受信した最初のバイトから最後のバイトまでのスパンを追跡します。

URLローディングシステムがこれが応答に成功したかどうかを判断すると、最後のバイトを受信した直後にトランザクション全体が完了します。

実際には、GETリクエストのキャッシュルックアップと送信状態は通常はるかに短いため、このように見える可能性が高くなります。

実用的な例をお見せするために、同僚のセルジオに手渡したいと思います。

彼は、HTTPインストゥルメントがパフォーマンスと正確性の問題を修正するのにどのように役立つかを説明するために、最近開発し始めたアプリを案内します。

ありがとう、カスパー。みなさん、こんにちは。

私の名前はセルジオ・ロペスで、犬愛好家のためのこのアプリに取り組んできました。

ソーシャルメディアプラットフォームのように考えてください、しかし犬の写真のために...

だけ！

人々は犬の画像を投稿することができ、あなたは最新のアップロードのストリームを取得します!

そのため、アプリを開くと、いくつかの新しい犬の画像が読み込まれますが、読み込みを完了するのにかなりの時間がかかることに気づきました。

この状況を改善するために、新しいHTTPトラフィック機器でアプリをプロファイリングしましょう。

「製品」メニューで、「プロファイル」オプションを選択して、Instrumentsでアプリをプロファイルします。

これは、すべての最適化をオンにして、ユーザーのために実行されるようにアプリをプロファイリングしていることを確認するために、リリース構成で私のアプリを構築します。

ビルドが完了すると、Instrumentsは自動的に起動します。

起動時に、Instrumentsの標準テンプレートセレクタが表示されます。

私たちの場合、左下のネットワークテンプレートを選択したいと思います。これは、私のアプリが行う一般的なネットワーク接続に関する詳細情報を提供しますが、新しいHTTPトレース機能も含まれています。

トラックエリアには、各楽器に1つずつ2つのトラックが含まれています。

下のトラックは既存のネットワーク接続インストゥルメントで、上のトラックは新しいHTTPトラフィックインストゥルメントです。

今日はこの新しい楽器に焦点を当てます。

私が今する必要があるのは「レコード」を押すことだけです。

その後、楽器は私のアプリを起動し、録音を開始します。

このツールを使用する前に、ネットワークトラフィックをキャプチャすることの意味を理解していることを確認する必要があります。

特にすべてのプロセスを記録する場合、それは非常に強力です。

キャプチャされたデータには、送信されるすべてのものが含まれます。これは、ユーザーの資格情報まで、個人情報や機密情報である可能性があります。

したがって、結果のトレースファイルには細心の注意を払う必要があります。

では、これを確認させてください。

アプリが起動し、画像の読み込みが遅かった。

今から録音を停止します。

Optionキーを押しながらクリックして、HTTPトラフィックをカバーする領域をドラッグして、記録したデータにズームインしましょう。

左上の「HTTPトラフィック」トラックの開示インジケータをクリックすると、Kacperが以前に説明した完全なトラック階層が表示されます。

また、すべての間隔を表示するためにトラックの高さを増やします。

上部には、アプリの「最新」セクションに表示される画像のリストをサーバーに照会する最初のタスクがあります。

このタスクが完了したら、受け取ったリスト上のすべての画像のサムネイルをロードする新しいタスクを作成します。

画像のリストを取得するのにかかった時間枠をカバーする領域をドラッグし、その後、個々の画像を取得するための多くのリクエストが続きます。

この領域をドラッグすると、選択した時間範囲の期間を示すツールチップが表示されます。

全体として、初期画面の読み込みを完了するのに7秒以上かかりました。

最初のいくつかの画像はかなり速く読み込まれます。

しかし、下にスクロールすると、紫色のブロック状態の増加が指摘されているように、後で開始されたタスクは完了までに時間がかかりました。

混雑の問題のように思えますが、並行してリクエストが多すぎます。

後のタスクの1つを調査しましょう。

タスクにカーソルを合わせると、ツールチップはタスクの期間と、ホバーしている子間隔を示します。

このタスクは、ほとんどの場合ブロックされました。

ブロックされた理由を理解するために、トラック表示を「接続によるHTTPトランザクション」ビューに切り替えましょう。

左側のトラックサイドバーのドメイン名の下に、クリックしてトラック表示を切り替えることができる下向き矢印があります。

現在、私たちは「タスク」を描いています。

「接続によるHTTPトランザクション」の表示に切り替えましょう。

このビューはトランザクションのみを表示し、タスクごとにグループ化するのではなく、スケジュールされた接続を確認できるようになりました。

トランザクションは、使用した接続によってグループ化されます。

全体として、これらのトランザクションを処理するために利用可能な6つの接続がありました。

接続1で発行されたトランザクションを分析し、サムネイルの読み込みトランザクションのいくつかをさらに調査しましょう。

トップダウンから、各トランザクションが完了するまでに時間がかかることが顕著です。

連続するトランザクションごとに紫色のブロック状態が増加しています。

実際、ここにはかなり明確な階段のパターンがあります。

同じ接続上の以前のトランザクションが終了するまで、各トランザクションはブロックされます。

そうして初めて、リクエストを送信できます。

このパターンは、後続のトランザクションごとに繰り返されます。

これは「ヘッドオブラインブロッキング」と呼ばれ、HTTP/1を使用する際の問題の1つです。

イライラする部分は、これらの取引がほとんどの時間何もしていないことです。

代わりに、彼らはほとんどの時間をブロックしたり、サーバーからの応答を待って過ごします。

同じ接続で以前のトランザクションの応答を待っている間に、次のトランザクションの別のリクエストを送信できますが、HTTP/1ではサポートされていません。

ヘッドオブラインブロッキングはHTTP/1の主な制限の1つであり、HTTP/2の主な改善点の1つは、同じサーバーへの複数の要求を単一の接続に多重化することで、その影響を回避することです。

HTTP/2では、最初のリクエストが応答を待っている間に、実際に2番目のリクエストの送信を開始できます。

あなたのアプリはそれをサポートするために何もする必要はありません。

すべてのAppleプラットフォームはHTTP/2をサポートしており、iOS 15とmacOS Monterey以降、HTTP/3もサポートされています。

クライアントは、サーバーがサポートする最新のHTTPバージョンを選択します。

HTTP/1とHTTP/2の違い、およびHTTP/3が提供する追加の利点について詳しく知りたい場合は、「HTTP/3とQUICでネットワーキングを加速する」セッションをご覧ください。

私はこのトレースを取り、サーバーの人々に見せ、HTTP / 2を本当にサポートする必要があることを彼らに納得させることができました。

では、新しいサーバーの機能強化で私のアプリを実行しましょう。

うわー、これはすでに速く感じます!

これをインスツルメンツで確認しましょう。

これは、HTTP/2のサーバーサポートをオンにした後に記録したトレースです。

ドメイン固有のトラックでは、サムネイルの読み込みタスクが長時間ブロックされていないようです。

それはいいね！

もう一度「接続によるHTTPトランザクション」ビューに切り替えましょう。

私たちが最初に気づくのは、接続が1つしかないということです。

これは、同時リクエストを送信するために複数の接続が不要になったためです。つまり、接続設定コストを一度支払うだけで済みます。

個々のサムネイルローディングトランザクションに焦点を当てると、基本的に「ブロックされた」状態で時間を費やさないことがわかります。

実際、時間は非常に小さいので、このズームレベルでは見えません。

最終的に、すべてのトランザクションはリクエストの送信を完了し、応答を待ちます。

下にスクロールすると、応答が同時に進んでいることがわかります。

全体として、すべてのリクエストは3秒以内に完了します。

これは以前の2倍の速さです。

サーバーの人々と話し、HTTP / 1.1からHTTP / 2に切り替えたので、私たちのイメージははるかに速く読み込まれています。

アプリを再起動して、他に何ができるかをお見せしましょう。

画像をタップすると、アプリはフル解像度の画像をロードし、この写真が私からどのくらい離れているかを示します。

右上にはハートのアイコンもあり、その特定の写真をお気に入りにすることができます。

これを行うには、アカウントが必要です。

私は人々がアプリを使用してアカウントなしで写真を閲覧することを許可しますが、お気に入りの画像を保存し、デバイス間で同期し、新しい写真をアップロードするには、アカウントが必要です。

では、ここにログインさせてください。

すごい。別の写真をお気に入りにさせてください。

ああ、この犬はかわいく見える！お気に入りに追加させてください。 

待って、やっただけなのに、なぜもう一度ログインしなければならないの？

これは正しくありません。

私のアプリは私のログインを覚えているはずです。

これは以前はうまくいきました。

再度ログインしたくないので、ログイン画面を消去します。

私は以前、問題を再現した後、トレースファイルを記録しました。

録音を分析するために楽器で開けさせてください。

左側には、初めてお気に入りのボタンを押したときに対応するタスクがあります。

その右側には、最新のタブに戻った後に発行されたタスクがあり、画像のストリームが更新されました。

次に、別の犬の写真をタップした後、フル解像度の画像を読み込むタスクがあります。

そして右端には、お気に入りボタンを2回目にタップしたときに対応するタスクがあります。

最初のタスク間隔には、実際には2つのトランザクションが含まれています。

最初の取引は401ステータスコードを受け取りました。

ログインしていなかったので、これは予想されていました。

トランザクションは、これがHTTPレベルで成功していないことを示すためにオレンジ色で描画されます。

次に、タスクに大きな空の領域があり、ユーザー名とパスワードの入力に費やした時間を表します。

これらの資格情報の入力が完了したらすぐに、トランザクションを再試行します。

間隔の緑色と201ステータスコードは、今回成功したことを示しています。

認証チャレンジ、パスワードの入力、トランザクションの再試行のこの相互作用は、URLローディングシステムが処理する別のケースであるため、これら2つのトランザクションは同じタスクオブジェクトに属します。

ズームアウトすると、右側の画像をお気に入りにしようとする2回目の試みがあります。

ログイン画面を閉じるとタスクがキャンセルされ、ラベルにも表示されるため、タスクオブジェクトは灰色で表示されます。

再びサーバーから401応答を受け取ったので、トランザクション間隔はオレンジ色で表示されます。

このタスクは、別の犬の写真を好きになろうとした後に発生し、2回目のログインを求められるようになりました。

私たちは、ユーザーが最初に資格情報を送信する非常に基本的なログインシステムを使用しますが、サーバーがユーザーの資格情報を確認すると、次の要求で資格情報を提供する必要がないように、ユーザーを識別するクッキーを設定します。

だから、私はこのタスクが適切なクッキーを送信することを期待していたでしょう。

それが起こったかどうかを判断しましょう。

Kacperが先に説明したように、このトランザクションがCookieヘッダーを送信した場合、HTTPメソッドの横に小さなCookieアイコンがあるはずです。

しかし、ここにはそのようなアイコンはありません。つまり、クッキーは送信されませんでした。

だから、その部分は機能していません。

問題は、サーバーがクッキーを提供しなかったのか、それともクライアントがクッキーを受け取ったにもかかわらず、クッキーを送信していないのかということです。

調べるには、以前のトランザクションを調査し、サーバーからクッキーを受け取ったかどうかを確認する必要があります。

これが前のトランザクションで、最初のログインリクエストから成功したトランザクションです。

これには、トランザクションラベルの応答部分にクッキーアイコンが表示されているため、サーバーはクッキーを送信しました。

それは面白いですね。

では、なぜ次の取引でクッキーを送信しなかったのですか?

このトランザクションに関する詳細情報を入手し、クッキーを詳細に調査するには、下部の詳細ビューの「トランザクション」リストに切り替えます。

タイムカーソルがトラックビューの内側に配置されるため、トランザクションはすでにここで選択されています。

右下の拡張詳細ビューには、現在選択されているトランザクションのすべての要求ヘッダーと応答ヘッダーが表示されます。

そして、これが私たちが期待するSet-Cookieヘッダーです。

一見すると、このクッキーは大丈夫そうです。

しかし、ああ、待って、有効期限が見えますか？

2020年3月です。それは過去のことだ！

そのため、サーバーはクッキーを送信しましたが、期限切れのクッキーです。

期限切れのクッキーが好きな人はいない!

これにより、まだ有効なクッキーのみを送信するため、URLSessionはクッキーを送信しません。

これはサーバー側のバグです。

トレースファイルをサーバーの担当者に送信して、問題を調査して解決してもらうことができます。

クッキーの問題を修正したので、ログインを求められることなく、さらに数枚の写真をお気に入りにすることができます。

「最新」タブに加えて、「お気に入り」タブもあり、ユーザーがお気に入りにしたすべての犬の画像のリストを表示します。

そのタブに切り替えましょう。

素晴らしい、ここには昨日追加したお気に入りがいくつかありますが、何らかの理由で、私の最近のお気に入りは表示されません。

もう一度やってみましょう。

お風呂を楽しんでいるように見えるこの犬を選んで、私に好きにさせましょう。

私のお気に入りに戻って、それが表示されるかどうか確認しましょう。

うーん、まだそこにはありません。

もう一度インスツルメンツを使って、何が起こっているのかを把握しましょう。

私はすでにこれのためのトレースファイルを準備しました。

トラックビューでお気に入りのリストを読み込むタスクを見つけることを期待していますが、一見すると表示されません。

サーバードメインのトラックを選択して、そのドメインに発行されたリクエストのみを表示させてください。

次に、このドメインのすべてのタスクのリストを含む下部の詳細ビューに移動できます。

ここにはかなりの数のリクエストがあります。

左下の詳細フィルターを使用して、「お気に入り」に関連するすべてのリクエストを検索して、リクエストを行ったかどうかを確認できます。

フィルタリングすると、結果は、ここにお気に入りのリストをロードするためにいくつかのリクエストを送信したことを示しています。

トラックビューに集中しましょう。

カーソルは、詳細ビューで選択したタスクの開始時に配置されたので、上記のトラックビューでかなり簡単に見つけることができます。

ズームインして再確認しましょう。

だから、最初のアプリの起動時にお気に入りのリストを読み込んだのはこれが初めてでした。

これで大丈夫です。

ここで、私は新しい画像をお気に入りにし、その後、私たちは再びお気に入りをロードしました。

さて、ここにはタスクの間隔がありますが、とても短いです。

ええ、このGETリクエストは数ミリ秒しかかかりませんでした。

それはサーバーの応答を得るには速すぎます。

詳細については、もう一度「接続によるHTTPトランザクション」ビューに切り替えましょう。

最初に気付いたのは、このトランザクションは接続ではなく、「ローカルキャッシュ」で実行されるということです。

これは、リクエストがネットワーク上で送信されたのではなく、ローカルキャッシュからロードされたことを示しています。

これは、トランザクションがサーバーを待たなかったため、「応答待ち」状態がない理由も説明しています。

それが問題です。リクエストはキャッシュされているため、実際にサーバーに尋ねることはなく、常にキャッシュされた応答を取り戻します。

これを修正する1つの方法は、この応答を決してキャッシュしないために、キャッシュ制御ヘッダーを設定するようにサーバーに指示することです。

私たちが望むのは、ユーザーがお気に入りタブに移動し、新しい画像が追加されるたびに画像をリロードすることです。

私たちが望まないのは、そのような変更がなければ、画像のリスト全体を読み込むことです。

良いトレードオフは、サーバーに「ねえ、何か変わったことはありますか?」と尋ねることができればです。

もしそうなら、私に知らせてください。

これは実際には、リクエストにキャッシュポリシーを設定することでできることです。

コードを更新するには、タスクビューに戻り、問題のタスクを選択します。

ここで実行された各URLSessionタスクについて...

タスクで「再開」が呼び出されたバックトレースを右側に表示します。

メソッド同期、ImageCollectionタイプで再開されました。

ここで変更を加えるために、Xcodeでこれを開きましょう。

ここで、私はURLRequestを持っています、そして今、私はキャッシュポリシーを設定したいです。

必要なキャッシュポリシーはreloadRevalidatingCacheDataです。つまり、ローカルキャッシュを無視し、キャッシュがまだ有効かどうかを確認するためにサーバーに要求します。

その場合、サーバーは304応答コードを送信し、ローカルキャッシュの使用を知らせます。

そうでない場合は、新しいデータが返送されます。

試してみましょう。 

だから、これらは私の現在のお気に入りの画像であり、お風呂に入る犬が追加されました。

もう1つ追加しましょう。

では、「お気に入り」タブをチェックしてみましょう。

先ほどお気に入りにした画像が正しく表示されます。

OK、いいね！それも今修正されています。

同僚のKacperに戻って、アプリと依存関係が期待どおりに動作するかどうかを確認することをカバーしています。

Sergioが前に示したように、ログインせずに「お気に入り」タブをクリックすると、ログインビューが表示されます。

ログイン体験をシームレスにするために、すでにAppleでサインインを追加しました。

しかし、当社はいくつかのペットをテーマにしたアプリを持っており、別のチームは、ユーザーがアプリケーション間でアカウントを再利用できるように、共有ログインSDKに取り組んでいます。

このSDKは現在開発中であり、他のチームは、従来のログイン画面を置き換えることができるかどうかを尋ねました。

ペットと呼ばれるSDKバイナリを手に入れました。これは、すべてのプラットフォームで使用できるように、xcframeworkとして配布されています。

Xcodeプロジェクトに統合するのは、埋め込みフレームワークセクションにドラッグアンドドロップするのと同じくらい簡単です。

さて、残っているのは、既存のビューにボタンを追加することだけです。

Log-inViewのソースコードに移動します。

まずフレームワークをインポートしてから、Appleでサインインのすぐ下にあるSwiftUI VStackにボタンを追加します。

Swift UIプレビューをリフレッシュしましょう。

ここにあります。

「ペットでサインイン」ボタンがプレビューに表示され、まさに私が望む場所でした。

それは確かに、本当に簡単な統合でした。

この新しいログイン方法がどれだけ速くなるか知りたいです。

そして、これを測定するために、製品プロファイルアクションを使用してインスツルメンツでアプリケーションをプロファイリングします。

ネットワークテンプレートを選択しています。

そして、ツールバーの「録画」ボタンをクリックしてアプリを起動します。

私のアプリが起動しました。

ログインビューに切り替えることができます。

機器は、その間に発生するすべてのネットワークトラフィックを表示しています。

私はそれを拡張して、アプリのURLセッションを検査します。

ここにあります。

でも待って。

メインアプリのURLSessionだけがここにあることを期待していますが、統合したばかりのPetsフレームワークは、ログインボタンをクリックすることなく、独自のセッションからリクエストをしているようです。

それは予想外です。

今すぐ録音を停止して、さらに調査しましょう。

オプションをクリックしてドラッグして、いくつかの最初のリクエストにズームインします。

いくつかの分析エンドポイントには多くのリクエストがあり、詳細を取得するには、この「ペットサインオンネットワーク」セッションをクリックして、詳細ビューにそれらをすべて一覧表示することができます。

それらはすべてPOSTリクエストであり、1つをクリックすると、リクエストがコードのどの部分から発信されたかを示す右側のバックトレースが表示されます。

だから、その要求は予想通り、ペットによって呼び出されたCFNetworkを通過しているようです。

しかし、より深くナビゲートすると、CoreLocationが関与しているように見えます。

特に私はそれをトリガーするためのアクションを実行しなかったので、それは本当に疑わしいです。

私の場所がサーバーに送り返されているのだろうか、それがCoreLocationとCFNetworkが同じバックトレースにある理由です。

これらのタスクの対応するHTTPトランザクションを検査することで、それを検証します。

これを行うには、詳細をタスクのリストからトランザクションのリストに切り替えます。

そして、そのうちの1つを選択してください。

右下の拡張された詳細では、この要求にかなり標準的なヘッダーが含まれていることが明らかで、心配する必要はありません。

しかし、待って、リクエストボディを見てください。

それは私の位置座標を含み、それは本当に悪いです。

この情報を送信すると、ユーザーのプライバシーが侵害されます。

私たちは、彼らの同意と正当な理由なしに彼らの場所を集めたくありません。

これまでのところ、私たちのアプリは、ユーザーエクスペリエンスをより良くする正当な目的のためにのみこの許可を要求しています。

現時点では、このSDKの統合についてはこれ以上進みません。

代わりに、他のチームにバグレポートを提出して、私が検出したこの容認できない行動について知らせます。

また、このInstrumentsトレースを使用して、バグレポートに必要な情報を生成することもできます。

まず私のデスクトップに保存しましょう。

私はそれを「PrivacyViolation」と名付け、「保存」を押します。

Instrumentsにバンドルされているコマンドラインツールであるxctraceは、このトレースをHTTPトラフィックに関する情報交換の業界標準であるHTTPアーカイブ形式にエクスポートするために使用できます。

これを行うには、トレースの入力とHARエクスポートフラグを使用して、xctraceエクスポートコマンドを実行するだけです。

今それを実行しましょう。

このコマンドは、バグレポートに添付できるファイルを生成します。

それを受け取った人は、機器がマシンにインストールされていなくても、HARをサポートするツールで記録された情報を検査することができます。

HAR自体はJSONベースの形式であるため、テキストエディタで開いたり、スクリプトを使用して簡単に処理することもできます。

また、URLSessionsやバックトレースなどの機器固有の詳細は含まれていませんが、他のチームがこの問題を調査するには十分なはずです。

そして、HTTPトラフィックインストゥルメントを使用して、アプリケーションからのトラフィックのソースとコンテンツを診断し、実行時にアプリが何をするかを制御できることを確認する方法です。

新しいHTTPトラフィックインストゥルメントの使用に慣れたので、今日お見せしたように、問題を検出するためにアプリをターゲットにしてください。

デバッグを容易にし、コンテキストを増やすには、URLSessionとタスクオブジェクトに名前を付けてください。

常に最新のネットワークプロトコルの採用を目指してください。

また、アプリのパフォーマンスや正確性の問題が見つからない場合でも、不要なトラフィックを取り除くために送信するデータの量を確認してください。

今日はご覧いただきありがとうございます。アプリのHTTPトラフィックを追跡して楽しい時間を過ごせることを願っています。

[明るい音楽]。