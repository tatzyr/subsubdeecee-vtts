10207

♪ベース音楽の演奏♪

♪

ウィル・アダリオ・ターナー:こんにちは、「XCTestで予想される失敗を受け入れる」へようこそ。

私の名前はウィルです。このセッションでは、プロジェクトのテストを実行するときに得られるデータを改善する方法について説明します。

まず、そもそもなぜコードをテストするのかを考えてみましょう。

もちろん、高いレベルでは、製品の品質を確保する方法です。

しかし、より具体的には、出荷前にバグを発見するためであり、その後ではないと思います。

今、テストは投資です。

テストを作成、実行、維持するにはリソースが必要です。

他の投資と同様に、コストを最小限に抑えながらリターンを最大化したいと考えています。

このセッションでは、メンテナンスコストを削減するためのツールに焦点を当てます。

メンテナンスでは、主にテストスイートで発生した障害の処理方法について言及しています。

合格したテストが失敗し始めると、それは貴重な新しい情報です。

これは、製品の欠陥、テスト自体の問題、または依存関係の1つ、つまり製品の上にあるすべてのフレームワークとサブシステムの問題のいずれかを示します。

問題の種類に関係なく、その障害が登録されると、同じ障害のその後の報告は、すでに持っている情報を表すため、価値が大幅に低下します。

理想的には、新しい障害はトリアージされ、迅速に修正されます。

しかし、あなたのチームはすぐに問題を解決できないかもしれません。つまり、失敗はすぐに貴重な新しい情報から騒々しい気晴らしになります。

すぐに解決できないテストの既知の失敗を考えると、ノイズを管理するためのツールは何ですか?

思い浮かぶかもしれない2つのアプローチは、無効化とスキップです。

これらのトレードオフを検討し、最高のツールとこのセッションのトピックであるXCTestのExpectedFailures APIについて話しましょう。

Xcodeでは、テストプランまたはスキームでテストを無効にすることができます。

これは既知のテストの失敗に使用できますが、1つの利点は、テストコードが引き続きコンパイルされることです。

ただし、コードが実行されないため、テストレポートには表示されません。

この可視性の低下により、解決が必要な問題として追跡することが難しくなります。

この機能（有効または無効にするテストを選択する機能）が本当に輝いているのは、特定の目的のためにテストのコレクションをキュレーションするためのものです。

しかし、既知の障害を処理する最善の方法であることはめったにありません。

XCTSkipは、失敗したテストを管理する別の方法です。

このアプローチでは、コードはテストで構築され続けるだけでなく、XCTSkipが呼び出されるまで実行されます。

これは、テストレポートに含まれており、問題の可視性がはるかに向上することを意味します。

ただし、すべてのテストが実行されるわけではないため、新しい問題や既存の問題の変更という形で潜在的に有用な情報を失うことになります。

XCTSkipは、特定のOSバージョンやデバイスタイプを要求するなど、テストの構成ベースの制限を管理するための優れたツールです。

この例では、iPadで実行されていない場合、テストはスキップされます。

これにより、既知の障害を管理するために特別に設計されたXCTestの一連の機能であるXCTExpectFailureに導きます。

Swiftでは、さまざまなユースケースに対して多くのオーバーロードがあり、Objective-Cはいくつかの異なる機能で同じ機能を提供します。

このAPIでは、テストは正常に実行されますが、結果は次のように変更されます。テストの失敗は、予想される失敗として報告されます。

もちろん、他のテストが失敗しない限り、そのテストを含むテストスイートの失敗は合格として報告されます。

これにより、障害によって発生するノイズが排除され、テストに他の問題があるかどうかを確認しやすくなります。

もちろん、ノイズを抑制しても根本的な問題は解決しません。

だから、あなたがそれを追跡するのを助けるために、APIは失敗の理由を取ります。

この文字列はコードに問題を文書化し、問題追跡システムのURLを埋め込むこともできます。

XcodeのテストレポートUIは、通常の失敗やスキップされたテストと同じように、予想される失敗を示します。

ホバーを合わせると、失敗の理由にURLが含まれている場合、リンクにジャンプできる問題追跡ボタンが表示されます。

それでは、これがどのように機能するか見てみましょう!

ここに私のVendorAccountクラスのいくつかの単体テストを含む簡単なプロジェクトがあります。

私はテストを実行し、それらが終了すると、一方が失敗し、もう一方が合格していることがわかります。

テストごとに1つずつ、3つのテスト結果アイコンを見ることができます。

失敗したテストの赤いXと合格テストの緑のチェック、テストスイートの赤いX。スイート内のテストの1つが失敗したため、スイート自体が失敗したと見なします。

次に、失敗したテストの開始時にXCTExpectFailureへの呼び出しを追加します。

失敗の理由は、この失敗を追跡するために私が提出したバグを参照するURLで始まることがわかります。

次に、テストを再実行し、これが結果にどのように影響するかを確認します。

さて、失敗したテストの赤いXアイコンは、予想される失敗の指標である灰色のXに変わりました。

さらに興味深いのは、テストスイートのアイコンが赤いXから緑のダッシュに変わったことです。

このアイコンは、テストスイートが混合状態で合格したことを示します。つまり、1つ以上のテストは合格しませんでしたが、スキップまたは予想される失敗のいずれかでした。

そのため、XCTExpectFailureを使用して失敗したテストを処理するのは簡単です。

では、APIを詳しく見てみましょう。

XCTExpectFailureを使用する際の最初の考慮事項は、どのAPIバリアントを呼び出すかです。

2つのアプローチがあります。XCTExpectFailureを呼び出すステートフルアプローチと、テストのその後の失敗は期待どおりに扱われます。または、XCTExpectFailureに渡されたクロージャで失敗したコードをラップするスコープ付きアプローチを使用できます。

いくつかの例を見てみましょう。 ではいくつかの例を見てみましょう。

これは私のプロジェクトでいくつかの関数を呼び出す非常に簡単なテストです。

関数がtrueを返さなくなったため、テストは失敗し始めます。

デモで行ったように、ステートフルな予想される障害アプローチを使用する方法は次のとおりです。

あるいは、XCTExpectFailureへの呼び出しに続くクロージャで失敗したコードをラップすることで、スコープ付きアプローチを使用できます。

これは、クロージャ外のコードの障害が正常に報告されることを意味します。

APIはネスティングもサポートしています。

言い換えれば、別の呼び出しからのクロージャの内側を含め、テストでAPIを複数回呼び出すことができます。

これは、テストライブラリコードでAPIを使用する際の重要な考慮事項です。

たとえば、一般的なユーティリティ関数が失敗し始めると、多くのテストが影響を受ける可能性があり、そのうちのいくつかはすでにさまざまな問題に対してXCTExpectFailureを使用している可能性があります。

XCTExpectFailureへのネストされた呼び出しのコンテキストで障害が発生した場合、問題は最初に最も近いコールサイトと照合され、マッチャーによって拒否された場合、XCTExpectFailureへの呼び出しのスタックセマンティクスで次の呼び出しなどに引き継がれます。

このため、共有コードでは、クロージャベースのAPIを使用してテスト状態への影響を制限するのが最善です。

次に考慮すべきことは、問題をどのように正確に一致させるかです。

デフォルトでは、影響を受けるスコープの障害は捕捉されますが、イシュートマッチングフィルタを指定することで、より選択的にすることができます。

この例では、XCTExpectedFailure.Options型のオブジェクトを構築し、そのissueMatcherを定義します。

マッチャーには、失敗の詳細が記載されたXCTCIssueオブジェクトに渡されるため、一致するかどうかを判断する際に、その情報に完全にアクセスできます。

マッチャーが失敗を拒否した場合、予想される失敗として処理されません。

これは、テスト対象のコードに新しい問題が表示されたときの検出に役立ちます。

オプションオブジェクトには、特定の構成で予想される障害を無効にするために使用できるプロパティもあります。

例えば、私のテストはmacOSで合格しているかもしれませんが、iOSでは失敗しているので、iOSでの失敗を期待したいだけです。

それを達成するために、私はオプションを介して予想される失敗を無効にしますが、それを必要としないプラットフォームに限ります。

では、予想される失敗が失敗しなくなったらどうなりますか?

通常、これは根本的な問題が解決されたことを意味し、それは素晴らしいことです。

しかし、XCTExpectFailureはどのように動作しますか?

まだAPIを呼び出していて、障害が発生していない場合は、新しい明確な障害が生成されます。

私たちはこれを「比類のない予想される失敗」と呼び、XCTExpectFailureのデフォルトである厳密な動作の一部です。

この動作は、APIへの不要な呼び出しを削除するように促すことで、コードを維持するのに役立ちます。

しかし、時々しか失敗しないテストはどうですか?

テストが失敗することもありますが、他の時には失敗しない場合があります。

これらは2つのカテゴリに分類され、最初のカテゴリは決定論的であり、特定のプラットフォームでのみ失敗するテストの以前の例など、環境またはその他の知可能な条件が含まれます。

一方、いくつかの失敗は本質的に非決定論的です。

これらは、タイミングの問題、信頼性の低い順序の依存関係、または並行性のバグによって引き起こされる可能性があります。

非決定的な失敗の場合、厳密な動作は役に立ちません。ノイズを発生させるだけです。

繰り返しになりますが、オプションオブジェクトはこれを制御する方法を提供します。

デフォルトでtrueであるisStrictフラグはオフにすることができます。

その後、XCTExpectFailureが失敗をキャッチしない場合でも、テストに合格することができます。

Swiftでは、XCTExpectFailureへの直接パラメータとして厳密な動作を指定することもできます。

厳格な動作を無効にすることは、プロジェクトでフレークまたは非決定的なテストを処理するのに最適な方法です。

余談ですが、非決定的な失敗を調査する必要がある場合、Xcodeはテストを複数回簡単に実行し、失敗したり、他の条件が満たされたときに停止します。

これは、フレーク状のテストの失敗を追跡するのに本当に役立ちます。

これの詳細については、「テストの繰り返しで信頼性の低いコードを診断する」セッションをご覧ください。

それがXCTExpectFailureです -- テストスイートの結果のシグナルツーノイズを改善するためのXCTestのAPIです。

これにより、新しい問題をより効率的に特定し、より高品質のコードにつながります。

見てくれてありがとう!

♪