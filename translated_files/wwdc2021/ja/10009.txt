10009

♪ベース音楽の演奏♪

♪

ブレイディ・ホワイト:こんにちは、私はブレイディです。

私はフィットネスチームのエンジニアです。

参加してくれてありがとう。

App Storeにはすでに素晴らしいワークアウトアプリがたくさんあります。

Apple Watchは、あらゆる種類のフィットネス活動を追跡できる素晴らしいデバイスです。

挑戦的な自転車に乗って、距離と標高を追跡できます。

激しいトレーニング中に消費された心拍数とエネルギーを監視できます。

水泳では、ストロークの種類を検出し、ラップを数えることさえできます。

これらすべてが、素晴らしいワークアウトアプリを構築するために利用できます。

今日取り上げるものを見てみましょう。私たちは何をカバーするかを見てみましょう。

このセッションはコードアロングです。

それが何を意味するのか、どのように参加できるかについて説明します。

SwiftUIでワークアウトビューを構築します。

次に、HealthKitを私たちの見解に統合します。

また、Always On状態をサポートする方法も紹介します。

ワクワクしています、始めましょう。

このセッションはコードアロングです。

ワークアウトアプリをゼロから一緒に構築します。

Xcodeの準備をしながら、いくつかの概念を取り上げましょう。

ワークアウトアプリとは何ですか?

ワークアウトアプリは、ワークアウト中のフィットネス活動を追跡します。

ワークアウトはワンタップで開始できます。

ワークアウトのセッション中は、経過時間、エネルギー燃焼、心拍数、距離などのライブメトリクスが表示されます。

ワークアウトが終了すると、要約にはワークアウトに記録されたメトリクスが表示されます。

これが私たちが今日構築するものです。

ワークアウトビューの構築を始めましょう。

Xcodeを開いて、新しいプロジェクトを始めましょう。

[新しいXcodeプロジェクトの作成]、[watchOS]、[Watch App]をクリックし、[次へ]をクリックします。

ワークアウトアプリに「MyWorkouts」などの名前を付けてください。

インターフェイスがSwiftUIで、言語がSwiftであることを確認し、[次へ]をクリックします。

プロジェクトの場所を見つけて、[作成]をクリックします。

インスペクターを隠して、キャンバスのサイズを変更しましょう。

「再開」をクリックして、Xcodeプレビューを使用して、アプリがどのように見えるかを見てみましょう。

素晴らしい、私たちのSwiftUIアプリは準備ができています。

誰かがStartViewでワークアウトを始める方法を提供しましょう。

ワークアウトはワンタップで開始できます。

カルーセルスタイルのレイアウトを持つリストビューは、大きな深度効果で垂直にスクロールするワークアウトのリストを提供します。

私たちのワークアウトのリストには、自転車、ランニング、ウォーキングが含まれます。

StartViewを作成しましょう。

「ContentView」の名前を「StartView」に変更しましょう。

コマンドキーを押しながらContentViewをクリックし、[名前の変更]をクリックし、新しい名前として「StartView」と入力します。

MyWorkoutsApp.swift StartViewでは、NavigationViewのルートビューになりました。

[名前の変更] をクリックします。

StartViewのリストに表示するワークアウトタイプの配列を定義しましょう。

まず、HealthKitをインポートしてHKWorkoutActivityTypeにアクセスしましょう。

次に、ワークアウトタイプの配列を追加しましょう。

私たちのワークアウトリストには、サイクリング、ランニング、ウォーキングのHKWorkoutActivityTypesがあります。

識別可能なプロトコルに準拠するようにHKWorkoutActivityType列挙型を拡張し、名前変数を追加することで、HKWorkoutActivityTypeをリストにアクセスできるようにしましょう。

IDで計算された変数は、列挙型のrawValueを返します。

名前変数は、ケースを切り替えて、「Run」、「Bike」、または「Walk」などの名前を返します。

StartViewのボディにリストビューを追加して、ワークアウトのリストを表示しましょう。

このリストは、そのモデルとしてoutworkTypes変数を使用します。

ワークアウトタイプごとにナビゲーションリンクが表示されます。

NavigationLinkは、ナビゲーションベースのインターフェイスの宛先を定義します。

今のところ、目的地はテキストビューになります。

これらのナビゲーションリンクは後で設定して、正しいワークアウトを追跡していることを確認します。

パディングはナビゲーションリンクを高くし、より大きなタップエリアを提供し、簡単にワークアウトを開始します。

このリストは、スクロール時に深度効果を提供するためにカルーセルリストスタイルを使用します。

navigationBarTitleには「ワークアウト」が表示されます。

「再開」をクリックして、StartViewのプレビューを見てみましょう。

ライブプレビューをクリックするとスクロールできます。

上にスクロールして、カルーセルリストスタイルの深度効果を確認します。

素敵ですね。

ワークアウトセッションはモーダル体験として提示されます。

ワークアウト中、人々は通常、セッション固有の機能だけを必要とします。

ワークアウトのリストを確認したり、アプリの他の部分にアクセスしたりする必要はありません。

モーダルエクスペリエンスで最も重要なアイテムを提供することは、気晴らしを最小限に抑えながらセッションを管理するのに役立ちます。

Apple Watchでワークアウトアプリを使用する人は、ビューがこの順序であることを期待しています。

左側のコントロールビューには、終了、一時停止、再開などの進行中のセッションを制御するボタンがあります。

中央では、メトリクスが一目で読める専用画面に表示されます。

右側のメディア再生コントロールでは、ワークアウト中にメディアを制御できます。

watchOSのTabViewは、誰かが左右にスワイプすると、複数の子ビューを切り替えます。

TabViewは、ビューの下部にページインジケーターも提供します。

TabViewは、セッション中のビューを表示するのに最適です。

3つのワークアウトセッションビューのタブビューでSessionPagingViewを作成しましょう。

[ファイル] > [新規] > [ファイル] をクリックします。

SwiftUI Viewをクリックし、[次へ]をクリックし、この名前を「SessionPagingView」と命名し、[作成]をクリックします。

TabViewで選択できる各ビューをモデル化するためのタブ列挙型を作成しましょう。

タブ列挙型には、コントロール、メトリクス、nowPlayingの3つのケースがあります。

また、TabViewの選択のバインディングを提供するために、「選択」という名前の@State変数を追加しました。

選択のデフォルト値はメトリクスになるため、ワークアウトが始まるとメトリクスビューが表示されます。

TabViewを追加しましょう。

TabViewの選択パラメータは、選択状態変数へのバインディングを使用します。

テキストビューは、作成されるまで各ビューのプレースホルダです。

各ビューにはタグが付いているので、選択できます。

「再開」をクリックして、SessionPagingViewがどのように見えるかを見てみましょう。

ライブプレビューをクリックすると、ビュー間をスワイプできます。

SessionPagingViewの選択変数のデフォルト値はメトリクスであるため、メトリクステキストビューが最初に表示されることに注意してください。

左にスワイプすると、コントロールのテキストビューが表示されます。

右にスワイプすると、再生中のテキストビューが表示されます。

すごい！

ワークアウトの実行中に、ライブメトリクスが表示されます。

セッションが実行などの動きを必要とする場合、アプリは大きなフォントサイズを使用し、最も重要な情報が読みやすいようにテキストを配置する必要があります。

MetricsViewは、経過時間、アクティブエネルギー、現在の心拍数、距離を表示します。

HealthKitには、さらに多くのHKQuantityTypesが使用できます。

MetricsViewを作成しましょう。

[ファイル] > [新規] > [ファイル SwiftUI ビュー] をクリックし、[次へ] をクリックし、この名前を「MetricsView」と命名し、[作成] をクリックします。

VStackには、4つのメトリックテキストビューが含まれます。

テキストビューは、これらのテキストビューをモデルに接続するまで、今のところデフォルト値です。

黄色のforegroundColorと半太字のfontWeightを与えて、経過時間を焦点にしましょう。

アクティブエネルギーテキストビューは、エネルギー単位キロカロリーのデフォルト値を使用して測定値を作成します。

測定は、ユニットを短縮する新しいフォーマットされた機能を使用し、使用法はワークアウトエネルギー燃焼のためのワークアウトであり、numberFormatは分数をトリミングする分数Lengthがゼロです。

心拍数テキストビューは、fractionLength zeroでフォーマットされたデフォルト値を使用します。

フォーマットされた文字列に「bpm」を追加します。

距離テキストビューは、UnitLength.metersのデフォルト値を使用します。

測定値は短縮単位でフォーマットされています。

使用法は道路であり、ロケールに基づいて自然に進行する帝国単位またはメートル単位を表示します。

丸みを帯びたデザイン、monospacedDigits、小文字のTitleのシステムフォントを使用します。

メトリクスを最先端に整列させたいので、VStackにmaxWidth infinityと先頭の整列を持つフレームビュー修飾子を与えました。

このVStackのコンテンツを画面の下部まで拡張できるようにしたいと考えています。

これを許可するために、私たちは一番下の安全な領域を無視します。

メトリクスをナビゲーションバーのタイトルに揃えたいので、これを行うにはscenePadding()を使用しました。

経過時間テキストビューは、経過時間を適切にフォーマットし、Always On状態に基づいてサブ秒を非表示または表示したいと考えています。

これを行うには、ElapsedTimeViewを作成し、カスタムのElapsedTimeFormatterを作成しましょう。

[ファイル] > [新規] > [ファイル]、SwiftUI View をクリックし、[次へ] をクリックし、「ElapsedTimeView」という名前を付け、[作成] をクリックします。

私たちのElapsedTimeViewには、TimeIntervalであるelapsedTimeがあり、デフォルトはゼロになっています。

showSubsecondsは、デフォルトでtrueに設定されているブール引数です。

timeFormatterは、以下で定義するElapsedTimeFormatter状態変数です。

ビューの本文には、timeFormatterが使用できるように、経過時間をNSNumberにキャストするテキストビューが含まれています。

テキストビューには半大胆なfontWeightがあります。

showSubsecondsが変更されると、timeFormatterのshowSubseconds変数も変更されます。

ElapsedTimeFormatterは、DateComponentsFormatterを使用するカスタムフォーマッタです。

経過時間が分と秒とパッドゼロを表示したい。

showSubseconds変数は、サブ秒が表示されるかどうかを決定します。

オプションの文字列を返す値関数の文字列をオーバーライドします。

最初のガードは、値がTimeIntervalであることを保証します。

2番目のガードは、componentsFormatterが文字列を返すことを保証します。

showSubsecondsがtrueの場合、By 1で割って切り捨てられたRemainderを取得し、100を掛けてサブ秒を計算します。

ローカライズされた decimalSeparator を使用し、formattedString を返し、サブ秒を追加します。

showSubseconds が false の場合、subseconds なしで formattedString を返します。

再開をクリックすると、ElapsedTimeViewのプレビューが表示されます。

よさそうですね。

分には、コロンの左側にゼロが埋め込まれています。

セコンドには、コロンの右側にゼロが埋め込まれています。

サブ秒は小数点の後に表示されます。

ElapsedTimeViewをMetricsViewに追加しましょう。

MetricsViewをクリックします。

経過時間テキストビューをElapsedTimeViewに置き換えます。

MetricsViewをプレビューしましょう。

美味しそう！

ControlsViewには、終了、一時停止、再開など、進行中のセッションを制御するボタンがあります。

終了ボタンをタップすると、ワークアウトの概要が表示されます。

一時停止ボタンをタップすると、ワークアウトが一時停止し、メトリクスビューが表示されます。

ControlsViewを作成しましょう。

[ファイル] > [新規] > [ファイル]、SwiftUI View をクリックし、この名前を「ControlsView」と選択し、[作成] をクリックします。

終了ボタンと一時停止ボタンを追加しましょう。

HStackには2つのVStackが含まれており、各VStackにはボタンとテキストビューが含まれています。

終了ボタンのラベルは、システム名「xmark」の画像です。

ボタンは赤い色合いで、title2フォントを使用してシンボルのサイズを大きくします。

下のテキストビューには「終了」文字列があります。

一時停止ボタンは、システム名「一時停止」の画像を使用します。

それは黄色の色合いを持っています。

下のテキストビューには「一時停止」文字列があります。

[再開]をクリックして、ControlsViewをプレビューします。

素敵ですね。

NowPlayingViewは、ワークアウトのセッション中にメディア再生コントロールを提供します。

これには、現在メディアを再生しているサードパーティのアプリのコントロールが含まれます。

NowPlayingViewを追加しましょう。

SessionPagingViewを選択します。

NowPlayingViewはWatchKitによって提供されています。

WatchKitをインポートしましょう。

テキストビューをControlsView、MetricsView、NowPlayingViewに置き換えましょう。

NowPlayingViewは、WatchKitが提供するSwiftUIビューです。

それはとても簡単です。

[再開] をクリックすると、SessionPagingView のプレビューが表示されます。

プレビューでは、MetricsViewを見ることができます。

左にスワイプすると、ControlsViewが表示されます。

右にずっとスワイプして...

...NowPlayingViewを見るには。

StartViewに戻り、NavigationLinkの宛先をSessionPagingViewに変更しましょう。

StartViewを選択します。

宛先をSessionPagingViewに更新します。

要約画面は、ワークアウトが終了したことを確認し、記録された情報を表示します。

人々が現在の進捗状況を簡単に確認できるように、アクティビティリングを含めることで要約を強化します。

サマリービューを作成しましょう。

[ファイル] > [新規] > [ファイル]、SwiftUI View をクリックし、[次へ] をクリックし、この名前を「SummaryView」と名前を付け、[作成] をクリックします。

メトリクスとその値を記述するカスタムSummaryMetricViewを作成しましょう。

SummaryMetricViewは、メトリックを記述するタイトルとメトリックの値文字列を取ります。

本文には、2つのテキストビューと分割器が含まれています。

メトリック値を示すテキストビューは、丸みを帯びたデザインと小文字のSmallCapsのタイトルシステムフォントを使用します。

前景カラーとしてアクセントカラーを使用します。

SummaryViewのワークアウト期間フォーマッタを作成しましょう。

durationFormatterは、時、分、秒をコロンとパッドゼロで区切って表示するDateComponentsFormatterです。

SummaryMetricViewsとDoneボタンをSummaryViewに追加しましょう。

ScrollViewとVStackには、4つのSummaryMetricViewsとDoneボタンが含まれています。

合計時間テキストビューは、hurationFormatterを使用して、時間、分、秒をコロンで区切って表示します。

Total Distance SummaryMetricViewは、短縮単位を使用してフォーマットされたデフォルト値で測定を使用します。

使用法は道路であり、ロケールに基づいて自然に進行する帝国単位またはメートル単位を表示します。

Total Energy SummaryMetricViewは、デフォルト値とキロカロリーのエネルギー単位で測定を使用します。

短縮単位でフォーマットされています。

使用法はワークアウトエネルギーのためのワークアウトであり、numberFormatは分数Lengthゼロの精度を持っています。

平均心拍数SummaryMetricViewは、数値精度、分数Lengthゼロでフォーマットされたデフォルト値を使用し、1分あたりの拍数に「bpm」を追加します。

SummaryMetricViewsの実際のワークアウト値は後で提供します。

テキストビューとディバイダをナビゲーションバーのタイトルに揃えたいので、VStackで.scenePadding()を使用しました。

navigationTitleは「Summary」になり、ナビゲーションバーにインラインで表示されます。

次に、ワークアウトの概要にアクティビティリングを追加します。

[ファイル] > [新規] > [ファイル] をクリックし、[スウィフト ファイル] をクリックし、[次へ] という名前を付け、[作成] をクリックします。

HealthKitをインポートしてHKHealthStoreにアクセスします。

SwiftUIをインポートして、WKInterfaceObjectRepresentableにアクセスします。

ActivityRingsView構造体は、WKInterfaceObjectRepresentableに準拠しています。

healthStore定数は初期化時に割り当てられます。

プロトコルに準拠するには、makeWKInterfaceObjectとupdateWKInterfaceObjectの2つの機能が必要です。

makeWKInterfaceObject内では、WKInterfaceActivityRingであるactivityRingsObjectを宣言します。

次に、HKActivitySummaryQueryの述語を作成し、今日の日付コンポーネントを使用します。

次に、クエリを作成して結果を処理し、メインキューのactivityRingsObjectにアクティビティサマリーを設定します。

次に、HKHealthStoreでクエリを実行します。

最後に、activityRingsObjectを返します。

ActivityRingsViewをSummaryViewに追加しましょう。

SummaryViewをクリックします。

HKHealthStoreにアクセスするには、HealthKitをインポートしましょう。

次に、完了ボタンの上にテキストビューとActivityRingsViewを追加します。

テキストビューとActivityRingsViewsを追加しました。フレームの幅と高さは50です。

とりあえずHKHealthStoreを作成します。

後で、1つ再利用します。

SummaryViewをプレビューしましょう。[再開]をクリックします。

ライブプレビューをクリックするとスクロールできます。

SummaryMetricViews、Activity Rings、および完了ボタンのそれぞれを参照してください。

HealthKitの統合について話しましょう。

HealthKitは、ワークアウト中のフィットネスアクティビティを追跡し、そのワークアウトをHealthKitに保存するための組み込み機能を提供します。

これにより、開発者としての時間を節約でき、顧客はすべてのワークアウトを1か所に保存できます。

HKワークアウトセッションは、カロリーや心拍数など、ワークアウトに関連するデータを正確に収集できるように、データ収集のためにデバイスのセンサーを準備します。

また、ワークアウトがアクティブなときにアプリケーションをバックグラウンドで実行することもできます。

HKLiveWorkoutBuilderは、HKWorkoutオブジェクトを作成して保存します。

サンプルやイベントを自動的に収集します。

詳細については、「ワークアウトで作業する新しい方法」セッションをチェックしてください。

アプリのデータフローがどうなるか見てみましょう。

WorkoutManagerは、HealthKitとのインターフェースを担当します。

HKWorkoutSessionと連携して、ワークアウトを開始、一時停止、終了します。

HKLiveWorkoutBuilderと連携して、ワークアウトのサンプルをリッスンし、そのデータを私たちの見解に提供します。

WorkoutManagerは環境オブジェクトになります。

環境オブジェクトは、観測可能なオブジェクトが変更されるたびに現在のビューを無効にします。

MyWorkoutsAppのNavigationViewをWorkoutManager環境オブジェクトに割り当て、WorkoutManagerをNavigationViewのビュー階層内のビューに伝播します。

その後、ビューは、環境内のWorkoutManagerにアクセスするための@EnvironmentObjectを宣言します。

WorkoutManagerを作成しましょう。

[ファイル] > [新規] > [ファイル] > [Swift ファイル] をクリックし、[次へ] をクリックし、この名前を「WorkoutManager」に名前を付けて [作成] をクリックします。

WorkoutManagerがHealthKitのAPIにアクセスできるように、HealthKitをインポートします。

次に、ObservableObjectプロトコルに準拠したNSObjectであるWorkoutManagerクラスを定義します。

私たちは、すべてのビューにWorkoutManagerへのアクセスを許可したいと考えています。

これは、MyWorkoutsAppのNavigationViewの環境オブジェクトとしてWorkoutManagerを割り当てることによって行います。

MyWorkoutsAppを選択します。

workoutManagerをStateObjectとして追加します。

environmentObjectビュー修飾子をNavigationViewに追加します。

NavigationViewにenvironmentObjectが割り当てられると、そのビュー階層内のビューにenvironmentObjectを自動的に渡します。

ナビゲーションモデルを設定しましょう。

WorkoutManagerを選択します。

WorkoutManagerは、オプションのHKWorkoutActivityTypeである選択したワークアウトを管理します。

選択したワークアウトを追跡するために、選択したワークアウト変数を追加しました。

これで、StartViewのNavigationLinkは、その選択をWorkoutManagerの選択したワークアウトにバインドする必要があります。

StartViewを選択します。

workoutManager EnvironmentObjectをStartViewに追加します。

タグと選択でNavigationLinkを更新しましょう。

タグはワークアウトタイプです。

選択は、outworkManagerのselectedWorkoutへのバインディングです。

これで、ワークアウトがタップされるたびに、outworkManagerで選択したワークアウトが更新されます。

ワークアウトが選択されたら、HKWorkoutSessionとHKLiveWorkoutBuilderを始めましょう。

WorkoutManagerを選択します。

HKHealthStore、HKWorkoutSession、HKLiveWorkoutBuilderを追加します。

では、ワークアウトを開始するためのstartWorkout機能を作成しましょう。

startWorkout関数は、workoutTypeパラメータを取ります。

HKWorkoutConfigurationは、outworkeTypeを使用して作成されます。

私たちのアプリでは、すべてのワークアウトが屋外になります。

ロケーションタイプによって、HKWorkoutSessionとHKLiveWorkoutBuilderの動作が決まることに注意してください。

たとえば、屋外サイクリング活動は正確な位置データを生成しますが、屋内サイクリング活動は生成しません。

healthStoreと設定を使用してHKWorkoutSessionを作成します。

セッションの関連WorkoutBuilderにビルダーを割り当てます。

これは、スローされたエラーを処理するためにdo-catchブロックで行われます。

healthStoreとoutreoutConfigurationを使用して、ビルダーのデータソースをHKLiveWorkoutDataSourceに割り当てます。

HKLiveWorkoutDataSourceは、アクティブなワークアウトセッションからのライブデータを自動的に提供します。

startDateを作成し、セッションでstartActivityを呼び出し、ビルダーでbeginCollectionを作成します。

選択したワークアウトが変更されるたびに、startWorkoutを呼び出しましょう。

選択されたワークアウトはゼロにすることができます。

ガードステートメントを使用して、選択したワークアウトがnilではない場合にのみstartWorkoutを呼び出します。

アプリがワークアウトセッションを作成する前に、HealthKitを設定し、アプリが使用する健康データの読み取りと共有の許可を要求する必要があります。

承認を要求する機能を追加しましょう。

ワークアウトセッションでは、ワークアウトの種類を共有する許可を求める必要があります。

また、セッションの一環としてApple Watchによって自動的に記録されたデータタイプも読みたいです。

また、アクティビティリングの概要を読む許可も必要です。

次に、healthStoreでrequestAuthorizationに電話します。

ビューが表示されたら、HealthKitからStartViewリクエストの承認をもらいましょう。

StartViewをクリックします。

現れると、outreoutManagerのrequestAuthorization関数が呼び出されます。

拡張機能にHealthKitを有効にしましょう。

MyWorkoutsのプロジェクトファイルを選択してください...

...MyWorkouts WatchKit拡張機能、署名、機能。

「機能を追加」を選択し、下にスクロールし、「HealthKit」を選択します。

アクティブなワークアウトセッションを持つアプリはバックグラウンドで実行できるため、WatchKit拡張機能にバックグラウンドモード機能を追加する必要があります。

ワークアウトセッションには、ワークアウト処理のバックグラウンドモードが必要です。

[機能の追加、背景モード] を選択します。

ワークアウト処理を選択します。

WatchKit ExtensionのInfo.plistファイルに使用状況の説明を追加する必要があります。

Info.plistを選択します。

最後の行を選択し、Returnキーを押します。

NSHealth ShareUsageDescriptionキーを使用してください。

アプリが要求されたデータを読み取る必要がある理由を説明してください。

Returnキーを押します。

NSHealth UpdateUsageDescriptionキーを使用してください。

アプリが書き込む予定のデータを説明してください。

アプリを構築して実行して、アプリがHealthKitに許可を要求するのを見てみましょう。

[実行]をクリックします。

私たちのアプリはHealthKitの承認を要求しました。

下にスクロールして[レビュー]をクリックします。

以下のすべての要求されたデータを選択します。

私たちのアプリがワークアウトの共有を要求しているのを見てください。

提供された説明を参照してください。

「次へ」をタップします。

私たちのアプリは読み取りアクセスを要求しました。

以下のすべての要求されたデータを選択します。

アプリが読み取りアクセスを要求したデータ型を参照してください。

提供された説明を参照してください。

「完了」をタップします。

ワークアウトセッションを開始できるようになったので、HKWorkoutSessionをコントロールする必要があります。

WorkoutManagerを選択します。

セッション状態制御ロジックを追加しましょう。

「running」という名前の@Published変数は、セッションが実行されているかどうかを追跡します。

一時停止と再開機能は、セッションを一時停止して再開します。

togglePause機能は、セッションが実行されているかどうかに基づいてセッションを一時停止または再開します。

endWorkout関数はセッションを終了します。

WorkoutManagerをHKWorkoutSessionDelegateに拡張して、セッション状態の変更をリッスンしましょう。

workoutSession didChangeTo toState fromState with Date 関数は、セッション状態が変更されるたびに呼び出されます。

実行中の変数は、toStateが実行中かどうかに基づいて更新され、UI更新のためにメインキューにディスパッチされます。

セッションが終了に移行したら、ビルダーのendCollectionを呼び出し、終了日を指定して、ワークアウトサンプルの収集を停止します。

endCollectionが終了したら、finishWorkoutを呼び出してHKWorkoutを健康データベースに保存します。

必ずWorkoutManagerをHKWorkoutSessionの代理人として割り当ててください。

それでは、ControlsViewでセッションを一時停止、再開、終了させましょう。

ControlsViewを選択します。

ビューがセッションを制御できるように、outworkManagerをEnvironmentObjectとして追加します。

workoutManagerで終了ボタンのアクションコールendWorkoutを持っています。

一時停止/再開ボタンは、セッションを一時停止または再開し、セッションの状態に基づいて画像とテキストを更新する必要があります。

ボタンのアクションは、sessionManagerのtogglePause機能を呼び出し、セッションを一時停止または再開します。

ボタンの画像のsystemNameは、outworkManagerの実行変数に基づいて「一時停止」または「再生」のいずれかです。

ボタンの下のテキストには、workoutManagerの実行変数に基づいて「一時停止」または「再開」のいずれかが表示されます。

SessionPagingViewを更新して、ナビゲーションバーにワークアウト名を表示しましょう。

SessionPagingViewを選択します。

SessionPagingViewはWorkoutManager環境変数にアクセスする必要があるので、それを追加しましょう。

では、ナビゲーションバーを設定しましょう。

ナビゲーションタイトルは、WorkoutManagerが選択したWorkoutの名前です。

トレーニング中に誰かがStartViewに戻りたくないので、ナビゲーションバーの戻るボタンは非表示になっています。

NowPlayingViewが表示されたら、ナビゲーションバーを非表示にします。

誰かがワークアウトを一時停止または再開するときは、MetricsViewにスワイプする必要はありません。

onChangeビュー修飾子を追加することで、彼らのためにこれを行うことができます。

WorkoutManagerの実行中の公開変数が変更されると、displayMetricsView関数が呼び出されます。

displayMetricsViewは、選択状態変数をメトリクス withAnimationに設定します。

ワークアウトが終了したので、SummaryViewを表示して閉じる機能を追加しましょう。

WorkoutManagerをクリックします。

ブール値がデフォルトでfalseである「showingSummaryView」という名前の公開変数を追加します。

この変数は、アプリのナビゲーションビューでシートの選択にバインディングを提供します。

endWorkoutで、ShowingSummaryViewをtrueに設定します。

SummaryViewをシートとしてMyWorkoutsAppのNavigationViewに追加しましょう。

MyWorkoutsAppをクリックします。

NavigationViewにシートビュー修飾子を追加します。

isPresentedパラメータは、outworkManagerの showingSummaryViewへのバインディングです。

シートの内容はSummaryViewです。

SummaryViewで、シートを閉じる機能を追加しましょう。

SummaryViewをクリックします。

Dismiss Dnvironment変数を追加します。

[完了] ボタンのアクションで、dis dismiss() を呼び出します。

アプリケーションを実行してセッションを開始および終了し、SummaryViewが表示されるのを見てみましょう。

[停止] をクリックして、前回の実行を停止します。

[実行]をクリックします。

ランニングワークアウトをタップします。

デフォルトのメトリック値は、セッション中と要約に引き続き表示されます。

後で設定します。

左にスワイプします。

一時停止をタップします。

MetricsViewが表示されていることに注意してください。

左にスワイプします。

ボタンに「再開」と表示されていることに注意してください。

終了をタップします。

ワークアウトの概要はシートとして表示されます。

下にスクロールします。

「完了」をタップします。

シートが却下され、StartViewが表示されます。

MetricsViewとSummaryViewを取得して、実際のワークアウト指標を表示しましょう。

WorkoutManagerは、MetricsViewとSummaryViewが観察できる公開されたワークアウトメトリクスを公開します。

WorkoutManagerを選択します。

公開されたメトリクス変数をWorkoutManagerに追加しましょう。

averageHeartRateはSummaryViewによって使用されます。

ハートレート、アクティブエネルギー、および距離は、メトリクスビューによって観察されます。

WorkoutManagerは、HKLiveWorkoutBuilderDelegateであることによってビルダーに追加されたワークアウトサンプルを観察する必要があります。

今これをやりましょう。

まず、ビルダーのデリゲートをWorkoutManagerとして割り当てましょう。

それでは、WorkoutManagerをHKLiveWorkout BuilderDelegateプロトコルに準拠させましょう。

HKLiveWorkout BuilderDelegateプロトコルに準拠するようにWorkoutManagerを拡張しました。

workoutBuilderDidCollectEventは、ビルダーがイベントを収集するたびに呼び出されます。

アプリでは、この機能を空のままにします。

workoutBuilder didCollectDataOf collectedTypesは、ビルダーが新しいサンプルを収集するたびに呼び出されます。

collectedTypesの各タイプを反復します。

ガードは、収集されたタイプがHKQuantityTypeであることを保証します。

統計は、その数量タイプのビルダーから読み取られます。

updateForStatistics（まもなく作成する関数）が呼び出され、公開されたメトリック値が更新されます。

updateForStatistics関数を作成しましょう。

updateForStatisticsは、オプションのHKStatisticsオブジェクトを取ります。

統計がゼロの場合、ガードは早期に戻ってきます。

メトリックの更新を非同期にメインキューにディスパッチします。

各数量タイプを切り替えます。

heartRateの場合、1分あたりの拍数が欲しいので、カウントHKUnitを1分HKUnitで割った値を使用します。

1分あたりの拍数に対して、heartRateをmostRrecentQuantityのdoubleValueとして割り当てます。

averageHeartRateを統計として割り当てます。平均1分あたりのビートのaverageQuantityのdoubleValue。

activeEnergyBurned quantityTypeには、キロカロリーエネルギーユニットを使用します。

energyUnitのsumQuantityのdoubleValueとしてactiveEnergyを割り当てます。

ウォーキング、ランニング、サイクリング距離については、mmeterUnitのsumQuantityのdoubleValueを取得します。

それでは、MetricsViewにWorkoutManagerのメトリック値を使ってもらいましょう。

MetricsViewを選択します。

workoutManagerを環境変数として追加します。

WorkoutManagerのメトリック値を使用するようにビューを更新しましょう。

ElapsedTimeViewは、workoutManagerのビルダーのelapsedTimeを使用します。

activeEnergyテキストビューの測定は、workoutManagerのactiveEnergyを使用します。

heartRateテキストビューは、workoutManagerのheartRateを使用します。

距離テキストビューの測定は、workoutManagerの距離を使用します。

ビルダーの経過時間変数は公開されていないため、ビルダーの経過時間が更新されると、現在ビューは更新されません。

私たちができることは、VStackをTimelineViewでラップすることです。

タイムラインビューは今年新しくです。

TimelineViewは、スケジュールに沿って時間の経過とともに更新されます。

watchOSアプリは、Always On状態をサポートするようになりました。

TimelineViewsは、Always Onコンテキストの変更を認識させます。

詳細については、「watchOS 8の新機能」と「SwiftUIの新機能」セッションをチェックしてください。

アプリはアクティブ状態または常時オン状態のいずれかになります。

アクティブなワークアウトセッションを持つアプリは、せいぜい1秒に1回、Always On状態で更新できます。

これは、MetricsViewがAlways On状態でサブ秒を非表示にする必要があることを意味します。

ビューを簡素化するためにページインジケータコントロールを非表示にするなど、Always On状態に関するその他の設計上の考慮事項を行う必要があります。

TimelineViewには、Always Onコンテキストによって決定されるTimelineScheduleModeに基づいて間隔を変更するカスタムTimelineScheduleが必要です。

カスタムのタイムラインスケジュールを作成しましょう。

MetricsTimelineScheduleには、スケジュールを開始するタイミングの開始日があります。

その初期化子はstartDateを取ります。

MetricsTimelineScheduleは、PeriodicTimelineScheduleエントリを生成するエントリ関数を実装しています。

この関数は、startDateを使用してPeriodicTimelineScheduleを作成します。

間隔はTimelineScheduleModeによって決定されます。

TimelineScheduleModeがlowFrequencyの場合、TimelineSchedule間隔は1秒です。

TimelineScheduleModeが正常な場合、間隔は毎秒30回です。

VStackをTimelineViewでラップしましょう。

TimelineViewは、ビルダーのstartDateを使用して、MetricsTimelineScheduleを使用します。

ElapsedTimeViewのshowSubsecondsは、TimelineViewのcontext.cadenceによって決定されます。

ケイデンスがライブの場合、サブ秒が表示されます。

それ以外の場合、サブ秒はAlways On状態で非表示になります。

アプリケーションを実行して、ワークアウト中に更新されるメトリクスを見てみましょう。

[停止]をクリックして、現在の実行を停止します。

[実行]をクリックします。

ランニングワークアウトをタップします。

経過時間が増加していることに注意してください。 

watchOSシミュレーターは、ライブワークアウトサンプルの収集を自動的にシミュレートします。

カロリーが蓄積されています。

心拍数が更新されています。

距離が溜まっています。

シミュレーターのロックボタンをクリックして、常にオンの状態を試してみましょう。

サブ秒が非表示になり、メトリクスは1秒間に1回しか更新されません。

ロック解除ボタンをクリックしてアクティブな状態に戻ります。

左にスワイプしてワークアウトを終了します。

SummaryViewにはまだ実際のHKWorkoutの値が必要です。

今これをやりましょう。

まず、SummaryViewで使用するHKWorkoutをWorkoutManagerに追加しましょう。

WorkoutManagerを選択します。

HKWorkout公開変数を追加します。

ビルダーがワークアウトの保存を終了したら、ビルダーのfinishWorkout機能が完了したら、ワークアウトをWorkoutManagerに割り当てます。

この割り当ては、UI更新のメインキューで行います。

SummaryViewが却下されたら、モデルをリセットする必要があります。

これを行うresetWorkout関数を作成しましょう。

resetWorkout関数は、すべてのモデル変数を初期状態にリセットします。

要約が却下されたら、resetWorkoutを呼びましょう。

これは、ShowingSummaryViewのdidSetで行われます。

ワークアウトが終了したら、ワークアウトが保存されている間に、サマリービューを表示する前に、進行状況ビューを表示しましょう。

サマリービューに行きましょう。

SummaryViewをクリックします。

まず、outworkManager EnvironmentObjectをSummaryViewに追加します。

ビルダーがワークアウトの保存を終了したら、workoutManagerがHKWorkoutを割り当てるまで、ProgressViewを表示したい。

workoutManagerのワークアウトがゼロの場合、「ワークアウトの保存」というテキストでProgressViewを表示し、ナビゲーションバーを非表示にします。

また、WorkoutマネージャーのHKHealthStoreを使用するようにActivityRingsViewを更新しました。

アプリごとに1つのHKHealthStoreのみが必要です。

HKWorkoutの値を使用するようにSummaryMetricViewsを更新しましょう。

合計時間メトリックビューは、ワークアウトの期間を使用します。

totalDistanceメトリックビューは、ワークアウトの総距離を使用します。

Total Energyメトリックビューは、ワークアウトのtotalEnergyBurnedを使用します。

平均心拍数メトリックビューは、outworkManagerの平均HeartRateを使用します。

後で平均心拍数を保存したい場合は、ワークアウトを保存する前にビルダーにメタデータとして追加できます。

Always On状態に反応するようにSessionPagingViewを更新しましょう。

SessionPagingViewを選択します。

isLuminanceReduced Environment変数を追加します。

Always On状態では、TabViewのページインジケーターを非表示にし、MetricsViewが表示されるようにします。

isLuminanceReducedに基づいて、tabViewStyleのindexDisplayModeを決してまたは自動に設定しました。

isLuminanceReducedが変更されたら、displayMetricsView関数を呼び出すと、MetricsViewが表示されます。

シミュレーターでアプリを実行して試してみましょう。

停止をクリックして最後の実行を停止します。

[実行]をクリックします。

ランニングワークアウトを選択します。

メトリクスがビルダーからライブで更新されていることに注意してください。

左にスワイプします。一時停止をタップします。

ワークアウトが一時停止されているため、メトリクスの更新が停止したことに注意してください。

左にスワイプします。[再開] をタップします。

メトリクスは更新を再開します。

右にスワイプして、NowPlayingViewを参照してください。

左にスワイプします。

ロックをクリックして、常にオン状態をトリガーします。

サブ秒が非表示になり、ページコントロールインジケーターが非表示になっていることに注意してください。

ロック解除をクリックして、アクティブな状態を再開します。

左にスワイプして、終了をタップします。

ワークアウトは節約します。

要約が表示されます。

下にスクロールして、各メトリックを表示します。

アクティビティリングは、エネルギー量、運動時間、待機時間に基づいて入力されます。

「完了」をタップします。

私たちはスタートビューに戻り、次のトレーニングの準備ができています。

SwiftUIを使用して、Always On状態をサポートするHealthKitと統合された完全に機能するワークアウトアプリを実装するのがいかに簡単かを見ました。

あなたが次に構築する素晴らしいワークアウトアプリを見るのが待ちきれません!

♪