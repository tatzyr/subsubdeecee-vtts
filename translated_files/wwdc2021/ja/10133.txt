10133

♪ベース音楽の演奏♪

♪

ダリオ・レキシン：こんにちは、私の名前はダリオ・レキシンで、アップルのスウィフトチームのエンジニアです。

今日、同僚のダグと私は、Swiftの俳優と、同時Swiftアプリケーションの可変状態を保護するためにそれらがどのように利用されているかについて話します。

並行プログラムを書く際の根本的に難しい問題の1つは、データ競争を避けることです。

データレースは、2つの別々のスレッドが同時に同じデータにアクセスし、それらのアクセスの少なくとも1つが書き込みである場合に発生します。

データレースは構築するのは簡単ですが、デバッグが難しいことで有名です。

これは、カウンタをインクリメントして新しい値を返す1つの操作を持つ単純なカウンタクラスです。

先に進んで、2つの同時タスクからインクリメントしようとしましょう。

これは悪い考えです。

実行のタイミングによっては、1、次に2、または2、次に1が得られる場合があります。

これは予想され、どちらの場合も、カウンタは一貫した状態のままになります。

しかし、データレースを導入したため、両方のタスクが0を読み、1を書き込むと、1と1を得ることもできます。

または、リターンステートメントが両方の増分操作の後に発生する場合は、2と2でさえも。

データレースは、回避とデバッグが難しいことで有名です。

レースの原因となるデータアクセスがプログラムの異なる部分にある可能性があるため、非ローカルな推論が必要です。

また、オペレーティングシステムのスケジューラは、プログラムを実行するたびに異なる方法で同時タスクをインターリーブする可能性があるため、それらは非決定的です。

データレースは、共有可変状態によって引き起こされます。

データが変更されない場合、または複数の同時タスク間で共有されていない場合は、データレースをすることはできません。

データレースを回避する1つの方法は、値セマンティクスを使用して共有可変状態を排除することです。

値型の変数では、すべての突然変異は局所的です。

さらに、値セマンティック型の「let」プロパティは本当に不変であるため、異なる同時タスクからアクセスしても安全です。

Swiftは、当社のプログラムについて推論しやすくなり、同じことが並行プログラムで安全に使用できるため、創業以来、価値セマンティクスを推進してきました。

この例では、いくつかの値を持つ配列を作成します。

次に、その配列を2番目の変数に割り当てます。

次に、配列の各コピーに異なる値を追加します。

最後に両方の配列を印刷すると、両方のコピーに配列が初期化された値が含まれていることがわかりますが、追加された各値は、追加したそれぞれのコピーにのみ存在します。

Swiftの標準ライブラリの大部分の型には、辞書やこの例のように配列などのコレクション型を含む値のセマンティクスがあります。

値のセマンティクスがすべてのデータレースを解決することを確立したので、先に進み、カウンターを構造体に変換して値型にしましょう。

また、増分関数を突然変異としてマークする必要があるため、valueプロパティを変更できます。

カウンタを変更しようとすると、カウンタがletであるため、コンパイラエラーが発生し、突然変異を防ぐことができます。

さて、カウンタ変数をvarに変更して可変にするのは非常に魅力的に思えます。

しかし、カウンターは両方の同時タスクによって参照されるため、再び競合状態になります。

幸いなことに、コンパイラは私たちをカバーしており、この安全でないコードをコンパイルすることはできません。

代わりに、各同時タスク内のローカル可変変数にカウンタを割り当てることができます。

今、例を実行すると、両方の同時タスクに対して常に1が印刷されます。

しかし、私たちのコードは現在レースフリーですが、その動作はもはや私たちが望むものではありません。

これは、共有可変状態が必要なケースがまだあることを示しています。

並行プログラムで可変状態を共有している場合、共有可変状態の同時使用がデータ競合を引き起こさないように、何らかの形式の同期が必要です。

アトミックやロックなどの低レベルのツールから、シリアルディスパッチキューなどの高レベルの構造まで、同期のためのプリミティブがいくつかあります。

これらのプリミティブにはそれぞれさまざまな強みがありますが、それらはすべて同じ重要な弱点を共有しています。毎回正確に正しく使用するために慎重な規律が必要です。そうしないと、データレースになります。

ここが俳優の出番です。

アクターは、共有可変状態の同期メカニズムです。

俳優には独自の状態があり、その状態はプログラムの残りの部分から隔離されています。

その状態にアクセスする唯一の方法は、俳優を通過することです。

そして、アクターを通過するたびに、アクターの同期メカニズムは、他のコードがアクターの状態に同時にアクセスしていないことを保証します。

これは、ロックまたはシリアルディスパッチキューを手動で使用することで得られるのと同じ相互除外プロパティを提供しますが、アクターでは、Swiftが提供する基本的な保証です。

試してみると、Swiftはコンパイラエラーが発生するため、同期を実行することを忘れないでください。

俳優はスウィフトの新しいタイプです。

それらは、Swiftのすべての名前付きタイプと同じ機能を提供します。

プロパティ、メソッド、初期化子、添字などを持つことができます。

それらはプロトコルに準拠し、拡張機能で拡張することができます。

クラスと同様に、それらは参照型です。アクターの目的は、共有可変状態を表現することだからです。

実際、アクタータイプの主な特徴は、インスタンスデータをプログラムの残りの部分から分離し、そのデータへの同期アクセスを確保することです。

彼らの特別な行動はすべて、それらの中核的なアイデアに従います。

ここでは、カウンターをアクタータイプとして定義しました。

カウンタのインスタンスプロパティ値と、その値をインクリメントして新しい値を返すインクリメントメソッドがまだあります。

違いは、アクターが値が同時にアクセスされないようにすることです。

この場合、インクリメントメソッドは、呼び出されると、アクターで他のコードが実行されることなく完了まで実行されることを意味します。

その保証は、俳優の状態に関するデータレースの可能性を排除します。

データレースの例を復活させましょう。

再び、同じカウンタをインクリメントしようとする2つの同時タスクがあります。

アクターの内部同期メカニズムは、もう一方のインクリメントコールが開始される前に、1つのインクリメントコールが完了するまで実行されることを保証します。

したがって、どちらも有効な同時実行であるため、1と2または2と1を得ることができますが、アクターの内部同期により、アクター状態のデータレースの可能性が排除されたため、同じカウントを2回取得したり、値をスキップしたりすることはできません。

両方の同時タスクが同時にカウンタをインクリメントしようとすると、実際に何が起こるかを考えてみましょう。

一人は最初にそこに着き、もう一人は順番を待たなければなりません。

しかし、2番目のタスクが俳優の順番を辛抱強く待つことができるようにするにはどうすればよいでしょうか?

スウィフトにはそのためのメカニズムがあります。

外部から俳優と対話するときはいつでも、非同期にそうします。

アクターがビジー状態の場合、実行中のCPUが他の有用な作業ができるように、コードが一時停止されます。

アクターが再び自由になると、コードが起動し、実行を再開するので、アクターでコールを実行できます。

この例のawaitキーワードは、アクターへの非同期呼び出しがそのような停止を伴う可能性があることを示しています。

不必要に遅いリセット操作を追加して、反例をもう少し伸ばしましょう。

この操作は、値を0に戻し、適切な回数をインクリメントを呼び出して、カウンタを新しい値に取得します。

このresetSlowlyメソッドは、カウンターアクタータイプの拡張で定義されているため、アクター内にあります。

つまり、アクターの状態に直接アクセスでき、カウンタ値を0にリセットします。

また、インクリメントの呼び出しなど、アクター上の他のメソッドを同期的に呼び出すこともできます。

私たちはすでに俳優で走っていることを知っているので、待つ必要はありません。

これは俳優の重要な財産です。

アクターの同期コードは、常に中断されることなく完了します。

したがって、並行性がアクター状態に与える影響を考慮することなく、同期コードを順番に推論することができます。

私たちは、同期コードが途切れることなく実行されることを強調してきましたが、アクターはしばしば互いに相互作用したり、システム内の他の非同期コードと対話したりします。

数分かけて、非同期コードとアクターについて話しましょう。

しかし、まず、より良い例が必要です。

ここでは、画像ダウンローダーの俳優を構築しています。

別のサービスから画像をダウンロードする責任があります。

また、同じ画像を複数回ダウンロードしないように、ダウンロードした画像をキャッシュに保存します。

論理フローは簡単です。キャッシュを確認し、画像をダウンロードし、戻る前にキャッシュに画像を記録します。

私たちはアクターにいるので、このコードは低レベルのデータレースから解放されています。任意の数の画像を同時にダウンロードできます。

アクターの同期メカニズムは、一度に1つのタスクのみがキャッシュインスタンスプロパティにアクセスするコードを実行できることを保証するため、キャッシュが破損する方法はありません。

とはいえ、ここでのawaitキーワードは、非常に重要なことを伝えています。

待機が発生するたびに、この時点で関数を一時停止できることを意味します。

プログラム内の他のコードが実行できるようにCPUをあきらめ、プログラム全体の状態に影響します。

機能が再開される時点で、全体的なプログラムの状態が変更されます。

待機後に保持されない可能性のある待機の前に、その状態について仮定していないことを確認することが重要です。

同じ画像を同時に取得しようとする2つの異なる同時タスクがあると想像してみてください。

1つ目は、キャッシュエントリがないのを見て、サーバーから画像のダウンロードを開始し、ダウンロードに時間がかかるため中断されます。

最初のタスクがイメージをダウンロードしている間、新しいイメージが同じURLでサーバーにデプロイされる可能性があります。

さて、2番目の同時タスクは、そのURLの下の画像を取得しようとします。

また、最初のダウンロードがまだ終了していないため、キャッシュエントリが表示されず、画像の2回目のダウンロードが開始されます。

また、ダウンロードが完了している間は一時停止されます。

しばらくすると、ダウンロードの1つ（それが最初であると仮定しましょう）が完了し、そのタスクはアクターの実行を再開します。

キャッシュに入力し、結果の猫の画像を返します。

これで2番目のタスクのダウンロードが完了したので、目を覚ます。

キャッシュ内の同じエントリを、それが得た悲しい猫の画像で上書きします。

そのため、キャッシュにはすでに画像が入力されていたにもかかわらず、同じURLに対して異なる画像を取得できるようになりました。

それはちょっとした驚きです。

画像をキャッシュすると、常に同じURLで同じ画像を取り戻すことを期待していたので、少なくとも手動でキャッシュをクリアするまで、ユーザーインターフェイスは一貫しています。

しかし、ここでは、キャッシュされた画像が予期せず変更されました。

低レベルのデータレースはありませんが、待機中に状態に関する仮定を運んだため、潜在的なバグが発生しました。

ここでの修正は、待った後に私たちの仮定を確認することです。

再開時にキャッシュにすでにエントリがある場合は、その元のバージョンを保持し、新しいバージョンを破棄します。

より良い解決策は、冗長なダウンロードを完全に回避することです。

私たちは、このビデオに関連するコードにその解決策を入れました。

俳優の再参入はデッドロックを防ぎ、前進の進歩を保証しますが、各待機全体で仮定を確認する必要があります。

再参入のためにうまく設計するには、同期コード内でアクター状態の突然変異を実行します。

理想的には、すべての状態変更がうまくカプセル化されるように、同期関数内で行います。

状態の変更には、一時的に俳優を一貫性のない状態に置くことが含まれます。

待つ前に必ず一貫性を回復してください。

そして、待つことは潜在的な停止点であることを覚えておいてください。

コードが一時停止されると、コードが再開される前にプログラムと世界が進みます。

グローバル状態、時計、タイマー、または俳優について行った仮定は、待機後にチェックする必要があります。

そして今、私の同僚のダグが俳優の孤立についてもっと教えてくれます。ダグ？

ダグ・グレゴール:ありがとう、ダリオ。

俳優の孤立は、俳優タイプの行動の基本です。

ダリオは、アクターの外部からの非同期インタラクションを通じて、Swift言語モデルによってアクターの分離がどのように保証されるかについて議論しました。

このセクションでは、アクターの分離がプロトコル適合性、クロージャ、クラスなど、他の言語機能とどのように相互作用するかについて説明します。

他のタイプと同様に、アクターはプロトコルの要件を満たすことができる限り、プロトコルに準拠することができます。

たとえば、このLibraryAccountアクターをEquatableプロトコルに準拠させましょう。

静的平等法は、ID番号に基づいて2つのライブラリアカウントを比較します。

メソッドは静的であるため、セルフインスタンスがないため、アクターに分離されません。

代わりに、アクタータイプの2つのパラメータがあり、この静的メソッドは両方の外側にあります。

実装はアクターの不変状態にのみアクセスしているので、それは大丈夫です。

ライブラリアカウントをHashableプロトコルに準拠させるために、例をさらに拡張しましょう。

そのためには、ハッシュ(into)操作を実装する必要があり、このように行うことができます。

しかし、Swiftコンパイラは、この適合性が許可されていないと文句を言うだろう。

どうしましたか？

さて、この方法でHashableに準拠することは、この関数をアクターの外部から呼び出すことができることを意味しますが、ハッシュ(into)は非同期ではないため、アクターの分離を維持する方法はありません。

これを修正するには、このメソッドを非単離にすることができます。

Nonisolatedとは、この方法が、構文的に俳優に記述されているにもかかわらず、俳優の外にあるものとして扱われることを意味します。

これは、Hashableプロトコルからの同期要件を満たすことができることを意味します。

非単離された方法はアクターの外にあるものとして扱われるため、アクターの可変状態を参照することはできません。

この方法は、不変のID番号を参照しているため問題ありません。

貸し出し中の書籍の配列など、他のものに基づいてハッシュしようとすると、外部からの可変状態へのアクセスがデータレースを許可するため、エラーが発生します。

プロトコルの適合性はそれで十分です。

閉鎖について話しましょう。

クロージャは、ある関数内で定義された小さな関数であり、その後、別の関数に渡して、しばらく後に呼び出すことができます。

関数と同様に、クロージャはアクターで隔離されているか、非単離されている可能性があります。

この例では、貸し出し中の各本からいくつか読み、読んだページの総数を返します。

削減の呼び出しには、読み取りを実行するクロージャが含まれます。

この呼び出しでは、readSomeへの待ち時間がないことに注意してください。

それは、アクター分離関数「読み取り」内で形成されるこのクロージャは、それ自体がアクター分離であるためです。

削減操作は同期的に実行され、同時アクセスを引き起こす可能性のある他のスレッドにクロージャをエスケープできないため、これは安全であることを知っています。

さて、少し違うことをしましょう。

今は読む時間がないので、後で読みましょう。 

ここでは、切り離されたタスクを作成します。

切り離されたタスクは、アクターが行っている他の作業と同時にクロージャを実行します。

したがって、閉鎖はアクターにあることができないか、データレースを導入します。

したがって、この閉鎖は俳優に隔離されていません。

Readメソッドを呼び出す場合は、waitで示されるように、非同期に呼び出す必要があります。

コードのアクターの分離について少し話しました。これは、そのコードがアクター内で実行されるか、アクターの外で実行されるかです。

では、アクターの分離とデータについて話しましょう。

私たちの図書館アカウントの例では、本の種類が実際に何であるかを言うのを熱心に避けてきました。

私はそれが構造体のような値型であると仮定してきました。

ライブラリアカウントアクターのインスタンスのすべての状態が自己完結型であることを意味するので、それは良い選択です。

先に進んでこの方法を呼び出して、読むべきランダムな本を選択すると、読める本のコピーが手になります。

本のコピーに加えた変更は、俳優には影響しませんし、その逆も同様です。

しかし、本をクラスに変えると、物事は少し異なります。

私たちの図書館アカウントアクターは現在、ブッククラスのインスタンスを参照しています。

それ自体は問題ではありません。

しかし、ランダムな本を選択するメソッドを呼び出すとどうなりますか?

今、私たちは俳優の外で共有されている俳優の可変状態への参照を持っています。

私たちはデータレースの可能性を生み出しました。

さて、本のタイトルを更新すると、変更は俳優内でアクセス可能な状態で行われます。

訪問方法はアクターではないため、この変更はデータレースになる可能性があります。

値タイプとアクターはどちらも同時に使用しても安全ですが、クラスは依然として問題を引き起こす可能性があります。

同時に安全に使用できるタイプの名前があります：Sendable。

センバブルタイプは、異なるアクター間で価値を共有できるタイプです。

ある場所から別の場所に値をコピーし、両方の場所が互いに干渉することなく、その値の独自のコピーを安全に変更できる場合、タイプは送信可能です。

Darioが先に述べたように、各コピーは独立しているため、値タイプは送信可能です。

アクタータイプは、可変状態へのアクセスを同期させるため、送信可能です。

クラスは送信可能ですが、慎重に実装されている場合に限られます。

たとえば、クラスとそのすべてのサブクラスが不変のデータのみを保持している場合は、Sendableと呼ぶことができます。

または、安全な同時アクセスを確保するために、クラスがロックなどの同期を内部的に実行する場合、送信可能にすることができます。

しかし、ほとんどのクラスはこれらのどちらもなく、送信できません。

関数は必ずしも送信可能ではないので、アクターを渡しても安全な関数には新しい種類の関数タイプがあります。

私たちはすぐにそれらに戻ります。

あなたのアクターは、実際には、すべての同時コードは、主にSendableタイプの観点から通信する必要があります。

送信可能なタイプは、データレースからコードを保護します。

これは、Swiftが最終的に静的にチェックを開始するプロパティです。

その時点で、アクターの境界を越えて送信不可能なタイプを渡すことはエラーになります。

タイプが送信可能であることをどうやって知るのですか?

さて、Sendableはプロトコルであり、あなたのタイプは他のプロトコルと同じようにSendableに準拠していると述べています。

その後、Swiftは、あなたのタイプが送信可能なタイプとして理にかなっているかどうかを確認します。

保存されたすべてのプロパティがSendableタイプの場合、Book構造体はSendableにすることができます。

Authorが実際にはクラスであるとします。つまり、著者の配列は送信可能ではありません。

Swiftは、Bookが送信可能ではないことを示すコンパイラエラーを生成します。

ジェネリックタイプの場合、送信可能かどうかは、一般的な引数に依存します。

必要に応じて、条件付き適合を使用してSendableを伝播できます。

たとえば、ペアタイプは、その一般的な引数の両方がSendableである場合にのみSendableになります。

同じアプローチを使用して、Sendableタイプの配列自体がSendableであると結論付けます。

値を同時に共有しても安全なタイプにSendableコンフォーマンスを導入することをお勧めします。

俳優の中でこれらのタイプを使ってください。

その後、Swiftがアクター間でSendableを強制し始めると、コードの準備が整います。

関数自体は送信可能であり、アクター間で関数値を渡すのが安全であることを意味します。

これは、データレースを防ぐためにクロージャができることを制限するクロージャにとって特に重要です。

たとえば、Sendableクロージャは、ローカル変数のデータレースを可能にするため、可変ローカル変数をキャプチャできません。

クロージャがキャプチャするものはすべて、クロージャを使用して送信不可能なタイプをアクターの境界を越えて移動できないようにするために、送信可能である必要があります。

そして最後に、同期送信可能なクロージャは、外部からアクターでコードを実行できるため、アクターを分離することはできません。

私たちは実際にこの講演で送信可能な閉鎖のアイデアに頼っています。

切り離されたタスクを作成する操作は、関数タイプの@Sendableでここに書かれたSendable関数を取ります。

話の冒頭から私たちの反例を覚えていますか？

値型カウンタを構築しようとしていました。

その後、私たちは同時に2つの異なるクロージャからそれを修正しようとしました。

これは、可変ローカル変数のデータレースになります。

ただし、切り離されたタスクのクロージャはSendableであるため、Swiftはここでエラーを生成します。

送信可能な関数型は、同時実行が発生する可能性のある場所を示すために使用され、データレースを防ぎます。

これは先ほど見た別の例です。

切り離されたタスクのクロージャはSendableであるため、アクターに分離すべきではないことを知っています。

したがって、それとの相互作用は非同期でなければなりません。

送信可能なタイプとクロージャは、可変状態がアクター間で共有されておらず、同時に変更できないことを確認することで、アクターの分離を維持するのに役立ちます。

私たちは主にアクタータイプと、それらがプロトコル、クロージャ、およびSendableタイプとどのように相互作用するかについて話してきました。

議論する俳優がもう1人います。メイン俳優と呼ぶ特別な俳優です。

アプリを構築するときは、メインスレッドについて考える必要があります。

これは、コアユーザーインターフェイスのレンダリングが行われる場所であり、ユーザーインタラクションイベントが処理される場所です。

UIで動作する操作は、通常、メインスレッドから実行する必要があります。

ただし、メインスレッドですべての作業を行うわけではありません。

メインスレッドで作業が多すぎる場合、例えば、入出力操作が遅いか、サーバーとのやり取りをブロックするため、UIがフリーズします。

したがって、UIと対話するときはメインスレッドで作業を行うように注意する必要がありますが、計算コストのかかる操作や長時間の操作のためにすぐにメインスレッドから外れる必要があります。

したがって、可能な限りメインスレッドで作業し、メインスレッドで実行する必要がある特定の操作があるときはいつでも、コードでDispatchQueue.main.asyncを呼び出します。

メカニズムの詳細から一歩下がって、このコードの構造は漠然と見覚えがあるように見えます。

実際、メインスレッドとのやり取りは、俳優とのやり取りとまったく似ています。

すでにメインスレッドで実行していることがわかっている場合は、UIの状態に安全にアクセスして更新できます。

メインスレッドで実行していない場合は、非同期に操作する必要があります。

これはまさに俳優のやり方です。

メインスレッドを説明する特別な俳優がいて、私たちはそれをメイン俳優と呼んでいます。

メイン俳優は、メインスレッドを表す俳優です。

それは2つの重要な点で普通の俳優とは異なります。

まず、メインアクターはメインディスパッチキューを介してすべての同期を実行します。

これは、ランタイムの観点から、メインアクターがDispatchQueue.mainを使用することと交換可能であることを意味します。

第二に、メインスレッド上にある必要があるコードとデータはどこにでも散らばっています。

SwiftUI、AppKit、UIKit、その他のシステムフレームワークにあります。

独自のビュー、ビューコントローラー、およびデータモデルのUIに面した部分に広がっています。

Swift並行性を使用すると、メインアクター属性で宣言をマークして、メインアクターで実行する必要があると言うことができます。

私たちはここでチェックアウト操作でそれをやったので、それは常に主役で実行されます。

メインアクターの外部から呼び出す場合は、メインスレッドで非同期に実行されるように待つ必要があります。

メインスレッドで実行する必要があるコードをメインアクター上にあるものとしてマークすることで、DispatchQueue.mainを使用するタイミングについての推測はもうありません。

Swiftは、このコードが常にメインスレッドで実行されることを保証します。

タイプはメインアクターにも配置できるため、すべてのメンバーとサブクラスがメインアクターになります。

これは、ほとんどのものがメインスレッドで実行する必要があるUIと対話する必要があるコードベースの部分に役立ちます。

個々のメソッドは、通常のアクターから慣れ親しんでいるのと同じルールで、非分離キーワードを介してオプトアウトできます。

UIに面したタイプと操作にメインアクターを使用し、他のプログラム状態を管理するための独自のアクターを導入することで、並行性の安全で正しい使用を確保するためにアプリを設計することができます。

このセッションでは、アクターの分離を使用し、実行をシリアル化するためにアクターの外部からの非同期アクセスを要求することによって、アクターが同時アクセスから可変状態を保護する方法について話しました。

アクターを使用して、Swiftコードで安全な同時抽象化を構築します。

あなたのアクターを実装するとき、そして任意の非同期コードでは、常に再参入のために設計します。あなたのコードで待つことは、世界が前進し、あなたの仮定を無効にすることができることを意味します。

バリュータイプとアクターは、データレースを排除するために協力します。

独自の同期を処理しないクラスや、共有可変状態を再導入する他の送信不可能なタイプに注意してください。

最後に、UIと対話するコードのメインアクターを使用して、メインスレッドにある必要があるコードが常にメインスレッドで実行されるようにします。

独自のアプリケーション内でアクターを使用する方法の詳細については、Swift並行性アプリの更新に関するセッションをご覧ください。

また、俳優を含むSwiftの並行性モデルの実装の詳細については、「舞台裏」セッションをご覧ください。

アクターはSwift並行性モデルの中核部分です。

それらは、非同期/待機および構造化された並行性と協力して、正確で効率的な並行プログラムの構築を容易にします。

あなたが彼らと一緒に何を作るかを見るのが待ちきれません。

♪