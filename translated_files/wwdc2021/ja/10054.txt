10054

♪ベース音楽の演奏♪

♪

ジェフ・ナドー:こんにちは、「AppKitの新機能」へようこそ。

私はジェフ・ナドーです。

私はAppKitに取り組んでおり、あなたと共有する素晴らしいアップデートがいくつかあります。

macOS Montereyには、Macアプリのためのいくつかの素晴らしい新機能と機能強化が含まれています。

このリリースには、ユーザーインターフェイスデザインのアップデート、多くのコントロールの強化、SFシンボルの大きなアップデート、TextKit 2と呼ばれるまったく新しいテキストエンジン、強力な新しいSwift言語機能、Macで利用可能なショートカットによる自動化など、誰にとっても本当に何かがあります。

macOSのユーザーインターフェイスのデザインに関するいくつかのアップデートから始めましょう。

私たちは、macOS Big Surでデビューしたシステム全体の再設計への反応に興奮しています。

私たちのお気に入りのアプリの多くは、わずか数ヶ月で新しいデザインを採用するように更新されました。

macOS Montereyでは、この新しいデザインを反復して改良し続けているので、システム全体でいくつかの新しいタッチに気づくでしょう。

それらのいくつかは、新しいアニメーションで表示されて後退するポップオーバーや、クリックしたときにスムーズに所定の位置に滑り込むスライダーなど、大きくて目立つものもあります。

ツールバーコントロールの洗練されたメトリクスや、検索ボタンのバネローディングサポートなど、はるかに微妙な変更もあるので、テキストやトークンを簡単にドラッグできます。

そして、明快さを向上させるためにテーブルセクション間の間隔を増やしました。

私たちは、細部まで新しいデザインを反復し、強化し続けています。

そして、それはあなたがあなた自身のデザインを洗練するために使用できるいくつかのコントロールの強化につながります。

最初の大きなものはコントロールティンティングです。

個々のボタン、セグメント化されたコントロール、スライダーのカスタム着色を有効にしました。

これらの各コントロールは、これらのAPIの1つを使用してカスタムティントカラーを受け入れます：bezelColor、selectedSegmentColor、およびtrackFillColor。

タッチバーで個々のコントロールの着色を可能にするために、macOS SierraにこれらのAPIを導入しました。

そして、macOS Monterey以降、ウィンドウ内コントロールでも機能します。

要約すると、ほとんどのコントロールは、システム環境設定で設定可能なアクセントカラーを使用して描画します。

これにより、人々は自分の好きな色に合わせてMacをテーマにすることができます。

マルチカラーオプションを使用すると、各アプリは独自のカスタムカラーを定義できます。

広範なテーマについては、アプリのアセットカタログでカスタムアクセントカラーを定義できます。

新しい着色APIは、1つの特定のコントロールの色を上書きする方法を提供します。

これは、意味的に意味のある色を適用したいコントロールに最適です。

たとえば、アプリが特定のオレンジ色の色合いを使用して予約注文と通常の購入を区別する場合、着色されたボタンを使用してそのデザインを強化できます。

もう1つの例は、通話の開始ボタンと終了ボタンがアプリで最も意味のあるアクションの2つを実行するビデオ会議アプリです。

それらを緑と赤に着色すると強調され、その機能が即座に認識可能になります。

重要な注意点の1つは、着色されたボタンは、白や灰色の通常のプッシュボタンとは異なり、すべてのアクティブな状態で常に色合いの色を表示することです。

これはあなたの色合いの色を前面と中央に置きます。

ただし、カラフルな外観を使用するデフォルトのボタンと混同しないようにデザインに注意してください。

最後に、単なる色以上のものを使ってコントロールの目的を伝えることが重要です。

色を区別するのが難しい人は、特定のコントロールの目的を簡単に識別できるようにしたいので、必ず明確なラベルやアイコンを提供してください。

もう1つの重要なボタンのデザイン変更は、プッシュボタンがクリック時にアクセントカラーを使用して強調表示されなくなったことです。

これにより、セグメント化されたコントロールセグメント、スライダーノブ、ステッパーなど、他のクリック可能な要素と一致します。

これは重要な変更です。なぜなら、ハイライトされている間にカラフルな外観を想定したカスタム描画を行う場合、つまり、上に白いコンテンツを描画することを選択した場合、macOS Montereyでは正しく見えない可能性があるためです。

ハイライト状態をチェックする代わりに、interiorBackgroundStyleプロパティを使用して描画の決定を推進できます。

このプロパティは、ボタンベゼルの基礎となるスタイルを反映しているため、無色の状態には常に.normalを返し、着色されたボタン、デフォルトボタン、および「オン」状態に切り替えられたボタンなど、カラフルな強調状態に対して.emphasizedを返します。

最後に、以前はレギュラースクエアとして知られていたボタンのフレキシブルプッシュスタイルを更新し、可変高さのプッシュボタンとして機能しました。

通常のプッシュボタンと同じ構成をすべてサポートするようになりました。つまり、デフォルトのボタンとして機能し、色を塗ることができます。

コーナー半径とコンテンツパディングは、各コントロールサイズの標準プッシュボタンと一致するため、他のコントロールとうまく収まりますが、垂直方向のサイズ変更可能なデザインは、改行でより大きなアイコンやテキストに対応できることを意味します。

プッシュボタンの大部分は、標準の固定高さスタイルを使用し続ける必要がありますが、この新しく拡張されたスタイルは、背の高いコンテンツに対応する必要がある場合の特別なケースに柔軟性を提供します。

もう1つの非常に重要なコントロールアップデートは、メニューキーボードショートカットの自動ローカリゼーションの形で提供されます。

世界には多くのキーボードレイアウトがあり、キーボードショートカットのローカライズをかなり複雑にする可能性があります。

一部のキーボードでは手が届きにくいものもあれば、まったく入力できないものもあります。

さらに、いくつかの指向性キーボードショートカットは、本当に右から左の言語でミラーリングする必要があります。

素晴らしいニュースは、macOS Montereyでは、AppKitがあなたのためにそれを行うことができるということです。

ローカリゼーションの恩恵を受けることができるショートカットの例を次に示します。Command-backslashです。

これは米国の英語のキーボードではうまく機能しますが、実際にはバックスラッシュキーがまったくない日本語のキーボードで入力することは不可能です。

macOS Monterey以降、システムはショートカットを自動的に再マップし、自然に入力できる同等のショートカットを提供します。

もう1つの一般的なケースは、方向性の意味を持つキーボードショートカットです。

たとえば、Safariはコマンド二乗括弧を使用して、歴史を前後に進めます。

右から左の言語では、左の括弧を使用して戻るのはあまり直感的ではないため、AppKitは右から左の言語で実行するときに自動的に右の括弧に交換するようになりました。

この動作は、括弧、中括弧、括弧、矢印キーに適用されます。

場合によっては、このミラーリング動作を無効にしたい場合があります。

たとえば、メニュー項目に絶対的な方向性がある場合（たとえば、左揃えなど）は、右から左の言語でも左括弧を使用します。

このようなケースのオプトアウトを提供しました。

NSMenuItemのいくつかの新しいプロパティを使用して、この動作を制御できます。

allowsAutomaticKey EquivalentMirroringを使用すると、ブラケットなどの方向キーのミラーリング動作を制御でき、allowsAutomaticKey EquivalentLocalizationは、キーボードマッピングやミラーリングを含むすべてのローカリゼーション機能を制御します。

すでにキーボードショートカットを慎重にローカライズしている場合、またはアプリケーションにキーボードショートカットバインディングのカスタム実装がある場合は、アプリ全体でこの機能を無効にすることをお勧めします。

これを行うには、このアプリケーションデリゲートメソッドを実装し、applicationShouldAutomatically LocalizeKeyEquivalentsを実装し、falseを返すことができます。

ほとんどのアプリはこれを使用する必要はありません。

個々のメニュー項目APIは、特定の項目をオプトアウトするために強く好まれており、ほとんどのアプリはまったくオプトアウトする必要はありません。

次に、シンボル画像のいくつかの大きな機能強化。

私たちはBig SurのmacOSにSFシンボルをもたらし、すべてのMacアプリに美しく、タイポグラフィ的にバランスのとれたシンボル画像の大規模なレパートリーを開きました。

macOS Montereyでは、SFシンボル3と呼ばれる新世代のシンボルAPIとツールを構築しました。

これは、シンボル画像ワークフローのあらゆる側面にまたがる大きなアップデートであり、AppKitアプリケーションですべて利用できます。

SFシンボル3は、シンボル画像のプレビュー、エクスポート、インポートのためのSFシンボルアプリの機能を拡張します。

また、カスタムシンボルに注釈を付けるための更新されたフォーマットが付属しており、シンボル画像内に異なるレイヤーを定義することができ、AppKit、UIKit、SwiftUIのAPIを拡張して、シンボルの各レイヤーを個別に色付けできるようにしました。

ビッグサーでは、シンボルの2つの異なるレンダリングモードを提供しました。

まず、シンボル全体に単一の色合いの色または効果を使用して描画する伝統的なテンプレートスタイルがありました。

2つ目はマルチカラーで、フルカラー画像のように描画し、シンボル画像自体で定義されている色を使用して各パス要素を描画します。

SFシンボル3では、新しいシンボル画像フォーマットによって提供されるレイヤー情報を利用する2つの新しいレンダリングモードを追加しました。

最初のヒエラルキーは、シンボルの特定の部分を強調しながら、他のものを強調しながら、単一の色を使用して描画します。

そして2番目のパレットでは、シンボルの各レイヤーに好きな色を割り当てることができます。

NSImage.SymbolConfigurationの新しいAPIを使用して、これらのレンダリングモードにアクセスできます。

NSColorパラメータをドットとして表現して、レンダリングされたシンボルとどのように対応するかを示しています。

階層レンダリングモードは単一の色を取り、不透明度が減少してシンボルレイヤーに適用されます。

パレットモードは、レイヤーに逐語的に適用される色の配列を受け入れます。

マルチカラーレンダリングモードを好む設定を作成することもできます。

また、1つのベースシンボルからそのバリアントの1つにマッピングできる新しいAPIを追加しました。

たとえば、ハートのシンボルを塗りつぶされたバリアント、円のような刻まれたバリアント、さらにはスラッシュを含むバリアントにマッピングできます。

これは、特定のコンテキストで特定のスタイルのシンボルを好む状況で本当に便利です。

たとえば、選択されていない状態のアウトラインを好むピッカーコントロールがありますが、選択には塗りつぶされたスタイルがあります。

通常、このコントロールでは、画像の選択されたバージョンと未選択のバージョンを指定するために、2つの異なる画像プロパティが必要になります。

しかし、バリアントAPIを使用すると、単一のベースシンボルを受け入れ、満たされた状態を自動的に導き出すことができます。

このコントロールは、image(with: .fill)を呼び出すことができ、選択状態で塗りつぶされたシンボルを好むことができ、塗りつぶされたバリアントが利用可能なときはいつでも、シンボルの適切なバージョンを自動的に選択します。

シンボルバリアントの種類ごとに定数があり、それらを組み合わせて、円や塗りつぶしなどの複数のバリアントを一緒に要求することができます。

これは、SFシンボル3の機能の簡単な紹介でした。

シンボルワークフロー全体で新しいすべての詳細を入手できる新しいビデオコレクションがあります。

必ずウォッチリストに追加してください。

macOS Montereyは、TextKit 2の形でテキストシステムの大幅なアップデートも備えています。

TextKitは、すべてのAppleデバイス用のテキストレイアウトとレンダリングエンジンであり、実績のある優れたテキストエンジンです。

TextKitは線形テキストレイアウトエンジンです。つまり、テキストのブロックを最初から最後までタイプします。

プラットフォームと技術を進化させるにつれて、非線形テキストレイアウトがはるかに役立つケースが多く見つかりました。

そこで、基本に戻り、TextKitの新しいバージョンを作成しました。それはTextKit 2です。

TextKit 2にはいくつかの重要な目標がありました。

いつものように、私たちはすべてのスクリプトとレイアウトの国際的なテキストに最高の体験を提供したいと考えています。

また、テキストを他の種類のコンテンツと簡単に混在させたいと考えています。

そして最後に、TextKit 2は、短いラベルであろうと、大規模なドキュメントの途中でスクロールされるであろうと、テキストを超高速で効率的に整形し、レンダリングするように設計されています。

TextKit 2はTextKit 1と共存しているため、特定のテキストビューに使用するエンジンを選択できます。

今、私はあなたに秘密を教えます。

Big Sur以降、TextEditはプレーンテキストドキュメントに使用し、AppKitテキストフィールドはほとんどの設定にTextKit 2を使用するため、すでにMacでTextKit 2を実行しています。

だから、あなたは実際にこの間ずっとスニークピークを得ています。

TextKit 2の主な違いの1つは、常に非線形レイアウトシステムを使用していることです。

つまり、テキストレイアウトをより詳細なレベルで実行できるため、不要な作業を回避できます。

たとえば、テキストの一部のみがスクロールして表示される大きなドキュメントがある場合、線形システムは、この領域を表示するために、以前のテキストをすべてレイアウトする必要があります。

比較すると、TextKit 2のような非線形システムは、最も近い段落境界でレイアウトを開始できます。

大規模な文書の場合、これは大きなスピードアップです。

新しいレイアウトエンジンは、堅牢なカスタマイズポイントセットを提供し、レイアウトシステムを拡張して独自の動作を簡単に追加できるようにします。

非線形レイアウトシステムは、非テキスト要素をテキストレイアウトに混在させるのにも適しています。

そして、最大のドキュメントでもパフォーマンスを向上させながら、これらすべてを行います。

詳細については、新しいAPIの設計とその使用方法について詳しく説明する「Meet TextKit 2」をチェックしてください。

次に、並行性から始まるSwiftのAppKitに関するいくつかのアップデートを共有したいと思います。

Swift 5.5では、並行性を管理するための重要な言語レベルの機能をいくつか導入しています。

最初のasync/awaitは、コルーチンのように振る舞う非同期メソッド呼び出しを可能にします。

2番目のアクタータイプは、単一の実行スレッドへのアクセスを分離することで、データレースから変更可能な状態を保護します。

AppKitは、これらの新機能の両方でうまく機能します。

非同期/待機の場合、AppKitの多くの非同期メソッド、つまり、補完ハンドラブロックとして継続を取るメソッドは、非同期バリアントも提供するためにSDKで変換されています。

1つの簡単な例は、ユーザーが画面上のどこからでも色を選択できるNSColorSamplerです。

この呼び出しは、ユーザーが好きな色を選択するのを待ってから、完了したら完了ハンドラを実行するため、非同期です。

Async/awaitを使用すると、これを非同期関数呼び出しとして表現できます。

非同期作業が完了するのを待っている間に実行スレッドを生成し、中断したところから右に戻ります。

ガードステートメント内から行うこともできます。

これで、継続（次に実行する作業）は、完了ハンドラブロック内にネストされなくなりました。

代わりに、コードは自然に順番に読み込まれます。

アクターは、実行の単一のスレッドに分離することで、状態を同時アクセスから保護するために働きます。

それが聞き覚えがあるなら、ビュー階層やレスポンダーチェーンなど、AppKitの状態のほとんどは、単一の実行スレッド、特にメインスレッドからもアクセスする必要があるためです。

この制限はアクターモデルにうまく適合するので、メインスレッドからアクセスしなければならないタイプであるメインアクターの概念を導入しました。

AppKitでは、NSView、ViewController、WindowController、Applicationのサブクラスを含むNSResponderと、NSCell、Alert、Document、DocumentControllerをMainActorsとして指定しました。

MainActorで実行されているコードは、すでにメインスレッドにいることを知っているので、他のMainActorタイプのメソッドを自由に呼び出すことができます。

ただし、MainActorで実行されていないコードは、MainActorのコンテキストでそのUI作業を実行するために、新しい非同期/待機機能を使用する必要があります。

これをコンパイラレベルで強制することで、Swiftは並行性とUIコードを混在させる際のバグの一般的な原因を回避するのに役立ちます。

Swiftの並行性ビデオは、この強力な新言語機能について深く掘り下げています。

あなたはそれらを見逃したくありません。

また、Swift 5.5の新機能には、AttributedStringの値型バージョンがあります。

価値セマンティクスを提供することに加えて、タイプセーフな属性と、属性の範囲を列挙および操作するための優れたSwift人間工学も備えています。

AppKitでAttributedStringを使用すると、テキスト描画システムに関連する属性に自動的にアクセスできます。前景色、段落スタイルなどです。

Struct AttributedStringと参照型のNSAttributedStringの間で変換できるため、NSAttributedStringを使用するAPIと相互運用できます。

「What's new in Foundation」ビデオでは、AttributedStringのデザインとその使用方法について詳しく説明します。

最後のSwiftの機能強化は、NSViewsの更新の推進に関係しています。

Swiftのプロパティラッパー機能を使用して、ビュープロパティに共通するボイラープレートを劇的に減らします。

例を見てみましょう。例を見てみましょう。

これは、一握りのプロパティを介して設定可能なカスタムビューです。

そして、これは問題ないように見えますが、現実には、私たちのビューのプロパティ宣言には、多くのdidSetと余分な副作用が含まれている可能性がはるかに高いです。なぜなら、何かが変更されたときに再描画、またはレイアウト、または制約を更新する必要があるからです。

さて、それは多くのボイラープレートです。

そのため、このケースのためだけに新しいSwiftプロパティラッパーを作成することで、このシナリオをより良くしました。

それは無効化と呼ばれています。

NSViewの下にネストされており、ラップされたプロパティが変更されたときに無効にするビューの1つ以上の側面を指定できます。

didSetとブラケットはすべて消えてしまうため、プロパティ自体の定義に集中しやすくなります。

AppKitは、表示、レイアウト、制約、固有のコンテンツサイズ、および回復可能な状態など、いくつかの組み込みの無効化ケースを提供します。

これらの無効化はビューでのみ意味をなすため、NSViewのサブクラスでのみ機能するようにプロパティラッパーを制約しました。

また、値がEquatableに準拠していることも要求します。

この適合性を使用して、潜在的に高価な再描画またはレイアウトパスを実行する前に、値の有意義な変更を確認します。

カスタムをしたい場合は、NSViewInvalidatingプロトコルにタイプを適合させることで、独自の無効化を定義することもできます。

最後に、ショートカット。

macOS Montereyでは、ショートカットのフルパワーをMacにもたらすことに興奮しています。これには、ショートカットをAppKitアプリと統合することが含まれます。

素晴らしいニュースは、アプリがサービスをサポートしている場合、すでにショートカットをサポートしており、ショートカットは今日のサービスにアクセスできるすべての同じ場所に表示されることです。

この機能に慣れていない場合は、採用するのは本当に簡単です。

AppKitは、レスポンダーチェーンをチェックすることで、どのショートカットが文脈的に適切かを決定します。

各応答者は、各ショートカットで期待されるデータの種類を提供または受信できるかどうかを尋ねます。

ほとんどの場合、統一型識別子に対応するペーストボード型を使用してこれを表現します。

あなたがしなければならないのは、sendTypeとreturnTypeメソッドのvalidRequestorを実装することだけです。

また、指定されたタイプを受け入れたり提供したりできる場合は、NSServicesMenuRequestorプロトコルに準拠したオブジェクトを返します。

ほとんどの場合、そのプロトコルを直接実装してから自己を返すだけです。

ショートカットが呼び出されると、ショートカットが入力と出力に使用する特別なペーストボードからデータを書き込むおよび/または読み込むための呼び出しが取得されます。

そして、それだけです!

アプリをショートカットと統合するのはとても簡単です。

また、Siri IntentsをmacOSにもたらしました。

XcodeでIntents Extensionを作成することで、Intentsを処理できるようになりました。

または、メインアプリケーションからそれらを処理する必要がある場合は、アプリケーションデリゲートからインテントハンドラを返すことができます。

アプリデリゲートで、application handlerFor intent:メソッドを実装し、処理できるインテントのハンドラーオブジェクトを返します。

すべてのタイプのインテントには、返されたオブジェクトが準拠しなければならない独自のハンドラープロトコルがありますので、ハンドラーオブジェクトの実装の詳細については、インテントフレームワークのドキュメントを確認してください。

この新しい情報がすべて揃ったので、次は何ですか?

まず、コントロールティンティングやSFシンボル3などの機能が、アプリのデザイン強化にどのように役立つかを考えてください。

次に、アプリがTextKitを使用してカスタムテキストエクスペリエンスを作成する場合は、「Meet TextKit 2」ビデオを見て、新しいAPIを試してみてください。

TextKit 2でカスタムレイアウトや豊富なコンテンツを表現するのがいかに簡単かを気に入るはずです。

アプリが並行性を管理する方法は、そのアーキテクチャの重要な部分であり、Swiftの新しい並行性機能は、この分野で大きな改善になります。

今、async/awaitなどの機能が、アプリが同時ワークロードを管理する方法をどのように形成するかの計画を開始する時です。

最後に、AppKitの自動化機能を採用して、アプリをショートカットに備えましょう。

あなたの時間と注意に感謝します。

macOS Montereyでこれらの素晴らしい機能強化をすべて楽しんでいただければ幸いです。

♪