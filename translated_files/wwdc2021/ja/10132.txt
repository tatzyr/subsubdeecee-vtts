10132

♪ ♪

こんにちは、私はアップルのSwiftチームのエンジニア、ネイトです。

今日、同僚のロバートと私は、スウィフトでの非同期/待機についてお話しします。

非同期プログラミングは、多くの人にとって定期的な活動です。

だから、冗長で、複雑で、さらには正しくない非同期コードを書くのは簡単すぎることを知っています。

SwiftのAsync/awaitが役に立ちます。

それを使用すると、通常のコードを書くのと同じくらい簡単に非同期コードを書くことができます。

そして、あなたがそうするとき、あなたのコードはあなたのアイデアをよりよく反映するでしょう。

それもより安全でしょう。

その上、SDKには何百もの待機可能なメソッドがあります。

たとえば、UIKitはUIImageからサムネイルを形成する機能を提供します。

実際、そのタスクを完了するために、同期機能と非同期機能の両方を提供します。

簡単なリマインダーとして、同期している関数、つまり通常の古い関数を呼び出すと、スレッドがブロックされ、その関数が終了するのを待ちます。

したがって、fetchThumbnail関数が準備サムネイルを呼び出す場合--同期関数UIKitが提供する--それが終わるまで、あなたのスレッドは他に何もできません。

対照的に、その関数の非同期バージョンであるprepareThumbnail (of:completionHandler:)を呼び出すと、スレッドは他の作業を自由に行うことができます。

完了したら、完了ハンドラを呼び出すことで通知します。

SDKは多くの非同期機能を提供します。

彼らはいくつかの異なる方法で完了したことをあなたに知らせます。

このような完了ハンドラを使用する人もいます。

他の人はデリゲートコールバックに依存しています。

そして、多くは非同期とマークされ、値を返すだけです。

これらの非同期関数に共通しているのは、これを呼び出すと、スレッドのブロックをすばやく解除し、作業を開始することです。

これにより、長時間の作業が完了している間、スレッドが他のことをすることができます。

その違いを見るために、多くのおなじみの例を見てみましょう。

ロバートと私が一緒に構築しているアプリでは、アイテムのリストがあり、各行にはサーバーに保存されている画像のサムネイルが表示されます。

サムネイルをそのリストに表示する準備をするとき、ビューモデルでは、fetchThumbnailメソッドが呼び出されます。

一連のステップで文字列をUIImageに変換します。

まず、ビューモデルの thumbnailURLRequest メソッドは、文字列から URLRequest を作成します。

次に、URLSessionのdataTaskメソッドは、そのリクエストのデータを取得します。

次に、UIImage initWithDataはそのデータから画像を作成し、最後にUIImageのprepareThumbnailメソッドは元の画像からサムネイルをレンダリングします。

これらの各操作は、前の結果に依存します。

つまり、それらは順番に実行されなければならないということです。

これらの操作のいくつかは、値をすばやく返します。文字列からURLRequestを構築し、データからUIImageを構築することはどちらもこんな感じです。そのため、関数がたまたまオンになっているスレッドで実行し、これらを同期呼び出しにすることは問題ありません。

しかし、そのうちのいくつかは時間がかかります。

画像を構成するすべてのデータをダウンロードするにはしばらく時間がかかります。

そして、そこから見栄えの良いサムネイルをレンダリングするには、高価な作業を行うためのデバイスが必要です。

そのため、SDKはこれらのタスクを完了するための非同期機能を提供します。

したがって、これらの呼び出しは非同期であるべきです。

Robertと私がasync/awaitでスピンを取る前に、完了ハンドラを使用して関数を書いていました。

この関数は、文字列、最初の操作への入力、および出力を呼び出すために使用される完了ハンドラを引数として受け取ります。

fetchThumbnailが呼び出されると、まずthumbnailURLRequestを呼び出します。

このメソッドは同期的であるため、完了ハンドラは必要ありません。

次に、共有URLSessionインスタンスでdataTaskを呼び出し、そのURLRequestと完了ハンドラを渡します。

同期的にURLSessionDataTaskを生成し、非同期作業を開始するために再開する必要があります。

その後、FetchThumbnailが戻り、スレッドは他の作業を自由に行うことができます。

画像のダウンロードには時間がかかり、データがストリーミングされるのを待っているスレッドをブロックしたくないので、それは本当に重要です。

最終的に画像のダウンロードが完了するか、何かがうまくいかないかのどちらかです。

いずれにせよ、要求は完了し、dataTaskに渡された完了ハンドラは、データ、応答、およびエラーのいくつかのオプション値で呼び出されます。

何か問題が発生した場合は、完了ハンドラを呼び出してエラーを渡す必要があります。

すべてがうまくいった場合は、UIImageのinitWithDataを使用してデータから画像を作成します。

同期しているため、結果を処理するために通常の直線コードを書くことができます。

画像が生成されなければ、完了です。

そして、画像が生成された場合、最後にUIKitのメソッドprepareThumbnailを呼び出して、完了ハンドラを渡します。

その作業が完了している間、スレッドはブロック解除され、他の作業を行うために解放されます。

サムネイルが準備された後、サムネイルの準備が成功した場合、またはnilの場合、その完了ハンドラは画像で呼び出されます。

成功した場合は、完了ハンドラを呼び出すと、画像を渡します。

しかし、ロバートが私に指摘したように、問題があります。

FetchThumbnailの発信者は、失敗した場合でも、fetchThumbnailが作業を終了したときに通知されることを期待しています。

そして現在、私たちは発信者を置き去りにしています。

私は「guard else return」を書くのに慣れているので、完了ハンドラを2回呼び出すのを忘れました。

したがって、データからのUIImageの作成やサムネイルの準備に失敗した場合、fetchThumbnailの呼び出し者に通知されることはなく、行も更新されません。

それは永遠にスピナーを見せるだけです。

だからこそ、fetchThumbnailの著者である私たちにとって、何が起こっても発信者に通知することが非常に重要です。

したがって、機能を通るすべてのパスは、それらを通知する必要があります。

これを行うには、エラーが発生した場合に完了ハンドラを呼び出し、エラーを渡す必要があります。

通常の関数は、それをスローすることで呼び出し元にエラーを返します。

そして、Swiftは、関数を通じて実行がどのように進行しても、値が返されない場合、エラーがスローされることを保証します。

しかし、ここではSwiftの通常のエラー処理メカニズムを使用することはできません。

問題が発生した場合、これらの完了ハンドラ内からエラーをスローすることはできません。

スウィフトが私たちの仕事をチェックできないことを意味するので、それは残念です。

Swiftにとって、fetchThumbnailsのような補完ハンドラは単なるクロージャです。

常に呼び出されていることを確認したいのですが、Swiftではそれを強制する方法はありません。

だからこそ、その2人の警備員から戻ったときにコンパイルエラーが発生しませんでした。

ロバートは、私がそれを修正するのに問題があることを指摘しました。

したがって、完了ハンドラが最終的に呼び出されることを確認するのはあなた次第です。

私たち二人がこの関数を書くために座ったとき、私たちは次から次へいくつかの操作をしたかっただけです。

2つは同期で、2つは非同期で、完了ハンドラを取りました。

私たちは成功しましたが、微妙なバグが忍び寄る5つの機会を含む約20行のコードで終わりました。

私たちが望んでいたのは、これらの4つの操作を順番に実行することでしたが、私たちが得たものは従うのが難しく、正しく理解するのが難しく、私たちの意図を覆い隠しています。

さて、これをもう少し安全にする方法があります。

たとえば、標準ライブラリの結果タイプを使用できました。

そして、これは少し安全ですが、それはまた式典を追加し、私たちのコードを醜く、わずかに長くします。

人々はまた、他の方法で非同期コードを改善するために先物のような技術を使用しています。

しかし、これらのアプローチのいずれも、シンプルで簡単で安全なコードを提供してくれません。

Async/awaitで、私たちはもっとうまくやることができます。

ロバートと私は、これらの4つのステップを実行する機能を書き直しました。

そして今回は、async/awaitを使用しました。

この関数は依然として文字列を引数として取ります。

しかし、前回は完了ハンドラも渡されましたが、今回は代わりに関数は非同期です。

関数を非同期にマークするとき、キーワードはこのように関数署名の「スロー」の直前、または関数がスローしない場合は矢印の前に行く必要があります。

関数を非同期にマークすると、それとその署名がより簡単になります。

画像のサムネイルが正常に実行されると、そのサムネイルは単に返されます。

そして、エラーが発生した場合、それはただスローされます。

fetchThumbnailが呼び出されると、以前と同じように、thumbnailURLRequestを呼び出すことで始まります。

この関数は同期的であるため、スレッドはブロックされ、その作業を行います。

次に、共有URLSessionでdata(for: request)を呼び出すことで、データのダウンロードを開始します。

dataTaskと同様に、このメソッドはFoundationによっても提供され、非同期でもあります。

しかし、dataTaskとは異なり、データメソッドは待機可能です。

だから、それが呼び出された後、それはすぐに自分自身を一時停止し、スレッドのブロックを解除します。

その後、スレッドは他の作業を自由に行うことができます。

データメソッドが「スロー」とマークされているため、「トライ」がここにあります。以前のバージョンでは、エラーをチェックし、完了ハンドラを明示的に呼び出す方法を覚えていますか?

ここ待機可能なバージョンでは、そのコードはすべてtryキーワードだけに煮詰められています。

「Throws」とマークされた関数を呼び出すために「try」が必要なように、「await」は「async」とマークされた関数を呼び出すために必要です。式に複数の非同期関数呼び出しがある場合、複数のスロー関数呼び出しを持つ式に対して1つの「試行」だけを必要とするのと同じように、「await」を一度だけ書く必要があります。

全体として、関数呼び出しは「try await」とマークされています。スローする非同期式を扱うときは、このように待つ前にtryを置く必要があります。

最終的に、データのダウンロードが完了すると、データメソッドが再開され、fetchThumbnailに戻ります。

その時点で、データメソッドが返す値またはスローするエラーが流れ込みます。

エラーをスローした場合、fetchThumbnailはそのエラー自体を順番にスローします。

それ以外の場合は、データ変数と応答変数が定義されます。

これは、URLSessionのdataTaskメソッドに渡された完了ハンドラが呼び出されたときの以前のバージョンのfetchThumbnailで起こったことと似ています。

どちらのバージョンでも、URLSessionの非同期メソッドによって生成された値とエラーが流れ込みました。

しかし、待ち時間のあるバージョンはとてもシンプルです。

それは私たちが何を意味するのかを正確に述べています。

このリクエストを行い、変数に戻す値を割り当てて、それらを使用できるようにします。

そして、問題に遭遇した場合は、エラーをスローします。

次に、fetchThumbnailはダウンロードしたデータからUIImageを作成しようとします。

それが成功すると、サムネイルプロパティにアクセスすることで、その画像のサムネイルがレンダリングされます。

サムネイルが形成されている間、サムネイルプロパティが最終的に再開され、fetchThumbnailに戻るまで、スレッドは他のことを自由に行うことができます。

サムネイルがレンダリングされると、fetchThumbnailがそれを返します。

そうでなければ、エラーがスローされます。

完了ハンドラーバージョンとは対照的に、サムネイルがレンダリングされない場合、Swiftはここでエラーをスローするか、値を返すことを保証します。

しかし、私たちは黙って失敗することはできません。

そして、それだけです。それが私たちが必要とするすべてのコードです。

この関数は、完了ハンドラのバージョンが以前とまったく同じことをします。

しかし、20行のコードの代わりに、6行しかない。

そして、それはすべて直線コードです。

順番に実行する必要がある4つの操作は、次々にリストされています。

そして、Swiftは、関数が完了したときに、問題が発生した場合に返すか、投げることによって、常に呼び出し元の呼び出し者に通知することを確認します。

これは、async/awaitを使用して非同期Swiftコードを変換し、より安全で短くし、意図をよりよく反映させる方法の一例にすぎません。

fetchThumbnailの実装方法の詳細を掘り下げてみましょう。

最後から2行目では、関数呼び出しがないにもかかわらず、サムネイルのレンダリングを開始する式は「await」とマークされています。それは、サムネイルプロパティが非同期だからです。

関数だけでなく、非同期にすることができます。

プロパティもできますし、初期化子もできます。

現在、サムネイルプロパティはSDKの一部ではありません。

それは実際にロバートが付け加えたものです。

それを見てみましょう。 てみましょう。

彼はUIImageの拡張機能でこのプロパティを定義し、その実装は短いです。

それはCGSizeを形成し、PreparingThumbnail(ofSize)によってそれを渡す結果を待っています。

ところで、selfのこのメソッドは、以前に使用したメソッドの待機可能なバージョンです。

注目すべきことがいくつかあります。

まず、それは明示的なゲッターを持っています。

これは、プロパティを非同期にマークするために必要です。

スウィフト5.5では、プロパティゲッターも投げることができます。

また、非同期関数シグネチャと同様に、プロパティが非同期とスローの両方である場合、非同期キーワードはスローの直前になります。

第二に、プロパティにはセッターがありません。

読み取り専用プロパティのみを非同期にすることができます。

関数、プロパティ、および初期化子では、関数がスレッドのブロックを解除する可能性のある場所を示すために式でawaitを使用できます。

待っている場所も使用できる別の場所があります。forループで非同期シーケンスを反復します。

非同期シーケンスは、要素を非同期に販売することを除いて、通常のシーケンスと同じです。

したがって、次のアイテムを取得するには、非同期であることを示すawaitキーワードでマークする必要があります。

関数が非同期シーケンスを何度も反復すると、次の要素を待っている間にスレッドのブロックを解除し、次の要素でループの本体に戻るか、要素が残っていない場合はループの後に再開することがあります。

AsyncSequenceの詳細については、「Meet AsyncSequence」セッションをご覧ください。

また、多くの非同期タスクを並行して実行することに興味がある場合は、「Swiftでの構造化された並行性」セッションをチェックしてください。

だから、アウェイを使用できる場所がたくさんあります。

キーワードは、非同期関数がそこで一時停止する可能性があることを示します。

非同期関数が一時停止するとはどういう意味ですか?

それに答えるために、関数を呼び出すと何が起こるかを考えてみましょう。

任意の関数を呼び出すときは、関数が実行されているスレッドをその関数に制御します。

ここのthumbnailURLRequestのように、呼び出している通常の関数の場合、スレッドは終了するまでその1つの関数に代わって作業して完全に占有されます。

その作業は、関数自体の本体、またはそれが呼び出す他の関数にある可能性があります。

最終的には、その関数は値を返すか、エラーをスローすることによって終了します。

そうすると、それはあなたの機能にコントロールを戻します。

これは、通常の関数がスレッドの制御を放棄できる唯一の方法です。

そして、あなたの機能は、それが制御を与えることができる唯一のものです。

あなたが呼び出している非同期関数であれば、状況は異なります。

通常の関数のように、完了すると、終了し、コントロールを関数に戻します。

しかし、通常の機能とは異なり、サスペンドすることで、まったく異なる方法でスレッドの制御を放棄することができます。

通常の関数と同様に、非同期関数を呼び出すと、スレッドを制御できます。

実行されると、非同期関数は一時停止できます。

そうすると、スレッドの制御をあきらめます。

しかし、あなたの機能に制御を返すのではなく、代わりにシステムにスレッドの制御を与えます。

それが起こると、あなたの機能も中断されます。

一時停止は、「あなたがやるべきことがたくさんあることを知っています」とシステムに伝える機能の方法です。

何が最も重要なかを決めるのはあなたです。それはどれくらい協力的ですか?

したがって、関数がそれ自体を一時停止すると、システムはスレッドを使用して他の作業を自由に行うことができます。

ある時点で、システムは、最も重要な作業は、以前に中断していた非同期関数の実行を継続することであると判断します。

その時点で、システムはそれを再開します。

その非同期関数は、スレッドの制御に戻り、その作業を続けることができます。

そして、それが望むなら、それは再び自分自身を中断することができます。

実際、それは必要なだけ何度でも自分自身を中断することができます。

一方、それはまったく自分自身を中断する必要はないかもしれません。

非同期関数は一時停止するかもしれませんが、非同期とマークされているからといって、必ずしも一時停止するとは限りません。

そして、同様に、「待機」が表示されたからといって、機能が間違いなくそこで中断されるわけではありません。

しかし、最終的には、一時停止しなくても、または最後に再開した後でも、関数は終了し、値やエラーとともにスレッドの制御を関数に戻します。

fetchThumbnailをもう一度見て、一時停止時に何が起こるかを見てみましょう。

fetchThumbnailがURLSessionの非同期データメソッドを呼び出すと、データメソッドは、非同期関数のみが一時停止できる特別な方法でスレッドでの実行を停止します。

スレッドをシステムに制御し、URLSessionのデータメソッドの作業をスケジュールするようにシステムに要求します。

しかし、現時点では、システムは制御されており、その作業はすぐには開始されない可能性があります。

スレッドは代わりに他のものに使用できます。

それがどのように起こるか見てみましょう。

fetchThumbnailが呼び出された後、ユーザーがいくつかのデータをアップロードするボタンをタップするとします。

例えば、彼らが投稿に反応するとします。

その後、システムは、以前にキューに入れられた作業の前に、ユーザーの反応を投稿する作業を自由に実行できます。

その遅い作業が完了すると、URLSessionのデータメソッドが再開される可能性があります。

または、システムは代わりに他の作業を実行するかもしれません。

最後に、データメソッドが終了すると、fetchThumbnailに戻ります。

関数が中断されている間に他の作業を実行できるという事実は、Swiftがawaitキーワードで非同期呼び出しをマークすることを主張する理由です。

機能が一時停止すると、アプリの状態が劇的に変化する可能性があることを認識する必要があります。

さて、これは完了ハンドラを使用する場合にも当てはまります。

しかし、async/awaitコードに伴うすべての儀式とインデントがないため、awaitキーワードは、コードのブロックが1つのトランザクションとして実行されないことに気付く方法です。

関数は一時停止する可能性があり、関数の行間で中断されている間に他のことが起こる可能性があります。

それ以上に、この関数はまったく異なるスレッドに再開される可能性があります。

これらの問題について学ぶには、「Swiftアクターで可変状態を保護する」セッションを参照してください。

Async/awaitについて覚えておくべき重要なことがいくつかあります。

まず、関数を非同期にマークすると、一時停止を許可します。

そして、関数が自分自身を一時停止すると、その呼び出し者も一時停止します。

したがって、その呼び出し者も非同期でなければなりません。

第二に、非同期関数で1回または何度も一時停止する可能性がある場所を指摘するために、awaitキーワードが使用されます。

第三に、非同期関数が中断されている間、スレッドはブロックされません。

そのため、システムは自由に他の作業をスケジュールできます。

後でキックオフされる作業でも、最初に実行できます。

つまり、機能が中断されている間、アプリの状態は大いに変わる可能性があります。

最後に、非同期関数が再開されると、それが呼んだ非同期関数から返された結果は元の関数に戻り、実行は中断したところから続きます。

Swiftでasync/awaitがどのように機能するかを見てきました。

今、ロバートはあなた自身のプロジェクトでそれを使い始める方法を紹介します。

ありがとう、ネイト。

以前、ネイトは私たちが一緒に構築しているアプリを見せてくれました。

彼がasync/awaitを採用するように変換したサムネイル関数は、いくつかの場所で呼び出されたため、並行性を採用するためにそれらを移行する必要があります。

現代のソフトウェア開発にとって重要なもの、つまりテストから始めましょう。

非同期コードのテストが同期コードのテストと同じくらい簡単であることを望んでいたので、XCTestは箱から出して非同期をサポートしています。

以前は、期待を設定し、テスト中のAPIを呼び出し、期待を満たし、任意の時間を待つという面倒なプロセスであったことは、テスト関数に非同期キーワードを追加し、XCTestの期待、そのフルフィルメント、および明示的な待機を削除し、代わりにネイトが以前に示した新しい非同期fetchThumbnail関数を呼び出す結果を待つのと同じくらい簡単になります。

テストが解決したので、アプリケーションコード自体を拡大しましょう。

特に、このリストの各行のサムネイルビューの背後にあるSwiftUIコード。

画像セルは投稿で作成され、各投稿にはビューモデルに渡すIDがあり、サムネイルを非同期に取得できます。

あなたはすでにテストコードからこの呼び出しを変換する方法を見たので、試してみましょう。

まず、完了ハンドラを削除し、次にエラーを処理するために「try」が追加され、非同期関数の呼び出しを完了するために「await」が追加されます。

しかし、このコードを構築しようとすると、何かがうまくいかない。

Swiftコンパイラは、それ自体が非同期ではないコンテキストで非同期関数を呼び出すことはできないと言っています。

ここでは、onAppear修飾子はプレーンで非非同期クロージャを取るため、同期世界と非同期世界の間のギャップを埋める方法が必要です。

解決策は、非同期タスク関数を使用することです。

非同期タスクは、クロージャ内の作業をパッケージ化し、グローバルディスパッチキューの非同期関数のように、次の利用可能なスレッドですぐに実行するためにシステムに送信します。

ここでの主な利点は、同期コードを同期コンテキスト内から呼び出すことができることです。

別の再構築の後、コンパイラは満足しています。

非同期タスクは、使い慣れた自然に構造化されたスタイルで豊富な同時Swiftコードを構築できるAPIファミリーの一部です。

詳細については、「Swiftで構造化された並行性を調べる」を参照してください。また、SwiftUIアプリで非同期コードを最大限に活用する方法については、「SwiftUIで並行性を発見する」を参照してください。fetchThumbnail関数と呼んでいたすべての場所の移行が完了しました。

しかし、私たちのアプリには、async/awaitを採用する機会がたくさんあります。

迅速に起動して実行するには、既存のAPIに代わる非同期の代替手段で小さく始めることをお勧めします。

SDKは、非同期の方法であなたに代わって動作するため、完了ハンドラを取る何百ものAPIを提供します。

これらのAPIが並んで並ぶと、パターンが現れ始めます。

名前や目的が異なる場合がありますが、これらの機能はすべて同じ必須API契約を持っています。

あなたは彼らに電話し、彼らは提供された完了ハンドラーであなたに電話をかけ直し、彼らが得た結果を渡します。

以前、ネイトは、より自然に見えるコードを書くために非同期関数の結果を待つことができることを示しました。

これらのコールバックブロックをこれらの非同期関数に変えることができれば、それは素晴らしいことではないでしょうか?

Swift 5.5の時点で、これはまさに起こることです。

Swiftコンパイラは、Objective-Cからインポートされた完了ハンドラコードを自動的に調べ、非同期の代替手段を提供します。

しかし、私たちはそこで止まりませんでした。

多くのデリゲートAPIには、完了ハンドラを渡すメソッドも含まれています。

ハンドラーを呼び出すと、非同期タスクが完了したときにフレームワークに協力して通知します。

fetchThumbnailを呼び出して、特定の投稿のタイムラインエントリを表示するこのClockKitコンプリケーションデータソースを取ります。

以前と同様に、すべてのパスで完了ハンドラーを呼び出す必要があります。また、閉鎖のため、ここには余分なノイズがたくさんあります。

Async awaitでは、これはもはやそうである必要はありません。

このデリゲートメソッドには、代わりに使用できる非同期の代替手段があります。

まず、先頭の「get」をドロップする非同期代替の名前が使用されます。非同期関数は、呼び出しの結果が直接返されないときに通信する「get」のような先頭の単語を省略することをお勧めします。

結局のところ、これは非同期の代替関数であるため、タイムラインエントリを直接返します。

非同期コンテキストが設定されたので、fetchThumbnailの非同期バージョンを呼び出します。

最後に、現在削除された完了ブロックを呼び出すのではなく、このメソッドからタイムラインエントリを返します。

ここで強調した非同期APIは、表面をかろうじて傷つけます。

詳細については、API自体と、async/awaitを採用する際の使用方法について詳しく説明するこれらのセッションを参照してください。

これらはすべて、Swiftがあなたに代わって非同期の代替案を作成する状況の例です。

しかし、必然的にコードには、自分で非同期の代替案を作成する必要がある場所があります。

これが実際にどのように見えるか見てみましょう。

私たちのアプリでは、このgetPersistentPosts機能を使用して、コアデータストアに保持した投稿を取得します。

この関数は、非同期サムネイル関数よりも多くの場所でアプリ内で呼び出されるため、どこでも非同期を使用するのは本当に大きな変化になります。

そして、NSAsynchronousFetchRequestを使用しているので、この関数は非同期の代替案の完璧な候補のようです。

まず、非同期関数を作成し、戻り値を変換します。

この関数はエラーが発生する可能性があるため、この関数も「スロー」とマークします。

次に、getPersistentPostsの完了ハンドラーバージョンを呼び出し、今、私たちは立ち往生しています。

コールバックの結果を、async persistentPosts関数の呼び出しを待っている場所に返す必要があります。

それだけでなく、これらの発信者は中断状態にあります。

彼らが残りの仕事に取り掛かることができるように、適切なタイミングで適切なデータでそれらを再開する必要があります。

以前、ネイトは、スウィフトとシステムが私たちのために非同期コードを再開するためにどのように協力するかを示しました。

この一時停止/再開プロセスがどのように機能するかをもう少し深く掘り下げて、問題に対して同様の解決策を考え出すことができるかどうかを確認します。

persistentPostsの非同期バージョンが呼び出されると、Core Dataが呼び出されます。

後で、Core Dataは完了ハンドラを呼び出し、フェッチ要求の結果を渡します。

この状況は、fetchThumbnail関数がCore Dataではなくシステムに一時停止された非同期関数呼び出しを再開するように要求したときに、Nateが以前に示したものとほぼ同じように見えます。

欠けているのは、完了ハンドラを待ち、フェッチ要求の結果を再開するためのブリッジだけです。

このパターンは常に登場し、名前があります：続き。

このセッションを通して、ネイトと私はすでに継続の例をたくさん見せました：完了ブロックを取る方法。

メソッドの呼び出し者は、関数呼び出しの結果を待ち、次に何をすべきかを指定するクロージャを提供します。

関数呼び出しが完了すると、完了ハンドラを呼び出して、呼び出し元が結果でやりたいことを再開します。

この種の協調的な実行は、まさにSwiftの非同期関数の仕組みです。

これを明示するために、Swiftは、高レベルで安全な方法で継続を作成、管理、再開できる機能を提供します。

例に戻って、継続が非同期の代替案の作成を完了するのにどのように役立つかを見てみましょう。

withCheckedThrowingContinuation関数は、非同期Swift関数をスローするエラーで完了ブロックを持ち上げます。

関数が決してエラーをスローしないことを知っている状況に対して、withCheckedContinuationsと呼ばれるカウンターパートがあります。

これらの関数は、中断された非同期関数を再開するために使用できる継続値にアクセスする方法です。

これはまた、私たちがPersistentPostsを取得するための呼び出しを待つことを可能にすることによって、ブリッジの最初の部分を構築します。

橋の建設を終わらせましょう。

継続値は、完了ハンドラの結果を配置する再開機能を提供します。

それだけでなく、resumeは、persistentPosts関数の結果を待っている呼び出しの一時停止を解除するために必要な不足しているリンクを提供します。

そして、1つのきちんとしたパッケージには、完了ハンドラから非同期関数への完成したブリッジがあります。

継続は、非同期関数の実行を手動で制御する強力な方法を提供しますが、心に留めておくべきことがいくつかあります。

継続にはシンプルだが重要な契約がある。

履歴書は、すべてのパスで正確に1回呼び出す必要があります。

でも、心配しないでください。スウィフトはここであなたの背中を持っています。

再開が呼び出されずに継続が破棄された場合、非同期呼び出しが一時停止されることはないため、Swiftランタイムは警告を記録します。

ただし、継続が同じ機能で複数回再開された場合、プログラムデータが破損する可能性があるため、これはより深刻なエラーです。

これに対処するために、Swiftランタイムは再開を複数回呼び出す試みを検出し、2番目の再開ポイントで致命的なエラーが発生するようにします。

これを念頭に置いて、チェックされた継続を使用する可能性のあるもう1つの重要な場所を強調しましょう。

多くのAPIはイベント駆動型です。

彼らは、特定の重要なポイントでアプリケーションに通知し、適切に応答できるようにするために、デリゲートコールバックを提供します。

Async/awaitを適切に採用するには、継続を保存し、後で再開する必要があります。

以前と同様に、チェックされた継続を作成します。

その後、それを保存し、作業を開始します。

チェックされた継続のAPI契約を尊重するために、アクティブな継続を再開し、最終的にそれをゼロにして、複数回呼び出すことから保護されるようにします。

常に覚えておいてください：ここでチェックされた継続値は、このAPIへの非同期呼び出しを手動で再開する機能を表すため、すべてのパスで呼び出す必要があります。

デリゲートAPIが何度も呼び出された場合、または特定の状況でまったく呼び出されない場合は、アクティブな継続を1回だけ再開することが重要です。

継続を含むSwift並行性の下位レベルの詳細の詳細については、「Swift並行性：舞台裏」セッションを参照してください。

これは、Swiftのasync/awaitの旋風ツアーでした。

実行時に非同期と待機キーワードがどのように機能し、アプリケーションやフレームワークに採用する方法を示しました。

始めるために、SDKで利用可能な非同期APIのサンプルを提供し、既存のコードを同期世界から非同期世界に橋渡しする方法を紹介しました。

Async/awaitは、Swiftの並行性機能の全宇宙の基盤です。

私たちは、あなたが彼らと一緒に構築するものを見ることに興奮しています。

ご覧いただきありがとうございます。