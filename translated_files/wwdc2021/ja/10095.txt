10095

♪ベース音楽の演奏♪

♪

Guoye Zhang:こんにちは、私はGuoyeです。

同僚のZhenchaoと私はHTTPフレームワークに取り組んでいます。

あなたは今までにSwiftの並行性について多くのことを聞いたことがあると思います。

まだしていない場合は、「Swiftで非同期/待機する」をチェックしてください。

URLSessionでasync/awaitがどのように機能するかに飛び込みます。

Swiftの並行性について私が最も好きなのは、コードを直線的で簡潔にし、ネイティブのSwiftエラー処理をサポートすることです。

ネットワーキングは本質的に非同期であり、iOS 15とmacOS Montereyでは、Swiftの並行性機能を利用するために、URLSessionに一連の新しいAPIを導入しました。

新しいAPIを紹介するために、ここにasync/awaitを採用するために取り組んでいるアプリがあります。

それは犬愛好家のための写真共有アプリで、私たちはこれらの写真をお気に入りにすることができます。

これは、犬の写真を取得する既存のコードです。

URLSessionで completionHandlerベースの便利なメソッドを使用しています。

コードは簡単そうで、私の限られたテストでうまくいきました。

しかし、少なくとも3つの間違いがあります。

飛び込みましょう。

まず、コントロールフローに従いましょう。

データタスクを作成し、それを再開します。

次に、タスクが完了したら、完了ハンドラにジャンプし、応答を確認し、画像を作成し、そこで制御フローが終了します。

うーん、私たちは前後にジャンプしています。

スレッドはどうですか?

この小さなコードは驚くほど複雑です。

合計で3つの異なる実行コンテキストがあります。

最も遠いレイヤーは、呼び出し先のスレッドまたはキューで実行され、URLSessionTask completionHandlerはセッションのデリゲートキューで実行され、最終的な完了ハンドラーはメインキューで実行されます。

コンパイラはここで私たちを助けることができないので、データレースなどのスレッドの問題を避けるために細心の注意を払う必要があります。

今、私は何かが間違っていることに気づきました。

completionHandlerへの呼び出しは、メインキューに一貫してディスパッチされるわけではありません。

これはバグかもしれません。

また、私たちはここで早めのリターンを逃しています。

エラーが発生した場合、完了ハンドラーを2回呼び出すことができます。

これは、発信者の仮定に違反する可能性があります。

最後に、これはあまり明白ではないかもしれませんが、UIImageの作成は失敗する可能性があります。

データが間違った形式の場合、このUIImage初期化子はnilを返すので、nil画像とnilエラーの両方でcompletionHandlerを呼び出しました。

これはおそらく予想外です。

さて、これはasync/awaitを使用する新しいバージョンです。

うわー、それはとても簡単です!

制御フローは上から下まで線形であり、この関数のすべてが同じ並行性コンテキストで実行されることを知っているので、スレッドの問題を心配する必要はもうありません。

ここでは、URLSessionで新しい非同期データメソッドを使用しました。

ブロックせずに現在の実行コンテキストを一時停止し、正常に完了するとデータと応答を返すか、エラーをスローします。

また、応答が予期しないときにエラーをスローするためにthrowキーワードを使用しました。

これにより、発信者はSwiftネイティブエラー処理を使用してエラーをキャッチして処理できます。

最後に、この関数からオプションのUIImageを返そうとすると、コンパイラは吠えるので、本質的にnilを正しく処理することを強制します。

これは、ネットワークからデータを取得するために使用したメソッドの署名です。

URLSession.dataメソッドは、URLまたはURLRequestのいずれかを受け入れます。

これらは、既存のデータタスクの便利な方法と同等です。

また、データをアップロードしたり、ファイルをアップロードしたりできるアップロード方法も提供しています。

これらは、既存のアップロードタスクの便利な方法と同等です。

デフォルトのメソッドGETはアップロードをサポートしていないため、リクエストを送信する前に必ず正しいHTTPメソッドを設定してください。

ダウンロードメソッドは、レスポンスボディをメモリではなくファイルとして保存します。

ダウンロードタスクの便利な方法とは異なり、これらの新しい方法は自動的にファイルを削除しないので、自分で削除することを忘れないでください。

この例では、さらなる処理のためにファイルを別の場所に移動しています。

Swift並行性のキャンセルは、URLSession非同期メソッドで動作します。

キャンセルする1つの方法は、並行性Task.Handleを使用することです。

ここでは、非同期を呼び起こして、2つのリソースを1つずつロードする並行性タスクを作成します。

後で、Task.Handleを使用して、現在実行中の操作をキャンセルできます。

並行性タスクは、「タスク」という名前を共有しているにもかかわらず、URLSessionTaskとは無関係であることに注意してください。

先ほど話した方法 - データ、アップロード、ダウンロード - 応答ボディ全体が到着するのを待ってから戻ります。

応答本文を段階的に受け取りたい場合はどうなりますか?

URLSession.bytesメソッドをご紹介させていただきます。

応答ヘッダーが受信されたときに返し、応答本文をバイトのAsyncSequenceとして配信します。

それがどのように機能するかを示すために、私の同僚のZhenchaoは、彼がDogsアプリでそれをどのように採用しているかをデモします。

Zhenchao Li: ありがとう、Guoye!こんにちは、私はジェンチャオです。

私は、犬の写真をお気に入りにした人の数を示すDogsアプリの新機能に取り組んできました。

今、スクロールビューをプルダウンして、お気に入りのカウントを更新できます。

これらのお気に入りのカウントをリアルタイムで更新したいと思います。

そうすれば、アプリははるかにインタラクティブに感じられます。

これを行うために、当社のバックエンドエンジニアは、写真のライブアップデートを提供するリアルタイムのイベントエンドポイントを構築しました。

エンドポイントをチェックして応答を調べます。

応答本文の各行は、更新されたお気に入りのカウントなど、写真の更新を記述するJSONデータの一部です。

新しい非同期シーケンスAPIを使用して、エンドポイントの応答を消費し、リアルタイムイベントが解析されるにつれてお気に入りのカウントを更新しましょう。

フォトコレクションビューが表示されたときに呼び出されるアクションであるonAppearHandler関数でライブアップデートを開始できます。

関数内で、新しいURLSession.bytes APIを呼び出して、新しいエンドポイントからデータを取得します。

ここで返されるバイトには、URLSession.AsyncBytesのタイプがあることに注意してください。

これにより、応答体を段階的に消費する方法が得られます。

また、サーバーから応答が成功したことを確認するために、ここにエラーチェックを追加しました。

応答の各行をJSONデータの一部として解析したい。

これを行うには、AsyncBytesでlinesメソッドを使用できます。

これにより、データを受信したときに応答を行ごとに消費することができます。

ループ内では、JSONデータを解析し、updateFavoriteCountを呼び出すことでUIを更新することができます。

UIの更新はメインアクターで行う必要があるため、await構文を使用して、非同期関数であるupdateFavoriteCountを呼び出していることに注意してください。

すごい。これで、これらのお気に入りのカウントがリアルタイムで更新されます。

あなたに戻って、Guoye。

Guoye：Zhenchaoは、AsyncSequence組み込みの変換（行）を使用して、応答本体を行ごとに解析する方法を示しました。

AsyncSequenceは多くの便利な変換をサポートしており、FileHandleなどの他のシステムフレームワークAPIでAsyncSequenceを使用することもできます。

AsyncSequenceの詳細については、ビデオ「Meet AsyncSequence」を見ることをお勧めします。

URLSessionは、認証の課題、メトリクスなどのイベントのコールバックを提供するデリゲートモデルを中心に設計されています。

新しい非同期メソッドは、もはや基礎となるタスクを公開しないので、タスクに固有の認証の課題をどのように処理しますか?

はい、これらのメソッドはすべて、追加の引数（タスク固有のデリゲート）を取ることができ、このデータアップロード、ダウンロード、またはバイト操作に固有のデリゲートメッセージを処理するオブジェクトを提供できます。

また、同じ機能を利用するために、Objective-CのNSURLSessionTaskにデリゲートプロパティを導入しています。

デリゲートは、タスクが完了または失敗するまで、タスクによって強く保持されます。

タスク固有のデリゲートがバックグラウンドURLSessionでサポートされていないことは注目に値します。

メソッドがセッションデリゲートとタスクデリゲートの両方に実装されている場合、タスクデリゲートのメソッドが呼び出されます。

さて、Zhenchaoは、タスク固有のデリゲートを使用して認証の課題を処理する方法を紹介します。

Zhenchao:ありがとう、Guoye!

私たちのDogsアプリには、新しい非同期APIで書かれたシンプルなデータフェッチレイヤーがあります。

写真をお気に入りとしてマークしたり、すべてのお気に入りの写真を取得したりするなど、データ取得タスクの一部では、ユーザーを認証する必要があります。

現在、写真のお気に入りをタップすると、「無許可」というエラーが表示されます。

タスク固有のデリゲートを使用してユーザー認証を追加する方法を見てみましょう。

まず、URLSessionTaskDelegateを書きましょう。

それをAuthenticationDelegateと呼びましょう。

AuthenticationDelegateはURLSessionTaskDelegateプロトコルに準拠しており、初期化子でsignInControllerのインスタンスを受け入れます。

私たちが実装したsignInControllerクラスには、ユーザーに資格情報を求めるために使用できるいくつかの素晴らしいヘルパー機能がすでに含まれています。

次に、URLSession didReceive challenge delegateメソッドを実装しましょう。

デリゲートメソッド内では、ユーザーに資格情報の入力を促すことで、HTTP基本認証の課題に応答することを選択できます。

もちろん、エラー処理を忘れてはいけません。

では、このAuthenticationDelegateクラスをタスク固有のデリゲートとして使用しましょう。

これを行うには、そのインスタンスをインスタンス化して、URLSession.dataメソッドのデリゲートパラメータとして解析することができます。

デリゲートオブジェクトはインスタンス変数ではなく、タスクが完了または失敗するまでタスクによって強く保持されることに注意してください。

ここでの新機能なのは、デリゲートを使用してURLSessionタスクのインスタンスに固有のイベントを処理できることです。これは、デリゲートメソッド内のロジックが特定のURLSessionタスクにのみ適用され、他のタスクには適用されない場合に便利です。

すごい。今、写真のお気に入りをタップすると...

...ログインフォームがポップアップ表示されます。

ログインすると、写真はお気に入りとして表示され、お気に入りの写真コレクションに追加されました。

あなたに戻って、Guoye。

Guoye: Zhenchaoさん、デモをありがとう。

URLSessionでasync/awaitを試すのが待ちきれません。関数の変更、完了ハンドラーを非同期関数に持っていく、繰り返しイベントハンドラーをAsyncSequencesに変更するなど、同じ非同期の概念を適用してコードを改善することをお勧めします。

URLSessionの進歩の詳細については、アプリのHTTPトラフィックを検査するクールな新しい機器に関するビデオと、URLSessionでのHTTP/3サポートに関するビデオがあります。

ありがとう、そして素晴らしいWWDCを!

♪