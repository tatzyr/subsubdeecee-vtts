10021

こんにちは、私はジェイコブです。「SwiftUIアプリにリッチグラフィックスを追加する」へようこそ。

私は何人かの同僚と一緒にグラデーションを構築するためのアプリに取り組んでいます。

今年、色は私たちのチームでホットなものです。

ほとんどの実装はすでに完了しています。

今、私はいくつかの豊かなグラフィックを追加してそれを終える必要があります。

アプリをカスタマイズすると、いくつかの異なる領域が表示されます。安全な領域のカスタマイズを含む安全な領域での作業、新しいフォアグラウンドスタイルのサポート、豊富な新しい素材セット、キャンバスを使った描画、強力な新しいビュー。

では、始めましょう。

これまでにアプリに何が入っているかをお見せします。

グラデーションのライブラリがあり、それらのグラデーションを見ることができます。

これには私が本当に好きな何かがあります。

私はそれの上に指を置くことができません。

グラデーションを編集することもできます...

これにより、カラーストップを変更できます。

そして、新しいグラデーションを追加できます。

これらのグラデーションは、いくつかのビジュアライザーでも使用できます...

しかし、一歩ずつ。それらを少し後で見てみましょう。

とりあえず、このグラデーションの詳細ビューに焦点を当てましょう。

それは機能的ですが、実際のコンテンツはクロムと空きスペースに比べてかなり小さいです。

この画面のグラデーションを本当に引き継いでほしい。

では、Xcodeで編集を始めましょう。

これは私たちの主な詳細ビューであり、編集モードにも使用されます。

isEditing falseから始めて、後で編集モードを見てみましょう。

このフレームを削除して、グラデーションでできるだけ多くのスペースを使用させましょう。

勾配がすべての高さを占めている今、私たちはもはやこのスペーサーを必要としません。

これをZStackに変更することで、このグラデーションの上にコントロールを置くことで、さらに進むことができます。

以前にZStackを見たことがない場合は、互いに隣り合うのではなく、互いの上に要素をレイアウトします。

編集コントロールを一番下に移動しましょう。

そして、グラデーションではなく、コントロールにパディングだけが必要です。

では、これを動かしましょう。

パディングを取り除いた後でも、なぜグラデーションの上部と下部にまだ空きスペースがあるのか疑問に思うかもしれません。

デフォルトでは、SwiftUIはコンテンツをセーフエリア内に配置し、ホームインジケーターや表示されているバーなど、ビューを不明瞭にしたりクリップしたりするものを避けます。

安全な領域は、ビューが表示されている最も外側の完全な領域から挿入された領域として表されます。

安全領域のコンテンツは、隠される領域を避けるために、適切なインセット内に自動的にレイアウトされます。

安全なエリアは、SwiftUIがキーボードの下にコンテンツを描くのを避ける方法でもあります。

したがって、私たちのアプリでは、私たちのコントロールは自動的にキーボードの邪魔にならないように持ち上げられます。

これは同じように機能し、どのようにより詳しく見ると、複数の異なる安全領域があるためです。

最も一般的なものはコンテナセーフエリアで、コンテナによって駆動され、ビューが内部に表示され、バーやデバイスクロームのようなものが含まれています。

さらに、キーボードを避けるためのキーボードの安全なエリアがあります。

また、キーボードセーフエリアは常にコンテナセーフエリア内の領域であることに注意してください。

キーボードに加えて、コンテナの安全な領域と同じ領域からコンテンツを安全に保ちます。

安全なエリアをオプトアウトすることは可能です。

ほとんどのコンテンツはクリップされないように安全なエリア内にある必要があるため、通常はこれを行う必要はありません。

結局のところ、それは安全です。

しかし、安全なエリアを無視することは、完全にエッジからエッジまで行きたい背景やその他のコンテンツにとって理にかなっています。

このコードを使用して、すべてのセーフエリアをオプトアウトするか、キーボードのエリアをオプトアウトするようにキーボード領域を指定できます。

そのフルブリード効果を得るために、線形グラデーションにignosesSafeAreaを追加しましょう。

この編集ボタンはグラデーションの上にはあまり見えないので、下端の安全な領域だけを無視しましょう。

さて、この下のテキストがグラデーションから判読不能であるという同じ問題に遭遇しないようにするために、その背後に背景を追加しましょう。

1分で背景をカスタマイズしますが、ダークモードで自動的に変更される白い背景を提供する最も単純なデフォルトから始めましょう。

そして、この背景は自動的に安全なエリアを超えて広がっています。

このバージョンの背景とその動作は、iOS 15と調整されたOSリリースで新しいものです。

それがどのように機能するかを見てみましょう。

コンテナビューとその安全なエリアから始めましょう。

次に、コンテンツビューがあり、読みやすく保つために安全なエリア内にあります。

適用されたビューに同じ境界を持つ背景を素朴に追加すると、これが表示されます。

しかし、background viewだけにignosesSafeArea修飾子を適用すると、メインコンテンツを素敵で安全に保ちながら、セーフエリアを超えて拡大します。

新しい背景修飾子は、この動作を自動的に提供します。

背景に戻って、カスタマイズを始めましょう。

グラデーションのような色や他のスタイルである可能性のある特定のスタイルで渡すことができます。

このアプリではあまり意味がありませんが、パステルカラーのものを見てみましょう。

私はまた、この背景をクリップする形を渡すことができます...

例えば、丸みを帯びた長方形。

カスタム図形を使用すると、図形がコンテンツの境界と一致するように、背景が安全領域の外に伸びなくなったことに注意してください。

私たちのアプリにもっと合うと思うのは、私たちの背景のぼかしです。

これを行うには、別の新しいAPIを使用できます。マテリアルです。

素材は、適用できる標準的なぼかしスタイルのセットです。

そして、この背景をエリア全体を取り上げることに戻しましょう。

素材は、このようなカラフルなコンテンツを通して見せたい場所に最適です。

超薄型から超薄型まで、さまざまな素材から選択できます。

そして、これらはすべて、すべてのプラットフォームで適切なデザインを自動的に表示します。

私はここで薄い材料を使うつもりです。

次に、テキストをカスタマイズしたいです。

名前がここでの主な情報であることを示すために、色の数を少し目立たないようにしましょう。

セカンダリのフォアグラウンドスタイルを設定することで、それを行うことができます。

セカンダリコンテンツは、その背後にある色をブレンドするバイブランシーと呼ばれる効果で自動的に表示されることに気づいたかもしれません。

SwiftUIでは、この効果のための追加のAPIはありません。

物質的な文脈で新しいセカンダリから第四紀のスタイルを使用すると、自動的に発生します。

これは、先ほどのように、マテリアルで背景を明示的に追加した場合、またはコンテンツがサイドバーなどのシステムコンポーネントにあり、マテリアルを追加する場合に発生する可能性があります。

そして、これらのスタイルには多くの自動スマートがあります。

ぼやけていないコンテキストでも使用すると、自動的に正しいことを行い、鮮やかな効果を使用しません。

また、色を設定すると自動的に動作が変更され、各レベルの色のバージョンが設定されます。

そして、同じサポートは、グラデーションのようなものであっても、任意のベースフォアグラウンドスタイルを設定するために機能します。

上品に使ってください。

注意すべき点：任意のテキストには、単一のフォアグラウンドスタイルを適用できますが、その範囲内で複数の色が適用されます。

たとえば、文字列補間を使用して内部テキストを埋め込むことができます...

そして、赤の前景色を適用します...

「色」という言葉に。

そして、それはその色を示し、その範囲の活気を自動的にオプトアウトします。

さらに重要なことに、これらのフォアグラウンドスタイルでは、初めて、埋め込まれた絵文字で正しい動作を得ることができます。

これは良さそうです。

もう一度実行して、これらの変更で編集モードも試してみましょう。

それはほとんどすでに機能しています。

そして、これらの色はぼかしの下に入ります、それは素晴らしいです。

しかし、よく見ると、それは正しいことをしていません。

ずっと下にスクロールすると、ぼかしの後ろに隠されているリストが少しあります。

何が起こっているのかもっと詳しく見てみましょう。 

クロムを取り除き、ここで関連するビューだけを見てみましょう。

これらのビューを少し水平にスライドさせると、バーがコンテンツの上にZStackedされているため、これがわかります。

後ろのすべてのビューを見たいので、それは正しい行動ではありません。

ここではVStackに変更できますが、ぼかしの下のリストがなければ、下にスクロールするときに色が表示されません。

リストの背景とそのスクロール可能な領域をバーの下に拡張したいが、メインコンテンツは拡張したくない。

そして、これはまさに安全なエリアのためのものです。

このバーに安全なエリアを挿入させると、重要なコンテンツは隠されないままになります。

独自のビューの安全な領域をカスタマイズするには、新しい修飾子「safeAreaInset」を使用できます。

これにより、メインコンテンツの上にバーなどの補助コンテンツを追加できます。

ZStackを交換します...

safeAreaInsetで...

ボトムのエッジを使用して...

そして、それに私たちのコントロールを入れてください。

もう一度実行して確認しましょう。

この景色はまだ同じように見えますが、それは良いことです。

それはセーフエリアを無視しているからです。

そして、編集モードでは...

私たちはまだそのぼかしを得るためにバーの下をスクロールすることができます。

しかし、一番下までスクロールすると、何も隠されません。

すごい。

次に、ビジュアライザーを見てみましょう。

すでに書かれているシェイプビジュアライザーから始めましょう。

多数のランダムな形状記号が表示され、それぞれがアプリからのグラデーションの1つで描かれています。

シンボルをタップしてズームアップできます...

または、バックグラウンドをタップして、すべてのシンボルの位置を変更します。

そして、以前にSwiftUIアニメーションのデモを見たことがあるなら、常にインタラクティブで中断可能であることを知っています。

だから私は再配置し続けることができます...

そして、それが起こっている間、タップして図形を選択および選択解除することもできます。

もし私がコードを見に行ったら...

SwiftUIでグラフィックを描画するための一般的な手法を使用しています。

GeometryReaderがあるので、ビューのサイズを読んで、これらのグラフィックをすべてレイアウトし、それらを配置するのに役立つZStackがあります。

そして、本文の最後には、以前に見たことのある修飾子があります：drawingGroup。

drawingGroupは、SwiftUIに、含まれているすべてのビューを1つのレイヤーにまとめて描画するように指示します。

これは、このようなグラフィカルな要素ではうまく機能しますが、テキストフィールドやリストなどのUIコントロールでは使用しないでください。

これは、ここで行っているような多数のグラフィック要素を表示したいときに使用する素晴らしいテクニックです。

そして、drawingGroupの利点の1つは、これらのビューの描画が異なっていても、アプリの他の場所で使用しているのと同じ機能をSwiftUIから使用できることです。

たとえば、ここでは、各シンボルをタップするためのジェスチャーと、選択を変更したり位置を変更したりしたときに適用されるアニメーションがあります。

これらのビューに含まれるアクセシビリティ情報も、通常通り渡されます。たとえば、各シンボルのこれらのアクセシビリティアクションなどです。

ただし、これらの機能をすべてサポートするために、各ビューにはいくつかの簿記とストレージが必要です。

あなたが十分な数の要素を持っているなら、その余分なオーバーヘッドでさえ多すぎるかもしれません。

そして、そのようなケースのために、私たちは新しいキャンバスビューを導入しました。

次のビジュアライザーは複雑な粒子システムを表示しますが、まだ書かれていません。

それを作りに行きましょう。

それを描くためにキャンバスビューから始めましょう。

これにより、キャンバスが描画されるたびに実行され、描画コマンドを含むクロージャを作成できます。

UIKitまたはAppKitのdrawRectに精通している場合、これはかなり同じように機能します。

このクロージャは、描画コマンドを送信するコンテキストと、キャンバス全体のサイズを取得するために使用できるサイズを提供します。

イメージを描くことから始めましょう。

SwiftUIコードの残りの部分で使用しているのと同じ画像タイプを使用して作成できます。

そして、私たちのイメージを描くように文脈を伝えましょう。

0,0で描くと、ここにあり、原点を中心に、あまり目立たない。

キャンバス全体のサイズが利用できるので、それを使って真ん中に描きましょう。

そして、プレビューをダークモードに変更すればわかることが1つあります。

先ほど見たのと同じ前景スタイルを使用しているので、私たちの画像は自動的に反転して白で描画するということです。

パーティクルシステムを構築したいので、この画像をもう数回描きましょう。

このクロージャは命令コード用であることに注意してください。

それはViewBuilderではありません。

だから、私はループにノーマルを使うことができます。

そして、実際に見ることができるように、各画像を少しシフトしてみましょう。

今、私たちはこの画像を数回描いていますが、毎回、コンテキストは毎回同じ画像であるにもかかわらず、現在の環境のようなものに基づいてそれを評価するためにそれを解決する必要があります。

画像を描く前に自分で画像を解決することで、これを改善できます。

同じ解決済み画像を共有しているため、パフォーマンスが向上しましたが、解決済み画像では他のこともできます。

私たちは今、そのサイズとベースラインを求めることができます。

私たちの場合、そのサイズを使用して、それぞれを適切な量にシフトします。

次に、輝きの後ろに楕円を加えましょう。

私はそれらを同じ地域に描くつもりです。

では、フレームを引き抜いて両方を描きましょう。

同じXとYの値でCGRectを作成し、幅と高さにimageSizeを使用します...

次に、そのフレームに画像を描きます。

各描画操作は順番に行われるため、楕円を画像の後ろに置くには、最初に描画する必要があります。

そして、私たちは文脈でそれを描くことができます。フィル...

それは道と陰影を取ります。

標準的なベジェ曲線でパスを構築できますが、ここにヒントがあります。楕円のような図形を使用して、特定の長方形のパスを尋ねることもできます。

もう1つの議論はシェーディングであり、それは私たちの道を埋めるものです。

そして、これはSwiftUIアプリの残りの部分と同じスタイルを使用できます。

シアン色を使いましょう。

そして、楕円があります。

しかし、画像とのコントラストはあまりありません。

それを直しましょう。

グラフィックコンテキストには、不透明度、ブレンドモード、変換など、多くの標準的な描画プロパティがあります。

ここに不透明度を設定しましょう。

そして、このコンテキストがあなたが慣れているかもしれないものとは少し異なる動作をする領域を見ることができます。

コンテキストに不透明度を設定すると、期待どおりに動作します。

それはその後に起こるすべての操作に影響します。

過去には、描画操作の一部にのみ適用されるグラフィックスコンテキストに変更を加えたい場合、保存と復元の呼び出しでそれらの操作を括弧で囲う必要があります。

しかし、SwiftUIのコンテキストでは、私がしなければならないのはコピーに変更を加えることだけです。

そして、これらの変更は、変更されたコンテキストで行われた描画にのみ影響します。

元のコンテキストで行われた描画は影響を受けません。

私たちのイメージにも色を加えましょう。

解決された画像でできるもう1つのことは、シンボルの描画方法を制御するためのシェーディングを設定することです。

ここに青い色を設定しましょう。

それは私が望んでいたよりも少し明るく見えません。

時々、あなたが絵を描いているとき、適切なブレンドモードは大きな違いを生むことができます。

ブレンドモードは、ここにあるように、特に部分的な不透明度で、色がどのように組み合わされるかを制御します。

スクリーンブレンドモードを設定しましょう。

それは色を組み合わせて、常に明るくなります。

その方が良さそうです。

あなたができる描画操作はもっとたくさんあります。

GraphicsContextタイプをチェックして、可能なすべてを確認してください。

さて、これをシミュレーションのようにするには、実際に移動する必要があります。

SwiftUIには、時間の経過とともに何かを変えるためのツールがいくつかあります。

アニメーションは最も一般的であり、通常、変更を加えると自動的に発生します。

今年は、時間の経過とともに何かがどのように変化するかを正確に制御したいときに、TimelineViewと呼ばれる新しい低レベルのツールを導入します。

変更したいビューを囲むだけで、タイムラインビューを使用できます。

そして、更新する頻度を示すスケジュールで設定できます。

タイマーなどのスケジュールがありますが、アニメーションスケジュールを使用して、表示できるだけ迅速に更新を取得します。

表示リンクに精通している場合、これは非常によく似ています。

そして、あなたがそうでないなら、それは全く大丈夫です。

私たちは、私たちが何を示すべきかについての情報を提供するタイムラインコンテキストを渡されます。

画像をアニメーション化するために使用する時間を数秒で引き出すことができます。

回転する振動で画像を移動させましょう。

だから、私は現在の時間から角度を作ります。

余りを使って3秒ごとにループさせましょう...

そして、それに120を掛けて360度になります。

そして、コサインでX値を取得します。

それとも正弦だったの？

あなたの三角法を覚えていることを願っています。

では、その値を使ってオフセットを変更しましょう...

そして、私たちのプレビューをライブで見て、それがどのように見えるかを見てください。

いいね。それらが重なると、さらに明るくなるのを見てください。

それが職場でのスクリーンブレンドモードです。

次に、いくつかのインタラクティブ性を追加しましょう。

先ほど、個々のビューにジェスチャーを追加することで実行できるインタラクションのいくつかを調べました。

キャンバスを使用することのトレードオフの1つは、キャンバス内の個々の要素が1つの図面にまとめられていることを覚えておいてください。

そのため、たとえば、これらの個々の画像にジェスチャーを添付することはできませんでした。

ただし、ビュー全体にジェスチャーを追加できます。

表示される輝きの数を増やす機能を追加しましょう。

表示する数について、いくつかの状態を追加します。

そして、2つから始めましょう。

カウントを使ってループをコントロールしましょう。

次に、TapGestureを追加してカウントを増やします。

プレビューを更新しましょう。

そして今、私たちはタップして輝きを加えることができます。

キャンバスを使用するもう1つの重要な側面は、単一のグラフィックであるため、アクセシビリティで利用可能なコンテンツに関する情報がないことです。

これをアクセスしやすくするために、標準のアクセシビリティ修飾子を使用して、ビューに関する情報を追加します。

また、より高度なケースでは、ビューに関するアクセシビリティ情報を生成するために使用する任意のSwiftUIビュー階層を指定できる強力な新しい.accessibilityChildren修飾子があります。

使用方法の詳細については、「SwiftUI Accessibility: Beyond the Basics」を参照してください。

私たちはCanvasの比較的単純な使用を構築しましたが、それははるかに複雑な使用をサポートするように設計されているので、物事を少し盛り上げましょう。

私の同僚の一人は、私たちがここに持っているものと同じように動作するいくつかのシミュレーションコードを書いてくれましたが、より多くの要素がより興味深いことをしています。

彼がここに送ってくれたファイルがあるので、私たちのビューに貼り付けます。

このコードは、私たちが今やっていたのと同じ構造です。

私たちは今、すべての粒子を追跡するために時間をかけて更新している長寿命のモデルオブジェクトを持っています。

私たちは、コンテンツをアニメーション化して描画するために同じTimelineViewとCanvasを持っています。

モデルを新しい日付で更新し、そのスクリーンブレンドモードを設定し、各活性粒子に、先ほどの楕円と同じ方法で描画するように指示しています。

そして最後に、もう少し複雑なジェスチャーで、同じ修飾子が適用されます。

だから、それがどのように見えるか見てみましょう。

定期的に新しい花火バーストを作成し、タップしてバーストを追加することもできます。

そして、それらはアプリのグラデーションの色と楕円を使用して作られています。

Canvasで描画するもう1つの素晴らしい点は、watchOS、tvOS、macOSでも機能することです。

すべてのSwiftUIプラットフォームで利用できます。

わかった。私たちはアプリを終えました。

その過程で、安全な領域の操作と変更、フォアグラウンドスタイルを使用してコンテンツの描画方法を制御する方法、素材を使用してぼかしと活気を得る方法、CanvasとTimelineViewを使用して複雑なアニメーショングラフィックを構築しました。

あなたがアプリでどんな素晴らしいグラフィックを作るかを見るのが待ちきれません。

[音楽]。