10119

♪ベース音楽の演奏♪

♪

ネイサン・タナー:こんにちは、WWDCへようこそ!

私の名前はネイサンで、アクセシビリティチームのエンジニアです。

今日は、基本を超えて、例外的でアクセスしやすいSwiftUIアプリを提供する方法を学びます。

今年は、SwiftUIのアクセシビリティの大きな飛躍を迎えます。

アップルでは、アクセシビリティは私たちのコアバリューの1つです。

すべてのプラットフォームにわたる当社の支援技術は、身体的、視覚的、聴覚的、または運動障害に関係なく、誰でもあなたのアプリを使用できるようにします。

私のチームと私は、あなたのアプリのほとんどがデフォルトでアクセス可能であることを確認するために働いていますが、経験を豊かにするためにできることは常にあります。

今日は、この体験を簡単に豊かにするSwiftUI用の新しいツールとAPIを紹介します。

Xcodeのツールの改善から始めましょう。

SwiftUIプレビューは、私たちの多くがアプリを開発する方法を変えました。

アプリを実行することなく、複数の環境でビューを反復する能力を劇的に向上させます。

最も重要なアクセシビリティ修飾子をワンクリックで作成するために、アクセシビリティエディタの厳選されたリストを追加しました。

これが、誰もが常に自分の意見にアクセスできるようにすることを奨励することを願っています。

しかし、もっとあります。

アクセシビリティ修飾子にはプレビューに視覚的な変更がないため、Xcodeを離れることなくビューのアクセシビリティを検査できる新しいツールが開発されました。

エディターパネルから新しいアクセシビリティパネルに切り替えましょう。

Xcode 13での出荷、SwiftUIプレビューは、アクセシビリティプレビューも備えるようになりました。

それを使えば、アクセシビリティ要素をリアルタイムで検査してプレビューすることができます。

そして、これはゲームチェンジャーです。

アクセシビリティプレビューは、各支援技術を深く理解していなくても、アクセス可能なアプリを作るのに役立ちます。

変更がアクセシビリティプレビューにどのように反映されているかを詳しく見てみましょう。

これは、先ほど見たビューの簡略化されたバージョンです。

プレビューを実行した後、VStackを選択すると、アクセシビリティプレビューが更新され、要素がソートされた順序で表示されます。

各要素には、ラベルや特性などの基本的なプロパティが常に表示されることに注意してください。

たとえば、テキストビューは、文字列をラベルとしてアクセシビリティ要素を作成します。

また、.isStaticText特性も得ます。

プレビューは、.isHeaderトレイトを追加するなど、アクセシビリティの変更について更新されます。

また、自動SFシンボルラベルなど、舞台裏で行われる自動アクセシビリティの一部を見ることができます。

たとえば、checkmark.seal.fillシンボルはデフォルトで「Verified」とラベル付けされています。

シンボルのデフォルトラベルに依存している場合は、インターフェイスを正確に記述していることを確認することが重要です。

アプリのすべてのユーザーに優れた体験を提供するのに役立つ5つの重要な分野をステップスルーしながら、アクセシビリティプレビューを引き続き使用します。

まず、カスタムコントロールにアクセスできるようにするための最良の方法を検討します。

次に、子供と一緒に景色にアクセスできるようにする方法について説明します。

一般的なナビゲーションの問題についてアプリを監査する方法と、アクセシビリティプレビューがこれをどのように支援できるかを強調します。

次に、VoiceOverローターでアプリのナビゲーションをスーパーチャージする方法を紹介します。

そして最後に、フォーカスとそれが支援技術とどのように関連しているかを見ていきます。

私はWallet Palと呼ばれる新しい金融アプリのプロトタイプに取り組んできました。

まだ初期段階ですが、これまでのところ、私は最初のデザインにかなり満足しています。

初期のベータテスターもそれを気に入っていると聞いてうれしかったです。

UIを磨いた今、私はアクセシビリティインターフェースを磨くためにいくつかの時間を費やす必要があります。

アクセシビリティインターフェースは、誰もが使用できるように、視覚的な体験を補完します。

私は何人かのVoiceOverユーザーにWallet Palのテストを手伝ってくれるように頼みましたが、このアプリはナビゲートが難しく、完全にアクセスできないと聞きました。

部品がVoiceOverにアクセスできない場合は、他の支援技術にもアクセスできません。

誰でもWallet Palを使用できることが重要なので、どこで体験を向上させることができるかを調査しましょう。

Wallet Palの重要な機能である、ユーザーが予算を編集できないという報告から始めます。

これは、ユーザーが食べ物、エンターテイメント、節約の予算を編集できる予算プランナービューです。

Wallet Palのデザインに合うように、結局カスタムスライダーを作成する必要がありました。

私は図形から予算スライダーを作成し、インタラクションにドラッグジェスチャーを使用することでこれを達成しました。

SwiftUIの図形は、見事でユニークなビューを簡単に作成できますが、デフォルトではアクセスできないので、私の予算スライダーもそうではありません。

これが、一部のユーザーが予算を編集できない理由に違いない。

SwiftUIプレビューを実行し、SliderShapeを選択すると、アクセスできないことを確認できます。

アクセシビリティプレビューは、要素がないことを示しているので、このコントロールにはアクセスできません。

理想的には、変更できる値を持つ単一のラベル付きアクセシビリティ要素を持つべきです。

対照的に、標準コントロールはデフォルトでアクセス可能であり、優れた体験を提供するために余分な労力がほとんど必要とされないことを意味します。

SwiftUIは、ビュータイプとその初期化パラメータを使用して、アクセシビリティ要素のラベル、値、特性、およびアクションを自動的に導出します。

では、カスタム予算スライダーにアクセスできるようにするための最良の方法は何ですか?

標準スライダーはデフォルトでアクセス可能なので、私のチームと私は、あるビューのアクセシビリティを別のビューで表現できるAPIを持つことは素晴らしいことだと思いました。

これが、アクセシビリティ表現(表現:)を作成するために私たちを導いたものです。

これは、あるビューのアクセシビリティを別のビューで定義できるようにするAPIです。

私はこれを支援技術によってスライダーとして認識させたいので、それは私がアクセシビリティ表現に使用するものです。

accessibilityRepresentation(representation:)により、私たちは今、この予算スライダーをアクセシブルにするための道を歩んでいます。

スライダーのエクスペリエンスを向上させるために必要な唯一の変更は、価値をドルで記述することです。

そして素晴らしい、ちょうどそのように、今、私たちの予算スライダーは完全にアクセス可能です。

macOSでは、コントロールの種類はVoiceOverユーザーにも話されます。

したがって、予算スライダーの表現でスライダービューを使用すると、スライダーとしてアナウンスされます。

カスタムコントロールにアクセスできるようにするために、可能であればaccessibilityRepresentation(representation:)を使用することをお勧めします。

これは、accessibilityRepresentation(representation:)を使用する1つの方法にすぎません。

その柔軟性は、より多くの創造的な使用を可能にします。

アプリ内の他のアクセシビリティのバグを修正するために使用できるかどうか見てみましょう。

予算を編集する機能機能を修正しましたが、一部のユーザーは、予算プランナービューに移動する方法を発見できなかったと報告しました。

Wallet Palをデザインする際には、すべてのボタンにSFシンボルを使用することにしました。

SFシンボルには優れたデフォルトのアクセシビリティラベルがあるかもしれませんが、必ずしも意図したユースケースに適合するとは限りません。

問題がラベルの悪いボタンであるかどうかを調査しましょう。

NavigationBarViewには、予算の編集ボタンが含まれています。

多くのボタンをSFシンボルに頼っているので、SymbolButtonStyleと呼ばれるカスタムボタンスタイルを作成しました。

しかし、「予算の編集」というラベルでボタンを初期化したにもかかわらず、ボタンのラベルはslider.vertical.3のようです。

したがって、アクセシビリティラベルはSFシンボルから派生しています。

SymbolButtonStyleを詳しく見てみましょう。

SymbolButtonStyleのmakeBody(configuration:)メソッドは、画像ビューを返します。

ボタンを初期化する予算の編集文字列は、構成のラベルとしてテキストビューを作成します。

しかし、このスタイルは構成のラベルを完全に無視します。

これが、ボタンが「予算の編集」とラベル付けされていない理由です。

SFシンボルを視覚的に表示されるようにしたいが、ボタンのアクセシビリティを構成のラベルで表したい。

そして、これはaccessibilityRepresentation(representation:)の素晴らしいユースケースのように思えます。

accessibilityRepresentation(representation:)を使用すると、画像ビューのアクセシビリティを別のビュー、この場合は設定のラベルに置き換えることができます。

このようにして、ボタンの作成に使用したラベルを保存できます。

accessibilityRepresentation(representation:)は、カスタムコントロールをアクセス可能にするための理想的で推奨される方法であるだけでなく、ビューをアクセス可能にするための新しい創造的な可能性も開きます。

次に、子供とアクセシビリティコンテナの関係について話し合いましょう。

覚えているかもしれませんが、アクセシビリティ要素は、アクセシビリティコンテナの子としてグループにまとめることができます。

これは、accessibilityElement(children:)修飾子と子を含む行動で行われます。

なじみのない場合は、包含子の動作を使用して、既存のアクセシビリティ要素を子としてラップするアクセシビリティコンテナを作成できます。

しかし、代わりにアクセシビリティ要素があり、その子を設定したい場合はどうなりますか?

予算履歴グラフにアクセスできるようにしようとすると、このケースに遭遇します。

ユーザーは、グラフに完全にアクセスできないと報告した。

つまり、支援技術が予算履歴ヘッダーに焦点を当て、次の要素に移動しようとすると、アラートヘッダーになります。

VoiceOverユーザーは、このグラフが存在することさえ知らないだろう。

新しいキャンバスビューを使用してグラフを作成しました。

キャンバスを使用すると、図形のコレクションを簡単に描画できます。

キャンバスの詳細については、アプリに豊富なグラフィックを追加するために使用する方法に関するジェイコブのプレゼンテーションをご覧ください。

アクセシビリティのための最も重要なポイントは、キャンバスが図形のコレクションを描くことです。

そして、BudgetSliderで見たように、図形はデフォルトではアクセスできません。

すべてのユーザーが予算履歴を表示できる必要があるので、誰もがアクセスできるようにしましょう。

基本から始めて、キャンバスにラベルを付けましょう。

これにより、キャンバスの新しいアクセシビリティ要素が自動的に作成され、そのラベルが割り当てられます。

さて、グラフの各バーは、独自のアクセシビリティ要素で表されるようにしたいと思います。

これは、アクセシビリティ要素があり、その子を提供したいユースケースです。

これを行うには、新しいaccessibilityChildren(children:)修飾子を使用します。

これにより、アクセシビリティ要素がアクセシビリティコンテナに変換され、ラベルなどの他のアクセシビリティプロパティが保持されます。

修飾子はViewBuilderを取ります。これにより、アクセシビリティコンテナの子として新しいビューを設定できます。

予算履歴グラフは水平棒グラフを描画しているので、HStackを使用して各予算のビューを返します。

フレームが利用可能なすべての垂直スペースを埋めるように、各アクセシビリティ要素に長方形を使用します。

これにより、各アクセシビリティ要素のフレームが視覚的に表示されているものよりも大きくなり、問題ありません。

大きくて一貫性のあるフレームを持つことで、VoiceOverユーザーが画面上で指をドラッグしてアクセシビリティ要素をスキャンするときに、iOSでナビゲートしやすくなります。

accessibilityChildren(children:)修飾子内からHStackを選択すると、アクセシビリティプレビューはグラフ内の各バーに要素が作成されたことを確認します。

これらはすべて、Canvasアクセシビリティコンテナの子としてアクセスできます。

これらの変更により、予算履歴グラフは完全にアクセス可能になり、支援技術はグラフの各バーをナビゲートできます。

各要素のフレームが同じであることに注意してください。これは理想的です。

より複雑なチャートについては、アクセスできるようにする他の方法があります。

そのために、チャートにアクセシビリティをもたらすことに関するプレストンのプレゼンテーションをチェックしてください。

しかし、アクセシビリティの子供たちでは、ビューのアクセシビリティ要素は視覚的に提示されたものとは異なる可能性があり、素晴らしい体験を調整することができます。

しかし、アクセシビリティの子供たちは、結合行動の助けを借りてアクセシビリティを構成するためにも使用できます。

クイックリフレッシュとして、コンバイン子の動作は、複数のアクセシビリティ要素のプロパティを新規または既存のアクセシビリティ要素にマージします。

しかし、アクセシビリティの子APIを追加して、一般的な方法でアクセシビリティを構成するためにも使用できるようになりました。

アクセシビリティ表現により、元のアクセシビリティは完全に置き換えられます。

これは、構成ができないことを意味します。一方、アクセシビリティの子供たちは添加物です。

これは、後で子を組み合わせて、そのプロパティを元の要素にマージできることを意味します。

これはaccessibilityChildren(children:)修飾子のより高度なユースケースですが、私が強調したかった機能です。

例は、このプレゼンテーションのアクセシビリティカタログサンプルプロジェクトで紹介されています。

多くの人がこの種の構成で何が可能かを探るのを見たいと思っています。

accessibilityChildren(children:)を使用すると、コンテナの子を制御できます。

そして、キャンバスで描かれた複雑なグラフは、すでに慣れ親しんでいる修飾子とビューでアクセスできるようになります。

そして、組み合わせた子供の行動により、単一のビューのアクセシビリティは多数で構成できます。

アプリの個々のコンポーネントにアクセスできるようにする方法を学んだので、ナビゲーション体験を洗練するために物事をまとめ始めることができます。

VoiceOverでWallet Palをナビゲートするのは混乱し、難しいと聞きました。

だから、素晴らしいアクセシブルなアプリを提供したい場合は、もう少しやるべきことがあります。

上部にあるフレンズカルーセルを詳しく見てみましょう。

この機能はまだ構築されていませんが、Wallet Palに何らかのゲーミフィケーションを追加する予定です。

そこで、各フレンドビューの左上にチャレンジボタンを追加しました。

すでにSymbolButtonStyleを修正したので、チャレンジボタンは適切にラベル付けされます。

しかし、ユーザーはナビゲーションが混乱していると報告しているので、他の問題はありますか?

それに答えるには、まず、支援技術がWallet Palをどのようにナビゲートするかを理解する必要があります。

デフォルトでは、アクセシビリティ要素は、左上から右下まで、他の要素との関係で幾何学的な位置に基づいてソートされます。

これは、コンテンツを区別するためのアクセシビリティコンテナがなければ、VoiceOverは各チャレンジボタン、次に画像と友達を追加ボタン、そして最後にユーザー名のテキストをナビゲートすることを意味します。

アクセシビリティプレビューの大きな特徴は、整理された順序でアクセシビリティ要素を表示することです。

これにより、支援技術がXcode内から直接どのようにナビゲートするかを簡単に視覚化できます。

予想通り、ソートされた順序は私たちが以前に見たものと一致します。

そして、この順序は確かにナビゲートするのに混乱するでしょう。

これで、アクセシビリティ要素の並べ替え順序を修正する方法は複数あります。

私たちができることの1つは、アクセシビリティコンテナを導入することです。

包含ビヘイビアでaccessibilityElement(children:)修飾子を追加します。

これにより、各FriendCellViewのアクセシビリティ要素がアクセシビリティコンテナにラップされます。

これは、アクセシビリティコンテナの子が次のアクセシビリティ要素に移動する前にナビゲートされるため、ナビゲーションの順序を修正します。

この変更により、VoiceOverは次のアクセシビリティ要素に移動する前に、アクセシビリティコンテナの子をナビゲートします。

そして、私たちははるかに望ましいナビゲーション順序を達成します。

しかし、この経験を改善するためにもっとうまくやれるでしょうか?

1つの問題は、ユーザーが誰であるかを知る前にチャレンジボタンがナビゲートされることです。

VoiceOverユーザーは、チャレンジを送信する前にユーザーの名前を知りたいので、このボタンは本当に最後にソートする必要があります。

accessibilitySortPriority(_:)修飾子を使用してこれを修正できます。

accessibilitySortPriority(_:) は、アクセシビリティ コンテナ内の要素の順序を変更するために使用できます。

優先度の高い要素は最初にソートされ、優先度が低い要素は最後にソートされます。

優先順位が等しい要素は、その幾何学的ポジショニングに基づいてソートされます。

チャレンジボタンにaccessibilitySortPriority(_:)修飾子を追加して、ナビゲーションの順序を改善します。

デフォルトが0なので、優先度-1を使用して、チャレンジボタンの並べ替え順序を最後にします。

これで、チャレンジボタンが最後にナビゲートされます。

VoiceOverユーザーが誰にチャレンジを送っているのか混乱する可能性は低いため、これは良い改善ですが、それでも素晴らしいものではありません。

各FriendCellViewをアクセシビリティコンテナにラップするのではなく、子を1つの要素にまとめることができます。

結合は、子のプロパティを既存または新しいアクセシビリティ要素にマージすることを思い出してください。

結合動作は、最適なデフォルト結果を得るためにマージされるプロパティもキュレーションします。

たとえば、チャレンジボタンは「チャレンジを送信」という名前のアクションになりました。

これもナビゲーションの順序を修正し、アクセシビリティ要素の数を減らします。

これで、ユーザーごとに1つの要素があり、各要素にはSend Challengeアクションがあります。

ForEachで表されるビューのアクセシビリティ要素を組み合わせることがしばしば理想的です。

あなたが今までに拾ったかもしれないように、コンバインは超有用な子供の行動です。

子が個別にナビゲートできる代わりに、プロパティを単一のナビゲート可能な要素にマージします。

単一の要素が必要で、子からプロパティを継承したくない場合は、無視動作を使用します。

そして最後に、包含された子の行動は、アクセシビリティコンテナに子を包み込み、関連するビューのグループを表現するために使用する必要があります。

これにより、デフォルトのソート順が改善されるだけでなく、支援技術に他の利点があります。

新しいアクセシビリティプレビューでは、これらのナビゲーションの問題を簡単に発見できます。

そして、いくつかの小さな変更で、経験を劇的に改善することができます。

しかし、VoiceOverユーザーに本当に優れたナビゲーション体験を提供するために、ローターを検討したいと思うでしょう。

アクセシビリティが初めてなら、「ローターとは何ですか？」と思うかもしれません。

要するに、ローターは強力なナビゲーションツールです。

これらは、ユーザーがそれらの間をすばやくナビゲートできるブックマークと考えることができます。

見出しやコンテナローターなどのシステムローターは、このスーパーチャージされたナビゲーションの基盤を提供します。

たとえば、ユーザーは見出しローターを使用してセクションをすばやくナビゲートできます。

これは、セクションビューが自動的にisHeader特性をヘッダービューに追加するためです。セクションビューを使用していない場合は、accessibilityAddTraits(_:)を使用してisHeader特性をビューに追加できます。

同様に、アクセシビリティコンテナはコンテナのローターに追加され、先に見たように、accessibilityElement(children:)修飾子で作成されます。

ご覧のとおり、見出しローターのサポートは非常に簡単で、コンテナのローターは、アクセシビリティ要素を子の行動を含むとグループ化する利点をさらに高めます。

Wallet Palの基本的なナビゲーション体験が洗練されたので、ローターでさらに一歩進めましょう。

Wallet Palでは、アラートは、予算が制限に近づいたり超えたりしたときにモチベーションメッセージや警告を提供することで、ユーザーの支出習慣を抑えるのに役立ちます。

さまざまな種類のアラートにSFシンボルを組み込みました。

これにより、ビジュアルユーザーはリストをすばやくスキャンできます。

しかし、この図像はVoiceOverユーザーには役に立ちません。

代わりに、警告があるかどうかを知るために、すべてのアラートをナビゲートする必要があります。

目の見えるユーザーが持っている同様の体験を再現するには、VoiceOverユーザーは警告を独占的にナビゲートできる必要があります。そうすれば、瞬時に次の警告アラートに移動できます。

これを行うには、ローターを使用できます。

カスタムローターのより多くの例と、それらが効率にとって非常に重要である理由については、2020年の「カスタムローターのボイスオーバー効率」プレゼンテーションをご覧ください。

AlertsViewに警告ローターを追加するには、最初に行うことは、アクセシビリティコンテナにローターを追加していることを確認することです。

SwiftUIの一部のビューは、ListやLazyVStackなどのアクセシビリティコンテナですが、VStacksとHStacksはそうではないので、adtainingElement(children:)修飾子を含む修飾子を追加します。

次に、accessibilityRotor(_:entries:)修飾子でローターを作成し、「警告」という名前を付けます。

そして最後に、どのアラートを警告ローターに含めたいかを宣言します。この場合はすべての警告アラートです。

そして、それだけです!

アプリのナビゲーションをスーパーチャージするのは簡単です。

これらの簡単なユースケースでローターを非常に簡単にする理由の一部は、SwiftUIがIDに基づいてローターエントリをアクセシビリティ要素に自動的に一致させることができることです。

これは、ローターエントリのIDが、ForEachによってAlertCellViewに与えられたIDと一致するためです。

ビューのアイデンティティは、アクセシビリティローターのために理解することが重要です。

したがって、ビューのアイデンティティが不明な場合、または復習をご希望の場合は、「Demystifying SwiftUI」プレゼンテーションをチェックして詳細を確認することを強くお勧めします。

今、あなたは「ちょっと待って、私の見解はこんなに単純ではありません。

ForEach内にないビューはどうですか?

心配しないで、アクセシビリティローターAPIは単純なビューから複雑なビューまで拡張できます。

このシンプルなケースは、AlertCellViewに単一のアクセシビリティ要素があるため、エレガントに機能します。

そして、AlertCellViewはアラートのIDによって識別されます。

すべてのアラートにアクションビューもあった場合はどうなりますか?

この場合、VStackはForEachのルートビューであり、アラートのアイデンティティが与えられるのはVStackです。

したがって、警告ローターにAlertCellViewを含めるには、ローターエントリとして明示的にマークする必要があります。

アクセシビリティRotorEntry修飾子でそれを行うことができます。

この修飾子には、名前空間とIDが必要です。これは、AccessibilityRotorEntryの作成に使用されたIDと名前空間と一致する限り、何でもかまいません。

そして最後に、各ローターエントリにこの名前空間を含める必要があります。

明示的な名前空間を参照する機能は、アクセシビリティローターAPIが単純なユースケースから複雑なユースケースにスケーリングすることを可能にし、複数のビューにまたがるアクセシビリティ要素を同じローターに含めることができます。

アクセシビリティローターを追加して、テキストナビゲーションを豊かにすることもできます。

これを行うには、accessibilityRotor修飾子の別のバリアントを使用します。これにより、テキスト範囲の配列を指定できます。

この修飾子は、VoiceOverユーザーが電子メール、リンク、電話番号などのテキストエディタ内の特定の文字列にすばやく簡単にアクセスできるようにするのに最適です。

アクセシビリティローターは、VoiceOverユーザーにとって複雑なナビゲーションを容易にします。

そして、新しいSwiftUIローターAPIにより、この優れたナビゲーション体験を提供することがかつてないほど簡単になりました。

今日の最後のトピックはフォーカスです。

焦点の要素の概念は、あなたがすでに慣れ親しんでいるかもしれませんが、あなたが知らないかもしれないのは、私たちの支援技術の多くが独自の焦点状態を持っているということです。

これは私たちが「アクセシビリティフォーカス」と呼ぶものです。

それは私がナビゲートする支援技術について言及するとき、あなたが変化を見ていた焦点を絞ったビューです。

支援技術のカーソルの位置は、ユーザーエクスペリエンスにとって非常に重要です。

VoiceOverでフォーカスが変更されると、カーソルは要素の説明を話すことに加えて、フォーカスされた要素のパスと一致するように移動します。

では、焦点はいつ変わりますか?

3つのイベントのいずれかが発生すると、フォーカスは変更できますが、常に変わるとは限りません。

最初で最も一般的なユースケースは、ユーザーが別のアクセシビリティ要素にナビゲートするときにフォーカスの変更を駆動する場合です。

2番目のケースは、UIが変更され、以前にフォーカスされたビューが画面に表示されなくなったり、モーダルビューでカバーされたりした場合です。

これが発生すると、フォーカスは最初にソートされたアクセシビリティ要素にリセットされることがよくあります。

これは、新しく提示されたビューの最初のアクセシビリティ要素に移動するなど、多くのユースケースを自動的にカバーします。

しかし、それはあなたのアプリでの最良の行動ではないかもしれないので、プログラマティックな要求に応じてフォーカスを変更することもできます。

ただし、VoiceOverユーザーのフォーカスを移動することは非常に破壊的になる可能性があるため、これは慎重に処理する必要があります。

そのメモでは、最後のケースに集中しましょう。ダジャレは意図していません。

今年は、支援技術が現在焦点を当てている場所を読むことに加えて、その焦点を移動するために支援技術を要求できる新しいAPIがあります。

ここでは、通知を追跡するシンプルなビューがあり、存在する場合は、カスタムNotificationBannerをオーバーレイします。

Wallet Palでこのビューを使用して、アプリがフォアグラウンドにある間に受信したプッシュ通知のアラートを表示したいと考えています。

NotificationBannerが追加されると、支援技術は自動的にそれに焦点を合わせません。

しかし、新しいAccessibilityFocusStateでそうするように要求することができます。

AccessibilityFocusStateは、支援技術が集中する読み取り方法と、プログラム的なフォーカスの変更を要求する方法の両方を提供するプロパティラッパーです。

ビューに1つ追加し、accessibilityFocused(_:)修飾子でNotificationBannerにバインドします。

次に、onChange(of:perform:)修飾子を使用して、新しい通知がいつ受信されたかを追跡します。

優先度の高い通知を受け取った場合にのみ、アクセシビリティフォーカスの変更を要求します。

ユーザーインタラクションが発生しない場合、プログラムでフォーカスを移動することは非常に破壊的になる可能性があることに注意することは特に重要です。

ユーザーが現在焦点を当てているコンテキストから外すため、注意して処理する必要があります。

したがって、優先度の低い通知については、VoiceOverが発表するためのアクセシビリティ通知を投稿します。

このようにして、VoiceOverユーザーはまだ新しい通知が表示されたことを知っていて、必要に応じてナビゲートすることができます。

では、NotificationBannerビューに入りましょう。

通知が表示されると、タイマーが開始されます。

完了すると、通知はゼロに設定されます。

通知がnilの場合、NotificationBannerは非表示になります。

これは、VoiceOverユーザーが通知バナーに集中し、タイマーの有効期限が切れた場合、ビューが削除されるため、フォーカスがリセットされることを意味します。これは素晴らしいユーザーエクスペリエンスではありません。

これを修正するには、NotificationBannerが支援技術に焦点を当てているかどうか、もしそうなら、通知の却下を遅らせるかどうかを読みましょう。

これは理想的な解決策です。

フォーカス中にビューが削除されなくなったため、VoiceOverユーザーのフォーカスはリセットされなくなります。

さらに、支援技術ユーザーにコンテンツを消化し、必要に応じて対話するための無制限の時間を与えました。支援技術ユーザーがそうするのにはるかに時間がかかるかもしれない2つのこと。

AccessibilityFocusStateは、今年以降、例外的でアクセスしやすいSwiftUIアプリを提供するために必要な最後の作品です。

それを使用すると、ビュー間のスムーズな移行を作成するために、支援技術の焦点を読み、指示することができます。

うわー、今日はSwiftUIのアクセシビリティについて多くのことを取り上げました。

SwiftUIのアクセシビリティを開発およびデバッグする方法を強化する新しいアクセシビリティプレビューが紹介されました。カスタムコントロールと複雑なグラフにアクセスできるようにする方法を取り上げました。そして、グループ化、ローター、フォーカスでナビゲーション体験をどのように改善できるかを学びました。

すべてをまとめると、今年は本当にアクセシビリティにとって大きな飛躍でした。

アクセシビリティAPIのシンプルで複雑な例については、アクセシビリティカタログサンプルプロジェクトをご覧ください。

今日カバーできなかったより多くの例と、推奨されるベストプラクティスのいくつかを特集しています。

参加してくれて本当にありがとう。

誰もがあなたのアプリにアクセスできるようにする方法を楽しみにしています。

♪