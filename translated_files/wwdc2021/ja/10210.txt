10210

♪ベース音楽の演奏♪

♪

Jake Petroules: こんにちは、「Xcodeで高度なプロジェクト構成を探索する」へようこそ。

私はジェイクです。同僚のプラチと一緒に、Xcodeプロジェクトのビルド構成を最大限に活用するための戦略とテクニックについて話し合います。

3つの主要なトピック分野をカバーします。

まず、PrachiはマルチプラットフォームプロジェクトとXcode 13のマルチプラットフォームフレームワークターゲットの新しいサポートについて議論します。

次に、スキーム、ターゲット設定、依存関係管理、およびフェーズとルールの構築を通じて、プロジェクトのモデリングと設定のベストプラクティスについて説明します。

そして最後に、Prachiはビルド設定を深く掘り下げ、その構造と動作、プロジェクトエディタUI、構成設定ファイルとその構文などについて説明します。

この講演では、Frutaと呼ばれるマルチプラットフォームアプリプロジェクトを使用して、これらのテクニックが実際のプロジェクトにどのように適用されるかを示します。

そして今、私はそれをプラチに引き渡します。プラチはマルチプラットフォームフレームワークについて話します。

Prachi Pai Asnodkar: ありがとう、ジェイク。

Xcode 13の新機能の1つは、マルチプラットフォームフレームワークのサポートです。

マルチプラットフォームフレームワークを使用すると、複数のフレームワークを1つに統合し、ターゲット管理を簡素化し、管理する1組のビルドフェーズ、管理する1組のビルド設定を提供します。

Frutaアプリを見て、この機能を利用するためにプロジェクトを更新しましょう。

これはFrutaアプリです。

これは、macOS、iOS、watchOS用に構築されたマルチプラットフォームアプリです。

また、3つのフレームワークターゲットがあります。各プラットフォームに1つずつ、アプリで使用される一連の共有コードが含まれています。

3つの別々のフレームワークを維持するには、ビルド設定を同期させ、すべてのソースファイルがコンパイルソースのビルドフェーズに適切に追加されるようにするなど、課題が生じる可能性があります。

これらの課題に取り組むために、フレームワークの1つをマルチプラットフォームフレームワークに変換することから始めます。

ここには3つのフレームワークがあります。各プラットフォームに1つずつです。

これらのターゲットはすべて同一ですが、macOSでのみビルドされるファイルがあります。

まず、macOSフレームワークターゲットのプロジェクトナビゲーターの「ビルド設定」タブに移動しましょう。

次に、サポートされているプラットフォームのビルド設定に移動し、任意のプラットフォームを選択して、すべてのプラットフォーム用に構築するフレームワークを構成します。

また、マルチプラットフォームビルドの許可が自動的に「はい」に設定されていることがわかります。

これは、必要に応じて、サポートされているプラットフォームごとにこのターゲットを1回構築するようにビルドシステムに通知します。

これはマルチプラットフォームのターゲットなので、元のmacOSフレームワークには、macOS用に構築するときにのみ構築すべき1つの追加ファイルがあったことを思い出してください。

これを行うためのフレームワークを設定するために、プラットフォームフィルターを追加して、このファイルがmacOS用にのみビルドされることを指定できます。

これを行うには、まず[ビルドフェーズ]タブに移動します。

次に、コンパイルソースのビルドフェーズを展開します。

最後に、フィルター項目をクリックし、macOS以外のすべてのチェックを外して、macOS専用にビルドするようにIngredient+macOS.swiftを設定します。

新しいマルチプラットフォームターゲットが設定されたので、フレームワークの他の2つのバリアントは不要になったため、削除できます。

さらに、フレームワークターゲットは1つしかないため、その新しいターゲットをリンクして埋め込むようにすべてのアプリを設定する必要があります。

macOSアプリはすでに設定されています。なぜなら、macOSからマルチプラットフォームのターゲットを設定しているからです。

各アプリターゲットの[一般]タブに移動し、フレームワークとライブラリの構築フェーズにフレームワークを追加することで、iOSおよびwatchOSアプリに新しいフレームワークを追加できます。

要約すると、macOSフレームワークのターゲットを取り、iOSとwatchOS用に構築できるようにしました。

macOSのみのソースファイルのプラットフォームフィルタを使用して、そのフレームワークをカスタマイズしました。

そして最後に、新しいシングルマルチプラットフォームフレームワークターゲットをリンクして埋め込むようにアプリターゲットを設定しました。

そして、それはXcodeのマルチプラットフォームターゲットです。

さて、プロジェクト構成を深く掘り下げるジェイクに戻ります。

ジェイク:ありがとう、プラチ。

Xcodeプロジェクトのモデリングと設定のベストプラクティスについて話し合い、ビルドのパフォーマンスと正確性を向上させるためにできることをいくつか紹介します。

まず、スキームのビルドオプションを見てみましょう。

スキームピッカーをクリックし、スキームを編集し、ビルドセクションに移動します。

ここで設定できる簡単なことがいくつかあります。

ビルドオーダーでは、依存関係グラフに従ってプロジェクト内のターゲットが並行して構築される依存関係オーダーを選択することをお勧めします。

これにより、マルチコアのビルドパフォーマンスが大幅に向上し、継続的インテグレーションからより迅速な結果が得られます。

対照的に、手動注文の選択は非推奨であり、推奨されません。

このオプションを使用すると、ビルドが遅くなり、スキームにリストされているターゲット順序がプロジェクトの依存関係と矛盾すると、サイクルエラーが発生する可能性があります。

スキームビルドオプションのもう1つの重要な設定は、暗黙の依存関係の検索です。

このオプションをチェックすると、Xcodeは、ビルド設定のリンカーフラグやビルドフェーズのリンクされたライブラリの名前など、プロジェクト内の情報に基づいてターゲット間の依存関係を自動的に追加できます。

これは、関連するターゲットが、通常は明示的なターゲット依存関係を追加できない異なるプロジェクトにある場合に特に便利です。

異なるプロジェクト間で明示的なターゲット依存関係を追加できないため、手動の依存関係順序を使用して特定の順序でターゲットを構築している場合、依存関係順序の選択と組み合わせて暗黙の依存関係の検索を有効にすることが、多くの場合、より良い解決策です。

次に、スクリプトフェーズとビルドルールについて話します。

プロジェクトのターゲットリストからSmoothyKitターゲットを選択し、[ビルドフェーズ]タブを選択します。

ここでは、カスタムビルドロジックを含むプロセスレシピスクリプトフェーズがあります。

その責任の1つは、入力ごとに1つの出力を持つ多数のレシピファイルからコードを生成し、順番に処理することです。

さて、これらの計算は互いに完全に独立していることに気づくかもしれません。

これは、それらを並行して実行することで活用できるパフォーマンス最適化の機会を提供します。

ルールを構築することで、私たちはまさにそれを行うことができます。

この作業をビルドルールに抽出する方法を見てみましょう。 ルール

フレームワークのプロジェクトエディタの[ビルドルール]タブに移動し、プラスボタンをクリックして新しいビルドルールを追加します。

次に、このルールで処理するファイルタイプのファイル拡張子に対応するファイルパターン「*.recipe」を入力します。

次に、このルールに依存関係を追加します。

入力として処理する各入力ファイルが自動的に取得されるため、ビルドルールに追加の入力を追加する必要はありません。

ただし、ルールが処理するファイルごとに生成する出力ファイルのパスをビルドシステムに伝える必要があります。

プラスボタンをクリックして新しい出力ファイルを追加し、$(DERIVED_ FILE_ DIR)/$ (INPUT_ FILE _BASE) .compiledrecipeを入力します。

ビルドシステムによって管理される適切な場所を指すため、生成されたファイルをDERIVED_FILE_DIRに書き込むのがベストプラクティスです。

ソースルートで出力ファイルを生成することは避けるべきです。

これは、複数のビルドを同時に実行すると、ソース制御に干渉し、競合につながる可能性があります。

もちろん、スクリプトのフェーズコードをルールにコピーする必要があります。

スクリプトフェーズに戻り、各ファイルを処理したコードをコピーします。

その後、ルールに戻り、それを貼り付けます。

ルールは、処理する入力ごとに1回実行されることを忘れないでください。

したがって、forループを削除し、$RECIPEを$SCRIPT_INPUT_FILEに置き換えます。これは、処理中の現在の入力ファイルの絶対ファイルパスに対応し、$DERIVED_FILE_DIR/ $RECIPE.compiledrecipeを$SCRIPT_OUTPUT_FILE_0に置き換えます。これは、以下の出力ファイルセクションで

ファイルパスのスペースやその他の特殊文字が正しく処理されていることを確認するために、変数を引用することを忘れないでください。

すごい。

今、ルールで設定すべきことがもう1つあります。

ルールは、処理する入力ごとに1回実行されると述べました。

デフォルトでは、ターゲットがコンパイルしているアーキテクチャごとに1回実行されます。

たとえば、Macアプリのターゲットのルールは、arm64に対して1回、x86_64に対して各入力を1回実行することがあります。

したがって、4つの入力と2つのアーキテクチャがある場合、ルールは8回呼び出されます。

これは、ルールの出力がオブジェクトコードなどのアーキテクチャに依存している場合に便利です。

しかし、この場合、私のルールは基礎となるCPUアーキテクチャから独立した出力を生成するので、「アーキテクチャごとに1回実行」のチェックを外します。

最後に、ビルドシステムが入力ファイルをビルドルールに伝播するには、フレームワークターゲットのコンパイルソースビルドフェーズにすべての.recipeファイルを追加する必要があります。

ビルドフェーズに戻り、コンパイルソースを展開し、プラスボタンを使用してレシピファイルを追加します。

では、スクリプトフェーズに戻りましょう。

これが行う残りの作業は、複数のテキストファイルの内容を1つのファイルにマージすることで、アプリで実行時により効率的に読み込むことができます。

そして、より良いソース制御の経験を持つために、私はスクリプトをプロジェクトファイルの外部に保管し、ここでインラインスクリプトエディタからそれらを呼び出しています。

それでは、package.shへの参照に従ってコードを見てみましょう。

この場合、すべての入力を一度に処理して1つにまとめる必要があるため、ビルドルールは適切ではありません。

したがって、並行して実行できる分離されたユニットに分割する方法がないため、この作業をスクリプトフェーズに維持することは理にかなっています。

しかし、これは最も重要なポイントの1つに私たちをもたらします:スクリプトには入力と出力の依存関係が指定されていません。

これは、スクリプトフェーズが使用している可能性のあるファイルがわからないため、Xcodeが他のタスクを並行して実行することに関してより保守的でなければならないため、ビルドタスクが間違った順序で実行され、ビルドが遅くなる可能性があります。

したがって、スクリプトフェーズによって実行される作業がビルド内の他のタスクと比較して正しい順序で行われるように、入力と出力の依存関係を追加することが重要です。

この特定のスクリプトには、多数の入力があります。

これらをプロジェクトファイルに1つずつ入力する代わりに、xcfilelistを使用して、外部ファイルを介してこの入力リストを管理できます。

今からプロジェクトに1つ追加します。

「ファイル」>「新規ファイル」に移動し、「その他の」セクションの下にある「フェーズファイルリストのビルド」を選択します。

このスクリプトフェーズで処理される入力ファイルのリストを1行に1つずつ貼り付けます。

必要に応じて、ポンド記号で行を開始してコメントを書くこともできます。これは、追加のコンテキストを追加するのに最適です。

次に、スクリプトフェーズからこのxcfilelistを参照します。

スクリプトフェーズに戻り、入力ファイルリストのxcfilelistへのパスを指定します。

最後に、ビルドルールで行ったのと同じように、出力内容が書き込まれるファイルパスを提供することで、出力依存関係を指定します。

もう1つ言及すべきことがあります。

ビルドルールと同様に、スクリプトフェーズによって提供される重要な環境変数がいくつかあります。

Package.shに戻って詳しく見てみましょう。 

ソースでは、SCRIPT_INPUT_FILE_LIST_COUNTを参照します。これは、スクリプトフェーズに渡された入力ファイルリストの総数、SCRIPT_INPUT_FILE_LIST_nを参照します。これは、n番目のインデックスの入力ファイルリストの解決された絶対ファイルパスを参照し、SCRIPT_OUTPUT_FILE_0を参照します。これは、

以下は、スクリプトフェーズに提供される主要な環境変数の概要です。

ターゲットのビルド設定は、スクリプトフェーズ環境でも利用できます。

以下は、ルールを構築するための特定の環境変数と、あまり一般的ではない環境変数の概要です。

スクリプトフェーズと同様に、ターゲットのビルド設定もビルドルール環境で利用できます。

わかりました。さて、プロジェクトを構築しようとすると、問題に遭遇します。

ビルドログに行って、詳しく見てみましょう。

SmoothieKitはマルチプラットフォームのターゲットであるため、2回構築されています。1回はiOS用、もう1回はwatchOS用です。これは、これらのビルドのそれぞれが同じパスでスクリプトフェーズの出力を生成しようとしていることを意味します。

ビルドシステムでは、ビルド全体で1つのタスクのみが特定のパスで出力を生成する必要があるため、これは許可されていません。

これを解決できる方法はいくつかあります。

簡単な解決策の1つは、スクリプトフェーズの出力パスを変更して、ターゲットが構築されるたびに一意になるようにすることです。

この場合、プラットフォーム固有のDERIVED_FILE_DIRのような別のビルド設定を使用することを検討し、パスを十分に一意にし、競合を解決します。

ただし、スクリプトフェーズが行っている実際の作業が各ターゲットのコンテキスト内で同一である場合、同じ作業が2回行われるだけです。

その場合、スクリプトフェーズを、共有フレームワークターゲットが依存する新しい集約ターゲットに移動する方がより良い選択肢です。

それが私のプロジェクトのためにやろうとしていることです。

開始するには、ターゲットリストの下部にあるプラスボタンをクリックし、[その他]タブを選択し、[ターゲットの集計]を選択します。

私はそれをリソースと呼びます。

次に、新しいスクリプトフェーズを追加し、フレームワークターゲットから名前、スクリプトソース、入力、出力をコピーします。

最後に、フレームワークターゲットから元のスクリプトフェーズを削除し、新しい集約ターゲットにターゲット依存関係を追加します。

このようにして、作業は一度だけ行われ、出力ファイルの競合はなく、フレームワークのiOSとwatchOSの両方のバリアントは、そのスクリプトフェーズに対して正しい順序で構築されます。

成功する。

そして今、Prachiに戻って、誰がビルド設定についてあなたにすべて話すつもりです。

プラチ：ありがとう、ジェイク！

では、ビルド設定とは何ですか?

これは、ビルド方法の側面を設定するために、Xcodeターゲットに適用できるプロパティです。

Xcodeは、ビルド設定を構成するための2つの主要なメカニズムを提供します。

1つ目は、ビルド設定エディタを介してです。

2つ目は、構成設定ファイルまたは.xcconfigファイルです。

まず、ビルド設定エディタを使用してプロジェクト内の設定を管理する方法を見てみましょう。

ビルド設定エディタを表示するには、まずプロジェクトナビゲーターでプロジェクトを選択する必要があります。

次に、設定するターゲットを選択してください。

そして最後に、タブバーの[ビルド設定]タブをクリックします。

ここから、新しいビルド設定を追加したり、既存の設定を変更したりできます。

クイックヘルプインスペクタを開いて、選択したビルド設定の追加情報を見つけることもできます。

ビルド設定は複数のレベルで定義されています。

これは定義の積み重ねと考えることができます。

実際、これらのレベルは、レベルフィルターをクリックすることで視覚化できます。

各列は、ビルド設定を定義できる異なるレベルを表し、右から左に評価されます。

最低レベルから始めて、現在選択されているSDKによって定義されたデフォルト値、プロジェクトレベルの構成設定ファイル、Xcodeプロジェクトファイルからのプロジェクトレベル設定、構成設定ファイルで定義されたターゲット設定、Xcodeプロジェクトファイルで定義されたターゲットレベルの設定、そして最後に、ビルド設定の解決値があります。

レベルがビルド設定の明示的な値を持つことを示す太字の設定が表示された場合は、注意してください。

ビルド設定を管理するためにXcodeが提供するもう1つのメカニズムは、構成設定ファイルまたは.xcconfigファイルです。

Xcconfigファイルの利点には、より良いソース管理管理、ターゲットまたは構成間で設定の共有、ビルド設定の高度な構成、および開発またはテスト環境に基づいて追加のxcconfigファイルを含める機能が含まれます。

Xcconfigファイルでビルド設定を作成する方法を見てみましょう。

最も基本的なレベルでは、ビルド設定は名前、代入演算子、および値で構成されています。

条件付き構文を使用して、ビルド設定の値を絞り込むことができます。

条件設定は角括弧を使用して定義されます。

サポートされている条件には、構成、アーキテクチャ、SDKなどがあります。

SDK条件に示すように、ワイルドカードはマッチング目的で使用できます。

おなじみのダブルスラッシュ構文を使用してコメントを追加することもできます。

ビルド設定は、dollar-parens構文を使用して、別のビルド設定の値に設定できます。

この例では、MY_OTHER_BUILD_SETTINGがYESに設定されています。

MY_BUILD_SETTING_NAMEの値は、dollar-parens構文を使用してMY_OTHER_BUILD_SETTINGを評価します。

MORE_SETTINGSで見られるように、ここでも複数の値を評価できます。

そして最後に、ビルド設定の既存の値は、$(継承)値で使用できます。

これにより、既存の値をすべて保持しながら、ビルド設定に追加値を追加できます。

これは、ビルド設定名であるAPPEND_TO_EXISTING_SETTINGSを使用することもできるため、便利なフォームです。

ビルド設定評価構文のもう1つの用途は、他のビルド設定のセットからビルド設定を一緒に作成することです。

まず、コントロール設定から始めます: IS_BUILD_SETTING_ENABLED。

この設定の値を、MY_BUILD_SETTING_NOとMY_BUILD_SETTING_YESの2つの追加ビルド設定のサフィックスとして使用します。

最後に、MY_BUILD_SETTINGとIS_BUILD_SETTING_ENABLEDの両方で構成される値を持つようにMY_BUILD_SETTINGを定義します。

ビルド設定の評価はインサイドアウトで行われるため、最も内側の設定が評価され、IS_BUILD_SETTING_ENABLEDの値であるNOを返します。

最後に、構成されたBUILD_SETTING_NOは-use_this_oneの値に評価されます。

ビルド設定を評価する際には、値の基本的な変換を提供するために使用できる一連の演算子があります。

演算子の3つの分類は、文字列演算子、パス演算子、および置換演算子です。

サポートされている文字列演算子は、文字列内の文字をエスケープする引用符、文字のケースを変換する下と上、および文字列をさまざまな形式で有効な識別子に変換する識別子です。

ディレクトリ、ファイル名、基本名、接尾辞、および標準化されたパスを取得するための一連のパス演算子を提供します。

各パス演算子には、値の一部を置き換えることができる代替演算子があります。

ビルド設定が空の場合、置換値を提供するデフォルト演算子もあります。それ以外の場合は、ビルド設定の既存の値を使用します。

最後に見るべき項目は、他のxcconfigファイル内にxcconfigファイルを含める機能です。

利用可能なメカニズムは2つあります。

1つ目は、xcconfigファイルがディスクに存在する必要があるインクルードが必要です。

ファイルが見つからない場合、コンパイラエラーが発生します。

2つ目はオプションのインクルードで、ディスクに存在する場合はxconfigファイルを含めることができます。

ファイルが存在しない場合、これは失敗しません。

パスはXcodeプロジェクトファイルの場所から相対的であることに注意してください。

では、これらすべての情報を現実世界のシナリオにまとめる方法を見てみましょう。

この例では、次の問題を解決する方法を見ていきます。

私たちの開発マシンでは、コンパイラは入力チェックに時間がかかりすぎる式を積極的に警告する必要があります。

ただし、CIマシンは遅いため、式チェックの時間を増やす必要があります。

当社のソリューションには、debug、common、ci.xcconfigの3つの構成設定ファイルがあります。

デバッグxcconfigファイルは、デバッグビルドに使用され、 OTHER_SWIFT_FLAGSビルド設定を介してSwiftコンパイラにいくつかの追加のフラグを渡します。

一般的なxcconfigファイルには、オプションでci.xcconfigファイルが含まれています。

また、型式警告を制御するための OTHER_SWIFT_FLAGS 設定も定義しています。

$(継承)を使用して、debug.xcconfigファイルやデフォルト値200のMAX _EXPRESSION_TIMEのビルド設定評価など、他のフラグ設定が含まれていることを確認します。

Ci xcconfigファイルは、MAX_EXPRESSION _TIMEのオーバーライド値を定義します。

最後に、Xcodeは、これらのxcconfigファイルをサポートされている構成レベルの1つに適用する方法を伝える必要があります。

これは、ここで見られるプロジェクトエディタを通じて行われます。

設定セクションから、定義されたビルド設定に対して、プロジェクトまたはターゲットレベルでプロジェクトの任意の設定ファイルを適用できます。

ここでは、debug.xcconfigファイルがFrutaのデバッグ設定のプロジェクトレベルで適用されていることがわかります。

また、プロジェクト内のターゲットごとにcommon.xcconfigファイルが設定されています。

解決策を要約すると、デフォルトの演算子を使用してMAX_EXPRESSION_TIMEのデフォルト値を定義しました。

ci.xcconfigファイルは、CIシステムにのみ存在するため、オプションで含まれていました。

そして、CI xcconfigファイルでは、MAX_EXPRESSION_TIMEのデフォルト値のオーバーライドが使用されました。

これは私たちの実用的な例を締めくくります。

さて、ジェイクに戻って、私たちがカバーしたすべてを見直しましょう。

ジェイク:ありがとう、プラチ。

要約しましょう。

マルチプラットフォームフレームワークと、マルチプラットフォームプロジェクトのビルド設定とビルドフェーズを管理する簡単な方法を提供する方法について学びました。

依存関係の順序に従って並行してターゲットを構築することで、プロジェクトの構成を改善し、パフォーマンスを構築する方法、ビルドルールとビルドフェーズを適切に使用する方法、および依存関係を指定することの重要性を見ました。

最後に、ビルド設定、構成設定ファイルを使用してそれらをより簡単に管理する方法を深く掘り下げ、その構文とそれが提供するすべての構造を掘り下げました。

これらのレッスンが、開発経験を最大限に活用するのに役立つ一連の便利なツールを提供することを願っています。

見てくれてありがとう!

♪