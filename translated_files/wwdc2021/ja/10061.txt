10061

ドナ：こんにちは。

私はDonna Tomで、TextKitのエンジニアです。

同僚のクリス・ウィルモアが後でこのビデオに参加します。

Appleの次世代テキストエンジンであるTextKit 2を導入します。

TextKit 2が何であるかを理解するために、TextKit 1と呼ぶオリジナルのTextKitを簡単に復習しましょう。

TextKit 1は、Appleのすべてのプラットフォームでテキストレイアウトと表示を駆動するテキストエンジンです。

UIKitとAppKitのテキストコントロールは、TextKit 1を使用してストレージを管理し、テキストコンテンツのレイアウトを制御します。

TextKit 1は、20年以上前にOpenStepのシステムに初めて登場しました。

macOS 10.0からiOS 7、macOS 11、iOS 14まで、長年にわたって成長し、進化してきました。

TextKit 1が依然としてすべてのAppleデバイスで非常に多くの必須機能に電力を供給していることは非常に驚くべきことです。

技術設計とエンジニアリングの原則は、何十年にもわたって大きく変化してきました。

TextKit 1は元の原則に結びついているため、高水準のパフォーマンスを提供しながら、新しい技術とうまく統合するAPIを提供することは、長年にわたってより困難になっています。

それが私たちがTextKit 2を構築した理由です。

TextKit 2は、一連の前向きなデザイン原則に基づいて構築されたAppleの次世代テキストエンジンです。

そして、何だと思う?

あなたはすでにMacでTextKit 2を使っています。

Big Surでは、舞台裏でTextKit 2を使用するように、OS全体のテキストコンポーネントの多くを更新しました。

大きな驚き：あなたはmacOS 11からTextKit 2を使っています。

では、これを行うことができるアーキテクチャを簡単に確認しましょう。

TextKit 2はTextKit 1と共存しています。

前身と同様に、TextKit 2はFoundation、Quartz、Core Textの上に構築されています。

UIKitとAppKitのテキストコントロールは、TextKit 2の上に構築されています。

TextKit 2はまた、前任者のMVCデザインをゆるやかに保持しています。

ビュー部分はUIKitとAppKitフレームワークのビューオブジェクトに残りますが、古い友人であるNSTextStorageとNSLayoutManagerの新しいバージョンがあります。

これらの新しいバージョンに加えて、モデルレイヤーとコントローラーレイヤーに参加する新しいクラスとプロトコルがたくさんあります。

かなりの数がありますが、心配しないでください。 心配しないでください。

これらの新しいコンポーネントは、シンプルで集中的で、パワフルな組み合わせです。

彼らは、あなたがテキストでやりたいことを表現しやすくなり、システムがあなたが望むことをどのように達成するかを心配しなくなります。

システムのアーキテクチャビューがわかったので、詳細を掘り下げてみましょう。

まず、TextKit 2のコア設計原則と、これらの原則がアプリ内のテキストのストレージ、レイアウト、表示のカスタマイズに関する考え方をどのように変えるかについて説明します。

その後、クリスは私たちがレシピの本で共同作業するために作成したTextKit 2サンプルアプリを案内します。

このアプリは、新しいTextKit 2クラスを使用して、CALayersでテキストをレイアウトして表示します。

ここでは、設計原則が実際にどのように機能するかを学びます。

最後に、TextKit 2用のアプリをモダナイズするための重要な技術的詳細を取り上げます。

では、デザインの原則から始めましょう。

TextKit 2のコアハイレベル設計原則は、正確性、安全性、およびパフォーマンスです。

私たちはバランスの取れたアプローチを取りました。

3つの原則はすべて重要なので、それらを議論する順序に優先順位はありません。

これらの高レベルの設計原則のそれぞれは、システムの特定の設計変更を通知します。

正確性のために、TextKit 2はグリフ処理を抽象化します。

安全のために、TextKit 2は価値セマンティクスに重点を置いています。

また、パフォーマンスのために、TextKit 2はビューポートベースのレイアウトとレンダリングを使用します。

正確性から始めます。

この分野では、国際的なテキストに一貫した体験を提供するために、グリフ処理を抽象化しました。

Appleデバイスは世界中のどこでも使用されているため、すべての言語とスクリプトでテキストに正しいレイアウト、レンダリング、インタラクションを提供することが非常に重要です。

私たちは、誰もが自分のデバイスでテキストを読んだり操作したりできるようにしたいと考えています。

また、TextKit 1 APIの一部の設計により、普遍的に正しい方法で国際テキストを操作することが困難になります。

理由を理解するには、まずグリフが何であるかを理解する必要があります。

グリフは、可変数の文字の視覚的表現です。

多くの西洋言語では、1つのグリフは通常1つの文字を表しますが、これは必ずしも真実ではありません。

1つの文字を表す複数のグリフを持つこともできますし、その逆になることもあります。

1つのグリフは複数の文字を表すことができます。

複数の文字を表すために使用されるこの単一のグリフは、合字と呼ばれます。

西洋言語には合字がそれほど多くなく、通常はテキストの読みやすさには影響しません。

あなたはまだ合字なしでそれをうまく読むことができます。

しかし、それはすべての言語に当てはまるわけではありません。

アラビア語やデーヴァナーガリーのようなスクリプトは、多くの合字を使用しており、読みやすさに影響します。

この単語をアラビア文字でチェックしてください。

それは「瞬間」を意味するウルドゥー語の単語です。

少し時間を取って、これら2つのレンダリングを比較してください。

右側の合字で描かれた完全な単語は、左側の個々の文字とは大きく異なるように見えます。

言語のネイティブ読者は、左側のバージョンが判読不能であると考えるだろう。

TextKit 1のAPIの多くは、グリフインデックスまたは範囲で作業する必要があります。

たとえば、テキストの境界矩形を取得するには、必要なテキストのグリフ範囲を知る必要があります。

テキストが西洋言語の場合、正しいグリフ範囲を理解することはそれほど悪くありません。

この英語の例では、テキストの最初の4文字のグリフ範囲を見つけるのはかなり簡単です。

今、インドの何百万人もの人々が話すスクリプトと言語であるカンナダ語を考えてみましょう。

多くの合字を使用するだけでなく、グリフは並べ替えて、あらゆる種類の興味深い方法で組み合わせることができます。

「10月」を意味するこのカンナダ語は、文字インデックス4で分割された母音を特徴としているため、2つのグリフに分割されます。

次に、左側のものは、2の合字が適用される前に、文字1と2を表すグリフの間で並べ替えられます。

インデックス3の文字を表すグリフも結合形式に置き換えられます。

最後の言葉では、それは分割母音のグリフの1つの下に描かれます。

さて、私が今言ったことを理解していなかったら、それは完全に大丈夫です。

これらは、アプリの構築に集中できるように、フレームワークが処理すべき詳細です。

ポイントは、このようなテキストの最初の4文字のグリフ範囲を見つけることができないということです。

これらの4文字を表す単一のグリフ範囲はありません。

また、多くのTextKit 1 APIはグリフ範囲を必要とするため、これらのAPIを使用すると、このような複雑なスクリプトのレイアウトとレンダリングを壊す可能性があります。

そして、それがTextKit 2がグリフ処理を抽象化する理由です。

TextKit 2は、すべてのテキストをコアテキストでレンダリングするので、複雑なスクリプトに対して自動的に正しいレンダリングを取得します。

TextKit 2でグリフをまったく管理する必要はありません。

代わりに、より高いレベルのオブジェクトを使用して、テキストレイアウトとインタラクションを制御します。

これらの上位レベルのオブジェクトの1つであるNSTextSelectionをご紹介します。

粒度、親和性、選択を構成するテキストのおそらくバラバラな範囲など、テキスト選択を表すために必要なすべてのコンテキストが含まれています。

NSTextSelectionのこれらのプロパティは読み取り専用なので、選択オブジェクトのインスタンスを変更して変更することはありません。

代わりに、NSTextSelectionNavigationのインスタンスを使用して、テキスト選択に対してアクションを実行し、結果の選択を表すNSTextSelectionの新しいインスタンスを受け取ります。

ナビゲーションオブジェクトに、画面上のポイントでタップまたはマウスダウンイベントから選択したり、前方または後方に移動して新しい選択を取得するように依頼できます。

これにより、選択範囲を1つの単語で前方に拡張し、正しい結果を得るなど、右から左の言語の双方向テキストを考慮しやすくなります。

今、私はこれらの新しい選択APIについて何か興味深いことにあなたの注意を喚起したいと思います。

このメソッドはNSTextLocationを取ります。

これはTextKit 2のもう1つの新しいオブジェクトです。

NSTextLocationとNSTextRangeをご紹介します。

これらは、UIKitのUITextPositionおよびUITextRangeクラスと非常によく似ていますが、サブクラスにする必要はありません。

ほとんどの場合、TextKit 2でデフォルトの場所と範囲のオブジェクトを使用します。

整数の代わりにオブジェクトを使用すると、範囲は互いに相対的な位置の観点から定義されているため、より表現力豊かなドキュメントモデルが可能になります。

HTMLドキュメントオブジェクトモデルは、その良い例です。

ネストされた要素があるため、場所はドキュメント内の絶対位置と可視テキスト内の位置の両方を表す必要があります。

これは単一の数値インデックスでは表現できません。

そして、それは正しさのためです。

次は安全です。

この分野では、SwiftやSwiftUIなどのテクノロジーの目標によりよく一致するように、バリューセマンティクスに重点を置いたTextKit 2を設計しました。

そして、私が「価値セマンティクス」と言うとき、私は価値タイプについて話しているのではありません。

NSLayoutManagerを構造体にはしませんでした。

値タイプはデータの一意のコピーを保持し、そのデータの突然変異を防ぎます。

これにより、意図しない共有や関連する副作用を取り除くことで、コードがより安全で安定したものになります。

しかし、価値タイプは、この利益を得る唯一の方法ではありません。

不変クラスには、初期化後に変更できないプロパティがあり、データの突然変異も防ぎます。

これらのクラスは値型のように振る舞うので、値セマンティクスを持つと呼びます。

これらのオブジェクトの1つのデータを変更したい場合は、元のインスタンスを置き換えるために真新しいインスタンスを作成する必要があります。

そして、TextKit 2の多くのクラスはこのように設計されています。

このデザイン変更の利点を説明するために、TextKit 1のデザインに関する記憶をリフレッシュしましょう。

ストレージから画面へのテキストの流れは、このように機能していました。

テキストストレージの更新は、レイアウトマネージャーに通知し、グリフを生成し、配置し、ビューに直接描画します。

ビューに直接グリフを描画するこのアプローチでは、カスタム描画用のスペースを作成するためにテキストを分離する場所を理解することは困難です。

私が何を意味するのかを理解するために、レシピにいくつかのコメントを残したサンプルアプリからこのスニークピークスクリーンショットをチェックしてください。

コメントが参照しているレシピのすぐ下にどのように表示され、この明確な泡の形をしたインディゴの背景と白いテキストで描かれていることに注目してください。

正しい場所にコメントを挿入し、テキストの残りの部分と異なって見えるようにするには、どのようなアプローチを取るべきですか?

レシピテキストを意味のある単位または要素に分割し、各コメントを独自の要素に入れ、関連するレシピの後に各コメントを配置しながら、コメントの描画方法の指示を提供することで、これを行うことを期待するかもしれません。

TextKit 1では、現実はかなり異なります。

グリフインデックスの検索、グリフが書記素クラスタの真ん中にないことを確認する、そのグリフインデックスの調整、行間隔の変更、ラインフラグメントジオメトリのカスタマイズなど、多くの詳細を心配する必要があります。

そして、これらの詳細は、あなたがやろうとしていることとは関係ありません。

したがって、TextKit 2では、期待を現実にすることを目指しています。

このようなアプローチを可能にするために、システムを通るテキストの流れを変更しました。

TextKit 2でそのフローの仕組みは次のとおりです。

テキストストレージの更新は、コンテンツマネージャーと呼ばれる新しいオブジェクトを通過します。

コンテンツマネージャーは、テキストを要素に分割し、それらを追跡します。

レイアウトの時間になると、テキストレイアウトマネージャーはコンテンツマネージャーに要素を尋ねます。

次に、テキストレイアウトマネージャは要素をテキストコンテナにレイアウトし、レイアウトと位置情報を含むレイアウトフラグメントを生成します。

表示の時間になると、レイアウトフラグメントはViewportLayoutControllerに引き渡され、ビューであろうとレイヤーであろうと、選択したレンダリングサーフェス内のそれらのフラグメントの位置とレイアウトを調整します。

わかるように、このプロセスには多くの新しいオブジェクトが関与しています。

そして、ここで価値セマンティクスに重点が置かれます。

適切なポイントでシステムにフックし、値セマンティクスを使用するオブジェクトから必要な情報を取得することで、テキストのレイアウトと表示を制御します。

変更を加えるには、必要な変更で値オブジェクトの新しいインスタンスを作成し、システムに返します。

システムは、レイアウトと表示に置換オブジェクトの値を使用します。

それでは、これらの新しいオブジェクトに会い、それらを受信または交換できるシステムのさまざまなポイントを特定しましょう。

ストレージオブジェクトから始めます。

NSTextElementをご紹介します。

要素はドキュメントの構成要素です。

各要素はコンテンツの一部を表し、ドキュメントのどこにあるかを記述する範囲が含まれています。

そして、要素には価値のセマンティクスがあります。

範囲を含むそれらのプロパティは不変であり、要素の作成後に変更することはできません。

文書を一連の文字ではなく一連の要素としてモデル化することは、私たちにもっと多くの力を与えます。

テキストの段落、添付ファイル、またはその他のカスタムタイプなど、特定の要素が表すコンテンツの種類を簡単に区別できます。

そして、そのタイプに基づいて要素をレイアウトする方法を決定することができます。

それでは、NSTextContentManagerに会いましょう。

コンテンツマネージャーは、テキストコンテンツから要素を生成する方法を知っており、ドキュメント全体内のそれらの要素の範囲を追跡します。

また、バッキングストアで作業する方法や、バッキングストアのコンテンツが変更されたときに更新された範囲で新しい要素を生成する方法も知っています。

コンテンツマネージャーをバッキングストアのラッパーと考えてください。

コンテンツマネージャーは、生データを要素に変換するためのインターフェースを提供します。

NSTextContentManagerとNSTextElementはどちらも抽象型であるため、カスタムドキュメントモデルまたはカスタムバッキングストアを使用する必要がある場合は、それらをサブクラス化できます。

ヘッダーとドキュメントは、これを行う方法に関するガイダンスを提供します。

しかし、ほとんどの場合、TextKit 2が提供するデフォルトのものを使用できます。

NSTextContentStorageとNSTextParagraphをご紹介します。

これらはデフォルトのコンテンツマネージャーと要素タイプです。

NSTextContentStorageは、NSTextStorageをバッキングストアとして使用するコンテンツマネージャーです。

テキストストレージの内容を、NSTextParagraphのインスタンスである段落要素に分割する方法を知っています。

NSTextContentStorageは、テキストストレージ内のテキストが変更されたときに更新された段落要素を生成する方法も知っています。

これは私を重要なポイントに導きます。

基礎となるテキストストレージに変更を加えるときは、このperformEditingTransactionメソッドで更新をラップする必要があります。

これにより、TextKit 2システムの他の部分にあなたの変更が確実に通知されます。

完全なNSTextContentManagerサブクラスを実装することなく、コンテンツストレージデリゲートでいくつかのクールなことを行うことができます。

このビデオの後半では、クリスは、コンテンツデリゲートを使用してテキストストレージを変更せずにコメントのフォントと色を変更する方法と、コメントを完全に非表示にする方法について説明します。

詳細については、ご期待ください。

わかりました。

これで、TextKit 2がテキストコンテンツから要素を作成する方法を理解しました。

それは私たちの新しいアプローチからの最初の2つのステップの世話をします。

コンテンツストレージは自動的にテキストを段落要素に分割し、新しいコメントの新しい段落を作成する方法を知っています。

次に、コメントのポジショニングと表示という最後の2つのステップを達成する方法を考えてみましょう。

フロー図に戻ると、コメント要素のレイアウト情報を取得する必要があります。

これらのタスクに役立つ新しいレイアウトオブジェクトがあります。

今、彼らに会いましょう。

NSTextLayoutManagerをご紹介します。

テキストレイアウトマネージャは、テキストレイアウトプロセスを制御します。

NSTextLayoutManagerは、TextKit 1の古いNSLayoutManagerに似ていますが、1つの大きな違いがあります。NSTextLayoutManagerはグリフを扱っていません。

代わりに、NSTextLayoutManagerはテキスト要素をテキストコンテナにレイアウトし、それらの要素のレイアウトフラグメントを生成します。

レイアウトフラグメントを使用して、テキスト要素のレイアウト情報を取得します。

それでは、レイアウトフラグメントについて学びましょう。

NSTextLayoutFragmentをご紹介します。

レイアウトフラグメントには、1つ以上のテキスト要素のレイアウト情報が含まれています。

要素と同様に、それらは値セマンティクスを使用し、そのプロパティは不変です。

したがって、テキストレイアウトマネージャーは、各コメント要素のレイアウトフラグメントを作成し、レイアウトフラグメントの情報を使用して配置して表示することができます。

レイアウトフラグメントは、textLineFragmentsの配列、layoutFragmentFrame、およびrendersSurfaceBoundsの3つのプロパティを通じてレイアウト情報を伝えます。

レイアウトをカスタマイズまたは変更する場合は、これらの各プロパティで得られる情報を理解することが不可欠です。

だから、次はそれを調べます。

最初のプロパティでは、NSTextLineFragmentに会います。

ラインフラグメントには、レイアウトフラグメント内のテキストの各行の測定情報が含まれています。

これらは、特定の行の幾何学的情報を取得したり、レイアウトフラグメントの行数を数えたりするのに便利です。

2番目のプロパティであるレイアウトフラグメントフレームは、レイアウトフラグメント内のテキストがテキストコンテナ領域内にどのようにレイアウトされるかを説明しています。

TextKit 2では、テキストレイアウトは基本的にコンテナ内のレイアウトフラグメントフレームを積み重ねています。

これらのフレームをタイルのように考えてください。

システムは、テキストコンテナ領域をタイルに分割しており、各レイアウトフラグメントは単一のタイルです。

図に示すように、空の線には独自のレイアウトフラグメントフレームがあります。

一般に、レイアウトフラグメントフレームは、フラグメントコンテンツの近くにUI内の他のビューを配置したり、テキストコンテンツの合計高さを計算したりするのに便利です。

さて、このフレームはテキスト自体を描画するために必要なスペースを正確に表していません。

その情報は第3の財産から来ています。

レンダリングサーフェスの境界は、テキストを描画するために必要な領域を記述します。

これは、ビューの座標空間内のテキストのサイズを取得するために使用する長方形です。

そして、テキストはフラグメントフレームの端をオーバーシュートする可能性があるため、これはレイアウトフラグメントフレームとは異なります。

これは、発音記号、またはここに示すように、イタリックフォントの長いディセンダで発生します。

Jの左下端がレイアウトフラグメントフレームからほんの少し突き出ていることに注目してください。

それはそれほど目立たないので、ここにもっと極端な例があります。

Zapfinoのようないくつかのフォントには、タイポグラフィの境界をはるかに超えているグリフがあります。

この場合、レンダリングサーフェスの境界はレイアウトフラグメントフレームよりもはるかに大きくなります。

レイアウトフラグメントが提供するレイアウト情報を理解したので、少しバックアップして、この情報を使用してテキスト要素のレイアウトをカスタマイズする方法について話しましょう。

レイアウトフラグメントは不変であるため、フラグメントのレイアウト情報を直接変更することはできません。

フロー図に戻ると、レイアウトプロセスにフックし、変更したい情報を使用してNSTextLayoutFragmentの新しいインスタンスを作成する必要があります。

そして、NSTextLayoutManagerでこのデリゲートメソッドを使用してレイアウトプロセスにフックします。

このメソッドは、テキストレイアウトマネージャーが要素からレイアウトフラグメントを生成しているときに、レイアウトプロセス中に呼び出されます。

ここでは、要素の独自のレイアウトフラグメントを作成する機会があります。

これは、コメント問題へのアプローチの最後の2つのステップを処理します。

NSTextLayoutFragmentのサブクラスを使用し、テキストレイアウトマネージャーデリゲートにカスタムフラグメントのインスタンスを提供することで、コメントレイアウトフラグメントの配置とカスタム描画を処理します。

このビデオの後半で、クリスはこれが私たちのサンプルアプリでどのように行われるかを実演します。

そして、それは安全です。

では、パフォーマンスに移りましょう。

パフォーマンスは、あらゆるテキストエンジンにとって最大の課題の1つです。

TextKit 2は、それぞれわずか数行のラベルをすばやくレンダリングすることから、インタラクティブな速度でスクロールされる数百メガバイトのドキュメントをレイアウトすることまで、信じられないほど幅広いシナリオで非常に高速です。

そして、これらのシナリオでは、これらの本当に大きな文書を可変速度でスクロールしているとき、連続しないテキストレイアウトは優れたパフォーマンスのために絶対に不可欠です。

連続したレイアウトと非連続したレイアウトの違いを確認しましょう。

この図は、黄色の長方形が画面上の目に見えるコンテンツ領域を表す文書を示しています。

連続したレイアウトは、ドキュメントの先頭から始まり、テキストの先頭から末尾まで順番に進みます。

したがって、ドキュメントの中央のどこかのポイントまでスクロールすると、連続したレイアウトは、そのポイントの前に来たすべてのテキストのレイアウトを実行します。

これには、最初から最後まで、画面からスクロールされたすべてのテキストが含まれます。

また、テキストが多い場合は、パフォーマンスが遅くなり、スクロール時にアニメーションのしゃっくりが得られる可能性があります。

最悪の場合、それはハングアップすることができます。

対照的に、非連続したレイアウトは、その前に来る部分をレイアウトすることなく、文書内のどこにでもテキストの一部をレイアウトできることを意味します。

ドキュメントの中央までスクロールすると、その表示領域のレイアウトがすぐに発生します。

これにより、画面に表示されるテキストの一部と追加のオーバースクロール領域に対してのみレイアウトを実行することでパフォーマンスが向上し、よりスムーズなスクロール体験が得られます。

そして、TextKit 2のレイアウトは常に連続しません。

対照的に、TextKit 1では非連続レイアウトはオプションです。

NSLayoutManagerのブールプロパティを使用して有効になります。

このAPIはシンプルですが、シンプルであるため、レイアウト情報を要求したときのレイアウトの状態に関する情報を表現することはできません。

非連続レイアウトは、ドキュメントの他の部分がレイアウトされると後で変更される可能性のある見積もりに依存しています。

TextKit 1では、非連続レイアウトのオン/オフのみを切り替えることができます。

ドキュメントのどの部分がレイアウトされるかを制御する機能はなく、レイアウトがいつ終了し、レイアウトの見積もりが実際の値に更新されるかを知る方法はありません。

TextKit 2 APIは、より豊かで表現力豊かです。

TextKit 2は、可視コンテンツ領域の要素の一貫したレイアウト情報を提供し、その可視領域のレイアウトが更新されたときに通知します。

このエリアはビューポートと呼ばれています。

ビューポートを調整または再配置して管理し、ビューポートレイアウトの前、最中、後にコールバックを受け取ります。

最適なパフォーマンスを得るには、コードはビューポート領域内のレイアウト情報の操作に集中する必要があります。

可能であれば、ビューポート外の要素のレイアウト情報を要求しないでください。

ビューポート外の要素のレイアウト情報は、これらの要素に対応するテキスト範囲のレイアウトの確保を明示的に要求しない限り、正確ではない可能性があります。

この通話は、特に大きな文書の場合、高価になる可能性があります。

先ほどのフロー図を再検討すると、ビューポートの管理に役立つ別の新しいコントローラークラスがあります。

NSTextViewportLayoutControllerをご紹介します。

これは、ビューポートレイアウト情報の真実の源です。

テキストレイアウトマネージャーと話して、ビューポート領域内の要素のレイアウトフラグメントを取得します。

テキストレイアウトマネージャーのプロパティからビューポートレイアウトコントローラーにアクセスできます。

ビューポートレイアウトコントローラーに出会ったので、ビューポートレイアウトプロセスに参加する方法について話しましょう。

ビューポートレイアウトコントローラーは、ビューポートレイアウトプロセス中にデリゲートの3つの重要なメソッドを呼び出します。TextViewportLayoutController WillLayout、textViewportController configureRenderingSurface FortextLayoutFragment、およびtextViewportLayoutController DidLayout。

まず、ビューポートレイアウトコントローラーは、ビューポートに要素をレイアウトする前に、willLayoutメソッドを呼び出します。

ここでは、ビューやレイヤーの内容をクリアするなど、レイアウトの準備のためのセットアップ作業を行う場所です。

次に、ビューポートレイアウトコントローラーは、ビューポートに表示されるすべてのレイアウトフラグメントに対してconfigureRenderingSurfaceを呼び出します。

ここでは、各フラグメントビューまたはレイヤーのジオメトリを更新します。

最後に、ビューポートレイアウトコントローラーは、ビューポートに表示されるすべてのレイアウトフラグメントのレイアウトが完了した後、didLayoutメソッドを呼び出します。

そして、ビューポートのレイアウトが完了した後、ビューポートを調整して最後の要素を画面に完全に表示したい場合など、必要な更新を実行する場所です。

そして、それはパフォーマンスのためにそれを要約します。

今、私はそれをクリスに渡して、実際にTextKit 2の使い方をお見せします。

ありがとう、ドナ。

TextKit 2を使用してアプリ内のテキストをレイアウトしたり操作したりするさまざまな方法のいくつかを示すサンプルアプリを書きました。

このビデオで使用されているサンプルコードをダウンロードできます。

開けて試してみましょう。

このコラボレーションアプリを使用してレシピの本をレビューし、昼食に何を作りたいかを把握できます。

レシピのスクロールは期待どおりに機能しますが、舞台裏で何か特別なことが起こっています。ビューポートに表示される段落のみが描画されています。

そして、すべての段落が同じ大きな表面にレンダリングされる代わりに、各段落は独自のレイヤーにレンダリングされます。

ここのツールバーの[境界を表示]ボタンをクリックすると、これらの色付きの長方形が表示されます。

オレンジ色の長方形は、各レイヤーの境界を示しています。

テキストを別々のレイヤーに描画すると、楽しい機能を実装できます。レシピにコメントを残すことができます。

さて、エッグサンドイッチはかなり良さそうだと思うので、この段落をダブルクリックして「ねえ、これはかなり良さそうですね」と入力し、Enterキーを押してコメントを挿入します。

文書に新しい段落を挿入しました。

バブルの背景は、BubbleLayoutFragmentと呼ばれるNSTextLayoutFragmentのカスタムサブクラスによって描画されています。

それについては後で詳しく説明します。

特別なのは、文書にコメントを挿入すると、コメントの下のすべての段落がそれのためのスペースを作るために移動することです。

初めて捕まえなかった場合は、ツールバーのこのタートルボタンをクリックしてスローモードを有効にします。

別のコメントを追加しましょう。

ええ、今日の昼食に作りましょう。

Enterキーを押すと、その下のドキュメントにコメントが追加され、その下のすべての段落がゆっくりとアニメーション化されます。

すべてのコメントを非表示にしたい場合は、ツールバーの[コメントの切り替え]ボタンをクリックします。

これは実際に基礎となる文書を編集しているわけではありません。

代わりに、レイアウトのテキスト要素を列挙するときにコメントをスキップするようにテキストコンテンツマネージャーに求めています。

TextKit 2は、macOSと同様にiOSでも同様に機能します。

これは、macOSアプリのTextKit 2の部分がiOSで再利用できることを意味します。

iPadで実行しましょう。

これらの部分を使用して、同じ機能を備えたコラボレーションアプリのiOSバージョンを書きました。

段落を長押ししてコメントを残し、「やあ、それは良さそうだね」と入力しています...

そしてEnterキーを押す。

macOSのアプリと同じように、コメントの表示/非表示ボタンをタップして、すべてのコメントを非表示にすることができます。

TextKit 2を使用してレイアウトし、描画し、テキストを操作するアプリを操作したところです。

それでは、サンプルアプリのコードの一部と、TextKit 2がそれを可能にする方法について説明します。

このアプリはTextKit 2が提供する多くの機能を示していますが、今のところ2つの分野に焦点を当てたいと思います。NSViewportLayoutControllerを使用してビューポート内のテキストをどのようにレイアウトするか、カスタム非表示動作とコメントのレンダリングをどのように実装するかです。

テキストレイアウトマネージャが変更されたため、コンテナサイズが変更されたため、またはドキュメントのこれまで見られなかった部分がビューポートに移動したためにドキュメントをレイアウトしようとしているとき、ビューポートレイアウトデリゲートでtextViewportLayout ControllerWillLayoutを呼び出します。

ここでは、すべてのテキストサブレイヤーをクリアし、アニメーショントランザクションを開くために使用しています。

テキストレイアウトマネージャがレイアウトするテキスト要素ごとに、textViewportLayoutController、configureRenderingSurfaceFor textLayoutFragmentを呼び出します。

ここでは、テキストレイアウトの断片を表示し、ジオメトリを更新し、可能であれば新しい位置にアニメーション化し、ビューのサブレイヤーとして追加するレイヤーを取得しています。

レイアウトマネージャのレイアウトが完了すると、textViewportLayout ControllerDidLayoutが呼び出されます。

アニメーショントランザクションをコミットし、選択のハイライトを更新し、スクロールの親指が正しく配置されるようにコンテンツサイズを更新します。

では、コメントについて話しましょう。

TextKit 2は、レイアウト要素とレイアウトフラグメントの生成をカスタマイズするために使用できるいくつかのフックを提供します。

ドキュメントのコメントを取り、表示用のフォントや色などのカスタム属性を設定し、その背後にあるバブルを描く方法を紹介します。

ドキュメントの各段落について、テキストコンテンツストレージは、そのデリゲートにその段落の属性をカスタマイズする機会を与えます。

実装では、基礎となるテキストストレージのフォントや色を変更することなく、コメントにカスタムフォントと色を設定しています。

テキストコンテンツマネージャーはまた、そのデリゲートにレイアウト中にテキストレイアウトマネージャーにどのテキスト要素を表示するかを決定する機会を与えます。

テキスト要素にfalseを返すと、表示されなくなります。

ここでは、基礎となるテキストストレージから実際に削除することなく、コメントを列挙しないことを選択することで、コメントを隠しています。

テキストレイアウトマネージャーにもデリゲートがあります。

textLayoutManager、textLayoutFragmentFor location in textElementを実装することにより、デリゲートは、特定のNSTextElementのデフォルトのNSTextLayoutFragmentインスタンスの代わりに、カスタムテキストレイアウトフラグメントを生成できます。

この場合、コメントを表すNSTextElementに遭遇すると、NSTextLayoutFragmentのカスタムサブクラスであるBubbleLayoutFragmentが作成されます。

BubbleLayoutFragmentは、NSTextLayoutFragmentの描画メソッドを上書きして、基本クラスの実装を呼び出してテキストを上に描画する前に、背景バブルを描画します。

テキストは、先ほど設定したカスタムフォントとテキストの色でレンダリングされていることに注意してください。

サンプルアプリがTextKit 2を使用してテキストのビューポートベースのアニメーションレイアウトを実行する方法と、テキストストレージのカスタム属性からカスタム描画まで、それらのカラフルなバブルにコメントを表示する方法を調べました。

しかし、テキスト選択を決定するためのマウスイベントの解釈、テキスト選択のハイライトのレンダリング、ドキュメント内の特定の段落へのコメントポップオーバーの配置、ドキュメントの高さの推定など、TextKit 2が提供する新しいAPIを利用するサンプルコードにはもっと多くのものがあります。

これらすべてのトピックのさらなる議論は、サンプルコードで見つけることができます。

ドナに戻って、TextKit 2用のアプリの準備について話しましょう。

ありがとう、クリス。

これは、TextKit 2が実際にどのように機能するかの素晴らしい例です。

TextKit 2で何ができるかを説明したので、アプリの近代化のためのいくつかのアプローチについて話し合いましょう。

これまでに話したことはすべて、一般的なビューまたはレイヤーで使用する独自のTextKit 2スタックの作成に適用されます。

すべての新しいクラスは、iOS 15のUIKitとmacOS 12のAppKitで利用できます。

だから、このルートに行きたいなら、今日からTextKit 2で新しいコードを書き始めることができます。

一方、多くのアプリは、テキストビューなどの組み込みのテキストコントロールを使用して、アクセシビリティサポートや選択および編集サービスなど、すべての優れた無料機能を利用できます。

これらのコントロールのいくつかは、TextKit 2を使用するようにすでに更新されています。

アプリが組み込みのコントロールを使用している場合は、注意すべき追加の詳細がいくつかあります。

互換性を維持することは、あなたと同じくらい私たちにとっても重要です。

TextKit 1は組み込みのテキストコントロールの不可欠な部分であるため、それらを使用しているアプリの互換性を維持するために多大な努力を払います。

これが、一部のコントロールだけがiOS 15とmacOS 12でTextKit 2を自動的に使用する理由です。

さらに、一部のコントロールでは、これらのOSバージョンでTextKit 2を使用するための追加の手順が必要です。

AppKit開発者にとって、NSTextViewはTextKit 2を自動的に使用しません。

NSTextViewでTextKit 2を使用する場合は、作成時にプログラムでオプトインする必要があります。

これがやり方です。

まず、テキストレイアウトマネージャーを作成します。

次に、テキストコンテナを作成します。

次に、NSTextLayoutManagerのtextContainerプロパティを使用して、テキストコンテナをテキストレイアウトマネージャーに関連付けます。

最後に、テキストコンテナで指定された初期化子を使用してNSTextViewを作成します。

これで、TextKit 2を使用するテキストビューが表示されます。

NSTextViewの新しいプロパティを使用して、テキストレイアウトマネージャーとテキストコンテンツストレージにアクセスできます。

注意すべきことが1つだけあります。

NSTextViewには、NSLayoutManagerを取得して設定できるlayoutManagerプロパティがあることを思い出してください。

NSLayoutManagerはTextKit 1オブジェクトであり、TextKit 2スタックと互換性がありません。

テキストビューは、レイアウトマネージャーとテキストレイアウトマネージャーの両方を同時に持つことはできません。

だから、これが取引です。

NSTextViewの特別な互換性モードを追加し、必要に応じてTextKit 1に切り替えました。

テキストビューは、このモードを使用する必要があるかどうかを自動的に検出し、NSTextLayoutManagerをNSLayoutManagerに置き換えることができます。

最適なパフォーマンスのために、テキストビューはその時点から互換性モードのままになります。

TextKit 2をオプトインした場合でも、テキストビューまたはテキストコンテナのlayoutManagerプロパティを明示的に呼び出すと、テキストビューは自動的にTextKit 1に切り替わります。

テキストビューは、まだサポートされていないテキストコンテンツに遭遇した場合、またはTextKit 1を必要とする他の条件を検出した場合にも切り替わります。

そして、これはフィールド編集者にも起こる可能性があります。

NSTextFieldのフィールドエディタは、デフォルトでTextKit 2を使用します。

しかし、テキストフィールドサブクラスがフィールドエディタのレイアウトマネージャーからレイアウト情報を要求している場合、フィールドエディタはそのウィンドウ内のすべてのテキストフィールドに対してTextKit 1に切り替わります。

システムは、テキストビューがTextKit 1に切り替わる前後に通知を発行します。

これらの通知を観察して、この情報を受け取ることができます。

通知オブジェクトには、モードを変更した正確なテキストビューへの参照が含まれています。

AppKitのTextKit 1互換モードの詳細については、Apple Developerポータルのドキュメントを参照してください。

UIKit開発者にとって、UITextFieldはiOS 15でTextKit 2を自動的に使用します。

TextKit 2を使用したUITextViewは、iOS 15では利用できません。

私たちは、UITextViewを使用するすべてのアプリケーションに最大限の互換性を確保するため取り組んでおり、それらはかなりたくさんあります。

それまでの間、UITextViewのlayoutManagerプロパティの使用について既存のコードを確認し、TextKit 2で意図を表現する方法を考えることができます。

そうすれば、利用可能になったら移行する準備が整います。

そして、それはラップです。

今、あなたは私たちを未来に連れて行くためのAppleの新しいテキストエンジンであるTextKit 2に会いました。

TextKit 2で何を構築するかを楽しみにしています。

見てくれてありがとう。

[明るい音楽]。