10098

♪ベース音楽の演奏♪

♪

David Stites: こんにちは、「Showcase app data in Spotlight」へようこそ。

私の名前はDavid Stitesで、Core Dataチームのエンジニアです。

このセッションでは、NSCoreDataCoreSpotlightDelegateを使用してアプリにSpotlightインデックスを追加する方法を紹介します。

このセッションの議題は、NSCoreDataCoreSpotlightDelegateオブジェクトとそれを使用する理由について学び、簡単な実装を設定し、その実装をカスタマイズする方法を学び、最後にフルテキスト検索を追加してコードを検証することです。

まず、コアデータとスポットライトを見てみましょう。

人々はあなたのアプリに多くの素晴らしい重要なコンテンツを作成して保存します。

アプリの使用とデータセットのサイズが大きくなるにつれて、標準の検索方法を使用してアプリ内と、Spotlight検索などのアプリの外部の両方で、そのデータをすばやく見つけたいと思うでしょう。

アプリ内のデータがSpotlightに表示されるのは素晴らしいことではないでしょうか？

さて、これはコアデータがあなたを助けることができる場所です。

NSCoreDataCore SpotlightDelegateオブジェクトは、すべての重い作業を行い、アプリによって提供されるコンテンツを迅速かつ効率的にインデックス化する一連のAPIを提供します。

電源を入れるだけでいい！

インデックスが作成されると、検索結果はアプリ外のSpotlight検索ユーザーインターフェイスにも表示されます。

Spotlightデリゲートは、グラフの管理対象オブジェクトへの変更を自動的に処理し、それに応じてSpotlightインデックスを更新します。

さらに、プライベートでデバイスのみのインデックスと対話するための堅牢なインデックス管理機能を提供し、好みに合わせてインデックス結果を調整できます。

実際、永続的なストアにあるコンテンツは、インデックスを作成する資格があります。

Spotlightデリゲートを使用する理由は3つあります。(1)Spotlightデリゲートは、Core Spotlight APIとの機能パリティを維持し、(2)多くの必要な実装コードを削除し、(3)このセッションの後半で議論する素晴らしい追加機能セットを提供します。

私の前のポイントを説明するために、これは検索インデックスにアイテムのみを追加し、それを...これに減らすコアスポットライトAPIを使用した非常に簡単な実装です!

2行！

シンプルで読みやすく、メンテナンスが簡単です。

つまり、さあ、誰がより少ないコードを好まないのですか？

すぐにセットアップして実行する方法を見てみましょう。 すぐに実行する

この簡単な例では、何を索引付けするかを決定し、デリゲートを作成します。

このセッションを通して、私は自分で書いたタグというアプリを参照します。これは簡単な写真タグ付けアプリケーションです。

このサンプルアプリには、私が今日議論している多くのAPIが組み込まれます。

スポットライトのサポートを追加する前に、「ナチュラルブリッジ州立公園」のスポットライト検索クエリ結果がないため、すべてのタグと写真データがタグ内に閉じ込められていることがわかります。

それを変えよう！

NSCoreDataCoreSpotlightDelegateを使用した実装の最初のステップは、Spotlightで何をインデックス化するかを決定することです。

スポットライトで何がインデックス化されるのは、完全にあなた次第です。

タグでは、エンティティ写真のuserSpecifiedName属性とエンティティタグの名前属性をインデックス化することにしました。

インデックス作成用のモデルを準備するために、Xcodeでプロジェクトのコアデータモデルを開き、インデックスを作成する各属性を選択し、属性インスペクタの「スポットライトのインデックス」チェックボックスにチェックを入れました。

Core Data Spotlightの表示名を設定する必要があるため、Core Dataモデルエディタで作業が継続されます。

コアデータスポットライトの表示名はNSExpressionです。

インデックス作成時に、この式はSpotlightによってインデックス化されたプロパティを持つ各管理オブジェクトで評価され、結果が保存されます。

その後、Spotlight検索ユーザーインターフェイスが表示されると、これらの保存された結果は検索結果の「表示名」として使用されます。

NSExpressionとは何ですか?

まあ、式はキーパス、この場合はTag.nameを評価するのと同じくらい簡単です。

しかし、このオブジェクトには、キーパスを評価する以外にもかなりの数のトリックがあります。

この例では、それはあなたのためにいくつかの数学をしています。

この式は、一連の数値の標準偏差を計算するなど、さらに複雑になる可能性があります。

タグでは、Spotlightの表示名は、エンティティPhotoのuserSpecifiedNameとエンティティタグの名前に設定されます。

モデルのインデックス作成の準備ができたので、Spotlightデリゲートを作成しましょう。

iOS 15とmacOS Monterey以降、StoreWith: model:の初期化子は非推奨になりました。

Spotlightデリゲートを初期化する新しい方法は、forStoreWith: coordinator:を使用しています。

新しい指定されたイニシャライザを採用することで、ストアをコーディネーターに追加する前に、スポットライトデリゲートのインスタンスをストアオプションに追加する必要がなくなりました。

ただし、Spotlightデリゲートが作業を開始するには、startSpotlightIndexingを呼び出す必要があります。

NSCoreDataCoreSpotlightDelegateを使用するためのいくつかの要件を呼び出したいと思います。

インデックスを作成するストアのストアタイプはSQLiteでなければならず、永続的な履歴追跡が有効になっている必要があります。

そして、それで、あなたは終わりです!

それでおそれ！

他に何もする必要はなく、データはSpotlightでインデックス化されます。

タグアプリにSpotlightインデックスを追加するのがいかに簡単かを実証しました。

基本を説明したので、その実装を少しカスタマイズしてみましょう。

実装をカスタマイズする最初の方法は、ドメイン名とインデックス名を定義することです。

まず、NSCoreDataCoreSpotlightDelegateのサブクラスであるタグSpotlightDelegateを定義します。

次に、実装でdomainNameとindexNameをオーバーライドします。

これらのセレクタをオーバーライドすると、インデックスされたデータを保存する場所をSpotlightに伝え、特に複数のインデックスがある場合は、後でよりよく識別できます。

domainIdentifierを上書きしない場合、デフォルトのドメイン識別子はストア識別子です。

indexNameをオーバーライドしない場合、デフォルトのインデックス名はnilです。

Spotlightデリゲートをカスタマイズする次のステップは、属性セットを定義することです。

このセッションのセットアップ部分では、NSCoreDataCore SpotlightDelegateオブジェクトは、Spotlightのチェックボックスインデックスにチェックを入れるだけで、Spotlightに返される属性セットを定義しました。

次に、インデックス作成に使用する属性を指定する方法を正確に実演します。

インデックスを作成する属性を指定すると、インデックスが作成されるものと検索方法をより明示的に制御できます。

これを行うには、CSSearchableItemAttributeSetを使用します。

属性セットには、いくつかの事前定義されたプロパティが含まれており、検索結果として表示されるときに、指定された管理対象オブジェクトについて表示するメタデータを指定できます。

選択する属性は、ドメインに完全に依存します。

CSSearchableItemAttributeSetで利用可能な定義済みのプロパティを使用するか、独自のプロパティを定義することができます。

タグアプリは、事前定義されたプロパティキーワード、displayName、およびthumbnailDataを使用します。

属性セット内のプロパティへの同時アクセスには未定義の動作があるため、一度に1つのスレッドで設定された属性のみを変更する必要があることに注意することが重要です。

TagsSpotlightDelegateクラスに戻って、attributeSet(オブジェクト:)をオーバーライドして、これがどのように機能するかを見てみましょう。

オーバーライドの実装では、オブジェクトがフォトタイプのオブジェクトであるかどうかを判断することから始めます。

次に、コンテンツタイプ.imageでattributeSetを初期化します。

次に、Photoオブジェクトの適切な属性を使用して、設定された属性にプロパティ識別子、displayName、およびthumbnailDataを設定します。

次に、Photoオブジェクトタグセットから属性セットのキーワード配列にタグを追加します。

この時点で、モデルが関係をインデックス化する場合、attributeSet（オブジェクトの場合：）をオーバーライドして、特にその関係の何がインデックス化されるかを定義する必要があることに言及する価値があります。

最後に、属性セットを返します。

モデルはタグオブジェクトもインデックス化しているため、コードはタグのケースを処理する必要があります。

そのために、contentType .text で設定された属性を作成し、表示名をタグの名前に設定してから、属性セットを返します。

最後のステップとして、前の手順でモデルエディタで設定したCore Data Spotlight表示名を削除します。

さらに進んで、インデックス作成を開始および停止するためのイベントループを定義しましょう。

以前、Spotlightデリゲートを設定すると、Spotlightデリゲートを作成した直後にstartSpotlightIndexingが呼び出されました。

NSCoreDataCoreSpotlightDelegateがいつインデックス作成作業を行っているかを正確に制御するために、stopSpotlightIndexingもフレームワークに追加されました。

これら2つのセレクタを協調して使用すると、アプリが強力なCPUまたはディスクアクティビティ操作を実行している場合に、必要に応じてインデックス作成作業を開始および停止することができます。

それでは、インデックスの更新が完了したときに通知を受けるためのサポートを追加しましょう。

Spotlightでインデックスされているエンティティまたはエンティティに変更が発生すると、そのインデックスは非同期に更新されます。

iOS 15とmacOS Montereyでは、Core Dataフレームワークにインデックス更新通知が追加されました。

インデックスの更新が完了したときに通知を受けるには、Spotlightデリゲートが投稿するNSCoreDataCoreSpotlightDelegate .indexDidUpdateNotificationを購読してください。

これらの通知は、NSManagedObjectContextで保存する呼び出しを処理した後、またはバッチ操作の完了後に掲載されます。

これを実際に見てみましょう。

まず、インデックス作成が有効になっているかどうかを確認します。

もしそうなら、indexDidUpdateNotificationに登録してください。

次に、ハンドラで通知を調べます。通知には、リモート変更通知に似た2つのキーと値のペアを含むuserInfo辞書があります。Spotlightデリゲートがインデックスを更新したストアのNSString UUIDと、Spotlightデリゲートがインデックスを更新したストアの永続的な履歴トークンです。

これらのキーの両方を使用して、興味のあるストアが最新の永続的な履歴トークンまでインデックス化されているかどうかを判断できます。

インデックス作成が有効になっていない場合は、通知からオブザーバーとして自分自身を削除できます。

今年以前は、アプリによってインデックスされたデータを削除する唯一の方法は、Core Spotlight APIを実装してインデックスエントリを削除するか、Core Dataのクライアントグラフ全体を削除することでした。

重要なことに、iOS 15とmacOS Montereyで新しく追加されたCore Dataは、開発者にクライアントグラフを削除せずにSpotlightインデックスを管理する新しい方法を提供し、ユーザーのプライバシーにとって大きな勝利です!

まず、コードはインデックス作成を停止します。

次に、deleteSpotlightIndexを呼び出します。

最後に、完了ハンドラで結果として生じるエラーを処理します。

このメソッドを呼び出すと、Core DataやCore Spotlightなどの下位層の依存関係からエラーが返される可能性があることに注意してください。

Spotlightデリゲートの実装をカスタマイズする方法をお見せしたので、Core Spotlight APIを使用してタグアプリに全文検索を追加して、設定を検証しましょう。

結果は、以前にインデックス化されたものになります。

まず、UISearchResultsUpdatingプロトコルと関数updateSearchResults（コントローラ用）を採用したPhotosViewControllerの拡張機能を定義することから始めます。

タグのユーザーインターフェイスにはUISearchControllerがあります。

その検索コントローラーの検索バーからユーザー入力を取得します。

ユーザー入力が空の場合は、データプロバイダーからすべての画像を取得し、検索クエリがないためコレクションビューをリロードします。

では、検索クエリがある場合に対処しましょう。

開始するには、ユーザー入力文字列をエスケープしてサニタイズします。

次に、ユーザーのサニタイズされた入力文字列を使用してクエリ文字列を定義します。

クエリ文字列は、CSSearchableItemAttributeSetオブジェクトのプロパティに関連付けられた値を操作します。

この場合、コードは前の手順で設定したキーワード属性で動作します。

検索クエリでは、修飾子c、d、およびwが使用されています。

Cは大文字と小文字を区別しません。

Dは発音記号の無神経です。

そして、wは単語ベースの検索用です。

次に、作成されたばかりのフォーマットされたクエリ文字列と、CSSearchableItemAttributeSetで定義されたプロパティに対応する属性名の配列を指定して、CSSearchQueryオブジェクトを作成します。

この検索クエリオブジェクトは、SpotlightデリゲートAPIを使用して以前にインデックスしたアプリコンテンツを検索するときに適用する基準を管理します。

その後、foundItemsHandlerを設定します。

このハンドラは、以前に定義された検索クエリに一致する項目で繰り返し呼び出されます。

一度呼び出されるクエリの完了ハンドラで、エラーをチェックし、エラー処理を実行する可能性があります。

エラーがない場合、メインキューにブロックをディスパッチして、データプロバイダーを使用してSpotlightが見つけたアイテムのフェッチを実行し、ユーザーインターフェイスにロードします。

最後に、そして最も重要なことは、クエリを開始することを忘れないでください。

タグアプリにはSpotlightデリゲートがコンテンツをインデックス化しているため、データはアプリ内から解放されました!

スポットライトに行き、以前追加したタグを検索すると、タグ名自体と「Natural Bridges State Park」というキーワードでタグ付けした特定の写真の2つの結果が返されます。

最後に、NSCoreDataCoreSpotlightDelegateと、ユーザーがSpotlight検索でアプリ内とアプリの外でコンテンツを見つけるのにどのように役立つかを学び、Spotlightデリゲートをすばやく簡単にセットアップして、巨大なコード負担なしでインデックス作成を開始し、このリリースで利用可能な新しいAPIを使用してSpotlightデリゲートをカスタマイズしました。

この情報が役に立ち、ユーザーがコンテンツを見つけるのを助けるために、プロジェクトにNSCoreDataCoreSpotlightDelegateを採用することを検討することを願っています。

素晴らしいWWDCを！

♪