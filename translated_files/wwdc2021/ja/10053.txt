10053

♪ベース音楽の演奏♪

♪

オーウェン・モンスマ:こんにちは、「素晴らしいMac Catalystアプリの資質」へようこそ。

私の名前はオーウェン・モンスマで、ココアのエンジニアです。

そして、後でUIKitの同僚Dave Rahardjaが参加します。

今日は、素晴らしいCatalystアプリを作るための3つの重要な考慮事項について説明します。

まず、Mac Catalystアプリに移行するときに発生するいくつかの高レベルの変更について説明します。

次に、Macでのアプリ体験を向上させるためにできる特定のコード変更について説明します。

そして、アプリの配布に関する情報で締めくくります。

それでは、アプリをMac Catalystに移行することから始めましょう。

優れたCatalystアプリへの第一歩は、優れたiPadアプリを持つことであり、あなたのアプリはすでにM1を搭載したMacで追加の変更なしで実行されています。

M1 Macをお持ちの場合は、XcodeのDesigned for iPad実行先ですぐにこれを試すことができます。

iPadでこれらの機能を採用することで、あなたのMacアプリは有利なスタートを切るでしょう。

アプリがiPadでマルチタスクをサポートしている場合は、Macで自動的に複数のウィンドウサポートを受けることができます。

また、UIMenuBuilderを使用している場合、メニューはアプリのメニューバーで自動的にピックアップされ、ビューをセカンダリクリックしたコンテキストメニューによって選択されます。

また、コピー/ペーストやドラッグアンドドロップなどのシステム動作を自動的にブリッジします。

iPadアプリがM1 Macでそのまま動作する方法の詳細については、ビデオ「M1を搭載したMacでの素晴らしいiPadとiPhoneアプリの品質」をご覧ください。

しかし、あなたは物事をさらに進めたいので、ここにいます。

Macのチェックボックスをオンにすると、すべてのMacに配布し、アプリをさらに絞り込むための追加のAPIにアクセスできます。

だから、私たちのアプリ、トリッププランナーでやりましょう!

Xcodeのプロジェクト設定では、Deployment Infoの下にあるMacオプションをチェックします。

右側には、追加のポップアップが表示され、スケーリングされたiPadインターフェイスとMacに最適化されたインターフェイスのどちらかを選択できます。

この選択をもう少し検討します。

とりあえず、ビルドをクリックして、Xcodeツールバーで実行しましょう。

そして、私たちのアプリはビルドされ、実行されます!

さて、アプリがビルドに失敗した場合、調査すべきことがいくつかあります。

特定の非推奨のフレームワークとクラスはMac Catalystでは利用できないので、今が近代化する時です。

これにより、Macでアプリが実行されるだけでなく、iOSアプリも改善されます。

OpenGLESからApple独自のMetalフレームワークへの移行は、GPUのフルパワーのロックを解除します。

連絡先フレームワークは、非推奨のアドレスブックを置き換え、連絡先を処理するための前向きでスレッドセーフな方法です。

そして、UIWebViewは廃止され、WKWebViewに取って代わられました。

また、サードパーティの依存関係を必ず確認してください。

これらのフレームワークがXCFrameworkバンドルとして配布されている場合は、リンクするMacバイナリを提供していることを確認してください。

Macアプリの作業を開始するときは、プロジェクトを構築するときにコンパイラの警告に注意し、ランタイムメッセージのコンソールログを監視します。

これらの警告は、Mac Catalystプロセスとしてうまく実行されるようにコードを修正する方法を教えてくれます。

また、将来のmacOSリリースでアプリが引き続き実行されるように、サポートされているAPIのみを使用することを忘れないでください。

また、Macで実行しているときにアプリが受け取るライフサイクルイベントを認識することも重要です。

アプリが現在、アプリデリゲートで呼び出されたライフサイクルイベントに依存している場合は、代わりにシーンのライフサイクルを監視し、アプリがデスクトップ上の各ウィンドウのコンテンツに固有のイベントに応答できるようにする必要があります。

Mac Catalystアプリは、iPadアプリほど頻繁にシーンDidEnterBackgroundイベントを受信しないことを忘れないでください。

デスクトップウィンドウが最小化または閉じられると、シーンはバックグラウンド状態になります。

アプリが sceneDidEnterBackgroundを使用してドキュメントの自動保存などの日常的な作業を実行する場合、代わりにタイマーを使用すると、このアクションが定期的に実行されます。

最後に、Catalystアプリのシーンはゼロかもしれませんが、フォアグラウンドで実行し続けることを覚えておいてください。

この状態は、すべてのアプリのウィンドウが閉じられたときに発生しますが、アプリの名前はメニューバーに表示されたままです。

では、Mac用のインターフェースを最適化するかどうかを決めましょう。

これは、最初にアプリを導入し始めたときに行う最も重要な決定の1つです。

Macのイディオムを使用することは、Macでアプリを最もくつろげるようにすることをお勧めしますが、追加の作業が必要です。

Macのイディオムでは、アプリは100%のスケールで実行され、ピクセルパーフェクトなテキストと画像、およびネイティブのAppKitコントロールを提供します。

必要に応じて、アセットカタログに新しいMac固有のアセットを追加して、この追加の詳細を活用できます。

すべてのモニター解像度をサポートするために、1xと2xの両方のアセットを提供するのは良い習慣です。

多くのコントロールのサイズメトリックが変更されるので、アプリのレイアウトを調整することが重要です。 対応してください。

アプリのカスタムコントロールには、追加の選択肢があります。

自動的に、Macスタイルのコントロールが手に入る。

しかし、この変換からボタンとスライダーをオプトアウトして、Macコントロールでは利用できないカスタマイズAPIを使用できます。

UISliderに親指を設定するなど、カスタムアセットを使用すると、デフォルトでは予想よりも大きく表示されるため、スケーリングしたり、新しいアセットを提供したりする必要があるかもしれません。

また、MacユーザーはAppKitスタイルのコントロールを期待しているため、カスタムコントロールは控えめに使用する必要があることを覚えておいてください。

Macのイディオムの詳細については、ビデオ「Mac Catalystアプリのインターフェースを最適化する」をご覧ください。

MacイディオムのCatalystアプリはAppKitのコントロールスタイルを取るため、一部のコントロールの外観と動作の両方が変わります。

私たちのビデオ「Mac Catalystの新機能」では、Macボタンタイプのスイートを締めくくる新しいポップアップボタンスタイルを紹介しました。

これらのコントロールの違いと、システムがどのコントロールを使用するかをどのように選択するかを掘り下げてみましょう。

これらのコントロールとそれらが一般的に見つかる場所を理解することは、アプリでの使用について情報に基づいた選択をするのに役立ちます。

デフォルトのUIButtonタイプはUIButtonタイプ.systemです。

このボタンタイプでは、ボタンは自動的にそのコンテキストの期待される外観を取ります。

Macの慣用句では、これは縁取りされたプッシュボタンになることを意味します。

プルダウンボタンは、可能なアクションのリストを提供するために使用されるMacネイティブコントロールであり、単一の矢印インジケーターで描画されます。

良い例は、印刷ダイアログのPDFプルダウンで、PDFとして保存やメールで送信などのアクションが表示されます。

プルダウンボタンを取得するには、メニュープロパティを使用してUIメニューをボタンに割り当てていることを確認し、さらにshowsMenuAsPrimaryActionをtrueに設定します。

ボタンはプルダウンの外観になり、クリックでメニューが表示されます。

そして、macOS Montereyを搭載したCatalystの新機能には、ポップアップボタンがあります。

ポップアップボタンはプルダウンボタンに似ていますが、ダブルアローインジケーターがあり、少し違うことをします。

プルダウンがアクションをトリガーする場合、ポップアップボタンを使用して、相互に排他的なオプションのセットの1つを選択します。

たとえば、曜日を選択します。

ボタンのタイトルは、選択を反映するように更新されます。

これは、アプリのUIPickerViewを置き換えるのに良い、Macに優しい選択です。

このコントロールの取得はプルダウンボタンに似ていますが、プロパティの変更SelectionAsPrimaryActionもtrueでなければなりません。

最後に、チェックボックスは非排他的なバイナリトグルを表すために使用され、スイッチのよりマウスに優しい代替手段です。

そして、結局のところ、あなたは追加の作業なしでチェックボックスを取得します!

スイッチにタイトルが設定されていることを確認し、タイトルプロパティはMacのイディオムでのみサポートされていることを覚えておいてください。

デフォルトでは、スイッチには自動の優先スタイルがあり、読み取り専用スタイルプロパティを使用して、スイッチかチェックボックスかを実行時に確認できます。

さて、いくつかの特定のコード変更に飛び込むために、私の同僚のデイブに物事を手渡しましょう。

Dave Rahardja: みなさん、こんにちは。私の名前はDaveで、UIKitチームのエンジニアです。

Mac Catalystアプリをよりくつろげるためにできる具体的なことについて話しましょう。

Mac Catalystアプリは、より多くの画面の不動産にアクセスできる可能性があります。

アプリのウィンドウは、iPadよりもMacではるかに大きくサイズ変更でき、フルスクリーンで表示できます。

少し時間を取って、アプリのウィンドウのサイズを変更し、そのレイアウトに注意を払ってください。

アプリをより使いやすくするために、より多くのコンテンツとコントロールを表示するために追加のスペースを使用していることを確認してください。

ライブサイズ変更は、アプリのレイアウトパフォーマンスをテストします。

アプリは、サイズ変更中にアプリのウィンドウをレスポンシブに保つために、レイアウト中に可能な限り最小限の作業を行う必要があります。

モーダルプレゼンテーションやポップオーバーに依存するアプリのインタラクションに特に注意してください。

表示領域が大きくなると、子ビューとして表示することで、これらのインタラクションを常に利用できるようにすることができます。

では、ポインタ入力デバイスについて話しましょう。

すべてのMacがトラックパッドを持っているわけではないし、一部のMacはスクロールをサポートしていない入力デバイスに接続されていることを覚えておいてください。

ビューがピンチまたは回転ジェスチャーに依存している場合は、スクロール入力なしでマウスを使用してすべての機能にアクセスできることを確認してください。

Mac Catalystアプリのビューに追加のボタンやその他のコントロールを追加して、すべての機能にアクセスできるようにします。

さらに、タップまたはパンジェスチャーリコグナイザでキーボード修飾子を検出すると、ビューの機能にすばやくアクセスできる場合があります。

たとえば、Shift-panをズームできるようにします。

キーボードショートカットとメインメニューについて話しましょう。

Macアプリのメインメニューは、アプリで利用可能なすべてのアクションと、関連するキーボードショートカットを見つけるのに最適な場所です。

アプリがレスポンダーからキーコマンドを返すことでキーボードショートカットをすでにサポートしている場合は、代わりにメニュービルダーAPIを使用してこれらのコマンドをメインメニューに追加してください。

すべてのキーボードショートカットをメインメニューに移動すると、現在有効になっていなくても検出可能になります。

さらに、MenuBuilder APIを使用してMac Catalystでショートカットを整理し、iPadのショートカットオーバーレイでも整理します。

メインメニューを作成する際に、アプリとの対話に必要なすべてのアクションを必ず追加してください。

iPadのジェスチャーで実行されるアクションは、メインメニューから項目を選択することでアクセスできるはずです。

メニュー項目にキーボードショートカットを追加すると、これらのアクションにさらにすばやくアクセスできます。

メニューバーとキーコマンドアクションはファーストレスポンダーからルーティングされるため、これらのアクションのターゲットとなるビューがファーストレスポンダーになり、フォーカスを受け入れることができることを確認してください。

canBecomeFirstResponder プロパティと canBecomeFocused プロパティに対してビューを true に戻すことで、これを行うことができます。

Macアプリは、ビューの直接操作に頼らず、ユーザーがビューを選択し、メインメニューからアクションを選択することに依存する必要があるため、より多くのアプリのビューがファーストレスポンダーになり、集中する能力は、Mac Catalystでより重要になります。

フォーカスとファーストレスポンダーの詳細については、ビデオ「iPadキーボードナビゲーションに焦点を当てる」をご覧ください。

レスポンダーをテーマにしている間は、アプリでレスポンダーチェーンを変更せずに残してください。

言い換えれば、nextResponderをオーバーライドしないでください。

レスポンダチェーンを変更しないままにしておくと、Mac Catalystがアクションを適切なターゲットにルーティングできるようになります。

アプリがレスポンダーチェーンにないオブジェクトを使用して特定のアクションを処理する場合は、target(for Action:, withSender:)関数を使用して、代わりにこれらのアクションを適切なオブジェクトに委任します。

コードを調べてみましょう。

この例では、ビューはsetAsFavoriteアクションをモデルオブジェクトに委任し、他のアクションがレスポンダチェーンを伝播し続けることを可能にします。

それでは、シーンとそれらがMac Catalystアプリでどのように機能するかについて話しましょう。

Macアプリでは、多くのデスクトップウィンドウが同時に開いている可能性があります。

Mac Catalystアプリでは、これらの各ウィンドウがUIWindowSceneとペアになっています。

あなたのアプリは、異なる機能を持つウィンドウを提供するかもしれません。

たとえば、ドキュメントウィンドウ、詳細ビューアウィンドウ、メッセージコンポーザーウィンドウなどがある場合があります。

これらの異なるシーン機能を整理する最善の方法は、ウィンドウの種類ごとにシーン設定を定義することです。

シーン設定を定義するには、アプリケーションシーンマニフェストエントリの下のInfo.plistに追加します。

アプリケーションセッションロール配列の下で、アプリがサポートするシーンの種類ごとに1つの設定を作成します。

これらの設定のそれぞれに名前を付け、シーンの作成時にインスタンス化されるシーンクラス、デリゲートクラス、ストーリーボードを選択します。

シーン構成を定義したので、それらを使用して特定の構成の新しいシーンを作成する方法について説明します。

この例では、ビューをダブルクリックしたときに新しい詳細ビューアシーンを作成したいと考えています。

最初に行うことは、詳細ビューアシーンを要求するための新しいユーザーアクティビティタイプを定義することです。

私たちはそれをviewDetailActivityTypeと呼びます。

その新しいユーザーアクティビティを作成するときは、詳細に表示したいアイテムの識別子を渡します。

これを行うには、その情報をユーザー情報辞書に保持するitemIDKeyを定義します。

次に、ダブルクリックイベントハンドラで、適切なタイプの新しいNSUserActivityオブジェクトを作成し、そのuserInfoプロパティを表示したいitemIDを保持する辞書に設定します。

最後に、UIApplication requestSceneSessionActivation関数を呼び、作成したばかりのユーザーアクティビティを渡します。

これにより、システムは新しいシーンを作成します。

これで、特定のユーザーアクティビティタイプの新しいシーンをリクエストする方法がわかります。

では、その情報を使用して適切なシーン設定をロードする方法について話しましょう。

アプリケーションデリゲートにアプリケーションconfigurationForConnecting機能を実装することで、シーン作成要求に対応します。

実装では、着信シーンリクエストにユーザーアクティビティが含まれているかどうかを調べます。

リクエストには複数のユーザーアクティビティを含めることができますが、このコード例では、最初のものを調べます。

処理する必要があるアクティビティがある場合は、そのactivityTypeをチェックします。

ここでは、viewDetailActivityTypeに等しいかどうかをテストします。

もしそうなら、DetailViewerという名前のシーン設定を返します。

これにより、システムはInfo.plistでその名前の設定を確認し、適切なシーンとシーンのデリゲートクラスをロードし、指定されたストーリーボードを新しいデスクトップウィンドウに表示します。

特定のシーン設定をロードする必要がある場合は、デフォルトの設定を返すことにフォールバックします。

やるべきことがもう1つあります。

表示するアイテムのアイテムIDを保存したことを覚えていますか？

作成したばかりのシーンのビューコントローラーにその値を設定する必要があります。

私たちはSceneDelegateクラスでそれを行います。

シーンwillConnectToセッション機能は、シーンがデスクトップに表示されようとしている直前に呼び出されます。

アプリケーションデリゲートに渡されたユーザーアクティビティは、シーンデリゲートのこの機能にも渡されます。

userInfo辞書からitemIDを抽出し、新しいビューコントローラーに設定できるようになりました。

NSUserActivityを使用して新しいシーンを設定すると、アプリが状態の復元を簡単にサポートできます。

シーンデリゲートがstateRestorationActivity（Scene：）コールバックに応答すると、返されたユーザーアクティビティは、アプリが終了したときにシステムによって保存されます。

システム環境設定で状態復元が有効になっている場合、次回アプリが起動されると、システムはシーンを再作成し、各シーンのユーザーアクティビティオブジェクトをアプリデリゲートのアプリケーションconfigurationForConnecting SceneSession機能に渡します。

これは、先に説明したように、アプリが新しいシーンを作成するときに呼び出されるのと同じ関数です。

一貫した一連のアクティビティタイプを使用することで、同じコードを使用して、アプリが新しいデスクトップウィンドウを作成し、状態の復元中に適切なシーン設定を選択できます。

アプリが同じコードで新しいシーンリクエストと状態復元の両方を処理できるように、シーンデリゲートに追加する必要があることが1つあります。それは、シーン接続オプションのアクティビティがnilの場合、シーンデリゲートのシーンwillConnectセッション機能を変更して、stateRestorationActivityにフォールバックするようにすることです。

これで、アプリは新しいシーンリクエストと状態復元を処理する準備が整いました。

状態の復元の詳細については、「iPadで複数のWindowsを紹介する」ビデオをご覧ください。

次に、アプリのツールバーについて話しましょう。

優れたMacアプリは、Windowsのツールバーを使用して、頻繁に使用されるアクションやその他のナビゲーションオプションを表示して、すばやくアクセスできます。

iOSのツールバーとは異なり、Mac Catalystアプリのデスクトップウィンドウのツールバーは、ビューコントローラーがSplit Viewコントローラーまたはナビゲーションコントローラーに表示されたり消えたりしても変更されません。

ツールバーはシーンと強く関連しているため、ツールバーを設定するのに最適な場所はシーンデリゲートサブクラスです。

通常、ツールバーにある重要な項目の1つは、共有ボタンです。

ツールバーにNSSharingServicePicker ToolbarItemを追加すると、アプリはMacの標準共有メニューを使用してシーンに表示されるメインコンテンツを共有できます。

macOS Montereyでは、シーンで共有されているアクティビティアイテムの設定を自動的に使用するボタンの機能を追加しました。

これは、Siriの新しいShare This機能がiOSで使用しているのと同じ設定であることに注意してください。

シーンの共有設定を提供する良い方法は、RootViewControllerのactivityItemsConfigurationプロパティからオブジェクトを返すことです。

Mac Catalystでは、アプリのツールバーにあるNSSharingServicePicker ToolbarItemが自動的にこのプロパティを使用します。

iOSでは、Siriは同じプロパティを使用して「Share This」を使用してデータを共有します。

もちろん、ツールバーは、アプリが共有するアイテムを提供できる唯一の場所ではありません。

多くの場合、コンテキストメニューから画像やその他のアイテムの共有を許可したいと思うでしょう。

これを行うには、ビューからactivitiesItemsConfigurationオブジェクトを返し、contextMenuInteractionを追加します。

これがMac CatalystとiPadの両方での結果です。

Mac Catalystでは、コピーアクションと共有メニューが自動的に追加されることに注意してください。

また、アプリがiPadで実行されると、コピーと共有アクションが追加されます。

共有アクションをタップすると、自動的に共有シートが表示されます。

アクティビティアイテム構成APIを使用すると、アプリはビューを共有できるものを宣言できるため、システムは各プラットフォームで適切なUIを表示できます。

アプリがデータを共有する方法について話しましたので、アプリがContinuity Cameraを使用してiPhoneやiPadから画像をインポートする方法について話しましょう。

アプリがUITextViewを使用してリッチテキストを表示する場合、macOS MontereyでContinuity Cameraのサポートが自動的に有効になります。

テキストビューを右クリックすると、iPhoneまたはiPadで写真を撮り、添付ファイルとして自動的に追加するオプションを備えたコンテキストメニューが表示されます。

任意のビューにContinuity Cameraのサポートを追加するには、ビューのpasteConfigurationプロパティから画像を受け入れるUIPasteConfigurationオブジェクトを返し、UI contextMenuInteractionを追加するだけです。

次に、貼り付け(itemProviders:) 関数を実装して、着信オブジェクトをロードして貼り付けます。この場合は画像です。

ボーナスとして、ビューから貼り付け設定を返すと、設定が画像を受け入れるときにContinuity Cameraが有効になるだけでなく、コンテキストメニューの貼り付けアクションを自動的に有効にし、Mac CatalystとiPadの両方でビューが着信ドラッグを受け入れることができます。

だから、これらはあなたのアプリを素晴らしいMac Catalystアプリにするためにあなたができるいくつかの具体的なことです。

さて、オーウェンに戻って配布について話しましょう。

オーウェン:ありがとう、デイブ。

アプリのリリースに関しては、覚えておくべき重要なことは、Mac CatalystアプリはMacアプリであり、他のMacアプリと同じ手段で配布できるということです。

既存のiOSの顧客が自動的にMacアプリを入手できるように、ユニバーサル購入のオプションを使用して、Mac App Storeにアプリを公開することができます。

アプリのベータリリースのためにTestFlightにアクセスし、新しいビルドに関する早期のフィードバックを得ることができます。

アプリ公証を使用して、自分で配布することもできます。

また、フレームワークを開発する場合は、XCFrameworksを使用してクロスプラットフォームを配布し、すべてのプラットフォームのバイナリをバンドルします。

今日は、Mac Catalystを使用してMac用のiOSアプリを構築するプロセスを取り上げ、その過程で行うべきいくつかの重要な決定と変更を強調しました。

今、あなた自身のプロジェクトを検討する時が来ました。

Macでアプリを実行するのは簡単で、ほんの少しの作業で、アプリを自宅にいるように感じさせ、まったく新しい興奮した顧客が利用できるようにすることができます。

ありがとう！

♪