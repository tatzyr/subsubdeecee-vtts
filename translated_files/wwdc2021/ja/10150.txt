10150

♪ベース音楽の演奏♪

♪

アリ・デ・ヨング：WWDC 2021へようこそ。

私の名前はアリ・デ・ヨングで、アップルのGPUソフトウェアエンジニアです。

そして今日、同僚のデビッド・ヌニェス・ルビオと一緒に、メタルレイトレーシングによるハイブリッドレンダリングを探ります。

まず、レイトレーシングがビジュアルにもたらすことができるいくつかの改善点をお見せします。次に、「ハイブリッドレンダリング」と呼ばれる技術を使用して、レイトレーシングパスをラスタライズに組み込む方法について説明します。その後、デビッドはレイトレーシングを実装するのに役立つ新しいツールを紹介します。

まず、レイトレーシングの素晴らしいユースケースを見てみましょう。

ゲームや映画は、増え続けるリアリズムを絶えず追求しており、長年にわたり、グラフィックスへのアプローチはラスタライズによって行ってきました。

ラスタライズは、リアルタイムのレートで美しい画像を生成するのに最適です。

しかし、私たちが達成できることには限界があります。

レイトレーシングは、シェーダーから世界を照会し、新しいエキサイティングな技術への扉を開くことを可能にするメカニズムです。

そして、それをラスタライズと組み合わせることで、ビジュアルを大幅に改善することができます。

いくつかの例を見てみましょう。 いくつか見てみましょう。

ラスタイズにとって常に問題となっている領域の1つは、反射です。

これは、ラスタライズされたピクセルをシェーディングするときに、正確な反射のためのシーンの残りの部分のコンテキストがなく、その情報を生成するために余分な作業を行う必要があるためです。

レイトレーシングを使用すると、シェーディングされているピクセルからアレイをトレースし、世界にあるものを発見することができます。

さらに良いことに、このプロセスを再帰的に適用して、反射に正しい影、さらには反射を適用することができます。

レイトレーシングが優れているもう1つの分野は影です。

ラスタライズ、シャドウの一般的なぼやけ、モペットの湾曲した表面のシャドウマップ解像度によって引き起こされるエイリアシングに注目してください。

レイトレーシングシャドウはよりシャープで、シャドウバイアスなどの人工的なパラメータを必要とせずにエイリアシングの問題に対処します。

柔らかい影は、より正確に近似することもできます。

陰影のある点への閉塞オブジェクトの近さに応じて、より硬いまたは柔らかい影を自然に生成できます。

ラスタライズでは、サンプリング時にシャドウマップをフィルタリングすることに頼る必要があります。

しかし、レイトレーシングでは、コーン内の光線をトレースするだけで、この結果を得ることができます。

最後に、レイトレーシングが私たちのビジュアルを高めることができるもう1つの領域は透明性です。

これは伝統的に、ラスタライズ技術のために正確に扱うのは非常に困難です。

この画像では、日光が窓からどのように入ってくるかに注目しますが、ガラスの不透明な文字は影を出しません。

従来のシャドウマッピング技術は、多くの場合、透明なオブジェクトに問題があります。

レイトレーシングを使用すると、透明な材料のカスタム交差機能を作成できます。

これにより、どの光線が材料を通過でき、どの光線が通過できないかを定義でき、バストの頭の文字のように自然に投影された影を生成することができます。

そしてもちろん、すべての影は全体的にシャープに見えます。

では、なぜレイトレーシングが私たちのビジュアルを劇的に改善できるのでしょうか?

これを理解するために、従来のラスタライズプロセスがどのように機能するかを見てみましょう。

ラスタライズプロセスでは、メッシュはレンダリングされる金属に送られます。

それらは頂点シェーダーによって世界とカメラの前に配置され、それらのプリミティブはラスタライザによってピクセル（またはフラグメント）に配置されます。

これらのピクセルはフラグメントシェーダーによってシェーディングされ、結果は出力画像にブレンドされます。

ご存知のように、各ピクセルは独立してシェーディングすることができ、並行して動作します。これは、GPUがラスタライズプロセスで非常に優れている理由です。

しかし、トレードオフは、シェーディングを適用している時点で、シーンの残りの部分のコンテキストを完全に失っており、このピクセルに関連するポイントを取り囲む可能性のあるオブジェクトがわかりません。

高度なゲームエンジンは、中間情報を生成する追加のレンダリングパスを追加することで、この状況を埋め合わせます。

フラグメントシェーダーは、そのデータを活用して、ポイントがある幾何学的コンテキストの詳細を近似することができます。

これがどのように機能するかをもう少し詳しく見てみましょう。

このテクニックでは、シーンに関する幾何学的情報を画面に直接ではなく、中間テクスチャにラスタライズします。

これは、アルベド、深さ、またはノーマルのようなものです。

これは一般に、ジオメトリバッファパスまたは略してGバッファパスと呼ばれます。

中間テクスチャは、光がシーン内のオブジェクトとどのように相互作用するかを近似するためにスマートなトリックを使用する光近似パスの入力として使用されます。

いくつかの例は、スクリーン空間アンビエントオクルージョンとスクリーン空間反射です。

最後のステップでは、私たちの中間アタッチメントは、より滑らかな画像を作るためにノイズ除去またはわずかにぼやけ、すべてが一緒に結合されて最終的な画像を生成します。

これらの時には精巧なテクニックは画像を改善するのに役立ちますが、それでも単なる近似値です。

一方、レイトレーシングは、より正確なビジュアルと簡略化されたビジュアル技術を可能にするまったく異なるアプローチを採用しています。

レイトレーシングでは、メッシュを一度に1つずつ処理する代わりに、シーン全体を網羅する加速構造を構築します。

それを手に入れたら、GPUは特定の方向に向かって点から光線をトレースし、交差点を見つけることができます。

これにより、すべてのコンテキストシーン情報にアクセスできます。

レイトレーシングはレイインタラクションをモデル化するため、レンダリングを超えたアプリケーションもあります。

オーディオおよび物理シミュレーション、衝突検出、またはAIおよびパスファインディングに使用できます。

レイトレーシングは非常に強力な技術であるため、レイトレーシングとラスタライズを組み合わせて、それぞれのユニークな利点を得たいと考えています。これは、「ハイブリッドレンダリング」と呼ばれる技術を通じて行うことができます。

では、ハイブリッドレンダリングフレームの作成方法と、このテクニックのユースケースを見てみましょう。

ラスタライズされたフレーム図から始めると、レイトレーシングを使用して、光近似パスの一部または全部を置き換えることができます。

私たちはまだGバッファをラスタライズします - それは私たちの主要な光線の役割を果たします - そして、レイトレーシングを使用して、シーンの残りの部分にクエリすることによって、より現実的に光の特性をシミュレートします。

私たちはまだノイズを消し、光の構成パスを行いますが、私たちの結果はシーンデータに対してはるかに正確です。

このフレームアーキテクチャは、多くのハイブリッドレンダリング技術を探求するための良い基盤を提供します。

Metalを使用してこのようなフレームをエンコードする方法を見てみましょう。

Gバッファの記入から始めます。

そのために、レンダリングパスを作成し、Gバッファに記入し、そのテクスチャをパスの添付ファイルとして設定します。

レンダリングされたコンテンツが後続のパスで使用できるように、画像がメモリに保存されていることを確認します。

パスを開始し、レンダリングをエンコードし、レンダリングパスを終了します。

次に、これにレイトレーシングコンピューティングディスパッチを追加します。

中間テクスチャを作成したら、レイトレーシングパスをエンコードしましょう。

同じコマンドバッファからコンピューティングパスを作成し、Gバッファテクスチャを入力として設定するようにします。

デフォルトでは、Metalは書き込みと読み取りの依存関係を追跡するので、同期を気にしすぎることなく、自由にアルゴリズムに集中できます。

これは計算なので、レイトレーシング作業の結果を書き込むために出力テクスチャを設定します。

レイトレーシング技術のためにPipelineStateオブジェクトを設定しました。

計算シェーダーの各スレッドは、ピクセルまたは領域のレイトレーシング結果を計算します。

最後に、2Dグリッドを派遣し、このパスを終了します。

このパスがエンコードされた後、光蓄積パスなどのより多くの作業をエンコードし続けるか、コマンドバッファを送信して、フレームの残りの部分をエンコードしながらGPUが作業を開始することができます。

作業を2つのパスでエンコードしたため、パスが相互に通信するために、中間レンダリングアタッチメントをシステムメモリに保存する必要があります。

これは機能しますが、Apple SiliconとiOSデバイスでは、これをさらに良くする機会があります。

Apple GPUでは、ハードウェアはタイルメモリを利用して、作業中にピクセルデータを保持します。

パスの最後に、このタイルメモリはシステムメモリに肉付けされ、次のパスの開始時にリロードする必要があります。

しかし、理想的には、システムメモリへの往復を避けて、計算パスをタイルメモリで直接動作させるでしょう。

今年は、レンダリングパイプラインからレイトレーシング作業をディスパッチすることで、その機能を追加しました。

これにより、シングルパスでタイルシェーダーを介してレンダリングと計算を混合して、レイトレーシングにオンタイルメモリを活用することができます。

これにより、帯域幅の使用、メモリ消費が削減され、ユーザーのデバイスが涼しく動作するのに役立ちます。

2019年の「Modern rendering with Metal」セッションを必ず確認して、レンダリングと計算を効率的にミックスする方法を学んでください。これにより、レンダリングからレイトレーシングに適用できます。今年の「メタルレイトレーシングでアプリを強化する」セッションでは、今年のメタルレイトレーシングの他の改善点について学んでください。

ハイブリッドレンダリングワークロードをエンコードする方法がわかったので、レイトレーシングで改善できるテクニックをいくつか確認しましょう。

影、周囲の閉塞、反射に焦点を当てます。

影から始めましょう。

影は、シーン内のオブジェクトの近接性を伝えるのに役立ちます。

しかし、シェーディング時にシーンのコンテキストを失うため、これはラスタライズの課題です。

シャドウマッピングは、この情報不足を補うのに役立ちますが、各光の観点から追加のレンダリングが必要です。

このラスタライズ技術は、すべての光の視点からシーンをレンダリングすることから始まります。

これにより、各光の変換行列と一緒に保存する必要がある一連の深度マップが生成されます。

次に、メインカメラの視点からレンダリングします。

各ピクセルをシェーディングするには、点を光の座標に変換する必要があります。

深度マップから来る深さをサンプリングし、最終的にこれらの深さ値を比較して、各光源の光と影のどちらにあるかを判断します。

このテクニックにはいくつかの欠点があります。

まず、各光の光の視点からシーンをレンダリングする必要があります。

これは、シーンを複数回処理することを意味します。

第二に、シャドウマップには所定の解像度があります。つまり、影はエイリアシングの対象となります。さらに悪いことに、画像に収まらないピクセルの情報はありません。

これをレイトレースされた影と比較してみましょう。

レイトレーシングで影を計算するには、光源の方向に向かって点から光線をトレースし、物体がその経路を塞いでいるかどうかを判断することができます。

何も見つからない場合、それはポイントがシェーディングのためにこの光源を考慮する必要があることを意味します。

オブジェクトが経路をブロックしている場合は、照明方程式でその光源の寄与を除外するだけです。

これが、閉塞するオブジェクトのシルエットに対応する自然な影を生成する方法に注目してください。

さらに良いことに、私たちはもはや深度マップに保存されている情報に限定されません。

光のフラスタムやカメラの視界の外側のポイントの影を決定できます。

レイトレーシングでシャドウテクニックがどのように簡素化されるかを見てみましょう。

メインカメラからレンダリングすることから始めます。

次に、カメラの位置からレンダリングされた加速度構造と深度マップを取り、それをレイトレーシングカーネルに供給します。

ピクセル位置を計算し、光の方向に光線をトレースするだけです。ここから、閉塞する物体との交点が見つかったかどうかに応じて、点が照らされているか影にあるかを判断します。

このプロセスでは、シャドウテクスチャが生成され、レンダリングパスの結果と組み合わせて最終的な画像を取得できます。

これを行うためにメタルシェーダーをコーディングする方法を見てみましょう。

シェーダーコードでは、各スレッドが深さとthread_idから処理する位置を計算することから始めます。

計算された位置からシャドウレイを作成し、光の方向にトレースするように設定します。

ポイントライト、スポットライト、エリアライトなどのほとんどのライトタイプでは、ポイントから光源まで追跡するために最小値と最大値を設定します。

指向性シャドウの場合、最大値を無限大に設定したい場合があります。

さらに、より柔らかいシャドウのためにコーンレイトレーシングを実装することにした場合、これはShadowRayにジッターを追加するのに最適な場所です。

次に、インターセクターオブジェクトを作成します。

1つの交差点が見つかった場合、それは私たちが影にいることを意味するので、任意の交差点を受け入れるようにインターセクターを設定します。

最後に、加速構造と交差します。

その交差結果に基づいて、ポイントが点灯しているかどうかを書き込み、シーンに対してより正確な影のテクスチャを作成します。

そのシャドウテクスチャが適用されると、はるかにリアルなシャドウを取得し、エイリアスを取り除くことがわかります。

レイトレーシングでは、影を決定することは非常に自然な技術になります。

光線をトレースして、何かがその点の光源を遮っているかどうかを調べるだけです。

中間深度マップを持つ必要がなくなり、ライトごとに複数の余分なレンダリングパスを持つことを避けることができます。

このテクニックは、深さにのみ依存するため、遅延レンダラーまたはフォワードレンダラーに簡単に実装できます。

そして最後に、半透明材料のカスタム交差機能を可能にします。

次に、アンビエントオクルージョンを見てみましょう。

概念的には、ジオメトリに囲まれた点は、大量の周囲光を受け取る可能性が低い。

アンビエントオクルージョンは、その近所がどれほど忙しいかに基づいて、ある時点で受信した周囲の光をミュートすることで構成されており、自然に裂け目を暗くし、最終的な画像に深みを与えます。

これを達成するためのラスタライゼーション技術は、ポイントの近くの深さと法線をサンプリングし、それを囲み、潜在的に閉塞するオブジェクトがあるかどうかを判断します。

近くの物体の数に基づいて、減衰係数を計算して周囲の光をミュートし、画像に適用するテクスチャを作成します。

ただし、深度バッファやサーフェス法線などの画面空間情報に頼ると、目に見えないオクルーダーや画像の境界外のオブジェクトの情報が欠落しています。

レイトレーシングでは、画面空間情報に頼るのではなく、シーンの実際の幾何学的データに頼ることができます。

アイデアは、すべてのピクセルをシェーディングし、半球でランダムな光線を生成し、オブジェクトに対する交差点を検索することです。

交差点が見つかった場合は、周囲の閉塞要因を考慮します。

加速構造からやり直します。

この手法では、通常のデータと深さが必要なため、Gバッファパスでデータを収集します。

深さと法線は、半球でランダムな光線を生成するために使用されます。

次に、光線を追跡し、減衰係数を計算します。

これにより、裂け目が自然に暗くなる画像が生成され、効果が生まれます。

アンビエントオクルージョン用のメタルシェーダーを見てみましょう。

まず、ランダムな光線を生成します。

この場合、各スレッドの法線に沿ってcosineWeightedRayを取ります。

小さな近所にしか興味がないため、max_distanceを小さな数に設定しました。

次に、インターセクターを作成し、加速構造を交差させます。

結果に応じて、減衰係数に蓄積します。

これは横並びの比較です。

そして、レイトレーシングされたアプローチがどれほど良く見えるかをすぐに見ることができます。

スクリーンスペース効果の限界を本当に示すいくつかの場所を強調したいと思います。

これは、画面空間の情報が限られているため、近所が誤って表示される例です。

これは、実際のジオメトリがカメラにほぼ垂直であるため、この角度の深度バッファではないためです。

同じ問題が画像全体、特にモペットの下で発生します。

この角度から見ると、モペットの底が深度バッファーから欠けています。

したがって、スクリーンスペースのテクニックは減衰を完全に見逃します。

一方、レイトレーシングバージョンは、フロアピクセルのモペットの底に対する交差点を正しく検出します。

そして、これは画面の境界線に関する制限の素晴らしい例です。

閉塞ジオメトリはオフスクリーンであるため、その貢献はスクリーンスペース技術で失われますが、レイトレーシングで説明されます。

ご覧のとおり、ハイブリッドレンダリングは、シーンの実際のジオメトリを使用して大幅な品質改善を提供し、画面空間情報の制限から技術を解放します。

そして最後に、反省を見てみましょう。 

反射は伝統的にラスタライズにとって非常に困難でした。

反射プローブは、うまく機能するが、解像度が限られており、フィルタリングを必要とし、動的ジオメトリに苦労する技術です。

スクリーン空間反射技術は、スクリーン空間情報によって制限されます。

反射プローブは、周囲の色情報をキャプチャするために、シーン全体に沿ってカメラを戦略的に配置する必要があるソリューションです。

反射プローブを使用するには、キューブマップがシーン内のさまざまな場所からキャプチャされます。

これは本質的に、同じ点から6方向のシーンのレンダリングです。

ピクセルがシェーディングされると、プローブとの関係を計算し、キューブマップをサンプリングして反射されたシェーディングを生成します。

現実的な結果を得るには、通常、多くのプローブがシーン全体に散在する必要があります。

また、動的なオブジェクトがシーンを移動すると、シェーダーは複数のキューブマップからサンプリングし、反射色を手動で補間する必要があります。

キューブマップはまた、放射照度を正確に表すために事前にフィルタリングする必要があり、解像度が制限されています。

別のラスタライズ技術である画面空間反射は、すでにフレームバッファにあるピクセルの反射に基づいて、これらの問題のいくつかを回避します。

フラグメントシェーダーは、法線を使用して徐々に外側に行進し、潜在的な近くのオブジェクトの深度マップをチェックします。

何かを見つけたら、フレームバッファから直接色をサンプリングし、出力画像にシェーディングします。

しかし、先ほど説明した画面空間の制限に苦しんでいます。

このモペットの例では、フレームバッファに存在する床タイルに対応して、表面の一部のみが正確な反射を得ることができることに注意してください。

シーンの残りの部分が欠けています。

さらに悪いことに、黄色でマークされたフェンダーの後ろの下部には情報が欠けています。カメラから離れた表面がどのように見えるかを知る方法はありません。

レイマーチングも計算的に高価になる可能性があります。

しかし、レイトレーシング反射は、加速構造の真のシーン情報に頼ることができるため、両方の問題を克服するのに役立ちます。

完璧な鏡がどのように機能するかを見てみましょう。

まず、カメラの位置からポイントまでインシデント光線を取ります。

次に、この点をその点に関連する通常の点に反映します。

これにより、光線をたどり、反射した物体を見つけることができる方向が得られます。

このため、反射レイトレーシングカーネルにGバッファの法線と深さを提供します。

このレイトレーシングカーネルは、カメラから各ポイントまでのビューベクトルを計算し、このベクトルを反射し、ポイントからその方向に光線をトレースします。

最後に、正確な反射のために、レイトレーシングカーネルで直接見つかった交点をシェーディングすることができます。

このシェーダーのコーディングを見てみましょう。

もう一度、ポイントの深さから始めて、その位置を再構築します。

今回は、その地位が世界空間にあることを望んでいます。

したがって、computePosition関数では、ビュー行列の逆数を乗算する必要があります。

次に、法線上で反射された入射ベクトルを計算し、その方向に光線を作成します。

次に、インターセクターを作成し、反射光線を追跡します。

物体に当たった場合、その点をシェーディングして反射を生成します。

交差点がすべてのオブジェクトを見逃した場合は、スカイボックスをサンプリングし、その色を返して、空を示す反射をシミュレートすることができます。

シェーディングは、この手法の計算カーネルで直接実行されることに注意してください。

反射プローブと光線追跡反射を比較してみましょう。

右側の画像はハイブリッドレンダリングを使用しており、床タイルの詳細をより明確に見ることができます。

建物は存在し、モペットのフロントパネルに影が映っているのを見ることさえできます。

反射はレイトレーシングに自然に適合します。

鏡のような反射や大まかな反射をうまく処理します。

これらは、コーンに沿って複数の光線をトレースし、結果をフィルタリングすることによって達成できます。

彼らは加速構造から来る完璧な情報に依存しているため、レイトレーシング反射はスクリーン空間アーティファクトから解放され、シーンの静的幾何学と動的幾何学の両方を処理できます。

さて、1つの重要な詳細：反射のために、計算カーネルで直接ポイントをシェーディングする必要があると述べました。

この1つやグローバルイルミネーションのようないくつかのテクニックでは、コンピューティングカーネルから直接頂点データと金属リソースにアクセスする必要があります。

このような場合、GPUがシェーディング方程式を適用するために必要なデータにアクセスできることを確認する必要があります。

これは、Metalで引数バッファとして表されるバインドレスバインディングモデルで達成されます。

詳細については、今年の「メタルのブロンドレスレンダリング」トークを必ずチェックしてください。

私たちは、いくつかの異なる技術でハイブリッドレンダリングを実践する方法を見ました。

これは、より正確な結果を生み出すという利点を持つ、より自然なアルゴリズムにつながります。

場合によっては、従来のラスタライズ技術と比較すると、レンダリングパスを削除し、場合によってはメモリと帯域幅を節約できることがわかります。

レンダリングからレイトレーシングを追加することで、作業全体をチップに維持することもできます。

レイトレーシングの採用は大きな課題であり、これらの技術をエンジンに持ち込むプロセスを支援する優れた新しいツールがあります。

今年は、レイトレーシング作業をキャプチャし、加速構造を検査し、可視機能と交差機能を検査できるツールを紹介します。

今、デビッドは私たちにこれらの新しいツールのツアーを提供します。

デビッド・ヌニェス・ルビオ:ありがとう、アリ。私の名前はデビッド・ヌニェス・ルビオで、GPUソフトウェアエンジニアです。

昨年、メタルにレイトレーシングサポートを導入しました。

しかし、複雑なアプリケーションの開発は難しい場合があります。

幸いなことに、メタルデバッガーはあなたを助けるためにここにいます。

今年は、メタルデバッガーでレイトレーシングサポートを導入しました。

ハイブリッドレンダリングの採用のおかげで、私たちのデモはこれまで以上に良くなっています。

光線でトレースされた柔らかい影、反射、周囲の閉塞。結果は素晴らしいです。

デモの開発中に、私たちはいくつかの問題にぶつかった。

これは、ツールがこれらの問題を解決するのに役立つ方法です。

この初期のバージョンのデモでは、レイトレーシングシャドウがすでに実装されています。

しかし、よく見ると、地面の木の葉から欠けている影に気づくでしょう。

参照バージョンと比較すると、より明白です。

参照とレイトレースを参照してください。

Xcodeに飛び込んでキャプチャして、ツールがこの問題のデバッグにどのように役立つかを見てみましょう。

メタルボタンを押して、キャプチャーをクリックする必要があります。

これは静的な問題なので、必要なフレームは1つだけです。

デバッガでは、API呼び出しはデバッグナビゲーターの左側に編成されます。

オフスクリーンコマンドバッファを展開して、シャドウエンコーディングを探しましょう。

コンピューティングコマンドエンコーダを「Raytrace Shadows」とラベル付けしました。

メタルデバッガーで簡単に見つけられるように、メタルオブジェクトにラベルを付けるのは良い習慣です。

サムネイルはまた、確かに、これが私たちが探しているエンコーダであるというヒントを与えてくれます。

ディスパッチThreadgroups API呼び出しをクリックして、バンドリソースを表示できるようになりました。

これは、現在のカーネルディスパッチに関連付けられているすべてのオブジェクトのリストです。

そして、ここでは、私たちが便利にラベル付けした構造の加速を見ることができます。

私たちのカーネルは、光線をキャストするために加速構造を使用しています。

これは通常、光線が交差する3D世界を表すツリーのようなデータ構造である境界ボリューム階層またはBVHとして実装されています。

次に、ダブルクリックして加速度構造ビューアを開きます。

これは、メタルデバッガーに組み込まれた素晴らしい新しいツールです。

それがどのように整理されているかの概要を説明しましょう。

右側には、カスタムジオメトリや交差関数を含む3Dシーンのレイトレースビジュアライゼーションがある3Dビューがあります。

これは、髪などのカスタムジオメトリやアルファテストを使用する場合に最適です。

使い慣れたコントロールを使って、カメラを動かしたり、周りを見回したりできます。

そして、ここにヒントがあります：スクロールしながらOptionキーを押してズームインおよびズームアウトします。

私たちは、私たちのシーンをよりよく理解するために、いくつかの素晴らしい視覚化ツールを構築しました。

強調表示されたメニューをクリックして、利用可能なさまざまなモードを見てみましょう。

たとえば、バウンディングボリュームトラバーサルを視覚化できます。

これは、サーフェスに当たる前に1つの光線が通過する必要があるノードの数を示すヒートマップです。

暗い色は、より多くのノードを横断し、交差テストを遅くする必要があることを意味します。

また、加速度構造に基づいてシーンを色分けすることもできます...

ジオメトリ...

インスタンス...

または交差関数。

ツールにもう少し慣れたので、元の問題に戻ることができます。

3Dビューのおかげで、ジオメトリがそこにあることを確認しました。

だから、何か他のものがあるに違いない。

左側にはナビゲーターエリアがあります。

ここでは、トップレベルとボトムレベルの加速構造を見ることができます。

任意の加速度構造を展開して、それが構築されたジオメトリのリストを見ることができます。

不透明度やプリミティブカウントなどの特性を見るために再び展開することができます。

また、この加速構造のインスタンスのリストも見ることができます。

木の葉をクリックして、ナビゲーターでインスタンスを表示し、そのプロパティを調べましょう。

マトリックスは正しく見え、フラグは設定されていませんが、マスクに何かが欠けているようです。

このデモでは、交差点マスクを使用しています。

マスクの最も低いビットを使用して、影を落とすオブジェクトにフラグを立てます。

その後、インターセクターは、ビット単位と操作を使用してこのマスクをテストし、失敗した場合は交差を拒否します。

この動作を3Dビューで直接視覚化できます。

インターセクターヒントメニューを開く必要があります。

ここでは、視覚化のためのレイトラバーサルオプションを設定できます。

カリング操作を変更したり、カスタム交差点を無効にしたり、インターセクターのマスクを変更したりできます。

デフォルトでは、すべてが交差します。

シャドウに使っている値に変更しましょう。

これにより、シャドウマスクを使用する際のシーンの正確な視覚化が表示されます。

そして実際、私たちは木の葉が欠けていることを確認しました。

問題を特定したら、ソースに戻り、適切なマスク値を設定していることを確認する必要があります。

これは影が以前どのように見えたかです。

そして、これは彼らがマスクの価値を修正した後にどのように見えるかです。

これは、レイトレーシングアプリケーションのデバッグに役立つワークフローの例です。

ツールについてもっと知りたい場合は、今年の「金属デバッグ、プロファイリング、資産作成ツールの発見」WWDCセッションをチェックしてください。

このセッションでは、レイトレーシングがあなたのビジュアルをどのように高めることができるかを見直しました。

ハイブリッドレンダリングは、ラスタライズとレイトレーシングの組み合わせです。

これにより、光近似技術を、たまたまより単純なより正確なものに置き換えることができます。

また、エンジンにレイトレーシングを採用するプロセスを支援する新しいツールも見ました。

ラスタライズとレイトレーシングを組み合わせることで、どのような新しい可能性が利用できるかについて表面を引っ掻いただけです。

将来の新しい革新的なグラフィック技術を開発するために、これらの技術をどのように実践するかを見るのが待ちきれません。

ありがとう、WWDCの残りの部分を楽しんでください。

♪