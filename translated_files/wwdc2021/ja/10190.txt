10190

こんにちは。私の名前はベク・サン・チャンで、コアオーディオに取り組んでいます。

今日は、DriverKitでオーディオドライバを作成する新しい方法について説明します。

しかし、まず、今日のオーディオドライバの仕組みを確認しましょう。

macOS Big Sur以前は、オーディオサーバープラグインは、ユーザークライアントを介してカーネル拡張機能にハードウェアデバイスと通信する必要が高かった。

macOS Big Surでは、CoreAudio HALは、DriverKit拡張機能の上に構築されたオーディオサーバープラグインを作成するためのサポートを提供しました。

プラグインとdextの間のレイヤーはkextと同じでしたが、カーネルからユーザースペースに移動することでセキュリティが改善されました。

DriverKitの詳細については、以前のWWDC DriverKitのビデオをご覧ください。

現在のソリューションでは、オーディオドライバの開発はカーネルから移行できますが、機能的なハードウェアオーディオドライバを実装するには、オーディオサーバープラグインとドライバ拡張機能の2つの別々のコンポーネントが必要です。

これにより、開発が複雑になり、リソースが増加し、オーバーヘッドとレイテンシが増加する可能性があります。

macOS Monterey以降では、dextだけが必要で、プラグインはもう必要ありません。

AudioDriverKitは、USBDriverKitまたはPCIDriverKitと一緒にオーディオドライバ拡張機能を書くために使用される新しいDriverKitフレームワークです。

この新しいフレームワークは、CoreAudio HALへのすべてのプロセス間通信を処理します。

あなたはdextしか持っていないので、dextとオーディオサーバープラグインの間で通信する必要はありません。

DriverKit内で集中し続けることができます。

AudioDriverKit拡張機能はMacアプリ内にバンドルされているため、別のインストーラーは不要になりました。

そして今、あなたのドライバーはすぐに読み込まれ、再起動は必要ありません。

AudioDriverKitの利点がわかったので、新しいオーディオドライバの作成に飛び込みましょう。

オーディオドライバーに関連するコンポーネントの簡単な概要から始めて、デックスを書く前に必要なものをいくつか紹介します。

コードの作成を開始する準備ができたら、dextの設定と初期化、デバイス、ストリーム、その他のオーディオオブジェクトの作成、IOパスとタイムスタンプの処理方法を説明します。

最後に、構成変更の処理方法について話し合い、最後にdextのデモをお見せします。

では、建築から始めましょう。

この図は、HALがAudioDriverKitフレームワークを使用してドライバー拡張機能と通信する方法を示しています。

AudioDriverKitフレームワークは、CoreAudioとオーディオデクスト間のすべての通信に使用されるプライベートユーザークライアントを作成します。

このユーザークライアントは、直接使用することを意図しておらず、dextにさらされていません。

アプリとdextの間で通信するために必要なプラグインやカスタムユーザークライアントがないことに注意してください。

オプションで、必要に応じて、アプリはカスタムユーザークライアントを開き、デクストと直接通信することができます。

それでは、あなたが必要とする資格について話しましょう。

すべてのDriverKitドライバ拡張機能には、DriverKitの資格が必要です。

AudioDriverKit dextsには、ユーザークライアントのアクセスを許可する権限も必要です。

これは、DriverKitの資格が承認されたすべての開発者が利用できます。

さらに、輸送家族の資格は、必要に応じて追加する必要があります。

USBまたはPCIトランスポートの資格をまだリクエストしていない場合は、Appleの開発者サイトにアクセスしてリクエストを送信してください。

提示されたサンプルコードは純粋にデモンストレーション目的であり、ハードウェアデバイスに関連付けられていない仮想オーディオドライバを作成するため、そのようなユースケースでは資格は付与されないことに注意してください。

仮想オーディオドライバまたはデバイスがすべて必要な場合は、オーディオサーバープラグインドライバモデルを引き続き使用する必要があります。

では、あなたのdextのinfo.plistを見てみましょう。

これらの設定は、dextのIOKitPersonalitiesに追加する必要があります。

AudioDriverKitは、HALが必要とするIOUserAudioDriverUserClientの作成を処理します。

HALには、ユーザークライアント接続に接続するために必要な資格があります。

SimpleAudioDriverUserClientのカスタムユーザークライアントの例を次に示します。

詳細については、AudioDriverKitTypes.hヘッダーファイルを参照してください。

次に、設定と初期化について話しましょう。

オーディオデクストを設定する最初のステップは、IOUserAudioDriverをサブクラス化し、仮想メソッドをオーバーライドすることです。

IOUserAudioDriverはIOServiceのサブクラスです。

カスタム動作を実装するために必要なIOUserAudioオブジェクトをサブクラス化します。

次に、それらを設定してIOUserAudioDriverに追加します。

この図は、作成するIOUserAudioオブジェクトの概要を示しています。

SimpleAudioDriverは、IOUserAudioDriverのサブクラスであり、dextへのエントリポイントです。

SimpleAudioDriverは、IOUserAudioDeviceのサブクラスであるSimpleAudioDeviceを作成します。

オーディオデバイスは、すべてのスタートストップIO関連メッセージ、タイムスタンプ、および構成変更を処理します。

SimpleAudioDeviceは、さまざまなIOUserAudioObjectsを作成します。

デバイスオブジェクトはまた、OSTimerDispatchSources、OSActionsを作成し、ハードウェア割り込みとIOをシミュレートするためのトーンジェネレータを実装します。

IOUserAudioStreamは、デバイスが所有するストリームです。

ストリームは、HALにマッピングされるオーディオIOにIOMemoryDescriptorを使用します。

IOUserAudioVolumeLevelControlは、スカラー値またはdB値を取る制御オブジェクトです。

制御値は、入力オーディオバッファにゲインを適用するために使用されます。

すべてのIOUserAudioObjectは、IOUserAudioCustomPropertiesを持つことができます。

SimpleAudioDeviceは、カスタムプロパティと文字列の例を修飾子とデータ値として作成します。

コードを見てみましょう。-コードを見てみましょう。

SimpleAudioDriverはIOUserAudioDriverのサブクラスです。

Start、Stop、およびNewUserClientは、ドライバーがオーバーライドする必要があるIOServiceクラスの仮想メソッドです。

StartDeviceとStopDeviceは、IOUserAudioDriverのIO関連の仮想メソッドです。

これらは、HALがオーディオデバイスのIOを開始または停止したときに呼び出されます。

デバイス、ストリーム、その他のオーディオオブジェクトを調べた後、IOパスについて説明します。

この例は、NewUserClientをオーバーライドしてユーザークライアント接続を作成する方法を示しています。

NewUserClientは、クライアントプロセスがdextに接続したいときに呼び出されます。

AudioDriverKitフレームワークは、IOUserAudioDriver基本クラスでNewUserClientを呼び出すことで、HALが必要とするユーザークライアントの作成を処理します。

これにより、CoreAudio HALに必要なIOUserAudioDriverUserClientが作成されます。

以前に追加されたドライバー拡張機能info.plistエントリからユーザークライアントオブジェクトを作成するIOService Createを呼び出すことで、カスタムユーザークライアントも作成できます。

Startをオーバーライドし、カスタムIOUserAudioDeviceオブジェクトを作成する方法を見てみましょう。

まず、スーパークラスでスタートを呼び出します。

次に、SimpleAudioDeviceを割り当て、いくつかの必要なパラメータで初期化します。

初期化されたデバイスは、AddObjectを呼び出してオーディオドライバに追加する必要があります。

最後に、サービスを登録すると、ドライバーは行く準備が整います。

ドライバーが初期化されたので、デバイス、ストリーム、その他のオーディオオブジェクトを作成しましょう。

カスタム動作を取得するサブクラスIOUserAudioDevice。

入力ストリーム、ボリュームコントロール、カスタムプロパティオブジェクトを作成しましょう。

SimpleAudioDeviceのinitメソッドは、デバイスを設定し、さまざまなオーディオオブジェクトを作成する方法を示しています。

デバイスのサンプルレート関連情報は、デバイスでSetAvailableSampleRatesとSetSampleRateを呼び出すことによって設定されます。

IOUserAudioStreamに渡されるIOBufferMemoryDescriptorを作成します。

メモリはCoreAudio HALにマッピングされ、オーディオIOに使用されます。

メモリは理想的には、ハードウェアへのDMAに使用されるのと同じIOメモリであるべきです。

IOUserAudioStreamは、入力ストリームの方向で指定し、上記で作成されたIOメモリ記述子を渡すことによって作成されます。

機能する前に、ストリームでいくつかの追加設定をする必要があります。

ストリームフォーマットは、IOUserAudio StreamBasicDescriptionsのフォーマットリストを作成することによって定義されます。

サンプルレート、フォーマットID、およびその他の必要なフォーマットプロパティを指定します。

上記で宣言されたストリームフォーマットリストを渡すことで、利用可能なフォーマットを設定します。

そして、ストリームの現在のフォーマットを設定します。

最後に、AddStreamを呼び出して、設定されたストリームをデバイスに追加します。

それでは、ボリュームレベルコントロールの作成についてお進みください。

ボリュームコントロールオブジェクトを作成するには、IOUserAudioLevelControl::Createメソッドを呼び出します。

コントロールは、初期レベルが-6dBに設定され、範囲が96dBの設定可能なボリュームコントロールです。

コントロールの要素、スコープ、およびクラスも指定する必要があります。

最後に、コントロールオブジェクトをデバイスに追加します。

ボリュームコントロールゲイン値は、入力ストリームのIOバッファにゲインを適用することにより、IOパスで使用されます。

それでは、デバイスのカスタムプロパティオブジェクトの作成について確認しましょう。

すべてのカスタムプロパティオブジェクトにプロパティアドレスを提供する必要があります。

グローバルスコープとメイン要素を持つカスタムセレクタタイプを定義します。

次に、上記で定義されたプロパティアドレスを提供して、カスタムプロパティオブジェクトを作成します。

カスタムプロパティは設定可能で、修飾子とデータ値の型は両方とも文字列です。

次に、修飾子とデータ値のOSStringを作成します。

次に、カスタムプロパティに設定します。

最後に、カスタムプロパティをデバイスに追加します。

オーディオオブジェクトを作成したので、IOについて話しましょう。

GetIOMemoryDescriptorメソッドは、IOUserAudioStreamで使用されるIOMemoryDescriptorを返します。

IOMemoryDescriptorは、ストリームの作成時にinitメソッドに渡され、ストリームも新しいメモリ記述子で更新できます。

メモリはHALにマッピングされ、オーディオIOに使用されます。

ストリームで使用されるのと同じメモリ記述子は、理想的にはハードウェアデバイスへのDMAに使用されるものと同じであるべきです。

IOUserAudioClockDeviceは、IOUserAudioDeviceの基本クラスです。

UpdateCurrentZeroTimestampとGetCurrentZeroTimestampは、ハードウェアデバイスからのタイムスタンプを処理するために使用する必要があります。

タイムスタンプはアトミックに処理され、HALはサンプルのタイムホストタイムペアを使用してIOを実行および同期します。

ハードウェアクロックのタイムスタンプをできるだけ近くで追跡することが重要です。

SimpleAudioDeviceクラスを見て、IO関連のメソッドに焦点を当てましょう。

HALがIOを実行しようとすると、StartIOとStopIOがドライバーから呼び出されます。

プライベートメソッドは、IOTimerDispatchSourceとOSActionを使用してハードウェア割り込みをシミュレートし、入力IOバッファでゼロタイムスタンプとオーディオデータを生成するために使用されます。

この例はハードウェアデバイスに対して実行されていないため、ハードウェア割り込みとDMAの代わりにタイマーとアクションが使用されます。

HALがデバイスでIOを起動しようとすると、デバイスオブジェクトでStartIOが呼び出されます。

ハードウェアでIOを起動するために必要な呼び出しは、ここで行う必要があります。

その後、StartIOは基本クラスで呼び出されるべきです。

次に、入力ストリームのIOMemoryDescriptorを取得して、CreateMappingを呼び出してIOMemoryMapを作成できます。

バッファアドレス、長さ、およびオフセットは、IOバッファにトーンを生成するために発生したハンドラで使用されます。

StartTimersは、タイムスタンプを生成し、入力オーディオバッファに入力するためのタイムソースとアクションを設定して有効にするために呼び出されます。

UpdateCurrentZeroTimestampは、IOUserAudioDeviceのサンプル時間-ホスト時間ペアを原子的に更新するために呼び出されます。

タイマーソースは有効になり、mach_absolute_timeとデバイスから設定されたホストティックに基づいてウェイクアップ時間で設定されます。

ZtsTimerOccurredアクションは、デバイスで新しいタイムスタンプを更新できるように、ウェイク時間に基づいて呼び出されます。

ここには示されていませんが、サンプルコードはトーン生成タイマーとアクションも同様の方法で更新します。

ゼロタイムスタンプアクションが発生すると、GetCurrentZeroTimestampを呼び出すことで、最後のゼロタイムスタンプ値がデバイスから取得されます。

これが最初のタイムスタンプの場合は、タイマーに渡されたmach_absolute_timeをアンカー時間として使用します。

それ以外の場合、タイムスタンプはゼロタイムスタンプ期間とバッファごとのホストティックによって更新されます。

UpdateCurrentZeroTimestampを呼び出すと、HALが新しい値を使用できるようにデバイスのタイムスタンプが更新されます。

次のゼロタイムスタンプのために将来目を覚ますようにZTSタイマーを設定します。

DMAをシミュレートするために、タイマーアクションが実行されると、オーディオデータが入力IOバッファに書き込まれます。

まず、start IOが呼び出されたときに割り当てられた入力メモリマップが有効かどうかを確認します。

メモリマップバッファの長さとストリーム形式を使用して、IOバッファのサンプルの長さを取得します。

ストリームは署名された16ビットpcmサンプル形式のみをサポートしているため、バッファアドレスとオフセットを取得し、int16_tバッファポインタとして割り当てます。

これで、入力IOバッファは、正弦音を生成することによって埋めることができます。

まず、入力ボリュームコントロールゲインをスカラー値として取得します。

次に、必要なサンプル数をループし、ボリュームコントロールゲインを適用して正弦音を生成します。

次に、バッファをループし、チャンネル数に基づいて正弦トーンサンプルをIOバッファに入力し、ラップアラウンドも考慮します。

オーディオデクストが設定され、IOを実行できるようになったので、次のステップは、デバイスとそのIO関連の状態を更新するための構成変更を処理することです。

表示されているデバイスメソッドは、構成変更を要求および実行するために使用できます。

IOまたはその構造に影響を与えるオーディオデバイスの状態の変更については、ドライバーはRequestDeviceConfigurationChangeを呼び出して設定変更を要求する必要があります。HALは実行中のIOを停止し、PerformDeviceConfigurationChangeはドライバーで呼び出されます。

そうして初めて、オーディオデバイスはIO関連の状態を更新できます。

これの一般的なシナリオは、オーディオデバイスの現在のサンプルレートを更新するか、ハードウェアデバイスの変更に合わせて現在のストリーム形式を変更することです。

この図は、デバイス構成変更の一連のイベントを示しています。

ドライバーはまず設定の変更をリクエストする必要があります。

HALは、デバイスの設定変更が開始されることをリスナーに通知します。

IOが現在実行されている場合、IOはデバイスで停止します。

デバイスの現在の状態がキャプチャされます。

PerformDeviceConfigurationChangeがドライバで呼び出されます。

これは、ドライバーがデバイスとハードウェアの状態を変更できるときです。

設定変更が実行されると、デバイスの新しい状態がキャプチャされ、IOバッファやサンプルレートなどのすべてのIO関連状態が更新されます。

デバイスの状態の変更は、クライアントリスナーに通知されます。

設定変更前にIOが以前に実行されていた場合、IOはデバイスで再起動されます。

最後に、HALは設定の変更が終了したことをリスナーに通知します。

ハードウェアボトムアップ設定変更要求をシミュレートするために、カスタムユーザークライアントコマンドを使用して、dextのサンプルレート変更をトリガーします。

RequestDeviceConfigurationChangeは、オーディオデバイスの設定変更要求をHALに通知します。

変更情報は、あらゆる種類のOSObjectである可能性があることに注意してください。

この例では、カスタム設定変更アクションと変更情報をOSStringとして提供します。

構成変更の実行を処理するには、SimpleAudioDeviceクラスは、PerformDeviceConfigurationChangeのメソッドをオーバーライドする必要があります。PerformDeviceConfigurationChangeは、スイッチステートメントの構成変更アクションを処理します。

設定変更が要求されたときに変更情報として提供されたのと同じOSStringオブジェクトを記録します。

次に、現在のサンプルレートを取得し、デバイスに新しいレートを設定します。

ストリームオブジェクトでDeviceSampleRateChangedを呼び出して、サンプルレートの変更を処理するために、オーディオストリームが現在のストリームフォーマットを更新していることを確認してください。

デバイスが直接処理しないその他の設定変更アクションは、基本クラスに渡すことができます。

Macでこれを見てみましょう。 では、Macで見てみましょう。

So SimpleAudioは、ドライバ拡張機能をバンドルするサンプルコードアプリケーションです。

オーディオドライバ拡張機能をインストールするには、[ドライバのインストール]を押すだけで、セキュリティ設定が表示されるはずです。

したがって、Allowキーを押すと、オーディオドライバの拡張機能が動的に読み込まれます。

以前は、再起動が必要になるため、これはkextでは不可能でした。

そのため、SimpleAudioDeviceには、利用可能なサンプルレート形式とトーン選択データソースがあります。

そして、サンプルコードに追加したボリュームコントロール。

これで、QuickTimeを開いて、オーディオデバイスでオーディオ録音を行うことができます。

また、ボトムアップ設定の変更をテストするには、dextと直接通信してトーン周波数またはサンプルレートを切り替えることができ、変更はAudio MIDI設定にも反映する必要があります。

ドライバーの拡張機能を削除するには、アプリケーションを削除するだけです。

そして、オーディオMIDIの設定では利用できなくなったことがわかります。

まとめとして、オーディオサーバープラグインとDriverKit拡張機能の状態をまとめました。

これは引き続きサポートされ、AudioServerPlugInドライバインターフェイスは非推奨ではありません。

私は新しいAudioDriverKitフレームワークを紹介し、新しいドライバーモデルの利点について議論しました。

AudioDriverKitフレームワークを採用する方法の詳細な例を調べ、ユーザースペースで実行されているIOUserServiceベースのオーディオデクストを作成するためのサンプルコードを示しました。

最新のXcodeとDriverKit SDKをダウンロードしてください。

DriverKitがサポートするハードウェアデバイスファミリを持つオーディオデバイスにAudioDriverKitを採用してください。

また、Appleのフィードバックアシスタントを通じて、AudioDriverKitに関するフィードバックを提供してください。

ありがとう。

[明るい音楽]。