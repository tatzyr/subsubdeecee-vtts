10030

♪ベース音楽の演奏♪

♪

Sihui Liu:こんにちは。「高度なウェブコンテンツの開発」へようこそ。私はSihuiで、SafariとWebKitチームのエンジニアです。

過去1年間にウェブ開発者のためにWebKitとSafariで行った重要なアップデートを皆さんと共有できることを嬉しく思います。

私が共有しようとしているものは、一般的に3つのカテゴリーに分類されます。

まず、JavaScriptの新機能と機能強化について説明します。

次に、WebAssemblyの更新の概要を説明します。

そして最後に、ウェブコンテンツに機能を追加できる新しいウェブAPIを紹介します。

取り上げることがたくさんあるので、JavaScriptでのニュースから始めましょう。

毎年、私たちのJavaScriptエンジンには何百もの変更が加えられています。

JavaScriptで作業する場合、あなたが知る必要がある最も重要なもののいくつかをカバーします。

それらは、新しいクラスフィールド構文、よりスマートなメモリ管理を可能にする弱い参照、awaitキーワードの新しい使用法、ワーカーのモジュールのサポート、および国際化APIファミリに追加されたインターフェイスです。

これらの新機能の絵にあなたを入れるために、私は例として簡単なストップウォッチを使うつもりです。

ストップウォッチにはボタンが1つしかありません。

一度クリックすると、カウントが開始されます。

もう一度クリックすると、停止し、経過した期間が表示されます。

これを念頭に置いて、後でJavaScriptで実装します。

では、新しいクラスフィールド構文を見てみましょう。

アクセスが言語によって保護されている実際のプライベートメンバーを定義できる新しいプライベートクラスフィールドとメソッドがあります。

アクセスルールを破るとエラーが表示されます。

また、静的フィールドのサポートを追加します。これにより、クラスのインスタンスを作成せずにアクセスできるクラスメンバーを宣言できます。

今、あなたは基本的な考えを持っています。

ストップウォッチの例でどのように使用できるかを確認しましょう。

ストップウォッチクラスを実装するように求められた場合、実装は次のようになります。

StopwatchWithOneButtonには、click()という名前のメソッドが1つしかありません。

startTime変数をチェックします。

開始時間が設定されていない場合、クリックは開始を意味するので、開始時間が設定されます。

開始時間がすでに設定されている場合、クリックは停止することを意味するので、期間を計算し、開始時間をリセットします。

startTimeにはアンダースコアプレフィックスが付属していることがわかります。

これは、変数がクラス内でのみ使用されるべきであることを示すために一般的に使用される命名規則です。

しかし、それは実際には開始時間が公にアクセスされるのを妨げるものではありません。

新しいプライベート構文は、これを修正するのに役立ちます。

アンダースコアをハッシュに置き換えるだけで、実際のプライベートインスタンスフィールドを宣言できます。

カプセル化は言語によって強制されます。

プライベートメソッドのサポートもあります。

たとえば、click() メソッドをより構造化するには、次のように強調表示されたコンテンツを置き換えるために、2 つのプライベート メソッド start() と stop() を作成できます。

メソッドにハッシュプレフィックスを追加することで、メンバー関数がクラス内からのみアクセスできるようにします。

新しいプライベート構文は、startedStopwatchCountのような静的フィールドにも適用されます。

ここでは、startedStopwatchCountは、開始時刻または停止時刻にストップウォッチオブジェクトによってのみ変更できます。

もちろん、startedStopwatchCountをどこでもアクセスしたい場合は、ハッシュプレフィックスなしでパブリック静的フィールドとして宣言できます。

パブリックスタティックフィールドは現在、WebKitでも利用可能です。

プライベートインスタンスフィールド、メソッド、プライベート静的フィールド、パブリック静的フィールド。それが私たちの新しいクラスフィールドサポートです。

そして、別の機能、弱い参照を続けましょう。

弱い参照を使用すると、ガベージコレクションを妨げない方法でJavaScriptオブジェクトへの参照を保持することができます。

WeakMapやWeakSetとは異なり、すでに参照しなくても、基礎となるオブジェクトを取得できます。

サポートにはガベージコレクションの通知も含まれているので、必要に応じてクリーンアップタスクを実行できます。

そして、それがどのように使用できるか見てみましょう。

ストップウォッチクラスを実装したばかりです。

さまざまなタスク用に複数のストップウォッチオブジェクトを作成したと想像してみてください。

テストを行うには、一度にすべてをクリックする必要があります。

どうやってそれをするの？

直感的な方法は、すべてのストップウォッチインスタンスのセットを維持することです。

ストップウォッチが作成されたら、セットに追加します。

次に、clickAllStopwatches機能で、セットを反復して各ストップウォッチをクリックします。

しかし、このアプローチには問題があります。

JavaScriptオブジェクトはデフォルトで強力な参照を保持していることを知っているので、この場合、セットにはまだ参照があるため、すべてのストップウォッチオブジェクトをガベージコレクションすることはできません。

もちろん、テストのためだけにすべてのストップウォッチオブジェクトを周りに置いておきたくありません。

これはメモリの使用には最適ではありません。

さて、SetをWeakSetに置き換えることを提案するかもしれませんが、WeakSetは反復可能ではありません。

それで、あなたはどうしますか?

オブジェクトへの弱い参照を保持する新しいインターフェイスWeakRefで解決できます。

私たちはまだセットを持っていますが、今回はストップウォッチオブジェクトのWeakRefをセットに追加します。

clickAllStopwatches関数では、クリックする前にオブジェクトを逆参照して、オブジェクトがまだ存在するかどうかを確認します。

これは私たちの問題を解決しているようですが、別の問題があります。ガベージコレクションのストップウォッチをタイムリーにセットから削除せず、次のクリックテストの前にセットがかなり大きくなる可能性があります。

さて、私たちは何をすべきですか?

この場合、別の新しいインターフェイスであるFinalizationRegistryが役立つかもしれません。

それを使用すると、あるオブジェクトがガベージコレクションされたときに呼び出されるコールバックを指定できます。

ここでは、removeStopwatch関数を使用してfinalizationRegistryオブジェクトを作成するため、オブジェクトが収集されるたびにこの関数が呼び出されます。

次に、ストップウォッチオブジェクトをレジストリに登録します。

各ストップウォッチは識別子でバインドされているので、removeStopwatchはどのストップウォッチを削除するかを知っています。

よし、ゴミ収集ストップウォッチはすべてのストップウォッチから削除されます。

弱い参照の使用はそれほど難しく聞こえませんよね?

しかし、JavaScriptのガベージコレクションは非常に複雑であり、多くの不確実性があることに注意してください。

たとえば、収集する必要があると思われるオブジェクトは、実際には長い時間後まで収集されない可能性があり、イベントループで実行されるため、FinalizationRegistryから正しい方法でコールバックを取得できない場合があります。

したがって、使用前に構文とその予想される動作を完全に理解していることを確認してください。

弱い参照から次の機能、トップレベルの待機に移りましょう。

これはモジュールの新機能です。

これにより、非同期関数の外でawaitキーワードを使用できます。

この場合、モジュール自体は大きな非同期関数のようなものなので、非同期モジュールはそれらをインポートするモジュールの実行をブロックすることができます。

ストップウォッチクラスの例をお見せしましょう。

これは私たちが作成したばかりのクラスです。

トップレベルの待機の使用を説明するために、それをモジュールにしてクラスをエクスポートしましょう。

これは、インラインモジュールを含むHTMLファイルです。

動的インポートを使用してストップウォッチモジュールをインポートします。

インポート関数は約束を返すので、インポートが完了した後、thenまたはcatchメソッドを使用してアクションを実行できます。

トップレベルの待機では、チェーンメソッドを削除し、同期的な方法でコードを書くことができます。

これにより、コードがわかりやすくなります。

また、インポートされたモジュールはロード時に評価されるため、非同期モジュールはそれに応じてモジュールの実行をブロックすることができます。

つまり、ストップウォッチモジュールが非同期操作を実行して結果を待つ場合、ストップウォッチモジュールの実行が完了した後、ここでのストップウォッチ変数が初期化されます。

トップレベルの待機により、依存関係管理が容易になりました。

しかし、繰り返しますが、この機能はモジュールでのみ利用できるので、スクリプトがモジュールでない場合、このように...

...Webインスペクタに構文エラーが表示されます。

モジュールといえば、別の関連機能があります。モジュールワーカーです。

労働者にはいくつかのよく知られた利点があります。

バックグラウンドスレッドでスクリプトを実行できるため、リソースをより効率的に活用できます。

この新しいサポートにより、ワーカーは動的インポート、最適化されたロードと実行、依存関係管理など、モジュールの利点を共有します。

重い作業をメインスレッドからバックグラウンドスレッドに移動することは、より有益で簡単です。

モジュールは、ウェブワーカー、サービスワーカー、ワークレットなど、さまざまなタイプのワーカーで利用可能になりました。

ウェブワーカーとサービスワーカーのモジュールワーカーを作成するには、オプションでモジュールの型を指定する必要があります。

オーディオワークレットのようなワークレットには、addModule関数を使用できます。

アプリケーションを高速化するのに役立つモジュールワーカーを作成するのはとても簡単です。

JavaScriptの最後のセクションは、国際化APIの更新です。

このAPIは、言語ベースの書式設定を提供します。

ウェブコンテンツが異なるロケールのユーザー向けに構築されている場合に便利です。

使用方法を示すために、このストップウォッチレコードページを作成しました。なぜなら、ストップウォッチは時間と機能のリリースに追いつく必要があるからです。

このページでは、期間、開始時間、イベント、参加者、ページの利用可能な言語など、ストップウォッチの1回の使用に関する詳細を示しています。

では、各セクションに飛び込んで、各インターフェイスを詳しく見てみましょう。

最初はNumberFormatです。

NumberFormatは、言語に敏感な数値の書式設定を提供し、期間を書式設定するために使用されます。

NumberFormatのコンストラクタは、言語とオプションの2つのオプションパラメータを取ります。

ここでは、言語を英語に設定し、異なる最小桁数を指定する2つのオプションオブジェクトを作ります。

言語とオプションで2つのNumberFormatオブジェクトを作成した後、それらを使用して期間番号をフォーマットできます。

ここでは、数値がミリ秒でない場合は、Format1を使用して2桁を保持します。それ以外の場合は、Format2を使用して3桁を保持します。

ご覧のとおり、フォーマットメソッドは自動的に私たちのためにパディングゼロを追加します。

スタイルなど、必要なフォーマットを作成するために利用できるさまざまなオプションがあり、値を通貨または単位として指定できます。

次は、言語に敏感な日付と時刻の書式設定を可能にするDateTimeFormatです。

使い方はNumberFormatに似ています。

まず、言語を設定します。

次に、オプションを設定します。

オプションでは、日付と時刻に異なるスタイルを設定します。

DateTimeFormatオブジェクトは、2秒またはミリ秒のスタイルを指定できるきめ細かな構成を提供します。

その後、パラメータを持つDateTimeFormatオブジェクトを作成し、それを使用して開始時間をフォーマットすることができます。

結果は英語で表されます。

スタイルが長いので、日付がより詳細であることがわかります。

次はセグメンタです。

これにより、言語に敏感な文字列分割を行うことができます。

イベント文のキーワードを見つけるために使用しました。

これはストップウォッチレコードページの中国語版です。

まず、強調したいキーワードの短いリストを宣言します。

イベント文字列には、摂氏度記号のUnicodeも含まれています。

ここでは、中国語を言語として指定します。

オプションでは、粒度は単語に設定されています。

他の可能な値は、書記素と文です。

次に、セグメンタを作成し、それを使用してセグメントメソッドで文字列を分割します。

結果オブジェクトを反復して、すべてのセグメントを取得できます。

各セグメントがキーワードリストに含まれているかどうかを確認してマークします。

セグメンタは、単語の境界がそれほど明白ではない中国語のような言語を解釈するのに非常に便利です。

次は、言語に敏感なリストの書式設定を可能にするListFormatです。

以前と同じように、言語とオプションを指定できます。

ListFormatには、他のインターフェイスほど多くのオプションはありません。

私が見つけた最も有用なものは、タイプとスタイルです。

言語とオプションを使用すると、ListFormatを作成し、参加者リストをフォーマットできます。

ご覧のとおり、タイプは接続詞でスタイルが長いため、フォーマットメソッドは結果にカンマと単語「and」を追加します。

最後はDisplayNamesです。

言語、地域、スクリプトの表示名の一貫した翻訳を提供します。

ここでは、日本語の言語を指定します。

DisplayNamesは、言語コードを入力として取ることができます。

オプションでは、タイプを言語として設定します。

次に、DisplayNamesオブジェクトを作成できます。

そしてここで、メソッドを使用して、翻訳された結果を得ることができます。

このページは英語で構築されていますが、日本のユーザーはどの言語がサポートされているかを知ることができます。

そして、これが私が新しい国際化インターフェースでストップウォッチレコードページを構築した方法です。

記憶をリフレッシュするために、JavaScriptセクションで見たもののリストを次に示します。

その後、次の目的地はWebAssemblyの更新です。

私たちはしばらくの間、WebAssemblyエンジンを出荷してきましたが、それに慣れていない場合は、WebAssemblyの背景を記入することから始めましょう。

WebAssemblyは、スタックベースの仮想マシンのバイナリ命令形式です。

これは、ネイティブコードに近いパフォーマンスを持つ最新のWebブラウザで実行できるコードの一種です。

WebAssemblyは、C、C ++、Rustなどのプログラミング言語のポータブルコンパイルターゲットとして設計されているため、WebAssemblyは、これらの言語で書かれたアプリケーションをWeb上に展開するのに役立ちます。

WebAssemblyのほとんどのユースケースでは、JavaScriptと一緒に実行されます。

彼らはWebAssembly APIを通じて互いに通信することができます。

WebAssemblyは、ほぼネイティブなパフォーマンスを提供し、強力なフレームワークをウェブ上で利用できるようにします。

JavaScriptはDOMを操作でき、強力なウェブAPIを提供します。

彼らはお互いに良い追加になることができます。

WebAssemblyの使用の良い例は、ファンキーカートです。

これは、EmscriptenでC++からWebAssemblyに変換されたゲームです。

ご覧のとおり、Safariでは非常にスムーズに実行できます。

今年は、次の機能を備えたWebAssemblyエンジンをアップグレードしました。メモリブロックのコピーや初期化など、バルクメモリ操作でより良いパフォーマンスを提供する新しいメモリ命令。floatとintの間で変換するときの正のオーバーフローなど、例外をトラップしないようにユーザープロセスに指示する新しい命令。符号付き整数を拡張できる新しい符号拡張演算子。以前のソリューションよりも簡単で、コードをオブジェクト、それらを引数として渡し、それらを保存します。そして最後に、全体的な実行時間を短縮するWebAssemblyのダウンロードとコンパイルをストリーミングします。

これらは、新しいWebAssembly機能のハイライトです。

彼らがあなたの開発に役立つことを願っています。

では、強力な低レベルコードからいくつかの高レベルAPIに移行しましょう。

このセクションでは、新しいWeb APIについて説明します。

私の目標は、新機能についてあなたに知らせるだけでなく、あなたがそれらを使用する準備ができていると感じさせることですので、あなたはいくつかの良い例を見るでしょう。

しかし、これは完全なチュートリアルではないので、使用前に公式のドキュメントを確認することを忘れないでください。

これは私が話す機能のプレビューです。

それらのいくつかは音声認識のように完全に新しく、それらのいくつかはすでにそこにありますが、ストレージアクセスのように共有したいいくつかのアップデートがあります。

では、それぞれを掘り下げてみましょう。

私たちはウェブコンテンツを魅力的にすることを知っています、素晴らしい視覚体験を提供することは非常に重要です。

WebGL2がWebKitとSafariで利用可能であるため、美しくインタラクティブなWebコンテンツを簡単に作成できます。

これは、WebGL2で何ができるかの良い例です。

After the Floodは、PlayCanvasが開発したインタラクティブなデモです。

穏やかな風が木を揺らしているのが見えます。

サファリでは鮮やかに見えます。

では、WebGL2とは何ですか?

WebGLは、2Dおよび3Dグラフィックスをレンダリングするために非常に広く使用されている低レベルAPIです。

WebGL2は、フォールバックを排除し、いくつかのクールな新機能を導入するWebGLのアップグレードです。

雲のような体積効果をレンダリングできるように、3Dテクスチャを追加します。

シェーダーでテクスチャを使用する方法について、より柔軟性を与えるサンプラーオブジェクトがあります。

GPUにパフォーマンスパーティクルシステムを実装するのに役立つ変換フィードバックを提供します。

WebGL2には非常に多くの素晴らしい新機能があります。

さらに重要なことに、WebGL2はすべてのAppleデバイスのSafariで利用可能になりました。

つまり、どこでも見栄えのいい美しいサイトを構築できるということです。

そして、オレンジ色の四角を作成するという例で、WebGL2に慣れましょう。

そして、これはあなたがそれのために書く必要があるJavaScriptコードです。

以前にWebGLを使用したことがないなら、これはあなたが想像していたほど簡単ではないかもしれません。

前述したように、WebGLは低レベルのAPIであるため、非常に冗長になる可能性があります。

しかし、心配しないでください。開発を簡素化するのに役立つ素晴らしいライブラリやフレームワークがたくさんあります。

彼らと一緒に、素敵な正方形やそれよりも複雑なものを作るのはそれほど難しくありません。

さて、すでにウェブコンテンツでWebGLを使用している場合は、良いニュースもあります。

バックエンドをOpenGLからMetalに移行することで、サポートを改善しました。

つまり、iOS SimulatorはWebコンテンツにGPUを使用でき、ユーザーが見るものをはるかに正確に表現できるようになったということです。

また、Xcodeフレームデバッガなどの金属ツールを使用して、WebGLコードを分析することもできます。

WebGLでコンテンツを作成するだけでなく、優れたビジュアル体験を提供するもう1つの一般的な方法は、ビデオです。

すべてのブラウザが同じ種類のメディアフォーマットをサポートしているわけではないので、使用するフォーマットを決めるのが難しい場合があります。

物事をより簡単にするために、今年は、ウェブ上の一般的なメディアフォーマットであるWebMのサポートを強化しました。

まず、サポートはストリーミング再生のみです。

macOS 11.3では、VP8またはVP9ビデオとVorbisオーディオを含むWebMファイルを再生するためのサポートを追加しました。

また、macOS 12では、Opusオーディオを含むファイルのサポートが追加されています。

昨年、macOSのMedia Source Extensionsで再生されるWebMのサポートを開始しました。

今、私たちはそのサポートをiPadOS 15にもたらしています。

WebMがコードでサポートされているかどうかを確認するには、MediaCapabilities APIを使用して、使用する正確なメディア構成を検出できます。

画面上の設定は最新のSafariでサポートされています。つまり、VP9もサポートされています。

このビデオコーディングフォーマットのサポートにより、SafariやWebKitアプリでより多くのウェブコンテンツが利用可能になることを期待しています。

VP9はストリーミングとWebRTCの両方で使用できます。

macOSとiPadOSで動作します。

さまざまなデバイスでのサポートについては、すべてのAppleシリコンMacで利用できます。

他の人については、WebMで見たものと同じように、MediaCapabilities APIで確認できます。

さて、あなたのサイトにWebMまたはVP9のコンテンツがある場合は、最新のSafariとWebKitでどのように機能するかを確認することをお勧めします。しかし、まだ使用するメディア形式を決定している場合は、H.264またはHEVCをお勧めします。

H.264は成熟しており、ブラウザ間で十分にサポートされています。

HEVCは高品質のビデオを非常にサポートしています。

どちらも、よりスムーズな再生とより長い再生バッテリー寿命を提供できるハードウェアアクセラレーションが付属しています。

ビデオコンテンツのホスティングについて言えば、一般的なケースは、コンテンツを所有するのではなく、第三者から入手することです。

例えば、私はvideo.domainでこの素敵なビデオを見ます。

私のサイトmain.domainに表示するには、video.domainからこのビデオソースを読み込むか、video.domainのiframeを作成するだけです。

セキュリティ上の理由から、サードパーティのiframeまたはリソースはデフォルトでファーストパーティストレージにアクセスできません。

つまり、video.domainのリソース要求がmain.domainから開始された場合、video.domainのクッキーは含まれません。

これは、video.domainのWebサーバーが認証されたユーザーにのみコンテンツを提供したい場合に問題になる可能性があります。

そして、クッキーがないということは、認証がないことを意味します。

ストレージアクセスAPIはこの問題を解決します。

これにより、サードパーティのiframeは、ファーストパーティのCookieにアクセスする許可を要求できます。

ユーザーが許可を付与すると、サードパーティのvideo.domainはファーストパーティのCookieにアクセスできるようになります。

ストレージアクセスAPIは、WebKitとSafariで3年以上にわたって利用可能です。

相互運用性を向上させるために、今年は2つの新機能を追加しました。

まず、アクセスはページごとの範囲で許可されます。

これは、第三者に許可が付与されると、同じページ上のすべてのサブリソースに拡張されることを意味します。

各iframeのリクエストを行う必要はありません。

第二に、ネストされたiframeが要求をすることを許可します。

これは、iframe内のiframeが、以前は不可能だったファーストパーティクッキーへのアクセスも要求できることを意味します。

新しい使用法の詳細については、webkit.orgのブログ記事「Storage Access APIの更新」を確認してください。

これで、必要に応じてユーザーの許可を得て第三者からビデオコンテンツをロードまたはインポートする方法を知っています。

自分で何かを作るのはどうですか?

新しいメディアレコーダーAPIを使用すると、非常に簡単に実行できます。

Media Recorder APIを使用すると、ビデオタグやMediaStreamオブジェクトなどのHTMLメディア要素を含むメディア要素からデータをキャプチャできます。

ユーザーの入力デバイスから記録するために使用できます。

コンテナのMIMEタイプやトラックの所望のビットレートなど、目的のオプションを指定できます。

APIはシンプルです。

これは、単一の主要なインターフェイスであるMediaRecorderで構成されており、ソースからデータを収集して配信するすべての作業を行います。

例をお見せしましょう。

MediaRecorder APIを使用して、「ボイスメモ」と呼ばれるこのウェブアプリを構築しました。

これは私の最初のボイスメモです。

ボタンをクリックすると、マイクから録音が始まります。

もう一度クリックすると、録画を停止し、再生を提供します。

これは私の最初のボイスメモです。

それは楽しいです。

では、実装を確認しましょう。

startRecordingとstopRecordingの2つの主要な機能があります。

startRecordingでは、マイクの入力メディアストリームを取得します。

次に、それを使用してMediaRecorderオブジェクトを作成します。

私たちはメディアレコーダーの2つのイベントを聞きます。

そして、開始方法でレコーダーを起動できます。

録音を停止するには、mediaRecorderオブジェクトのstopメソッドを呼び出すだけです。

ここに2つのイベントハンドラがあります。

キャプチャされたデータが利用可能な場合は、それを配列に保存します。

録音が停止すると、収集したデータを配列でブロブを作成し、再生のために既存のオーディオ要素に送信します。

そのように、機能的なボイスレコーダーを作成できます。

オーディオデータを収集した後、それを編集したいと思うかもしれません。

この場合、新しいAudio Worklet APIをうまく活用できます。

Audio WorkletインターフェイスはWeb Audio APIの一部であり、以前にWebでオーディオ処理を行ったことがある場合は、すでによく知っているかもしれません。

JavaScriptやWebAssemblyコードなどのスクリプトを実行して、カスタムAudioNodesをサポートするオーディオレンダリングスレッドでオーディオを処理できます。

ScriptProcessorNodeと比較して、カスタムスクリプトを実行するための以前のソリューションは、レンダリングスレッドとメインスレッドの間のホッピングを減らし、低レイテンシーを保証します。

オーディオワークレットで、ボイスメモに新しい機能を追加しました。

これは私の歪んだ声です。

録音のために歪みボックスがチェックされている場合、オーディオに何らかの歪み効果が適用されます。

これは私の歪んだ声です、それはクールに聞こえます、そしてそれがどのように実装されているかを見てみましょう。

startRecording機能を変更して、オーディオ処理を追加しました。

最初にオーディオ入力用のMediaStreamを取得する必要があります。

Audio Worklet APIを使用するには、4つの基本的なステップがあります。

ステップ1：ソースを作成します。

ステップ2：AudioWorkletNodeを作成し、オーディオ処理を実行するAudio Workletプロセッサにバインドします。

プロセッサはモジュールに実装されており、後で見ていきます。

ステップ3：目的地を作成します。

ステップ4：ソースから宛先へのパスを接続します。

今回、MediaRecorderはAudioWorkletからの出力をソースとして取り、歪んだオーディオを記録します。

これはオーディオ処理モジュールです。

ここでDistortionProcessorクラスを実装します。

AudioWorkletProcessorクラスを拡張し、プロセス機能の実装を提供する必要があります。

入力はAudio Workletに入ってくるオーディオサンプルで、出力は処理後の結果のサンプルです。

異なるアルゴリズムを使用して出力を作成できます。

ここでは、distorted()と呼ばれるカスタム関数を使用して、入力に基づいて値を計算します。

プロセス関数はtrueを返します。つまり、プロセッサノードがアクティブです。

それがプロセス機能の基本的な構造です。

プロセッサクラスを作成した後、AudioWorkletNodeの構築に使用できるように、指定された名前でグローバルに登録する必要があります。

このようにして、オーディオデータに効果音を適用できます。

これまでのところ、オーディオデータの作成と処理について議論しました。

記録のために保存したり、他の場所に共有したりするのはどうですか？

ブラウザを終了した後、録画を失いたくないと思います。

今年のWeb Share APIのアップデートにより、それを行うのは非常に簡単です。

Web Shareは、WebKitとSafariでは新しいものではありません。

SafariでWebページでリンクを共有することを選択した場合、メッセージ、メール、AirDropなどの共有ターゲットを含む共有シートが表示されます。

システムスタイルによく一致する共有シートは、Web Share APIで作成されます。

今年は、ファイル共有のサポートを追加しました。

これは、このAPIで画像、ビデオ、オーディオ、またはその他の種類のファイルを共有できることを意味します。

ボイスメモに共有機能を追加しましょう。

[保存]ボックスがチェックされている場合、ボイスメモはキャプチャされたデータを含むオーディオファイルを作成し、ファイルを共有できるように共有ボタンを表示します。

ここでは、メモファイルをメールで共有したいです。

ワンクリックで、メモファイルが添付された素敵なドラフトが作成されます。

そして、コードを確認しましょう。

これは、MediaRecorderの例で見た停止イベントハンドラです。

まず、共有関数で使用できるように、停止イベントハンドラでブロブ変数をグローバルにしましょう。

共有機能は、共有ボタンのクリックイベントハンドラです。

Blobをファイルに変換し、ファイル名を与えます。

予想される入力タイプであるため、ファイルは配列に入れられます。

次に、APIが利用可能かどうか、およびファイルをcanShareメソッドで共有できるかどうかを確認します。

チェックが合格した場合、ファイル配列でnavigator.shareを呼び出します。

タイトルや説明テキストなど、指定できるオプションがあります。

ネイティブアプリのように、ウェブアプリがファイルを共有できるのと同じくらい簡単です。

まあ、実際にオーディオデータと対話したくないが、そのテキストが欲しいだけなら、例えば音声コマンドの場合、新しいAPIもあります。

それは音声認識です。

その名前が示唆されているように、音声認識APIはライブオーディオをキャプチャし、それをテキストに転写します。

また、トランスクリプトの確率と代替案も提供します。

Siriと同じ音声エンジンを使用し、複数の言語のサポートと優れた精度など、すべての利点が得られます。

つまり、APIを利用可能にするには、ユーザーがシステム環境設定または設定でSiriまたはディクテーションをオンにする必要があることを意味します。

認識はサーバーベースでできるため、認識サービスがアプリで初めて使用されるときにプライバシープロンプトを表示します。

ユーザーは、システム環境設定または設定で権限を変更できます。

さて、この新機能でボイスメモを更新しましょう。

認識ボックスがチェックされている場合は、録音のトランスクリプトを生成することを意味します。

これは私のボイスメモのトランスクリプトです。

期間。

そして、コードを確認しましょう。

使い方はメディアレコーダーに少し似ています。

ここには、startRecognitionとstopRecognitionの2つの主要な機能があります。

最初にwebkitSpeechRecognitionオブジェクトを作成する必要があります。

はい、互換性のために今のところWebKitプレフィックスを保持しているので、追加することを忘れないでください。

次に、停止するまで継続するように認識を要求する連続など、認識のいくつかのプロパティを設定できます。

私たちは結果と終了イベントに耳を傾けます。

認識オブジェクトを使用すると、startメソッドを呼び出して開始し、stopメソッドを呼び出して停止できます。

結果イベントでは、finalTranscriptを文字列に収集します。

ここでは、転写の選択肢は確率に基づいてソートされるため、結果の最初の項目のみを選択します。

認識が停止すると、カスタムログ機能を使用してトランスクリプトを画面に印刷します。

このように、わずか数行でウェブコンテンツに認識機能を追加できます。

それは長い旅であり、言及する価値があると思う最後のWeb APIが1つあります。

macOSとiOSでは、再生中ウィジェットがSafariでメディアの状態を表示できることに気付いたかもしれません。

便利ですが、通常はあまり情報が含まれていません。

たとえば、これはウェブページのタイトルのみを表示し、再生されているオーディオに関する情報はありません。

この状況を改善するのに役立つ新しいウェブAPIがあります。メディアセッションAPIです。

メディアセッションAPIを使用すると、Webページと他のプラットフォームコンポーネント間でメディアの状態を通信できます。

ユーザーが「再生中」ウィジェットのように、ウェブページの外でメディアの状態を表示または制御したい場合、これはあなたが知る必要があるAPIです。

メディアセッションAPIの詳細については、WWDCセッション「GroupActivitiesでウェブ上のメディア再生を調整する」をご覧ください。

そして、これらは私たちが探求したばかりの新機能です。

あなたがそれについて何かを学んだと感じることを願っています。

そして、今日の宿題は、これらの新しいAPIで独自のボイスメモを実装することです。

冗談ですが、WebKitとSafariで最高の開発体験をお届けするために、あなたができることがいくつかあります。

最新のWebKitとSafariの新機能を試して、bugs.webkit.orgでバグレポートを提出してください。

Safari Technology Previewを使用すると、アクティブな開発中の新機能や機能を垣間見ることができます。

WebKitやSafariで使用されるウェブ技術に興味がある場合、またはWebKitコミュニティへの参加に興味がある場合は、webkit.orgが良い情報源です。

WebKitに関する最新情報を入手したい場合、または私たちに質問がある場合は、私たちをフォローするか、Twitterでタグを付けることを忘れないでください。

このセッションをご覧いただきありがとうございます。WWDCで楽しい時間を過ごせますように！

♪