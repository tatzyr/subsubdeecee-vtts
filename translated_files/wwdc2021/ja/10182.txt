10182

♪ ♪

こんにちは。

私はクラウドファイルプロバイダーチームのヨハネス・フォートマンで、macOSのファイルプロバイダーをお見せするためにここにいます。

ユーザーのファイルをmacOSに同期するクラウドストレージベンダーなら、あなたは正しい話です。

紹介の後、ファイルの同期に関連するユーザーフローのいくつかについて説明します。

次に、Xcodeのフローの1つを実行し、それぞれのサポートを実装する順序について説明します。

追加のオプションの統合ポイントと次のステップの概要を簡単に説明します。

まず、ファイルプロバイダーがあなたのために何ができるかについて話しましょう。

ファイルプロバイダーフレームワークを使用すると、クラウドストレージをmacOSのファイルシステムに統合できます。

新しいAPFS機能を使用して、ユーザーファイルやフォルダのオンデマンドダウンロードを可能にします。

APIは完全にユーザースペースにあります。

macOSではカーネル拡張機能を廃止しているので、FUSEやKAUTHに頼ってシステムコールを傍受したり、オンデマンドでファイルをダウンロードしたりする場合、これはあなたにとって良い選択肢です。

あなたがしなければならないのは、アップロード、ダウンロードを処理し、リモートで何が変わったかを伝えることだけです。

システムは、ローカルで何が変更されたかを教えてくれ、残りのすべてを処理します。

この機能はすべて、システム、特にFinderとうまく統合されています。

プロバイダーがサイドバーに表示されます。

ファイルのステータスはFinderに表示され、追跡され、UIとのカスタマイズ可能な統合ポイントがいくつかあります。

システムと統合するアプリ拡張機能を実装します。

そのライフサイクルは、ユーザーの行動によって駆動されます。

最初は、ユーザーがクラウドストレージでアクセスできるファイルツリーを表すドメインを作成します。

システムは、Finderのサイドバーでそのドメインを公開し、ファイルシステム内のドメインのルートディレクトリを作成します。

この時点で、実際のデータはデバイス上にはありませんが、ユーザーはすでにルートとのやり取りを開始できます。

これはどのように機能しますか?

ルートは、私たちがデータレスディレクトリと呼ぶものです。

これはAPFSの新しい種類のオブジェクトであり、それらを認識して対話するためのAPIがあります。

しかし、さらに重要なことに、データレスオブジェクトは、準備ができていないプロセスに対して完全に透明です。

読み取りはダウンロードをトリガーし、ファイルは読み取りの再開が許可される前にデータレスプロパティを失います。

このプレゼンテーションでは、ファイルプロバイダーフレームワークを使用して、データレスファイルを読み取る処理時に呼び出されるコールバックを実装する方法を見ていきます。

同期して実行するために、いくつかのユーザーフローを見てみましょう。

同期ダウンと同期アップの両方をカバーする4つの重要なフローを見ていきます。

各フローでは、新しいデータが必要なときはいつでも、システムが拡張機能を呼び出していることがわかります。

クラウドサーバーと話をしてそのデータを取得し、最後に完了ハンドラーに電話して返信できることをお見せします。

まず、データレスファイルが読み込まれたときに何が起こるかを見ていきます。

カーネルがデータレスファイルへの読み取りアクセスを検出すると、拡張機能がファイルの内容を取得するために呼び出されている間、そのシステムコールは一時停止されます。

拡張機能のfetchContentsメソッドが呼び出されます。

通常、ダウンロードを実行するために実装します。

ダウンロードが完了すると、完了ハンドラが呼びます。

ファイルの内容は、開いているファイル記述子を無効にすることなく、以前のデータレスファイルを埋めるシステムに渡されます。

その後、システムは読み取りアクセスの一時停止を解除します。

ファイルがデータレスではなくなったので、その後の読み取りに拡張機能を含める必要はありません。

ディレクトリの列挙は非常によく似ています。

カーネルはreaddir呼び出しを検出して一時停止します。

拡張機能を呼び出して、そのディレクトリ内の項目を列挙します。

これらのアイテムのメタデータをサーバーから取得します。

そして、あなたはいくつかの項目で返信します。

列挙はページ分割されています。

アイテムの完全なセットよりも少ないものを返すことができ、システムは中断したところから列挙を再開します。

すべてのページが列挙されると、システムは元の呼び出しを通過できるようにします。

ファイルの場合と同様に、ディレクトリが列挙されると、後続のreaddir呼び出しはディスクの内容を使用し、拡張子を巻き込む必要はありません。

しかし、それらのコンテンツがリモートで変更された場合はどうなりますか?

さて、リモート変更をシステムに通知する必要があります。

それがどのように機能するかを見てみましょう。

リモート変更がある場合、サーバーはMacにプッシュ通知を送信できます。

そのプッシュ通知に応答して、特別な列挙子である.workingSetから列挙する必要がある変更があることをシステムに通知します。

システムは回転し、.workingSetで変更された項目を列挙します。

syncAnchorと呼ばれる継続トークンは、新しい変更のみを列挙するために使用されます。

このトークンは、あなたの拡張機能によって定義されます。

システムは、最後に列挙されたsyncAnchorを追跡します。

enumerateChanges(from syncAnchor:)メソッドで列挙子を呼び出します。

それに応じて、変更されたアイテムを返品し、完了したら、次回使用できる新しいsyncAnchorをお知らせください。

システムは非同期に移動し、ユーザーに表示されるファイルを更新します。

APFSの比較とスワップ機能を使用して、その過程でローカルの変更が失われないようにしています。

さらに、このシステムは、ファイル調整やその他のアドバイザリーロックメカニズムと統合して、アプリケーションと調整します。

これら3つのメカニズムを使用すると、クラウドからファイルを同期し、リモートでの変更が発生した場合に同期させることができます。

最後のフローは、ローカルの変更をクラウドに同期させることを扱います。

システムは、ローカルアイテムが変更されたときに検出し、拡張機能のmodifyItemメソッドを呼び出し、変更されたフィールドの正確なセットを渡します。

低レベルのイベントを、同期に意味のあるイベントに集約します。

たとえば、カーネルは安全な保存を検出し、アイテム識別子を新しいファイルIDに透過的に再マップします。

一貫したパッケージレベルの変更を要求して提示すると、システムもパッケージファイルを圧縮します。

modifyItem呼び出しに応答して、アイテムサーバー側の状態を更新します。

ファイルの内容が変更された場合、システムは変更されたファイルのクローンを手渡すので、さらに変更された場合でも一貫したバージョンをアップロードできます。

完了したら、完了ハンドラを呼び出します。

完了ハンドラは、アイテムのバージョン識別子を更新し、拡張機能への変更の配信を確認するために使用されます。

完了ハンドラは、アイテムの最終状態もパラメータとして取ります。

クラウド内のアイテムを更新すると、リモート変更と競合する場合など、状態が変更される可能性があります。

最終状態を元に戻すと、システムはクラウド内の真実と一致するようにアイテムのローカル状態を更新することができます。

5番目の流れがあります:立ち退き。

システムは、ディスク容量が緊急に必要になった場合、ファイルプロバイダの拡張子を関与させることなく、自動的にローカルファイルを追い出します。

これは、たとえば、ユーザーがビデオを録画したり、ソフトウェアアップデートをダウンロードしたりしているときに発生する可能性があります。

システムは、これらの新しいファイルを書き込むために必要なディスク容量を解放するために必要な、最近使用されていないファイルの最小セットを追い出します。

トランジションを見直しましょう。

立ち退きはローカルファイルをデータレスファイルに変え、ダウンロードはデータレスファイルをローカルファイルに変えます。

ファイルは、リモートで作成されている場合や、ローカルで作成されている場合は、データレスで開始できます。

しかし、すべてのファイルが追い出すことができるわけではありません。

システムは、アップロードされたものとして報告したファイルのみを追い出し、再度ダウンロードできるようにします。

したがって、ローカルファイルには、アップロードされたファイルとアップロードされていないファイルの2種類があります。

ローカル編集後、新しいバージョンのファイルをアップロードする必要があるため、追い出不能な状態に戻ります。

これまでのこのプレゼンテーションでは、アクセス時にファイルをダウンロードし、ローカル編集後にファイルをアップロードするために、ファイルプロバイダーの拡張子がシステムによってどのように呼び出されるかを見てきました。

ディスク圧力トリガーの立ち退きには関与していませんが、エクステンションからの立ち退きをトリガーまたは防止する方法があります。

これは多くの理論でした。

実際のフローの1つを見てみましょう。

私たちは、小さなローカルファイルサーバーを実行し、そのサーバーに対して動作するファイルプロバイダの拡張子を埋め込むアプリを書きました。

それはFruitBasketと呼ばれています。

私はすでにそのサーバーにログインしているので、サイドバーにルートフォルダのエントリがあります。

また、システムがそのフォルダ内のアイテムにデータレスエントリを作成する原因となったルートフォルダも選択しました。

ファイル名の横にあるクラウドダウンロードアイコンから、アイテムがデータレスであることがわかります。

コマンドラインで「cat」を使用してファイルを読み込みます。

ファイルがデータレスであるため、拡張機能でコンテンツがフェッチされます。

私はすでにXcodeの拡張機能に添付し、このコンテンツのフェッチを傍受するためのブレークポイントを設定しました。

「猫」が走っていて、私たちのブレークポイントがヒットしました。

コンテンツフェッチの完了をブロックしているため、ターミナルウィンドウの読み取りもブロックされます。

Finderウィンドウで、クラウドアイコンが進行状況インジケータに置き換えられたことに注意してください。

システムは、ダウンロードステータスの一貫したビューを持っています。

もちろん、実際にはダウンロード中ではなくデバッガでブロックされているため、進行状況は更新されません。

続けましょう。

完了ハンドラを呼び出す直前に2番目のブレークポイントを設定しました。

現時点では、プロバイダーはファイルの内容をディスク上のローカルURLにダウンロードしました。

完了ハンドラを呼び出すと、システムはユーザーに表示されるファイルの内容をダウンロードしたものと交換します。

Xcodeで続行して、システムのブロックを解除しましょう。

Finderのステータスは、ファイルをローカルとして表示するように更新され、catプロセスがブロックされたという読み取りが成功します。

ブレークポイントはまだ設定されていますが、ファイルがローカルになったので、ブレークポイントに当たらずに「cat」を再度実行できます。

これらの読み取りは、通常のローカルファイルに反しており、拡張子は含まれません。

もちろん、これはサンプルファイルプロバイダの機能セットのほんの一部にすぎません。

APIの全機能セットを取り上げ、このセッションの一環としてソースコードを公開しています。

私たちが話したフローの実装にどのようにアプローチできるかについて話しましょう。

まず、同期する準備ができていることをシステムに伝えたいと思います。 同期する

これにより、Finderのサイドバーにエントリが表示されます。

これらのエントリをドメインと呼び、通常はクラウドサーバーのログインセッションに対応します。

各ドメインには一意の識別子があり、それを表示するために、新しいインスタンスを作成し、マネージャーオブジェクトを介して追加します。

ドメインを削除することもできます。

通常、ユーザーがログアウトするときにこれを行いますが、最初の開発とテスト中にも役立ちます。

ドメインがFinderに表示されると、エントリに移動するとすぐに、システムはアイテムの列挙を要求します。

では、次にそれを実装しましょう。

ここでの最初のステップは、アイテムクラスを実装することです。

そのインスタンスは、列挙する個々のエントリを表します。

次に、システムが要求したときにアイテムでシステムを呼び出す列挙子を実装します。

この時点で、サイドバーのエントリに移動することでディレクトリを見ることができます。

もちろん、これらのディレクトリ内のすべてのファイルはデータレスになります。

コンテンツフェッチを実装して、それを変更しましょう。

fetchContentsメソッドは、データレスファイルの1つを開くと、システムによって呼び出されます。

私たちの仕事は、ファイルの内容をディスク上の場所にダウンロードし、その場所のURLで完了ハンドラを呼び出すことです。

システムは、コンテンツを使用してデータレスファイルを埋め、私たちのためにそれらをクリーンアップします。

ディレクトリ構造を同期させるために、別のタイプの列挙子を実装します。

これはリモートでの変更を同期します。

システムは、最初にcurrentSyncAnchorメソッドを呼び出して同期アンカーを取得します。

データベースの変更カーソルを記述するデータオブジェクトを返します。

何かが変更されたことを知らせるたびに、システムはあなたが提供した最後のアンカーから変更を要求します。

その後、変更を返し、最後に新しいアンカーを返すことができます。

最後のステップは、変更の同期を許可することです。

システムがローカルファイルへの変更を検出した場合、既存のアイテムを作成、変更、または削除するための3つの方法のいずれかを呼び出します。

作成方法を簡単に見てみます。

システムは、作成を依頼する新しいアイテムを手渡します。

これはシステムアイテムですが、自分のアイテムと同じプロトコルに従います。

システムはまた、アイテムに関心のある一連のフィールドを手渡します。

たとえば、アイテムには拡張属性が添付されているかどうかがあり、それを記述するフィールドがあります。

コンテンツフィールドが設定されている場合、システムはコンテンツを含むファイルURLを渡します。

フォルダやシンボリックリンクを記述するアイテムにはコンテンツがありません。

あなたの仕事は、新しいローカルアイテムのデータをサーバーにアップロードし、結果のリモートアイテムで完了ハンドラを呼び出すことです。

そして、それだけです。

この時点で、macOS上の機能的なファイルプロバイダーがオンデマンドでファイルを提供し、クラウドへのローカル変更とMacへのリモート変更を伝播します。

ファイルプロバイダーフレームワークには多くの追加のオプションAPIがあり、システムとのより細かい統合が可能です。

見てみましょう。 見てみましょう。

アイコンの装飾は、Finderでアイテムを視覚的に飾るために使用できます。

ファイルアイコンにバッジをつけたり、フォルダをエンボス加工したり、共有ステータスを表示したりできます。

アプリで宣言されたUTTypeを介して、装飾用のカスタムアートワークを提供します。

コンテキストメニューアクションを使用すると、ユーザーはコンテキストメニューを介してファイルに対してカスタムアクションを実行できます。

UIと非UIのバリエーションがあります。

拡張機能のInfo.plistで宣言されたNSPredicatesを使用して、これらのアクションが適用されるファイルを定義できます。

フライト前のアラートを使用すると、意図しない結果をもたらす可能性のあるアクションを実行する前にユーザーに警告することができます。

アラートUIとアラートをアクティブにする基準は、Info.plistでも設定されています。

それで、あなたの次のステップは何ですか?

さて、まず第一に、セッションのサンプルコードをダウンロードできます。

それは非常に包括的で、あなたに多くの指針を与えるでしょう。

新しい拡張機能の既存のアプリにターゲットを追加します。

起動するのに役立つXcodeテンプレートがあります。

そこから、あなたがしなければならないのは、私たちが議論した順序でメソッドスタブを実装することだけで、すぐに起動して実行できます。

このセッションをご覧いただきありがとうございます。

macOSでファイルプロバイダの拡張子を楽しみにしています。