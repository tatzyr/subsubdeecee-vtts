10211

♪ベース音楽の演奏♪

♪

アレハンドロ・ルセナ:皆さん、こんにちは。

象徴化に関するこのセッションにご参加いただきありがとうございます。

シンボリック化は曖昧な用語のように思えるかもしれませんが、バグ、クラッシュ、パフォーマンスのボトルネックの根本原因を迅速に特定するのに役立つ重要な役割がわかります。

私たちは、シンボリックがどのように機能するかについてより深い直感を得て、あなたが直接従うためにあなたが自由に使えるいくつかのツールをカバーします。

その過程で、豊富なシンボリック化体験に必要なデバッグ情報のさまざまなソースと、この情報を最大限に活用するようにアプリを設定する方法について説明します。

象徴的な具体的な定義と例に慣れることから始めましょう。

基本的に、シンボリック化は、デバイスが実行時にアプリをどのように見ているかを変換または翻訳するメカニズムです。これは、メモリアドレスと命令の観点から、開発者としての私たちがアプリをどのように見ているかに戻ります。これは、機能、名前、ファイルの観点からです。

このブリッジングレイヤーがなければ、数行のコードでもバグの診断が非常に複雑になります。

例として、このSwiftコードを考えてみましょう。

ここには、候補番号のリストから特定の番号を選択する関数 `generateMagicNumber()` があります。

これを行うには、まずランダムに生成された10個の数値の配列を返す`numberChoices()`を呼び出します。

次に、その配列を「selectMagicNumber(choices:)」に渡し、特定のインデックスで数値を返します。

これは合理的なプログラムのように思えますが、最初に実行したときにクラッシュに遭遇します。

私の最初の手段は、クラッシュログをチェックすることですが、これはかなり実りのないものです。

スレッドのバックトレースからわかるのは、私のMagicNumbersアプリがどこかでクラッシュしたということだけです。

ありがとう、でも私はすでにそれを知っていました。

レジスタが何を指しているのか、私にはわかりません。

デバッガでアプリをステップスルーしてクラッシュを特定しようとすることができますが、これが再現できない特定の状況でのみ発生する場合はどうなりますか?

その場合、デバッガを使用すると、必ずしも問題を特定するとは限りません。

または、分解を見てみることもできますが、物事を追跡することははるかに困難です。

これは明らかに問題を診断するための実行可能な方法ではなく、さらに重要なことに、シンボリック化の助けを借りて、この出発点からデバッグする必要はありません。

Xcodeオーガナイザーは、クラッシュログを再処理するこのアプリのdSYMをダウンロードできると教えてくれます。

そうすることで、Xcodeはシンボリック化の概念を適用して、はるかに素晴らしいクラッシュログで問題を診断できます。そこでは、すべての関数が実際に呼び出されているのを見ることができるだけでなく、コードで参照するファイルと行番号を決定することもできます。

この更新されたクラッシュログは、範囲外のインデックスにアクセスしようとしたことも教えてくれます。

あるいは、すでにdSYMを持っている場合は、「atos」コマンドを使用して同じ情報を取得できます。

私のコードを振り返ってみると、「MAGIC_CHOICE」は10要素配列の境界をはるかに超えていることに気づきました。

おっと。

別の例では、最速のユーザーエクスペリエンスを提供するためにアプリをプロファイリングすることに興味があります。

ここでは、インスツルメンツは、アプリが高利用率と低利用率の期間を循環することを示しています。

使用率の低い期間に焦点を当てると、Instrumentsはアプリがファイルにいくつかのコンテンツを書き込んでいたことを教えてくれます。

しかし、高い利用率の期間を検査すると、同じ正確なバックトレースが得られる。

これはどのように可能ですか?

これはまったく同じコードを実行していませんか?

ご覧のとおり、このインストゥルメントのトレースは部分的にしか象徴化されていません。

たとえば、更新されたクラッシュログで行ったように、バックトレースにファイル名や行番号が表示されません。

その結果、いくつかの情報が欠落しています。

それを念頭に置いて、私は同様に楽器で私のdSYMを見つけることができます。

これを行う後、私の新しいInstrumentsトレースは、高利用率領域が実際にファイルに書き込んでいたことを示していますが、それらは特に私がプログラムに残したデバッグコードパス内でした。

利用率の低い領域はこれを避け、私のアプリが本番でどのように振る舞うかを表しています。

XcodeがdSYMを利用してかなり情報のないクラッシュログを象徴化したように、InstrumentsもdSYMを使用して部分的に象徴化されたトレースを充実させ、パフォーマンスの問題の正確な原因を教えてくれました。

さて、これらのツールがシンボリックを利用して私のコードの問題領域を特定するのは素晴らしいことですが、自然にいくつかの疑問を投げかけます。

これはすべてどのように機能しますか?

他にどこでこれを適用できますか?

そして、これはすべてdSYMについてですか?

これらの質問に答え、シンボリックの機能のロックを解除するには、詳細を深く掘り下げる必要があります。

これは少し圧倒的に思えるかもしれませんが、これらは理解すべき重要な概念です。

シンボリックに基づいて構築されたデバッグとプロファイリングを支援する多くのツールがあります。

「atos」だけで、すでにクラッシュの正確な根本原因が示されており、Xcodeにはさらに多くのツールが組み込まれています。

さらに、`o`、`l`、`i`のようなフラグを`atos`に指定しましたが、それらはどういう意味ですか?

私たちはいつも同じ旗のセットを使いますか?

利用可能な値の1つがない場合はどうなりますか?

また、インスツルメンツのケースで見たように、バックトレースが完全に象徴化されていない可能性がある時期と理由、およびそれを修正する方法を理解する上で、良い基盤を得ることができます。

最後に、シンボリックの豊かさに影響を与える、あなたがコントロールできる多くのビルド設定があります。

これらのビルド設定を調べて、それらがどのように利用されているかについて確かな直感を持つようにします。

そのために、象徴化のための2段階のプロセスを紹介したいと思います。

ステップ1はファイルに戻り、ステップ2はデバッグ情報を参照することです。

ご覧のとおり、ファイルに戻ることは、ランタイムメモリアドレスをより安定した使用可能な形式に変換または変換することです。

これにより、デバッグ情報と通信して、生のメモリアドレスとソースコードの間に有意義な接続を行うことができます。

まず、ステップ1について話し合い、ファイルに戻りましょう。

このステップの究極の目標は、元のクラッシュログで見たようなランタイムメモリアドレスを、ディスク上のバイナリの対応するアドレスに変換することです。

ランタイムアドレスがあるように、アプリやフレームワークにもディスクにアドレス空間があります!

ディスク上のアドレス空間は、アプリが実行時に占有するアドレス空間とは異なり、それらの違いを把握するためのメカニズムが必要です。

まず、ディスク上のアドレスが何であるかを正確に理解する必要があります。

これらのアドレスは、アプリをビルドするときにリンカーによって割り当てられます。

具体的には、リンカーはバイナリをセグメントにグループ化します。

各セグメントには関連データが含まれており、名前、サイズ、割り当てられたアドレスなどのプロパティがあります。

たとえば、バイナリの `__TEXT` セグメントには、作成したすべての関数とメソッドが含まれており、`__DATA` セグメントには、グローバル変数などのプログラム全体の状態が含まれています。

これらのセグメントのそれぞれには、重複しないように異なるアドレスが割り当てられます。

リンカは、Mach-Oヘッダーの一部として、実行可能ファイルの冒頭にこの情報を記録します。

Mach-Oは、すべての実行可能なバイナリとライブラリに使用される形式であり、システムはアプリを実行するためにこのヘッダーを読み取る必要があることを知っています。

もう少しよく見ると、Mach-Oヘッダーには、セグメントプロパティを保持する多くのロードコマンドが含まれています。

システムは、これらのロードコマンドを使用してセグメントをメモリにロードします。

アプリがユニバーサル2の場合、アプリには各アーキテクチャに1つのヘッダーとセグメントのセットがあることに注意してください。

指定されたファイルのロードコマンドを出力する`otool -l`コマンドを使用することで、自分で見ることができます。

ここでは、「LC_SEGMENT_64」で識別されるセグメントロードコマンドを探しています。

このロードコマンドは、`__TEXT`セグメントが`vmaddr`のアドレスから始まり、`vmsize`バイトの長さであると言います。

したがって、カーネルがこれらのロードコマンドに従ってセグメントをメモリにロードする場合、ランタイムとリンカーアドレスの違いは何ですか?

さて、カーネルが実際にセグメントをロードする前に、ASLRスライドと呼ばれるランダムな値を初期化します。

その後、カーネルはロードコマンドのアドレスにASLRスライドを追加します。

したがって、アドレスAで`__TEXT`セグメントをロードし、アドレスBで`__DATA`セグメントをロードするのではなく、カーネルは代わりにそれらをA+SとB+Sにロードします。SはASLRスライドです。

A+SとB+Sはシステムが使用する真のアドレスであるため、ロードアドレスとも呼ばれます。

それを念頭に置いて、ランタイムアドレスとリンカーアドレスの違いはASLRスライドであることを知っています。

次の式でASLRスライドを計算できます。S = L-A、SはASLRスライド、Lはロードアドレス、Aはリンカアドレスです。

この方程式の例をまもなく見ますが、重要なポイントは、ASLRスライドを知ったら、いつでもファイルアドレス空間に戻ることができるということです。

ASLRスライド方程式には、ロードアドレスとリンカーアドレスの2つのアドレスが必要だったので、どこから入手できますか?

「Otool」を使用してリンカーアドレスを知るためにロードコマンドを照会する方法をすでに見ました。

ランタイムアドレスを知るために、システムはクラッシュの時点で、またはインスツルメンツによってプロファイリングされているランタイムアドレス空間についてアプリを照会します。

この情報は、クラッシュログのバイナリ画像リストに反映されます。

また、プログラム内のアクティブなメモリ領域を列挙する「vmmap」ツールを使用して、ロードアドレスをインタラクティブに表示することもできます。

元のクラッシュログからASLRスライド値を計算しましょう。

バイナリ画像リストには、`__TEXT`セグメントのロードアドレスがあります。

ロードコマンドを見たとき、ディスク上のバイナリのリンカーアドレスも持っています。

これら2つを差し引くと、ASLRスライド値は0x45c000になります。

これは、私のプログラムのランタイム`__TEXT`セグメント内のすべてのアドレスが、リンカ`__TEXT`セグメントアドレスから0x45c000バイト離れていることを意味します。

したがって、クラッシュログのバックトレースアドレスがファイルで何に対応するかを確認するには、そこから0x45c000を引いてディスク上のアドレスを取得できます。

このアドレスは現在、ディスク上のアドレス空間の一部であるため、アプリを調べて、そこに何があるかを確認できます。

クラッシュログは、このアドレスにあるものを実行中にスレッドがクラッシュしたことを教えてくれるので、再び「otool」を使用して問題のある命令を見ることができます。

今回は、分解を印刷する「otool」に「-tV」フラグを指定しました。

アーキテクチャもarm64として指定していることに注意してください。

これは、アプリがユニバーサル2として構築されているため、otoolがどのMach-Oヘッダーとセグメントを考慮するかを知るためです。

`otool`の出力は、アドレスで`brk`命令を明らかにする。

「Brk」は、アプリの例外または問題を示します。

「atos」などのツールも、一緒に経験したのと同じテクニックを使用してASLRスライドを計算します。

`atos`は、`-o`フラグで示されたファイルのロードコマンドを読み取り、`-l`フラグでロードアドレスについて伝えます。

前述したように、「vmmap」は、実行中のアプリのロードアドレスについても教えてくれます。

この計算をもう一度試してみましょうが、今回はバイナリ画像リストの代わりに「vmmap」を使用してASLRスライドを決定します。

MagicNumbersプログラムを再度実行し、プログラムがクラッシュする前に`__TEXT`セグメントロードアドレスを得ました。

以前の式を使用して、今回はASLRのスライド値が0x104d14000だったと判断できます。

繰り返しますが、ファイルに戻るには、ASLRスライドの値を差し引く必要があります。

新しいクラッシュログの一番上のエントリから0x104d14000を引くと、以前と同じ正確なファイルアドレスが表示されます。

そして、これは偶然ではありません。カーネルはちょうど別のASLR値を選んだので、クラッシュログ間でロードアドレスが変更されました。

ただし、クラッシュの原因となったファイルアドレスは引き続き特定できます。

ここでの重要なポイントは、ランタイムアドレスに関係なく、アプリが命令レベルまで何をしていたかを正確に理解するメカニズムがあるということです。

そして、そのマッピングにより、これらの命令にコンパイルされたソースコードのデバッグ情報を参照することができます。

先に進む前に、私たちがカバーした内容と使用したツールの概要を紹介したいと思います。

アプリバイナリとフレームワークはMach-Oファイルです。

これは、異なるセグメントに関連コンテンツがあることを意味します。

これらのセグメントはリンカーによって作成されます。

Mach-Oヘッダーロードコマンドは、アドレスを含むこれらのセグメントのプロパティを記述します。

`otool`と`-l`フラグを使用して、ロードコマンドを印刷しました。

次に、カーネルがリンカーアドレスにASLRスライドと呼ばれるランダムな値を追加することを学びました。

ASLRスライドとリンカーアドレスの追加は、ロードアドレスとして知られています。

クラッシュログのバイナリイメージリストをチェックして、クラッシュが発生した場合のロードアドレスを確認することも、「vmmap」を使用して実行中のアプリのロードアドレスを確認することもできます。

最後に、ファイルアドレス空間に戻るためにASLRスライドを計算するいくつかの例を見てきました。

これで、ファイルアドレスとソースコードの間の重要なリンクを含むデバッグ情報について話し合うことができます。

Xcodeは、アプリを構築するときにデバッグ情報を作成し、アプリバイナリに直接埋め込むか、dSYMなどの別のファイルとして保存します。

デバッグ情報にはいくつかのカテゴリまたは種類があります。

それぞれが、特定のファイルアドレスに対して異なるレベルの詳細を提供します。

今日は3種類のデバッグ情報を見ていきます。

まず、関数の開始について説明します。それ自体はあまり価値を付加しませんが、一般的な出発点です。

次に、関数名とメソッド名を追加するnlistシンボルテーブルが表示されます。

最後に、dSYMと静的ライブラリに由来するDWARFを見ていきます。

DWARFは、ファイル名、行番号、最適化レコードなど、最も詳細を追加します。

DWARFは最も詳細を提供するので、可能な限りこの種のデバッグ情報を持つように努力したいと考えています。

これらのそれぞれと、それらを使用して完全にシンボリック化されたクラッシュログを構築する方法について学びます。

関数の開始から始めましょう。

表で見たように、function startsは最小限のソースコードの詳細を提供します。

また、その名前に忠実に、このタイプのデバッグ情報は、関数の最初のアドレス（または文字通りの開始）についてのみ教えてくれます。

たとえば、これは、関数が特定のアドレスで始まり、存在することを教えてくれます。

ただし、どの関数がそれらのアドレスで始まるかは教えてくれず、それらが存在することだけです。

デバッグ情報を開始する関数は、アプリの`__LINKEDIT`セグメントのアドレスのリストをエンコードすることによってこれを行います。

これはアプリに直接埋め込まれているため、Mach-Oヘッダーには「LC_FUNCTION_STARTS」という場所を知らせるloadコマンドもあります。

`symbols`コマンドと`-onlyFuncStartsData`フラグで、これらを自分で見ることができます。

ここでは、アドレスとヌルプレースホルダのリストを取得します。

これらのプレースホルダは、ヌルではなく関数名とメソッド名を持つことが理想的ですが、関数の開始データは名前を提供しません。

繰り返しますが、これは最も説明的なデータではありません。

ただし、クラッシュログのわずかな更新が可能です。

ファイルアドレスを関数からのオフセットとして表示できるようになりました。

たとえば、まずASLRスライドの値を引いてファイルに戻ります。

次に、ファイルアドレスを含む可能性のある関数開始値を見つけます。

この場合、他のすべての値がアドレスよりも大きいため、最初の値のみがアドレスを含めることができます。

最後に、この関数では、ファイルアドレスが実際には264バイトであると主張することができます。

これは、この関数がどのように設定され、どのレジスタが変更されたかの詳細を理解できるため、デバッガにとって主に便利です。

しかし、これがあなたにとって意味することは、関数名のないクラッシュログに遭遇した場合、おそらくこの最低レベルのデバッグ情報を扱っているということです。

これは、より良いデバッグ情報でクラッシュログを充実させる機会がたくさんあることを意味するので、良いニュースです。

当然のことながら、私たちが見たい次のレベルの詳細は関数名です。

これにより、クラッシュログまたはインストゥルメントトレースを取得し、それを使用してソースコードの問題を追跡する最初の本当の機会が得られます。

これは、nlistシンボルテーブルにつながります。

シンボルテーブルは、関数開始のアイデアに基づいて構築され、「__LINKEDIT」セグメントの情報のリストをエンコードし、独自のロードコマンドもあります。

ただし、単にアドレスをエンコードするのではなく、C構造をエンコードします。

これにより、関数の開始と比較して、特定のエントリの詳細を追加できます。

具体的には、`nlist_64`構造体をエンコードします。

ここにその構造体の定義があります。

ざっと見ると、名前といくつかのプロパティにアクセスできることがわかります。

これらの構造体フィールドの値は、nlistの`n_type`によって決定されます。

私たちが興味を持っている主要なn_typeは3つありますが、今のところ2つだけに焦点を当てます。

1つ目は直接シンボルとして知られています。

これらは、アプリとフレームワーク内で完全に定義した機能とメソッドです。

直接記号には、`nlist_64`構造体に名前とアドレスがあります。

さらに、それらは「n_type」フィールドの特定のビットパターンで表されます。

具体的には、`n_type`には、2番目、3番目、4番目の最下位ビットが設定されます。

これらのビットは「N_SECT」とも呼ばれます。

これらは「nm」で表示され、「-defined-only」フラグと「--numeric-sort」フラグを指定できます。

ここでは、「nm」はMagicNumbersプログラムの定義されたシンボルを歩き、それらをアドレス順にリストしました。

私たちが戻ってきた名前は不可解に見えます。

なぜなら、シンボルテーブルに実際に保存されている名前は、めちゃくちゃな名前だからです。

これらのめちゃくちゃな名前は、コンパイラとリンカーが関数を一意に識別するのに役立ちますが、angledがない限り理解するのは簡単ではありません。

これらの名前のより親しみやすいバージョンを取得するために、出力を「swift-demangle」に渡しました。

これで、私のアプリで直接定義されているため、「main」や「numberChoices」など、おなじみの名前がいくつか得られます。

同様に、「シンボル」ツールには、nlistデータを表示するオプションがあり、名前を自動的にデangleします。

関数名をアドレスに関連付けることができるようになったので、クラッシュログをもう一度更新することができます。

ここでは、関数開始データから取得したオフセット式も直接記号からのエントリと一致し、そのエントリに名前があることがわかります。

これら2つをまとめると、クラッシュが264バイトで発生したと言えます。

メインが唯一の機能ではないという事実を知っているので、これはまだいくつかの詳細を望んでいます。

また、正確な行番号を持つことも役立ちます。

インスツルメントのトレースの例でこれに似たものに遭遇しました。いくつかの機能名がありましたが、他のものは見逃していました。

この理由の1つは、シンボルテーブルには、リンクに関与する関数の直接シンボルエントリしかないことです。

これらは、フレームワークからエクスポートするモジュールまたは関数間で使用する機能です。

これにより、APIの境界を特定するのに役立ちます。

また、`dlsym()`や`dladdr()`などの関数で動的ロードに電力を供給するために必要なデータがあることを意味します。

しかし、1つの欠点は、ローカルまたは静的関数がモジュールの外部で参照されないため、シンボルテーブルで表現されないことです。

これは、アプリのロジックのかなりの部分を持つ可能性のある実装機能を省略することになります。

さらに、リリースモードで構築されたバイナリは、シンボルテーブルが削除されるのが一般的です。

これは、不要なエントリがシンボルテーブルから削除されることを意味し、アプリのサイズを小さくするのに役立ちます。

考えてみると、アプリのプライマリドライバーがどこにでも機能をエクスポートすることはかなり珍しいので、これらのシンボルテーブルのエントリを維持するスペースを無駄にしています。

フレームワークとライブラリについては、クライアントが使用すべき機能を間違いなくエクスポートしていますが、他の場所では使用できないため、ローカルで共有された機能を保持する必要はありません。

プライマリアプリの実行可能ファイルを削除すると、ほとんどの場合、シンボルテーブルは実質的に空のままになります。

フレームワークとライブラリを削除すると、エクスポートされた機能だけが残ります。

Strip Linked Product、Strip Style、Strip Swift Symbolsなど、Xcodeのビルド設定に出くわしたかもしれません。

これらのビルド設定は、ビルド中にアプリがどのように削除されるかを制御します。

ストリップリンク製品が有効になっている場合、バイナリはストリップスタイルに従って削除されます。

たとえば、すべてのシンボルは最も侵襲的な除去を実行し、むき出しの必需品だけを残します。

Non Globalsは、アプリのさまざまなモジュール内で使用されているが、他のアプリで使用するためにエクスポートされない直接シンボルを削除します。

デバッグシンボルは、DWARFにたどり着いたときに後で説明する3番目のタイプのnlistタイプを削除します。

しかし、このストリップスタイルは直接記号を保持します。

たとえば、ここには2つのパブリックインターフェイスと1つの内部共有実装機能を定義するフレームワークがあります。

これらの機能はすべてリンクに役割を果たすため、すべて直接シンボルエントリがあります。

非グローバルを削除すると、インターフェイスだけが残ります。

共有実装機能は、私のフレームワーク内でのみ使用されたため、グローバルとは見なされません。

同様に、すべてのシンボルを剥がすことは、他のアプリがフレームワークを使用するために必要であるため、依然としてインターフェイスを離れます。

また、`symbols --onlyNListData`出力では、直接シンボルの間に点在する関数開始アドレスがあることに気付くことができます。

これらのアドレスは、直接記号になかった、または削除された機能を表します。

これらのストリップ設定は、シンボルテーブルの可視性の希望のレベルに合わせて調整できます。

この情報を使用して、いつダイレクトシンボルで作業しているかを判断できます。

これのいくつかの兆候は、関数名を持つが、行番号やファイル名がないことです。または、フレームワークの例でここに示すように、関数名と関数の開始アドレスが混在しています。

分析する2番目のタイプのnlist構造体は、直接記号とは対照的に、間接記号として知られています。

これは、`n_type`が`N_EXT`ビットパターンにのみ一致する場合です。

これらは、`print()`などの他のフレームワークやライブラリから使用している関数とメソッドです。

これらは「nm」で見ることができますが、今回は「--defined-only」ではなく「--undefined-only」を指定します。

また、関数がどのフレームワークまたはライブラリにあるべきかを示す「-m」フラグも追加します。

たとえば、MagicNumbersアプリは、libswiftCoreで定義されているさまざまなSwift関数に依存しています。

3つのデバッグ情報カテゴリのうち2つをカバーしたので、その特性を理解していることを確認しましょう。

関数の開始はアドレスのリストなので、名前がありませんが、オフセットを決定することができます。

Nlistシンボルテーブルは、情報の構造体全体をエンコードし、名前をアドレスに関連付けることができます。

それらは、アプリで定義されている直接シンボルと、依存関係によって提供される間接シンボルを記述します。

直接シンボルは通常、リンクに関連する機能のために予約されており、ストリップビルド設定は、利用可能な直接シンボルに影響します。

最後に、関数の開始とnlistシンボルテーブルの両方がアプリに直接埋め込まれます。

私たちがまだ見ていないのは、ファイル名や行番号など、より豊かなレベルの詳細です。

これはDWARFによって私たちに提供されています。

DWARFは、nlistシンボルテーブルの概念をまったく異なるレベルに引き上げます。

DWARFは、関数のサブセットのみを保持するのではなく、すべてを記述するよう努めています。

Nlistシンボルテーブルは、関数の開始と比較して、はるかに多くの情報を追加することがわかりました。

それは次元を追加することによってそれを達成しました。

関数の開始を見たとき、アドレスである単一の次元から始めたことを覚えておいてください。

次に、nlistシンボルテーブルに情報でいっぱいの構造体をエンコードして、2次元にアップグレードしました。

DWARFは、関係に関する3次元を追加します。

DWARFは、機能が分離されていないことを認識しています。

彼らは他の関数を呼び出し、パラメータを持ち、意味のあるデータを返し、特定のファイルで定義されます。

これらの関係をエンコードすると、シンボリックの最も強力な側面が解き放たされます。

DWARFを分析するときは、主にdSYMバンドルを参照しています。

plistsなどの他のメタデータに加えて、dSYMバンドルにはDWARFのバイナリが含まれています。

このバイナリが特別な理由は何ですか?

バイナリには、特別な「__DWARF」セグメントにデータが含まれています。

DWARF仕様は、私たちが焦点を当てるセグメント内の3つのデータストリームに言及しています。

`debug_info`には生データが含まれ、`debug_abbrev`はデータに構造を割り当て、`debug_line`にはファイル名と行番号が含まれています。

DWARFはまた、最初に勉強する2つの語彙タイプを定義します。コンパイルユニットとサブプログラムです。

3つ目は後で紹介します。

コンパイルユニットは、製品の構築に入った単一のソースファイルを表します。

たとえば、プロジェクト内のSwiftファイルごとに1つのコンパイルユニットを持つことが期待できます。

DWARFは、ファイルの名前、SDK、その機能が占める`__TEXT`セグメントの部分など、コンパイルユニットにプロパティを割り当てます。

Main.swiftコンパイルユニットには、左側の`debug_info`ストリームにこれらのプロパティが含まれており、右側の`debug _abbrev`ストリームに対応するエントリがあり、値が何を表しているかを示します。

ここでは、ファイル名、書かれている言語、および`__TEXT`セグメント範囲を表す低/高のペアが表示されます。

サブプログラムは、定義された関数を表します。

Nlistシンボルテーブルで定義された関数をすでに見ましたが、サブプログラムは静的およびローカル関数も記述できます。

サブプログラムには、名前とその「__TEXT」セグメントアドレス範囲もあります。

コンパイルユニットとサブプログラムの基本的な関係の1つは、サブプログラムがコンパイルユニットで定義されることです。

DWARFはこれを木で表しています。

コンパイルユニットはツリーのルートにあり、子としてサブプログラムエントリがあります。

子供たちは住所範囲に従うことで検索できます。

「Dwarfdump」コマンドを使用して、これらをより詳細に調べることができます。

まず、コンパイルユニットを見ていきます。

これは、先に述べたコンパイルユニットのプロパティの一部と一致します。

`dwarfdump`は、`debug_ info`と`debug _abbrev`の内容を組み合わせて、dSYMのデータの構造と内容を表示します。

そして、出力を下にスクロールすると、1つのサブプログラムの子に遭遇します。

それが占めるアドレス範囲はコンパイルユニットの範囲内であり、関数の名前も見ることができます。

私は、DWARFがそのデータを非常に詳細に説明していると述べました。

これらすべての詳細に多くの時間を費やすことはありませんが、関数パラメータなどの詳細を見るのは楽しいと思います。

彼らは、パラメータの名前とタイプを記述する独自の語彙タイプを持っています。

ツリーモデルに続いて、パラメータはサブプログラムの子です。

ここでは、関数に供給する選択肢パラメータのエントリに出くわします。

次に、ファイル名と行番号は「debug_line」ストリームから来ます。

このストリームにはツリー構造がありません。

代わりに、個々のファイルアドレスを正確なコード行にマッピングできるラインテーブルプログラムを定義します。

これにより、ファイルと行を見つけるために検索できるソースコードの詳細のリストが生成されます。

`debug_info`ツリーを解析して`debug_line`リストを生成すると、次のような構造になります。

したがって、ファイルアドレスを一致させたい場合は、ツリーを横断できます。

まず、コンパイルユニットから始めて、ブランチに従います。

次に、一致した「debug_line」エントリのいずれかをピックアップします。

「Atos」でこれを再び自動化できますが、今回は特に「-i」フラグを除外しています。

ここで少し奇妙なことに気づきましたか?

はい、私たちは関数名と行番号を持っているので、間違いなくDWARFを使用しています。

しかし、それ以外は、これはnlistシンボルテーブルの更新とあまり違いはありません。

実際、初めて「atos」を使用したときと比較すると、まだ多くの貴重な機能と詳細が欠けているように見えます!

ここで何があったの?

唯一変わったのは、今回は「-i」を「atos」に指定しなかったことです。

その旗は「インライン関数」の略です。

インライン化は、コンパイラが実行するルーチンの最適化です。

これには、関数呼び出しを関数の本体に直接置き換えることが含まれます。

それが持っている1つのクールな効果は、コードが一見消えるようにすることです。

`numberChoices()`を呼び出すのではなく、`numberChoices()`のコード全体が削除されたと考えることができます。

突然、`numberChoices()`への関数呼び出しがなくなりました!

DWARFはこれをインラインサブルーチンで表します。

これは、今日議論するDWARFの3番目で最後の語彙タイプです。

インライン化されたサブルーチンは、別のサブプログラムにインライン化されたサブプログラムであるため、関数です。

インライン関数は関係ツリー内の別のノードに完全に飲み込まれるため、インラインサブルーチンはそのノードの子です。

この定義は再帰的にも適用されます。つまり、インライン化されたサブルーチンは他のインライン化された子を持つことができます。

繰り返しますが、「dwarfdump」を使用すると、インライン化されたサブルーチンを探すことができます。

それらは他のノードの子としてリストされており、名前や住所などのサブプログラムと同様のプロパティを持っています。

ただし、DWARFでは、これらのプロパティは、抽象オリジンと呼ばれる共通のノードを介して頻繁にアクセスされます。

特定の関数のインラインコピーが多い場合、それらの共通の共有プロパティは、どこでも重複しないように、抽象的なオリジンに保持されます。

インラインサブルーチンが持つユニークなプロパティの1つは、コールサイトです。

これは、実際の関数呼び出しを書いたソースコードの場所ですが、オプティマイザがそれを置き換えました。

たとえば、main.swiftファイルの36行目で「generateANumber」を呼び出しました。

これにより、新しい子ノードでツリーを更新できます。

そして今、これは私たちのプログラムのはるかに包括的な見解のように見えます。

インライン関数の最適化の詳細は、完全にシンボリック化されたクラッシュログにたどり着くための重要な詳細でした。

「Atos」の「-i」フラグは、シンボリック化中にそれらを考慮するようにツールに指示します。

彼らはまた、私たちのインスツルメントトレースから欠けている詳細でした。

インスツルメンツとクラッシュログの両方でdSYMが必要な理由は、まさにこのすべてのコンテンツを抽出できるようにした。

DWARFを見つける別のソースがあり、それは静的ライブラリとオブジェクトファイルからのものです。

dSYMがない場合でも、静的ライブラリまたはオブジェクトファイルからリンクした関数のDWARFを収集できます。

そのような場合、デバッグシンボルnlistタイプがあります。

これらは、剥がすことができるシンボルタイプの1つでした。

しかし、彼らはDWARF自身を保持していません。

むしろ、彼らは関数を元のファイルに関連付けます。

ライブラリがデバッグ情報を使用して構築された場合、nlistエントリはそのDWARFを指し示すことができます。

これらのタイプのnlistエントリは、`dsymutil -dump-debug-map`で冗長に見ることができます。

ここには、さまざまな機能のリストと、それらがどこから引き出されたかがあります。

これらの場所は、DWARFのためにスキャンして処理することができます。

要約すると、DWARFは詳細なシンボリック化データの重要な情報源です。

DWARFは、関数とファイルの間の重要な関係を公開します。

関数インライン化などの最適化は、シンボリック化の品質に大きな影響を与え、DWARFはそれを非常によく表現できます。

また、dSYMと静的ライブラリにはDWARFが含まれていることもわかりました。

ただし、dSYMを他の人に簡単に転送でき、いくつかのツールからサポートが組み込まれているため、dSYMを優先してください。

最後に、象徴化を促進するために使用できるさまざまなツールやヒントを共有したいと思います。

ローカル開発ビルドの場合、デバッグモードでビルドすると、一般的に多くのデバッグ情報があります。

リリースモードでは、デバッグ情報フォーマットのビルド設定をチェックすることで、XcodeがdSYMを生成することを確認できます。

リリースがdSYMファイルでDWARFに設定されていることを確認してください。

App Storeに提出されたアプリについては、App Store ConnectからdSYMをダウンロードできます。

これには、ビットコードが有効になっているアプリも含まれます。

特定のdSYMがすでにデバイス上にあることを確認したい場合は、「mdfind」コマンドを使用できます。

ここでの英数字の文字列は、バイナリのUUIDであり、ロードコマンドで定義された一意の識別子です。

dSYMのUUIDは「シンボル-uuid」で確認できます。

ツールチェーンが無効なDWARFを生成することがあります。

これは「dwarfdump -verify」で確認できます。

報告されたエラーが表示された場合は、バグを提出してください!

DWARFデータには、バイナリごとに4ギガバイトの上限もあります。

dSYMで問題が発生し、4ギガバイトを超えていることが確認された場合は、それぞれが独自の小さなdSYMを持つように、プロジェクトを別々のコンポーネントに分割することを検討してください。

使用しているdSYMが、UUIDを比較することで、興味のあるアプリの特定のビルドと一致することを確認できます。

アプリのUUIDは、クラッシュレポートのバイナリ画像リストセクションにあり、「シンボル」コマンドでも見ることができます。

アプリとdSYMの両方が同じUUIDを持っていることを確認する必要があります。

「シンボル」ツールでは、アプリが利用可能なデバッグ情報の種類を確認することもできます。

私たちはすでにこの例を見てきましたが、角括弧内のこれらのタグが情報源を教えてくれることを思い出させるのに役立ちます。

どのデバッグ情報を扱っているのかわからない場合に便利です。 便利です。

dSYMが利用可能であることは確かですが、Instrumentsトレースで関数の名前を取得していない場合は、資格とコード署名を確認してください。

具体的には、「codesign」コマンドを使用すると、適切なコード署名があることを確認できます。

また、開発用にローカルに構築されたアプリに「get-task-allow」資格があることを確認する必要があります。

この資格は、インストゥルメントなどのツールにアプリをシンボリックする権限を付与します。

Xcodeは、プロファイルアクションでこのエンタイトルメントを自動的に設定する必要がありますが、確認すると便利です。

「get-task-allow」エンタイトルメントが有効になっていない場合は、Code Signing Inject Base Entitlementsのビルド設定を確認し、開発中に有効になっていることを確認する必要があります。

最後に、ユニバーサル2アプリの場合、興味のあるアーキテクチャをツールに指定する必要があります。

`symbols`、`otool`、および`dwarfdump`はすべて、特定のアーキテクチャスライスでのみ動作する`-arch`フラグを持っています。

これで「象徴化：基本を超えて」は終わります。

他に何もなければ、私は本当にいくつかの重要なポイントを強調したいと思います。

UUIDとファイルアドレスは、ASLRスライドから独立しているため、アプリが何をしていたかを識別するための一貫した信頼性の高い方法です。

また、デバッグ情報を照会するための鍵でもあります。

また、可能な限りdSYMを使用する必要があります。

dSYMには、DWARFの形で最も豊富なデバッグ情報が含まれており、XcodeとInstrumentsでサポートされています。

最後に、いくつかのツールを取り上げました。

これらのツールはXcodeですぐに利用でき、強力な診断と洞察を提供します。

デバッグと最適化のために、それらをワークフローに組み込むよう努めるべきです。

もっと知りたい場合は、WWDC18の次の2つのセッションをお勧めします。「アプリの起動時間の最適化」と「アプリの起動時間：過去、現在、未来」です。

象徴化について学ぶために私に参加してくれてありがとう!

素敵な一週間をお過ごしください。

♪