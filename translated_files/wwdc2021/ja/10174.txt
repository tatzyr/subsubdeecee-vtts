10174

こんにちは、WWDCへようこそ。

私はToriです。サーバーの新機能についてお話しし、すべてのアプリ内購入のステータスを追跡するために効果的なサーバーを実行するためのガイドラインを設定するのに役立つことにとても興奮しています。

では、すぐに飛び込みましょう。

このセッションは、アプリ内購入に焦点を当てた3つのセッションシリーズのパート2です。

「Meet StoreKit 2」または「顧客をサポートし、払い戻しを処理する」をまだ見ていない場合は、このセッションの後を見て、完全なストーリーを入手することをお勧めします。

このセッションでは、サーバーと、アプリ内購入を管理するためのサーバーを構築する方法に焦点を当てます。

このセッションを始めるために、まずサーバーを持つことが有用な理由のいくつかについて話しましょう。

サーバーを持つことはいくつかの理由で有用であり、アプリ内購入の場合、それらのほとんどは追跡ステータスを中心に展開します。

サーバーがある場合、App Storeサーバー通知を通じてアプリ内購入のステータスが変更されたときにリアルタイムで通知することができ、サーバーツーサーバーAPIを使用していつでもオンデマンドでステータスを確認できます。

サーバーを持つことで、デバイスがオフラインであっても、またはアプリの外でステータスが変更された場合でも、顧客のコンテンツへのアクセスを検証できるため、更新後も顧客がまだ購読しているかどうか、またはゲームで購入したコインが返金されているかどうかを知ることができます。

すでにサーバーをお持ちの場合は、これらの理由のいくつかでサーバーを設定している可能性があります。

サーバーを持っておらず、サーバーを構築することを考えている場合、これらはコンテンツをより詳細に制御できるため、考慮すべき強力な理由です。

あなたがサーバーを持っていても、私たちの物語はアプリ内購入でiPhone、iPad、またはその他のデバイスから始まります。

transactionId、originalTransactionId、領収書など、その購入に関する情報をサーバーに送信すると、当社のサーバーと直接通信することで、サーバーからその購入を追跡できるようになりました。

今日、これにはverifyReceiptのようなAPIやApp Storeサーバー通知のようなフレームワークの使用が含まれます。

私たちは、今日のコンテンツに私たちをもたらす、私たちのサーバーとの統合をさらに良くしたいだけです。

サーバー側で提供されるすべての変更と、これらと統合して、より良い、より強力なサーバーを構築する方法を確認します。

まず、App Storeの領収書でアクセスを検証し、App Store Server APIでステータスを追跡し、App Storeサーバーの通知でステータスを受動的に追跡する方法について説明します。

また、これが家族共有を管理するための意味と、サンドボックスでサーバーをテストする方法についても確認します。

領収書を使ってステータスの検証を始めましょう。

今日、私たちの領収書は統一されたアプリの領収書形式です。

領収書のJSONバージョンを取得するには、アプリでデバイス上の領収書検証を行うか、サーバーについて話しているので、サーバー間verifyReceiptエンドポイントを呼び出す必要があります。

サーバーツーサーバーを呼び出すと、このデコードされた領収書に加えて、最新の_receipt_infoセクションの新しいトランザクション、pending_renewal_infoセクションの今後の更新情報、および最新の領収書が取得されます。

この領収書は巨大になる可能性があり、非消耗品、消耗品、サブスクリプション、または非更新サブスクリプションなど、アプリ全体からのトランザクションが含まれています。

これはあなたにたくさんの情報を提供しますが、それが多すぎるのではないかと思います。

さらに、StoreKit 2では、JWS、またはJSON Web署名、クライアント側のフォーマットに新しい署名付きトランザクションを導入しており、サーバー上で同じものを提供したいと考えています。

なぜ私たちは署名された取引を導入することに決めたのですか?

アップルでは、セキュリティを重視しています。

JWSを使用してこれらのトランザクションに署名すると、署名と署名の検証を通じてセキュリティが強化されます。

さらに、トランザクションは簡単にデコードして検証できるため、電話することなくサーバーで実行できます。

今、これらの署名された取引を見てみましょう。

署名された取引は、ピリオドで区切られた3つの文字列で構成されています。

最初の文字列は、base64でエンコードされたJSONヘッダー、次にbase64でエンコードされたJSONペイロード、続いて署名です。

base64でヘッダーをデコードすると、使用した署名アルゴリズムとx5Cクレームが含まれています。

これには、署名を確認するために必要な証明書チェーンが含まれています。

すぐに署名の確認に戻ります。 もう少ししたら。

次に、base64でペイロードをデコードすると、レシートJSONが表示されます。

つまり、トランザクションをデコードするために必要なのは、base64がペイロードをデコードすることだけです。これは、サーバー上で自分で実行できる簡単な操作です。

デコードされたトランザクションを簡単に見てみましょう。

ちらっと見るだけで、一部のデータ型が以前のレシートの文字列から、数値やブール値などのより適切なデータ型に変更されていることに気付くかもしれません。

また、エポック以来、日付形式を1ミリ秒に減らしたことに注意してください。

また、いくつかの新しいフィールドを追加しました。

トランザクションが適用されるコンテンツタイプを示す「タイプ」というフィールドを追加しました。

「appAccountToken」というフィールドも追加しました。

StoreKit 2アプリで購入時にこの値をStoreKitに提供すると、サーバーに保持して各トランザクションで返します。

また、新しい署名された取引だけでなく、各取引の既存の統一されたアプリの領収書でもこれを返します。

ここで呼び出したい次の2つのフィールドは、実際には新しいものではなく、むしろ名前が変更されました。

これらのフィールドの存在が、失効日の時点でサービスを取り消す必要があることを示すことをより明確にするために、 cancellation_date と cancellation_reason と cancellation_reason を revocation_date と revocation_reason に変更しました。

これらの最後の2つのフィールドは新しく見えるかもしれませんが、実際には以前の領収書からのいくつかの情報の単純化です。

isTrialPeriod、isIntroOfferPeriod、promotionalOfferIdentifier、offerCodeRefNameを offerTypeとofferIdentifierに統合しました。

offerTypeは、顧客がこの期間に適用したオファーの種類を示します。1はイントロオファー、2はサブスクリプションオファー、3はオファーコードです。

オファータイプが2または3の場合、オファー識別子フィールドに、プロモーションオファーIDまたはofferCodeRefNameのいずれかの値も表示されます。

さて、署名されたトランザクション情報の署名部分の検証について話したいと思います。

署名を確認することは、取引がAppleから来ており、信頼できることを検証するためのオプションです。

トランザクションの内容のみを見たい場合は、この手順は必要ありません。

ただし、署名を確認するには、署名されたトランザクション情報のヘッダー部分で利用可能なクレームを使用する必要があります。

Algクレームを使用して、使用した署名アルゴリズムを知り、x5cクレームの配列の証明書チェーンを使用します。

これら2つを取得したら、お気に入りの暗号化ライブラリを使用して、署名されたトランザクション情報の署名を確認できます。

そのため、App Storeの領収書の変更、または私たちが今呼んでいるように、署名された取引をカバーしています。

では、APIでステータスを確認する方法に移りましょう。

したがって、署名されたトランザクションの有効性を確認したり、トランザクションをデコードしたりするために、今日のverifyReceiptのようなAPIは必要ありませんが、サーバー上で役立つAPIを構築したいと考えていました。

そのため、今年WWDCでApp Store Server APIの新しいライブラリを導入し、サーバーで以前は利用できなかった新機能を提供し、新しい署名されたトランザクションも利用します。

そこで、私たちは今、2つの真新しいAPIについて話します。サブスクリプションステータスAPIとアプリ内購入履歴APIです。

まず、サブスクリプションステータスAPIについて話したいと思います。

サブスクリプションステータスAPIは、アプリの元のTransactionIdで示される自動更新サブスクリプションの最新ステータスを提供します。

このAPIを使用すると、購読者のステータスに関する迅速な回答を得ることができます。

1回の簡単なチェックで、サブスクリプションがアクティブか、期限切れか、猶予期間か、その他の州かをすぐに知ることができます。

今、それを見てみましょう。"

このAPIへのリクエストは簡単で、URLにオリジナルのTransactionIdのみが必要です。

このAPIからの応答には、顧客がアプリで購読しているすべてのサブスクリプションのステータスが含まれており、subscriptionGroupIdentifierでグループ化されています。

subscriptionGroupIdentifierごとに、サブスクリプショングループ内の元のTransactionIdごとにエントリを含む最新のトランザクションのリストを提供します。

この配列の各エントリには、ステータス、originalTransactionId、signedTransactionInfo、およびsignedRenewalInfoが含まれており、これもJWS形式で署名されています。

今、そのステータスフィールドを詳しく見てみましょう。

ステータスフィールドは、サブスクリプションのステータスに関する迅速な回答を提供するので、購読者のサービスのロックを解除するかどうかを知ることができます。

ステータスの5つの可能な値から始めます。1は、サブスクリプションがアクティブであることを意味します。2は、サブスクリプションの有効期限が切れていることを意味します。3は、サブスクリプションが請求再試行期間にあることを意味します。4は、サブスクリプションが猶予期間にあることを意味します。5は、キャンセルまたはその他のイベントによりサブスクリプションアクセスが取り消されたことを意味します。

ステータスフィールドを見ると、サブスクリプションに関する簡単な回答が得られます。

そのステータスの詳細については、署名されたトランザクション情報のペイロードと署名された更新情報のペイロードを確認できます。

signedRenewalInfoをデコードするには、base64がペイロード部分をデコードすることで、署名されたトランザクション情報と同じ手順に従います。

ヘッダーを使用して、同じ方法でsignedRenewalInfoの署名をさらに検証できます。

デコードされると、このようなものが表示されます。

更新情報には、今日のverifyReceiptの保留中の更新情報セクションで提供しているのと同じフィールドが含まれており、日付形式を1つだけ含めたり、該当する場合はいくつかのフィールドをブール値または数値にしたりするなど、いくつかの更新が含まれています。

また、新しいフィールドofferTypeとofferIdentifierをsignedRenewalInfoに追加します。

これにより、お客様が次回の更新時にオファーを引き換える予定があるかどうかがわかります。

サブスクリプションステータスAPIに加えて、今日のverifyReceiptの最新の_receipt_infoセクションで提供しているように、アプリに関連するすべてのトランザクションを取得する方法を提供したいと考えています。

このため、アプリ内購入履歴APIも追加しています。

アプリ内購入履歴APIは、今日のverifyReceiptの最新の_receipt_infoセクションで受け取るのと同じように、アプリのすべてのトランザクションの履歴を提供します。

ここでの主な違いは、各トランザクションが新しい署名されたトランザクション情報形式になり、APIがページネーションされてApp Storeから受け取る応答のサイズを制御することです。

これに対する最初の要求は、サブスクリプションステータスAPIと同様に、非常に簡単です。

リクエストを処理するには、お客様からのオリジナルのTransactionIdのみが必要です。

応答では、アプリのApple IDやバンドルIDなどのアプリのメタデータと、新しい署名されたトランザクション情報形式でアプリの最新の20トランザクションの配列を受け取ります。

リクエストごとに20の署名済み取引情報を返します。

より多くのトランザクションがある場合は、応答のhasMoreとリビジョン値を見てください。

アプリにさらに多くのトランザクションが残っている場合、hasMoreは真実になります。

この場合、別のリクエストを行い、リビジョントークンをクエリパラメータとして渡し、次の20のトランザクションを取得します。

hasMoreがfalseになるまでこれを繰り返します。

では、ピボットして、すべてのApp Store Server APIが互いにどのように一致するかについて話しましょう。

それらはすべて、JWT（またはJSON Webトークン）の認証の背後にあり、新しい署名されたトランザクションをサポートし、JSON要求と応答形式を備えています。

そして何よりも、それらはすべて、リクエストで領収書と共有秘密を要求するのではなく、リクエストで提供した元のTransactionIdからキーオフします。

さて、私はJWT認証をカバーしたいと思います。

すべての新しいApp Store Server APIは、JSON Webトークン（JWT）認証を利用します。

私たちは、私たちのサーバーとあなたのサーバーの間の通信のセキュリティを高めるためにこれを選びました。

このJWTを生成するには、App Store Connectから秘密鍵をダウンロードする必要があります。

このプロセスでは、公開鍵がサーバーに自動的に登録されます。

その後、サーバーを呼び出す前に、ES256アルゴリズムを使用してトークンに署名する必要があります。

App Store Connectで秘密鍵を生成するには、[ユーザーとアクセス]ページに移動し、[キー]タブにアクセスしてください。

アプリ内購入キーオプションを選択すると、このようなページが表示されます。

キーを追加して名前を付けます。

一度しかダウンロードできないので、キーを安全な場所に保存し、キーIDをメモしてください。

さて、このJWTが実際にどのように見えるかを見てみましょう。

JWTは、ヘッダー、ペイロード、署名の3つの部分で構成されています。

ヘッダーには、秘密鍵のキーIDと署名に使用されるアルゴリズムを含める必要があります。

SHA 256ハッシュ、またはES256の楕円曲線シグネチャが必要です。

また、トークンの種類も含めます。この場合、常にJWTです。

ペイロードには発行者IDを含める必要があります。

この値はApp Store Connectで見つけることができます。

トークンが発行された時間と期限切れになる時刻を、エポックから秒単位で含めます。

この2つの時間の差は1時間以内でなければなりません。

常にappstoreconnect-v1であるオーディエンスを含めます。

ノンス、または1回限りの一意の文字列を生成する必要があります。

最後に、アプリのバンドル識別子を含める必要があります。

この情報をすべて入手したら、ES256アルゴリズムを使用してこのトークンの署名、またはSHA 256ハッシュを持つ楕円曲線シグネチャを実装する必要があります。

先に進む前に、App Store Server APIの重要なポイントを確認しましょう。

まず、これらは別々の機能であるため、ステータスの決定と取引の履歴の表示を分離しました。

次に、これらのAPIはリクエストの元のTransactionIdのみを必要とします。つまり、アプリまたはサーバーからの応答から受け取った署名されたトランザクションを取得し、元のTransactionIdを含む興味のあるフィールドを保存し、署名されたトランザクション情報を取り除くことができます。

過去に領収書で行うように案内してきたので、もう署名された取引を保存する必要はありません。

そのため、新しいApp Store Server APIで顧客のステータスを確認する方法について説明します。

さて、App Storeサーバーの通知を一貫性のあるものにする方法と、通知を使用してステータスを追跡する方法について説明します。

まず、App Storeサーバー通知の簡単なレビューから始めましょう。

私たちは数年前からApp Storeサーバーの通知について議論してきたので、なぜそれが役に立つのかを見直しましょう。

App Storeサーバー通知を使用すると、トランザクションのステータスがApp Storeから直接変更されたときに通知を受け取ることができます。

通知を受け取ったら、顧客が携帯電話でアプリを開くことなく、すぐにステータスを更新できます。

App Storeのサーバー通知では、ステータスについてお電話いただく必要もありません。

何かが変わったらお知らせします。

これらは、サーバーが利用できる最も強力なツールの1つです。

今年の目標は、新しい使いやすい署名付きトランザクションを利用して、App Storeサーバー通知をさらに強力にすることです。

これに加えて、1つのユーザーアクションに対して1つの通知のみが送信されるように通知を更新し、ペイロードを更新し、セキュリティを強化するためにJWSを使用してペイロード全体が署名されます。

また、準備ができたらv2通知にオプトインすることも許可し、しばらくの間、既存の通知を送信し続けます。

これは、v1通知の現在の通知です。

INITIAL_BUYからREVOKEまで、合計11のタイプがあります。

v2通知では、INITIAL_BUY、INTERACTIVE_RENEWAL、CANCEL、PRICE_INCREASE_CONSENTの4つの通知タイプを廃止します。

しかし、SUBSCRIBED、OFFER_REDEEMED、EXPIRED、GRACE_PERIOD_EXPIRED、PRICE_INCREASEの5つの新しいタイプを追加します。

新しい通知タイプに加えて、通知に「サブステート」という新しいフィールドを追加します。

これは、より一般的な通知タイプを特定のユーザーアクションに絞り込むのに役立ちます。

現在、サブステートは、SUBSCRIBED、DID_CHANGE_RENEWAL_STATUS、DID_CHANGE_RENEWAL_PREFERENCES、OFFER_REDEEMED、EXPIRED、PRICE_INCREASEの6つのv2通知タイプに適用されます。

サブステートがこれらの通知タイプにどのように適用されるかの例を見てみましょう。

まず、SUBSCRIBED通知とそのサブステートについて話したいと思います。

顧客が初めて購入すると、INITIAL_BUYのサブステートでSUBSCRIBEDを受け取ります。

顧客が同じSKUまたは別のSKUを再購読すると、サブスクリプションが同じサブスクリプショングループ内にある限り、RESUBSCRIBEのサブステートでSUBSCRIBEDを受け取ります。

V1 App Storeサーバー通知で同等のタイプを持たない新しい通知タイプの1つは、OFFER_REDEEMED通知です。

だから、この例を見てみたい。

OFFER_REDEEMEDは、顧客がプロモーションオファーを利用するたびに受信されます。

お客様が初回購入のオファーを引き換えると、INITIAL_BUYのサブステートでOFFER_REDEEMEDを受け取ります。

顧客が同じ非アクティブなサブスクリプションに再購読するオファーを引き換えると、RESUBSCRIBEのサブステートでOFFEET_REDEEMEDを受け取ります。

お客様がアクティブなサブスクリプションをアップグレードするオファーを利用すると、UPGRADEのサブステートでOFFEE OFFER_REDEEMEDが届きます。

お客様がアクティブなサブスクリプションをダウングレードするオファーを引き換えると、DOWNGRADEのサブステートでOFFER_REDEEMEDを受け取ります。

さらに、お客様が同じ期間内にキャンセルした後にアクティブなサブスクリプションに再購読するオファーを引き換えた場合、AUTO_RENEW_ENABLEDのサブステートでOFFEE OFFER_REDEEMEDを受け取ります。

では、EXPIREDを見てみましょう。

新しいEXPIRED通知タイプでは、顧客がVOLUNTARYのサブステートで自動更新を無効にした後、サブスクリプションの有効期限が切れると、EXPIREDを受け取ります。

請求の再試行期間が正常に回復せずに終了したため、サブスクリプションの有効期限が切れた場合、BILLING_RETRYのサブステートでEXPIREDを受け取ります。

さらに、顧客が値上げに同意していないためにサブスクリプションが期限切れになった場合、PRICE_INCREASEのサブステートでEXPIREDを受け取ります。

したがって、v2通知タイプと該当するサブステートを組み合わせることで、現在20以上の異なる顧客ライフサイクルイベントをカバーしています。

通知タイプを見るだけで、購入で何が変更されたかの一般的な把握を得るには十分ですが、より詳細に入りたい場合は、サブステートを見ると、より具体的な状態を取得するのに役立ちます。

では、新しいペイロードを簡単に見てみましょう。

V2通知の場合、通知の種類に関係なく、常に同じフィールドセットが含まれます。

通知タイプ、サブタイプ、v2通知を購読すると2になる通知バージョン、通知が適用される環境、バンドルID、アプリのApple ID、バンドルバージョンなどのアプリメタデータ、新しいsignedTransactionInfo形式の影響を受けるアプリ内の最新のトランザクション、新しいsignedRenewalInfo形式のアプリ内の最新の更新情報。

これらの変更により、通知の解析が容易になり、新しい署名されたトランザクションを利用し、影響を受けるアプリ内購入に関する情報のみが含まれているため、採用が容易になります。

先に述べたように、通知のセキュリティと信頼性を高めるために、ペイロード全体が署名されます。

先ほど見たペイロードは読みやすさのために署名されていませんが、署名はJWS形式でトランザクションと更新情報に署名する方法に似ています。

準備ができたら、v2通知にオプトインできるようにしてほしい。

このため、App Store Connectの通知URLにオプションを追加して、App Storeサーバーの通知バージョンを選択できるようにしています。

これを行うには、アプリのページに移動し、新しいApp Storeサーバー通知セクションまでスクロールします。

本番サーバーのURLを選択すると、バージョン1またはバージョン2のApp Storeサーバー通知を選択するオプションが表示されます。

これらの変更が今年後半に開始されると、バージョン2のApp Storeサーバー通知にオプトインできるようになります。

それでは、サブスクリプションの初回購入から始めて、新しいApp Storeサーバー通知を使用して、いくつかのシナリオの例をいくつか見たいと思います。

アプリでの初回サブスクリプション購入の場合、購入の結果として署名された取引情報を受け取ります。

アプリでこれを検証し、元のTransactionIdやその他の関連フィールドをサーバーに送信するか、署名されたトランザクション情報をサーバーに送信して検証し、その時点でデータベースに保存するフィールドを選択できます。

同じ頃、INITIAL_BUYのサブステートを含むSUBSCRIBED通知が届きます。

通知の署名されたトランザクション情報にアプリアカウントトークンが含まれているので、購入後にサーバーとアプリ間の通信が失われた場合でも、この通知をアプリ内ユーザーにすぐにリンクできます。

署名されたトランザクション情報を確認するためにサーバーに電話する必要はありません。

元のTransactionIdを送信して、ステータスまたはアプリ内購入履歴APIを確認したい場合は、いつでも当社のサーバーに電話することができます。

今、私はサブスクリプションの購入をカバーしました。

サブスクリプションの更新に移りましょう。

これで、このサブスクリプションの更新に達しました。

このサブスクリプションが正常に更新されると、DID_RENEWタイプの通知が届きます。

ペイロードで署名された取引情報と署名された更新情報を見て、サブスクリプションの次の更新日と、次の更新のための顧客の更新設定を確認できます。

また、サブスクリプションステータスAPIを呼び出すジョブをスケジュールして、フェイルオーバーメカニズムとして更新時にサブスクリプションのステータスを確認することもできます。

繰り返しになりますが、通知で受け取った取引を確認するために私たちに電話する必要はありません。

もちろん、自動更新は、特に請求の問題がある場合、常に計画通りに進むとは限りません。

だから今、私は猶予期間と請求の再試行をカバーしたいと思います。

それでは、サブスクリプションが期待どおりに更新されなかったとしましょう。

このような場合は、DID_FAIL_TO_RENEW通知で通知します。

猶予期間が有効になっていて、サブスクリプションが正常に更新せずに猶予期間を終了した場合、GRACE_PERIOD_EXPIRED通知が送信され、顧客が請求再試行期間に入ったことを知ることができます。

請求再試行期間中にサブスクリプションがまだ回復しない場合は、BILLING_RETRYのサブステージで期限切れの通知が送信されます。

猶予期間または請求再試行期間中にサブスクリプションの請求を回復した場合、DID_RECOVER通知をお送りします。

更新の結果に関係なく、署名された取引情報と署名された更新情報を含むv2通知で結果を通知します。

このプロセスの任意の時点でサブスクリプションステータスまたは履歴APIを呼び出すと、サブスクリプションステータスを再確認できます。

今、私たちは、顧客があなたのアプリで購入するものはサブスクリプションだけではないことを認識しています。

それでは、消耗品の初回購入時に何を期待するかをピボットしてカバーしましょう。

アプリの消耗品を初めて購入すると、購入の結果として署名された取引情報が届きます。

アプリでこれを検証し、元のTransactionIdやその他の関連フィールドをサーバーに送信するか、署名されたトランザクション情報をサーバーに送信して検証し、その時点でデータベースに保存するフィールドを選択できます。

後で必要になるかもしれないので、元のTransactionIdを常にメモしておいてください。

消耗品や非消耗品や非更新サブスクリプションなどの他のコンテンツタイプについては、顧客が払い戻しを要求しない限り、その購入のライフサイクルにわたってあまり変更はありません。

だから私は今、そのケースをカバーしたい。

さて、顧客が消耗品購入の払い戻しを要求したとします。

署名された取引情報に失効日と失効理由を記載した払い戻し通知をお送りします。

失効日以降に消耗品購入へのアクセスの提供を停止することを知ることができます。

いつでも消耗品購入のステータスを心配している場合は、アプリ内履歴APIを呼び出すことができ、応答でそれを探すことができます。

キャンセルされた消耗品は常に含まれるので、取引状況が変わったかどうかがわかります。

今、私は停電について話したいです。

最善の努力にもかかわらず、サーバーで停止が発生することがあります。

次に、サーバーが停止から回復するのを助ける方法について説明します。

サーバーで停止が発生し、App Storeサーバーの通知を見逃した場合は、その間に何が変更されたかを知りたいでしょう。

アプリ内履歴APIは、ここでのソリューションです。

各顧客のAPIを呼び出して、アプリからオリジナルのTransactionIdを提供するだけで、アプリの最新のトランザクション履歴を取得して、サーバーを更新できます。

その後、サブスクリプションステータスAPIを呼び出すと、各サブスクリプションの最新のサブスクリプションステータスを取得できます。

さて、最後のケースを取り上げたいと思います。サーバー上で署名されたトランザクションに移行します。

これは、アプリの前にサーバーを更新する準備ができている場合や、古いバージョンのアプリから統一されたアプリの領収書を受け取っている場合に特に重要です。

オリジナルのTransactionIdのみが必要なため、サーバー上の署名付きトランザクションへの移行は簡単です。

サーバーがアプリから受信した統一されたアプリレシートをJWSレシートに簡単に変換できるため、サーバーはApp StoreサーバーAPIやApp Storeサーバー通知と互換性があります。

これを行うには、まず統一されたアプリレシートでverifyReceiptを呼び出して、応答から一意のoriginalTransactionIdをすべて引き出します。

これらの元のTransactionIdの1つのアプリ内購入履歴APIを呼び出して、署名されたトランザクションのアプリの履歴を取得します。

次に、サブスクリプションoriginalTransactionIdのサブスクリプションステータスAPIを呼び出すと、すべての顧客サブスクリプションの署名付きトランザクションとsignedRenewalInformationを取得します。

署名されたトランザクションのペイロードから関連するデータを書き留めると、これらのAPIを引き続き使用し、v2 App Storeサーバー通知を受け取る準備が整います。

だから今、私はApp Storeサーバー通知に関するすべての変更と、通知を使用して顧客のステータスを確認する方法を取り上げました。

さて、サーバーからのアプリ内購入のファミリー共有の管理をさらに簡単にする方法について話したいと思います。

アプリ内購入のファミリー共有は、App Store Connectでそのアプリ内購入のファミリー共有を有効にしている場合、現在、自動更新サブスクリプションと非消費型購入でサポートされています。

現在、トランザクションが家族共有または購入であるかどうかを示すためにinAppOwnershipTypeというフィールドを提供し、家族向けの通知のサブセットをサポートしています：REVOKE、DID_RECOVER、およびDID_FAIL_TO_RENEW。

アプリ内の所有権タイプフィールドと既存のサポートされている通知タイプは、新しい署名済みトランザクションとApp Storeサーバー通知v2に残ります。

しかし、今年後半には、家族向けのApp Storeサーバー通知のサポートが追加されます。

v1通知には、DID_CHANGE_RENEWAL_STATUS、DID_CHANGE_RENEWAL_PREF、DID_RENEW、およびINTERACTIVE_RENEWALを追加します。

V2通知では、家族へのサポートをさらに追加しています。

DID_CHANGE_RENEWAL_STATUS、DID_CHANGE_RENEWAL_PREF、DID_RENEWに加えて、購入者と家族向けのSUBSCRIBED、EXPIRED、GRACE_PERIOD_EXPIRED、OFFER_REDEEMEDのサポートを追加しています。

これにより、App Storeサーバーの通知を通じて、購入者と家族の両方のすべての顧客のステータスを追跡することがさらに簡単になります。

そのため、今年の家族への通知の変更により、既存の家族共有機能と組み合わせることで、アプリ内購入の家族共有の管理がさらに簡単になるはずです。

さて、もう1つ締めくくりたいと思います。サンドボックスでサーバーをテストすることです。

私たちはあなたのアプリとサーバーに自信を持ってほしいです。

そのため、本番前にサンドボックスで新しいApp Store Server APIとApp Storeサーバー通知と統合できるようにしてほしい。

今日議論したApp Store Server APIについては、サンドボックスで完全にテスト可能であり、今からライブであることを意味します!

これには、サブスクリプションステータスAPIとアプリ内購入履歴APIが含まれます。

これに加えて、サンドボックスに他のいくつかの新機能を追加しています。

今年後半には、App Store Connectでサンドボックス固有の通知URLを追加できるようになります。

この追加により、プロダクションとサンドボックスの通知を完全に分離しておくことができます。

さらに、サンドボックス通知バージョンを選択することもできるので、生産前にサンドボックスでv2通知をテストすることができます。

昨年、トライアル資格のリセットやサンドボックスでのサブスクリプション管理ページの提供など、いくつかのエキサイティングなサンドボックスの改善をもたらしました。

サンドボックスでのテストを引き続き簡単にしたいので、今年はいくつかの新しい機能強化を追加する予定です。

これらは、サンドボックスApple IDの購入履歴の消去、サンドボックスアカウントの地域の変更、サンドボックスでのサブスクリプション更新率の調整です。

さらに、セキュリティ強化として、お客様がTestFlightユーザーではなくなったことが検出された場合、TestFlight領収書のverifyReceiptからエラーを返します。

これらの新しいサンドボックスの機能強化は、App Store Connectのサンドボックステスターページからアクセスできます。

購入履歴を消去するには、[編集]を選択し、テスターを切り替えて、[購入履歴を消去]ボタンを選択します。

テスターの購入履歴のクリアを確認すると、アクションを元に戻すことはできません。

だから、このオプションを選択したテスターを覚えておいてください。

購入履歴のクリアは、新しいアカウントを作成せずに何かを再度購入できる強力な新しいテストツールです。

また、テスト用の新鮮で空の領収書を持つこともできます。

アカウントの地域を変更したり、サブスクリプション更新率を調整したりするには、テスターページに戻り、テスターの行を選択します。

テスターの設定では、App Storeの地域を変更し、サブスクリプションの更新率を調整するための新しいオプションが表示されます。

目的の地域を選択することで、テスターのアカウント地域を変更できます。

これにより、サンドボックスの175のストアフロントでテストすることができ、すべて1つのテスターアカウントでテストできます。

最後の新しいサンドボックス機能は、サンドボックスでのサブスクリプション更新率を調整することです。

これを編集するには、ドロップダウンから希望の更新率を選択します。

現在、1か月はサンドボックスの5分と相関しています。

テスターの更新率を調整するためのオプションをいくつか提供します。

サブスクリプションの更新率を調整すると、サブスクリプションのキャンセル、アップグレード、ダウングレードなどの時間が増え、更新を迅速にスピードアップして長期的な顧客をシミュレートできます。

それが私たちが今年サンドボックスに来るすべてです。

これらの新機能でテストを気に入っていただければ幸いです。

だから、私たちは今日多くの新しい情報をカバーしました、そして今、私はあなたにそのすべてを探求できるようにしてほしいです。

新しいJWSの領収書を採用するために、アプリとサーバーを更新するのに時間がかかることを願っています。

新しいApp Store Server API、特に現在稼働しているサンドボックスで活用してください。

そして、まだ登録していない場合は、App Storeサーバー通知に登録し、今年後半に予定されているv2アップデートの準備をしてください。

私たちの新しいサンドボックスの強化も今年後半に来ます。

これらを活用して、サンドボックスのテスト体験を向上させてください。

最後に、このシリーズの今年の他の2つのセッション「Meet StoreKit 2」と「顧客をサポートし、払い戻しを処理する」をチェックしてください。

App Storeサーバー通知の背景とその設定方法については、WWDC 2020の「アプリ内購入の新機能」とWWDC 2019の「アプリ内購入とサーバー間通知の使用」をご覧ください。

当社の領収書、API、通知は、サーバーからアプリ内購入を管理するために必要な3つの強力なツールです。

これらを活用することで、サーバーとアプリをこれまで以上に強力にすることができます。

今日紹介したすべての新機能を活用してください。ご意見をお待ちしております。

今日は聞いてくれてありがとう、そしてWWDCの残りの部分を楽しんでください。

[明るい音楽]。