10192

♪ ♪

こんにちは！私はニコールです。「スウィフトの新機能」へようこそ。

Swift 5.5はこれまでで最高のリリースです!

Swift言語は、Swiftでの並行プログラミングを便利、効率的、安全にするために設計された非同期および並行プログラミングの新しいモデルであるSwift Concurrencyを含む多くの新機能により、急速なペースで進化し続けています。

さらに、パッケージエクスペリエンスの進歩、新しい標準ライブラリパッケージ、開発者エクスペリエンスを強化する機能のおかげで、Swiftでの開発がこれまで以上に簡単になりました。

これらの進歩と同じくらい重要ですが、Swiftプロジェクトの中心はコードではなく、Swiftプロジェクトの目標に向かって取り組んでいる人々のコミュニティです。

これが、ソフトウェアだけでなく、コミュニティにも投資することが重要である理由です。

重要なSwiftコミュニティイニシアチブについて話すことから始めたいと思います。

多様性はスウィフトコミュニティの中核的価値です。

研究は、多様なオープンソースプロジェクトがより生産的であり、より良い決定を下すことを示しています。

あらゆる背景と多様な視点を持つ人々を含めることは、コミュニティが繁栄するのに役立ちます。

私たちとSwiftコミュニティの他のメンバーは、Diversity in Swiftイニシアチブで、より幅広い開発者からSwiftエコシステムとコミュニティへの積極的な関与を奨励する機会を見ました。

SwiftのDiversityの使命は、さまざまな声を高め、開発者がバックグラウンドに関係なくSwiftの学習や貢献を始めやすくすることで、包括的なSwiftコミュニティを育成することです。

このイニシアチブの一環として、コミュニティ内の幅広い開発者からの貢献を認識し、強調する投稿を含むようにswift.orgブログを拡大しました。

また、開発者が同様の経験をしたり、同様の障壁に直面した可能性のある他の人とつながるためのコミュニティグループをSwiftフォーラムに作成しました。

スウィフトの多様性や詳細については、swift.org/diversityをご覧ください。

また、すでにコミュニティにいる開発者がSwiftで成長し、目標を達成できるよう支援したいと考えています。

Swiftオープンソースプロジェクトへの貢献をより親しみやすくするために、私たちは最近、新規参入者が定期的な貢献者から直接サポートと指導を受けるのを支援するSwiftメンターシッププログラムを発表しました。

このプログラムはAppleのプロジェクトに限定されるものではありません。

また、Swiftパッケージとオープンソースツールのエコシステム全体を網羅しています。

次に、パッケージについて話したいと思います。

パッケージは、ソフトウェアを構築するための基本的な構成要素であり、増え続けるオープンソースコードの配列を便利に活用することができます。

Swiftコミュニティのメンバーは、Swiftパッケージインデックスなど、開発者がパッケージを見つけるのに役立つ素晴らしいソリューションを考え出しました。

Swift Package Indexは、Swift Package Managerをサポートするパッケージを見つけるのに役立つコミュニティによって作成されたページです。

現在、Swift 5.5とXcode 13では、統合Xcodeツールサポートを提供し、開発ワークフローの一部としてプロジェクト内のパッケージをより迅速かつ簡単に使用できるようにすることで、パッケージを見つけてアクセスするための追加の方法を提供しています。

今年は、コマンドラインとXcode 13の両方から使用できるSwiftパッケージのキュレーションリストであるSwiftパッケージコレクションを紹介します。

パッケージコレクションを使用すると、インターネット上でパッケージを検索したり、URLをコピー&ペーストして追加したりする必要はありません。

Xcodeの新しいパッケージ検索画面からコレクションを閲覧し、パッケージを追加できるようになりました。

パッケージコレクションは、どこにでも公開できるシンプルなJSONファイルです。

パッケージコレクションは、誰もがさまざまなユースケースのパッケージのキュレーションされたリストを作成できるようにすることを目的としています。

たとえば、コンピュータサイエンスクラスのインストラクターは、そのクラスの概念を教えるのに役立つパッケージのセットをまとめることができます。または、誰かが特定のドメインやタスクに適したパッケージ、または組織で使用されるパッケージのコレクションをまとめることができます。

私たちは、人々がコレクションを使用するさまざまな方法を見ることに興奮しています。

パッケージコレクションに関する素晴らしいプレゼンテーションがありますので、詳細を確認することをお勧めします。

パッケージコレクションには、Xcodeの強力なツールサポートが含まれています。

あなたは今、お気に入りのAPIの使用からちょうどインポートです。

見つからないモジュールをインポートしようとすると、Xcodeは、設定したパッケージコレクション内のパッケージのいずれかがそのモジュールを提供しているかどうかを確認し、そのパッケージを自動的に使用を開始する機会を提供します。

パッケージの使用を選択すると、パッケージコレクションの情報に基づいてすべての設定が処理されます。

パッケージコレクションも検索可能で、ユースケースに合ったパッケージを簡単に見つけることができます。

今日パッケージコレクションを試すことに興味があるなら、AppleがGitHubで公開しているSwiftパッケージのパッケージコレクションなど、すでに利用可能なものがいくつかあります。

Xcodeは、Appleコレクションを使用するために事前に配線されています。

コミュニティからすでに入手可能なコレクションを含むパッケージコレクションの詳細については、パッケージコレクションに関する新しいswift.orgのブログ記事をご覧ください。

お気に入りのAPIといえば、AppleはオープンソースのSwiftパッケージのファミリーを増やしています。

お気に入りのパッケージの大きな機能強化に加えて、今年はさらに4つの新しいパッケージを発売しました。

まず、スウィフトコレクションについてお話ししたいと思います。

Swift Collectionsは、Swift Standard Libraryで利用可能なものを補完するデータ構造の新しいオープンソースパッケージです。

Swift Collectionsの初期バージョンには、最も頻繁に要求される3つのデータ構造の実装が付属しています：Deque、OrderedSet、およびOrderedDictionary。

Dequeは、両端で効率的な挿入と削除をサポートすることを除いて、配列のようなものです。

OrderedSetは、配列とセットの強力なハイブリッドです。

Arrayと同様に、OrderedSetは要素を順番に維持し、ランダムアクセスをサポートします。

セットと同様に、OrderedSetは各要素が一度だけ表示されるようにし、効率的なメンバーシップテストを提供します。

そして最後はOrderedDictionaryです。これは、順序が重要な場合、または要素へのランダムなアクセスが必要な場合、辞書の便利な代替手段です。

次に、スウィフトアルゴリズムについて話しましょう。

Swift Algorithmsは、シーケンスとコレクションアルゴリズムの新しいオープンソースパッケージです。

要素のコレクションのすべての組み合わせまたは順列を生成したり、シーケンスの要素を2つまたは3つまたは述語によって決定されたグループで反復したり、コレクション内の5つの最小要素、最大の5つ、または任意の5つをランダムに選択するなど、すでに40以上のアルゴリズムをSwiftアルゴリズムに追加しました。

語彙を学ぶには少しの投資が必要ですが、一度そうすると、どれだけのアルゴリズムが目の前に隠れているかを発見するのは印象的です。

詳細を知りたい場合は、新しいSwiftアルゴリズムとコレクションパッケージがコードをより明確に、より速く、より正確にするのにどのように役立つかを説明するセッションがあります。

では、スウィフトシステムについて話しましょう。

昨年の秋、私たちはシステムコールに慣用的で低レベルのインターフェイスを提供するライブラリであるSwift Systemをオープンソース化しました。

システムは、Appleプラットフォーム、Linux、さらにはWindowsでも利用できます。

最近、一般的なパス操作操作を実行するために、システムのFilePathタイプに強力な新しいAPIを追加しました。

これらには、拡張機能を照会または設定し、コンポーネントを追加および削除し、パス正規化を実行する機能が含まれます。

パスは、そのルートとその相対的な構成要素に分解することができます。

FilePathのComponentViewは、構造化されたパスコンポーネントのコレクションです。つまり、箱から出してすぐにSwiftの一般的なアルゴリズムの多くをサポートしています。

また、Windowsをターゲットにする場合、複雑なルートコンポーネントを持つWindowsパスは、すべての新しいFilePath APIで完全にサポートされています。

次に、Swift Numericsについて話しましょう。

Swift Numericsは今年、多くの大きな追加を受けました。

昨年、Float16をiOS、tvOS、watchOSに導入しました。

今年は、Apple Silicon MacにFloat16のサポートと、Float16ベースの複素数を作成する機能を追加しました。

今年のもう1つの追加は、対数、正弦、コサインなどのすべての基本関数の複素数サポートです。

これらの実装はSwiftで書かれているため、従来のCライブラリよりも効率的であり、他の方法では不可能な最適化が可能です。

最後に、Swift ArgumentParserについて話しましょう。

今年は、Fishシェルのコード補完スクリプトの生成、短いオプションの参加、エラーメッセージの改善など、Swift ArgumentParserの改良を続けました。

また、この春、ArgumentParserがXcode 12.5のSwift Package Managerに採用された重要なマイルストーンを通過しました。

そうです！

最近Swift Package Managerのコマンドラインツールを使用した場合は、Swift ArgumentParserを使用しました。

次に、サーバー開発でSwiftをサポートするために行ったいくつかの作業について話したいと思います。

昨年、Amazon Linuxを含む多くのプラットフォームのサポートを追加しました。

今年は、Swiftサーバーアプリケーションのパフォーマンスと機能に投資することで、その作業をフォローアップしました。

Linuxで静的リンクを有効にすることから始めました。これにより、アプリケーションの起動時間が改善され、サーバーアプリケーションの展開が簡素化され、単一のファイルとして展開できるようになりました。

また、Swift 5.5では、Linuxで使用されるJSONエンコーディングとデコードがゼロから再実装され、最も一般的なユースケースのパフォーマンスが向上しました。

最後に、AWS Lambdaランタイムライブラリ自体のパフォーマンスを強化および最適化しました。

これらすべての作業により、AWS Lambdaで実行されているSwiftプログラムの起動速度が33%速くなり、AWS APIゲートウェイを介してルーティングされたラムダの呼び出し時間が40%速くなりました。

AWSランタイムライブラリのパフォーマンスを最適化することに加えて、クロージャの代わりに新しい非同期/待機モデルを使用するようにリファクタリングしました。

Swift開発者体験の向上は、Swift 5.5のもう1つの重要な焦点です。

ドキュメントについて話すことから始めたいと思います。

優れたドキュメントを提供することは、フレームワークのユーザーにスムーズで楽しい体験を提供するための鍵です。

今年は、開発者にSwiftフレームワークやパッケージの使い方を教えるために、Xcode 13に深く統合されたドキュメントコンパイラであるDocCを導入します。

素晴らしいドキュメントを作成して共有することがこれまで以上に簡単になりました。

DocCは、Swiftソースコードのマークダウンコメントなど、すでに知っていて愛しているツールやテクノロジーを使用してゼロから構築されているため、ドキュメントを簡単に作成したり差分したりできます。

XcodeでDocCドキュメントのあらゆる側面を紹介する4つの素晴らしいセッションがあります。

それらをチェックすることを強くお勧めします。

そして今、Swift DocCが今年後半にオープンソース化されることを発表できることを嬉しく思います。

オープンソースのSwift DocCにより、開発者はSwiftでサポートされているすべてのプラットフォームで優れたドキュメントをより簡単に生成できます。

Swift 5.5では、タイプチェッカーの品質とパフォーマンスの向上に投資しました。

この結果の1つは、コードをコンパイルするときに「表現が複雑すぎる」エラーが少なくなるということです。

また、配列リテラルの型チェックのパフォーマンスも高速化しました。

このリリースでは、増分ビルドをスピードアップするための3つの大きな改善により、開発者の生産性も向上しています。

まず、増分インポートをサポートするようになりました。つまり、そのモジュールが変更されたときにモジュールをインポートするすべてのソースファイルを再構築しなくなりました。

さらに、モジュールの依存関係グラフを事前に計算して、変更されたもののみの増分ビルドをすばやく開始できるようになりました。

最後に、拡張機能で動作するように選択的な再コンパイルを拡張しました。つまり、拡張機能の本体を変更すると再コンパイルが少なくなります。

SwiftDriverオープンソースプロジェクトを例として、平均して、Swift 5.5の増分インポートでは、インポートされたモジュールが変更されたときに10分の1未満のファイルを再コンパイルし、ビルド時間が約3分の1短縮されます。

増分インポートによるパフォーマンスの向上は、プロジェクトをモジュール化し、ビルドパフォーマンスに大きなペナルティを与えることなく、インポートされたモジュールを変更できることを意味します。

ところで、これらのパフォーマンスの向上のいくつかは、Swiftで記述されるコンパイラの最初の部分であるSwiftプロジェクトの重要なマイルストーンによって可能になりました。

これは、Swiftソースコードのコンパイルを調整するプログラムであるSwift Driverです。

このプロジェクトは2019年後半に開始され、Xcode 13の時点で、現在はSwiftコンパイルのデフォルトです。

最後に、Swiftプログラムがより迅速にメモリを取り戻すために、Swiftのメモリ管理をより効率的にするために行った改善について話しましょう。

Swiftクラスインスタンスは、自動参照カウント、ARCを使用して、特定の時点で特定のオブジェクトへの参照の数を追跡します。

ほとんどの場合、これはメモリ管理がSwiftで動作することを意味し、自分でメモリ管理について考える必要はありません。

ARCは、これらのインスタンスが不要になったときに、クラスインスタンスで使用されるメモリを自動的に解放します。

これを行うには、Swiftコンパイラは、新しい参照が作成されるたびに保持操作を挿入し、新しい参照が使用を停止するたびにリリース操作を挿入します。

今年は、コンパイラが保持およびリリース操作の数を大幅に削減できるように、コンパイラ内の参照を追跡する新しい方法を導入しました。

この変更により、測定可能なパフォーマンスとコードサイズの改善が見られました。

Xcodeの設定「Optimize Object Lifetimes」を追加しました。これにより、この新しい、より積極的なARC最適化のコードへの影響を確認できます。

ARCの詳細については、「ARC in Swift」セッションをご覧ください。

これらは、Swift 5.5によってもたらされた改善点のほんの一部です。

次に、ティムはSwiftの並行性やSwift言語のその他の進化について話します。

ありがとう、ニコール。

私たちは皆、Swift Concurrencyに非常に興奮していますが、その前に、日常のプログラミングを簡素化および改善するためにSwiftに加えた他の多くの変更について話し合いたいと思います。

これが私たちが今年行った人間工学的な改善のリストです。

SE番号は、Swift Evolutionの提案を特定します。

これらの提案のそれぞれは、コミュニティのメンバーによって書かれ、Swift Evolutionフォーラムで議論され、言語に受け入れられる前にSwiftコアチームによって承認されました。

すべてのSE提案は、受け入れられるか、拒否されるか、まだ議論中かにかかわらず、GitHubのSwift Evolutionリポジトリで見つけることができます。

これらの変更のいくつかを見てみましょう。 いくつか見てみましょう。

まず、結果ビルダー。

SwiftUIが最初に発表されたとき、複雑なオブジェクト階層をすばやく簡単に記述するために使用できる新しい構文を導入しました。

昨年、その構文はSwift Evolutionプロセスを通じて標準化され、洗練され、さまざまなコンテキストでより簡単に使用できるようになりました。

この強力な技術を利用したい場合は、特にResult Buildersの使用に特化したセッションがあります。

Codableプロトコルは、データをシリアライズする便利な方法ですが、長い間顕著な省略に苦しんできました。

この2つのケースの列挙型を考えてみましょう。

Codableに準拠するためには、以前はこのすべてのボイラープレートを手動で実装する必要ができていました。

今、あなたはCodable適合性を宣言する必要があり、コンパイラはあなたのためにそのすべての作業を行います。

また、Swiftのタイプチェッカーにいくつかの重要な改善を行いました。

ご存知のように、Swiftの型推論は、冗長な型情報を省略できることを意味します。

ここでは、Coffee.regularをjust .regularに短縮できます。

しかし、列挙型のような構造も他の方法で表現されます。

たとえば、プロトコルに準拠したタイプのコレクションがあり、APIでそれらのタイプのインスタンスを使用したい場合があります。

プロトコルでいくつかの静的プロパティを宣言することで、Enumsに使用するのと同じドット表記を使用して、これらのタイプのインスタンスを参照できるようになりました。

これは、ここで.largeなどのチェーンプロパティ参照を含む、一般的なコンテキストの静的プロパティについてより一般的に推論できるSwiftの型チェッカーの改善によって有効になります。

これにより、ライブラリ作成者は、自然で使いやすいEnumのようなAPIを使用して、洗練された汎用データモデルを構築できます。

今年はプロパティラッパーも改善されました。

プロパティラッパーは、プロパティに共通のセマンティクスを適用するための便利なツールです。

あなた方の多くは、構造体に@propertyWrapperアノテーションを使用して、独自のプロパティラッパーを実装しています。

以下は、プロパティが空ではないという要件を追加する例です。

SE-0293の実装により、これらの同じプロパティラッパーを関数およびクロージャパラメータに使用できるようになりました。

累積的に、言語へのこれらおよびその他の変更は、多くの一般的なコーディング問題を簡素化することができます。

簡単なSwiftUIコードサンプルの文脈でそれらを一緒に見てみましょう。

これは、設定の配列を保持する単一のプロパティと、それらの設定のリストを表示するボディを持つSwiftUIビューで、それぞれの横にトグルがあります。

このコードを確認して、新しいSwift 5.5の機能がどのようにそれを簡素化できるかを見てみましょう。

まず、その Toggle() 初期化子は明らかに複製されます。

この重複は以前は必要でしたが、#ifの使用を緩和して、ここのtoggleStyle修飾子などの接尾辞式をサラウンドできるようにしました。これにより、その冗長性を考慮することができます。

SwiftUIは、先ほど述べた新しいタイプチェッカーの改善を利用するためにも更新されました。

そのため、より多くの場所で自然なドット表記を使用できます。

設定配列にインデックスを指定し、クロージャ内の配列をインデックスするのは少し厄介です。

私たちはむしろ価値観をステップスルーしたい。

これで、投影されたバインディングをリストコンストラクタに直接渡すことができ、配列値を反復することができます。

プロパティラッパー引数の新しいサポートにより、クロージャ引数をドル記号で書くことができ、クロージャでバインドされた設定が得られます。

これにより、ラップされた値とバインディングの両方にアクセスできます。

そして最後に、SwiftコンパイラはCGFloatとDoubleの間で透過的に変換されるようになり、AppleプラットフォームAPIを使用する際に多くの冗長な数値変換を排除することができます。

ご覧のとおり、コア言語を洗練するための継続的な努力は、あなたが毎日書くコードをこれまで以上にシンプルにし、図書館の作者が豊かで使いやすいAPIを構築する機会を増やしています。

SwiftUIプログラミングが今年改善された多くの方法の詳細については、「SwiftUIの新機能」セッションをご覧ください。

もちろん、Swift 5.5のハイライトは、非同期および同時プログラミングをサポートする一連の連動機能です。

これらをすぐに紹介しますが、まず、「非同期」と「並行」の意味を簡単に説明しましょう。

ソフトウェアプロジェクトは、何らかの順序で実行されるコードブロックで構成されています。

最も単純なケースでは、これらのブロックは単純な順序で次々に実行されます。

しかし、他の構造も一般的です。

たとえば、ネットワークAPIは、多くの場合、非同期スタイルで設計されています。

これらのAPIでは、リモートサーバーにリクエストを送信した後、応答を受け取り、より多くの作業が必要になるまで長い遅延が生じる可能性があります。

理想的には、この遅延中にコードが一時停止されるため、応答に基づいて行動できるまでリソースを使用しません。

対照的に、同時コードは、同時に実行したい2つ以上のコードブロックがある場合です。

これらは多くの場合、独立していますが、関連する操作です。

たとえば、ビデオのいくつかのフレームを処理したり、前の結果セットでUIを更新すると同時にML分類器の次の反復を実行したりします。

これらのアイデアを念頭に置いて、Swiftの新機能を使用せずに、簡単な非同期プログラミングの例を見てみましょう。

iOSやmacOSのプログラミングをたくさんやったことがあるなら、これに似たコードを何度も書いたことがあるかもしれません。

これは、FoundationのURLSessionクラスを使用してネットワークコールを行います。

dataTaskメソッドは非同期操作です。

あなたはクロージャ引数でそれを呼び出します。

結果が利用可能になると、処理する結果とともにクロージャが呼び出されます。

ただし、この方法でクロージャを使用して非同期コードを表現すると、このコードを歩くとわかるように、やや厄介な操作順序になります。

まず、いくつかの初期設定があり、dataTaskメソッドはタスクハンドルを返してくれます。

次に、タスクハンドルを再開してバックグラウンド操作を開始します。

fetchImage関数は、この時点で実際に返されます。

私たちに電話した人は誰でも、私たちが頼まれた仕事を実際にやっていないにもかかわらず、続ける準備ができていなければなりません。

その後、ネットワーク運用が完了した後、この閉鎖は結果に対処する機会があります。

うまくいけば、すべてがうまくいき、最終結果で完了ハンドラーを呼び出すことができます。

やや厄介な実行順序に加えて、完了ハンドラを使用すると、試行/キャッチエラー処理を使用できなくなります。

dataTaskが完了ハンドラに余分なエラーパラメータを提供する方法と、可能なすべてのエラーで完了ハンドラを呼び出す必要がある方法に注目してください。

Swift 5.5がこれをどのように改善するかを見るために、この1行のコードを見てみましょう。

この呼び出しがタスク、バックグラウンド操作を表す抽象ハンドルを返す方法に注目してください。

それは本当に私たちが望むものではありません。

私たちはただデータを入手したいだけです。

だから、そのアイデアを少し推し進めて、どこで終わるか見てみましょう。

HTTPを扱っているので、応答メタデータもキャプチャする必要があります。

したがって、この関数は、実際のデータを最初の項目として、追加情報を2番目の項目として、実際にペアを返します。

これをデータを返す関数呼び出しとして構造化することで、try/catchエラー処理を使用して、前の例から多くのボイラープレートを削除できるようになりました。

データメソッドが開始されるとすぐに関数を一時停止することができ、その操作が完了するまで割り当てを完了できないことをコンパイラに伝えるために、少しの構文が必要です。

これはまさに新しいawaitキーワードが行うことです。

それを文脈で見てみましょう。

fetchImage関数の現在の様子は次のとおりです。

ご覧のとおり、このコードは従うのがはるかに簡単になりました。

コントロールは上から下に流れ、ネストされたクロージャは不要になり、try/catchエラー処理を使用できます。

awaitキーワードは、このfetchImage関数を一時停止できるポイントを示し、続行できるイベントが発生するまで実行しないように設定します。

この場合、URLSessionがリクエストを開始するとすぐに、操作が他の場所で実行されている間、私たちの機能はSwiftランタイムによって中断されます。

最終結果の準備ができたら、それが成功した応答であろうとスローされたエラーであろうと、私たちの機能は再開されます。

応答が成功した場合、データと応答変数の初期化を完了します。

スローされたエラーの場合は、私たちに電話した人に返します。

非同期関数は、一時停止中はリソースを使用しません。

特に、スレッドをブロックしていません。

これにより、Swiftランタイムは、この関数が実行されていたスレッドを他の作業に再利用することができます。

これにより、多くの非同期プロセス間でごく少数のスレッドを共有できます。

構文的には、async キーワードと await キーワードは、スローと試行に同様に使用されます。

Asyncは、この関数がサスペンションをサポートするためにコンパイルされなければならないことを示すために関数宣言を飾ります。

Awaitキーワードを使用して、非同期関数、メソッド、またはクロージャへの呼び出しをマークします。

もちろん、完全なメカニズムは、私がここで示したものよりもはるかに興味深いです。

「Meet async/await in Swift」と「Swift concurrency: Behind the scenes」のセッションを見て、これらすべてがどのように機能するかについて詳しく知ることができます。

次に、先ほど説明した非同期/待機の概念に基づいて構築されたSwiftの新しい並行性サポートを見てみましょう。

これは、3つの異なる画像をレンダリングし、それらを結合する機能です。

ここに書かれているように、これらの操作は順次です。

背景、前景、タイトル画像は次々にレンダリングされ、それぞれが前の画像が完了した後にのみ開始されます。

レンダリング操作を並行して実行したいと考えています。

しかし、異なるスレッドでそれらを実行するだけでは十分ではありません。また、3つの結果がすべて得られるまで、マージ操作を保持する必要があります。

これは、いくつかの点で、私が今話していた非同期コーディングに似ています。

そのため、この関数を「非同期」としてマークして、他のスレッドで計算されている結果を待つ必要がある場合に一時停止できるようにします。

次に、非同期let構文を使用して、最初の2つの操作を並行して実行します。

Async letは変数の初期化によく似ており、それは基本的にそれです。

しかし、この初期化は、結果を使用しようとするまで、他のコードと並行して実行されます。

バックグラウンド変数とフォアグラウンド変数は非同期レットで初期化されているため、Swiftのランタイムは、必要に応じて、それらの値の準備が整うまでマージ操作を一時停止します。

これを示すために、awaitキーワードでマージ関数をマークします。

このコードに関する最も重要な点は、バックグラウンドタスクがこの機能よりも長生きできないということです。

別の言い方をすれば、2つのバックグラウンドタスクのいずれかがまだ実行されている場合、この関数は戻ることができず、戻りません。

この関数内のどこからでもエラーがスローされた場合、Swiftランタイムはバックグラウンドタスクが完了するのを待ちます。

ここでは、タイトル画像の計算がスローされる可能性があることを示すトライマーカーを強調表示しましたが、別のスレッドで発生した場合でも、すべてのスローされたエラーにも同じことが当てはまります。

物事をレスポンシブに保つために、スローされたエラーがある場合、Swiftランタイムは未完成のタスクに通知し、早期に完了する機会を与えます。

構造化並行性に関するセッションでは、このキャンセルメカニズムの完全な議論や、ここで説明した非同期レット構文のより柔軟な代替案など、詳細を提供します。

前のセクションでは、Swift 5.5が規律ある構造化された方法で複数のスレッドで操作を簡単に実行する方法を示しました。

もちろん、それだけでは十分ではありません。

2つの別々のスレッドがデータを共有するたびに、データが矛盾したり、破損したりする危険性があります。

スウィフトの新しいアクター構造は、そのような問題からデータを保護するのに役立ちます。

繰り返しますが、あなたが自分で書いたかもしれないコードの例から始めましょう。

これは統計を収集するクラスです。

カウンタが含まれており、他のさまざまなコードがインクリメントメソッドを呼び出して、何か面白いことが起こるたびにそのカウンタを更新します。

残念ながら、このコードはマルチスレッドシステムではうまく機能しません。

2つ以上のスレッドが同時にインクリメントメソッドを呼び出すと、カウントがひどく破損する可能性があります。

このクラスをスウィフトアクターに変更することで、そのような腐敗から保護されます。

アクターは、その特定の変更を行うのが安全になるまで、データの破損を引き起こす可能性のある操作を一時停止することで作業します。

これは、通常、俳優の外部から俳優メソッドを呼び出すときにawaitを使用する必要があることを意味します。

俳優はまた、async/awaitとシームレスに動作します。

このパブリッシュメソッドを非同期としてマークすると、ネットワーク操作を待っている間に一時停止することができます。

中断されている間、他のメソッドは、ネットワーク操作が完了するのを待たずに、データ破損のリスクなしに、このアクターで実行できます。

アクターはクラスのような参照タイプですが、アクターがマルチスレッド環境で安全に使用できるように設計された多くのルールに従います。

データをアクターにパッケージ化することで、このデータが同時にアクセスされることを期待し、破損がないようにSwiftコンパイラとランタイムがアクセスを調整したいことを明確に述べています。

そして、もちろん、私たちは特にスウィフトの新しい俳優の構築に専念する完全なセッションを持っています。

そこでは、これがもたらすあらゆる機能を活用する方法を見つけることができます。

締めくくる前に、スウィフトの未来について少し話しましょう。

Swift 5.5で導入した3つの重要な概念（非同期関数、構造化並行性、アクター）は、安全で高性能なコードを作成するための良い基礎であると考えています。

Swift 6では、コンパイラが開発プロセスの早い段階でより多くの種類の並行性の間違いをキャッチし、それらの問題を解決するためのより詳細なエラーとガイダンスを提供する方法をすでに研究しています。

私たちの目標は、非常に簡単に言えば、非同期および同時プログラミングを他のどの種類のプログラミングよりも複雑にするために、最も一般的な種類の並行性のバグを完全に排除することです。

そしてもちろん、これらの概念に対するコンパイラの理解を向上させ続けるにつれて、これらの新しい構造を使用するコードが今日よりもさらに効率的になることを期待しています。

Swiftは、あなたのインプットを歓迎するオープンで協力的な取り組みです。

Swift 6をさらに良くするために、Swift 5.5での経験について教えてください。

これらの新機能は、実際のアプリ開発でどの程度うまく機能していますか?

Swift.orgで見つけることができるコンパイラのスナップショットの1つを試してみてください。

これらのスナップショットを提供しているので、Xcodeにインストールし、開発中に新機能を試すことができます。

これらのスナップショットを使用することで、Swiftの次のバージョンを導くのに役立ちます。

スウィフトフォーラムはプロジェクトの生命線です。

私が議論した各機能は、多様な人々のグループがそれを作業提案に洗練するのを手伝ったSwift Evolutionフォーラムで売り込むことによって人生を始めました。

また、新規ユーザー向けのヘルプエリアや、Swiftコミュニティに関心のあるニュースを交換する場所など、Swiftの他の多くの側面に特化したフォーラムもあります。

スウィフトをより良くする方法は他にもたくさんあり、ニコールがこのセッションの冒頭で言及した新しいメンターシッププログラムなど、さらに多くの人々を巻き込むことを熱望しています。

唯一の要件は、私たちのコミュニティのすべての人のためにSwiftを改善する手助けをしたいという誠実な願望です。

ご連絡をお待ちしております。会議を楽しんでいただければ幸いです。

[明るい音楽]。