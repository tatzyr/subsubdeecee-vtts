10027

♪ ♪

こんにちは。私の名前はエリー・エプスカンプ・ハントです。

私はサファリのエンジニアとして働いています。

今日は、Safariで利用できる新しいWeb拡張APIの概要を説明します。

昨年、SafariはmacOSでWeb Extensions APIのサポートを追加しました。

この新しいAPIサポートを使用する過去1年間に出荷されたすべての新しいSafari拡張機能を見るのは驚くべきことです。

そして、このリリースでは、iOSとiPadOSにウェブ拡張機能をもたらすことに本当に興奮しています。

これらの新しいプラットフォームの拡張機能の詳細については、独自の専用セッション「iOSでSafari Web拡張機能に会う」で学ぶことができます。

また、Safari Web Extensions全般についてもっと知りたい場合は、昨年のセッションをチェックしてください。

今日は、3つの新しい拡張APIを取り上げます。

まず、パフォーマンスを向上させるために拡張機能を構成する方法である非永続的な背景ページについて説明します。

次に、宣言型ネットリクエストと呼ばれるWeb拡張機能用のコンテンツブロックAPIを紹介します。

そして最後に、拡張機能がSafariで新しいタブをカスタマイズする方法を見ていきます。

この新しいAPIについてもっと学ぶ前に、永続的なバックグラウンドページについて話しましょう。

Web拡張機能は、JavaScript、HTML、およびCSSを使用して作成されます。

一部の拡張機能には、バックグラウンドページと呼ばれるブラウザのバックグラウンドで実行されるスクリプトがあります。

目に見えるUIはありませんが、タブの開口部や拡張機能の別の部分からのメッセージなどのイベントに反応することができます。

永続的な背景ページは決して閉じません。

したがって、ブラウザで2つの拡張機能をオンにすると、2つのバックグラウンドページが常に実行されます。

そして、8つの拡張機能を使用する場合、それは常にバックグラウンドで実行されている8つの拡張プロセスです。

ここに問題があることがわかります。これは問題です。

永続的な背景ページは、ユーザーが決して閉じることができないこれらの目に見えないタブのようなもので、メモリを消費し、CPU使用率を増加させます。

ユーザーは、拡張機能の使用とブラウザから優れたパフォーマンスを引き出すことの間で妥協する必要はありません。

したがって、代わりに、拡張機能は非永続的な背景ページを採用することができます。

これらのタイプのページは、必要に応じて行ったり来たりすることができ、拡張機能のパフォーマンスが向上し、ユーザーに全体的により良いブラウジング体験を提供します。

iOS用に開発している場合は、iOSデバイスのリソース制約があるため、拡張機能には非永続的なバックグラウンドページが必要です。

永続的な背景ページを使用する理由を理解したので、それらがどのように機能するかを見てみましょう。 それらがどのように機能するかを見てみましょう。

非永続的な背景ページの寿命は、イベントを中心に構成されています。

バックグラウンドページは、タブの閉鎖や拡張機能の別の部分からのメッセージなど、ブラウザで起こることに反応するためにイベントリスナーを登録します。

また、これらのイベントは、ブラウザがバックグラウンドページを読み込むかアンロードするかを判断するのに役立ちます。

例を見てみましょう。 例を見てみましょう。

拡張機能がオンまたは更新されると、バックグラウンドページが読み込まれ、イベントリスナーが登録されます。

この例のために、この背景ページには、コンテンツスクリプトからのメッセージのリスナーが正確に1つあるとします。

時間が経過し、コンテンツスクリプトがメッセージを送信しない場合、その非アクティブのため、バックグラウンドページはブラウザによってアンロードされます。

しかし、コンテンツスクリプトがメッセージを送信すると、バックグラウンドページがスリープされ、そのメッセージを受信して反応することができます。

そして、イベントが発生した後、背景ページはロードされたままになります。

しかし、再び時間が経過し、イベントが発生しない場合、背景ページはアンロードされます。

したがって、そのメンタルモデルを念頭に置いて、非永続的な背景ページを実際に実装する方法について話すことができます。

まず、マニフェストの背景セクションに「永続的」キーを追加します。

そして、バックグラウンドスクリプトにさらにいくつかの変更を加える必要があるかもしれません。

バックグラウンドページはアンロードできるため、必要に応じてストレージAPIを使用してディスクに情報を書き込む必要があります。

Browser.storageを使用して、バックグラウンドページの存続期間にわたって情報を維持します。

次に、スクリプトの最上位レベルでイベントリスナーを登録する必要があります。

別のイベントリスナーの完了ハンドラにリスナーを登録しないでください。

そして、タイマーの代わりにbrowser.alarms APIを使用したいと思うでしょう。

バックグラウンドページがアンロードされている場合、タイマーは呼び出されません。

では、避けたいコードについて話しましょう。

browser.extensionへの呼び出しを削除します。getBackgroundPage。

すでにアンロードされている場合、バックグラウンドページは起動しません。

そして最後に、webRequestリスナーを削除する必要があります。

webRequestは、Webトラフィックを分析できるAPIであり、webRequestイベントが発生する頻度により、このAPIは非永続的なバックグラウンドページと互換性がありません。

だから、これらすべてが一緒にどのように機能するかを見るために、Safariで試してみましょう。

私はSafariの拡張機能に関する昨年のセッションのサンプルコードの修正版を使用しています。

この拡張機能は、ウェブページの単語を絵文字に置き換えることができ、合計置換が発生した数を報告します。

まず、この拡張機能が変更を加えずに何をするかを見てみましょう。

マニフェストに「永続的な」キーを省略したため、バックグラウンドページはデフォルトで永続的です。

拡張機能を含むアプリを構築して実行します。

そして、Safariの環境設定でオンにします。

今、私はウェブページで拡張機能を使用します。

魚に関するこのウィキペディアの記事に行きましょう、そして私は拡張機能と対話するためにポップオーバーを使用します。

「単語を置き換える」ボタンをクリックすると、「魚」という単語のすべてのインスタンスが魚の絵文字に置き換えられました。

ポップオーバーをもう一度クリックすると、置き換えられた単語の総数が表示されます。

この拡張機能のバックグラウンドページは、その置換数の追跡を担当しています。

アクティビティモニターに行って、拡張プロセスを見てみましょう。

ここでは、すべての拡張コードが実行されているウェブプロセスを見ることができます。

拡張機能は永続的なバックグラウンドページを使用しているため、数時間後にこの拡張機能の使用を停止しても、Safariが実行されているときにこのプロセスは常に実行されます。

では、この拡張機能をもう少し良くして、背景ページを非永続的にしましょう。

最初に行うことは、マニフェストの背景セクションに「永続的」キーを追加することです。

そして、ここで立ち止まって、私たちの拡張機能がまだ機能するかどうかを見てみましょう。

拡張機能を含むアプリを構築します。

Safariに戻ってページをリロードします。

では、いくつかの単語を置き換えます。

その後、私は少し待って、バックグラウンドページにアイドル状態になる時間を与えます。

このデモの目的で、Safariを修正して、通常よりもはるかに速く背景ページをアンロードしました。

Web Extension Background Pagesの下にある開発メニューで、バックグラウンドページが実際にアンロードされていることを確認できます。

これは、背景ページを検査できる場所でもあります。

アンロード時にページを検査することを選択した場合、すぐに読み込まれることに注意してください。

背景ページがアンロードされたので、ポップオーバーをもう一度開きましょう。

予想される数564の代わりに、ゼロの単語が置き換えられます。

そのため、拡張機能にバグがあります。

拡張機能が非永続的な背景ページで正しく機能するように、戻ってさらにいくつかの変更を加える必要があります。

これは、拡張機能の背景ページのコードです。

この背景ページは2つのことを行います。

単語の置換カウントに1つを追加するか、現在のカウントを報告します。

グローバル変数は、私たちのバグの原因です。

バックグラウンドページがリロードされると、カウントは0にリセットされます。

だから、564語が置き換えられたという状態を維持する代わりに、私たちはそれを失います。

これを回避するには、browser.storage APIを使用して、必要に応じて単語数を保存してロードしましょう。

まず、ストレージからそのカウントをロードするためのコードを追加します。

ストレージAPIの結果を解析して、必要な値を取得します。

そして、更新されるたびに、その価値をストレージに保存します。

そして、そのonMessageリスナーをストレージコールバックの本体に持ち込みます。

でも待って。私たちは問題を抱えています。

イベントリスナーはスクリプトの最上位レベルで登録する必要があることを知っているので、これはうまくいきません。

では、ここで物事を再構築し、ストレージコールをリスナーの体に持ち込みましょう。

また、ストレージAPIを使用しているため、マニフェストにストレージ権限を追加する必要があります。

次に、アプリを再構築し、拡張機能を再度テストします。

私は以前とまったく同じことをします。

魚に関するウィキペディアのページを見て、ページをリロードします。

その後、私はいくつかの単語を置き換えてしばらく待って、私たちの背景にアンロードする時間を与えます。

すごい。

ポップオーバーでは、置き換えられた正しい数の単語が報告されています。

永続的な背景ページを持つ拡張機能を取り、非永続的な背景ページを使用するように正常に変換しました。

また、アクティビティモニターに戻ると、非永続的な背景ページを採用するためにこの作業を行ったため、背景ページがアンロードされた後、拡張プロセスは存在しなくなります。

これは、Safariの非永続的なバックグラウンドページサポートの概要でした。

iOS用の拡張機能を開発する場合は、非永続的な背景ページを採用する必要があることを覚えておいてください。

次に、新しいコンテンツブロックAPIである宣言的なネットリクエストを見てみましょう。

Safariは、2015年以来、WebKitコンテンツルールリストを使用して構築されたコンテンツブロッカー拡張機能をサポートしています。

今年はいくつかの改善点があり、Appleの更新されたドキュメントで確認できます。

しかし、ウェブ拡張機能は、これまでそのような高速でプライバシー保護、コンテンツブロック機能を持っていませんでした。

Chromeによって最近導入された宣言的なネットリクエストAPIは、これらすべてのボックスをチェックします。

基本をやり直しましょう。

コンテンツブロックルールはJSON形式で書かれています。

これらのJSONルールは、ルールセットと呼ばれるファイルに論理的にグループ化されており、これらのルールセットを個別にオンまたはオフに切り替えることができるJavaScript APIがあります。

また、ChromeはこのAPIもサポートしているため、複数のプラットフォームで複数のブラウザで実行できる1つのコンテンツブロッカーを書くことができます。

宣言型ネットリクエストを使用してコンテンツブロックルールを作成する方法を見てみましょう。

最初のステップは、拡張機能のマニフェストにルールセットを指定することです。

ここで、私は1つのルールセットを宣言しました。

また、宣言的なネットリクエスト権限を追加する必要があります。

以下は、ルールセットで指定したファイルの中に入る宣言的なネットリクエストルールの例です。

それは4つの部分があります。

一意のIDと優先順位があり、ルールが適用される順序を決定します。

ルールのアクションピースでは、リソースのスキームをブロック、許可、またはアップグレードすることができます。

そして、条件は、このルールを実行する場所と条件をSafariに伝える場所です。

このルールの条件辞書には、2つのキーがあります。

「regexFilter」はリソースURLと照合され、「resourceTypes」配列はブロックされるリソースのタイプを指定します。

この条件辞書でサポートされているものについてもっと詳しく説明しましょう。

宣言型ネットリクエストルールを使用してターゲットにできるすべてのリソースタイプを次に示します。

「excludedResourceTypes」キーを使用すると、一致させたくないタイプを指定できます。

「domainTypeキー」を使用すると、ロードされるリソースのドメインとドキュメントのドメインの関係に基づいてリソースをブロックできます。

「ファーストパーティ」ロードは、URLがドキュメントと同じセキュリティオリジンを持つロードです。

他のすべてのケースは「第三者」です。

そして最後に、「大文字と小文字を区別する」キーを使用すると、正規表現フィルターが大文字と小文字を区別するかどうかを制御できます。

デフォルトでは、それは本当です。

それでは、宣言型ネットリクエストAPIを使用してコンテンツをブロックするウェブ拡張機能を構築しましょう。

最初に行うことは、マニフェストに宣言的なネットリクエストセクションを追加することです。

その宣言的なネットリクエストセクションの中に、ID、それがオンになっていることを示すブール、および私のルールを含むJSONファイルへのパスを書いてルールセットを追加します。

そして、私たちがマニフェストにいる間、宣言的なネットリクエスト許可も追加します。

ここから、ルールセットJSONファイルに入りましょう。

すべてのウェブページで画像をブロックするルールを書きます。

拡張機能を含むアプリを構築し、Safariを開きます。

この拡張機能は、すべてのWebページのコンテンツをブロックできるにもかかわらず、閲覧履歴やWebページのコンテンツを表示する機能がないことに注意してください。

拡張機能を有効にする前に、いくつかの画像を含むWebKitブログ投稿を開きます。

このウェブページには2つの画像があることがわかります。

環境設定に戻り、拡張機能をオンにしてからページをリロードすると、画像はブロックされます。

では、魚に関するこのウィキペディアのページのような別のウェブページに行きましょう。

画像もここでブロックされていますが、実際にはこの特定のページで画像を見ることができた方がいいです。

だから、ここ以外のどこでも画像がブロックされるように拡張機能を変更しましょう。

Xcodeに戻って、このページで画像を許可するルールを書きます。

このルールのアクションタイプは「許可」になり、最初のブロッキングルールよりも優先度の高いルールになります。

アプリを再構築してから、Safariに戻ります。

ページをリロードします。

しかし、私はまだ画像を見ていないので、この新しいルールは機能しませんでした。

拡張機能の環境設定でエラーメッセージを探します。

さて、文字列「image」の配列ではなく、リソースタイプキーに空の配列を使用したようです。

間違いを直すためにXcodeに戻ります。

再構築してSafariの環境設定に戻り、エラーメッセージが消えたことを確認します。

その後、ページをリロードします。

そして素晴らしい、画像はもはやこのウィキペディアのページでブロックされていません。

つまり、ウェブ上のコンテンツをブロックできるウェブ拡張機能を構築する方法の概要でした。

宣言型ネットリクエストの使用方法の詳細については、Appleのドキュメントを参照してください。

最後に、拡張機能がSafariで新しいタブをカスタマイズする方法を見てみましょう。

私たちは、ユーザーがブラウザをパーソナライズするのが大好きで、拡張機能がそれを行うための素晴らしい方法であることを知っています。

新しいタブオーバーライドAPIを使用すると、拡張機能はSafariの新しいタブページを引き継ぎ、完全にカスタマイズできます。

このAPIはすでにSafari 14.1で公開されています。

新しいタブのオーバーライドはマニフェストで宣言されます。

そして、ユーザーが新しいタブオーバーライドで拡張機能をオンにすると、その拡張機能がSafariで新しいタブを引き継ぐかどうかを選択します。

マニフェストの新しいタブオーバーライドページを指摘する方法は次のとおりです。

この新しいAPIを一緒に使用する拡張機能を構築しましょう。

Sea Creator拡張機能に新しいタブオーバーライドを追加します。

私たちの目標は、Safariで新しいタブを開くたびに楽しいウェブページが表示されるようにすることです。

HTMLページがマニフェストの新しいタブオーバーライドであることを宣言することから始めます。

使い既存のHTMLファイルとCSSファイルがいくつかあります。

それらは私の拡張機能のリソースフォルダにあります。

それらをXcodeプロジェクトに追加するだけです。

Xcodeプロジェクトにファイルを追加したことがない場合は、心配しないでください。

それはかなり簡単です。

[ファイル]をクリックし、[Sea Creatorにファイルを追加]をクリックし、追加したいファイルを選択し、それらが拡張ターゲットの一部であり、アプリのターゲットではないことを確認します。

このHTMLは、楽しい事実を持つカラフルなページを作成します。

では、アプリを実行して、Safariで拡張機能をオンにします。

このプロンプトが表示され、この拡張機能が新しいタブとウィンドウを引き継ぐことができるかどうかを尋ねられます。

私はそれを許可します。

後でこれを変更したい場合は、一般設定に入ることができます。

しかし今、Safariで新しいタブを作成すると、新しいタブページが表示されます。

かなり良さそうですね！

しかし、私はいくつかの微調整をしたい。

私の新しいタブオーバーライドページには、あまり素敵なタイトルがありません。

Xcodeに戻って、Safariのタブバーでページが良く見えるようにタイトルを追加します。

Safariがページから推測したものとは異なるものが必要な場合は、別のテーマカラーを選択することもできます。

私が使用しているこのメタタグは、新しいタブのオーバーライドに固有のものではありません。

それはどのウェブページでも機能します。

SafariのUIの変更についてもっと知りたい場合は、「Design for Safari 15」というセッションを必ずチェックしてください。

それが今どのように見えるか見てみましょう。

もう一度建てます。

そして、Safariに戻って、新しいタブを作成します。

すごい。

Sea Creator拡張機能に新しいタブオーバーライドを正常に追加しました。

そして、それは拡張機能がSafariで新しいタブをカスタマイズする方法を見ていました。

今日は、macOSとiOSのSafariで利用可能な3つの新しいWeb拡張APIについて議論しました。

このセッションに関連するサンプルプロジェクトをダウンロードして、新しいAPIで遊ぶことをお勧めします。

これらの拡張機能がmacOSでどのように機能するかをお見せしましたが、iOSでも機能します。

私たちはまた、あなたの考えを知りたいです。

フィードバックアシスタントを使用してバグを提出することも、Safari開発者フォーラムで私たちとチャットすることもできます。

そして最後に、あなたがまだしていない場合は、私が今日言及した他のセッションをチェックしてください。

ありがとう、そして素晴らしいWWDCをお過ごしください。

[エーテルパーカッション音楽]。