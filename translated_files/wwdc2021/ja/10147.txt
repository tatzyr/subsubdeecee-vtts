10147

こんにちは、GPUソフトウェアエンジニアリングチームのカイル・サナーと申します。

同僚のアレックス・リーと一緒に、可変リフレッシュレートディスプレイでアプリで最適なフレームペーシングを取得する方法について話します。

macOSに搭載される新しいディスプレイ技術、Adaptive-Sync、およびあらゆる条件下でiPad Proでカスタム描画をスムーズに駆動する方法に焦点を当てます。

Appleプラットフォームで現在サポートされているディスプレイの種類の概要から始めます。

MacのAdaptive-Syncディスプレイと、これらのディスプレイ上のフルスクリーンアプリやゲームでスムーズなフレームレートを提供するために使用できるmacOS Montereyの新しいツールを紹介します。

次に、iPad ProのProMotionを深く掘り下げ、アプリが異なるフレームレートで正しいフレームペーシングを維持するのに役立つCADisplayLinkのベストプラクティスを見ていきます。

まず、Appleのデバイスがサポートできるディスプレイの種類を確認しましょう。

Appleシステムのほとんどのディスプレイは、固定のリフレッシュレートで動作します。

つまり、電源を入れるたびに一貫した速度でリフレッシュします。

例外は、iPadのProMotionディスプレイと、macOSのAdaptive-Syncディスプレイです。

MacのAdaptive-Syncディスプレイの新機能について掘り下げてみましょう。

Adaptive-Syncディスプレイとは何か、そしてそれらがMacでどのように機能するかから始めます。

しかし、まず、固定レートディスプレイがどのように機能するかを簡単に見てみましょう。

これは、フレームが60Hzのディスプレイに配信されていることを示す図です。

各フレームはディスプレイに表示され、ディスプレイが更新されるまで16ミリ秒間滞在します。

フレームバッファにMacによって描かれた新しいフレームがある場合は、その新しいフレームが表示されます。

それ以外の場合は、前のフレームが再び表示されます。

120Hzのディスプレイを見ると、リフレッシュレートを2倍にし、それによって各フレームが画面に表示される間隔を半分にしましたが、同じように、より速く動作することがわかります。

一方、このAdaptive-Syncディスプレイを見てみましょう。

静的な持続時間の代わりに、各フレームには画面に表示される時間のウィンドウがあります。

このウィンドウは、付属のディスプレイによって異なります。

このディスプレイは40〜120Hzの間で動作できます。つまり、フレームは8〜25msの任意の場所で画面に表示できます。

最大時間が経過すると、システムはパネルを更新する必要があり、ディスプレイは短時間、新しい更新のために一時的に使用できなくなることに注意してください。

さて、あなたのゲームやアプリはアダプティブ同期ディスプレイでどのような利点を得ることができますか?

主にディスプレイの最大リフレッシュレートで実行されるアプリケーションの場合、Adaptive-Syncディスプレイは無料で大きな利点を提供します。

まず、このシナリオを見てみましょう。アプリはほとんどの場合、8ms未満で新しいフレームを生成することができるため、120Hzでかなり確実に実行しています。

しかし、シーンの複雑さが瞬間的に増加したため、完成したフレームは、前のフレームが最初に表示された後、フレームバッファ9msに着地します。

固定フレームレートディスプレイでは、前のフレームは意図した8msではなく16msで表示されます。

これにより、アプリに目に見えるヒッチが発生します。

Adaptive-Syncディスプレイでは、フレームが完了した直後にディスプレイに表示されるため、アプリは1msのペナルティしか発生しません。

この小さなヒッチは、一般的にユーザーには認識できません。

ディスプレイの最大フレームレートに到達できないワークロードの場合、アプリが描画可能な表示方法にいくつかの小さな変更を加えることで、スムーズで均一なフレームを提供できます。

このシナリオを考えてみましょう。複雑なシーンを実行するゲームは、約90Hzで更新を生成することができます。

しかし、断続的な効果は複雑さの大きなジャンプを引き起こしますが、一貫性がなく、66Hzまでの突然のスパイクを引き起こします。

アプリのGPU作業を監視することで、シーンの複雑さが一貫して低くなるまで、後で意図的にフレームを提示することで、この複雑さの急増に対応できます。

さて、Adaptive-Syncのベストプラクティスについて話しましょう。

固定レートディスプレイでは、アプリのGPU動作が一貫してディスプレイのオンガラス間隔を超える場合、以前はレンダリングを遅くして、ディスプレイの最速のリフレッシュレートの次の要因に達することを推奨していました。

通常、この例のように、ターゲットフレーム/秒を60から30に下げることを意味します。

ただし、Adaptive-Syncディスプレイに表示する場合は、そのガイダンスを変更します。

代わりに、アプリが均等にできる最高のレートでフレームを表示しようとする必要があります。

フレームを均等に表示することに加えて、フレームがディスプレイがサポートする最小レート未満で表示されている場合、新しいフレームでディスプレイが使用できなくなる可能性があり、アプリでジャダーを誘発する可能性があることを覚えておいてください。

しかし、サポートされている範囲内にある限り、アプリに最適なレートを自由に選択できます。

今年Macに搭載される新しいディスプレイサポートを高レベルで理解したので、ゲームでアダプティブシンクを有効にする方法について話しましょう。

まず、サポートされているMacが必要です。

Apple Silicon GPUを搭載したどのMacでもうまく機能し、最新のIntelベースのMacの多くもサポートしています。

次に、サポートされているAdaptive-Syncディスプレイと、Adaptive-Syncモードを有効にする必要があります。

これは、ディスプレイシステム環境設定で利用可能な新しい可変リフレッシュレートを選択することで実行できます。

そして最後に、アプリはフルスクリーンモードで実行されている必要があります。

Adaptive-Syncスケジューリングを行う必要があるかどうかを検出するために、アプリで呼び出すことができるAPIを見てみましょう。

まず、実行しているディスプレイがAdaptive-Syncスケジューリングが可能かどうかを判断する必要があります。

そのために、今年はNSScreen、minimumRefreshInterval、maximumRefreshIntervalにいくつかの新しいプロパティがあります。

これらの値は、このディスプレイに表示されたフレームの有効な画面上の時間の範囲を示します。

固定フレームディスプレイでは、これらの値は同じになるので、単純な不均等な比較で、この画面がAdaptive-Syncモードになっているかどうかがわかります。

次に、ウィンドウが現在フルスクリーンであるかどうかを知る必要があります。

ウィンドウのstyleMaskをチェックすることで、それを判断できます。

また、アプリがAdaptive-Syncスケジューリングを活用できるように、これらのチェックの両方を組み合わせる必要があることを覚えておいてください。

オーケー、いいね。だから、Adaptive-SyncディスプレイとmacOSがそれらを検出するために提供する新しいAPIのハンドルを手に入れたので、Adaptive-Syncディスプレイで均等に提示するために、既存の金属プレゼンテーション技術を適応させる方法を見てみましょう。

presentAfterMinimumDurationやpresentAtTimeなど、フレームペーシングを内蔵したMetalDrawable APIを使用して、Adaptive-Syncディスプレイで大きな効果を発揮できます。

または、プレゼントナウコールと独自のカスタムタイマーを使用して、独自のソリューションをロールすることができます。

いくつかの異なる実装がどのように機能するかを見てみましょう。 

簡単な例から始めます。

ここでは、Drawableを取得し、GPU作業をセットアップし、画面に表示します。

私たちは、フレームレートを設定するために利用可能なDrawableの背圧に依存しています。

固定レートディスプレイでは、GPUの作業がディスプレイのリフレッシュレートに一致する保証がないため、これは最良のアイデアではないことを知っています。

しかし、Adaptive-Syncディスプレイで撮影されたこの楽器キャプチャからわかるように、私たちのシーンが一貫しているとき、これはうまくいくようです。

ここでの問題は、このシーンが定期的なヒッチに遭遇していることです。

これらのヒッチは、ユーザーに見える吃音に変換されます。

固定された均一なレートで提示することで、それを修正してみましょう。

このテクニックは、ゲームのプレイヤーにユーザー調整可能なFPSスライダーを実装する場合にも使用できます。

ここでは、必要な周波数を78Hzに設定しました。

そして、プレーンな現在の呼び出しの代わりに、このDrawableにpresent afterMinimumDurationを使用し、上記で定義した間隔を指定します。

そして、ここでは、私たちが要求した速度でスムーズに提示されたフレームを見ることができます。

前の例ほど迅速に提示していませんが、ユーザーは吃音に遭遇する可能性がはるかに低く、アプリはCPUとGPUの時間を短縮します。

さて、ここでは物事がもう少し面白くなります。

単一の固定レートを設定することなく、均等なペースのフレームを生成するアプローチを試してみましょう。

これを行う1つの方法は、各フレームを生成するために必要なGPU作業のローリング平均を計算し、その時間を現在のDrawableコールにフィードすることです。

最初のフレームでは、平均GPU時間を開始値でロードする必要があります。

私は楽観的であることを選択し、ディスプレイがここでサポートできる最速のレートをターゲットにするつもりです。

これは私たちの平均の出発点にすぎないので、合理的な推測は問題ありません。

次に、CommandBuffer完了ハンドラを添付して、GPUがこのフレームのレンダリングに費やした時間を測定し、その時間をローリング平均に組み込みましょう。

まず、GPUが作業を完了するのにかかった時間を獲得できます。

次に、その新しい時間を次のフレームを提示するときに使用されるローリング平均に組み込みます。

そして、これが結果です。

ご覧のとおり、前の例と同様のレートで提示していますが、この制限は生成した以前のフレームによって決定され、さまざまなMac GPUで均一なフレームレートを生成します。

ここでは、追加のコードを変更することなく、あまり強力ではないMacで同じプログラムが48Hzでスムーズに実行されているのを見ることができます。

さて、Adaptive-Syncディスプレイ用にアプリを最適化するために使用できる新しいツールとテクニックがいくつかあるようになりました。

macOSのAdaptive-Syncディスプレイについてもっと知りたい場合は、Apple Developerサイトで新しいMetalサンプルプロジェクトをチェックしてください。

メタルでパフォーマンス体験を提供することの詳細については、前年のWWDCトークをご覧ください。

そして今、私はあなたをアレックスに引き渡します、そこであなたはiPad Proのフレームペーシングについてもっと学びます。

ありがとう、カイル。

次に、ProMotionについて話しましょう。

2017年以来、すべてのiPad Proには、最大120Hzのリフレッシュレートを提供するProMotionディスプレイが搭載されています。

ただし、ユーザーがiPadOS 15で今年iPadに持ち込まれた低電力モードをオンにした場合など、状況によっては120Hzが利用できない場合があります。

適切なフレームペーシングにより、表示特性、ユーザーの好み、システムの状態に関係なく、アプリはモーションコンテンツを正確かつスムーズに表示できます。

ProMotionと固定レートディスプレイの違いと、一部のフレームレートが利用できない状況を見ていきます。

次に、表示リンクとは何か、アプリがそれを使用してカスタム描画を駆動する方法について説明します。

そして最後に、いくつかのディスプレイリンクのベストプラクティスを提供します。

すぐに飛び込みましょう。

カイルが先に簡単に提示したように、固定60Hzディスプレイは16ミリ秒ごとに更新され、固定ケイデンスです。

フレームレートが60の係数であるコンテンツのスムーズな表示をサポートします。

例えば、60Hz、30Hz、20Hzなど。

ただし、コンテンツがディスプレイのリフレッシュレート、例えば30Hzよりも遅い場合、ディスプレイ自体は同じケイデンスで更新する必要があります。したがって、他のすべてのフレームは以前のフレームの繰り返しであり、これはある程度の電力を消費します。

一方、ProMotionは最大120Hzのリフレッシュレートで優れた応答性を提供します。

また、画面上のコンテンツに適応するため、消費電力を削減します。

それがどのように機能するか見てみましょう。

もちろん、最大リフレッシュレートは120Hzで、ディスプレイは8ミリ秒ごとにリフレッシュされます。

120は60の倍数であるため、ProMotionは既存のすべてのフレームレートをサポートしています。

120Hzだけでなく、アプリの中間フレームレートも提供します。

さらに、ProMotionはリフレッシュレートを動的に調整できるため、スムーズな60Hzのコンテンツを使用すると、繰り返しなしで16msごとにのみ更新できます。それ以外の場合は、固定120Hzディスプレイで必要になります。

これは24Hzまでずっと当てはまります。

さて、これらのフレームレートは必ずしも利用可能ではないかもしれません。

ユーザーは、最大フレームレートを60Hzに制限するアクセシビリティ設定で、フレームレート制限トグルをオンにすることができます。

また、デバイスが熱くなると、システムは120Hzの可用性に制限を適用する場合があります。

iPadOS 15では、低電力モードで60Hzのキャップも適用します。

では、これらのシナリオはアプリにどのように影響しますか?

良いニュースは、ほとんどのアプリが変更なしで動作するということです。

しかし、アプリがフレームごとのカスタム描画を実行する場合は、これらのフレームレートの変更に注意を払う必要があり、その方法を紹介します。

カスタム描画を駆動するための推奨ツールは、基本的にディスプレイリフレッシュレートと同期するタイマーであるディスプレイリンクです。

アプリがカスタムアニメーションやカスタムレンダリングループを駆動するのに役立ちます。

表示リンクは2つあります。

1つは、macOSのCoreVideoが提供するCVDisplayLinkで、もう1つは、他のプラットフォームでCoreAnimationが提供するCADisplayLinkと、macOSのCatalystで、それぞれがわずかに異なる特性と動作を持っています。

今日は、CADisplayLinkについてのみ議論しますが、高いレベルでは、これらの概念は両方に適用されます。

CADisplayLinkは、すべてのvsyncでウェイクアップし、コールバックを呼び出します。

これにより、アプリケーションは作業を完了するために8ms全体を提供します。

NSTimerなどの通常のタイマーは、ディスプレイと完全に同期する可能性は非常に低いです。

位相から外れたり、ドリフトしたりする可能性があるため、アプリが作業を完了するのに十分な時間がなく、フレームドロップにつながることがあります。

CADisplayLinkが一貫したタイミングを提供する方法を見ましたが、追加の利点をいくつか紹介します。

ディスプレイのリフレッシュレートよりも遅い速度で実行できるため、アプリはpreferredFramesPerSecondを介してヒントを提供し、最も近いフレームレートを選択します。

先に説明したように、フレームレートの可用性が変更されると、CADisplayLinkは自動的にボンネットの下でレートを調整します。

もちろん、カスタム図面がこれらの変更を認識できるように、必要なタイミング情報をアプリにも提供します。

カスタムアニメーションやカスタムレンダリングループの書き方については取りませんが、カスタム描画がディスプレイのタイミングと同期し、一般的な落とし穴を回避するための4つのベストプラクティスを提供します。

まず、ハードコーディングするのではなく、実行時にディスプレイのリフレッシュレートを照会することが重要です。

第二に、通常、CADisplayLink自体のフレームレートを使用する必要があります。

次に、targetTimestampを使用して図面を準備すると、ヒッチを減らすのに役立ちます。

最後に、時間デルタを動的に計算することで、予期せぬ事態に備えることは常に良い考えです。

それらを一つずつ見てみましょう。

最大ディスプレイリフレッシュレートは、低電力モードがオンになっているなどの状況でも、ProMotionディスプレイで常に120Hzを返すUIScreenを介して照会できます。

一方、CADisplayLinkは実際には期間プロパティを介してフレーム間の最短間隔を提供し、現在のデバイスの状態に基づいて動的に更新されます。

しかし、ほとんどの場合、表示リンクは最大表示リフレッシュレートよりも遅くなる可能性があるため、CADisplayLinkから直接実際のフレーム情報を使用する必要があります。

また、フレームレートの可用性はハードウェアに依存し、実際のフレームレートは、システム状態の変化に応じて表示リンク自体によって動的に変更される可能性があります。

例を見てみましょう。 例を見てみましょう。

40Hzのディスプレイリンクを要求したとします。

ご覧のとおり、ProMotionディスプレイでは40Hzがサポートされています。

ただし、60Hzのディスプレイ、またはProMotionが60Hzに制限されている場合、ディスプレイリンクは自動的に30Hzに調整されます。

これにより、各ウェイクアップが可能なvsyncにあり、各フレームに同じ時間を与えようとする良好なケイデンスが保証されます。

フレームレートを認識していないプレーンな40Hz NSTimerを使用する場合、そのウェイクアップはvsync間隔のちょうど真ん中にある可能性があり、もちろん、そこにフレームを提示することはできないので、カスタム図面でヒッチを観察する可能性があります。

では、コードではどのように見えますか?

さて、これは通常、表示リンクを設定する方法です。

まず、呼び出されるコールバックであるターゲットとセレクタを指定する必要があります。

次に、preferredFramesPerSecondを介して40Hzの優先フレームレートをヒントします。

次に、現在のランループに表示リンクを追加し、そこからコールバックが呼び出されます。

したがって、コールバックでは、targetTimestampからタイムスタンプを差し引くことで、表示リンクのウェイクアップ間の予想される間隔を取得できます。

この間隔は、表示リンク自体が異なる周波数で実行されている可能性があるため、必ずしも40以上の1とは限りません。

次に、これらのタイムスタンプについて話しましょう。

CADisplayLinkには主に2つのタイムスタンプがあり、コールバックが呼び出される予定の時刻を示すTimestampと、次のフレームがCoreAnimationによって合成されるtargetTimestampがあります。

図面を準備するためにtargetTimestampを使用する理由を説明する例を見ていきます。

これは、0から1までの正規化された時間領域のアニメーションです。

可能な限り最高のフレームレートをターゲットにしており、現在は120Hzであるとします。

CADisplayLinkが目を覚まし、タイムスタンプを使用してフレームプレゼンテーションを準備する場合は、ここで直接サンプリングし、次のvsyncで提示され、ここにあります。

同じプロセスが続いており、120Hzフレームごとにアニメーションの進行が0.05増加する良いケイデンスがあることがわかります。

さて、熱状態が変化し、120Hzが使用できなくなったとします。

これで、表示リンクが再び起動し、アプリは進行状況0.4でアニメーションを準備し、次のvsyncでここで表示されます。

そして、同じパターンが続きます。

ここの移行では何かが正しくありません。

進歩は0.05増加しますが、1つは8ミリ秒を超え、もう1つは16ミリ秒を超えています。

時間に対して進捗状況をプロットすると、トランジションでしゃっくりが表示されることは非常に明確であり、これはユーザーが知覚できるヒッチとして反映され、それは望ましくありません。

では、targetTimestampを試してみましょう。

CADisplayLinkはここで目を覚ます。

進捗状況はtargetTimestampでサンプリングされ、0.15になります。

同じパターンが続き、再び、私たちは良いケイデンスを見ます。

このフレームレート遷移ポイントでは、表示リンクが起動し、targetTimestampでサンプリングされ、0.50になります。

そして、それは同じように続きます。

同じ進行状況と時間グラフをプロットすると、それが直線であることがわかります。したがって、フレームレートが変化してもスムーズなコンテンツを提供します。

したがって、図面を準備するには、タイムスタンプではなくtargetTimestampを使用する必要があります。

コードでは、通常、タイムスタンプの使用をtargetTimestampに置き換えるのと同じくらい簡単です。

最後に、時間デルタの動的計算について話しましょう。

targetTimestampとtimestampの違いは、表示リンクコールバック間の予想される時間を示しますが、実際の時間は保証されていません。

より優先度の高いスレッドがCPUでスケジュールされているか、ランループが何か他のものでビジーである可能性があります。

極端な場合、コールバックは完全にスキップされる可能性があるため、このような状況では、最高のユーザーエクスペリエンスのためにカスタム図面で正しいタイミングを維持することが特に重要です。

CADisplayLinkコールバックが呼び出されると、アプリは次のフレームに必要な更新またはレンダリングを準備する作業を実行します。

通常、コールバックは予定された起床時間に呼び出されますが、そうではありません。

次のコールバックがここで呼び出されることを期待しています。

ただし、表示リンクは、vsync間隔に数ミリ秒まで実行される機会がありません。

したがって、あなたは完全な8msを得ることはできません。

この場合、CACurrentMediaTimeを照会し、targetTimestampと比較して、利用可能な時間を取得できます。

さて、このフレームで作業に時間がかかりすぎるとします。

ランループが再び自由になるまで、次のコールバックは呼び出されません。

これは遅れているため、次のコールバックはスキップされるため、このコールバックでカスタム描画の進捗状況を進める準備をしているときは、カスタム描画状態が更新された以前のタイムスタンプを追跡する場合は、使用すべき時間デルタが8msではなく、16msであることに注意してください。

したがって、アプリがタイムデルタを使用してカスタム描画の状態を進めると、カルバックがスキップされるたびにカスタム描画が1フレーム遅くなります。

代わりに、以前のtargetTimestampを追跡して、状態を正しく進めることができます。

また、カスタム図面の作業負荷が高い場合は、targetTimestampを見て、必要に応じて締め切りに間に合うように作業負荷を軽減することができます。

ベストプラクティスを要約するために、ディスプレイのリフレッシュレートを推測しないでください。

常に実行時にそれを照会します。

カスタム図面は、サポートされているフレームレートで柔軟で、異なるレートに適応する準備ができている必要があります。

targetTimestampを使用して、ヒッチのないフレームレートの移行を確保し、表示リンクコールバックを逃したなど、予期しない状況に目を離さないようにします。

では、締めくくりましょう。

このセッションの前半では、macOSのAdaptive-Syncディスプレイで実行しているときに、アプリのフレームペーシングを最適化する方法について議論しました。

後半では、iPad ProのProMotionディスプレイで、アプリがカスタム描画を推進し、あらゆる条件下でスムーズなフレームペースを維持するためのベストプラクティスについて説明しました。

ディスプレイ技術が進化し続けるにつれて、このセッションが洞察だけでなく、ディスプレイのますますダイナミックなタイミングをサポートするためのツールやベストプラクティスも提供してくれることを願っています。

ご参加いただきありがとうございます。WWDC 2021の残りの部分をお楽しみください。

[音楽]。