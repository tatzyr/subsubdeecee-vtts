10290

♪ベース音楽の演奏♪

♪

マーティ・パイ：「AVKitの新機能」へようこそ。

私の名前はマーティ・パイで、AVKitチームのエンジニアです。

今日は、ピクチャー・イン・ピクチャー、または短いPiP、およびmacOSのフルスクリーン体験に対して行った機能強化のいくつかについて話したいと思います。

ピクチャー・イン・ピクチャーから始めましょう。

ピクチャー・イン・ピクチャーを使用すると、ユーザーはデバイスでマルチタスクしながらビデオコンテンツを引き続き楽しむことができます。

たとえば、ビデオをフルスクリーンで見ていて、メッセージを受信した場合は、コンテンツを見続けながら、そのメッセージに簡単に返信できます。

ビデオは自動的にPiPに入り、返信が完了したら、すぐにフルスクリーン再生を再開できます。

これにより、本当にシームレスな視聴体験ができ、ユーザーはビデオを見ているときにこの動作を期待すると思います。

PiPを自分のアプリに統合する方法の詳細については、AVKitで直感的なメディア再生を提供するこの2019年のセッションを見ることをお勧めします。

今年の新機能、ビデオがインラインで再生されている場合は、ユーザーがホーム画面にスワイプしたときにPiPを自動的に入力することをオプションで許可できます。

この動作を有効にすると、canStartPictureInPicture AutomaticallyFromInlineプロパティを介して実現されます。

このプロパティは、ネイティブコントロールを使用するアプリのAVPlayerViewControllerと、独自のカスタムUIを実装するアプリのAVPictureInPictureControllerの両方で利用できます。

再生コンテンツがユーザーの主な焦点であることを意図している場合にのみ、このフラグをtrueに設定してください。

AVPlayerViewControllerを使用してビデオコンテンツを提示している場合は、PiPが処理されます。

あなたがする必要があることは何もありません。

AVPlayerViewControllerを使用していない場合でも、AVPictureInPictureControllerを使用して、ネイティブのPiPエクスペリエンスをアプリに持ち込むことができます。

まず、再生用にアプリのオーディオセッションカテゴリを設定し、PiPバックグラウンドモードを有効にする必要があります。

次に、pictureInPictureControllerを作成し、playerLayerへの参照を渡すだけです。

次に、ユーザーが指定したボタンを使用してピクチャ・イン・ピクチャを切り替えようとすると、コントローラオブジェクトのPiPの開始または停止を呼び出すだけです。

これまで、私たちのピクチャー・イン・ピクチャー体験はAVPlayerベースのコンテンツを中心に構築されていました。

本日、AVSampleBufferDisplayLayerの同じレベルのサポートを発表できることを嬉しく思います。

プレーヤーレイヤーでピクチャーインピクチャーコントローラーを作成する代わりに、まずContentSourceを作成し、AVPlayerLayerまたはここに示すようにAVSampleBufferDisplayLayerで設定します。

ユーザーの場合、ピクチャー・イン・ピクチャーのエクスペリエンスは同じになります。

開発者として、AVSampleBufferDisplayLayerのPiPのサポートに関連するいくつかの新しい責任があります。

この再生デリゲートを見てみましょう。

メディア再生はAVPlayerによって管理されていないため、PiP UIをレンダリングするために、新しいAVPictureInPictureSample BufferPlaybackDelegateを介して提供される再生状態情報に依存する必要があります。

ユーザーがPiP UIからメディアを制御しようとすると、それらのコマンドをデリゲートに転送して処理します。

5つの個別のコールバックを1つずつ確認しましょう。

setPlaying機能は、ユーザーがPiPウィンドウの再生/一時停止ボタンを押すと呼び出されます。

skipByInterval関数は、ユーザーがスキップボタンの1つを押すと呼び出されます。

これらのコールバックを使用して、それに応じてメディアを制御します。

timeRangeForPlayback関数を使用すると、現在再生可能な時間範囲を指定できます。

これにより、タイムラインをレンダリングし、再生ヘッドが現在どこにあるかを示すことができます。

有限の期間を持つ時間範囲には、常にサンプルバッファ表示レイヤーのタイムベースの現在の時刻を含める必要があります。

ライブコンテンツを示すために、無限の期間を持つ時間範囲を使用してください。

didTransitionToRenderSize関数は、ピンチツーズーム中など、ピクチャインピクチャウィンドウのサイズが変更されたときに呼び出されます。

不要なデコードオーバーヘッドを避けるために、メディアバリアントを選択する際には、このレンダリングサイズを考慮してください。

isPlaybackPaused関数は定期的に呼び出され、一時停止または再生状態を反映するかどうかをPicture in Picture UIに通知します。

これは概念的には、AVPlayerのtimeControlStatusと同等です。

次に、macOSのフルスクリーン体験に対して行った改善点をいくつか見てみましょう。

Big Surでは、Mac Catalystアプリでビデオをフルスクリーンで撮影すると、ビデオはウィンドウ全体を埋めますが、画面全体は埋めません。

macOS Montereyでは、ビデオが画面全体を取り上げます。

ネイティブのmacOSアプリとMac Catalystアプリの両方で、真のフルスクリーン体験になります。

再生コントロールは両方とも同じように見えます。

すべてのMac Catalystアプリは、この新しい動作を自動的に取得します。

ネイティブのmacOSフルスクリーンエクスペリエンスと同様に、ユーザーはアプリウィンドウにスワイプして戻ることができます。

オリジナルのビデオの代わりにプレースホルダが表示され、コンテンツがフルスクリーンで再生されていることを示します。

これは、ビデオがピクチャ・イン・ピクチャで再生されているときに表示されるプレースホルダと非常によく似ています。

ユーザーがコンテンツを選択した後にプレイヤービューコントローラーをフルスクリーンで表示するシナリオでは、ビューコントローラーは引き続きフルウィンドウに表示されます。

しかし、macOS Montereyの新機能では、ユーザーはウィンドウの左上にある緑色のフルスクリーンボタンを押すことで、真のフルスクリーン再生体験に切り離すことができます。

フルスクリーンのライフサイクルは、アプリケーションのニーズに基づいてより良いユーザーエクスペリエンスを提供するために明示的に管理できます。

例を見てみましょう。 例を見てみましょう。

すでに示したように、ユーザーはビデオをフルスクリーンで撮影し、再生が継続している間にアプリにスワイプバックできるはずです。

プレイヤービューコントローラーがビュー階層から削除されたとしても、アプリを自由にナビゲートできるはずです。

いつでも、スワイプするか、Mission Controlを使用してフルスクリーンビデオに戻ることができるはずです。

それでは、それを機能させる方法を見てみましょう。

あなたはplayerViewControllerのライフサイクルに責任があります。

最適なエクスペリエンスを実現するには、アプリのビュー階層になくても、playerViewControllerを存続させる必要があります。

それ以外の場合、ユーザーがビデオでページから離れると、playerViewControllerがリリースされるとフルスクリーン再生が終了します。

あなたがする必要があるのは、willBeginFullScreenPresentationコールバックを受け取ったときに、playerViewControllerへの強力な参照を維持することだけです。

その後、ユーザーがフルスクリーンを終了すると、willEndFullScreenPresentationコールバックを受け取ります。

これは、ユーザーが提示された元のビューから離れてナビゲートしたと仮定して、あなたが生き続けていたplayerViewControllerを手放す機会です。

ネイティブmacOSにも同じことが当てはまります。

新しいplayerViewDelegateを使用すると、playerViewWillExitFullScreenコールバックを受け取るまで、playerViewを存続させることができます。

ユーザーがフルスクリーンを終了すると、このrestoreUserInterfaceコールバックも受信します。

これは、あなたのユースケースに適していると仮定して、アプリがビデオを含む元のページに戻る機会です。

これは、ユーザーがPicture in Pictureを停止したときに受け取る既存のコールバックと非常によく似ています。

フルスクリーンからインラインへの移行をブロックしないように、できるだけ早くこの完了ハンドラーから戻るようにしてください。

Falseを返すと、復元が失敗した、または不可能であることを示します。その場合、コンテンツはアニメーションなしでフルスクリーンを終了します。

それで、今日のセッションを締めくくりたいと思います。

AVPlayerLayerの代わりにAVSampleBufferDisplayLayerを使用する場合、新しいコンテンツソースAPIを使用してアプリにピクチャーインピクチャーサポートを追加する方法を見ました。

macOSとMac Catalystでは、強化されたフルスクリーンエクスペリエンスを確認し、コードをシームレスに統合するために必要な手順を概説しました。

今日のセッションを楽しんでいただければ幸いです。これらの機能のいくつかがアプリに統合されるのを楽しみにしています。

会議の残りを楽しんでください。

♪