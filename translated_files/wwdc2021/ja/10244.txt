10244

♪ ♪

こんにちは、「App AttestとDeviceCheckで詐欺を軽減」へようこそ。

私の名前はXuerui Yanで、App Store Trust and Safetyチームで働いています。

App AttestとDeviceCheckを使用してアプリを保護することについて話すことに興奮しています。

Appleでは、App Storeが顧客や開発者にとって安全で信頼できる場所であることを常に確認しています。

このビデオでは、エンジニアリングの詳細について説明します。

ビジネスと概念の詳細については、WWDC 2021の「アカウント、プロモーション、コンテンツの保護」ビデオを参照してください。

iOS 11では、DeviceCheckフレームワークを導入しました。

DeviceCheckは、プロモーション製品の詐欺を軽減するのに役立ちます。

アプリに新機能を導入していると仮定します。

この機能を宣伝するために、無料の使い捨てアイテムを提供しています。

誰かが無料のアイテムを請求するためだけに何度も何度もアプリを再インストールすることで、プロモーションを悪用するかもしれません。

おそらく、アプリを繰り返しインストールしてプロモーションを再利用するのではなく、プロモーションアイテムをデバイスごとに1回に制限したいと思うでしょう。

現在、DeviceCheckは、デバイスがプロモーションオファーを受け取ったかどうか、またはデバイスが不正行為に参加したかどうかを検出するのに役立ちます。

これにより、1つのデバイスに関連付けられた2ビットの情報とタイムスタンプをAppleサーバーに永続的に保存できます。

これらのビットがアプリケーションにとって何を意味するかを決めるのはあなた次第です。

状態は、あなたが更新して照会するためにAppleによって維持されます。

ビットは開発者からのすべてのアプリによって共有されます。

すべてのアプリに適用できるように、ビットに意味を割り当てるときは、それを覚えておいてください。

状態は、アプリの再インストール、ユーザー間のデバイス転送、さらには「すべてのコンテンツと設定を消去」しても持続します。

プロモーションおよびビジネス戦略に基づいて、タイムスタンプを使用して選択した期間のビットをリセットすることを検討してください。

DeviceCheckの詳細については、WWDC 2017の「プライバシーとアプリ」ビデオとDeviceCheck Frameworkのドキュメントを参照してください。

それがDeviceCheckです。

次に、DeviceCheck Frameworkでも利用可能なApp Attestについて話します。

あなたのサービスがリクエストを受け取ると、それが本当にあなたのアプリからのものかどうかを知るのは難しいかもしれません。

App Attestを使用すると、アプリはリクエストの一部としてハードウェアに裏打ちされたアサーションを添付できます。

サーバーはアサーションを使用して、リクエストが本物のAppleデバイス上の本物のアプリから来たことを確認できます。

想像してみてください、あなたは収集品を発見するために旅行を奨励する美しいアプリを設計し、変更されたアプリが家を出ることなくすべてを集めることができることがわかりました。

または、競争力のあるマルチプレイヤーレースゲームで無制限のブーストを得るためにチートを使用して、他の人がリーダーボードをレースするのを見るプレイヤーの欲求不満を想像してみてください。

または、土曜日に目を覚まし、あなたのサーバーで非常に高いリクエスト量を見て、あなたの喜びを想像してみてください、しかし、調査の後、あなたは通話があなたのアプリからまったく来ていないことがわかります。

App Attestは、アプリの正規版と修正版を特定するのに役立ち、アプリ体験とビジネスを保護することができます。

App Attestは、あなたとあなたの顧客を保護するために利用できる3つの重要なプロパティを提供します。

App Attestを使用すると、3つの条件を満たすことで、アプリの正当なインスタンスからのリクエストをサービスで確認できます。リクエストは本物のAppleデバイスから来て、本物のアプリケーションを実行し、ペイロードが改ざんされていないこと。

App Attestがこれらのプロパティのそれぞれをどのように提供しているかを見てみましょう。

App Attestの中心には、安全なキーペアとAppleが署名した証明書があり、キーペアが本物のAppleデバイスに由来することを証明しています。

秘密鍵は、App Attest APIを使用してSecure Enclaveを通じてのみ保存され、アクセス可能です。

アプリはキーでサービスへのリクエストに署名することができ、サービスは署名をチェックして、リクエストが本物のAppleデバイスで生成されたことを確認できます。

Appleデバイスでアプリを実行するには、署名が必要です。

アプリに不正な変更を加える人は、自分が管理するIDで再署名する必要があります。

これは必然的にアプリのアイデンティティを変更します。

認証には、アプリのIDのハッシュを含めます。

アプリのIDと認証に含まれるものを比較することで、発信者が変更されたバージョンを使用しているかどうかを判断できます。

リクエストが本物のデバイスと本物のアプリから来たことがわかったので、リクエストペイロードについて話しましょう。

ペイロードをサーバーに送信する前に、証明されたキーを使用してペイロードのダイジェストに署名するようにApp Attestに指示できます。

これにより、ペイロードのアサーションが作成されます。

アプリは、ペイロードとアサーションをサービスに送信する必要があります。

ペイロードに対するアサーションを検証することで、ペイロードが輸送中に改ざんされていないことを信頼できます。

これらは3つの重要な特性です。

では、プライバシーについて少し話しましょう。

ここアップルでは、プライバシーを深く気にかけています。

私たちは、プライバシーが健全なアプリエコシステムにとって不可欠な基盤であると信じています。

App Attestの各要素は、プライバシーを念頭に置いて構築されています。

認証は、追跡から保護しながら、本物のデバイスの保証を提供するように設計されています。

認証は匿名で、ハードウェア識別子は含まれていません。

App Attestキーは、アプリのインストールごとに一意です。

これは、App Attestキーがアプリの再インストールに耐えられず、バックアップされず、デバイス間で同期されないことを意味します。

アプリを設計するときは、これを覚えておいてください。

App Attestが提供する価値を理解したので、アプリに組み込む詳細を掘り下げてみましょう。

App Attestをアプリに組み込むための3つの基本的な部分があります。

App Attestキーを作成し、キーを証明および検証し、アサーションを生成および検証します。

App Attestキーの作成から始めましょう。

すべてのApp Attestコールは、isSupportedプロパティによって保護されるべきです。

App AttestはSecure Enclaveを持つデバイスでサポートされていますが、App Extensionsなど、isSupportedが依然としてfalseを返す場合があります。

アプリはこれらのケースを適切に処理する必要があります。

すぐにアクセスをブロックするのではなく、障害をリスクシグナルとして使用してください。

まず、発信者を信頼できないものとして分類します。

次に、リスク評価ロジックに基づいて、クライアントが機密性の高い機能を使用できるようにするかどうかを評価します。

もう1つのアプローチは、サービスを呼び出すときにApp Attestをサポートしていないと主張するデバイスの急激な増加を監視することです。

App Attestをサポートするデバイスの比率が突然減少した場合、変更されたアプリがチェックをバイパスしようとしている兆候である可能性があります。

App Attestキーが正常に生成されたら、先に進んでキーを証明しましょう。

中間者攻撃やリプレイ攻撃を防ぐには、1回限りのサーバーチャレンジが必要です。

サーバーにアプリへのチャレンジを発行してもらいましょう。

認証をユーザーアカウントIDまたはその他の値にリンクするには、それらの値をハッシュしてclientDataHashを作成するチャレンジします。

clientDataHashを使用して、前のステップのkeyIdとともに、attestKey APIを呼び出すことができます。

attestKeyは秘密鍵を使用してデバイスのハードウェア認証要求を作成し、確認のためにAppleに要求を送信します。

確認後、Appleは匿名の認証オブジェクトをアプリに返します。

認証は、カスタムペイロードとともに、検証のためにサーバーに送り返します。

さて、アプリが認証をサーバーに送信したので、確認してみましょう。

認証はWeb認証基準に従っており、Appleが署名した証明書のリスト、Authenticatorデータ構造、およびリスクメトリックの領収書の3つの部分が含まれています。

確認する必要がある重要な部分を見てみましょう。 確認する必要があります。

証明書セクションには、リーフ証明書と中間証明書が含まれています。

App Attestルート証明書は、Apple Private PKIリポジトリで入手できます。

完全な証明書チェーンを検証すると、デバイスが本物のAppleデバイスであることがわかります。

attestKeyを呼び出すと、nonceと呼ばれるシングルユースハッシュがclientDataHashやその他のデータから作成されました。

そのノンスは葉の証明書に含まれています。

改ざんを防ぐために、サーバー上のノンスを再構築し、それが一致することを確認します。

オーセンティケータデータブロックには、アプリIDのハッシュを含む複数のプロパティが含まれており、アプリがあなたを呼び出していることを確認するために使用できます。

キー認証には、Appleにリスク指標を要求するために保管して後で使用できる領収書も含まれています。

それについての詳細は、ビデオの後半で取り上げます。

すべてがチェックアウトされた場合、App Attestキーは本物です。

後続の要求を検証するために使用するために、クライアントデータに関連付けられたキーを保存します。

すべての失敗が無効な認証によるものというわけではありません。

isSupportedがfalseを返す、ランプアップ中にスロットルされる、または一般的なネットワーク障害などのシナリオを優雅に処理します。

その後、全体的なリスク評価に障害をシグナルとして組み込むことができます。

検証の実施の詳細については、ドキュメントを参照してください。

attest-Key APIを呼び出すと、アプリからApp Attestサービスへのネットワークコールが生成されます。

これは、アプリインスタンスごとに1回しか発生しません。

ただし、インストールベースが大きい場合、アプリはApp Attestに多くのリクエストを送信する可能性があります。

リソースを管理し、レートの制限を避けるために、インストールベース全体でこの機能を徐々に有効にしてください。

たとえば、毎日100万人のアクティブユーザーがいる場合、おそらく1日かそこらでランプアップすることができます。

毎日10億人のアクティブユーザーがいるなら、お疲れ様でした!

あなたは1ヶ月以上ランプアップする必要があります。

認証されたキーがわかったので、generateAssertion API呼び出しを使用して、アプリとサーバー間の機密性の高い通信を保護できます。

Appleのサーバーはもはや関与していないため、アサーションフローは認証よりも簡単です。

キーを使用するすべてのアサーションは、デバイス上で生成され、サーバー上で検証されます。

まず、サーバーに一意のチャレンジを要求し、ペイロードのダイジェストを生成し、generateAssertionを呼び出します。

generateAssertionは、ダイジェストを使用してノンスを計算し、App Attestキーで署名します。

その後、アプリはペイロードとアサーションをサーバーに送信できます。

最後に、サーバーはペイロードを確認する必要があります。

アサーションペイロードには、この高レベルの構造が含まれています。

署名と認証データ。

署名を検証するには、プロセスを逆にしてサーバー上のノンスを再構築します。

次に、公開鍵を使用して署名を確認します。

署名が有効な場合は、ペイロードが変更されていないことを信頼できます。

オーセンティケータデータセクションには、アプリのIDハッシュが含まれています。

ハッシュを検証して、アサーションが本物のアプリからのものであることを確認します。

オーセンティケータデータには、増え続けるカウンターも含まれています。

リプレイ攻撃から保護するために、カウンター値をサーバーに保存し、その後のリクエストごとに増加することを期待します。

キーを使用すると、必要なだけこのプロセスを繰り返すことができます。

アサーションを生成することはAppleサーバーを呼び出すことはありませんが、それはいくつかのレイテンシを追加する暗号化操作です。

App Attestをアプリに組み込むときは、これをデザインに組み込む必要があります。

アサーションは、重要だがまれな呼び出し、および追加のレイテンシと必要な計算に対処できる呼び出しに適しています。

頻繁なリアルタイムネットワークコマンドの場合、アサーションは適していない可能性があります。

おめでとうございます！

これで、App Attestの基本的な実装が完了しました。

この実装だけで、着信サーバー要求を本物で変更されたものとして分類し始め、この重要な詐欺信号をビジネスロジックに組み込むことができます。

しかし、もっとあります。

攻撃者は、単一のデバイスを使用して多くのApp Attestキーを作成し、そのデバイスを使用して多くの変更されたアプリとサーバー間の通信を提供することで、App Attestを回避しようとする可能性があります。

このような動作を検出するために、アプリのデバイスに作成されたキーのおおよその数を提供するApp Attest Risk Metric Serviceと呼ばれるサービスを提供しています。

attestKeyは、認証とリスクメトリックの領収書の両方を返すことを思い出してください。

サーバーは、その領収書をサービスに送信し、新しい領収書と引き換えることができます。

新しい領収書にはリスク指標が含まれます。

定期的に、最新の領収書をそのアプリ/デバイスペアの更新されたメトリクスに引き換えることができます。

これは、レシート構造の高レベルのビューです。

それはPKCS7コンテナです。

詳細については、DeviceCheck Frameworkドキュメントの「詐欺リスクの評価」を参照してください。

App ClipsはiOSのエキサイティングな機能です。

iOS 15のApp ClipsにApp Attestのサポートを追加しました。

App Clipからフルアプリへのシームレスなアップグレードをサポートするために、App ClipとフルアプリはApp Attestコンテキストで同じアプリIDを共有します。

サーバー側でアプリのIDを確認するときは、この点に留意してください。

App Clipsが手動で削除または期限切れになると、完全なアプリがアンインストールされたときと同じように、そのキーは無効になります。

はい、App Clipsはそれでおそれです。

さて、App Attestで成功するためのこれらの重要なポイントを覚えておいてください。

デバイス上ではなく、サーバーで検証します。

アプリは、検証コードを無効にするために変更される場合があります。

ネットワークリプレイ攻撃を防ぐために、ワンタイムサーバーチャレンジをフローに組み込みます。

isSupportedがfalseを返す、ランプアップ中にスロットルされる、または一般的なネットワーク障害などの障害シナリオを処理します。

リスク評価のシグナルとして失敗を組み込む。

App AttestとDeviceCheckは、全体的な不正評価に統合できる情報を提供します。

DeviceCheckを使用して、プロモーション製品の詐欺を軽減します。

App Attestを活用して、アプリの変更されたバージョンを検出し、コンテンツとユーザーエクスペリエンスを保護します。

見てくれてありがとう!

あなたのアプリがApp AttestとDeviceCheckで保護されるのを楽しみにしています。

平和！