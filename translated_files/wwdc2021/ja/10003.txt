10003

- こんにちは！WWDCへようこそ。

私の名前はアン・ヒッチコックで、Watch Frameworksチームのエンジニアです。

今日ここに来て、Apple Watchのデータ転送戦略について話すことに興奮しています。

導入以来、Apple Watchはますます独立しています。

シリーズ3は、携帯電話機能を備えた最初のApple Watchでした。

watchOS 6の独立した時計アプリは、iOSコンパニオンを必要とせず、顧客の時計のApp Storeから購入できるアプリを書く機能を提供しました。

watchOS 7でのファミリーセットアップの導入により、お客様はコンパニオンiPhoneを持っていなくても、これまで以上に自立しています。

しかし、これらの新機能は、開発者として、Watchアプリとのコミュニケーションに関する考え方に新たな課題を提示します。

幸いなことに、私たちには素晴らしい選択肢がたくさんあります。

今日は、これらのオプションと、その仕事に適したものを選ぶ方法について話します。

Watchアプリでのデータ通信のためのツールの概要を説明し、どれがタスクに適した選択になるかを評価する方法について説明します。

ツールをいくつかのカテゴリに大きく分類できます。

iCloudを使用すると、すべてのデバイスと共有でき、サーバーストレージを提供します。

iCloud同期のKeychainとCloudKitのCoreDataを使用して、アプリでこれを使用できます。

ペアリングされたデバイス間でデータを転送する必要がある場合は、Watch Connectivityを使用できます。

サーバーと直接通信するには、URLセッションまたはソケットを使用できます。

しかし、まず、あなたが正しいものを選ぶために尋ねることができる質問について話します。

Watchアプリからどのようにコミュニケーションをとるかを考えるとき、いくつかのことを考えます。

それはどんな種類のデータですか?

そして、データは今どこにあり、どこにそれが必要ですか?

インタラクションはコンパニオンiOSアプリに依存していますか?

ファミリー設定をサポートしたいですか?

そして、データはいつ目的地にある必要がありますか?

システムが顧客のパフォーマンスとバッテリー使用量を最適化するのを待つことができますか?

データはどのくらいの頻度で変更されますか?

これらの質問に対する私の答えに基づいて、私はデータ転送タスクのための適切なソリューションを作成する方法を評価するために私のツールボックスを通過し始めることができます。

iCloud同期でキーチェーンから得られる機能を見てみましょう。

キーチェーンは、パスワード、キー、その他の機密性の高い資格情報のための安全なストレージを提供します。

また、watchOS 6.2で導入されたiCloudキーチェーン同期により、これらのキーチェーンアイテムを人のすべてのデバイスに同期させることができます。

アプリでiCloud同期の恩恵を受けるには、関連するドメインと共有キーチェーンアイテムでパスワードの自動入力を使用する2つの方法があります。

パスワードの自動入力により、非常に少ないコードでキーチェーン同期を使用できます。

まず、関連ドメイン機能をターゲットに追加します。

Watchアプリでは、WatchKit Extension Targetに機能を追加します。

ドメイン名でwebcredentialsエントリを追加します。

Apple-app-site-associationファイルをウェブサーバーに追加します。

ファイルは、リダイレクトなしでHTTPS経由でアクセス可能でなければなりません。

ファイルはファイル拡張子のないJSON形式であり、サーバーの./well-knownディレクトリに配置する必要があります。

詳細については、「関連ドメインのサポート」のオンラインドキュメントをご覧ください。

テキストフィールドと安全なフィールドにテキストコンテンツタイプを追加します。

自動入力のオプションは、ユーザー名、メールアドレス、パスワード、および新しいパスワードです。

新しいパスワードの場合、システムは人に保存するように促し、サイトのキーチェーンにレコードが追加または更新されます。

自動入力の提案は、watchOS 6.2から利用可能であり、watchOS 8の新しいテキスト編集体験でさらに優れています。

パスワードの自動入力の使用の詳細については、Developerアプリまたはオンラインで「どこでも自動入力」セッションをチェックしてください。

キーチェーン同期を使用してデータを共有するもう1つの方法は、アプリ間でキーチェーンアイテムを共有することです。

議論したように、キーチェーンは、パスワード、キー、資格情報などの機密データのための安全なストレージです。

情報が頻繁に変更されない限り、起動画面に対する人の好みなど、他の小さな共有データをキーチェーンに保存することもできます。

キーチェーンに保存されているデータは、その人のすべてのデバイスに同期されます。

キーチェーンにOAuth 2トークンを保存して取得し、それをアプリのグループと共有する方法を見てみましょう。

まず、キーチェーン共有またはアプリグループ機能、これらのキーチェーンアイテムを共有したいすべてのアプリを追加する必要があります。

これはアイテムを共有するために必要であり、他のアプリによるアクセスを防ぐことで、顧客の情報のセキュリティとプライバシーを確保するのに役立ちます。

Watchアプリでは、Watch Extensionターゲットに機能を追加します。

この例では、キーチェーン共有機能を追加し、アプリをキーチェーングループに追加します。

キーチェーンアイテムを共有するすべてのアプリは、このグループも共有する必要があります。

では、OAuth 2トークンをキーチェーンに保存するコードを見てみましょう。

トークンを保存するには、アイテムが存在する場合はアイテムを更新し、存在しない場合は追加します。

トークン文字列、有効期限、リフレッシュトークンなどのトークンデータを含むOAuth 2トークン構造体を作成しました。

保存と取得を容易にするために、トークン構造体をcodableに適合させました。

クエリ辞書を作成します。

これは、このサーバーとアカウント用にすでに保存されている場合、既存のアイテムに一致する属性のセットです。

ここで「true」に設定されている同期可能な属性に注意してください。

アイテムをお客様のすべてのデバイスに同期させたいことを示すために、この属性をクエリに含めることが重要です。

トークンをデータとしてエンコードし、そのデータを属性辞書のキーチェーンアイテムの値として設定します。

次に、クエリと属性でキーチェーンのアイテムを更新します。

キーチェーンAPIから返された結果コードを常に確認する必要があります。

まず、キーチェーンにアイテムが見つからないと表示されているかどうかを確認します。

もしそうなら、私たちが書いた別の関数を呼び出して、それをキーチェーンに追加します。

私たちはすぐにそれを見ます。 

それ以外の場合は、エラーがなかったことを確認します。

そのためには、成功結果を確認します。

更新機能が成功を返した場合、トークンはキーチェーンで更新されました。

では、追加機能を見てみましょう。

キーチェーンにトークンを追加するには、すべての属性を持つ辞書を設定します。

これには、既存のアイテムを見つけるために使用した属性とトークンデータが含まれます。

次に、キーチェーンAPIの追加関数を属性で呼び出します。

そして、リターンコードをチェックして、それが成功したことを確認してください。

キーチェーンからトークン情報を取得するには、必要なアイテムを見つけるためにクエリ辞書を設定します。

更新機能で以前にアイテムを見つけるために含めたのと同じキーと値のセットを含めます。

さらに、アイテム属性を返すかどうか（返さない）、アイテムデータを返すかどうか（返す）かどうかをキーチェーンAPIに伝えるために、いくつかの属性が含まれています。

キーチェーンの「コピーマッチング」関数は、クエリを使用して検索し、提供した参照を「アイテム」として入力します。

取得したアイテムにアクセスする前に、返品コードが見つかったことを確認します。

その後、いつものように、リターンコードが成功することを確認します。

アイテムにコピーされた辞書を取得し、辞書から要求したトークンデータを取得し、データをOAuth 2トークンタイプとしてデコードします。

そして今、OAuth 2トークンをキーチェーンに正常に保存、更新、取得し、キーチェーン共有グループのすべてのアプリと共有されています。

あなたと共有したいキーチェーンストレージ機能がもう1つあります。

顧客のデバイスに何かを保存する場所と同じように、それが終わったら削除する必要があります。

検索するために、現在馴染みのある属性でクエリを設定します。

クエリでキーチェーンAPIの削除関数を呼び出します。

そして、いつものように、成功を確認してください。

削除の場合、見つかりません。

さて、データが終わったらクリーンアップを終えます。

iCloudキーチェーン同期を備えたキーチェーンサービスは、アプリが頻繁に変更されない小さなデータを共有するための素晴らしい方法であり、そのデータは人のすべてのデバイスに同期されます。

関連ドメインを使用すると、アプリにパスワードの自動入力機能を簡単に追加できます。

また、キーチェーンに直接値を保存して取得し、キーチェーン共有またはアプリグループを使用して他のアプリと共有することもできます。

iCloudキーチェーンの同期は、iOSコンパニオンアプリに依存せず、ファミリー設定をサポートしています。

アイテムは、ネットワークの可用性、バッテリー、その他のシステム条件に基づいて、可能な限り同期されます。

お客様はiCloudキーチェーンの同期を無効にすることができ、すべての地域で利用できるわけではないことに注意してください。

CloudKitを使用したCoreDataは、ローカルデータベースを、アプリのCloudKitコンテナを共有する顧客の他のすべてのデバイスに同期します。

CoreDataとSwiftUIの統合により、Watchアプリケーション内のデータベースからのデータへのアクセスと表示が簡素化されます。

マルチプラットフォームアプリケーションを開発している場合は、この方法でWatchであまりにも多くのデータをすばやく取得できます。

顧客が時計で本当に必要とする情報を慎重に考えてください。

コアデータモデルで複数の構成を使用して、より多くのストレージとバッテリー容量を持つデバイスで実行されているアプリに適したデータから、Watchアプリに持つことが理にかなっているデータをセグメント化することを検討してください。

CloudKitとコアデータは強力なツールです。

Core DataとSwiftUIの統合により、アプリでCore Data機能の使用が容易になります。

管理オブジェクトコンテキスト」を環境値でビューに提供し、フェッチリクエストプロパティラッパーを使用してデータベースから結果を取得できます。

これらの結果は、SwiftUIリストやその他のビューで使用できます。

CloudKitを使用したコアデータは、すべてのデバイスに同期し、iCloudにバックアップできる構造化データを共有する方法を提供します。

コンパニオンiPhoneアプリに依存せず、ファミリー設定をサポートしています。

コアデータの変更の同期は、ネットワークの可用性とシステム条件に基づいて行われます。

瞬間的であることを期待しないでくださいが、CloudKitはアプリのこの同期のパフォーマンスの最適化を処理します。

アプリでCloudKitでCore Dataを使用する方法の詳細については、Developerアプリまたはオンラインの「Build apps that share data through CloudKit and Core Data」と「Bring Core Data concurrency to Swift and SwiftUI」をチェックしてください。

あなたはすでにWatch Connectivityに精通しているかもしれませんし、以前に使用したことがあるかもしれません。

しかし、私はあなたが成功するのを助けるために、より多くの詳細といくつかのベストプラクティスを提供したいと思います。

Watch Connectivityを使用すると、両方のデバイスがBluetooth範囲内または同じWi-Fiネットワーク上にある場合、WatchアプリとそのコンパニオンiPhoneアプリ間でデータを送信できます。

携帯電話とWatchアプリの両方がインストールされている場合に、顧客体験を最適化し、1つのデバイスでしか利用できないデータを共有するのに最適です。

たとえば、誰かがiPhoneアプリを起動し、最新のデータをダウンロードした場合、そのデータをWatchアプリと共有して、合併症を最新の状態に保ち、Watchアプリが次回起動時に同じデータで開始できるようにすることができます。

これにより、顧客にとってより反応が良くなり、アプリが行う必要がある重複したデータのダウンロードを最小限に抑えることができます。

ウォッチコネクティビティには多様な機能があるので、何が利用可能で、いつそれぞれを使うべきかを知ると便利です。

しかし、まず、Watch Connectivityがタスクに適したツールであると判断した場合、成功に役立ついくつかのヒントを共有したいと思います。

Watch Connectivityは2つのデバイス間で通信するためのツールであるため、いくつかの前提条件について知り、いくつかのエラーを処理する必要があります。

これらは、ウォッチコネクティビティ通信がスムーズに機能するようにするためにできることです。

アプリのライフサイクルの早い段階で、できればアプリまたは拡張機能デリゲートでアプリの起動が終了したら、時計接続セッションをアクティブにします。

これにより、アプリはできるだけ早く対応するアプリから情報を受信できるようになります。

到達可能性を理解する。

バックグラウンド通信のいずれも、データを送信するときに相手のアプリに到達可能である必要はありません。

しかし、インタラクティブメッセージングには到達可能性の要件があり、その後それらについて説明します。

それらを理解する時間を節約できます。

すべてのウォッチ接続セッションデリゲート関数は、非メインのシリアルキューで呼び出されます。

ユーザーインターフェイスを更新するためにこれらの機能から作業を行う必要がある場合は、メインキューで行うようにしてください。

さて、さまざまなWatch接続機能と、それぞれを使用するタイミングについて話しましょう。

アプリケーションコンテキストは、バックグラウンドで対応するアプリに送信される単一のプロパティリスト辞書であり、アプリが起動したときに利用可能になることを目的としています。

前の辞書が送信される前にアプリケーションコンテキストを更新すると、新しい値に置き換えられます。

アプリケーションコンテキストは、新しいデータがあるときに、対応するアプリのコンテンツを最新の状態に保つことや、頻繁に更新される可能性のあるデータに役立ちます。

ユーザー情報転送は、バックグラウンドで対応するアプリにプロパティリスト辞書も送信しますが、アプリケーションコンテキストとは少し異なります。

更新するたびに置き換えられる単一の辞書ではなく、各ユーザー情報辞書の転送はキューに入れられ、キューに入れた順序で配信されます。

キューにアクセスして転送をキャンセルすることもできます。

ファイル転送はユーザー情報転送に似ており、一度行うと、もう一方は身近に感じるでしょう。

ファイルは、対応するアプリに送信されるキューに入れられ、電源やその他の条件が許せば送信されます。

キューにアクセスして転送をキャンセルできます。

ファイルは、転送されると、受信アプリのドキュメント受信トレイに配置されます。

セッションデリゲートで受信したファイルコールバックから戻ると、各ファイルは受信トレイから削除されます。

この方法から戻る前に、必ずファイルを移動するか、すぐに処理してください。

これについて覚えておくべき1つの役に立つこと：このコールバックは非メインのシリアルキューで呼び出されるため、受信トレイからファイルを処理するために非同期メソッドを呼び出すと、ファイルがなくなるため、問題が発生する可能性が最も高いです。

ファイル転送のタイミングはシステム条件に基づいており、もちろん、より大きなファイルは転送に時間がかかる場合があります。

transferCurrentComplicationUserInfo(_:)は、コンプリケーション関連のデータをWatchに送信するユーザー情報転送機能の特別なケースです。

予算に複雑な転送が残っている限り、他のユーザー情報の転送に先立って、できるだけ早く転送されます。

この即時転送により、携帯電話からデータを更新したときに、アクティブなコンプリケーションを顧客の最新の状態に保つことができます。

残りの予算を確認できますが、残りの予算なしで現在の合併症情報を転送しても、まだ送信されます。

通常のユーザー情報転送キューを使用するだけです。

sendMessageを使用して、相手のアプリにデータを送信し、返信を受け取ることができます。

これは、相手のアプリが到達可能な場合のインタラクティブなメッセージング用です。

辞書やデータを送信する場合でも、メッセージを小さくしてください。

また、sendMessageコールに返信ハンドラを含めることを選択することをお勧めします。

短い返信で、相手のアプリがメッセージを受信し、データが正しかったことを確認できます。

sendMessageにその返信ハンドラを含める場合は、返信ハンドラを含む相手アプリで、受信したメッセージまたは受信したデータデリゲートコールバック機能のバージョンを実装していることを確認してください。

そうしないと、メッセージを送信するときにエラーが発生します。

sendMessageについて聞いたので、到達可能性の概念を再検討しましょう。

メッセージを送信するには、両方のアプリに到達可能である必要があります。

Watch ConnectivityセッションでisReachableプロパティをチェックして、相手のアプリがライブの非バックグラウンドメッセージングに到達できるかどうかを判断できます。

しかし、到達可能とはどういう意味ですか?

両方のデバイスは、Bluetoothを介して、または同じWi-Fiネットワーク上にある必要があります。

WatchKit拡張機能に到達可能になるには、長時間実行されるバックグラウンドセッションを実行する場合と同様に、フォアグラウンドで実行するか、優先度の高いバックグラウンドで実行する必要があります。

iOSアプリには、このフォアグラウンド要件はありません。

WatchアプリからiOSアプリにメッセージを送信し、iOSアプリがフォアグラウンドにない場合、iOSアプリはメッセージを受信するためにバックグラウンドでアクティブになります。

これは、iOSアプリがWatch Extensionからはるかに多くアクセスできることを意味します。

Watch Connectivityは、iPhoneとWatchアプリの両方をインストールしたときに、タイムリーで応答性があり、直感的に感じられる体験を顧客に提供するための良い方法です。

ウォッチコネクティビティは、特に電話とペアリングされたウォッチの間で通信しているため、ファミリーセットアップのアプリをサポートするために使用しないでください。

データ転送は、BluetoothまたはWi-Fiを介したコンパニオンデバイスの可用性に依存します。

sendMessageを使用したリアルタイム通信では、相手が到達可能である必要があります。

特にWatchアプリと通信しようとしているときは、相手のアプリにはあまり連絡が取れないことを覚えておいてください。

バックグラウンド転送はすぐには配信されません。

手紙を投稿するように考えてください。箱に落としますが、いつそこにあるのか正確にはわかりません。

ウォッチコネクティビティの詳細については、開発者アプリまたはオンラインで「ウォッチコネクティビティの紹介」をご覧ください。

次に、サーバーと直接通信するいくつかの方法について話します。

ほとんどのユースケースでは、最適なオプションはURLセッションです。

インタラクションとデータの種類によっては、コミュニケーションを延期したり、すぐに行う必要があるかもしれません。

そのため、URLセッションをバックグラウンドまたはフォアグラウンドで実行できるように、URLセッションには異なる設定があります。

これらの各オプションをいつ使用すべきかを見てみましょう。

可能な限りバックグラウンドセッションを使用する必要があります。

これは開発者としての最初の本能ではないかもしれませんが、すぐにデータを取得または送信したいと思うかもしれません。

しかし、本当にそれについて考えてください。

フォアグラウンドセッションは、アプリがフォアグラウンドまたは最前面にある間に完了する必要があり、最短のタスクを除くすべてのタスクでは、これは十分な時間ではありません。

コミュニケーションタスクが失敗した場合、顧客の体験について考えてください。

だから、顧客に配慮し、各コミュニケーションタスクを慎重に評価し、「バックグラウンドでこれを行うことはできますか?」と尋ねてください。

バックグラウンドURLセッションは、通信が遅れる可能性のある時間や大規模なデータ転送のための正しい選択です。

また、アプリにプッシュ通知を送信して、新しいデータが利用可能であることを示し、バックグラウンド更新を開始することもできます。

バックグラウンド転送の正確なタイミングは、システム条件によって異なります。

バックグラウンドでサーバーにデータを送信する例を見てみましょう。

たとえば、Webサーバーを介して保存したいアプリケーションの設定がある場合は、顧客がそれらを保存したときに、ウォッチに保存し、バックグラウンドでサーバーに送信できます。

これを行うには、サーバー通信の作業を処理するためのバックグラウンドURLセッションクラスを作成しました。

私たちのURLセッションには、後でそれを見つけるために使用できる一意の識別子を持つバックグラウンド設定があります。

セッションのタスクを処理する必要があるときに、セッションがバックグラウンドでアプリを起動する必要があることを示すために、seds launch eventsプロパティをtrueに設定します。

大量のデータを転送する場合は、URLセッション設定のisDiscretionaryプロパティをtrueに設定して、システムが最良のパフォーマンスを得るためにデバイスに最適なタイミングで転送をスケジュールできるようにする必要があります。

この場合、Wi-Fiと電源に接続されるまでダウンロードが起こらない可能性があることを顧客に知らせる必要があります。

データを送信する準備ができたら、バックグラウンドセッションをスケジュールするために転送をキューに入れる必要があります。

サーバーへの設定更新の内容を含むURLリクエストを作成して設定します。

次に、セッションでリクエストのタスクを作成します。

この簡略化された例では、セッションに1つのタスクを追加するだけですが、効率のためにセッションに複数のリクエストを追加できます。

後でダウンロードを開始するには、最も早いBeginDateを設定します。

システムは、バックグラウンド予算、ネットワーク、およびシステム条件に基づいて、タスクの実際の開始時間を決定することに注意してください。

アクティブな文字盤に合併症がある場合、アプリは1時間あたり最大4つのバックグラウンドリフレッシュタスクを受け取ることができるので、システムによって遅れないように、少なくとも15分間隔でタスクをスケジュールしてください。

進行中のセッションのリストでこのセッションを保持しています。 

これは、システムが私のURLリクエストが完了したことを私に知らせるとき、後で重要になります。

タスクで「再開」を呼び出すと、実際に開始されるので、これを呼び出すことが重要です。

最後に、セッションのオブザーバーがいる場合に備えて、ステータスをキューに入れるように設定しました。

拡張デリゲートに送信されたバックグラウンドタスクを使用して、バックグラウンドリクエストが処理されると、システムはアプリに通知します。

そのタスクを処理するには、WK拡張デリゲートに準拠したクラスを作成し、handle(_ backgroundTasks:)関数を実装する必要があります。

バックグラウンドURLセッションの更新タスクでは、進行中のリクエストのリストでセッションを見つけようとします。

それがあれば、セッションの関数を呼び出すと、セッションのリストにバックグラウンド更新タスクが追加されます。そうすれば、データの処理が終了したらすぐに完了したことをシステムに知らせることができます。

すぐにお見せします。

リストにセッションが見つからない場合は、タスクを完了としてマークする必要があります。

完了したらすぐに完了するバックグラウンドリフレッシュタスクを常に設定することが非常に重要です。

バックグラウンドタスクコールを取得するために行う必要があることがもう1つあります。拡張デリゲートをアプリに接続する必要があります。

これを行うには、Extension DelegateクラスでWK拡張デリゲートアダプタープロパティラッパーを使用し、アプリにプロパティを追加します。

これで、システムは拡張デリゲートを呼び、バックグラウンドタスクを処理します。

拡張デリゲートでは、この関数を呼び出して、バックグラウンドタスクを既存のセッションに追加しました。

このタスクをバックグラウンドタスクのリストに追加すると、URLデータの処理が完了したらすぐに完了としてマークできます。

今、私たちは往復全体を配線し、私たちに残されたのは、データを取得し、私たちが終わったことをシステムに知らせることだけです。

リクエストが完了すると、URLセッションのダウンロードデリゲートが呼び出されます。

ダウンロードタスクからファイルで受信したデータを処理します。

このアイテムをアプリからアクセス可能なディレクトリに移動するか、ファイルからデータをすばやく処理することが重要です。

このタスクが完了すると、ダウンロードしたファイルは削除されます。

このセッションは、拡張デリゲートからバックグラウンドタスクがこれ以上取得されないため、プロセス中のセッションのリストからこのセッションを削除し、オブザーバーがいる場合に備えてステータスを完了に設定しています。

最後に、バックグラウンドタスクの完了を設定しています。

これにより、バックグラウンド処理が完了したことをシステムに知らせます。

これを行うことを確認することは、単に良いウォッチアプリの市民であることではありません。

バックグラウンド制限を超えて、システムがアプリを終了するのを防ぎます。

そして、それだけです!

設定をバックグラウンドで送信し、更新を取得するのは終わりました。

完全な実装では、エラーや認証の課題を処理したいと思うでしょうが、これは基本的な手順を提供します。

人があなたのアプリと対話している間、迅速なサーバー通信のためにフォアグラウンドURLセッションを使用してください。

これの良い例は、最新のワークアウトリストやその日の瞑想を取得することです。

フォアグラウンドURLセッションは、データを取得して送信するための電力効率の低い方法であり、2分半のタイムアウトが強制されます。

しかし、実際には、その制限よりもはるかに速いインタラクションにフォアグラウンドセッションをターゲットにしようとする必要があります。

URLセッションは、サーバーと直接の一般的な目的の通信に最適な方法です。

彼らはコンパニオンiPhoneアプリに頼らず、ファミリーセットアップをサポートするアプリで使用できます。

データ転送を遅らせる可能性のある場所や、常に大量のデータを転送するために、バックグラウンドセッションを使用してください。

URLセッションの詳細については、開発者アプリまたはオンラインで「コンプリケーションを最新の状態に保つ」と「バックグラウンド実行の謎を解く」をチェックしてください。

URLセッションに加えて、ストリーミングオーディオアプリを構築する場合、ソケットはサーバーと直接通信する別のオプションです。

アクティブなストリーミングオーディオセッションのコンテキストで、ウォッチアプリでHTTPライブストリーミングまたはWebソケットを使用できます。

Socketsの使用の詳細については、Developerアプリまたはオンラインで「watchOS 6のストリーミングオーディオ」セッションをチェックしてください。

私たちは多くのことをカバーしたので、私たちが見たすべてのオプションの中からどのように選択できるかをまとめましょう。

すべての人のデバイスに同期できる小さな機密データについては、iCloud同期のキーチェーンを選択します。

データベースをiCloudに保存し、すべての人のデバイスと共有するには、CloudKitでCore Dataを選択します。

コンパニオンiPhoneとWatchアプリのエクスペリエンスを最適化するか、コンパニオンアプリで1つのデバイスでのみ利用可能なデータを共有するには、Watch Connectivityを選択します。

サーバーと直接通信するには、URLセッションを選択します。

ストリーミングオーディオアプリには、ソケットを使用することもできます。

ファミリーセットアップを使用しているお客様、またはモバイルデータ転送を使用しているお客様をサポートするには、iCloud同期付きキーチェーン、CloudKit付きコアデータ、URLセッション、またはソケットを選択してください。

仕事に適したツールを選択するのに役立つソリューションを選択する前に、データの種類、そのソースと宛先、および顧客オーディエンスについて考えてください。

そして、デバッガに接続されていないデバイスでアプリをテストして、デバッガを展開する前に、実際の状況での動作を検証してください。

あなたのWatchアプリでデータ転送のために私たちが持っているすべての素晴らしいツールについて学ぶために来てくれてありがとう。

あなたが次に何を作るかを見るのが待ちきれません。

[音楽]。