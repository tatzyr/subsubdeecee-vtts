10146

♪ベース音楽の演奏♪

♪

アダム・ソナンスタイン:こんにちは!私の名前はアダムです。今日、AVFoundationの新機能をお見せします。

今日話し合うべき3つの新機能があります。

AVAsset検査の世界の新機能について話し合うのにほとんどの時間を費やし、メタデータを使用したビデオ合成とキャプションファイルのオーサリングの2つの機能を簡単に紹介します。

だから、これ以上手間をかけずに、AVAsset非同期検査という最初のトピックに飛び込みましょう。

しかし、まず、AVAssetの復習から始めて、少し背景があります。

AVAssetは、ユーザーのデバイスに保存されているムービーファイル、リモートサーバーなどの他の場所に保存されているムービーファイル、HTTPライブストリームやコンポジションなどの他の形式の視聴覚コンテンツを表現するためのAVFoundationのコアモデルオブジェクトです。

そして、あなたが資産を持っているとき、あなたは最も頻繁にそれをプレイしたいと思うが、同じように頻繁に、あなたはそれを検査したいと思うでしょう。

あなたは、その期間、またはそれに含まれるオーディオとビデオのフォーマットは何ですか？のような質問をしたいですか？

そして、それは私たちがこのトピックで本当に話すことです：資産検査。

そして、資産を検査するときはいつでも、心に留めておくべき重要なことが2つあります。

1つ目は、資産検査がオンデマンドで行われることです。

これは主に、映画ファイルが非常に大きくなる可能性があるためです。

長編映画は数ギガバイトのサイズになる可能性があります。

後でその期間を尋ねる場合に備えて、アセットがファイル全体を熱心にダウンロードしたくないでしょう。

代わりに、アセットはプロパティ値をロードするように要求するまで待ってから、その値を与えるために必要な情報だけをダウンロードします。

2番目に覚えておくべきことは、資産検査は非同期プロセスであるということです。

ネットワークI/Oには時間がかかる可能性があるため、これは本当に重要です。

アセットがネットワーク全体に保存されている場合、AVAssetが同期ネットワーク要求を発行している間、アプリのメインスレッドをブロックしたくありません。

代わりに、AVAssetは準備ができたら非同期に結果を提供します。

これら2つのことを念頭に置いて、資産プロパティを検査するための新しいAPIがあり、少しこのように見えます。

注意すべき主なことは、ロードするプロパティ値を伝えるために、プロパティ識別子（この場合は.duration）を取り込むこの新しいロードメソッドです。

各プロパティ識別子は、コンパイル時に結果タイプに関連付けられており、ロードメソッドの戻り値タイプを決定します。

この場合、期間はCMTimeなので、結果はCMTimeになります。

これまでに見たことのないものの1つは、このawaitキーワードです。

これはSwiftの新機能であり、コールサイトでロードメソッドが非同期であることをマークするために使用されます。

async/awaitとSwiftでのより広範な並行性の取り組みの詳細については、「Meet async/await in Swift」というセッションをチェックすることをお勧めします。

今のところ、新しいプロパティロード方法の使用方法を簡単に理解する方法として、awaitキーワードは呼び出し関数を2つの部分に分割すると考えたいと思います。

まず、非同期操作が始まる前に起こる部分があります。

この場合、アセットを作成し、その期間をロードするように依頼します。

この時点で、資産はオフになり、その期間を決定するために必要なI/Oと解析を行い、その結果を待ちます。

待っている間、呼び出し関数は中断されます。つまり、待機後に書かれたコードはすぐには実行されません。

しかし、私たちが実行していたスレッドはブロックされていません。

代わりに、私たちが待っている間、より多くの仕事をすることは自由です。

非同期期間のロードが終了すると、関数の後半が実行される予定です。

この場合、期間の読み込みが成功した場合、期間をローカル定数に保存し、別の関数に送信します。

または、操作が失敗した場合、呼び出し元関数が再開されるとエラーがスローされます。

だから、それがプロパティ値を非同期にロードする基本です。

複数のプロパティの値を一度にロードすることもできます。これは、複数のプロパティ識別子をロードメソッドに渡すだけです。

この場合、デュレーションとトラックの両方を同時にロードしています。

これは便利であるだけでなく、より効率的になることもあります。

資産があなたが興味を持っているすべてのプロパティを知っている場合、その値をロードするために必要な作業をバッチ処理できます。

複数のプロパティ値をロードした結果は、プロパティ識別子に使用したのと同じ順序でロードされた値を持つタプルです。

単一のプロパティ値を読み込むのと同じように、これはタイプセーフです。

この場合、結果タプルの最初の要素はCMTimeで、2番目の要素はAVAssetTracksの配列です。

そしてもちろん、単一の値を読み込むのと同じように、これは非同期操作です。

プロパティ値を非同期にロードすることに加えて、新しい status(of: ) メソッドを使用して、値がいつでもロードされるのを待たずにプロパティのステータスを確認することもできます。

Loadメソッドに使用するのと同じプロパティ識別子を渡すと、4つの可能なケースを持つ列挙型が返されます。

各プロパティは.notYetLoadedとして始まります。

資産検査はオンデマンドで行われるため、資産価値のロードを依頼するまで、資産はそれをロードするための作業を行っていないことを覚えておいてください。

読み込み中にステータスを確認すると、.loadingケースが表示されます。

または、プロパティがすでにロードされている場合は、関連する値としてロードされた値にバンドルされている.loadedケースを取得します。

最後に、おそらくネットワークがダウンしたため、障害が発生した場合は、何がうまくいかなかったのかを説明するエラーがバンドルされた.failedケースが表示されます。

これは、失敗したロード要求を開始したロードメソッドの呼び出しによってスローされたのと同じエラーであることに注意してください。

つまり、非同期プロパティをロードし、そのステータスを確認するための新しいAPIです。

AVAssetには、値を非同期にロードできるかなりの数のプロパティがあります。

これらのほとんどは自己完結型の値を販売しますが、.tracksと.metadataプロパティは、資産の階層構造に下降するために使用できるより複雑なオブジェクトを販売します。

.tracksプロパティの場合、AVAssetTracksの配列を取得します。

AVAssetTrackには、同じロードメソッドを使用して値を非同期にロードできる独自のプロパティのコレクションがあります。

同様に、.metadataプロパティはAVMetadataItemsの配列を提供し、いくつかのAVMetadataItemプロパティは、ロードメソッドを使用して非同期にロードすることもできます。

この領域の新しいAPIの最後のビットは、特定のプロパティ値の特定のサブセットで取得するために使用できる非同期メソッドのコレクションです。

たとえば、すべてのトラックをロードする代わりに、これらの最初の3つの方法のいずれかを使用して、トラックの一部だけをロードできます。たとえば、オーディオトラックのみです。

AVAssetとAVAssetTrackの両方に、このような新しい方法がいくつかあります。

だから、それが私たちがアセットを非同期に検査するためのすべての新しいAPIです。

しかし、この時点で、私は小さな告白をしなければなりません。

この機能のどれも実際には新しいものではありません。

APIは新しいですが、これらのクラスは常にプロパティ値を非同期にロードする機能を備えています。

ただ、古いAPIでは、もっとこのようなコードを書かなければならなかったでしょう。

それは3段階のプロセスでした。

まず、loadValuesAsynchronouslyメソッドを呼び出し、どのプロパティをロードするかを伝える文字列を与える必要があります。

次に、各プロパティが実際に正常にロードされ、失敗しなかったことを確認する必要があります。

その後、そこまで到達したら、対応する同期プロパティを照会するか、同期フィルタリングメソッドの1つを呼び出すことによって、ロードされた値を取得できます。

これは冗長で反復的であるだけでなく、誤用も簡単です。

たとえば、これらの重要なロードとステータスチェックの手順を実行するのを忘れるのは非常に簡単です。

残っているのは、いつでも呼び出すことができるこれらの同期プロパティとメソッドですが、最初にプロパティ値をロードせずに呼び出すと、I/Oをブロックすることになります。

メインスレッドでこれを行うと、アプリが予測不可能な時間にハングしてしまう可能性があることを意味します。

したがって、新しいAPIが単に使いやすいという事実に加えて、これらの一般的な誤用も排除するという事実は、将来のリリースでSwiftクライアントの古い同期APIを廃止する予定であることを意味します。

これは、これらのインターフェイスの新しい非同期バージョンに移行するのに最適な時期であり、それを支援するために、短い移行ガイドを用意しました。

したがって、値をロードし、そのステータスを確認し、同期プロパティを取得する3連単を行っている場合は、ロードメソッドを呼び出して、それをすべて1つの非同期ステップで行うことができます。

同様に、その3段階のプロセスを行っているが、プロパティの代わりに同期フィルタリング方法を使用している場合は、そのフィルタリング方法と同等の非同期を呼び出して、1つのステップでそれを行うことができます。

古い statusOfValue(forKey: ) メソッドを使用してプロパティのステータスを切り替え、.loaded ケースにいることが確認したときに同期プロパティ値を取得する場合、新しいステータス列挙型の .loaded ケースにその .loaded 値がバンドルされているという事実を活用できます。

アプリがコードの一部にプロパティの値をロードし、コードの別の部分でロードされた値を取得するなど、もう少し興味深いことをしている場合は、新しいインターフェイスでこれを行う方法がいくつかあります。

ロードメソッドをもう一度呼び出すことをお勧めします。

これは最も簡単で安全な方法であり、プロパティがすでにロードされている場合、これはすでに行われた作業を複製しません。

代わりに、キャッシュされた値を返すだけです。

ただし、これには1つの注意点があります。それは、loadメソッドは非同期メソッドであるため、非同期コンテキストからのみ呼び出すことができるということです。

したがって、本当に純粋な同期コンテキストからプロパティの値を取得する必要がある場合は、プロパティのステータスを取得し、プロパティの値を同期的に取得するためにロードされていることをアサートすることができます。

それでも、プロパティがすでにロードされた後でも失敗する可能性があるため、これを行うには注意する必要があります。

最後に、ロードとステータスチェックの手順をスキップして、結果が利用可能になるまでブロックするプロパティとメソッドの現在の動作に依存している場合は、実際にはこれに代わるものを提供していません。

これはAPIを使用するための推奨される方法ではないので、私たちは常にそれを思いとどまらせてきました。

新しいプロパティローディングAPIは、単純なプロパティを取得するのと同じくらい使いやすいように設計したので、新しいAPIへの移行は簡単であるべきです。

そして、それで、それが私たちの最初のトピックのすべてです。

Swiftの新しい非同期機能を使用して、アセットを検査する新しい方法に本当に興奮しています。私と同じくらい楽しんでいただければ幸いです。

それでは、2つの短いトピックの最初のトピックに移りましょう。メタデータを使用したビデオ合成です。

ここでは、複数のビデオトラックを取り、それらを単一のビデオフレームのストリームに構成するプロセスであるビデオ合成について話しています。

特に、カスタムビデオコンポジターの機能強化があり、合成を行うコードを提供します。

今年の新機能では、カスタムコンポジターのフレームコンポジションコールバックで、フレームごとのメタデータを配信できます。

例として、一連のGPSデータがあり、そのデータがタイムスタンプされ、ビデオと同期されており、フレームの構成方法に影響を与えるためにそのGPSデータを使用したいとします。

あなたは今それを行うことができ、最初のステップは、ソースムービーの時付けされたメタデータトラックにGPSデータを書き込むことです。

AVAssetWriterでこれを行うには、既存のクラス、AVAssetWriter InputMetadataAdaptorをチェックしてください。

では、新しいAPIを見てみましょう。

特定のトラックのコレクションを持つソースムービーから始めているとしましょう。

おそらく、オーディオトラック、2つのビデオトラック、3つの時付けメタデータトラックがあります。

しかし、トラック4と5には、ビデオ合成に役立つメタデータが含まれていますが、トラック6は無関係です。

実行する2つのセットアップ手順があり、1つ目は、新しいソースSampleDataTrackIDsプロパティを使用して、ビデオコンポジションオブジェクトに、ビデオコンポジション全体に関連するすべての時付けメタデータトラックのIDを指示することです。

それが終わったら、2番目のステップは、各ビデオ構成の指示を取り、同様のことをすることですが、今回は、その特定の命令に関連するトラックID（またはID）を伝えるためにrequiredSourceSampleData TrackIDsプロパティを設定します。

これらのセットアップ手順の両方を実行することが重要です。そうしないと、コンポジションのコールバックにメタデータを取得しません。

では、コールバック自体に移りましょう。

コールバックで非同期ビデオコンポジション要求オブジェクトを取得すると、ビデオコンポジションのメタデータを取得するために使用する2つの新しいAPIがあります。

1つ目は、その要求に関連するメタデータトラックのトラックIDをリプレイするソースSampleDataTrackIDsプロパティです。

次に、各トラックIDについて、sourceTimedMetadata(byTrackID :))メソッドを使用して、そのトラックの現在のタイミングメタデータグループを取得できます。

現在、AVTimedMetadataGroupはメタデータの高レベルの表現であり、値は文字列、日付、またはその他の高レベルオブジェクトに解析されます。

メタデータの生のバイトを操作したい場合は、sourceSampleBuffer(byTrackID: ) メソッドを使用して、AVTimedMetadataGroup の代わりに CMSampleBuffer を取得できます。

メタデータが手に入ったら、メタデータをソースビデオフレームと一緒に使用して出力ビデオフレームを生成し、リクエストを終了することができます。

だから、ビデオコンポジションでもっと面白いことをできるように、カスタムビデオコンポジターのコールバックにメタデータを取り込むのに必要なのはそれだけです。

さて、最後のトピックはキャプションファイルのオーサリングです。

今年のmacOSの新機能であるAVFoundationは、2つのファイル形式のサポートを追加しています。

まず、iTunes Timed Text、または字幕を含む.ittファイルがあります。

もう1つのファイル形式は、クローズドキャプションを含むScenaristクローズドキャプション（または.sccファイル）です。

AVFoundationは、これら2つのファイル形式の作成、これらのタイプのファイルからのキャプションの取り込み、および再生中の外観を確認するために実行時にキャプションをプレビューするためのサポートを追加しています。

オーサリング側では、単一のキャプションを表すモデルオブジェクトであるAVCaptionから始まるいくつかの新しいAPIがあります。

単一のキャプションのテキスト、位置、スタイル、その他の属性などのプロパティがあります。

AVCaptionsを自分で作成し、AVAssetWriterInputCaptionAdaptorを使用して、これら2つのファイル形式のいずれかに書き込むことができます。

さらに、AVCaptionConversion Validatorクラスに新しい検証サービスがあります。これは、あなたが書いているキャプションが実際に選択したファイル形式と互換性があることを確認するのに役立ちます。

これが重要な理由の例として、.sccファイルを検討してください。

CEA-608キャプションが含まれています。これは、特定の時間内に持つことができるキャプションの数について非常に具体的な制限があり、個々の文字とそのスタイリングを表すデータの固定ビット予算を持つまでです。

したがって、バリデータは、キャプションのストリームがファイル形式と互換性があることを確認するだけでなく、タイムスタンプを調整するなど、キャプションに調整できる調整を提案します。

キャプションを取り込むための新しいAPIはAVAssetReader OutputCaptionAdaptorで、これらのファイルの1つを取り、そこからAVCaptionオブジェクトで読み取ることができます。

最後に、AVCaptionRendererクラスがあり、単一のキャプションまたはキャプションのグループを取り、再生中の外観のプレビューを取得するためにCGContextにレンダリングすることができます。

だから、それは私たちの新しいキャプションファイルオーサリングAPIの氷山の一角にすぎません。

それらを採用することに興味がある場合は、フォーラムまたは会議ラボのいずれかで私たちと連絡を取ることをお勧めします。ご質問にお答えします。

そして、それが私たちの最後のトピックだったので、締めくくりましょう。

その日の大きなトピックは、AVAssetプロパティの検査、オンデマンドおよび非同期に行うことの重要性、この分野の新しいAPI、および古いAPIから移行するためのいくつかのヒントでした。

次に、時付きメタデータを使用して、カスタムビデオコンポジションをさらにカスタマイズすることについて話しました。

最後に、キャプションファイルのオーサリングとその分野の新しいAPIについて簡単に紹介しました。

今日はそれだけです。

WWDC21をご覧いただき、ありがとうございます。

♪