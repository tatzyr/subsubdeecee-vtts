10161

こんにちは、ディスプレイ・アンド・カラー・テクノロジーズチームのケン・グリーンバウムです。

この「ハイダイナミックレンジ、EDRによるレンダリング」トークにご参加いただきありがとうございます。

それは私があなたと共有することに興奮している技術です。

私たちがカバーするものと、出席することで誰が最も利益を得るかをすばやく実行しましょう。

EDRが実際に何であるかから始めて、既存のアプリにEDRを追加するために使用される4つのステップを説明し、レンダリングをより詳細に制御するためのネイティブEDR APIについて話し合い、最後に、EDRに関連する一連のベストプラクティスを探ります。

さて、EDRとは何ですか?

EDRは、あなたがよく知らないかもしれない頭字語です。

それは「拡張ダイナミックレンジ」の略です。

「EDR」を使用して、当社のプラットフォームで使用されるHDR表現とHDRレンダリング技術の両方を指します。

それはあなたがすでによく知っているかもしれないカラーマネジメントにやや似ています。

多くの種類のアプリの開発者は、この話が面白いと思うでしょう。

まず、コンピュータグラフィックス技術、ハイダイナミックレンジディスプレイ、特にAppleが過去数年間にリリースしてきた新しいXDRディスプレイに興味のある開発者。

次は、レンダリングエンジンにすでに存在する可能性のある明るい詳細のロックを解除し、最も現実的でエキサイティングな体験を作りたい筋金入りのゲーム開発者です。

重要なことに、HDRビデオと静止画のスタジオ参照応答を達成することに興味を持っているプロアプリ開発者がいます。

最後に、グラフィックスに特に重点を置いていますが、現在エコシステムに入っているHDR静止画とビデオコンテンツを受け入れたいアプリの開発者がいます。

HDRはここにあり、それは私たちのEDR技術によって有効になっています。

議論するように、私たちはすでにユーザーの手に信じられないほどの機能を備えたディスプレイを持っています。

ユーザーがキャプチャ、ストリーミング、ダウンロードしているエコシステムの素晴らしいHDRコンテンツと、ゲームとプロフェッショナルの両方のHDRアプリは、App Storeで入手できます。

EDRは適応技術です。

議論するように、EDRはHDRコンテンツを大きく異なる機能のディスプレイにマッピングするだけでなく、さらに幅広い視聴条件もサポートしています。

明るい環境でディスプレイが、暗闇で見たときとは大きく異なって見えることに気づいたことがありますか?

屋内で体験する明るく鮮やかな色は、屋外で見ると低いダイナミックレンジで薄暗く、ミュートに見える可能性があります。

ディスプレイは変わらなかった。

与えられた明るさの設定では、それは常に同じ光を作っています。

変化した環境と、環境に急速に適応したあなたのビジョンです。

暗い環境では、あなたのビジョンは、主要な光源である表示されたコンテンツに適応します。

しかし、明るい環境では、ユーザーのビジョンは、はるかに暗いディスプレイを介して環境に大きく適応し、コンテンツが薄暗く見え、洗い流され、黒と影のディテールを押しつぶします。

このため、EDRと基礎となる環境適応技術は、ホワイトポイント、ブラックポイント、参照ホワイト輝度、ダイナミックレンジなどのディスプレイパラメータを「EDRヘッドルーム」として記述し、ディスプレイをユーザーの適応ビジョンにマッピングします。

EDRの適応には多くの利点があります。

おそらく最も驚くべきことに、これにより、従来の標準ダイナミックレンジディスプレイでも、EDRが真のHDR応答を生み出します。

つまり、これらのディスプレイが、対応する調光輝度設定で調光環境で表示される場合です。

同様に、EDRのダイナミクスは、明るいHDRディスプレイで状況最適化されたHDR機能を生み出します。

これにより、HDRコンテンツはHDR参照の薄暗い環境で見事に見えると同時に、このイラストのパッチなどの影の詳細を維持しながら、より明るい環境で縮小されたが最適なダイナミックレンジを提供します。

EDRレンダリングは、私たちが何年も出荷してきたほとんどのデバイスでサポートされています。

私たちは、従来の最大SDRホワイトよりも何倍明るく、最も明るいEDRピクセルをディスプレイにレンダリングできるかであるEDRヘッドルームの観点からHDR機能を説明しました。

EDRヘッドルームは、表示機能だけでなく、現在の明るさスライダー設定を含む他のパラメータによって異なります。

最新のMacやiPadで見られるように、従来のバックライト付きディスプレイでは、最大2倍のSDRが利用可能です。

XDRディスプレイを搭載したiPhoneは、最大8倍のSDR EDRヘッドルームを提供します。

新しいiPad ProのLiquid Retina XDRディスプレイは、最大16倍のSDRを備えています。

Mac、iPad、AppleTV経由で一般的な外部HDR 10ディスプレイを運転する場合、約5倍のSDRが提供されます。

また、Pro Display XDRは、明るさが最小4nit値に設定されている場合、デフォルトのXDRプリセットで驚異的な400倍SDRにレンダリングされます。

HDR対応のディスプレイはすでに多くのユーザーの手に渡っているだけでなく、HDRコンテンツが主流になりつつあります。

商用HDRコンテンツに加えて、ユーザーは自分のiPhoneやその他のデバイスでキャプチャされたHDR静止画とビデオコンテンツをエコシステムに追加しています。

畏敬の念を起こさせるアプリケーションのリストは、すでにEDRを採用しています。

EDRをサポートする最上位ゲームには、「Baldur's Gate 3」、「Divinity: Original Sin 2」、「Shadow of the Tomb Raider」などがあります。

ますます多くのAppleTVサービスが、TVアプリ、Netflix、YouTubeなどのHDRコンテンツを提供しています。

最後に、Proアプリのエキサイティングで増え続けるリストがEDRを採用しており、賭け金を増やし、プラットフォームで開発されたHDRコンテンツの量を増やしています。

Affinity Photo、DaVinci Resolve、Cinema 4D、Final Cut Pro、Nuke、Pixelmator Proはアプリのほんの一部です。

私たちは、人によって異なる意味を持つ傾向がある「HDR」と区別するために、私たちの技術を「EDR」と名付けることを選びました。

多くの人がハイダイナミックレンジについて考えるとき、彼らは深い黒を生み出すことができる明るいディスプレイを想像します。

制作志向の人は、コンテンツフォーマット、おそらくHDR10またはドルビービジョンを考えるかもしれません。

技術的には、PQやHLGなどの転送機能が思い浮かびます。

そして、おそらく芸術的には、HDRは明るいハイライトを表すシュールで絵画的なトーンマップと、SDRとしての薄暗い影の詳細を提案することさえできます。

RITが生成した超高ダイナミックレンジOpenEXR画像のこのSDRトーンマップを考えてみましょう。

トーンマップには、光る電球と影のディテールがすべて存在します。

しかし、元のHDR画像の劇的なダイナミックレンジは失われます。

EDRは、意図を失いながらすべての詳細を保持する絵画的なHDRからSDRへの変換ではなく、真のハイダイナミックレンジレンダリングです。

RITチームは、ここで見られる18ブラケットのデジタル一眼レフ露出を組み合わせて、驚くべき50万:1のダイナミックレンジでHDR画像を作成しました。

EDRはこれを浮動小数点で完全に表し、画像の被写体であるLuxoランプ自体は、参照白の1.0の下のピクセル値として、電球の発光オーブなどの明るいディテールで、500に近い値として表されます。

それはランプベースよりも500倍明るいです。

EDRの実装は、システムのすべての要素の参照ホワイト間のマッピングを作成します。

コンテンツの参照白からディスプレイの参照白、ユーザーの適応ビジョンの参照白まで。

このマッピングは、HDRとSDRコンテンツが共存し、環境間でHDRディスプレイのダイナミックレンジを最適に公開し、従来のSDRディスプレイが真のHDRをレンダリングできるようにするなど、EDRの多くの利点を提供するための基本です。

たとえば、Pro Display XDRでは、輝度スライダーが最大500ニトに設定されている場合、最大3.2のEDR値がクリッピングなしでレンダリングされます。

ランプヘッドなどのより明るい要素は、それに応じてより大きなEDR値を持ち、ディスプレイの1,600ニトのピークにクランプします。

ディスプレイの明るさ設定を4ニトの最小値に向かって下げると、薄暗い環境で、自動輝度を介して自動的に、または手動で輝度スライダーを使用して発生すると、最大400のEDR値がレンダリング可能になり、この例外的な画像のダイナミックレンジのほとんどを提供します。

画像の最も明るい要素は、ディスプレイの1,600ニトのピーク輝度にレンダリングされていますが、電球の輪郭を明確に定義しています。

同様に、明るく照らされたカラーチェッカーの色など、他の詳細が明らかにされます。

ユーザーのビジョンが画像の4ニットリファレンスホワイトに適応するようになったため、画像の最も明るい要素は、ランプベースよりも400倍明るくレンダリングされるようになりました。

EDRの浮動小数点HDR表現とレンダリングパイプラインの影響を探りましょう。

浮動小数点であるEDRは、この完全に満たされた色度図で表されるように、人間が知覚できるすべての色を表すことができます。

同様に、EDRは、完全にレンダリングされると視力にダメージを与える明るさを表すことができます。

そのため、EDRの表現は将来性があります。

前述のように、EDRは表現であるだけでなく、HDRレンダリングパイプラインでもあります。

EDRは、Appleが開拓したカラーマネジメント技術の拡張であり、非常に長い間出荷されています。

たとえば、GPUアクセラレーションカラーマネージドビデオは、最初にMacOS 10.4 Tigerで出荷されました。

概念的には、通常の色域と広色域のメディアを並べて表示できるようにするのと同様に、EDRはHDRとSDRの資産を調和のとれた方法で画面を共有し、さまざまな機能のディスプレイに適切にレンダリングすることができます。

とりわけ、これは開発者が既存のSDR資産を引き続き使用し、必要に応じてEDRサポートを選択的に追加できることを意味します。

EDRのHDRピクセル値の表現を視覚的に探りましょう。

EDRは浮動小数点表現です。

EDR 0.0は黒を表し、1.0はSDR maxを表し、「参照白」または「UI白」とも呼ばれ、EDR 0.0から1.0はいつものようにSDR範囲を表します。

これらの値は画像の被写体を表し、レンダリング時にクリップされることはありません。

1.0を超えるEDR値は、ハイライトや発光面など、SDRの明るさを超える値を表します。

これらの値は非常に明るくなる可能性があり、表現可能ですが、レンダリング時にクリッピングの対象となります。

EDRは、ディスプレイが従来の純粋な電力応答または新しいHDR転送機能を持っているかどうかに関係なく、ディスプレイを駆動するために使用されます。

PQベースのデフォルトのXDRプリセットでPro Display XDRを考えてみましょう。

EDR 0.0は、ゼロnit PQコードを介して、ディスプレイをゼロnitsに駆動します。

「リファレンスホワイト」と呼ばれるEDR 1.0は、いつものようにディスプレイの明るさスライダーまたは自動明るさによってスケーリングされます。

XDRプリセットは、典型的な約4〜500ニトの参照白色輝度範囲を持っています。

この例では、最大500ニトの設定を考えてみましょう。

明るさの設定に関係なく、このプリセットではピークホワイトは常に1,600ニトです。

したがって、1,600ニトピークホワイトを500ニトの基準白で割って計算できるように、最も明るくレンダリング可能なEDR値であるEDRmaxは3.2です。

それに応じて、ディスプレイにレンダリング可能な最も明るい値は、参照白よりも3.2倍明るいため、3.2倍のSDRヘッドルームがあると言います。

要約すると、Pro Display XDRでは、デフォルトのXDRプリセットを使用して、ディスプレイの明るさは「リファレンスホワイト」とも呼ばれ、500ニトで、EDR値0.0〜3.2は0.0〜1,600ニトとしてディスプレイにレンダリングされ、EDR 1.0は500ニトとして表示されます。

最後に、EDRmaxの3.2を超えるEDR値は、ピークホワイト、1,600ニトにクリップされます。

驚くべきことに、ディスプレイの明るさが最小4ニトに向かって低下すると、最大400のEDR値がレンダリング可能になり、真のダイナミックレンジで信じられないほど明るいディテールが露出します。

EDRの仕組みの概要がわかったので、アプリケーションにEDRを追加することを検討します。

ほとんどのアプリケーションにEDRサポートを追加するには、4つのステップがあります。

これらの手順はすべて簡単ですが、その効果は微妙であり、それらをすべて適用するまでEDRの結果を確実に得られない可能性があります。

まず、適切なコンテキスト、レイヤー、またはオブジェクトに属性を追加してEDRを要求する必要があります。

次に、拡張範囲のカラースペースをバッファ、レイヤー、またはアプリに関連付ける必要があります。

拡張範囲のカラースペースが指定されていない場合、カラーマネジメントはEDR値を1.0を超えてクリップします。

カラー管理は、ソースとデスティネーションのカラースペースが一致しない場合にのみ関与する可能性があるため、このクリップは断続的またはコンテンツに依存する可能性があります。

第三に、1.0を超える値を表現できるピクセルバッファ形式を選択する必要があります。

これは通常、ある種の浮動小数点です。

最後に、アプリケーションはSDR 0.0から1の範囲を超えるピクセルを生成し、誇示するキラキラした要素を持つ必要があります。

多くの開発者は、EDRサポートを追加したいかもしれない既存のアプリを持っています。

おそらく、EDRを使い始める最も簡単な方法は、既存のSDRコンテンツの代わりにHDRビデオまたは静止画コンテンツを置き換えることです。

次に、先ほど概説した4つのステップに従ってください。

一部のアプリケーション、例えば、表示されている電子メールアプリは、HDRコンテンツに遭遇した場合にのみ選択的にEDRを有効にする場合があります。

AVFoundationのAVPlayerインターフェースは、ドルビービジョン、HDR 10、HLGなどのますます多くのHDRビデオフォーマットをサポートしています。

AVPlayerは、watchOSを除くすべてのプラットフォームで可能な限り、これらのフォーマットを自動的にEDRとしてレンダリングします。

既存のAVPlayerベースのアプリケーションは、EDRを介してサポートされているHDRビデオフォーマットをレンダリングするために変更を必要としません。

EDR対応のAVPlayerコードの例を見てみましょう。

いつものように、AVPlayerのplayerWithURLを使用して、まずAVPlayerインスタンスを作成するだけです。

ただし、この例では、HDRビデオコンテンツを指定します。

次に、playerLayerWithPlayerを使用して、プレイヤーをレイヤーに追加します。

最後に、コントローラーをプレイヤーに向け、プレイヤーにプレイを開始するよう依頼します。

AVFoundationは、HDRメディアをEDRとしてレンダリングするために必要なものを自動的に実行し、コンテンツタイプに基づいてEDRを有効または無効にします。

HDRビデオの再生はかなり簡単です。

次に、HDR静止画のレンダリングを考えてみましょう。

ImageIOはHDR画像フォーマットを幅広くサポートしており、便利なことに、浮動小数点バッファでデコードされたピクセルをEDRとして返します。

ImageIOはすべてのプラットフォームで利用できますが、現在、デコードされた結果はmacOSでEDRとしてのみレンダリングできます。

今後のCAMetalLayerの例で、ImageIOベースのアセットをアプリケーションに組み込む方法を紹介します。

では、ネイティブEDR APIを探りましょう。

前述したように、ネイティブEDR APIは、開発者がカスタムコンテンツをレンダリングし、HDRメディアのレンダリング方法をより詳細に制御したいかもしれないゲームやプロアプリなどのアプリケーション用に作成されました。

現在、このAPIはCAMetalLayerとNSOpenGLViewを介してmacOSで利用可能です。

好ましいネイティブEDRフレームワークであるCAMetalLayerを使用した例を見てみましょう。

まず、4段階のプロセスの最初の3つを見て、EDRを選択し、拡張範囲の色空間を設定し、FP16ピクセルバッファ形式を選択します。

まず、metalLayerの「wantsExtended DynamicRangeContent」属性を「はい」に設定して、EDRにオプトインします。

次に、metalLayerの色空間をExtendedLinearDisplayP3などの拡張範囲の色空間に設定します。

第三に、metalLayerのピクセル形式をRGBA16Floatなどの浮動小数点形式に設定します。

次に、実際にEDRピクセルを生成する4番目のEDRオプトインステップを調べます。

この場合、ImageIOを使用してHDR静止画コンテンツをインポートし、結果をEDRテクスチャとしてレンダリングします。

少し複雑なので、一歩一歩歩きます。

HDRコンテンツからCGImageを作成し、デコードされた画像を浮動小数点ビットマップに描画し、浮動小数点テクスチャを作成し、EDRビットマップをテクスチャにロードし、最後に、EDR対応の金属パイプラインにテクスチャをレンダリングします。

まず、CGImageは、CGImageSourceCreateWithURLとCGImageSourceCreateImageAtIndexを使用して、HDRimageURLで指定されたソースから作成されます。

次に、以前にmetalLayerで設定したのと同じ色空間を使用して、CGBitmapContextCreateでCGContextを作成し、CGContextDrawImageを使用してEDR画像を浮動小数点コンテキストに描画します。

次に、newTextureWithDescriptorを使用して、RGBA16Float型の浮動小数点テクスチャを作成します。

replaceRegionを使用して、CGBitmapContextGetDataを使用してEDR画像データをEDRテクスチャにロードします。

最後に、開発者はEDRテクスチャをEDR対応の金属パイプラインにレンダリングし、動的な結果を楽しむ準備ができています。

まだOpenGLベースのアプリケーションをサポートしている人のために、すでに実証したものと同様の手順を使用して、NSOpenGLViewでEDRを有効にすることを検討します。

EDRの採用はまた、カラーマネジメントを完全に受け入れる機会を提供するかもしれない。

しかし、この講演ではそれを取り上げません。

次の手順を探ります。EDRにオプトインし、浮動小数点ピクセルバッファ形式を選択し、EDRとコンテンツをNSOpenGLViewに描画します。

NSOpenGLViewは自動的にカラー管理されないため、拡張範囲のカラースペースを設定する必要はありません。

まず、NSOpenGLViewの「wantsExtendedDynamicRange OpenGLSurface」属性を「はい」に設定して、EDRにオプトインします。

次に、ピクセルバッファ形式をNSOpenGLPFAColorFloat with ColorSize、64に設定します。

最後に、EDR値をOpenGLViewに描画し、変更されたアプリケーションを実行し、結果をお楽しみください。

既存のアプリケーションで基本的なEDRサポートを有効にすることについて議論したので、EDR対応アプリケーションを最大限に活用するためのいくつかのベストプラクティスをもう少し深く掘り下げてみましょう。

リコールEDRオプトインステップ4は、拡張範囲の色空間を設定することです。

そして、これまでの例では、適切な拡張範囲の色空間を明示的に設定しました。

ただし、多くのアプリは色空間を明示的に設定せず、代わりにフレームワークによって提供されるデフォルトの色空間を使用します。

これは多くの場合、拡張範囲ではないディスプレイまたはコンポジションスペースに対応し、何かが行われない限りEDRを壊します。

既存の色空間を拡張範囲に促進する方法の例を探ってみましょう。

まず、この場合、ビューのウィンドウから既存の色空間を取得します。

次に、CGcolorspaceCreateExtendedを使用して、その色空間を拡張範囲に昇格します。

最後に、必要に応じて、新しく生成された拡張範囲の色空間をウィンドウ、バッファ、またはレイヤーに割り当て、色空間を明示的に設定していないアプリがEDRを使用できるようにします。

次に、EDRコンテンツを生成するためのベストプラクティスを探ります。

これまでのところ、EDRコンテンツには1.0を超える値があると述べましたが、このコンテンツを実際に合成する方法やHDRソースから変換する方法はありません。

EDRコンテンツの生成には注意してください。恐ろしい「輝くバニー症候群」を経験する可能性があるため、コンテンツは不気味で虹色の輝きがあり、適切に作成されたコンテンツが薄暗く見える可能性があります。

強調されているように、EDR 1.0を超えるピクセルは、鏡面ハイライトと発光面のみをエンコードする必要があります。

これは、SDRコンテンツを取り、それをHDRに伸ばすのは不適切であることを意味します。

SDRコンテンツは、ネイティブ0.0から1.0の範囲のEDR as-isと互換性があります。

これにより、SDR参照白がHDRコンテンツの白に合わせます。

HDRコンテンツが明るすぎるように作成されている場合、暗い要素や影がEDR 1.0を超えると、よく作成されたコンテンツに比べて不自然に見えます。

ユーザーのビジョンは、この過度に明るいコンテンツに適応し始め、他のコンテンツと比較して薄暗く見える可能性があります。

写真家やアニメーターが露出を設定するために使用する18%の灰色のカードを持っている女の子のこの例を検討してください。

少女は写真の被写体であり、その結果、写真家やアニメーターは露出を基準白以下に設定し、クリップされません。

ほとんどのユーザーインターフェイス要素もEDR 1.0を超えてはいけません。

ただし、注意を引くために明るく照らされたEDRカラーピッカーや一時的にスケーリングされたUIなど、例外があるかもしれません。

太陽や雲などの発光面や、光沢のある表面に反射する太陽などの鏡面ハイライトは、参考白よりもはるかに明るくなる可能性があり、その結果、EDR 1.0を超えると予想されます。

シーンの最も明るい要素は、すでにSDRエンコーディングによってクリップされています。

その結果、SDRコンテンツはEDR 0.0から1.0として正しく表されます。

ワークフローでは、HDRフォーマットを明示的にEDRに変換する必要がある場合があります。

前述のように、ImageIOはHDRコンテンツをEDRにデコードし、それ以上の変換を必要としません。

たとえば、HLGは0.0から12.0のEDR範囲にデコードされ、EDR 1.0は参照白を表します。

ImageIOは、他のHDR静止画フォーマットを独自の特定の範囲にデコードし、EDR 1.0は常にソースの参照白に対応します。

AVFoundationは現在、HDR10などのHDRフォーマットをEDRにデコードしていません。

したがって、これらはEDRレンダリングで使用するために適応する必要があります。

この変換は簡単で、2つのステップが必要です。

まず、逆伝達関数を適用して線形光に変換します。

そして第二に、媒体の基準白で割る。

たとえば、PQコンテンツの100ニトなので、参照白はEDR 1.0にマッピングされ、最大PQ 10,000ニトの値はEDR 100にマッピングされます。

デジタルとフィルムの両方の多くの写真と同様に、空が白に切り取られたこの写真を考えてみましょう。

EDRはEDR 1.0までの値をクリップしませんが、画像の主題を表す参照白、EDRは現在のEDRmaxを超えた参照白の上の値をクリップするので、現在のシステム表示と表示設定でレンダリングすることはできません。

参照白の上のこれらの値は、この画像では見ることができない雲、空、太陽などのハイライトまたは発光面であり、そのため、通常はクリップしても大丈夫です。

しかし、明るいディテールのクリッピングは必ずしも受け入れられるとは限りません。

例えば、雲の上を高く飛んでいる太陽に照らされた飛行機のこのイメージを考えてみましょう。

青い「HDR11」のカラーリングに注目してください。

明るく照らされて、番号とそれが塗装された胴体は、両方とも参照白よりも大きくレンダリングされる可能性があり、したがって、ディスプレイ機能と現在のEDRmaxに応じてクリップされる可能性があります。

この数字が映画やゲームの重要なプロット要素であった場合、ダイナミックトーンマッピングを使用してクリッピングを回避または管理し、数字を見えるようにすることができます。

洗練されたアプリケーションが現在のEDRmax値に遅れずについていく方法を検討し、それに応じてレンダリングするものを適応させましょう。

アプリケーションは、おそらくシーン内のオブジェクトの明るさを調整したり、シーンの露出を変更したり、ブルーム効果を適用したり、重要な詳細が失われないようにソフトクリップを適用したりするために、NSScreen通知を購読したい場合があります。

現在、NSScreenインターフェースからアクセスできる動的EDR値は1つしかありません。

これはmaximumExtendedDynamic RangeColorComponentValueであり、現在の最大レンダリング可能な線形EDR値を表します。

述べたように、EDRmaxより大きいEDR値はEDRmaxにクリップされます。

また、EDRmaxは、ディスプレイの明るさやTrue Toneなどの特性に依存しているため、動的に変化する可能性があります。

NSScreenからアクセスできる他の2つのEDR値は静的であり、時間の経過とともに変化しないことを意味します。

前述の値とは対照的に、maximumPotentialExtendedDynamic RangeColorComponentValueは、このディスプレイでクリッピングせずにレンダリング可能な最大EDRリニアピクセル値を返します。

つまり、ディスプレイの明るさやその他の機能が適切に設定されている場合です。

最大潜在的なEDRは、SDRまたはHDRバージョンのコンテンツを使用すべきかどうか、あるいはEDRを有効にする価値があるかどうかを決定するなど、意思決定を導くために使用される可能性があります。

可能性は名前にあることを覚えておいてください。

現在のレンダリング可能な最大値であるEDRmaxは、この値を下回っている可能性があります。

EDRをサポートしていないディスプレイまたはディスプレイプリセットには1.0が返されます。

最終的な静的値であるmaximumReferenceExtendedDynamic RangeColorComponentValueは、主に参照標準に対する最高の忠実度を達成することを懸念しているProアプリケーション開発者にとって興味深いものです。

これは、特定のディスプレイで、クリッピングやトーンマッピングなどの歪みなしでレンダリングされることが保証されている最大EDR値を提供します。

参照レンダリングをサポートしていないディスプレイでは、0.0が返されます。

それでは、NSScreen経由でEDR値を読み取るサンプルコードを見てみましょう。

ここでは、maxPotentialとmaxReferenceの2つの静的EDR値を読み取ります。

EDRの値はディスプレイ間で異なる場合がありますので、アプリが実際にオンになっている画面で必ず電話をかけてください。

この例では、ウィンドウに関連付けられたNSScreenを使用しています。

アプリケーションは、「NSWindowDidChangeScreen」通知を購読し、画面変更イベントを受信したときに現在のEDRパラメータを照会し、現在のEDRヘッドルームの知識に基づいてレンダリングされるものを変更する可能性があります。

トーンマッピングの議論を完了するために、CAMetalLayerトーンマッパーを簡単に検討します。

これは、HLGやHDR10などのHDRビデオを作成してレンダリングするProアプリにとって、プロジェクトベースのHDRマスタリングパラメータに興味があります。

すでに説明したように、システムアプリやAVPlayerを採用しているアプリは、CAMetalLayerトーンマッパーを使用して、メディア固有の光学から光学への転送機能と、そうでなければレンダリングできないHDR値のソフトクリップを提供します。

CAMetalLayerトーンマッパーは、「CAEDRMetadata」属性を介して有効になり、macOSで利用できます。

この例は、アプリのCAMetalLayerに「EDRMetadata」属性を設定して、システムトーンマッパーを有効にする方法を示しています。

多くのEDRMetadataコンストラクタが利用可能です。

それらは、提供されたマスタリング情報だけでなく、HDRビデオ標準に固有のものです。

ここでは、パラメータを取らないHLGMetadataコンストラクタを見ます。

次に、HDR10コンストラクタの1つを実演します。

これには3つのパラメータが必要です。nitsの両方の明示的な最小およびmaximumLuminanceと、しばしばHDR10の100nitリファレンスホワイトに設定されるopticalOutputScaleです。

構築されたら、結果のオブジェクトをアプリケーションのCAMetalLayerに設定し、このレイヤーでレンダリングされたすべてのコンテンツが、提供されたメタデータに基づいてシステムトーンマッパーによって処理されます。

アダプティブトーンマッピングと密接に関連して、アプリは、現在レンダリング可能な最も明るい白で描画したいと思うかもしれません。

NSScreenから現在のEDRmaxを取得する方法をすでに理解していますが、EDRヘッドルームは線形値であり、ピクセルはほとんどの場合非線形にエンコードされています。

この最後の例では、EDRmaxをアプリの潜在的に非線形色空間に変換します。

まず、CGColorSpaceCreateWithNameを使用して、レンダリングする線形EDRmaxホワイトピクセルを作成します。

そして、CGColorCreateCopy ByMatchingToColorSpaceを使用して、線形EDRmaxピクセルをアプリケーションの色空間に変換します。

結果の色は、EDR対応アプリケーションで使用できます。

これにより、EDRのパワーとパフォーマンスの影響について、議論する最後のトピックが残ります。

すべてのCGレンダリングと同様に、EDRの電力とパフォーマンスへの影響を評価することは複雑になる可能性があり、多くの場合、特定のデバイスで使用される特定のハードウェアアーキテクチャとディスプレイ技術に依存します。

この講演では詳しく説明しませんが、より明るいピクセルを生成すると、多くの場合、より多くの電力を消費し、EDRで使用される浮動小数点バッファが大きくなる可能性があるため、それ以外の場合に使用される可能性のある固定ポイントバッファよりも多くの帯域幅を消費するなど、考慮すべき一般的なポイントがいくつかあります。

これは、順番に、より多くの消費電力と相関しています。

CAEDRMetadataベースのトーンマッピングを有効にしても、追加の処理パスが必要です。

これにより、レイテンシと帯域幅が増加します。

単純に、EDRは、多くの機能と同様に、無料ではないので、慎重に使用する必要があります。

ベストプラクティスは、HDRコンテンツと潜在的なEDRヘッドルームの両方が利用可能な場合にEDRを有効にすることです。

そうでない場合は、EDRを無効にします。

同様に、EDRの潜在的なヘッドルーム、または現在のEDRmaxヘッドルームが1.0よりも大幅に大きいかどうかに基づいて、オープンまたはストリーミングするコンテンツのHDRまたはSDRバージョンを選択します。

または、より簡単に言えば、ユーザーが違いを見る場合にのみEDRを有効にします。

短期間でEDRについて多くのことを取り上げました。

あなたが私と同じようにEDRに興奮し、それをあなたのアプリケーションに統合することを熱望していることを願っています。

要約すると、EDRはmacOS、iOS、iPadOS、tvOSデバイスで使用されています。

EDRは、すでに使用しているカラーマネジメントとSDR表現の拡張機能です。

EDRは、アプリケーションがオプトインするのは簡単です。

EDRは業界のHDR規格と互換性があり、デバイスや環境全体で非モーダルアダプティブ体験を提供します。

HDRビデオ再生、Apple Pro Display XDR、EDRのメタルレンダリングの詳細については、以下の講演とリソースをご覧ください。

ありがとう！

残りのWWDCを楽しんでください。

[音楽]。