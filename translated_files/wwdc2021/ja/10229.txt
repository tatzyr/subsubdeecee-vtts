10229

こんにちは。私の名前はリニ・パテルで、GPUソフトウェアエンジニアリングチームの出身です。

このセッションでは、Metalの新しいシェーダーコンパイルワークフローを紹介します。

Metalシェーディング言語はC++ベースの言語であり、そのコンパイルモデルはCPUコンパイルモデルによく似ています。

GPUワークロードの複雑さが増すにつれて、Metalは現代のユースケースをサポートするために必要な柔軟性とパフォーマンスに対処するために同様に進化しました。

シェーダーのオーサリング中にすでに直面している可能性のある一般的な課題は、パイプライン間でユーティリティコードを共有したり、再コンパイルせずに実行時にシェーダーの動作を変更したり、アプリケーションの起動時にコンパイルされたGPUバイナリを再利用したりする機能です。

では、簡単なシェーダーコードを見て、シナリオについて話し合いましょう。

ここでは、条件の結果に応じて、foo()またはbar()の結果を返す単純なフラグメントシェーダーがあります。

さて、これらの関数が複数のパイプラインによって呼び出された場合は、一度だけコンパイルして、代わりに各パイプラインにリンクすることをお勧めします。

実行時にこれらの関数の異なる実装をリンクする必要があるかもしれませんし、baz()の新しいケースステートメントを処理するために拡張可能なフラグメントシェーダーが必要になるかもしれません。

また、フラグメント関数からbaz（）の代わりに、ユーザー提供の関数bat（）を呼び出すこともできます。

ご覧のとおり、シェーダーオーサリングパイプラインにはさまざまな要件があり、Metalはさまざまな実装をサポートするためのさまざまなAPIを提供しています。

各アプローチは、コンパイル時間とシェーダーのパフォーマンスの間で異なるトレードオフがあります。

そして今日は、パフォーマンスと柔軟性の完璧なバランスを見つけるのに役立つ新しいコンパイルワークフローについて話したいと思います。

レンダリングパイプラインの動的ライブラリと、レンダリングパイプラインの関数ポインタの新しいサポートから始めます。

binaryArchive APIへの追加について少し話します。

その後、プライベートリンク関数が表示されます。

そして最後に、メタルの可視機能をステッチするためのまったく新しい機能を紹介します。

では、Metalの動的ライブラリサポートから始めましょう。

動的ライブラリは、ソフトウェアエンジニアリングにおける一般的なツールです。

これらは、ユーティリティコードをスタンドアロンのコンパイルユニットに区画化できる共有オブジェクトファイルです。

それらは、コンパイルされたシェーダーコードの量を減らし、複数のパイプライン間で再利用するのに役立ちます。

さらに、GPUバイナリコードを動的にリンク、ロード、共有することができます。

昨年、コンピューティングパイプライン用の動的言語を導入し、Metalの動的ライブラリをさらに紹介するために、前年のプレゼンテーション「MetalでGPUバイナリを構築する」をチェックすることをお勧めします。

今年は、レンダリングとタイルパイプラインに動的ライブラリを導入します。

この追加サポートにより、すべてのコンピューティングとレンダリングワークロードでユーティリティライブラリを共有できるようになりました。

そして、動的ライブラリが何であるかがわかったので、いくつかのユースケースについて話す時が来ました。

ヘルパー関数は、一般的なコンピューティング、頂点、フラグメント、およびタイルシェーダーでよく使用されます。

パイプラインをレンダリングするための動的ライブラリを追加することで、大量のユーティリティコードを管理し、すべてのワークロードで共有できるようになりました。

パイプラインの作成中にロードされるライブラリを変更するだけで、コンパイルが遅くなることなく、実行時に使用できるライブラリを事前にコンパイルしたり、ランタイムの機能を切り替えたりできます。

また、ソースを提供することなく、パイプラインの一部としてロードできるシェーダーコードをユーザーが作成するのに役立ちます。

そこで、動的ライブラリを使用するタイミングについて話し合いました。

それでは、それらを構築し、一緒に作業する方法を見てみましょう。

フラグメントシェーダーの例では、関数 foo() と bar() を呼び出しますが、コンパイル時にどちらの実装も提供していません。

代わりに、これらの関数の実装は、後でレンダリングパイプラインを作成するときにリンクするMetalライブラリに存在します。

また、使用できる機能ごとに個別のライブラリを提供することも可能です。 

それでは、Metalで動的ライブラリを構築することで、あなたが持っているツールと柔軟性について話し合いましょう。

まず、MetalシェーダーソースをAIRにコンパイルする必要があり、ビルドプロセスの一部としてXcodeのMetalツールチェーンを使用するか、実行時にnewLibraryWithSource APIを使用してソースからコンパイルすることで、これを行うことができます。

AIRでコンパイルされたMetalシェーダーを使用すると、newDynamicLibrary APIを使用するだけで動的ライブラリを作成できるようになりました。

このライブラリは、GPUバイナリ形式で使用する準備ができています。

しかし、後で実行して再利用したい場合はどうなりますか?

これを行うには、動的ライブラリをディスクにシリアライズすることができ、これはserializeToURL APIを使用して行うことができます。

そして後で、newDynamicLibraryWithURL APIを呼び出すことで再利用することができます。

それでは、動的ライブラリとフラグメントシェーダーから関数を呼び出す例を見てみましょう。

この例では、extern キーワードを使用して関数 foo() と bar() を宣言しますが、それらの定義は提供していません。

それらを使用するには、フラグメントシェーダーからこれらの関数を呼び出すだけです。

また、Metalライブラリを構築するときに外部機能の実装を提供できます。

さて、これらの実装を実行時に別のものに置き換えることも可能です。

これを行うには、動的ライブラリを適切なプリロードされたライブラリ配列に追加するだけです。

私たちの場合、それは断片ですが、ステージとパイプラインごとに同様のプロパティが利用可能です。

そして、シンボルは、ライブラリがこの配列に追加されるのと同じ順序で解決されます。

このワークフローは、新しい実装を試すのに適しています。

そして、それは動的ライブラリのためのものです。

Metalダイナミックライブラリを使用する場合は、macOS MontereyのApple GPUファミリー7以降のコンピューティングパイプラインがサポートされています。

他のGPUやほとんどのMacファミリー2デバイスでも利用できますが、Metalデバイスは動的ライブラリをサポートする必要があります。

iOS 15では、この機能はすべてのApple 6デバイス以上で利用できます。

レンダリングとタイルのパイプラインのサポートは、Apple 6の機能セットをサポートするすべてのデバイスで利用できます。

次に、今年登場するファンクションポインタの改善について話しましょう。

関数ポインタは、これまでに見たことのない関数を呼び出すことで、コードを拡張可能にするために呼び出すことができるコードを参照するための単純な構造です。

昨年、コンピューティングパイプライン関数ポインタを導入しました。そのために、前年のプレゼンテーション「金属関数ポインタを知る」をチェックすることをお勧めします。

今年は、Apple Siliconのレンダリングおよびタイルパイプラインに機能ポインタのサポートを拡張します。

動的ライブラリと同様に、関数ポインタを使用すると、カスタマイズ可能なパイプラインを作成できます。

関数ポインタを使用すると、GPUパイプラインはパイプラインのコンパイル中に見られなかったコードを呼び出すことができます。

関数ポインタテーブルを使用すると、異なる関数テーブルをバインドするとき、またはGPUパイプラインが関数ポインタテーブルにインデックスを作成するときに、コード実行の動作が動的に変化する可能性があります。

また、関数ポインタを使用して、コンパイルパフォーマンスとランタイムパフォーマンスのバランスをとる方法を決定することもできます。

たとえば、最速のコンパイルのために、関数ポインタをGPUバイナリに事前コンパイルし、パイプラインをすばやく処理することができます。

一方、最高のランタイムパフォーマンスを得るには、パイプライン参照関数のAIR表現を持つことができ、コンパイラが最大限の最適化を行うことができます。

それでは、コードで関数ポインタを設定する方法を見てみましょう。

3つの基本的な構成要素があります。

まず、関数をインスタンス化し、これらの関数を使用してパイプラインを設定し、最後に関数テーブルを作成します。

これが完了したら、新しいレンダリングループを使用することは、多くのコードを伴いません。

それでは、各ステップの詳細に飛び込みましょう。

関数ポインタの使用を開始するには、まず関数記述子を宣言し、関数のGPUバイナリバージョンをコンパイルするためにインスタンス化します。

これにより、パイプラインの作成時間が短縮され、記述子を宣言し、バイナリにコンパイルするオプションを設定するのと同じくらい簡単です。

この記述子を使用してライブラリからMetal関数fooが作成されると、関数はGPUバックエンドコンパイラによってコンパイルされます。

次に、レンダリングパイプライン記述子を設定する必要があります。

まず、パイプライン記述子を介して、それらが使用されるステージ（頂点、フラグメント、またはタイルステージ）に追加します。

AIRまたはバイナリ形式で機能を追加することを選択できます。

AIR関数を追加すると、コンパイラは目に見える関数を静的にリンクし、バックエンドコンパイラがコードを最適化できるようにします。

一方、バイナリ関数を追加すると、どの外部にコンパイルされた関数が特定のパイプラインから呼び出すことができるかをドライバーに通知します。

ここで注意すべきことの1つは、バイナリ関数を使用するパイプラインを作成し、ここで示すように、呼び出しているコードに複雑なコールチェーンがある場合、コンパイラは深さを決定するために静的分析を行うことができないため、必要な最大コールスタックの深さを指定することが重要です。

コンパイラはデフォルトで実行される最大深度になり、深さが正しく指定されていない場合、スタックオーバーフローが発生する可能性があります。

対照的に、深さを正しく指定することは、より良いリソースの概念と最適なパフォーマンスにつながります。

したがって、記述子が完全に設定されたら、関数ポインタを使用する準備ができているパイプラインを作成できます。

パイプラインを作成した後、次のステップは、目に見える関数テーブルを作成し、APIに関数ハンドルを入力することです。

まず、記述子を使用して目に見える関数テーブルを作成し、レンダリングステージを指定します。

次に、これらの関数を参照するための関数ハンドルを作成します。

関数ハンドルとテーブルの両方は、特定のパイプラインと選択したステージに固有です。

その後、setFunction APIを使用して関数テーブルにハンドルを挿入できます。

それでは、すべてのセットアップが完了した後、この関数テーブルをどのように使用するかを見てみましょう。

まず、コマンドとコーディングの一部として、目に見える関数テーブルをバッファインデックスにバインドします。

シェーダー自体では、visible_function_tableがバッファバインディングとして渡され、このテーブルを介して関数を呼び出すことができます。

そして、それは関数ポインタを使用する単純なケースでした。

ファンクションポインタを使用する場合、1つ以上の追加機能にアクセスする必要があることを後で知るためにパイプラインを作成することは珍しくありません。

さて、同じ記述子から2番目のパイプラインを作成することでそれを達成することができれば、追加機能を追加しますが、パイプラインのコンパイルがトリガーされます。

このプロセスを加速するために、Metalでは、元のパイプラインを拡張する予定があるかどうかを指定できます。

これにより、既存のパイプラインから新しいパイプラインをより速く作成でき、元のパイプライン用に最初に作成されたすべての関数ポインタテーブルを使用できます。

コードからこれを行うには、元のパイプラインを作成するときに、拡張するすべてのステージに対して、supportAddingBinaryFunctionsオプションをYESに設定します。

次に、拡張パイプラインを作成する必要がある場合は、RenderPipelineFunctionDescriptorを作成し、フラグメント長関数リストに新しいバイナリ関数bat()を含めます。

最後に、renderPipeline1で追加のバイナリ関数を使用して新しいRenderPipelineStateを呼び出すと、同じですが、追加の関数ポインタバットを含むrenderPipeline2を作成します。

そして、それはほとんどそれです。

関数ポインタの使い方を見たので、ここでそれらを使用することができます。

コンピューティングパイプラインのファンクションポインタは、Apple GPUファミリ6以上、macOS Big Sur、およびiOS 14でサポートされています。

また、Macファミリー2デバイスでもサポートされています。

そして今年は、Apple GPUファミリー6以降、Mac OS Monterey、およびiOS 15のレンダリングおよびタイルパイプラインの機能ポインタサポートを拡張します。

私が話したい次のトピックは、バイナリ関数のコンパイルオーバーヘッドの管理です。

シェーダーのコンパイルは非常に時間がかかり、アプリケーションにもたらすオーバーヘッドを制御したいと思うかもしれません。

それを助けるために、私たちは昨年MetalにbinaryArchivesを追加しました。

BinaryArchivesは、コンパイルされたバイナリバージョンのパイプラインを収集してディスクに保存し、コンパイル時間とその後の実行を節約し、コンパイルに関連するメモリコストを削減できます。

今年は、可視機能と交差関数をbinaryArchivesに保存する機能を追加し、オーバーヘッドを大幅に削減できます。

では、binaryArchivesに保存してロードする方法を見てみましょう。

BinaryArchiveに関数を追加するには、addFunctionWithDescriptorを呼び出して、関数記述子とソースライブラリを引数として渡すだけです。

BinaryArchiveからバイナリ関数ポインタをロードするには、関数記述子のbinaryArchives配列にBinaryArchiveを配置し、MetalライブラリメソッドnewFunctionWithDescriptorを呼び出します。

配列内のアーカイブのいずれかにコンパイルされた関数ポインタがある場合、再コンパイルすることなく、すぐに返されます。

newFunctionWithDescriptorがbinaryArchivesでどのように動作するかを示すルールをいくつか紹介します。

まず、BinaryArchiveリストで関数のバイナリバージョンを検索します。

関数が見つかった場合は返され、見つからない場合は、CompileToBinaryオプションをチェックし、バイナリコンパイルが要求されなかった場合は、関数のAIRバージョンを返します。

一方、バイナリコンパイルが要求された場合、パイプラインオプションに応じて、FailOnBinaryArchiveMissは実行時に関数バイナリをコンパイルするか、nilを返します。

MTLBinaryArchiveをアプリケーションに統合すると、同じアーカイブを使用してすべてのGPUコンパイルコードを保存できます。

レンダリング、タイル、計算パイプライン、およびバイナリ関数ポインタ。

また、アーカイブにパイプライン状態オブジェクトとバイナリ関数が事前に入力された後、それをディスクにシリアライズすることができます。

この方法でGPUバイナリを収集して保存することは、その後のアプリケーションの実行にシェーダーのコンパイルを加速するのに役立ちます。

関数ポインタでパイプラインを使用する場合は、パイプラインの状態オブジェクト自体をキャッシュしたい場合があります。

しかし、異なる関数ポインタの組み合わせが付属するパイプラインがあるのに、なぜキャッシュする必要があるのですか?

たとえば、ここでは、ユーザー関数ポインタを除いて、同一の3つのパイプライン記述子があります。

したがって、AIR関数ポインタを使用している場合は、パイプラインのすべての順列をキャッシュする必要があります。

ただし、バイナリ関数ポインタを使用する場合、新しい関数ポインタが追加されてもパイプラインのバイナリコードは変更されないため、単一のバリアントをキャッシュするだけで十分です。

また、そのアーカイブを使用して、パイプライン記述子で使用されるバイナリ関数ポインタとは無関係に、パイプラインの他のすべてのバリアントを見つけることができます。

それをまとめるには、パイプラインのコンパイルコストを制御するのに最適なツールであるため、常にMetalでbinaryArchivesを使用する必要があります。

binaryArchivesのサポートはすべてのデバイスで利用できますが、BinaryArchiveへの関数ポインタの追加は、関数ポインタの能力に依存します。

さて、今年の次の追加について簡単にお話ししたいと思います。これはプライベートリンク機能です。

これまでのところ、動的ライブラリと関数ポインタがシェーダー開発パイプラインに多くの柔軟性を提供する方法について議論しましたが、パフォーマンス上の理由から、外部関数をパイプラインに静的にリンクしたい場合があります。

昨年、AIR関数を静的にリンクすることをサポートするlinkedFunctions APIを追加しました。

ただし、これは関数テーブルで使用可能であるため、関数ポインタのサポートが必要です。

今年はプライベート機能を導入します。

関数とprivateFunctionの両方がAIRレベルで静的にリンクされていますが、これらはプライベートであるため、関数ポインタの関数処理を行うことはできません。これにより、コンパイラはシェーダーコードを完全に最適化できます。

それで、彼らはどこで利用できますか?

この機能はAIRレベルのコードで動作するため、macOS MontereyとiOS 15のすべてのデバイスで利用できます。

今日議論したい最後の追加、ファンクションステッチに移ります。

一部のアプリケーションは、実行時に動的コンテンツを生成する必要があります。

たとえば、ユーザー入力に基づいてグラフィックエフェクトのカスタマイズを実装します。

または、例えば、受信データに基づく複雑なコンピューティングカーネル。

ファンクションステッチは、これを解決するための素晴らしいツールです。

ファンクションステッチの前に、これを行う唯一の方法は、メタルソースストリングを生成することでした。

文字列操作技術はやや非効率的であり、MetalからAIRへの変換が実行時に行われることも意味します。これは高価な操作になる可能性があります。

では、ファンクションステッチの仕組みを見てみましょう。

関数ステッチは、実行時に計算グラフとプリコンパイルされた関数から関数を生成するメカニズムを提供します。

計算グラフは指向性非巡回グラフです。

そして、グラフには、生成された関数の引数を表す入力ノードと、関数呼び出しを表す関数ノードの2種類のノードがあります。

また、あるノードから別のノードへのデータの流れ方を表すデータエッジと、関数呼び出しを実行する順序を表すコントロールエッジの2種類のエッジもあります。

関数ステッチが計算グラフを使用して関数を生成する方法を見ていきます。

ステッチ可能な関数の概念から始めます。

グラフ内の関数には、ステッチ可能な属性が必要です。

このような関数は、functionStitching APIで使用できる可視関数です。

ステッチ可能な機能は、MetalからAIRへの翻訳コストを避けるために、アプリケーションバンドルに同梱されているMetalライブラリの一部にすることができます。

ステッチプロセスは、AIRで直接機能を生成し、メタルフロントエンドを完全にスキップします。

生成された関数は通常のステッチ可能な関数であるため、パイプラインにリンクしたり、関数ポインタとして直接使用したり、他の関数の生成に使用できます。

したがって、前のグラフを考慮して、前述したように、ライブラリから二重関数AとCがあると仮定しましょう。

では、これらの関数をグラフにバインドするとどうなるか見てみましょう。

ここでのスティッチャーは、対応する関数タイプを各関数ノードに関連付けます。

N0とN1はFunctionAから型を取得し、N2はFunctionCから型を取得します。

その後、スティッチャーは、それらを使用して関数のパラメータ型を見て、入力ノードの型を推測します。

たとえば、Input0は、N0とN1の最初の引数であるため、ポインタで考案された型であると推測されます。

その後、スティッチャーは、Metalで説明されている次の関数と同等の機能を生成します。

functionStitching APIを使用すると、そのような関数を含むライブラリをAIRから直接生成できます。

そして今、私たちはステッチがどのように機能するかについて公正なアイデアを持っているので、APIでそれを使用する方法は次のとおりです。

まず、ステッチされた関数入力を定義する必要があります。

この場合、すべての引数を説明するのに十分な入力ノードを作成するだけです。

次に、グラフで呼び出す各関数の関数ノードを作成します。

関数呼び出しごとに、明示的な順序付け要件がある場合は、名前、引数、および制御の依存関係を定義します。

そして最後に、関数名、グラフで使用される関数ノード、および適用したい関数属性を含むグラフを作成します。

また、結果のステッチ関数の出力値が返されるoutputNodeも割り当てます。

だから、私たちはグラフを持っています。

これで、それを使って関数を作成できます。

最初のステップは、StitchedLibraryDescriptorを作成することです。

stitchableFunctionsとfunctionGraphをこの記述子に追加します。

次に、記述子を使用してライブラリを作成し、このライブラリからステッチ関数を作成できます。

このステッチ機能は、別のステッチグラフの機能を含め、ステッチ可能な機能が期待される場所ならどこでも使用できるようになりました。

そして、それは機能ステッチのためです。

このAPIは、macOS MontereyとiOS 15のすべてのデバイスでも利用できます。

そこで、簡単な要約として、今日はレンダリングパイプラインの動的ライブラリと関数ポインタを見てみました。

プライベートリンク関数は、可視関数を静的にリンクするために使用できます。

そして、シェーダーを動的に作成するときに、関数ステッチがコンパイル時間を節約する方法。

では、いつどちらか一方を選びますか?

動的ライブラリは、ヘルパー機能とユーティリティ機能をリンクするための優れた選択肢です。

また、ユーティリティ関数の固定セットがある場合に最もよく使用され、それらの関数はあまり頻繁に変更されません。

関数ポインタは、シェーダーが署名以外に何も知らない関数を呼び出す機能を追加します。

いくつの関数が存在するか、名前、または開発者がAIRまたはバイナリを使用して行った速度と柔軟性のトレードオフを知る必要はありません。

そして今年は、関数ポインタをキャッシュすることもできます。

プライベート関数は、関数をパイプライン状態オブジェクトに名前で静的にリンクする方法を提供します。

それらはパイプラインの内部にあるため、目に見える関数テーブルにエンコードすることはできませんが、コンパイラが最大限の最適化を行うことを可能にし、すべてのGPUファミリでサポートされています。

そして最後に、関数ステッチは、コードのスニペットをAIRに直接事前コンパイルし、実行時に関数コンパイルを実行する方法を提供します。

今日メタルシェーダーストリングを合成していて、実行時にソースからコンパイルするコストを支払わなければならない場合、ファンクションステッチはこのワークフローを大幅に加速します。

これらのコンパイラ機能を活用して、Metalを使用して新しい体験を開発できることを願っています。

見てくれてありがとう、そしてWWDC 2021の残りの部分を楽しんでください。

[音楽]。