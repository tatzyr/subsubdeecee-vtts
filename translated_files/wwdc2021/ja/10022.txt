10022

♪ベース音楽の演奏♪

♪

マット・リケットソン：こんにちは、私はマットです。後でルカとラジが加わります。

今日は、SwiftUIを解明します。

さて、SwiftUIは宣言的なUIフレームワークであることを何度も聞いたことがあります。

つまり、アプリに欲しいものを高いレベルで説明し、SwiftUIはそれを実現する方法を正確に決定します。

さて、ほとんどの場合、これはうまくいきます!

そして、それはSwiftUIが魔法のように感じるときです。

しかし、SwiftUIがあなたが期待しないかもしれないことをする瞬間は常にあります。

そして、それらの瞬間に、あなたが探している結果を得る方法についてより良い直感を構築するために、SwiftUIが舞台裏で何をしているのかをもう少し理解するのに役立ちます。

だから今日の質問は、SwiftUIがあなたのコードを見るとき、何が見えますか?

答えは、アイデンティティ、生涯、依存関係の3つです。

アイデンティティとは、SwiftUIがアプリの複数のアップデートで要素を同じまたは異なるものとして認識する方法です。

ライフタイムは、SwiftUIが時間の経過とともにビューとデータの存在を追跡する方法です。

そして、依存関係は、SwiftUIがインターフェイスを更新する必要があるときとその理由を理解する方法です。

これら3つの概念は、SwiftUIが何を、どのように、いつ変更する必要があるかをどのように決定するかを知らせ、その結果、画面に表示される動的なユーザーインターフェイスが得られます。

今日は、これら3つの概念のそれぞれについてより深く話します。

アイデンティティから始めましょう、そしてここには私を助けてくれる友達が何人かいます。

これらのルビースパニエルは愛らしいですが、深い哲学的な質問の対象でもあります。

この2匹の犬は違うの？

それとも、これらは実際には、同じ犬の2枚の写真ですか?

真実は、それは言うことは不可能です!

私たちは十分な情報を持っていないだけです。

しかし、物事が同じか異なるかというこの質問は、私たちが「アイデンティティ」と呼ぶものの中心です。

しかし、アイデンティティは犬にとって重要なだけではありません。

また、SwiftUIがアプリをどのように理解しているかの重要な側面でもあります。

例を見てみましょう。 例を見てみましょう。

これは私が作った「グッドドッグ、バッドドッグ」というアプリで、私の毛皮のような友人が彼女の最高の行動をとっているかどうかを追跡するのに役立ちます。

それはかなり簡単です。

画面上の任意の場所をタップするだけで、良い状態と悪い状態を切り替えることができます。

では、アイデンティティは私のアプリと何の関係があるのでしょうか?

まあ、それは実際に私たちが犬について尋ねた哲学的な質問と非常によく似ています。

これらのアイコンを見ると、それらは互いに完全に異なる2つの異なるビューのように見えますか?

それとも、同じビューで、ちょうど別の場所で、異なる色で?

その区別は、インターフェイスが1つの状態から別の状態に移行する方法を変えるため、実際には非常に重要です。

これらのアイコンは、実際には異なる見解だとしましょう。

つまり、フェードインやフェードアウトなど、アイコンは独立して移行する必要があります。

しかし、もし彼らが実際に同じ見解だったらどうでしょうか?

それは代わりに、ある場所から別の場所に移動する同じビューであるため、トランジション中にビューが画面を横切ってスライドする必要があることを意味します。

したがって、SwiftUIがそれらの間の移行方法を理解する方法であるため、異なる状態間のビューを接続することは重要です。

これは、ビューアイデンティティの背後にある重要な概念です。

同じアイデンティティを共有するビューは、同じ概念的なUI要素の異なる状態を表します。

対照的に、異なるUI要素を表すビューは、常に異なるアイデンティティを持ちます。

講演の後半で、LucaとRajは、ビューアイデンティティがアプリのデータと更新サイクルに及ぼす実用的な影響について話します。

とりあえず、SwiftUIで使用される2つの異なるタイプのアイデンティティに焦点を当てて、コードでアイデンティティがどのように表現されているかを見てみましょう。

まず、明示的なアイデンティティ：カスタムまたはデータ駆動型の識別子を使用します。

そして第二に、構造的アイデンティティ：ビュー階層のタイプと位置によってビューを区別する。

さて、これらの概念を理解するために、私の友人をさらに紹介しましょう。

さて、特に犬が同じように見える場合は、犬を区別するのは難しいことを覚えておいてください。

では、どのような追加情報が私たちの犬を識別するのに役立ちますか?

1つの方法は、単に彼らの名前を尋ねることです。

2匹の犬が同じように見え、同じ名前を共有している場合、実際には同じ犬である可能性が高いと思います。

しかし、彼らが異なる名前を持っている場合、私たちは彼らが実際には異なる犬であることを保証することができます。

このような名前や識別子を割り当てることは、明示的なアイデンティティの一形態です。

明示的なアイデンティティは強力で柔軟ですが、誰かがどこかでそれらのすべての名前を追跡する必要があります。

すでに使用されている可能性のある明示的なアイデンティティの1つの形式は、UIKitとAppKit全体で使用されるポインタアイデンティティです。

現在、SwiftUIはポインタアイデンティティを使用していませんが、それについて学ぶことは、SwiftUIの仕組みと理由をよりよく理解するのに役立ちます。

ざっと見てみましょう。

このようなUIKitまたはAppKitのビュー階層を考えてみましょう。

UIViewsとNSViewsはクラスであるため、それぞれがメモリ割り当てへの一意のポインタを持っています。

ポインタは明示的なアイデンティティの自然な源です。

ポインタを使用するだけで個々のビューを参照することができ、2つのビューが同じポインタを共有している場合、それらが本当に同じビューであることを保証できます。

しかし、SwiftUIビューは値型であり、一般的にクラスではなく構造体として表されるため、SwiftUIはポインタを使用しません。

2019年の「SwiftUI essentials」トークでは、SwiftUIがビューにクラスの代わりに値タイプを使用する理由について話し合ったので、そのトークを見て詳細を学ぶことをお勧めします。

今のところ、知っておくべき重要なことは、値型には、SwiftUIがビューの永続的なアイデンティティとして使用できる正規参照がないということです。

代わりに、SwiftUIは他の形式の明示的なアイデンティティに依存しています。

例えば、この救助犬のリストを考えてみましょう。

ここで使用されるidパラメータは、明示的なアイデンティティの形式です。

各救助犬のドッグタグIDは、リスト内の対応するビューを明示的に識別するために使用されます。

救助犬のコレクションが変更された場合、SwiftUIはこれらのIDを使用して、何が正確に変更されたかを理解し、リスト内で正しいアニメーションを生成できます。

この場合、SwiftUIは異なるセクション間を移動するビューを正しくアニメーション化することさえできました。

より高度な例を見てみましょう。

ここでは、ScrollViewReaderを使用して、下部のボタンを使用してビューの上部にジャンプします。

Id(_:)修飾子は、カスタム識別子を使用してビューを明示的に識別する方法を提供します。この場合、ページの上部にあるヘッダービューです。

次に、その識別子をスクロールビュープロキシのscrollTo(_:)メソッドに渡して、SwiftUIにその特定のビューに行くように指示することができます。

これの素晴らしいところは、すべてのビューを明示的に識別する必要はなく、ヘッダーテキストのように、コードの他の場所で参照する必要があるビューだけであるということです。

比較すると、ScrollViewReader、ScrollView、バックストーリーテキスト、およびBbuttonは明示的な識別子を必要としません。

しかし、彼らのアイデンティティが明示的ではないからといって、たとえ明示的でなくても、すべてのビューにアイデンティティがあるため、これらのビューにアイデンティティがまったくないわけではありません。

ここで構造的アイデンティティの出番です。

SwiftUIは、ビュー階層の構造を使用してビューの暗黙のアイデンティティを生成するので、その必要はありません。

さて、私が何を意味するのかを説明するのを手伝うために、もう少し友達を連れてきましょう。

似たような犬を2匹飼っていますが、名前はわかりませんが、それぞれを識別する必要があります。

さて、これらは非常に良い犬であり、彼らは非常にじっと座っていることができると仮定します。

彼らが動かないことを保証することができれば、「左側の犬」や「右側の犬」のように、彼らが座っている場所に基づいてそれらを識別することができます。

私たちは、被験者の相対的な配置を使用して、それらを互いに区別しています。それは構造的アイデンティティです。

SwiftUIはAPI全体で構造的アイデンティティを活用し、典型的な例は、Viewコード内でifステートメントやその他の条件付きロジックを使用する場合です。

条件文の構造は、各ビューを識別するための明確な方法を提供します。

最初のビューは条件がtrueの場合にのみ表示され、2番目のビューは条件がfalseの場合にのみ表示されます。

つまり、たとえ同じように見えたとしても、どのビューがどのビューであるかを常に伝えることができます。

ただし、これは、SwiftUIがこれらのビューが元の場所にとどまり、場所を交換しないことを静的に保証できる場合にのみ機能します。

SwiftUIは、ビュー階層の型構造を見ることでこれを達成します。

SwiftUIがあなたのビューを見ると、その一般的なタイプが表示されます。この場合、私たちのifステートメントは、真と偽のコンテンツに対して一般的な_ConditionalContentビューに変換されます。

この翻訳は、Swiftの結果ビルダーの一種であるViewBuilderによって供給されています。

Viewプロトコルは、ViewBuilderでbodyプロパティを暗黙的にラップし、プロパティのロジックステートメントから単一の汎用ビューを構築します。

私たちのボディプロパティのいくつかのビューリターンタイプは、この静的な複合タイプを表すプレースホルダであり、コードを乱雑にしないように隠します。

このジェネリックタイプを使用すると、SwiftUIは、真のビューが常にAdoptionDirectoryであり、Falseビューが常にDogListであり、舞台裏で暗黙の安定したアイデンティティを割り当てることができることを保証できます。

実際、これは以前のGood Dog、Bad Dogアプリを理解するための鍵です。

上部のコードでは、条件付きブランチごとに異なるビューを定義するifステートメントがあります。

SwiftUIは、ifステートメントの各ブランチが異なるアイデンティティを持つ異なるビューを表すことを理解しているため、ビューのインとアウトが遷移します。

あるいは、レイアウトと色を変更する単一のPawViewを持つこともできます。

別の状態に移行すると、ビューは次の位置にスムーズにスライドします。

これは、一貫したアイデンティティを持つ単一のビューを変更しているからです。

これらの戦略は両方とも機能しますが、SwiftUIは一般的に2番目のアプローチを推奨しています。

デフォルトでは、アイデンティティを維持し、より流動的な遷移を提供するようにしてください。

これはまた、ルカが後でより詳細に話すあなたのビューの寿命と状態を維持するのに役立ちます。

構造的アイデンティティを理解したので、その邪悪な宿敵であるAnyViewについて話す必要があります。

AnyViewの使用の影響を理解するために、それがビューの構造に及ぼす影響を見てみましょう。 ビューの構造への影響を見てみましょう。

以前、AdoptionDirectoryとDogListを切り替えるために、このifステートメントを書きました。

SwiftUIがこのコードを見ると、右側に一般的な型構造が表示されます。

では、AnyViewを広範囲に使用する別の例を見てみましょう。

これは、犬の品種を表すビューを得るために私が書いたヘルパー機能です。

関数の各条件付きブランチは異なる種類のビューを返すので、Swiftは関数全体に単一の戻り値タイプを必要とするため、それらをすべてAnyViewsでラップしました。

残念ながら、これはSwiftUIが私のコードの条件付き構造を見ることができないことも意味します。

代わりに、AnyViewを関数の戻り値タイプとして見るだけです。

これは、AnyViewが「タイプ消去ラッパータイプ」と呼ばれるもので、一般的な署名からラッピングしているビューのタイプを隠すためです。

しかし、おそらくもっと重要なのは、このコードは私たち単なる人間にとっても本当に読みにくいことです。

このコードを簡素化し、その構造をより多くSwiftUIに表示できるかどうか見てみましょう。

まず、近くに羊がいる場合、このブランチはBorderCollieViewと一緒にSheepViewを条件付きで追加しているように見えます。

ビューの周りにHStackを条件付きで追加するのではなく、HStack内にビューを条件付きで追加することで、これを簡素化できます。

その変更により、各ブランチから単一のビューを返すことが簡単にわかるようになったので、ローカルのdogView変数は必要ありません。

代わりに、各ブランチ内のリターンステートメントに置き換えることができます。

先に見たように、通常のSwiftUIビューコードは、異なるタイプのビューを返すifステートメントを使用できます。

しかし、コードからreturn文とAnyViewsを削除しようとすると、いくつかのエラーと警告が表示されます。

これは、SwiftUIがヘルパー関数から単一のリターンタイプを必要とするためです。

では、どうすればこれらのエラーを避けることができますか?

ViewプロトコルがViewBuilderで暗黙的にラップするため、ビューのbodyプロパティは特別であることを思い出してください。

これは、プロパティ内のロジックを単一の一般的なビュー構造に変換します。

現在、Swiftはヘルパー関数がデフォルトでビュービルダーであると推測しませんが、ViewBuilder属性を手動で適用することでオプトインできます。

これにより、警告やエラーなしに、リターンステートメントとAnyViewラッパーを削除できます。

さて、私たちのコードは今かなり良さそうです!

AnyViewsをすべて削除して、以前よりも読みやすくしました。

そして、結果の型シグネチャを見ると、条件付きコンテンツのツリーで関数の条件付きロジックを正確に複製し、SwiftUIにビューとそのコンポーネントのアイデンティティのより豊かな視点を提供します。

しかし、私たちができる小さな改善がもう1つあります。

私たちの機能のトップレベルは、犬の品種のさまざまなケースと一致しているだけです。

これは、ビュービルダーでもサポートされているスイッチステートメントの優れたユースケースのようです。

今では、私たちの見解のすべての異なるケースをすばやく理解することがさらに簡単になりました。

また、スイッチステートメントは実際には条件付きステートメントの構文的な砂糖にすぎないため、右側の結果のビューのタイプ署名はまったく同じままです。

一歩下がって、AnyViewsがコードからタイプ情報を消去する方法を示し、ビュービルダーを活用して不要なAnyViewsを取り除く方法を紹介しました。

一般的に、可能な限りAnyViewsを避けることをお勧めします。

AnyViewsが多すぎると、コードの読み取りと理解が難しくなることがよくあります。

If/elseやswitchなどの従来の制御フローステートメントにより、ビューのさまざまな可能な状態をはるかに見やすくなります。

また、AnyViewはコンパイラから静的型情報を隠すため、有用な診断エラーや警告がコードに表示されるのを防ぐことができます。

最後に、必要がないときにAnyViewを使用すると、パフォーマンスが低下する可能性があることに注意してください。

可能であれば、ジェネリックを使用して、コードの周りにAnyViewsを渡すのではなく、静的型情報を保持します。

そして、SwiftUIで基本的なタイプのビューアイデンティティを導入し終えました。

明示的なアイデンティティを使用すると、ビューのアイデンティティをデータに結び付けたり、特定のビューを参照するためのカスタム識別子を提供したりできます。

また、構造的アイデンティティを使用して、SwiftUIがビュー階層内のタイプと位置に基づいてビューを識別する方法を学びました。

そして今、私はルカに物事を引き渡して、あなたの見解のアイデンティティが彼らの生涯と状態とどのように関連しているかについて話し合います。

ルカ・ベルナルディ:ありがとう、マット。

SwiftUIがあなたのビューを識別する方法を理解したので、アイデンティティがビューとデータの寿命にどのように関連しているかを探りましょう。

これは、SwiftUIがどのように機能するかをよりよく理解するのに役立ちます。

これを説明するために、私も友人を連れてくるつもりです。

これはテセウスです。

彼も可愛くないですか？

誰かがもっと愛らしいと言うだろうが、私は脱線する。

お気に入りのペットに名前を付けると、異なる州にいて一日中動いても、いつも同じ愛らしい猫になると考えるのは非常に直感的です。

私たちが一瞬彼を見ると、彼は眠いかもしれませんし、しばらくして、適切な猫として、彼は私の存在に悩まされています - しかし、彼はいつもテセウスです。

これがアイデンティティと生涯を結びつける本質です。

アイデンティティを使用すると、時間の経過とともに異なる値に対して安定した要素を定義できます。

言い換えれば、時間の経過とともに継続性を導入することができます。

これはSwiftUIにどのように適用されるのか疑問に思うかもしれません。

だから、マットが取り組んでいたアプリの猫に優しいバージョンを持ち帰りましょう。

テセウスが時間の異なる瞬間に異なる状態にあるように、私たちの見解も生涯を通じて異なる状態にあります。

すべての状態は、私たちの見解にとって異なる値です。

アイデンティティは、これらの異なる値を時間の経過とともに単一のエンティティ（ビュー）として接続します。

これを明確にするために、いくつかのコードを見てみましょう。

ここでは、喉の強さを示す簡単なビューがあります。

ネタバレ：テセウスはかなりうるさいです。

ボディの評価を通じて、SwiftUIはこのビューの新しい値を作成します。この場合、強度値は25です。

テセウスはお腹が空いていて、もっと注目を集めている。

ボディはより高い強度で再び呼び出され、ビューの新しい値が作成されます。

これらは、同じビュー定義から作成された2つの異なる値です。

SwiftUIは、比較を実行し、ビューが変更されたかどうかを知るために値のコピーを保管します。

しかし、その後、価値は破壊されます。

ここで理解することが重要なのは、ビューの値がビューのアイデンティティとは異なるということです。

ビューの値は一時的であり、その寿命に頼るべきではありません。

しかし、あなたがコントロールできるのは彼らのアイデンティティです。

ビューが最初に作成され、それが表示されると、SwiftUIは以前に説明したテクニックの組み合わせを使用してアイデンティティを割り当てます。

時間が経つにつれて、更新によって駆動され、ビューの新しい値が作成されます。

しかし、SwiftUIの観点から見ると、これらは同じ見解を表しています。

ビューのアイデンティティが変更されるか、ビューが削除されると、その寿命は終了します。

ビューの寿命について話すときはいつでも、そのビューに関連するアイデンティティの期間を参照しています。

ビューのアイデンティティとその寿命を結びつけることができることは、SwiftUIがあなたの状態をどのように持続させるかを理解するための基本です。

では、StateとStateObjectを画像に入れましょう。

SwiftUIがあなたのビューを見て、StateまたはStateObjectを見ると、ビューの存続期間中、そのデータを保持する必要があることを知っています。

言い換えれば、StateとStateObjectは、ビューのアイデンティティに関連付けられた永続的なストレージです。

ビューのアイデンティティの開始時に、初めて作成されたとき、SwiftUIは初期値を使用してStateとStateObjectのメモリ内のストレージを割り当てます。

ここでは、タイトル状態に焦点を当てています。

ビューの存続期間中、SwiftUIはこのストレージが変異し、ビューの本体が再評価されると、このストレージを永続化します。

アイデンティティの変化が国家の永続性にどのように影響するかの具体的な例を見てみましょう。

私たちは同じ見解を持っていますが、2つの別々の枝にあるので、これは興味深い例です。

以前から覚えていれば、構造的なアイデンティティのために、2つのビューは異なるアイデンティティを持っていると見なされます。

マットはこれがアニメーションにどのように影響するかについて議論しましたが、これはあなたの状態の永続性にも大きな影響を与えます。

これを実際に見てみましょう。

最初にボディを評価し、真のブランチに入ると、SwiftUIは初期値で状態の永続ストレージを割り当てます。

このビューの存続期間中、SwiftUIはさまざまなアクションによって変異するにつれて状態を持続します。

しかし、dayTimeの値が変更され、偽のブランチを入力するとどうなりますか?

SwiftUIは、これが明確なアイデンティティを持つ異なる見解であることを知っています。

状態の初期値から始めて、偽のビューの新しいストレージを作成し、真のビューのストレージは直後に割り当て解除されます。

しかし、私たちが本当の支店に戻ったらどうなりますか?

さて、それは再び新しいビューなので、SwiftUIは州の初期値から再び開始して、新しいストレージを作成します。

ここでのポイントは、アイデンティティが変更されるたびに、状態が置き換えられるということです。

ここで少し立ち止まって、この重要な点を理解していることを確認してください。あなたの状態の永続性は、あなたの見解の寿命に結びついています。

ビューの本質であるもの、つまりその状態を明確に分離し、それをそのアイデンティティに結びつけることができるため、これは非常に強力な概念です。

他のすべてはそれから導き出すことができます。

そして、あなたのデータは非常に重要なので、SwiftUIには、あなたのビューの明示的なアイデンティティの形式としてあなたのデータのアイデンティティを使用する一連のデータ駆動型構造を持っています。

これの標準的な例はForEachです。

それでは、ForEachを初期化するさまざまな方法を見てみましょう。

これは、このタイプの周りにより良い直感を構築するのに役立ちます。

ForEachの最も単純な形式は、一定の範囲を取るものです。

これは、特に新しいUIのプロトタイピングを始めるときに、非常に便利な初期化子です。

SwiftUIは、この範囲のオフセットを使用して、ビュービルダーによって生成されたビューを識別します。

一定の範囲を要求することで、ビューの存続期間中、アイデンティティが安定していることを保証します。

実際、この初期化子をダイナミックレンジで使用するのはエラーです。

そして、今年は新しく、非一定の範囲を提供するときに警告が表示されます。

物事をより面白くし、ダイナミックなデータ収集をもたらしましょう。

この初期化子は、識別子として機能するプロパティへのコレクションとキーパスを取ります。

SwiftUIはその値を使用して、コレクションの要素から生成されたすべてのビューにアイデンティティを割り当てるため、このプロパティはハッシュ可能でなければなりません。

後で、Rajは、安定したアイデンティティを選択することがアプリのパフォーマンスと正確性にどのように影響するかの例をいくつか紹介します。

データに安定したIDを提供するというこのアイデアは非常に重要であるため、標準ライブラリはこの機能を記述するために識別可能なプロトコルを定義します。

また、SwiftUIはこのプロトコルを最大限に活用し、キーパスを省略し、プロトコル要件によって提供される識別子を使用して、データとビューに関連付けられたIDを定義できます。

私がスウィフトについて本当に気に入っているのは、そのタイプシステムを利用して、解決している問題の制約を正確に説明できることです。

だから、私たちがここで使用している初期化子の定義を見てみましょう。

この短い定義には興味深いものがたくさんあるので、それらを解凍してみましょう。

ForEachには、一般的な引数データで示されているコレクションと、コレクションの各要素からビューを生成する方法の2つの主要な部分が必要です。

この初期化子の形状は、ForEachがデータのコレクションとビューのコレクションの関係を定義するという直感を与えるはずです。

しかし、実際には、ここで最も興味深いのは、コレクションの要素を識別可能に制約することです。

繰り返しますが、識別可能なプロトコルの目的は、SwiftUIがその生涯を通じてデータを追跡できるように、タイプがアイデンティティの安定した概念を提供できるようにすることです。

実際、これは先ほど議論したアイデンティティと生涯の概念と非常によく似ています。

識別可能なタイプとビュービルダーを取るSwiftUIビューは、データ駆動型のコンポーネントです。

これらのビューは、指定したデータのアイデンティティを使用して、それに関連付けられたビューの寿命をスコープします。

良い識別子を選択することは、ビューとデータの寿命を制御する機会です。

では、このセクションで議論したことを要約しましょう。

ビューの値は一時的なものであり、その寿命に頼るべきではありません。

しかし、彼らのアイデンティティはそうではなく、時間の経過とともに継続性を与えるものです。

あなたは自分の見解のアイデンティティをコントロールしており、アイデンティティを使用して状態の寿命を明確にスコープすることができます。

そして最後に、SwiftUIはデータ駆動型コンポーネントの識別可能なプロトコルを最大限に活用しているため、データの安定した識別子を選択することが重要です。

そして今、伝統を続けて、私はそれをRajに引き渡すつもりです。ラージ？

ラージ・ラママーシー:ありがとう、ルカ!

これまでのところ、私たちはアイデンティティとは何か、そしてそれがビューの生涯とどのように結びついているかを説明しました。

次に、SwiftUIがUIを更新する方法について説明します。

目標は、SwiftUIコードを構造化する方法について、より良いメンタルモデルを提供することです。

また、最後にすべてを概説するいくつかの例を紹介します。

依存関係に関するこの議論をキックオフするために、ビューを見てみましょう。

これは簡単な見方です。

犬におやつをプレゼントするボタンが表示されます。

申し訳ありませんが、ルカ、私は犬派です。

ビューの構造に焦点を当てましょう。

まず、一番上を見てみましょう。

2つのプロパティがあります。1つは犬用、もう1つはおやつ用です。

これらのプロパティはビューの依存関係です。

依存関係はビューへの入力にすぎません。

依存関係が変更されると、ビューは新しいボディを生成する必要があります。

本文は、ビューの階層を構築する場所です。

このビューの階層に飛び込むと、アクション付きのボタンがあります。

アクションは、ビューの依存関係の変更をトリガーするものです。

コードを同等の図に交換しましょう。

これが私たちのDogViewの図です。

ボタンをタップすると、犬に報酬を与えるアクションが送信されます。

私たちの犬はあっという間におやつを飲み込みます。

そして、それは犬への変更をもたらします - 多分彼は別の犬を望んでいます。

依存関係が変わったため、DogViewは新しいボディを生成します。

SwiftUIのデータフローの一般的な概念の詳細については、WWDC 2020の「SwiftUIのデータエッセンシャル」をチェックしてください。

次に、この図を少し単純化しましょう。

ビュー階層に焦点を当てて、私たちのビューがどのように木のような構造を形成するかに注目してください。

そして、犬を追加して依存関係を一番上に戻すと、それはまだ木のように見えます。

ただし、DogViewは依存関係を持つ唯一のビューではありません。

SwiftUIでは、各ビューは独自の依存関係を持つことができます。

これまでのところ、これはまだ木のように見えます。

ただし、同じ状態やその他のデータに依存する複数のビューが存在する可能性があることに注意してください。

例えば、子孫の1人も犬に依存しているかもしれません。

そして、これは私たちの他の依存関係の1つに起こる可能性があります。

だから私たちは木から始めましたが、この構造は今では木に大まかにしか似ていません。

実際、重複する線を避けるために再配置すると、この構造になり、これは実際にはグラフであり、木ではないことがわかります。

実際、私たちはこの構造を「依存グラフ」と呼んでいます。

この構造は、SwiftUIが新しいボディを必要とするビューのみを効率的に更新できるため、重要です。

例えば、一番下の依存関係を考えてみましょう。

この依存関係を調べると、2つの依存ビューがあります。

グラフの秘密は、依存関係が変更された場合、それらのビューのみが無効になることです。

SwiftUIは各ビューのボディを呼び出し、各ビューに新しいボディ値を生成します。

SwiftUIは、無効になった各ビューの本文の値をインスタンス化します。

その結果、より多くの依存関係が変わるかもしれませんが、必ずしもそうとは限りません!

ビューは値タイプであるため、SwiftUIはそれらを効率的に比較して、ビューの適切なサブセットのみを更新できます。

これは、ルカが以前に議論したことを見る別の方法です。

ビューの値は短命です。

構造体値は比較に使用されますが、ビュー自体の寿命は長くなります。

そして、それが私たちが中央のビューのための新しいボディを生成するのを避けることができる方法です。

アイデンティティは依存関係グラフのバックボーンです。

マットが言ったように、明示的に指定されているか構造的に指定されているかにかかわらず、すべてのビューにはアイデンティティがあります。

そのアイデンティティは、SwiftUIが適切なビューに変化し、UIを効率的に更新する方法です。

依存関係には多くの種類があります。

先ほど、トリートプロパティとドッグバインディングでいくつかの例を見ましたが、環境、状態、または観測可能なオブジェクトプロパティラッパーのいずれかを使用して依存関係を形成することもできます。

次に、あなたの見解におけるアイデンティティの使用を改善する方法についてお話ししたいと思います。

これは、SwiftUIがあなたのコードをよりよく理解するのに役立ちます。

ルカが言ったように、ビューの寿命はそのアイデンティティの期間であり、それは識別子の安定性が重要であることを意味します。

安定していない識別子は、ビューの寿命が短くなる可能性があります。

また、安定した識別子を持つことは、SwiftUIがビューのストレージを継続的に作成し、グラフを更新してチャーンする必要がないため、パフォーマンスにも役立ちます。

先ほど見たように、SwiftUIは永続ストレージを管理するためにライフタイムを使用するため、状態の損失を回避するために安定した識別子も重要です。

識別子の安定性の重要性を説明するために、コード例を見てみましょう。

この例では、私のお気に入りのペットのリストがあります。

ペット構造体には識別子があります。

しかし、実際にはバグがあります。新しいペットを飼うたびに、画面上のすべてが点滅します!

ちょっと立ち止まって、このコードを見てみましょう。

虫がどこにあるか見つけられますか?

バグは、私たちの識別可能な適合性でここにあります。

テストに合格しなかった場合は、心配しないでください。このセクションにはおやつはありません。

問題は、この識別子が安定していないため、データが変更されるたびに新しい識別子を取得することです。

代わりに、ペット配列のインデックスを使用した場合はどうなりますか?

残念ながら、これにも同様の問題があります。

インデックスを使用することで、ビューはコレクション内のそれぞれのペットの位置によって識別されるようになりました。

私が新しい最初のお気に入りのペットを飼うと決めた場合、他のすべてのペットはアイデンティティを変更し、悪いバグを引き起こす可能性があります。

この例では、ボタンはインデックスゼロに新しい要素を挿入しますが、最後のインデックスは新しいインデックスであるため、開始ではなく最後に挿入されます。

これは、計算されたランダム識別子と同様に、インデックスはアイデンティティの安定した形式ではないためです。

この例では、データベースからのものやペットの安定したプロパティから派生したような安定した識別子を使用する必要があります。

永続的な識別子は素晴らしい選択です。

今、私たちのアニメーションは素晴らしく見えます!

しかし、優れた識別子に必要な特性は安定性だけではありません。

良い識別子のもう一つの特性は一意性です。

各識別子は、単一のビューにマッピングする必要があります。

これにより、アニメーションが素晴らしく見え、パフォーマンスがスムーズになり、階層の依存関係が最も効率的な形式に反映されます。

別の例を見てみましょう。

この例では、私はペットのお気に入りのおやつのすべてでビューに取り組んでいます。

それぞれのおやつには、名前、絵文字、有効期限があります。

私はそれぞれのおやつをその名前で識別することを選択しました。

この時点で - 私はあなたが推測できると確信しています - ここにもバグがあります。

同じ種類のおやつが複数あるとどうなりますか?

あなたのことは知りませんが、私は犬のビスケットを大量に買うのが好きです。

瓶に追加すると、表示されない場合があります。

問題は、おやつの名前が一意の識別子ではないことです。

代わりに、治療ごとにシリアル番号またはその他の一意のIDを使用できます。

そして、これはすべての正しいデータが私たちの瓶に表示されることを保証します。

また、より良いアニメーションとより良いパフォーマンスを保証します。

SwiftUIが識別子を必要とするとき、それはあなたの助けが必要です!

ランダムな識別子を使用する場合、特に計算されたプロパティでは注意してください。

一般的に、すべての識別子を安定させたいと考えています。

識別子は時間の経過とともに変更されるべきではありません。新しい識別子は、新しいライフタイムを持つ新しいアイテムを表します。

そして最後に、識別子は一意である必要があります。

複数のビューは識別子を共有できません。

SwiftUIは、アプリをスムーズかつバグのない状態に実行するために、これらのプロパティに依存しています。

明示的なアイデンティティについて話したので、構造的なアイデンティティに移りたいと思います。

この例では、私は以前からトリートジャーに取り組んでいます。

責任あるペット愛好家として、私はペットに最高級の未期限の食品しか与えます。

おやつがいつ悪くなったかを知るために、おやつの有効期限が切れたときにオプションでおやつセルを暗くする新しい修飾子を追加しました。

暗くなっているセルを強調しました。

修飾子に飛び込みましょう。

修飾子で、私は日付を持っていて、それを現在の日付と比較して、いつビューを暗くするかを知ることができます。

これは最初は問題ないようですが、ここには微妙な問題があります。

条件が変化し、私たちの治療が期限切れになった場合、ここにブランチがあるため、新しいアイデンティティになります。

マットが議論したように、枝は構造的アイデンティティの一形態です。

これは、オプションで修正された単一のコピーではなく、コンテンツの2つのコピーがあることを意味します。

ここのブランチは修飾子にあることに注意してください。

明確にするために、私は修飾子とその使用サイトを同じスライドに置きましたが、あなたのプロジェクトでは、気づかずにファイル間でこのようなブランチがあるかもしれません!

もちろん、ここで説明したことはすべて、ビューとビュー修飾子に適用されます。

では、どうすればこれを避けることができますか?

さて、1つの方法は、枝を折りたたんで、不透明度修飾子の中で条件を移動することです。

このブランチを削除することで、このビューは単一のアイデンティティを持つと正しく説明しました。

さらに、不透明度修飾子内の条件を移動すると、依存コードを厳密にスコープしたため、パフォーマンスに役立ちます。

条件が変更されると、不透明度のみを変更する必要があります。

これのコツは、条件が真の場合、不透明度が1で、このように見えることです。

不透明度1は効果がありません。

このような修飾子は、レンダリングされた結果に影響を与えないため、「不活性修飾子」と呼びます。

SwiftUI修飾子は安いので、このパターンには固有のコストはほとんどありません。

結果として生じる視覚効果がないため、フレームワークは修飾子を効率的に剪定し、コストをさらに削減できます。

ブランチは素晴らしく、SwiftUIに存在するのには理由があります。

しかし、不必要に使用すると、パフォーマンスの低下、驚くべきアニメーション、そしてルカが示したように、状態の喪失さえも引き起こす可能性があります。

ブランチを導入するときは、1秒間一時停止し、複数のビューを表しているのか、同じビューの2つの状態を表しているのかを検討してください。

見たように、単一のビューを識別するためにブランチの代わりに不活性修飾子を使用する方がうまくいくことがよくあります。

以下は、不活性修飾子のほんの一例です。

私は特に、環境に条件付きで書くためのtransformEnvironmentが大好きです。

すべてをまとめると、私たちは今日、アイデンティティが素晴らしいパフォーマンスの秘訣の1つであることをあなたに示しました。

明示的で構造的なアイデンティティと、それぞれを活用してアプリを改善する方法について議論しました。

アイデンティティから、関連するストレージ、トランジションなどを制御するビューの寿命を導き出すことができます。

また、SwiftUIはアイデンティティとライフタイムを使用して依存関係を形成し、UIを効率的に更新できるグラフで表されることも説明しました。

SwiftUIの謎を解くとともに、バグを回避し、アプリのパフォーマンスを向上させるためのヒントとコツをいくつか紹介しました。

そして、これらのトリックを学んだので、コードのツアーに参加して、彼らがあなたを助けることができるかどうかを確認してください。

ありがとう、そして素晴らしいアプリを作り続けてください!

♪