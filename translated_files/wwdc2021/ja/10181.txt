10181

みなさん、こんにちは。

私の名前はシェファリ・サブーで、アップルのパフォーマンスツールエンジニアです。

一緒にアプリケーションのパフォーマンスをナビゲートする際に、私はあなたのガイドになります。

今日の旅は、パフォーマンスの世界を巡るスリリングなツアーになります。

あなたのアプリは、私たちのデバイスでの全体的なソフトウェア体験において重要な役割を果たします。

アプリを最適化し、パフォーマンスを向上させ続けることは、ユーザーがアプリをより頻繁に使用し、よりエンゲージメントを維持し、アプリを長期間使用することを意味します。

パフォーマンスの最適化は、追跡する多くの指標と使用するツールを持つ困難な作業のように思えるかもしれません。

しかし、恐れることはありません。

このサバイバルガイドでは、開発を次のレベルに引き上げ、可能な限り最高の顧客体験を確保するのに役立つツール、メトリクス、パラダイムをスピードアップします。

私たちのパフォーマンスツールとあなたがそれらを使ってできる素晴らしいことを歩きながら、あなたのガイドになることにとても興奮しています。

今日取り上げる5つの主要なツールがあります。Xcode Organizer、MetricKit、Instruments、XCTest、App Store Connect APIです。

主要な指標を簡単に紹介することから始めます。

次に、各ドメイン領域の一般的な問題と、それらを解決して防止する方法について説明します。

そして最後に、次のステップで終わります。

パフォーマンスの最適化は、多くの停留所がある長い川のようなものです。

ナビゲーションに必要ないくつかの異なるツールがあり、各停留所で学ぶべき新しい何かがあります。

川を下って旅行しましょう。

まず、簡単な紹介です。

今日取り上げるさまざまなパフォーマンス指標を見てみましょう。 

現在、アプリケーションのパフォーマンスを追跡するには、バッテリー使用量、起動時間、ハングレート、メモリ、ディスク書き込み、スクロール、終端、MXSignpostsの8つの重要なポイントがあります。

これらはすべて、当社のツールセットを通じて追跡できます。

私は、ユーザーがその週の食事を追跡し、クールなレシピを保存できるMealPlannerというアプリの開発者です。

これは、特にスクロールヒッチの形で、私のアプリ内の貧弱なユーザーエクスペリエンスの例です。

遅い、スキップする、そして不安なスクロールに気づきましたか?

反対に、これはシームレスなユーザーエクスペリエンスとヒッチのない同じアプリケーションです。

私たちはすでに2つの経験の間にかなりの違いがあることがわかります、そしてこのスムーズなスクロールは、あなたがパフォーマンスの最適化を通じて達成するのを助けたいものです。

各パフォーマンスメトリックには、独自のパラダイムセットと共通のツールがあります。

各ドメイン領域の一般的な問題と、それらを解決して防止する方法に飛び込みましょう。

川沿いの最初の停留所はバッテリー使用量です。

アプリが多くのバッテリーを消耗している場合、ユーザーが自分の側で見るものは次のとおりです。

これはバッテリーUIです。

これは、デバイス上のアプリの全体的なバッテリー消耗がどの程度貢献したか、およびフォアグラウンドとバックグラウンドアクティビティをユーザーに示します。

なぜバッテリー寿命の向上を気にする必要があるのですか?

簡単。

ユーザーは、充電を必要とせずに一日中デバイスを使用できるアプリの使用を優先します。

バッテリー寿命を最適化することで、ユーザーは自分のデバイスとアプリを長期間使用できます。

それ自体が勝利です。

バッテリー寿命の最適化に関しては、注意すべき多くの異なるサブシステムがあります。

メモする上位3つは、CPU、ネットワーク、およびロケーションです。

開発中またはバージョンがすでにリリースされた後、いくつかの異なるツールを使用して、アプリのバッテリー寿命を追跡してトリアージすることができます。

デスクで新機能を開発およびテストしている間、Xcodeを使用してコードをビルドして実行し、小さなスプレーボトルのように見えるデバッグナビゲーターをクリックして、Xcodeが提供するさまざまなゲージを確認します。

私が細心の注意を払うのはエネルギーゲージです。

エネルギーゲージを使用すると、アプリをテストしているときにCPU使用率を追跡でき、CPU使用率の高い領域とCPUウェイクオーバーヘッドが表示されます。

高いCPU使用率とは、CPU使用量が20%を超える場合であり、CPUウェイクオーバーヘッドは、CPUがアイドル状態からウェイクし、発生するエネルギーコストが発生する領域です。

アプリがユーザーインターフェイスを描画したり、ネットワークからデータを処理したり、計算を実行したりすると、CPUが急増するのが一般的ですが、これらのタスクが完了し、アプリがユーザーが次のアクションを実行するのを待っていると、CPU使用率がゼロまたはゼロに近いことがわかります。

ここから、タイムプロファイルをクリックして、Instrumentsでアプリをプロファイリングし、プロファイリングされた期間のサーマル状態、CPU使用率、およびアクティブなコールスタックを確認することもできます。

また、ロケーションエネルギーモデルを使用して、コアロケーションの影響を測定し、アプリが使用すべきでないときに場所を使用していないことを確認することもできます。

時折、私のアプリのベータ版またはリリース版にバグがあり、私の机で再現するのが難しいか、デバッグするためにより多くのロギングとコンテキストが必要な場合があります。

オールインワンのパフォーマンステレメトリフレームワークとしてデバイス上で動作するMetricKitは、根本原因を絞り込み、顧客が直面している問題について貴重な洞察を提供するのに役立ちます。

MetricKitを使用するには、アプリにAppMetricsというカスタムクラスを追加して実装し、この新しいクラスをMXMetricManagerSubscriberプロトコルに適合させるだけです。

その後、カスタムクラスへの参照をマネージャーに追加できます。

そして、推奨されるベストプラクティスであるdeinitに関する私のカスタムクラスへの参照を削除します。

このデータは、対応するdidReceiveメソッドで処理できます。

戦略的に行われれば、エネルギーログやCPUメトリックなど、オーガナイザーで見つけるのと同じデータの多くを、問題が発生したときに何が間違っていた可能性があるかについてのMemetricKitのコンテキストデータで拡張できます。

オンデバイス分析パイプラインのおかげで、このデータのシンプルなバージョンは、余分な労力なしで利用できます。

ユーザーがアプリを使用する際に、同意したデバイスからパフォーマンスデータを収集します。

このデータは、当社のサーバーに集約され、Xcodeオーガナイザーなどの多くのツールの1つを介してお客様に返送されます。

Xcodeオーガナイザーにアクセスして、すでにアプリストアにあるアプリのバージョンのパフォーマンスデータを見るのは、Xcodeが開いている間にメニューバーに移動し、ウィンドウに移動し、オーガナイザーをクリックして起動するのと同じくらい簡単です。

ここに来たら、バッテリー使用量メトリックをクリックして、過去16のアプリバージョンのアプリの集計データと、チャートの右側にある主要なサブコンポーネント別の詳細な内訳を表示できます。

私のアプリの最新バージョンに大きな回帰がある場合、Xcode 13で新しい回帰ペインに移動すると、バージョンがオーガナイザーに表示された直後にわかります。

この新しい回帰ペインは、私のアプリの最新バージョンで大幅に増加したすべてのメトリクスを分離するので、集中する必要があるすべてのものを1か所で見ることができます。

アプリのどの領域が問題を引き起こしたかを判断するために、レポートの下のEnergy Organizerを使用して、CPU使用率の高い地域と、同意したユーザーデバイスから収集されたログを表示することもできます。

これにより、私のアプリで何が起こっていたのかをより詳細に見ることができます。

App Store Connect APIも照会し、要求されたデータとともに返されるJSONペイロードで独自の分析を実行することで、このすべてのデータを取得できます。

これらのツールはすべて、私のアプリで多くのバッテリー使用量の回帰を簡単にキャッチして解決することができます。

バッテリー寿命の最適化の詳細については、2019年の「バッテリー寿命とパフォーマンスの向上」トークをチェックし、Instrumentsの使用の詳細については、今年の「InstrumentsのHTTPトラフィックを分析する」トークをチェックしてください。

次の目的地はハングレートとスクロールで、私のアプリが反応しなかったことを伝える2つの指標です。

ハングとは、アプリが少なくとも250ミリ秒間ユーザーの入力またはアクションに応答しない場合です。

アプリにハングすると、顧客がアプリスイッチャーからアプリケーションを強制的に終了させる可能性があり、アプリでのユーザーエクスペリエンスにとって大きな障害となり、優先順位を付ける必要があります。

吃音スクロールは、新しいコンテンツが次の画面更新の準備ができていないときに発生します。

これらは、不快なユーザーエクスペリエンスと全体的なフラストレーションにつながり、その結果、ユーザーはアプリに費やす時間が少なくなります。

アプリ開発者として、目標はユーザーエンゲージメントの量を最大化することなので、これは最適化を始めるのに最適な場所です。

先ほどお見せした滑らかなスクロールを覚えていますか？

これを目指すことは、ユーザーにとって最善の利益です。

それぞれのビューに移動することで、Xcodeオーガナイザーでハングとスクロールメトリクスを追跡できます。

私のアプリが何をしているかに細心の注意を払う必要がある兆候は、チャートのいずれかが上昇傾向にあることに気付いた場合、またはスクロールの場合、このグラフのように、グラフが緑のバーではなく黄色と赤のバーを表示していることに気付いた場合です。

チャートの右側のキーによると、赤いバーは、以前にビデオで見たスクロール体験が悪いことであり、すぐに修正する必要があります。

このデータは、App Store Connect APIからも利用可能になりました。

スレッド状態またはシステムコールトレースを使用して、インストゥルメントを使用してハングの原因を検出できます。

スレッド状態トレースインストゥルメントは、スレッドの状態と、OSがスレッドの実行をスケジュールしたタイミングのタイムラインを表示します。

詳細セクションでは、スレッドがどのくらいの期間ブロックされたかがわかります。

システムコールトレースは、入力されたシステムコールと時間がかかった時間を詳述した物語を示しています。

ユーザーのスクロール体験に影響を与えるバグのあるアプリバージョンをリリースしていないことを確認するために、XCTestでパフォーマンステストを書いて、アプリを起動してスクロールすることができます。

このテストでは、スクロールデセルレーションサブメトリックを測定したいと指定し、メジャーブロックの本文では、アプリで期待するスクロール速度で上にスワイプしています。

このメジャーブロックはデフォルトで5回実行されるため、XCTMeasureOptionsを使用して実行間のアプリケーション状態をリセットします。

これを測定ブロックに渡し、測定を停止してから、アプリケーションの状態をリセットすることができます。

時には、強制テストケースでの応答性の問題を再現するのは簡単ではないかもしれません。

幸いなことに、MetricKitは、私の本番アプリケーションに展開されると、発生した時点でこれらの問題のテレメトリと診断を収集することができます。

ハングの場合、iOS 14では、MetricKitは24時間のケイデンスでこれらの診断を私に提供します。

iOS 15とmacOS 12の新機能で、問題が発生した直後に、ハングを含むすべての診断をアプリで受け取ります。

これらのインスタント診断を私自身のテレメトリと組み合わせて使用することで、最も差し迫った応答性の問題をすばやく根本原因と解決できます。

スクロールヒッチの場合、iOS 15はMetricKit内に新しいAPIを導入し、MXSignpostを使用してカスタムアニメーションにタグを付けます。

MXSignpostは、テレメトリの重要なコードセクションをマークできるMetricKitに同梱されているラッパーAPIです。

MXSignpostAnimation-IntervalBegin APIを使用すると、カスタムアニメーションの始まりを戦略的にマークすることができます。

MXSignpostエンドAPIを使用すると、アニメーションの終了をマークし、その間隔でヒッチレートテレメトリを収集できます。

これら2つの機能は、この間隔の詳細なパフォーマンスデータをキャプチャするだけでなく、発生したヒッチもキャプチャします。

ハングを理解して排除する方法の詳細については、今年の「アプリからハングを理解して排除する」トークをチェックすることをお勧めします。

スクロールヒッチの問題を特定する方法の詳細については、2020年の「XCTestを使用してヒッチを解消する」トークと「UIアニメーションヒッチとレンダリングループを探索する」技術トークをチェックすることをお勧めします。

ディスク書き込みの議論に進むにつれて、私たちは今、中途半端なマークに近づいています。

ディスクへの書き込みは、ユーザーのNANDを消耗させる可能性があり、デバイスの健全性が低下します。

書き込みにも多くの時間がかかり、頻繁に行うとユーザーエクスペリエンスが低下し、パフォーマンスが低下する可能性があるため、これらの書き込みをバッチ処理することが重要です。

アプリのバージョンをリリースする前に、Instrumentsのファイルアクティビティテンプレートを使用してアプリをプロファイリングできます。

これは、システムコールの形でファイルシステムの使用を記録するので、アプリのコードでファイルシステムにアクセスしている場所を簡単に識別できます。

システムの善良な市民になり、ディスクへの書き込みを制限する方法はたくさんあります。

一般的なもののいくつかは、書き込み操作をバッチ処理し、頻繁に変化するデータにコアデータを使用し、迅速なファイルの作成と削除を回避することです。

アプリのプロファイリングに加えて、XCTestでパフォーマンステストを書いて、アプリのディスク使用量を測定し、過剰なディスク書き込みのコードがユーザーのデバイスで実行されるのを防ぐこともできます。

これは、XCTStorageMetricのインスタンスをmeasureWithMetric APIに渡し、ディスクに書き込むコードを呼び出すのと同じくらい簡単です。

このテストは、ブロック内のコードによってディスクに書き込まれたデータ量を測定し、Xcode自体内で結果を表示します。

ブロック内のコードがそれを超えた場合にテストが失敗するように、ディスクに書き込まれる予定のデータ量のベースラインを設定できます。

これは、私がバグのあるコードを出していないことを確認するのに役立ちます。

ディスク書き込みの高いアプリのバージョンをすでにリリースしている場合は、オーガナイザーを使用してユーザーデバイスでのパフォーマンスを追跡できます。

ディスク書き込みメトリックは、以前にリリースされたバージョンと比較して、私のアプリの現在のバージョンが実行している書き込みの数の傾向を示しています。

グラフのスパイクは、私のアプリに大量の書き込みを引き起こしているバグがあることを示している可能性があります。

私はこれらの書き込みのトップソースを特定し、それらを理解し、それらを減らす方法を探す必要があります。

ディスク書き込みレポートを見ることで、これらの書き込みのソースを探すことができます。

これらは、私のアプリが24時間以内に1GB以上を書き込むときに生成される例外レポートのコレクションです。

スタックトレースは、コードのどこで過度の書き込みをしていたかを示し、Xcode 13で新しく、Insightsと呼ばれる追加の詳細を取得することもできます。これにより、システムの善良な市民になり、アプリの書き込みの一部を減らすことができる簡単な最適化が示されます。

このすべてのデータは、App Store Connect APIを通じて私にも利用可能になりました。

また、アプリケーションで発生した時点で、これらのレポートをMetricKitで取得することもできます。

MetricKitを使用してアプリのディスク使用状況を監視している場合は、MXSignpost間隔で重要なディスク書き込みパスを予約して、より詳細なテレメトリを収集することができ、最適化の機会を発見するのに役立ちます。

ディスク書き込みの問題をシームレスに特定して解決する方法の詳細については、今年の「アプリの電力とパフォーマンスの回帰の診断」トークに必ず同調してください。

次の停留所に近づくと、打ち上げ時間と終了について話し合います。

起動時間は、ユーザーがアプリのアイコンをタップして、最初のフレームがアプリでレンダリングされるまでの時間です。

ユーザーがアプリの起動を待つのに長い時間を費やすと、ユーザーにとって意図しない不満につながる可能性があり、起動時間が長くなり、システムがアプリを終了する可能性があります。

システムがアプリを終了すると、ユーザーは最初から起動フロー全体を経験し、バックグラウンド実行状態から再開するよりもはるかに時間がかかります。

プロセスの終了は、システムメモリ制限のヒットと超過、起動時にタイムアウトするなど、さまざまな理由で発生する可能性があります。

これらの理由のいずれかでアプリが終了するたびに、ユーザーが次回アプリアイコンをタップすると、完全な起動フローが通過し、時間がかかるだけでなく、特に頻繁に発生する場合はイライラする経験でもあります。

状態を復元しない場合、これはユーザーが自分の場所を再び見つけたり、失われた仕事を再作成したりしなければならないという不満を増す可能性があります。

私はちょうど私のユーザーが彼らの食事のための写真や詳細なレシピを追加できる機能を備えた私のアプリの新しいバージョンをリリースしました。

この新機能で私のアプリの起動時間がどのように見えるか、そしてそれが以前にどのように見えたかを見てみましょう。

これは、新しい機能が追加されたので、私のアプリを起動しようとすると、ユーザーが見るものです。

最初のフレームをレンダリングしようとしてどれだけの時間が費やされたかに注目してください。

私のアプリは、私たちがそれを使用する機会を得る前に停止されました。

比較すると、その機能が追加される前の起動の様子は次のとおりです。

私のアプリが起動を予想し、最初のフレームを表示する準備ができていたようなものです。

これら2つの例から、最初の信じられないほど遅い起動は、ユーザーが私のアプリについて考えるときに覚えておいてほしいものではないことをすでに知っています。

だから、できるだけ早くこれを修正する必要があります。

起動の問題はすでにユーザーが使用している私のアプリのバージョンにあるので、オーガナイザーに行き、起動時間と新しい終了ペインを見ることから始めることができます。

起動時間を見ると、アプリの平均的な「最初のフレームまでの時間」が過去16バージョンで何であるかがわかるので、新しい機能が追加される前の速さがわかります。

また、終了ペインにアクセスして、起動に時間がかかるため、アプリがシステムによって終了される頻度を確認することもできます。

オーガナイザーを見た後、実際にはこれは私の新機能で導入されたかなり悪いバグであり、多くのユーザーを襲っているように見えます。

これを修正する方法を見てみましょう。これはどのように修正できるかを見てみましょう。

InstrumentsのApp Launchテンプレートを使用して、アプリの起動時間をプロファイリングすることで、デスクでこの問題をテストできます。

このテンプレートはアプリを5秒間実行し、その間にアプリの起動中に何が起こっていたかの時間プロファイルとスレッド状態のトレースを収集するので、スレッドがブロックされた理由を把握し、それを修正することができます。

また、先ほど見たものと同様の測定ブロックでXCTApplicationsLaunchMetricを使用して、パフォーマンスXCTestの起動時間を測定することもできます。

アプリにMetricKitを実装して独自の分析を行いたい場合は、デフォルトで毎日のメトリックペイロードの一部として終了テレメトリを受け取ります。

アプリが終了したときにデータ損失を回避するための状態の復元の詳細については、「なぜ私のアプリが殺されるのですか?」をチェックしてください。2020年から話します。

イェーイ、やったよ。

私たちは旅を終える前に最後の停留所にいます。

私たちの最後の停留所は記憶です。

メモリは、アプリ、OS、カーネル間の共有リソースです。

アプリがメモリ制限を超えると、システムによって終了し、次回ユーザーが起動すると、最初から起動し、バックグラウンド実行状態から再開するよりもはるかに時間がかかります。

私のアプリの新機能により、開発者は食事に写真や説明を追加できます。つまり、メモリ使用量が少し高くなる可能性があります。

このような場合、メモリ制限を超えるとアプリが終了する可能性があるため、オーガナイザーのメモリと終了のメトリックに目を光らせて、そうではないことを確認する必要があります。

終了していないように見えますが、オーガナイザーのサスペンションチャートのピークメモリとメモリによると、この新しいバージョンの私のアプリのメモリ使用量が大幅に急増しています。

Instrumentsのリーク、割り当て、およびVMトラッカーテンプレートを使用して、アプリのメモリ使用量をプロファイリングできます。

リークは、私のプロセスのヒープを調べ、リークされたメモリをチェックします。

割り当ては、私のアプリのメモリライフサイクルを分析します。

そして、VMトラッカーは、時間の経過とともに私のアプリの仮想メモリ空間を表示します。

MetricKitを使用して同じ情報を取得し、独自の分析を実行することもできます。

終端とメモリテレメトリを含む毎日のメトリックペイロードを使用することに加えて、重要なコードセクションの周りにMXSignpostsを計測して、メモリ使用量に関するより詳細なテレメトリをキャプチャすることもできます。

アプリケーションに入る前にメモリ回帰を解決する方法の検出と理解の詳細については、今年の「メモリ問題の検出と診断」の講演をご覧ください。

途中であなたを送る前に、今日ここで見たことをまとめて、次のステップをいくつか見ましょう。

私たちは、パフォーマンスの最適化を特定することがどれほど難しいかを理解しています。

過去数年間、開発者は、重要なパフォーマンスの最適化を行うために、私たちがあなたに提供するこれらの同じツールを使用してきました。

素晴らしい例は、何百万人もの人々が毎日使用しているアプリであるSnapchatです。

Snapchatは、アプリの起動体験を向上させ、終了に追いやすことに長年の献身を持っています。

昨年、Snapchatの望ましくない終了が99%減少しました。

私たちはそれが信じられないと思いますし、今日ここで説明したパフォーマンスツールとデータを使用して、あなたもこれを達成することができます。

パフォーマンスツールを初めて使用する場合は、2020年の「Xcodeオーガナイザーでパフォーマンスの問題を診断する」と「MetricKitの新機能」トーク、2020年の「パワーとパフォーマンスAPIでトレンドを特定する」トーク、2019年の「Instrumentsを使い始める」トークをチェックすることをお勧めします。

これらの指標とツールをすべて掘り下げた後、App Storeで最もパフォーマンスの高いアプリを出荷するために必要なリソースを十分に備えていることを願っています。

ユーザーは、シームレスなユーザーエクスペリエンスを楽しんでいるため、これに感謝します。

ここでは多くの資料が取り上げられていたので、楽しいエクササイズとして、Xcodeオーガナイザーを使用してアプリのパフォーマンスに関するトレンドデータを確認することをお勧めします。

インストゥルメントで提供されているさまざまなテンプレートを探索してプレイしてください。

リリースされる前に問題をキャッチするためにXCTestsを書くことに挑戦してください。

そして、MetricKitで分析の範囲を広げます。

パフォーマンスの最適化に関しては、私たちのツールが提供しなければならないものがたくさんあるので、あなたの手を汚し、それらに付属するすべてを探索することを躊躇しないでください。

今日の旅にご参加いただきありがとうございます。今年の会議で素晴らしい時間を過ごせることを願っています。

[明るい音楽]。