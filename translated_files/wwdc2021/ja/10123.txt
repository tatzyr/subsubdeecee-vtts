10123

WWDCへようこそ。

私はスクリーンタイムチームのエンジニアであるクリストファー・スコゲンです。新しいスクリーンタイムAPIについてお話しします。

AppleがiOS用のスクリーンタイムを導入してから3年が経ちました。

そして、それはお客様と家族のデバイスとの関係を改善するための大きな前進でした。

過去3年間で、スクリーンタイムはiPhone、iPad、Macにいくつかの素晴らしい新しい能力をもたらしました。

スクリーンタイムは、あなたとあなたの家族がアプリやウェブサイトを使用する頻度を追跡し、制限を設定して時間を管理し、家族と共有してデバイスがどのように使用されているかのビューを提供し、最後に、子供が誰と通信しているかなどを管理するのに役立ちます。

また、多くのお客様から、これらの機能の一部を独自のペアレンタルコントロールアプリで活用したいと聞いています。

そこで、スクリーンタイムAPIを作成しました。

アプリにコアスクリーンタイム機能をもたらすので、顧客にダイナミックな新しい体験を生み出すことができます。

まず、APIはiOSとiPadOS 15で利用可能になります。

最新のSwiftアプリケーションに簡単に統合するための100%SwiftとSwiftUIコードです。

スクリーンタイムAPIは、3つの指針に基づいて設計および構築されました。

まず、既存の制限への直接APIアクセスのための最新のオンデバイスフレームワークを提供します。

私たちの2番目の指針は、ユーザーのプライバシーを保護することでした。

スクリーンタイムは、使用したアプリや訪問したウェブサイトなど、非常に機密性の高い個人情報を処理するため、スクリーンタイムは常に非常にプライバシー中心のアプローチを取っています。

たとえば、家族やApple以外の人が、どのサイトにアクセスしたか、どのアプリを使用しているかを知る方法はありません。

新しいAPIでは、プライバシーに対するこのアプローチを継続し、顧客の使用データはデバイスの外部では見えなくなります。

そして最後に、私たちの3番目の指導原則は、開発者が素晴らしい新しいダイナミックなペアレンタルコントロール体験を作成できるようにすることでした。

私たちの3つの指導原則が3つの新しいフレームワークを作成するために私たちを導いたのは偶然ではありません。

3つのフレームワークをまとめると、スクリーンタイムAPIを構成します。

まず、管理された設定。

マネージド設定により、アプリはスクリーンタイムで利用可能なのと同じ制限に直接アクセスできます。

第二に、家族のコントロール。

ファミリーコントロールは、当社のプライバシーポリシーを推進しています。

そして最後に、デバイスのアクティビティ。

デバイスアクティビティを使用すると、アプリを起動せずにコードを実行するための優れた新しい能力をアプリに与えることで、スクリーンタイムを超えることができます。

3つのフレームワークすべてを詳しく見てみましょう。

管理された設定から始めましょう。

あなたのアプリは、子供が自分のデバイスで何ができるかを制限し、親または保護者がそうでないと言うまでそれらの制限が維持されるようにするためのより良い方法が必要です。

管理された設定を使用すると、アプリは、スクリーンタイムと同様に、アカウントのロック、パスワード変更の防止、Webトラフィックのフィルタリング、アプリケーションのシールドなど、多くの制限を設定できますが、アプリのブランディングと機能でカスタマイズできます。

次はファミリーコントロールです。

ファミリー共有を活用することで、ファミリーコントロールは保護者の承認なしにスクリーンタイムAPIへのアクセスを防ぎます。

アプリが保護者によって承認されると、保護者の承認なしにデバイスから削除することはできません。

さらに、ファミリーコントロールは、アプリやウェブサイトを表す不透明なトークンを提供します。

これらのトークンは、スクリーンタイムAPI全体で使用状況を監視または制限し、単一のファミリー共有グループ以外の誰もどのアプリやウェブサイトが使用されているかを知らないようにします。

そして最後に、デバイスのアクティビティ。

このフレームワークでは、ウェブやアプリの使用状況を監視し、必要に応じてコードを実行する新しい方法をアプリに与えることで、スクリーンタイムを超えることができます。

あなたのアプリはペアレンタルコントロールアプリなので、子供が自分のデバイスでアプリを実行する理由がある可能性は非常に低いです。

では、制限を設定するためにコードをどのように実行しますか?

答えは、デバイスアクティビティのスケジュールとイベントです。

デバイスアクティビティスケジュールは、タイムウィンドウの開始時と終了時にアプリケーションの拡張機能を呼び出すタイムウィンドウです。

イベントは、デバイス上のユーザーがデバイスアクティビティスケジュールの使用しきい値に達したときに、拡張機能を呼び出す使用状況モニターです。

アプリは、どのような使用状況を気にし、いつ気にするかを宣言するだけです。

3つのフレームワークをすべて組み合わせると、次のようになります。

アプリが保護者と子供のデバイスの両方にインストールされた後、保護者は子供のデバイスでアプリを開きます。

あなたのアプリはファミリーコントロールで承認されます。

その後、保護者のデバイス上のアプリは、設定、制限、およびルールを選択します。

アプリはその情報を子供のデバイスに送信します。

そして、子供のデバイスで、アプリはデバイスアクティビティでスケジュールとイベントを作成します。

アプリのデバイスアクティビティ拡張機能は、スケジュールが発生したとき、またはイベントが発生したときに呼び出されます。

拡張機能から、管理された設定で制限を設定します。

ノーランを紹介する良い機会です。

ノーランは素晴らしい新しいデモアプリ「宿題」に取り組んでおり、宿題がスクリーンタイムAPIをどのように使用しているかを説明します。

こんにちは、私はスクリーンタイムチームのエンジニア、ノーランです。

私のデモアプリ、宿題を紹介したいと思います。

宿題は、保護者が使用を希望する他のアプリでの使用を蓄積するまで、特定のアプリへの子供のアクセスを制限することで、良い習慣を奨励します。

宿題を機能させるために、スクリーンタイムAPIの3つのフレームワークをすべて使用します。

まず、ファミリーコントロールの承認をリクエストする順を追って説明します。

次に、保護者が選択した落胆したアプリを定期的なスケジュールで保護します。

次に、十分に奨励されたアプリの使用を蓄積した後、それらのシールドを削除する方法を紹介します。

最後に、アプリのブランディングと機能に合わせて、宿題で使用されるシールドをカスタマイズします。

プロジェクトのセットアップとファミリーコントロールの承認から始めます。

ファミリーコントロール機能を含むようにXcodeプロジェクトを設定するには、プロジェクトエディタに移動し、アプリのターゲットを選択し、署名と機能の下でプラスボタンをクリックします。

ファミリーコントロールを検索して機能を見つけてプロジェクトに追加します。

機能が追加されたので、コーディングの準備が整いました。

宿題が最初にする必要があるのは、ファミリーコントロールの承認を要求することです。

ファミリーコントロールフレームワークの共有承認センターを使用して、アプリの起動時にこのリクエストを行います。

リクエストは成功または失敗につながる可能性があります。

この機能を呼び出すには、家族の保護者が宿題のためのファミリーコントロールを承認する必要があります。

私のアプリはこれまでこのiPhoneで実行されたことがないので、requestAuthorizationはアラートで保護者の承認を求めます。

許可をタップすると、保護者にApple IDとパスワードで認証して続行するように求められます。

保護者が正常に認証されると、requestAuthorizationを呼び出すと、再びアラートが表示されず、代わりに静かに成功を返します。

誤用を防ぐために、サインインしたiCloudがファミリー共有を使用している子供でない場合、requestAuthorizationは失敗を返します。

アプリがスクリーンタイムAPIを使用する準備をするのはとても簡単です。

ありがとう、ノーラン。

私たちはちょうど私たちのデモアプリ、宿題、ファミリーコントロールで承認するのを見ました。

ファミリーコントロールで承認すると、アプリに他の魔法の力も付与されます。

たとえば、デバイスが認証されると、ユーザーはiCloudからサインアウトできなくなります。

また、ネットワーク拡張フレームワークで構築されたデバイス上のWebコンテンツフィルタは、アプリに含めることができ、自動的にインストールされ、削除することはできません。

これにより、アプリはデバイス上のウェブトラフィックをフィルタリングすることができます。

ペアレンタルコントロールアプリを書く際の課題の1つは、子供がアプリを実行しない可能性が高いときに、子供のデバイスでコードを実行することです。

スクリーンタイムAPIでは、デバイスアクティビティでバックグラウンドコードの実行を実行する新しい方法を作成しました。

デバイスアクティビティ拡張機能は、スクリーンタイムAPIの残りの部分と対話する主な方法です。

ノーランに戻って、宿題が繰り返しスケジュールでコードを実行し、一部のアプリにスクリーンタイムシールドを配置して子供のデバイスを制限する方法を見てみましょう。

ノーラン。

ありがとう、クリス。

次の宿題は、保護者が繰り返しのスケジュールを思いとどまらせるために選択したアプリを保護することです。

アプリの実行が子供のデバイスで実行されているとは期待できないため、保護者が設定してから宿題が実行されていない場合でも、デバイスアクティビティスケジュールを使用して毎日アプリケーションシールドの制限を設定します。

デバイスアクティビティスケジュールが起動すると、デバイスアクティビティが新しい拡張ポイントに呼び込まれます。

宿題には、アプリを保護するための制限を設定するこの拡張ポイントの拡張機能が含まれます。

この拡張ポイントの拡張を実装するには、基本クラスとしてDeviceActivityMonitorをサブクラス化する必要があります。

ここでは、拡張機能の原理クラスの2つのメソッドをオーバーライドしました。intervalDidStartとintervalDidEndです。

これらの機能は、私のスケジュールの開始と終了後にデバイスが初めて使用されるときに呼び出されます。

宿題のメインアプリからデバイスアクティビティのスケジュールを設定するまで、これらの機能の実装を空のままにします。

デバイスアクティビティモニター拡張機能がメインアプリから設定されたので、デバイスアクティビティ名とデバイスアクティビティスケジュールを作成する必要があります。

デバイスアクティビティ名は、拡張機能内からアクティビティを参照する方法です。

そして、デバイスアクティビティスケジュールは、私の拡張機能がアクティビティを監視する時間枠を表します。

ここでは、アクティビティの名前を「毎日」に設定し、スケジュールを真夜中に開始および終了するように設定しました。

また、このスケジュールを繰り返すように設定します。

最後に、デバイスアクティビティセンターを作成し、先ほど定義したアクティビティ名とスケジュールでstartMonitoringを呼び出すことができます。

これらの数行のコードを使用すると、スケジュールが開始および終了するたびに、デバイスアクティビティモニター拡張機能がアクティビティ名で呼び出されます。

アプリを保護するためのもう1つの要素は、保護者が阻止したいものを理解することです。

ファミリーコントロールフレームワークには、ジョブのためだけにSwiftUI要素があります:ファミリーアクティビティピッカー。

メインアプリのUIから、家族のアクティビティピッカーを表示し、保護者が家族が使用するアプリ、ウェブサイト、カテゴリのリストから選択できるようにします。

保護者が選択したら、宿題はピッカーから返された不透明なトークンを使用して、各トークンが表すアプリ、ウェブサイト、およびカテゴリに制限を設定できます。

ここでは、アプリのボタンにfamilyActivityPickerビュー修飾子を追加し、ピッカーの選択パラメータをアプリのモデルのプロパティにバインドしました。

これにより、保護者の選択がUIで更新されるたびに、私のモデルが更新されます。

保護者の落胆したアプリの選択がアプリのモデルに保存されているので、デバイスアクティビティモニター拡張機能に戻ります。

まず、管理設定モジュールのインポートをドロップして、アプリケーションシールド制限にアクセスします。

その後、intervalDidStartで、アプリのモデルから選択範囲を引き出し、それに応じてアプリケーションシールド制限を設定できます。

そして、intervalDidEndでは、nilに設定することで制限を解除できます。

これらの簡単な変更により、宿題は保護者が選択した落胆したアプリを毎日真夜中から真夜中まで保護します。

折り返し連絡してね、クリス。

ありがとう、ノーラン。

シールドは、管理された設定で利用可能な唯一の制限ではありません。

また、デバイスアクティビティスケジュールの開始時または終了時に任意の数の制限を設定することもできます。

たとえば、アプリはアカウントの作成や削除を防ぐか、アプリやウェブサイトを完全にブロックするか、年齢別にメディアコンテンツを拒否するかを選択できます。

メディアの制限といえば、マネージド設定は、任意のアプリが映画やテレビコンテンツの制限を読むことを可能にするAPIも提供します。

ファミリーコントロールの承認は必要ありません。

これらの機能は、デバイスがユーザーに提示されるコンテンツを制限する必要があるかどうかを確認するためのメディアアプリに最適です。

宿題のデモアプリでは、制限は毎日真夜中に設定されていましたが、アプリやウェブの使用状況に基づいて制限を変更したい場合はどうなりますか?

デバイスアクティビティには、アプリがそれを可能にする別の機能があります。デバイスアクティビティイベントです。

これらのイベントは、ファミリーアクティビティピッカーで見たのと同じトークンで設定されており、使用制限に達したときにコードを実行できます。

これらのイベントは、ノーランが最後のセグメントで私たちに見せたスケジュールと一緒に登録されています。

では、ノーランにチェックインして、これらのイベントがどのように機能するかを見てみましょう。

宿題のスケジュールが終了したときだけでなく、子供が保護者が選択した一連の奨励されたアプリに十分な使用量を蓄積したときにも、アプリケーションシールドの制限を削除したい。

これを行うには、使用しきい値が満たされたときにデバイスアクティビティモニター拡張機能をさらに呼び出すようにデバイスアクティビティを設定することで、これらの奨励されたアプリの使用状況を監視する必要があります。

ここでは、デバイスアクティビティのイベント名を「encouraged」と定義します。

この名前は、拡張機能内からイベントを参照する方法です。

そして、保護者が選択した奨励されたアプリのセットと希望する使用のしきい値を含めるように、私の奨励されたイベントを定義します。

最後に、設定したばかりのイベントを含むように、startMonitoringへの呼び出しを更新します。

メインアプリからデバイスアクティビティイベントを監視しているので、これらのイベントのいずれかが使用しきい値を満たすたびに、デバイスアクティビティモニター拡張機能が呼び出されます。

関数eventDidReachThresholdは、デバイスアクティビティイベント名とDeviceActivityNameで呼び出され、どのイベントがどのスケジュールされたアクティビティに対して発生したかを識別します。

宿題では、このイベントの拡張機能が通知されたときに、アプリケーションシールドの制限をnilに設定したいです。

この制限をnilに設定すると、以前にシールドされたアプリのいずれかからシールドが削除されます。

クリスに戻る。

前のセクションでは、落胆したアプリはデフォルトのスクリーンタイムシールドでシールドされていました。

しかし、あなたはおそらくこれらのシールドであなた自身のブランディングとスタイルを手に入れたいと思うでしょう。

また、おそらくシールドのボタンのための独自のアクションハンドラーを持ちたいと思うでしょう。

私たちは両方のためのツールを持っています。

カスタムシールドを使用すると、ユニークなブランド体験を作成できます。

シールドをカスタマイズするには、管理設定で定義された2つの新しい拡張ポイントを実装する必要があります。

1つの拡張ポイントでは、背景素材、タイトル、アイコン、ボタンの外観を変更することで、シールドの外観をカスタマイズできます。

また、別の拡張ポイントでは、カスタムボタンハンドラを作成できます。

ノーランに戻って、シールドをどのようにカスタマイズするか見てみましょう。

宿題用のカスタムシールドのルックアンドフィールを設定するには、拡張機能のメインクラスとしてShieldConfigurationProviderをサブクラス化することから始める必要があります。

設定は、ここでオーバーライドする必要がある唯一の機能です。

この関数は、現在シールドされているアプリケーションへの参照が渡され、ShieldConfiguration構造体を返すことが期待されます。

ShieldConfiguration構造体を使用すると、背景効果、背景色、アイコン、タイトル、サブタイトル、プライマリボタンラベル、プライマリボタンの背景色、およびセカンダリボタンラベルを定義できます。

うわー、それはたくさんのカスタマイズです。

この構造体が設定され、私のシールド構成プロバイダー拡張機能によって返されると、オペレーティングシステムは宿題によってシールドされたすべてのアプリにこれらのカスタマイズを自動的に表示します。

シールドをスタイル設定したので、管理設定の2番目の拡張ポイントを使用して、プライマリボタンとセカンダリボタンのアクションハンドラを設定できます。

この新しい拡張機能では、ShieldActionHandlerをプリンシパルクラスとしてサブクラス化し、関数ハンドルをオーバーライドします。

ハンドル機能は、プライマリボタンアクションまたはセカンダリボタンアクションが押されたかどうか、どのアプリケーションが現在シールドされているかを知らされます。

スシールドアクション応答で関数の完了ハンドラを呼び出す必要があります。

応答は、シールドされたアプリケーションを閉じるか、アクションを延期してシールド構成を再描画するかのどちらかです。

シールドでアクションを延期する機能は、続行方法の信号を待っている間、シールドに外観を更新する機会を与えるため、非常に強力です。

たとえば、子供がここでアクセスを求めるをタップしたときに、シールドが保護者の行動を待っていることを示すために使用できます。

これらのカスタムシールドを追加することで、私のデモアプリ「宿題」が完成しました。

保護者は、ゲームやエンターテイメントなどのシールドするアプリを選択し、子供が読書、学習、創造性など、十分なポジティブなスクリーンタイムを終えたらシールドを取り外すことができます。

この素晴らしい新しいデモアプリの構築に参加してくれてありがとう。

さて、クリスに戻ります。

今日は、制限を提供し、プライバシーを保護し、新しい動的体験を可能にするという3つの目標が、スクリーンタイムAPIを構成する3つのフレームワークでどのように提供されたかを学びました。

管理された設定により、アプリは設定と制限を強制できます。

デバイスアクティビティを使用すると、アプリが使用されていない場合でも、アプリはスケジュールまたは使用イベントでコードを実行できます。

そして最後に、ファミリーコントロールは、管理された設定とデバイスアクティビティへのアクセスを許可し、ユーザーのプライバシーを保護し、保護者だけが子供が何をしているのかを知ることを保証します。

すべてのフレームワークと同様に、スクリーンタイムAPIはあなたからのフィードバックに基づいて進化し続けます。

だから、これらを試してみて、彼らがあなたのユニークなユースケースをどのようにサポートするか、またはサポートしないかを私たちに知らせてください。

今日はご参加いただきありがとうございます。

WWDC 2021をお楽しみください。

[音楽]。