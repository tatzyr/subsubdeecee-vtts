10286

♪ベース音楽の演奏♪

♪

アレハンドロ・セゴビア・アザピアン:WWDCへようこそ!

私の名前はAle Segovia Azapianで、AppleのGPUソフトウェアエンジニアです。

このセッションでは、Metalのバインドレスレンダリングを探ります。

Bindlessは、GPUがリソースのグループを利用できるようにして最新のレンダリング技術を実装できる最新のリソースバインディングモデルです。

まず、バインドレスの背後にあるコンセプトの必要性を見ていきます。

次に、バインドレスモデルを紹介し、従来のバインディングモデルの課題を解決するために必要な柔軟性をどのように提供するかを示します。

エン則バッファを使用してシーンリソースをエンコードしてMetalで利用できるようにするメカニズムと、シェーダーからGPU構造をナビゲートする方法を要約します。

始めましょう！

したがって、バインドレスレンダリングは、すべてのシーンリソースをシェーダーで利用できるようにし、グラフィック技術に信じられないほどの柔軟性をもたらします。

例を見てみましょう。 例を見てみましょう。

加速構造に対する交点を見つけるレイトレーシングカーネルがあると想像してみましょう。

レイトレーシングシャドウなどの一部の光効果では、アルゴリズムは非常に自然です。

交点と光の間の物体を見つけたい。

影の光線をたどるために必要なのは、光に向かう位置と方向だけです。

光線と交差点のパラメータから導き出すことができる交差点の世界空間位置を超えて、オブジェクト属性や金属資源は必要ありません。

しかし、反射などの他の効果については、状況はより複雑になります。

メタルシェーディング言語のレイトレーシング反射シェーダーを見てみましょう。

この新しい例では、交差点を見つけたばかりで、ピクセルを正しい反射色でペイントしようとしています。

交差点を見つけた後に単色を塗るだけで、地面の反射は正確には見えません。

正しい結果を得るには、見つかった各反射点の属性を決定し、そのピクセルの正しい陰影を計算する必要があります。

この問題は、場合によっては、拡散グローバル照明や周囲の閉塞など、他の光線追跡効果にも存在します。

課題は、私たちが光線トレースするとき、私たちの光線が加速構造内の任意の物体に当たる可能性があることです。

これは、レイトレーシングシェーダーから、交差するメッシュに関連する頂点データとその素材を含む、シーン内の金属リソースにアクセスする必要がある可能性があることを意味します。

この量のリソースをパイプラインに直接バインドすることはできません。

ここで、バインドレスバインディングモデルの出番です。

バインドレスの背後にあるアイデアは、リソースを集約し、それらをリンクすることです。

これにより、単一のバッファをパイプラインにバインドし、ナビゲーションを介して参照されたすべてのリソースを利用できるようにすることができます。

メタルでは、これを行うことを可能にする構造は引数バッファです。

特に、バインドレスの場合、引数バッファTier 2が必要です。

これらは、Apple6およびMac2 GPUファミリで利用できます。

引数バッファは、Metalのすべてのシェーダータイプから使用できます。

これは、レイトレーシングとラスタライズの両方に使用できることを意味します。

私たちが見たように、特定のレイトレーシング効果のために、良好な視覚結果を得るためにバインドレスを使用することは必須です。

ラスタライズの場合、使用はオプションですが、直接バインディングモデルよりも利点があります。

特に、特定のドローコールにバインドできるリソース数のスロット制限を事実上削除し、このセッションの後半で検討するいくつかの素晴らしい最適化の機会も提供します。

Metal APIへの1回の呼び出しで、一定のデータとリソースを一度にバインドできるメカニズムとして、Metal 2を使用した引数バッファを導入しました。

引数バッファは非常に柔軟で、他のバッファを参照することもできます。

バインドレスモデルの背後にあるアイデアは、この機能を活用してすべてのシーンリソースをリンクすることです。

これにより、それらをGPUで同時に利用できるようになります。

シーンリソースを引数バッファにリンクする方法の例を見てみましょう。

この消防車のようなモデルをレンダリングしたいとしましょう。

このモデルは、テクスチャ、頂点データ、およびインデックスデータで構成されています。

これらは、従来のバインディングモデルのドローコールごとに1つずつバインドする典型的なリソースです。

しかし、私たちの場合、シーンのすべてのテクスチャ、頂点データ、およびインデックスを一度に利用できるようにしたいので、これらを集約する必要があります。

ここにそうする潜在的な方法があります。

まず、資産の編成方法に応じて、すべてのメッシュまたはサブメッシュを含むメッシュ引数バッファを作成できます。

この引数バッファを使用すると、シーンの頂点配列とインデックス配列を参照できます。

同様に、同じことをして、マテリアルを引数バッファにエンコードすることができます。

各マテリアルは、そのテクスチャを参照するだけでなく、インライン定数データを含めることができます。

わかりましたが、すべてのメッシュと素材がGPUで利用できるようになったので、どうすればそれらをまとめることができますか?

たとえば、インスタンスオブジェクトを作成し、引数バッファに配置することもできます。

インスタンスは、1つのメッシュと関連するマテリアルを参照できます。

これは、モデル変換行列をインライン定数データとして保存するのに最適な場所です。

しかし、私たちはそこで止まる必要はありません。

1つのインスタンスを保存できるようになったので、これをさらに進めて、すべてのインスタンスを配列としてこの引数バッファにエンコードすることができます。

この図を簡素化し、それぞれが独自の材料を持ついくつかのトラックインスタンスを追加しましょう。

ご覧のとおり、これで、フルシーンとそのリソースをエンコードし、引数バッファとリンクできるようになりました。

後で、シェーダーからこれらのリソースのいずれかを参照する場合は、インスタンスバッファへのポインタが必要です。

直接渡して、このバッファを配列として解釈したり、別のシーン引数バッファにポインタを渡したりできます。

さて、間接的にアクセスされたリソースの居住で何が起こるかに注意することが重要です。

シーンへのポインタをパイプラインに渡すだけなので、Metalはこのバッファ参照については知っていますが、間接的にアクセスされるリソースについては知りません。

アプリケーションは、間接的にアクセスされたすべてのリソースの居住を宣言する責任があります。

リソースを常駐させるということは、GPUでメモリを利用できるようにするためにドライバーに信号を送ることを意味します。

これは、シェーダーから参照できるように必要です。

これを行うには、コンピューティングエンコーダ用のuseResource:usage: APIとレンダリングコマンドエンコーダ用のuseResource:usage:stages: APIを呼び出すことができます。

非居住者リソースへのアクセスは、GPUの再起動とコマンドバッファの失敗の一般的な原因です。

これは、このAPIを呼び出すのを忘れた場合、メモリページが存在しない可能性があるためです。

したがって、間接的にアクセスされたすべてのリソースをMetalに宣言することが非常に重要です。

さて、もう1つのオプションは、便宜上、MTLHeapsから割り当てられたリソースを、useHeap APIを使用して1回の呼び出しで常駐させることができるようになったことです。

すでにヒープからリソースをサブ割り当てまたはサブ割り当てすることを計画している場合、これは素晴らしい選択肢です。

現在、ヒープはMetal APIの素晴らしい部分であり、最高のリソース作成パフォーマンスとメモリ節約の機会のためにそれらを使用することをお勧めします。

しかし、それらを効果的に使用するためのいくつかの考慮事項があります。

最初に尋ねるべきことは、私たちのサブ割り当てリソースはすべて読み取られるだけですか?

リソースに書き込む必要がある場所の例には、計算シェーダーからのメッシュスキニングや動的テクスチャなどがあります。

このような場合、GPUがリソースに書き込む必要がある場合は、書き込み使用フラグを使用して個別に居住者を宣言する必要があります。

さらに、変更された可能性のあるリソースは、独自のuseResource呼び出しが必要です。

これは、Metalフレームワークがリソースの移行を処理し、GPUキャッシュをフラッシュし、内部メモリレイアウトを調整できるようにするためのものです。

2番目の考慮事項は、ヒープトラックはリソースの依存関係をサブ割り当てしますか？

繰り返しますが、同じヒープからのリソースを読み書きする場合、これは特に重要です。

Metalは、依存関係追跡を通じて同期の問題を回避するのに最適であり、Metal 2.3以降、ヒープはリソースへのアクセスにおける危険を追跡するように構成できます。

ただし、ヒープはMetalへの単一のリソースであるため、同期はサブ割り当てレベルではなくヒープレベルで処理されます。

これにより、サブ割り当てされたリソースが誤った共有の問題になる可能性があります。

見てみましょう。 

AとBの2つのレンダリングパスが同じヒープからリソースにアクセスするとしましょう。

レンダリングパスAは、追跡されたヒープから割り当てられたレンダリングテクスチャにレンダリングされます。

レンダリングパスBは、同じヒープからサブ割り当てされる無関係なバッファから読み取っています。

異なる条件に応じて、レンダリングパスAとBはGPUによって並行して実行される資格があります。ただし、同じリソース（ヒープ）からの書き込みと読み取りの潜在的な危険性があるため、Metalは競合条件がないことを確認するためにアクセスをシリアル化する必要があります。

これにより、GPUによるワークロードの実行ウォールクロック時間が増加する可能性があります。

しかし、私たちの場合、個々のリソースが独立していることがわかっていれば、このフェンスは回避できます。

これを行うには2つの方法があります。

1つのオプションは、静的リソースに使用されるものと別のヒープから更新可能なリソースをサブ割り当てすることです。

もう1つのオプションは、すべてをバンドルしたい場合は、ヒープがサブ割り当てされたリソースを追跡しないように設定されていることを確認することです。

これはMetalのデフォルトの動作であり、プログラマーとして私たち自身が危険を同期させる責任を負うことを意味します。

さて、この図では、誤った共有の問題を説明するために物事を少し簡略化しました。

実際には、重複はレンダリングパスレベルではなく、シェーディングステージレベルで発生します。

その結果、金属はステージの粒度でフェンスを指定することができます。

これは、頂点ステージやラスタライザなどのパイプラインの一部を同時に実行でき、以前のパスのフラグメントステージ出力に依存した場合は、フラグメントステージの後半でのみブロックできるため、これは素晴らしいことです。

可能であれば、最大限のパフォーマンスを得るために、常にこれを行うことをお勧めします。

さて、これは覚えておくべきことがたくさんあるので、このリストから1つだけ取得した場合は、これを覚えておいてください。静的テクスチャやメッシュなどの読み取り専用データは、処理するのが最も簡単です。

総割り当てサイズとアライメント要件を事前に決定し、アプリの起動時またはゲームのロードセクション中にこれらのリソースをヒープに配置します。

このようにして、クリティカルパスのオーバーヘッドを最小限に抑えながら、後で1回の通話に常駐させることができます。

バインドレスバインディングモデルについてわかったので、リソースをエンコードして実践し、引数バッファを使用してGPUで完全なシーンを利用できるようにする方法を見てみましょう。

インスタンスバッファをエンコードしたいとしましょう。

このバッファはインスタンスの配列で構成されていることを覚えておいてください。

見たように、インスタンスはメッシュ、マテリアルを参照し、ローカル空間から世界空間への変換を記述するインライン定数4x4行列が含まれています。

エンコーディングは引数バッファエンコーダを介して実行され、Metalで1つを作成するには2つの異なる方法があります。

リフレクションによるエンコーディングに精通しているかもしれません。

引数バッファがシェーダー関数への直接パラメータとして渡された場合、MTLFunctionオブジェクトにエンコーダの作成を依頼できます。

このメカニズムはうまく機能しますが、シーン全体を引数バッファにエンコードしているとき、すべてのエンコーダが反映されるわけではありません。

特に、MTLFunctionシグネチャは、間接的に参照されるバッファについて知りません。

MTLFunctionからエンコーダを作成するのが便利ではない他の状況もあります。たとえば、エンジンアーキテクチャがパイプライン状態の作成とは別に引数バッファの作成とリソースロードを処理する場合などです。

さらに、関数が配列を渡されることを期待している場合、エンコーダを反映することはできません。

では、このような場合、私たちは何ができますか?

このような場合、MetalはMTLArgumentDescriptorを介してエンコーダを作成するための便利な2番目のメカニズムを提供します。

MTLArgumentDescriptorsを使用すると、構造体メンバーをMetalに記述し、その後MTLFunctionなしでエンコーダを作成できます。

まず、データ型とバインディングインデックスを指定して、各メンバーの記述子を作成する必要があります。

次に、記述子を取り、それらをMTLDeviceに直接渡してエンコーダを作成します。

その結果、エンコーダオブジェクトを取り戻します。

それでは、これがコードでどのように見えるかを探ってみましょう。

各メンバーについて、MTLArgumentDescriptorを作成する必要がありました。構造体内のメンバーのID属性に対応するバインディングインデックスを指定します。MTLDataTypeと潜在的なアクセスを指定します。最後に、すべてのメンバーを宣言した後、デバイスから直接エンコーダを作成し、すべての記述子を含む配列を渡すことができます。

エンコーダができたら、データをバッファに記録するのは簡単です。

エンコーダに引数バッファを設定し、バッファの先頭を指します。

次に、保存するデータを設定するだけです。

配列のエンコードも簡単です。

私たちがしなければならないのは、エンコーダから便利に取得できるencodedLengthによってエンコーダの引数バッファ記録ポイントをオフセットすることだけです。

次の例では、encodedLengthをオフセットに2回目に追加します。

実際、記録する必要がある各位置のオフセットは、index×encodedLengthになります。

このメカニズムにより、構造体の配列を非常に簡単にエンコードできます。

さて、言及する価値のある重要な点の1つは、シェーダー側からこれらの配列へのインデックスに特別な処理は必要ないということです。

シェーダーはバッファの長さを知る必要がなく、配列内の任意の場所に自由にインデックスできます。

それはちょうど動作します!

さて、バインドレスシーンをエンコードしたので、ナビゲーションを見てみましょう。

レイトレーシングの場合、ナビゲーションは非常に自然です。

まず、バインドレスシーンのルートを含むバッファをレイトレーシングパイプラインにバインドします。

これは、他のすべてにアクセスできる引数バッファです。

次に、カーネルから、いつものようにレイトレースされた交差点に進みます。

交差点を発見した後、交差点の結果オブジェクトはナビゲーションを記述します。

このオブジェクトは、instance_id、geometry_id、およびprimitive_idを照会できます。

これらのメンバーは、加速構造をナビゲートするために特別に設計されています。

したがって、先に示したように、加速構造を反映した構造でバインドレスシーンを構築することが重要です。

もう一度見てみましょう。 もう一度見てみましょう。

覚えておいてください、これはシーンを整理する方法のほんの一例なので、私はそれをどのように整理したかに応じてそれをナビゲートするつもりです。

シーンの特定の詳細は、独自の引数バッファを整理する方法によって異なる場合があります。

まず、交差点を見つける必要があります。

それを手に入れたら、バインドレスシーンを戦略的に整理したため、instance_idが与えられた場合、インスタンスバッファへのポインタをたどり、どちらにヒットしたかを決定できます。

次に、私たちが見たように、インスタンスはそのメッシュと素材を知っています。

そのため、geometry_idを使用して、参照バッファ内でヒットしたジオメトリを決定できます。

最後に、各メッシュがインデックスバッファを知るように準備した場合、primitive_idを使用して、ヒットした正確なプリミティブを決定できます。

たとえば、三角形の場合、この配列から3つのインデックスを引き出し、それらを使用して頂点データを取得できます。

このナビゲーションは、Metal Shading Languageでどのように見えるかです。

交差オブジェクトから、instance_idを取得し、それを使用してインスタンス配列に動的にインデックスを作成し、ヒットしたインスタンスを取得します。

次に、インスタンスを使用して、geometry_idを使用して、どのジオメトリまたはサブメッシュがヒットしたかを判断します。

ジオメトリを決定したら、インデックスバッファから直接インデックスを引き出すことができます。

三角形の場合、次々に3つのインデックスを引きます。

これらのインデックスを使用して、頂点データ配列にアクセスし、テクニックに必要な属性を取得します。

たとえば、各頂点に対応する法線を取得できます。

そして最後に、点の重心座標を使用して、頂点法線を手動で補間して、交点の正しい法線に到達します。

これらの変更により、ティーポットの例に戻すと、交差点で法線を計算する方法が整ったので、反射を正しくシェーディングすることができます。

交差点で正しい属性を見つけるためにコードを更新しましたが、結果が視覚的に正しいようになりました。

これで、このフレームワークに基づいて構築し、テクスチャ座標や接線ベクトルを適用して通常のマッピングを実装するなど、必要な他の属性を計算することができます。

そこで、ここでは、バインドレスシーンをナビゲートして頂点データを取得し、手動で補間し、最後に、発見されたすべての交点を正しくシェーディングするために適用する方法を見ました。

これらの概念を独自のエンジンに持ち込むために、これらすべての具体的な実装を示すコンパニオンコードサンプルをリリースします。

これは、モデルI/Oフレームワークを使用してロードされたシーンのレイトレース反射を計算するハイブリッドレンダリングサンプルです。

このサンプルは、レイトレーシング加速構造に一致するバインドレスシーンをエンコードする方法を示し、交差を見つけて、レイトレーシングシェーダーから直接関連するピクセルを正しくシェーディングする方法も示しています。

ここで見ることができるように、サンプルはまた、光線がトラックと交差するポイントで反射レイトレーシングシェーダーの出力を直接視覚化することができます。

これは、反射アルゴリズムを反復的に実験するのに最適です。

さて、私たちはここで多くの分野をカバーし、これまでのところ、レイトレーシングの文脈で議論のほとんどを集中させてきました。

しかし、先に述べたように、ラスタライズの文脈でピクセルを適切にシェーディングするために同じ原則を適用することができます。

物理ベースのレンダリングは、これのための素晴らしい候補です。

PBRでは、フラグメントシェーダーには、アルベド、粗さ、メタリック、アンビエントオクルージョンなど、いくつかのテクスチャからの情報が必要です。

ダイレクトバインディングモデルでは、各ドローコールを発行する前に、各スロットを個別にバインドする必要があります。

バインドレスモデルは、これを大幅に簡素化します。

引数バッファをエンコードしたら、シーンを直接バインドし、ドローコールに対応するマテリアルに移動し、すべてのテクスチャに間接的にアクセスできます。

実際、単一のバッファを一度バインドする必要があるため、このアーキテクチャは、ドロー呼び出しの数を減らし、代わりにインスタンスレンダリングを使用することで、エンジンをさらに最適化する絶好の機会を提供します。

私たちがアクセスする予定のすべてのテクスチャを居住者にすることを忘れないでください。

典型的なPBRシェーダーの例を次に示します。

従来のモデルでは、参照される各テクスチャは、この描画呼び出しの前に個別にバインドする必要があります。

次のドロー呼び出しで異なるテクスチャセットが必要な場合は、これらのリソースもすべて1つずつバインドする必要があります。

バインドレスモデルを使用する場合、ルート引数バッファを渡して、以前と同じように参照構造から直接マテリアルを取得できるようになりました。

まず、インスタンスを取得します。これは頂点シェーディング段階で決定される場合があります。次に、そのマテリアルを取得し、参照されたテクスチャと一定データを使用して適切なシェーディングを計算します。

最後に、色を返すだけです。

わかった！

そして、それはメタルでバインドレスレンダリングを効果的に実装する方法についてのツアーでした!

要約すると、私たちはメタルバインドレスモデルを調査し、それがどれほど非常に柔軟であるかを見て、あなたが望むようにあなたのシーンを表現することができます。

私のお勧めは、与えられたレンダラーのナビゲーションを容易にする構造を設計し、構築することです。

このようにして、ナビゲーションは非常に自然になり、レイトレーシングとラスタライズの両方に同じバッファーを使用することもできます。

Bindlessはゲームを完全に変え、最新のレンダリング技術を実装するために必要なすべてのデータをGPUに与えます。

さらに進んで、このアーキテクチャを使用してGPUを運転席に置き、間接的なコマンドバッファとGPUカリングを通じて間接的なパイプラインを採用することもできます。

次世代のグラフィカルアプリケーションやゲームを提供するために、これをどのように実践するかを見るのが待ちきれません。

ありがとう、WWDC 2021の残りを楽しんでください!

♪