10233

♪ベース音楽の演奏♪

♪

ジョナサン・ホッグ：こんにちは、加速と関連するフレームワークに関するこのセッションへようこそ。

私はAppleのVector&NumericsチームのJonathanです。今日は、機械学習ライブラリであるBNNSの新機能を伝える前に、Accelerateフレームワークについて簡単にお話しします。

次に、simd.hの改善点を取り上げ、Apple Archiveと新しいApple Encrypted Archiveコンテナを紹介します。

それでは、Accelerateフレームワークの簡単な概要から始めましょう。

Accelerateは、MacOS、iOS、iPadOS、watchOS、tvOSなど、すべてのAppleプラットフォームで高性能な数値計算を提供します。

Accelerateは、Apple Silicon Macや最近のiPhoneやiPadデバイスの機械学習アクセラレータへのアクセスも提供します。

このハードウェアを活用する唯一の方法は、直接、またはCore MLなどの高レベルのフレームワークを介してAccelerateを呼び出すことです。

Accelerateはいくつかの部分で構成されています。

vDSPは、DFTやFFTルーチンなどの信号処理のためのプリミティブを提供します。

vImageは、フォーマット変換や畳み込みなどの画像処理のルーチンを提供します。

vForceは、正弦やコサインなどの超越関数のベクトル化されたバージョンを提供します。

BLASとLAPACKは、標準の高密度行列代数ルーチンの高性能移植を提供し、スパースBLASとスパースソルバーはスパース行列に同様の機能を提供します。

最後に、BNNSは機械学習のサポートを提供します。

今日は、関連するフレームワークについてもお話しします。また、関連するフレームワークについてお話しします。

simd.hは、グラフィックスプログラミングでカバーされているような計算された小さなベクトルと行列を提供し、圧縮とApple Archiveはロスレスデータ圧縮をサポートします。

これらのフレームワークを使用するには、関連するインクルードまたはインポートステートメントをコードに追加し、フレームワークをXcodeプロジェクトに追加するだけです。

さて、BNNSについてもっと詳しくお話ししましょう。

BNNSはBasic Neural Network Subroutinesの略で、CPUでの機械学習のパフォーマンスプリミティブを提供します。

Appleの機械学習エコシステムに不慣れな方のために、この図は土地のレイアウトを示しています。

3つの主要なハードウェアブロックがあります。前に述べた機械学習アクセラレータを含むCPU、GPU、そして別のニューラルエンジンです。

BNNSは、MPSがGPUでパフォーマンスプリミティブを提供するのと同じように、CPUでパフォーマンスプリミティブを提供します。

このレイヤーの上には、これらのバックエンドの1つ以上で実行される多くのフレームワークがあります。

これらには、Appleの高レベルの機械学習フレームワークであるCore MLとCreate ML、およびVisionやNatural Languageなどの専門的なフレームワークが含まれます。

BNNSは、幅広いレイヤータイプにわたるトレーニングと推論の両方のサポートと、下部に示されているオプティマイザのサポートを提供します。

このリリースでは、埋め込み、ランダムフィル、クオンタイズ化、AdamWオプティマイザのサポートなど、いくつかの新しいレイヤータイプのサポートを追加しました。

また、既存のレイヤーを改善し、SiLUとHardSwishの2つの新しいアクティベーション機能を追加し、三項選択、乗算加算、要素ごとの最小値と最大値の新しい算関数のサポートを追加しました。

レイヤーフュージョンは、後続のレイヤーへの入力として1つのレイヤーの出力をすぐに消費する機能を提供し、メモリに書き出して再度読み込む必要がなくなります。

畳み込みのレイヤー融合と、新しい量子化レイヤーと完全に接続されたレイヤー、および算術レイヤーと正規化レイヤーの融合を追加しました。

その他の改善には、スタンドアロン機能としても使用できるオプティマイザのグラデーションクリッピングのサポートの改善や、AdamベースのオプティマイザのAMSGradサポートが含まれます。

一緒に、これらの改善は、私たちがさらに加速できる範囲とネットワークアーキテクチャを拡大しました。

さて、simd.hの改善点についてお話ししましょう。

simd.hは、正弦や余弦などの関数のサポートや、四元数のサポートを含む有用な幾何学的演算など、CPUのレジスタに収まる小さなベクトルと行列の計算プリミティブを提供します。

私がsimd.hについて本当に好きなのは、私たちが飛び込んで、10%の努力でベクトル化の利点の90%を得ることができるということです。

ほら、お見せしましょう。

これは私が発明したばかりのニューラルネットワーク活性化機能です。

ご覧のとおり、それは3つの異なる枝を持っています。

入力がマイナス円周率より小さい場合は、ゼロを返すだけです。

マイナスπとπの間にある場合、xの指数の2倍にx+πを2倍に掛けて返します。

そうでなければ、円周率より大きい場合は、指数の2倍を返します。

それは素晴らしいことですが、大量のデータがある場合は、スカラーループが許すよりも速く実行したいと思うかもしれません。

それでは、それをsimdで実装する方法をお見せしましょう。

私はすでにいくつかのボイラープレート、バッファにベクトルを簡単に書き込むことができる拡張機能、および一度に1つの長さ8ベクトルの増分で出力配列を反復する単純なループを持っています。

興味深い部分は、スカラー関数を同等のsimdに変換する方法です。

スカラーコードをもう一度見ることから始めましょう。

枝がいくつかあるのがわかります。

これらはベクトル化にはうまく機能しません。

代わりに、マスクに基づいてマージできる部分からこれを構成しましょう。

もっとよく見ると、xがマイナスπより小さい場合、私はゼロを返すだけです。

大きい場合は、xの2倍の指数を含む式を返します。

それを引き抜きましょう。

さて、そのyからベクトルを構築し、xが要素的にマイナスpiよりも小さいすべての場所でゼロに置き換えます。

次に、より大きなケースを見ることができます。

ここでは、高い領域で1を掛けるか、中央の領域でxとπを2で乗算します。

だから、同じように書きましょう。

2つの式にx+piを取り、今回はxが要素的にpi以上であるすべての場所で1つに置き換えます。

今残っているのは、これら2つの量を一緒に乗算することだけです。

明らかに、ゼロ要素の場合、bのいずれかの値を掛けると、依然としてゼロが返されます。

だから、それを実行して、それがどのように見えるか見てみましょう。

今、コンソールを見下ろすと、私の新しいsimdバージョンは以前のスカラーコードのほぼ3倍高速であることがわかります。

では、このリリースでsimdはどのように改善されますか?

テンプレートを使用してC++プログラマーの使いやすさを向上させました。

複雑なコード構造や同様の型を自分で実装することなく、基礎となるスカラー型とベクトル長と具体的なsimd型の間を移動できるように、型と特性構造を追加しました。

使用を簡素化するために、C++ボイラープレートの必要性を減らすために便利なエイリアスも追加しました。

これは、それらが使用中どのように見えるかの例です。

ベクトル型と行列型は、floatやintなどの基礎となる型とベクトル長から具体的な型に移動し、非整列バージョンや比較結果のマスク型などの関連型へのアクセスを提供するメンバーも許可します。

Vector_tとMatrix_tエイリアスは、以前と同じ定義にアクセスするための簡略化された構文を提供します。

Get_traits構造体を使用すると、具体的なsimdタイプから一般的なタイプに移動して、他の方向に進むことができます。

繰り返しになりますが、一般的なユースケースの構文を簡素化するためのエイリアスがあります。

また、テンプレート化されたコードでの使用を可能にするために、makeおよびconvert関数のテンプレートバージョンを追加しました。

これらは既存の関数と同じように機能しますが、その宛先タイプは関数名の一部ではなくテンプレートパラメータになりました。

C++の改善に加えて、すべての言語でサポートされているいくつかの新しい機能を追加しました。

これらは、libmのスカラー関数のベクトルバージョンを提供するisfiniteやisinfなどの分類関数であり、ガンマ関数を計算するための新しい関数、およびsimd行列のトレースを提供します。

さて、Apple Archiveと新しいApple Encrypted Archiveフォーマットを紹介します。

アップルアーカイブは、10年の大部分の間、システムのアップデートに電力を供給してきました。

macOS 11のリリースでは、圧縮されたコンテナとアーカイブ形式へのアクセスを許可しました。

macOS 12の新機能では、このサポートに暗号化のためのAPIを追加しました。

アーカイブ形式自体は、最新のモジュラーアプローチを提供し、保存するファイル属性とメタデータを正確に選択できます。

ストリーミング可能なので、データ全体を一度にメモリに収めることを心配する必要はありません。

また、ファイルシステムイメージなどの大規模なアーカイブにインデックスを作成するための個別のマニフェストファイルもサポートしています。

新しいApple Encrypted Archiveは、圧縮、認証された暗号化、デジタル署名を1つの安全なパッケージに組み合わせ、これに基づいて構築されています。

これは、当社のセキュリティチームと外部の専門家によって設計および監査された最先端の暗号化を提供します。

データの機密性とは、データが秘密のままであることを意味します。

データの信頼性とは、転送中に破損していないことを確認できることを意味します。

送信者認証とは、誰が送信したかを確認できることを意味します。

署名プライバシーとは、公開鍵のコンテキストでは、あなたと送信者だけが誰が署名したかを知っていることを意味します。

また、ファイルの長さなどのメタデータを難読化し、辞任攻撃保護を含めます。

これは、データがプライベートで安全であることを確信できることを意味します。

正しい展開を容易にするために、さまざまなユースケース向けにさまざまなプロファイルを提供しています。

基本的なプロファイルは、暗号化なしでデジタル署名を持つことです。

これは、コンテンツが秘密ではないソフトウェアアップデートなどにも使用できますが、データが改ざんされていないことを確認する必要があります。

次に、署名の有無にかかわらず、安全に共有されたバイナリキーを使用して、対称暗号化を使用します。

これは、バイナリキーではなくパスワードを使用する次のオプションに似ています。

最後に、署名の有無にかかわらず、本格的な公開鍵暗号化が完成しました。

すべてのプロファイルでは、圧縮はオプションであり、データは常に認証されます。

これらのフォーマットを操作するために、いくつかのコマンドラインツールを提供しています。

フォーマットの圧縮アーカイブ部分を操作するには、compression_toolがあり、暗号化されたアーカイブにはaeaがあります。

Aaツールは容器全体を処理します。

もちろん、SwiftとCの両方でApple Archiveフレームワークが提供するAPIもあります。

ストリームベースで、シーケンシャルアクセスとランダムアクセスの両方を可能にします。

その実装は、非常に高速なパフォーマンスのためにマルチスレッド化されています。

では、このAPIの動作を見てみましょう。

ここには、私たちがまとめたシンプルなデモアプリがあります。

ウィンドウの上部は、暗号化したいもののドラッグアンドドロップターゲットとして機能し、下部は単純なステータスペインです。

このTopSecretディレクトリを暗号化したいとしましょう。

これをアプリにドラッグアンドドロップするだけです。

そして、ああ、いや!エラーが発生しました。

私たちはまだこの機能を実装していません!

今それをやりましょう。

では、これをApple Archiveで暗号化するにはどうすればよいですか?

まず、暗号化の秘密とともに、使用するアルゴリズムとプロファイルを記述する暗号化コンテキストが必要です。

また、アーカイブを書き込むファイルストリームも必要です。

これらを組み合わせて暗号化ストリームを作成します。

暗号化ストリームはバイトのストリームを暗号化するので、暗号化したいディレクトリをそのようなディレクトリに変換するアダプターが必要です。

これはエンコーダストリームです。

もちろん、データはオブジェクトの作成とは反対方向に流れます。

アーカイブエントリをエンコーダストリームにフィードし、暗号化ストリームのバイトに変換し、暗号化されたデータをファイルストリームに出力します。

それがコードでどのように見えるか見てみましょう。

ここでは、対称プロファイルを使用することを指定します。 対称プロファイルを使用します。

そして、「なし」は、デジタル署名を使用しないことを教えてくれます。

列挙型の最初の部分は、使用する特定のアルゴリズムを指定するだけです。

ここでは、「lzfse」を使用してデータを圧縮します。

コンテキストが作成されると、対称暗号化キーを指定するだけです。

次に、これらの3つのストリームを作成します。

まず、ファイルストリームを作成し、それをコンテキストと組み合わせて暗号化ストリームを作成します。

最後に、エンコーダストリームを導き出します。

さて、これらのストリームを正しい順序で閉じることを覚えておくことが重要です。

特に、cryptionStreamを閉じることは、アーカイブに署名して封印するため、舞台裏で多くの作業を行います。

最後に、残っているのは、ファイルをエンコーダストリームにフィードすることだけです。

エンコードするファイル属性を指定し、writeDirectoryContentsメソッドを呼び出します。

残っているのは、暗号化キーを使用してコンソールにステータスメッセージを印刷することだけです。

それがうまくいったかどうか見てみましょう。

TopSecretディレクトリをアプリにドロップすると、成功し、暗号化され、暗号化キーが出力されます。

今、暗号化されたアーカイブをアプリにドラッグアンドドロップすると、それを復号化しようとし、暗号化キーを要求します。

では、その暗号化キーをコピーして貼り付けて、中身を見てみましょう。

うーん、おいしい！

それは私がApple Encrypted Archiveであなたのために持っているすべてなので、締めくくりましょう。

今日は、BNNSの新しいレイヤータイプのサポートや、simd.hの拡張されたC++サポートやその他の機能など、Accelerateフレームワークの改善について話しました。

次に、Apple Archiveと新しいApple Encrypted Archiveフォーマットとフレームワークでのサポートを紹介しました。

ありがとう、WWDCの残りの部分を楽しんでください。

♪