10058

♪ベース音楽の演奏♪

♪

フィリップ・ハウスラー:こんにちは、私の名前はフィリップです。Swiftのクールな新機能、AsyncSequenceをご紹介できることを本当に楽しみにしています。

今日は、非同期シーケンスとは何か、その背後にある基礎について説明します。

次に、コードでそれらを使用する方法について話し、新しいAsyncSequence APIのいくつかについて説明します。

そして最後に、独自の非同期シーケンスを構築する方法を探ります。

だから、すぐに飛び込みましょう。

これは、AsyncSequenceでできるクールな新しいもののいくつかを説明するために私が書いた本当にシンプルなツールです。

このツールでは、エンドポイントへのURLから始めます。

最近の地震をリストアップしています。

さて、通常、ダウンロードは実際には非同期タスクであり、時間がかかることがあります。

しかし、この場合、すべてのものがダウンロードされるのを待ちたくありません。代わりに、受け取ったものを表示したいと考えています。

だから私は物事を少し揺るがし、新しい非同期/待機機能を使用して、このエンドポイントから応答する行を取得することにしました。

取得しているデータはカンマで区切られたテキストとしてフォーマットされているため、各行はデータの完全な行です。

非同期の行シーケンスは、受信されたときに各行を放出しているので、それは潜在的に私たちの前に本当に大きなダウンロードを持つことができることを意味します。

しかし、私たちがそれらを得るにつれてそれらを放出することによって、スニペットは本当に応答性を感じ、それについての最も素晴らしい部分は、この新しい非同期コンテキストで通常のシーケンスから使用することに慣れているのと同じものを使用できるということです。

つまり、新しいfor-await-in構文を使用して反復し、map、filter、reduceなどの関数、またはこのサンプルのようにdropFirst関数を使用してそれらの値を操作できることを意味します。

では、これはどのように機能しますか?

さて、私が今日話す多くのことは、非同期/待機トークに基づいた基礎を持っています。

しかし、いくつかの重要なポイントを要約しましょう。

非同期関数を使用すると、awaitキーワードを使用して、コールバックを必要とせずに並行コードを書くことができます。

非同期関数を呼び出すと、値やエラーが発生するたびに一時停止され、再開されます。

一方、AsyncSequenceは各要素で一時停止し、基礎となるイテレータが値を生成するか、スローしたときに再開します。

基本的に、名前が示すように、それらは通常のシーケンスに似ていますが、いくつかの重要な違いがあります。

つまり、各要素は非同期に配信されます。

しかし、それらは非同期配信であるため、それは失敗が間違いなく可能性があることを意味します。

一部の非同期シーケンスはスローされますが、失敗がオプションでない場合、そうでないものもあります。

スローする関数と同様に、コンパイラは反復または作成時にエラーが処理されることを確認するのに役立ちます。

一般的に言えば、非同期シーケンスは、時間の経過とともに値を生成する方法の説明です。

したがって、非同期シーケンスは0以上の値であり、シーケンスと同様に、イテレータからnilを返すことで完了を意味します。

エラーが発生した場合、それはまた、非同期シーケンスが端末状態にあるポイントであり、エラーが発生した後、イテレータの次への後続の呼び出しに対してnilを返します。

それでは、まず定期的な反復から始めて、その定義がどのように機能するかを掘り下げてみましょう。

ここには、かなり馴染みのあるパターンがあります。

これはフォーインループです。

この場合、シーケンスから地震を反復し、マグニチュードが特定の値を超えるときに関数を呼び出します。

コンパイラは、この反復がどのように機能するかについての知識を持っていますが、それが行うことは魔法ではありません。

コンパイルステップは、実際にはいくつかの簡単な変換を行うだけです。

この非同期形式が何であるかを理解できるように、これらの変換を調べてみましょう。

これは、以前のコードを構築するときにコンパイラが行うことです。

最初にイテレータ変数を作成することから開始し、次に呼び出されたときにイテレータによって生成されるすべての地震を取得するためにwhileループを使用します。

新しい非同期/待機機能を使用するには、わずかな変更が1つあります。

次の関数を非同期に変更するのと同じくらい簡単です。

次の地震を待つことで、反復をSwiftの並行性に参加させることができます。

ループが非同期シーケンスにあった場合、これがどのようなものであったかを明らかにするために巻き戻しましょう。

前述のように、非同期シーケンスから各アイテムを待つ必要があります。

これは、新しいfor-await-in構文に反映されています。

これはすべて、Sequenceの使い方を知っていれば、AsyncSequenceの使い方についてすでに良いアイデアを持っていることを意味します。

非同期シーケンスを利用する方法はいくつかあります。

先ほど説明したように、新しいfor-await-in構文を使用できます。または、非同期シーケンスがスローされた場合は、新しいfor-try-await-in構文を使用できます。

これにより、クロージャでつぶすことなく、非同期に生成された値を簡単に反復し、すでに慣れ親しんだ構文を使用して反復することができます。

休憩や継続のようなものでさえ、ただ働くだけです。

これで、非同期シーケンスの理論をよく紹介しました。

その反復をもう少し詳しく見てみましょう。

非同期シーケンスであるソースが与えられた場合、for-await-in構文を使用して各値を待つことができます。

これは、イテレータによって生成された各アイテムを待ち、端末にヒットするとループを完了することを意味します。

非同期シーケンスを反復する場合、ブレークは明らかにループ内から早期に反復を終了する良い方法です。

これは通常のシーケンスと同じように機能します。

ここでは、地震の位置データが存在しない場合に壊れています。

または、スキップしたい値がある場合は、continueを使用できます。

この場合、深さが何らかの値よりも大きい場合は、それらをスキップして次の地震を待ち続けます。

ダウンロードからのこの次の反復は以前と同じように機能しますが、この場合、私たちが持っているソースはエラーをスローする可能性があります。

関数をスローするのと同じように、反復されるAsyncSequenceがスローできるときに、各要素を処理するためにtryが必要です。

また、関数を投げるのと同じように、コンパイラはトライを逃したときに検出し、間違いを修正するためのFix-itを提供します。

これは、非同期シーケンスがエラーを生成する可能性がある場合、言語がそのエラーをスローするかキャッチすることを強制するため、常に安全であることを意味します。

この2番目の反復は、最初のループの反復の後に順番に実行されます。

コードを順番に実行することは、必ずしも望ましいとは限りません。

起こっている他のことと同時に反復を実行すると便利な場合は、反復をカプセル化する新しい非同期タスクを作成できます。

これは、使用している非同期シーケンスが無期限に実行される可能性があることがわかっている場合に便利です。

さて、そのシーケンスは潜在的に無期限である可能性がありますが、発生することはかなり一般的ではありません。

しかし、非同期行動の世界では、それははるかに一般的なものであり、それらを使用する際に考慮する必要があるものです。

ありがたいことに、Swiftの並行性のための施設は、これを本当に簡単で安全にします。

これは、外部で反復をキャンセルしたい場合にも本当に役立ちます。

ここでは、2つの反復を同時に実行し、後で反復を終了することができます。

コンテナの寿命に無期限である可能性のある反復の作業にスコープするタスクではかなり簡単です。

次に、macOS Monterey、iOS 15、tvOS 15、およびwatchOS 8で入手可能なAsyncSequence APIのいくつかを見てみましょう。

たくさんありますが、ハイライトをいくつかお見せします。

ファイルからの読み取りは、多くの場合、非同期動作の主なユースケースです。

FileHandleには、そのFileHandleから非同期のバイトシーケンスにアクセスできる新しいバイトプロパティが追加されました。

これは、バイトの非同期シーケンスを行に変換するAsyncSequenceの新しい拡張機能と組み合わせて使用できます。

しかし、ファイルを扱うことは非常に一般的であるため、URLはバイトと行の両方のアクセサを持つべきだと判断しました。

これは私が最初の例で使用したのと同じAPIです。

これは、ファイルまたはネットワークから、コンテンツから行のAsyncSequenceを返すためのURLの便利なプロパティです。

これにより、これまで多くの本当に複雑なタスクが簡単かつ安全になると確信しています。

ネットワークから物事を取得するには、応答と認証をもう少し制御する必要がある場合があります。

したがって、URLSessionには、URLまたはURLRequestが与えられたバイトの非同期シーケンスを取得するバイト関数を持つようになりました。

もっと知りたい場合は、この詳細とURLSessionを使用したさらに多くの新しい非同期機能については、セッション「URLSessionで非同期/待機」をチェックしてください。

しかし、AsyncSequenceにとって理にかなっているのはファイルやネットワークだけではありません。

通知は、新しい通知APIで待つことができます。

そして、反復はAsyncSequenceと対話する唯一の方法ではありません。

この例では、一致するストアUUIDを持つリモート変更の最初の通知を待っています。

firstWhereのようなメソッドを使用すると、通知非同期シーケンスとともに、以前は複雑なロジックを表現していたコードをコンパクトで読みやすくする、本当にきちんとした新しいデザインパターンが可能になります。

そして、それらすべてが十分にクールでなかった場合、非同期シーケンスから値を非同期に操作するための新しいAPIがたくさんあります。

これらは、Sequenceで利用可能なのと同じ機能のいくつかであるため、かなり馴染みがあるはずです。

これまでに、dropFirstやfirstWhereなど、いくつかを取り上げましたが、それ以上のものがあります。

シーケンスで使用するために考えられるほとんどすべてのものには、AsyncSequenceで作業するための非同期の対応物があります。

今、それは取り込むべきことがたくさんあり、あなたは「ねえ、それらの新しいAPIは本当にクールで、その構文は超きちんとしていますが、どうすれば自分の非同期シーケンスを作ることができますか?」と思うかもしれません。

さて、まさにそれをやりましょう!

非同期シーケンスを実装する方法はいくつかありますが、既存のコードを適応させる方法に焦点を当てます。

特に、AsyncSequenceで本当にうまく機能するいくつかのデザインパターンがあり、あなたがすでに持っているものをこの新しいコンセプトと相互作用させるためのいくつかの素晴らしい機能があります。

これらのデザインパターンのいくつかは、複数回呼び出されるクロージャのようなものですが、一部のデリゲートもうまく機能します。

応答を必要とせず、発生する新しい値を通知するだけで、非同期シーケンスを作成するための主要な候補になる可能性があります。

これらのデザインパターンは本当に一般的であり、あなたはおそらく今日すでにあなたのアプリにいくつか持っているでしょう。

これは一般的なハンドラパターンの例です。

ハンドラープロパティと開始および停止メソッドを持つクラスです。

AsyncSequenceの完璧な候補のようです。

既存の使用法は、モニターが作成され、値を取得するハンドラーが割り当てられ、その後、地震がハンドラーに送信されるようにモニターが開始される、このようなものになる可能性があります。

後で、生成されるイベントをキャンセルするためにモニターが停止される可能性があります。

同じインターフェイスを使用して、新しいAsyncStreamタイプに使用を適応させることができます。

それを使用するにはほんの少しのコードが必要で、非同期シーケンスを構築できます。

非同期ストリームを構築するときは、要素タイプと構築クロージャが指定されます。

クロージャには、値を複数回、終了、または処理できる継続があります。

つまり、この場合、モニターは建設閉鎖内に作成できます。

そして、ハンドラーを割り当てて、継続に地震をもたらすことができます。

そして、onTerminationはキャンセルとクリーンアップを処理できます。

そして、私たちは監視を始めることができます。

以前と同じモニターコードは、非同期ストリームの構築に簡単にカプセル化できます。

これにより、すべての使用サイトで同じロジックを複製する必要がなくなります。

そして、これがこの非同期ストリームの使用方法です。

フィルターなどの強力な変換関数と、新しいfor-await-in構文を使用できます。

これにより、すべてが1か所にまとめられているため、簿記の複製を心配するのではなく、コードの意図に集中できます。

独自の非同期シーケンスを作成するには、AsyncStreamに多くの柔軟性があります。

これは本当にほんの一例であり、あなた自身のコードに適応できる他の多くのものがある可能性があります。

AsyncStreamは、既存のコードを非同期シーケンスに適合させるのに最適な方法です。

安全性、反復、キャンセルなど、非同期シーケンスに期待されるすべてのものを処理しますが、バッファリングも処理します。

AsyncStreamは、生成される要素の唯一のソースは構築からであるため、独自の非同期シーケンスと独自のAPIから適切なリターンタイプを構築する堅実な方法です。

そして、あなたが投げられているエラーを表す必要がある場合?

まあ、私たちはそのためのタイプを持っています!

AsyncThrowingStreamはAsyncStreamに似ていますが、エラーを処理できます。

AsyncStreamと同じ柔軟性と安全性を提供しますが、反復からスローすることで障害を処理できます。

AsyncSequenceは、複数の非同期値を扱うのに安全で使い慣れた本当に強力なツールです。

シーケンスの使い方を知っていれば、すでにAsyncSequenceの使い方を知っています。

非同期シーケンスとは何か、どのように使用されるかを調べ、AsyncStreamを紹介しました。

私たちは、理論とそれらを定義するもの、そして新しく導入された非同期シーケンスのいくつか、そして最後に、独自のシーケンスを構築する方法に飛び込みました。

私はあなたが次に彼らと何をするかを心待ちにしています。

♪