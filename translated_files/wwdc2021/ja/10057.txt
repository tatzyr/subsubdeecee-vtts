10057

♪ベース音楽の演奏♪

♪

クリス・ドネガン:こんにちは、私はUIKitのエンジニアであるクリスです。

後で同僚のアナントとモハメッドが参加します。

iPadは、そのパワーと機能により、多くの人々にとって主要なデバイスです。

このビデオでは、iPadアプリを次のレベルに引き上げるために使用すべきいくつかのエキサイティングな新機能について学びます。

まず、マルチタスクとシーンの最新の進歩を紹介します。

その後、Anantはキーボードショートカットの強力な変更を案内します。

最後に、Mohammedはシステムポインタの最新の機能強化を紹介します。

すぐにマルチタスクに入りましょう。

iPadOS 13では、アプリのUIの複数のインスタンスを実行する機能が導入されました。

iPadOS 15では、シーンプレゼンテーション用の新しいAPIと強化された状態復元で、このエクスペリエンスを改善しています。

これらの機能強化は、既存のUISceneインフラストラクチャに基づいています。

UISceneを採用していない場合は、「iPadで複数のWindowsを導入する」をチェックしてください。

重要な概念を簡単に説明しましょう。

シーンは、アプリのUIの単一のインスタンスを表します。

シーンの構成要素の構造は、シーン構成によって定義されます。

少なくとも、シーンの役割とデリゲートクラスを定義します。

名前、ストーリーボード、シーンサブクラスを指定することもできます。

シーン設定は、Info.plistで宣言することも、UISceneConfigurationオブジェクトを使用して実行時に作成することもできます。

シーンの内容はNSUserActivityで表されます。

これらの活動は、シーンの要求や状態の復元に使用されます。

シーンはシーンデリゲートによって管理されます。

デリゲートは、UIの設定、ライフサイクルイベントへの応答、状態の保存と復元を担当します。

最後に、シーンはシーンセッションによって追跡されます。

シーン自体は、バックグラウンドにあるときにシステムによって切断され、再接続することができます。

シーンセッションは、接続状態に関係なくシーンを追跡し、起動の合間に持続します。

セッションは、システムアプリスイッチャーの表現と考えることができます。

スイッチャーの各項目は、シーンセッションに対応します。

システムからシーンをリクエストするときは、リクエストをカスタマイズするためのオプションオブジェクトを提供できます。

iPadOS 15には、ウィンドウシーン専用の新しいオプションサブクラスがあります。

このサブクラスを使用すると、プレゼンテーションスタイルを指定できます。

ウィンドウシーンのプレゼンテーションスタイルは、ワークスペースの他のシーンと比較してシーンがどのように表示されるかに影響します。

目立つ、標準、自動の3つの可能な値があります。

これは目立つプレゼンテーションスタイルを使ったシーンです。

それは現在のワークスペースでモーダルに提示され、その背後にあるシーンは暗められています。

モーダルなので、キャンセル、閉じる、または完了ボタンを指定する必要があります。

この新しいスタイルは、新しいシーンの舞台と考えることができます。

新しいマルチタスクコントロールを使用して、他のシーンと同様に再配置でき、後でアプリシェルフに移動することもできます。

このスタイルがシーンに適しているかどうかを検討する際には、心に留めておくべきガイドラインがいくつかあります。

まず、目立つシーンはそれ自体が役に立つはずです。

別のシーンにオプションやツールを提供するために使用すべきではありません。

「完了」または「閉じる」ボタンを提供し、ドキュメントやファイルなど、アプリ内の特定のコンテンツに専念する必要があります。

この専用のコンテンツスコープは、シーンのアクティベーション条件で定義する必要があります。

アクティベーション条件の詳細については、「複数のWindowsでコンテンツをターゲットにすること」をチェックしてください。

この例は、Safariが標準スタイルを使用して新しいシーンを開く方法を示しています。

それらは並んで提示され、それぞれとの相互作用を可能にし、両方ともメインシーンの完全な機能を提供します。

スタイルとして自動を指定することもできます。

この値は、要求された方法に基づいて最適なスタイルを選択する必要があることをシステムに伝えます。

iPadOS 15は、スタイルを使用してプレゼンテーションをカスタマイズする方法を提供するだけでなく、新しいシーンでコンテンツを簡単に開くことができます。

Macでは、コンテキストメニューで新しいウィンドウで開くアイテムを見つけるのが一般的です。

UIWindowScene.ActivationActionを使用して、この使い慣れた体験をiPadアプリに持ち込む必要があります。

これは、メニュー、ボタン、バーボタンの項目で使用できるシーンを要求するための新しいUIActionサブクラスです。

この機能をアプリに追加するには、まずUIWindowScene.ActivationActionを初期化します。

アイテムが選択されたときに実行されるクロージャで初期化されます。

クロージャは、新しいシーンのコンテンツのユーザーアクティビティを含むアクティベーション設定を返す必要があります。

最後に、アクションをメニューに入れて、あなたは行っても大丈夫です。

iPadとMac Catalystでは、メニューに「新しいウィンドウで開く」項目が表示され、選択すると新しいシーンが表示されます。

iPhoneでは、複数のシーンがサポートされていないため、アイテムは自動的に非表示になります。

代わりに別のアイテムを表示したい場合は、代替アクションを提供できます。

前の例を更新して1つを提供しましょう。

これを行うには、代替アクションを作成することから始めます。

新しいアクションのタイトルと画像は、複数のウィンドウが利用できない場合に表示されます。

次に、新しいアクションを代替として渡すことで、シーンアクティベーションアクションの初期化子を更新します。

代替アクションが提供されると、iPadとMac Catalystのメニューにはまだ「新しいウィンドウで開く」項目が表示されますが、iPhoneでは「詳細を表示」項目が表示されます。すべてコードに単一の条件なしで行われます。

これらのメニュー項目を追加することは、人々が新しいシーンでコンテンツを開くための明確で身近な方法です。

しかし、それが唯一の方法ではありません。

iPadはタッチファーストのデバイスで、1回のジェスチャーで簡単にシーンを開くことができます。

メモアプリでは、セルをつまむと、新しいシーンでメモが開きます。

シーンは、セルから最終的な位置までインタラクティブにアニメーション化されます。

アプリでこの機能を提供するには2つの方法があります。

コレクションビューを使用している場合は、新しいデリゲートメソッドがあります。

その他のビューについては、UIWindowScene ActivationInteractionを使用してください。

これらは両方とも、目立つスタイルのシーンを提示するためのものです。

コレクションビューでこのジェスチャーをサポートするには、sceneActivationConfiguration ForItemAt indexPathという名前の新しいデリゲートメソッドを実装します。

これは、以前のコンテキストメニューの例と非常によく似ています。

新しいシーンのコンテンツのユーザーアクティビティを作成し、そのアクティビティでアクティベーション設定を返します。

すべてのセルが新しいシーンを開くのをサポートしたくないかもしれません。

ジェスチャーが始まるのを防ぐために、ゼロを返してください。

他のビューでこのジェスチャーをサポートするには、UIWindowSceneを作成します。アクティベーションインタラクション。

これは、相互作用自体とビューの座標空間における相互作用のポイントという2つの引数を受け入れるクロージャで作成されます。

これらは、ビューのさまざまな領域の特定のユーザーアクティビティを作成するために使用できます。

クロージャは、ユーザーアクティビティのアクティベーション設定を返す必要があります。

インタラクションにはエラーハンドラもかかります。

複数のシーンをサポートしていないプラットフォームではインタラクションが無効になっていますが、構成の問題やシステムリソースの不足によりエラーが発生する可能性があります。

ウィンドウシーンを表示するこれらの方法はすべて、同じアクティベーション設定オブジェクトを使用していることにお気づきでしょう。

その唯一の要件はユーザーアクティビティですが、シーンリクエストオプションとターゲットプレビューも含まれています。

これらが提供されていない場合、システムはあなたのためにそれらを作成するために最善を尽くします。

しかし、あなたは経験を洗練させるためにそれらを明示的に提供することができます。

例として、これらのコレクションビューセルには、サムネイル、タイトル、キャプションがあります。

セルがピンチアウトされると、主にサムネイルのコンテンツのより大きなバージョンを表示するシーンが表示されます。

新しいシーンがセル全体から移行していることに注意してください。

サムネイルだけから移行した方が良さそうです。

この効果を達成するために、アクティベーション設定は以前と同じように作成されます。

次に、セルがサムネイルセルであるかどうかを確認します。

その場合は、セルのサムネイルビューを使用してターゲットを絞ったプレビューを作成し、設定に設定します。

アクティベーション設定のカスタムプレビューを提供することで、トランジションははるかに洗練されます。

詳しく見てみましょう。 

今では、セル自体から移行するのではなく、サムネイルから移行し、セルの残りの部分を所定の位置に残します。

アクティベーション設定では、アプリのシーンをリクエストできます。

ただし、自分でシーンを構築することなく、単にファイルを表示したいと思うかもしれません。

iPadOS 15はこれをとても簡単にします。

UIWindowSceneには特別なサブクラスがあります。ActivationConfigurationは「QLPreviewScene ActivationConfiguration」と呼ばれます。

プレビューシーン設定を返すと、システムが管理するプレビューシーンが要求されます。

シーンデリゲートや心配するコールバックはありませんが、アプリはInfo.plistで複数のウィンドウのサポートを宣言する必要があります。

人々が新しいシーンでコンテンツを開くための洗練された便利な方法を提供することは重要です。

しかし、シーンの状態を保存して復元することも同様に重要なので、後でそれらに戻ることはシームレスな経験です。

シーンがバックグラウンドに移動すると、システムはシーンのデリゲートにNSUserActivityがその状態を表すように要求します。

このアクティビティは、Handoffをサポートしている場合は、ルートビューコントローラーのアクティビティ、またはその場で作成されたアクティビティである可能性があります。

ここでは、アクティビティのユーザー情報辞書にテキストフィールドの内容を保存してユーザーアクティビティが作成されます。

最高の体験を提供するために、シーンの状態はコンテンツだけを超える必要があります。

また、スクロール位置、カーソル位置、ファーストレスポンダーステータスなどの視覚的およびインタラクション状態も保存する必要があります。

これらのそれぞれを個別に保存するのではなく、UITextFieldとUITextViewはinteractionStateプロパティを持つようになりました。

このプロパティは、すべてのインタラクション状態を含む単一のオブジェクトを提供します。

オブジェクトにはコンテンツ自体が含まれていないため、ユーザーアクティビティに保存するための追加情報です。

テキストフィールドのインタラクション状態を保存して、前の例を更新しました。

これで、コンテンツとインタラクション状態の両方を保存することで、ユーザーアクティビティには正確に復元するのに十分な情報が含まれています。

iPadOS 14では、状態の復元は少し難しい場合があります。

シーンが接続されているときに状態を復元しようとすると、ストーリーボードとビューが完全にロードされていないことに気付くでしょう。

後で復元した場合、シーンがフォアグラウンドに移行していたときに、それが初めてだったかどうかを追跡する必要がありました。

iPadOS 15は、状態を復元するための新しいデリゲートメソッドでこの問題を解決します。

シーンが接続され、ストーリーボードがロードされた後、フォアグラウンドへの最初の移行の前に呼び出されます。

アプリがストーリーボードを使用しているかどうかに関係なく、状態を復元するためにこの新しいコールバックを使用する必要があります。

前の例で保存されたアクティビティから状態を復元することは、システムが sceneRestoreInteractionStateを呼び出すことから始まります。

次に、テキストフィールドの内容を復元します。

最後に、その相互作用状態を復元します。

インタラクション状態の前にコンテンツを復元することが重要です。

最後に、同期復元状態は複雑になる可能性があります。

データベースにアクセスしたり、ファイルをロードしたりする必要がある場合があり、その間に空のUIは不要です。

これを考慮して、iPadOS 15では、アプリが短期的な延長をリクエストできます。

この拡張機能の間、メインのRunLoopの実行を許可しながら、起動イメージは表示されたままになります。

コンテンツが読み込まれると、アプリは復元を完了するように合図するはずです。

この拡張機能は短く、ネットワークアクセスなどの潜在的に長時間実行されるタスクに使用することを意図していません。

アプリの完了の合図に失敗したり、時間がかかりすぎたりすると、システムによって閉じられます。

拡張状態復元を使用するには、まずシーンから拡張をリクエストします。

その後、非同期作業を開始します。

コンテンツが読み込まれたら、それを復元し、シーンに復元を完了するように指示します。

その後、シーンには復元されたばかりのUIが表示されます。

アプリでマルチタスクをサポートすることはそれを輝かせますが、真の次のレベルのiPadアプリになるためには、やるべきことがもっとあります。

そして今、アナントへ。

アナント・ジェイン:ありがとう、クリス!

私の名前はアナントで、UIKitエンジニアです。

人々は、iPadが一瞬の通知で物理的なキーボードに取り付けることができながら、手に持つのに十分軽いのが大好きです。

彼らは、優れたキーボードサポートを持つことで、あなたのアプリが彼らに追いつくことを期待しています。

iPadOS 15では、アプリのキーボードショートカットを次のレベルに引き上げるためのいくつかの新機能が導入されています。

iPadOS 15は、キーボードショートカットを発見するためのまったく新しいインターフェースを備えています。

各コマンドを使い慣れたカテゴリに構造化し、iPadとMac Catalystバージョンのアプリ間のパリティが向上します。

メニューは、システム全体のどこからでも起動できる便利な検索機能を提供します。

ショートカットをタップしてトリガーすることもできます。

コマンドがレスポンダーチェーンにディスパッチされる方法など、UIKeyCommandでキーボードショートカットをサポートする方法について復習が必要な場合は、「アプリでハードウェアキーボードをサポートする」をチェックしてください。

Mac Catalystでは、各アプリにはメインメニューと呼ばれるグローバルメニューがあり、画面上部のメニューバーに表示されます。

メインメニューは、ファイルや編集などのいくつかのカテゴリサブメニューで構成されており、これらのカテゴリメニューには、すべてのアプリのコマンドを含むさらなるサブメニューが含まれています。

iPadOS 15では、メインメニューシステムをiPadアプリに導入しました。

Commandキーを押したままに表示される新しいショートカットインターフェイスには、このメニューが表示されます。

現在、メインメニューシステムは、Macと比較してiPadで少し異なって表現されています。

Macは各カテゴリ内の完全なサブメニュー階層を表示しますが、iPadはそれらの階層を平坦化します。

無効で実行不可能なコマンドは、Macではグレー表示表示されますが、iPadでは非表示になっています。

さらに、iPadのショートカットメニューは、アプリでキーボードショートカットを見つけるのに役立つように設計されています。

Macのメニューバーのようにキーレスコマンドは表示されません。

デフォルトでは、メインメニューには、ファイルや編集などのすべてのシステムカテゴリメニューが含まれています。

これらには、UndoとRedo、PasteとMatch Styleなど、すべてのシステムコマンドが含まれます。

iPadOS 15は、このシステムコマンドのリストにPrintコマンドを追加します。このコマンドは、アプリがInfo.plistにUIApplication SupportsPrintCommandキーを追加することで取得できます。

iPadOS 15のiPadアプリがメインメニューシステムをサポートしているようになったので、Mac Catalystアプリと同様に、UIMenuBuilder APIを使用してカスタマイズできます。

実際、すでにアプリのMac Catalystバージョンをお持ちの場合は、すでにほとんどの作業を完了しています。

アプリはビルダーを使用して、サポートされているすべてのキーコマンドをメインメニューに追加する必要があります。

これは、アプリが以前にキーボードショートカットを宣言する方法からの変更です。UIResponderのkeyCommandsプロパティをオーバーライドするか、ビューコントローラーでaddKeyCommand(_:)を呼び出すことによって。

この方法で定義されたコマンドは引き続き機能しますが、新しいインターフェイスの別の未分類セクションに表示されます。

アプリは、このようなキーコマンド宣言を削除し、代わりにメインメニューに追加する必要があります。

メインメニューをカスタマイズするには、AppDelegateでbuildMenu(withbuilder:)をオーバーライドします。

UIKitは、アプリの起動時にこのメソッドを呼び出し、UIMenuBuilderオブジェクトを渡します。

アプリは、ビルダーがメインメニューシステムを変更しているかどうかを確認する必要があります。

もしそうなら、彼らはビルダーを使ってカスタマイズを行うことができます。

アプリがタブを操作するためのファイルメニューにいくつかのキーコマンドを求めているとします。

アプリは、UIMenu APIを使用してサブメニューを作成し、そのメニューの子として目的のキーコマンドを追加するだけです。

次に、アプリはビルダーオブジェクトのinsertChildメソッドを呼び出して、ファイルメニューにサブメニューを挿入します。

ファイルメニューのように、メインメニューシステムの既存の要素を参照するには、この場合、アプリは要素の識別子を指定する必要があります。

組み込みのシステムメニュー識別子は、UIMenu.Identifierの下で定数として定義されています。

アプリは独自のメニューカテゴリも簡単に作成できます。

ここで、アプリはブックマークメニューを作成します - もう一度、UIMenu APIを使用します。

次に、アプリはビルダーを使用してそのメニューをルートメニューに挿入します。この場合、システムビューメニューの後です。

必要なのはそれだけです!

これで、ビルダーは、ファイルメニューと同じように、ブックマークメニューにさらに挿入するために使用できます。

UIKitが自動的に生成する新しいメニューの識別子を渡すだけです。

今、私は識別子に言及し続けています。

UIMenuBuilderは、メインメニューシステムの各要素に、個々のコマンドを含む一意の識別子を持つように強制します。

アプリがキーコマンドを挿入して、コンテンツをリストまたはグリッドとして表示するとします。

どちらのコマンドも同じアクションを共有します: changeViewMode(_:)。

メインメニューシステムでは、コマンドはアクションによって暗黙的に識別されるため、これらのコマンドは両方とも同じ識別子を共有します。

UIMenuBuilderは、異なる識別子がない限り、両方のコマンドを挿入することはできません。

これらのコマンドを区別する1つの方法は、異なるpropertyList値を与えることです。

しかし、より良い方法は、単に各コマンドに、それが具体的に何をするかを説明するユニークなアクションを与えることです。

ビルダーはまた、メインメニューのキーボードショートカットの組み合わせがユニークであることを強制します。

アプリがCommand-IにGet Infoキーコマンドを挿入したとします。

テキストスタイルメニューのシステムイタリックショートカットは同じショートカットを共有しているため、この挿入も失敗します。

繰り返しになりますが、2つの解決策があります。

このアプリは、Get Infoショートカットを、Control-Command-Iなどの既存のショートカットと衝突しないものに変更できます。

あるいは、アプリは、必要でない場合は、テキストスタイルのコマンドを削除するようにビルダーに指示することができます。

挿入に重複が含まれている場合、UIMenuBuilderはその挿入に失敗し、重複したキーコマンドまたは共有識別子を示すエラーをコンソールに記録します。

挿入が表示されない場合は、どこかに重複がある可能性があるので、コンソールでこのようなログを探してください。

buildMenu(with builder:)への呼び出しが終了すると、アプリのメインメニューがMacのメニューバーとiPadのショートカットオーバーレイに表示されます。

しかし、1つ問題があります。

アプリは、ブックマークを名前または日付で並べ替えるコマンドを含むサブメニューを追加しました。

しかし、iPadのショートカットオーバーレイにはサブメニュー階層が表示されないため、これらのショートカットがiPadOSで何をするかは明らかではありません。

このような状況では、キーコマンドでよりわかりやすい発見可能性のタイトルを設定します。

iPadOSは、両方が提供されている場合、通常のタイトルよりも発見可能性のタイトルを好みます。

さて、先ほど、個々のレスポンダーはキーボードショートカットの宣言を避け、代わりにメインメニューシステムで宣言する必要があると述べました。

ただし、レスポンダーはメインメニューコマンドのアクションメソッドを実装する必要があります。

キーコマンドがトリガーされると、UIKitは自動的にアクションをレスポンダーにディスパッチします。

UIKitは、アプリのレスポンダーチェーンを横断することでこれを行います。

アクションを実行できるレスポンダを見つけるとすぐに、そのレスポンダのアクションメソッドを呼び出します。

チェーン内の何もアクションを実行できない場合、キーコマンドは実行できません。

UIResponderの概念を初めて使うなら、「アプリでハードウェアキーボードをサポート」には、それがどのように機能するかについて素晴らしい紹介があります。

「素晴らしいMac Catalystアプリの資質」ももう少し詳しく説明しています。

UIKitがチェーンに沿ってレスポンダー検索を実行すると、2つの便利なUIResponderメソッドを呼び出します。

アプリは、キーコマンドを改善するために、レスポンダーでこれらのメソッドをオーバーライドできます。

1つ目は、UIKitがレスポンダーがアクションを実行できるかどうかを確認するために使用するcanPerformAction(_:withSender:)です。

デフォルトでは、レスポンダがそのアクションメソッドを実装する場合、これはtrueを返します。それ以外の場合は、falseを返します。

レスポンダーはこれをオーバーライドしてカスタムロジックを追加できます。

たとえば、Webブラウザは、開いているタブがない場合、closeTabコマンドが実行できないことをUIKitに伝えることができます。

UIKitはそのアクションのターゲットレスポンダーを見つけることができないため、コマンドは実行不能になり、ショートカットインターフェイスには表示されません。

このメソッドのオーバーライドは、未処理のケースに対してsuperを呼び出す必要があることに注意してください。

もう1つの便利な方法はvalidate(_ command:)です。

UIKitがキーコマンドのターゲットレスポンダを見つけると、そのレスポンダでこのメソッドを呼び出し、コマンドのコピーを渡します。

レスポンダーは、validate(_ command:)をオーバーライドして、アプリの現在の状態のコマンドの外観を更新できます。

ここでは、アプリは現在のページがブックマークされているかどうかに基づいて、toggleBookmark(_:)コマンドのタイトルを更新します。

このメソッドで設定されたタイトルは、表示されたときにショートカットインターフェイスに反映されます。

iPadOS 15では、UIKitはレスポンダーチェーンに大きな変更を導入しています。

アプリがフォーカスシステムでキーボードナビゲーションを採用すると、レスポンダートラバーサルはファーストレスポンダーではなくフォーカスされたアイテムから開始されます。

この変更は、キーコマンドで非常にうまく機能します。

たとえば、写真を使用すると、ユーザーはキーボードのみを使用してフォトライブラリを操作できます。

ユーザーがグリッド内のセルに焦点を合わせると、スペースバーを押してその写真を見ることができます。

Command-Cを押してその写真をコピーして別のアプリに貼り付けることもできます。

各セルはさまざまなキーコマンドアクションを実装し、レスポンダートラバーサルはフォーカスされたアイテムから始まるため、キーコマンドはセルをターゲットにします。

要するに、フォーカスシステムはキーコマンドとレスポンダーチェーンをレベルアップします。

それを利用して、アプリで強力なコンテキストショートカットをサポートしてください。

詳細については、「iPadのキーボードナビゲーションに焦点を当てる」をチェックしてください。

最後に、iPadOS 15とmacOS 12はキーボードショートカットのローカリゼーションを導入します。

これらのSDKを使用してアプリを構築すると、システムは自動的に各キーボードレイアウトのショートカット修飾子と入力をローカライズします。

たとえば、コマンドバックスラッシュショートカットを取ります。

ショートカットは米国のキーボードで動作しますが、そのレイアウトにはバックスラッシュキーがないため、日本語のキーボードで実行することは不可能です。

そのため、システムは日本語キーボードのショートカットを再マッピングします。

これは、アプリがショートカット修飾子や入力をローカライズせず、代わりにシステムに作業をさせるべきであることを意味します。

アプリは、アプリ全体のレベルまたはショートカットごとに自動ローカリゼーションをオプトアウトすることもできます。

システムがショートカットをローカライズすると、右から左へのレイアウトにもミラーリングされます。

たとえば、Command左括弧で後方に移動するショートカットは、Command右括弧に反転します。

ショートカットをミラーリングすべきでない場合は、コマンドの allowsAutomaticMirroring プロパティを false に設定して、自動ローカリゼーションを完全に無効にせずにミラーリングを無効にします。

iPadOS 15は、キーボードショートカットのための巨大なリリースです。

今日取り上げたすべてのものに加えて、他にもたくさんの機能強化があります。

そのため、すべての新しいマルチタスク機能を採用し、優れたキーボードサポートを構築しました。

今、モハメッドは、あなたのiPadアプリを最高レベルに引き上げるためのいくつかの指針を提供します。

モハメド・ジスラウィ:ありがとう、アナント!こんにちは、私はモハメッドです。

iPadOS 15がシステムポインタにもたらす改善点について話しましょう。

iPadOS 13.4は、iPadのタッチベースのUIとマウスやトラックパッドの精度を橋渡しするアダプティブシステムポインターを導入しました。

ポインターインタラクションに慣れていない場合は、それらに慣れて、これらの以前のビデオをチェックしてください。

「iPadOSポインタ用ビルド」は、ポインタインタラクションAPIを分解します。

「Design for the iPadOS Pointer」は、その背後にあるデザイン哲学を掘り下げ、アプリに採用する際のベストプラクティスについて議論します。

iPadOS 15は、iPadのデザイン言語と一致する方法で、おなじみのMacユーザーインタラクションをもたらします。

また、使いやすさと明瞭さを高めるいくつかの新しい概念も紹介しています。

これらの追加の最初のものは、バンド選択であり、Macを使用している人なら誰にでも馴染みのある新しいポインタ固有の複数選択体験です。

iPadOS 15では、コレクションビューをクリックしてドラッグすると、ポインタが長方形に伸び、コレクションビューは長方形が包含するアイテムを選択します。

もちろん、これはMac CatalystアプリのおなじみのMac UIに自然に翻訳されます。

このインタラクションは、非リストのUICollectionViewsに組み込まれています。

shouldBeginMultiple SelectionInteraction APIを介して既存の1本指と2本の指の複数選択ジェスチャーをサポートするUICollectionViewは、iPadOS 15でこの動作を自動的に取得します。

UICollectionView以外では、新しいUIBandSelectionInteraction APIを使用すると、このエクスペリエンスをアプリで簡単に採用できます。

選択ロジックは完全にあなた次第なので、カスタム選択動作をサポートし、選択した方法で変更された選択にUIを反応させることができます。

開始するには、ポインタが移動し、インタラクションの状態が変更されるときに呼び出される選択ハンドラとのインタラクションをインスタンス化します。

作成したら、他のUIInteractionと同様に、インタラクションをビューに追加します。

ハンドラでは、インタラクションの状態と selectionRect の変更に応答することで、カスタム選択ロジックを実装できます。

ここでは、ポインタが移動している間、インタラクションの選択Rect内の項目に選択を設定する簡単な実装があります。

次に、プライマリマウスボタンが解放され、インタラクションが終了すると、選択セッションが終了します。

基本的な選択に加えて、UICollectionViewの内蔵バンド選択は、箱から出してすぐにいくつかの一般的なキーボードショートカットをサポートしています。

たとえば、ドラッグの開始時にShiftキーを押したままにすると、現在選択されているアイテムを置き換えるのではなく、既存の選択にアイテムが追加されます。

コマンドを長押しすると、選択rect内の項目の選択状態が切り替えます。

これは、ドラッグの開始時に保持されたキーを提供するインタラクションのinitialModifierFlagsプロパティを使用して、カスタムUIで実装できます。

押されたすべての修飾子のセットであるため、任意のキーの組み合わせに応答して、アプリに固有のカスタムまたはより高度な動作をサポートできます。

システムポインタへの2番目の追加は、アクセサリを取り付ける機能です。

アクセサリは、二次形状とプライマリポインタを組み合わせることで、追加情報を伝達し、コンテキストのヒントを提供します。

たとえば、左側の例では、2つの矢印は、このビューを水平にドラッグできることを示しています。

右側の例では、プラスは、このカートに追加ボタンに追加のコンテキストを提供します。

アクセサリーとカスタムポインタ形状の使用には、いくつかの重要な違いがあります。

アクセサリーは視覚的に分離されており、メインポインタに二次的です。

これは、それらが異なる外観でレンダリングされ、メインポインタとは別にアニメーション化される可能性があるという事実によって強調されています。

それらは、異なるアイデアを伝えるためにポインターの周りに組み合わせて配置できる独立したユニットです。

それらは独立しているので、どんなポインタースタイルとも組み合わせることができます。

これは、同じアクセサリーセット（ドラッグ可能性を示す2つの矢印）を異なるポインタスタイルと組み合わせる方法のデモンストレーションです。

左側では、ポインタがビューとマージして持ち上げるリフト効果と組み合わされています。

真ん中には、ポインタが丸みを帯びた長方形に変わり、ビューの下に入るハイライト効果の横にあります。

右側には、新しいUIPointerStyle.system() APIを使用してデフォルトのシステムポインタが表示されます。

そのため、ポインタの活気を犠牲にすることなく、アプリのUIとの深い関係を維持しながら、状況に理想的な効果を使用しながら、この追加のコンテキストを提供することができます。

ポインタースタイル間でアニメーション化するように、システムは自動的にアクセサリーの外観と消失をアニメーション化します。

また、アクセサリーの形状と位置の間でシームレスにアニメーション化されます。

与えられた効果がアクティブな間にアクセサリーを移行する行為は意味があります。

このような移行は、基礎となるUIの状態や動作の変化を伝えるために使用できます。

左側の例では、プラス記号から無記号への移行は、以前に可能だった操作がもはや許可されていないことを示している可能性があります。

ポインターアクセサリーは、UIPointerShapeとUIPointerAccessory.Positionで構成され、所望の位置をポインターの中間点からのオフセットと上からの角度として記述します。

便宜上、UIKitはポインタの周りの位置にいくつかの事前定義された値を提供します。

事前定義されたポジションがニーズに合わない場合は、それらを出発点として使用し、個々のプロパティをカスタマイズできます。

この例は、右上の位置から始まり、オフセットをカスタマイズします。

この例のように、完全にカスタム位置を定義して、カスタムオフセットと角度で位置を作成することもできます。

このセグメントの冒頭で見た例を設定するには、ビューでUITargetedPreviewを作成し、それを使用してリフト効果のあるUIPointerStyleを作成します。

次に、スタイルの新しいアクセサリープロパティを、2つの矢印アクセサリーを含む配列に設定します。

UIKitは既製の矢印アクセサリーを提供しているので、エフェクトの左側と右側に配置されたものを2つ作成できます。

したがって、ポインタがこのビューの上にホバリングすると、ビューが上がると2つの矢印がアニメーション化し、ドラッグできることを示唆します。

ポインタ効果を持つビューがドラッグ可能なこの種のインタラクションを実装しようとしたことがあるなら、おそらくこのようなことに気づいたことがあるでしょう。

ポインタがポインタ領域の端に到達すると、持ち上げられたビューから切り離され、効果が終了します。

これは、ポインタが移動中にビューに固執するのを防ぐため、通常は望ましいです。

しかし、このようなシナリオでは、理想的な経験は、ポインタ効果が安定したままであり、ビューにラッチし、それが引きずられるにつれてそれに従うことです。

この種のインタラクションをより有効にするために、iPadOS 15はUIPointerRegionでラッチAxesの概念を導入しています。

領域が特定の軸に沿ってラッチすると、プライマリマウスボタンが押されたときに、そのポインタ効果は軸に沿ってポインタに従います。

水平ラッチ領域を使用すると、y軸に沿ってゴムバンドをしながら、x軸に沿って自由にドラッグできます。

垂直ラッチすると、y軸に沿って自由にドラッグできます。

そして、両方に沿ってラッチする1つは、両方の軸に沿って自由にドラッグすることができます。

これらの新しいツールは、いくつかの本当に強力な新しい経験を構築するために使用することができます。

ここでは、PagesやKeynoteなどのドキュメント編集アプリに組み合わされています。

この画像はバンド選択を使用して選択できます。

画像を選択すると、ドラッグインジケーターが表示され、ポインジケーターにカーソルを合わせると、アクセサリは、ドラッグされた場合に画像がどのようにサイズ変更されるかを示唆して表示されます。

そして最後に、ラッチにより、ポインタ効果とアクセサリは軸ロックされたサイズ変更ジェスチャーに従うことができます。

これらは、iPadOS 15がiPadにもたらす機能強化のほんの一部です。

アプリの有用性を最大限に高めるために、該当する場所でそれらを活用してください。

目立つシーンを採用して、人々にアプリのコンテンツの集中的で途切れないビューを提供します。

新しいキーボードショートカットメニューで複雑なタスクをすばやく達成できるようにし、新しいポインタ機能で生産性を向上させます。

見てくれてありがとう!

♪