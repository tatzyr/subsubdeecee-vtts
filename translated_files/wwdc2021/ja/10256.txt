10256

♪ベース音楽の演奏♪

♪

カイル・マコンバー:こんにちは、私はカイルです。

Swift Standard Libraryチームは、Swift ArgumentParser、Swift Numerics、Swift Systemなど、増え続けるオープンソースパッケージの名簿を維持しています。

今日、私たちは家族に2つの大きな新しい追加を紹介することに興奮しています:スウィフトアルゴリズムとスウィフトコレクション!

Swiftアルゴリズムは、Swift標準ライブラリを拡張するシーケンスおよびコレクションアルゴリズムのオープンソースパッケージです。

Swiftの最も強力な機能の1つは、組み込まれたアルゴリズムの豊富な分類です。

語彙を学ぶには少しの投資が必要ですが、一度そうすると、どれだけのアルゴリズムが目の前に隠れているか、それらを採用することでコードの品質をどれだけ向上させることができるかを発見するのは印象的です。

私が何を意味するかを見るために、私が取り組んできたメッセージングアプリケーションのコードを見てみましょう。

テーブルビューで選択した行のインデックスパスを反復し、転送または削除のために対応するすべてのメッセージを収集するこのループを検討してください。

これはただの地図です。

マップを使用すると、長さや複雑さに関係なく、クロージャの本体が入力を変換しているという余分なコンテキストを提供するため、このコードは読者にとってより明確になります。

マップを使用すると、容量を予約することで配列のサイズ変更による中間割り当てが回避されるため、このコードが速くなります。

または、ユーザーが画像をタップすると、トランスクリプト内のメッセージを反復し、クイックルックを使用して表示するためのすべての添付ファイルを収集するこのループを検討してください。

これは単なる地図とフィルターです!

実際、ニルをフィルタリングし、オプションをアンラップにマッピングするこのパターンは非常に一般的であるため、特別な名前とアルゴリズムがあります。コンパクトマップです。

次に、このコードを検討してください。

私はメッセージの配列を持っており、それをトランスクリプト項目の配列に変換したいです。

厄介なのは、特定のメッセージがチャット記録の複数の項目に対応する可能性があることです。

ここでマップを使用すると、配列の配列が生成されます。

しかし、それは私が欲しいものではありません。私はただ平らな配列が欲しいだけです。

これは、raw for loopの使用に戻らなければならないということですか？

もちろんそうではありません。そのための別のアルゴリズムがあります。

それは「結合」と呼ばれています。

それが行うことは、すべての内部配列を要素の単一のフラットなコレクションに結合することです。

このマッピングと結合のパターンは非常に一般的であるため、別の特別な種類のマップを定義します。flatMapです。

もちろん、地図とフィルターは氷山の一角にすぎません。

私のアプリのチャット詳細画面から、この生のループを考えてみましょう。

最新のものから古いものまで、最後の6枚の写真をチャットで表示したいです。

そのため、トランスクリプトを最新のものから古いものまで逆に反復し、アイテムが写真の場合は、配列に追加します。

そして、私が6つになったら、私は停止します。

標準ライブラリ（逆、コンパクトマップ、プレフィックス）のアルゴリズムを連鎖することで、これをより簡潔に表現できます。

アルゴリズムを連鎖させることで、このコードをより明確に表現するための柔軟性も高まります。

たとえば、この操作について、逆のトランスクリプトの接頭辞ではなく、トランスクリプトの接尾辞の観点から考える方が自然だと思います。

したがって、アルゴリズムの連鎖は生のループよりも明確で簡潔ですが、パフォーマンスはどのように比較されますか?

チェーンの各ステップが中間配列を割り当てる場合、生のループよりも遅くなるのではないでしょうか?

標準ライブラリがここで巧妙なトリックをしていなかったら、答えはイエスでしょう。

先ほど見た結合アルゴリズムに戻り、何が起こっているのかを詳しく見てみましょう。

Joinedは実際にはここで新しい配列を割り当てて返さないことが判明しました。

代わりに、FlattenSequenceを返します。

FlattenSequenceは、私たちが「怠惰なアダプター」と呼ぶものです。

ほとんどの目的のために、それは配列のように機能しますが、それはただの薄いラッパーなので、効果的に自由に作成できます。

そして、それは怠惰なので、すべての作業を前もって行うのではなく、オンデマンドで要素を処理します。

FlattenSequenceのような怠惰なアダプターは、アルゴリズムチェーンがループの生で競争力のあるパフォーマンスを持つことを可能にするものです。

詳細画面に戻り、チャットで最後の6枚の写真を計算するためのアルゴリズムを詳しく見てみましょう。

接尾辞は実際には配列スライスを返すだけであることがわかります - それは賢いです - そして、その逆は遅延アダプターとしても実装されています。

コンパクトマップはどうですか?

それはまだ配列を返しています。それは怠け者ですか?

できます。

チェーンの先頭に.lazyを追加するだけで、マップやフィルターなどのクロージャを取るアルゴリズムのいずれかが怠惰になります!

怠惰なアルゴリズムチェーンは、潜在的に非常に大きなコレクションから少数の要素しか処理していないこのようなユースケースに最適です。

もちろん、時には配列が必要な場合や必要な場合があります。

その場合、アルゴリズムチェーンを配列初期化子でいつでもラップできます。

これは、標準ライブラリチームで、私たちが怠惰なアルゴリズムの大ファンであるもう一つの理由です。

怠惰なアルゴリズムを熱心な結果に変えるのは本当に簡単ですが、他の道を行くことは不可能です。

だから私はメッセージングアプリで大きな進歩を遂げており、デザイナーが機能リクエストで私に近づいてきます。

2つの連続したメッセージの間に1時間以上経過した場合、トランスクリプトにタイムスタンプを含めたいと考えています。

合理的に思える。

これには別のアルゴリズムが使えるものがありますよね？

あります。しかし、それにアクセスするには、Swift Algorithmsパッケージをインポートする必要があります。

時々、Swift標準ライブラリがまだカバーしていないこのようなユースケースに遭遇するでしょう。

アルゴリズムパッケージの目的は、あなたの助けを借りて、標準ライブラリに最終的に含めるために、不足しているアルゴリズムの新しいファミリーをインキュベートするために、摩擦の少ない会場を提供することです。

私たちはすでにSwiftアルゴリズムに40以上のアルゴリズムを追加しました。

要素のコレクションのすべての組み合わせまたは順列を生成すること、またはシーケンスの要素を2つまたは3つ、または述語によって決定されるグループで反復すること、またはコレクション内の5つの最小要素、5つの最大の要素、または任意の5つをランダムに選択することなど。

Swiftアルゴリズムに付属する強力な反復ツールのいくつかを詳しく見てみましょう。

windows(ofCount:)は、コレクションの要素にサイズ3のスライディングウィンドウを提供します。

ループの各ターンに対して、ウィンドウはベースコレクションのサブシーケンスにすぎません。ここではArraySliceです。これは中間割り当てを回避します。

ウィンドウ(ofCount:2)は特に一般的であるため、利便性があります。

それは「adjacentPairs」と呼ばれています。

adjacentPairsは、サブシーケンスではなくタプルをベンドし、より便利な要素アクセスを可能にします。

もう1つの強力な反復ツールはチャンク(ofCount:)です。

ウィンドウとは異なり、チャンクは重ならない。

コレクションがチャンク数で均等に割り切れない場合、シーケンスの最後のチャンクには残りが含まれます。

そして、ウィンドウと同様に、チャンクはベースコレクションのサブシーケンスであるため、作成が安価です。

時には、コレクションをlike-elementsのランにチャンクしたい場合があります。

ここでは、isPrimeをチャンクしています。

これは、isPrimeに同じ値を返す連続した要素のチャンクを反復することを意味します。

便宜上、chunked(on:)は、チャンクとチャンクされる値の両方のタプルをベンドします。

以前と現在の要素が異なる場合にのみ機能する、このような生のループを書いていることに気づいたことがありますか?

これはただのチャンクです!

メッセージの間に1時間以上経過するたびにトランスクリプトにタイムスタンプを含めるように、私のデザイナーからのその機能要求に戻りましょう。

思い出せば、トランスクリプト項目を作成するために、メッセージの上にフラットマッピングしてトランスクリプトを作成します。

さて、すべてのトランスクリプト項目は、その日付にアクセスできます。

日付をチャンクして、トランスクリプト項目をグループ化することができます。

私たちはすでに、コレクションをような要素のランにチャンクする方法を見てきました。

スウィフトアルゴリズムには、カスタム述語を提供できるチャンクの別のバリアントが付属しています。

隣接する要素のペアを渡し、同じグループに属している場合はtrueを返します。

ここでは、トランスクリプト項目間の時間間隔が1時間未満の場合、trueを返します。

次に、タイムスタンプを作成し、すべてを1つのフラットコレクションにまとめる必要があります。

以前、私たちはネストされたコレクションを平らにするために参加していました。

標準ライブラリには、セパレータを挿入できる結合された別のバリアントが付属しています。

このアルゴリズムを使用して、新しい行やカンマ区切り文字などと文字列を結合することは本当に一般的です。

しかし、この場合、一定の区切り文字では不十分です。

タイムスタンプを構築するには、次のチャンクの最初の日付にアクセスする必要があります。

さて、アルゴリズムパッケージには、前のチャンクと次のチャンクからセパレータを計算できる結合の別のバリアントが含まれています。

ここでそれを使用して、タイムスタンプで区切られたトランスクリプトアイテムのチャンクを結合することができます。

かなり満足しているね？

もちろん、これらの中間割り当てのいずれにも支払う必要はありません。

このすべては、.lazyを追加するだけでオンデマンドで計算できます。

ヴォイラ！

しかし、怠惰は銀の弾丸ではないことに注意したい。

シーケンスを1回だけ反復している場合、オンデマンドで計算すると、作業を節約し、割り当てを回避できます。

しかし、私がメッセージングアプリのトランスクリプトを使用しているように、シーケンスを何度も繰り返しているとき、オンデマンドのコンピューティングは同じ作業を何度も繰り返します。ユーザーが編集モードに入ったり、画像をタップしたり、詳細画面にアクセスしたりするたびに、マッピング、チャンキング、参加します。

このような場合でも、怠惰なアルゴリズムチェーンを使用する必要があります。

最後のステップとして、すべてを配列にまとめて作業を保存すると、より効率的になります。

Swift標準ライブラリとアルゴリズムパッケージから12以上の異なるアルゴリズムを見てきました。

それらのすべては、配列だけでなく、文字列、およびシーケンスとコレクションプロトコルに準拠した他のすべてのSwiftタイプでも動作します - 新しいSwiftコレクションパッケージのすべてのデータ構造を含みます。

アルゴリズムを連鎖させることで、コードがより明確で、より速く、より正確になります。

そして、それに熟達することは複雑ではありません。それはあなたの語彙を構築することです。

だから、次に生のループを読んだり書いたりしていることに気づいたら、それがマップ、フィルター、またはあなたが今見た他のアルゴリズムの1つであるかどうかを立ち止まって考えてください。

何も思い浮かばない場合は、シーケンスとコレクションプロトコルに関するドキュメントを検索するか、Swift Algorithms GitHubリポジトリのガイドを読むか、Swiftフォーラムで一緒に解決してください。

誰が知っている、それはアルゴリズムパッケージへの新しい追加のためのインスピレーションとして役立つかもしれません!

次に、Karoyは、新しいSwift Collectionsパッケージに付属する汎用性の高いデータ構造について教えます。

カロイ？

カロイ・ロレンティ:ありがとう、カイル!

データ構造について話しましょう。

今日の現状では、Swift標準ライブラリは、配列、順序なしセット、および順序なし辞書を提供する3つの主要な汎用データ構造のみを実装しています。

これらは、ユニバーサルコレクションタイプとして素晴らしい選択肢であることが証明されており、モジュールの境界を越えてデータを転送するのに特に最適です。

それらはすべて、コピーオンライト値のセマンティクスを実装し、効率的なインプレース突然変異操作を提供すると同時に、これらの突然変異なしに収集値が安全に渡され、作成されたコピーの予期しない変更につながることを保証します。

しかし、そこにはもっと多くのデータ構造があります。

より多くの選択肢から選択できると便利です。

今年初め、新しいデータ構造の実装で、Swift Collectionsパッケージをリリースしました。

このパッケージを使用すると、Swift開発者は、最終的にSwift標準ライブラリに含めることを提案する前に、新しいコレクションタイプで実際の制作経験を積むことができます。

Swift Collectionsパッケージをインポートすることで、追加のタイプにアクセスできます。

パッケージの初期バージョンは、最も頻繁に要求される3つのデータ構造を実装しています。

これらはたまたま3つの標準コレクションタイプの新しいバリエーションです。

ダブルエンドキュー、OrderedSet、OrderedDictionaryがあります。

これらは配列、セット、辞書に似ています。それらは同じテーマの変種であり、既存の構造物に新しい機能を追加します。

とはいえ、これらの新しいタイプは既存のタイプに代わるものではなく、それらを補完するものです。

一部のユースケースでは、新しいタイプがより適しています。

しかし、他の多くの人にとって、既存のタイプは引き続き正しい選択です。

どのデータ構造に到達するかを知るには、これらが既存のタイプとどのように異なるかを学ぶ必要があります。

では、ダブルエンドのキュー、またはむしろ一般的なキューから始めて、これらのそれぞれを簡単に見てみましょう。

スーパーマーケットで並んで待っている顧客からアプリケーション内の非同期タスクまで、任意の数のアイテムを1つずつ処理する必要がある場所にキューがポップアップ表示されます。

最も抽象的な形式では、キューは2つの主要な操作を提供します。アイテムをキューの背面にプッシュし、要素を前面からポップすることができます。

ダブルエンドキューは、これらのキュー操作を対称にします。

新しいアイテムをキューの先頭に効率的にプッシュすることをサポートします...

...背中から要素をポップするだけでなく。

「ダブルエンドキュー」という名前は、このような便利なタイプにはかなり一口なので、「deque」に短縮したいと思います。

そして、もう1つの音節を剃るために、これは伝統的にカードのデッキのように「デッキ」と発音されます。

Collectionsパッケージでは、dequeは使い慣れた配列タイプとほぼ同じAPIを持ち、同じプロトコルの多くを実装しています。

たとえば、配列リテラルを使用してdequeを作成できます。

DequeはRandomAccessCollectionプロトコルに準拠しています。

配列と同様に、dequeはコレクションの開始から測定されたオフセットである整数インデックスを使用します。

これにより、その位置に基づいて任意の要素に簡単にアクセスできます。

たとえば、このデクのインデックス1の要素はEの文字です。

さて、このコレクションの最後にある小文字のfに悩まされているのは私だけではないと確信しています。

幸いなことに、dequeはMutableCollectionプロトコルに準拠しているため、インデックス2を介して割り当てて、小文字のfを大文字のfに置き換えることでこれを修正できます。

ああ、それはとても良く見えます!

DequeはRangeReplaceableCollectionプロトコルも実装しているため、要素のサブレンジを挿入、削除、または置き換えるためのすべての使い慣れた操作を提供します。

たとえば、インデックスがゼロのinsert(contentsOf:)メソッドを呼び出すことで、dequeの前面にシーケンスを挿入できます。

これをどのように実行するかは、dequeが配列と異なり始めるところです。

配列を使用してアイテムを格納する場合、前面に新しい要素を挿入するには、既存の要素を移動して新しい要素のためのスペースを作ることから始める必要があります。

アクセスをできるだけシンプルにするために、配列はストレージの開始から始めて、要素を単一の連続したバッファに保持します。

配列が大きい場合、新しい要素のプリセットは比較的高価になります。したがって、前面に新しい要素を挿入するには、すでに配列にある要素の数にほぼ比例する時間がかかります。

デケの働きは異なります。

既存の要素を移動せずに新しい要素を付加できるように、ストレージバッファを境界の周りにラップします。

インデックスはまだコレクションの論理的な開始からオフセットであるため、挿入後、インデックス1の要素はBになります。

これは、dequesが論理インデックスと実際のストレージ位置の間で翻訳するためにいくつかの作業を行う必要があることを意味しますが、要素へのアクセスはまだ非常に効率的です。

また、dequeにプリペンドすると、既存のメンバーをスライドさせないため、この操作を配列よりも根本的に高速に実行できます。

前面に新しい要素を挿入するには、すでにコレクションにいくつの要素があっても、一定の時間がかかります。

これがデータ構造の力です。

ツールボックスにそれらがあれば、以前は手の届かない問題を解決するためにそれらを使用することができます。

適切なデータ構造に切り替えることは、すべての違いを生むことができます。

それは、使用できないほど遅いアプリを、使うのが楽しいレスポンシブな不思議に変えることができます。

もちろん、dequesは、ストレージの途中で操作を実行する方法についても賢明です。

たとえば、要素の範囲を削除する場合、dequeには後続の要素ではなく前の要素を移動して結果のギャップを閉じるオプションがあり、これにより移動する必要がある要素の数を減らすことができます。

これは、要素をプリペンディングするほど劇的な改善ではありませんが、ランダムに要素を削除すると、平均して2倍の速さになります。

だから、それはデクです。

では、注文されたセットを見てみましょう。

標準の既存のセットタイプは、すべての要素が一意であることを保証するコレクションです。

しかし、それは彼らの元の注文を保持しません。

実際、セット内の要素の順序は事実上ランダムです。

これは、同じセットの2つのインスタンスが、多くの場合、2つのまったく異なる順列でそれらをリストすることを意味します。

それにもかかわらず、同じ要素を含む2つのセットは等しいと見なされます。順序は重要ではありません。

これは、私たちが望むすべてが独自性を保証することである場合に素晴らしいことですが、時には要素がどのように順序付けられているかをコントロールしたいこともあります。

たとえば、ToDoリストアプリを書いている場合は、各項目が一度だけリストされていることを確認したい場合がありますが、ユーザーが設定した特定の順序で保持する必要があります。

だから、それは注文されたセットが行うことです。

私たちの視点に応じて、その要素を一意に保つ配列のように機能するか、メンバーに確立した順序を保持するセットとして見ることができます。

配列やセットと同様に、順序付きセットも配列リテラルで表現できます。

ただし、セットとは異なり、要素の順序は保存されることが保証されています。

順序も重要です。2つの順序付けられたセットは、同じメンバーだけでなく、同じ順序でなければならない場合、比較は等しくなります。

2つの順序付きセットに任意の順序で同じ要素が含まれているかどうかを知る必要がある場合は、特別な順序付けられていないビューでそれらを比較することができます。

この軽量ビューは要素の順序を無視するので、より従来のセットのようなインターフェイスを提供します。

しかし、デフォルトでは、順序付けられたセットは配列の仕組みに似ています。

これは、順序付きセットが整数オフセットインデックスを持つランダムアクセスコレクションであるという事実によって強化されています。

配列やdequeのように、整数添字を使用してアイテムにアクセスできます。

セットから予想されるように、要素を追加および削除することもできますが、これらの操作は位置を考慮する必要があります。

たとえば、まだメンバーでない場合は、セットの末尾に新しい要素を追加する追加操作があります。

その戻り値は、要素を追加する必要があるかどうかを示し、アイテムのインデックスも報告します。

また、指定された場所に新しい要素を置く挿入操作もあります。

この場合、文字Bはすでに存在しているため、操作は単に既存のメンバーのインデックスを返します。

要素を削除すると、順序付けられたセットに穴が残り、配列のように、残りのメンバーを移動して埋める必要があります。

注文されたセットは、要素を一意に保つ必要があるため、任意のアイテムの交換をサポートすることはできません。

これは、配列とは異なり、MutableCollectionまたはRangeReplaceableCollectionプロトコルに準拠できないことを意味します。

ただし、ソートやシャッフルなどの標準的な並べ替え操作をサポートしています。

順序付きセットはまた、Order-serving方法で、SetAlgebraプロトコルからのすべての高レベルセット操作を実装します。

たとえば、ユニオンを形成すると、2番目のセットに表示される順序で、不足している要素が追加されます。

セットを引くと、残りの要素は元の順序で保持されます。

順序付けられたセットはほとんどのSetAlgebra演算を実装していますが、要素の順序が重要でなければならないため、そのプロトコルに正式に準拠することはできません。

しかし、彼らの順序のないビューは、順序に鈍感な平等の概念を持っています。

したがって、それはSetAlgebraに準拠することができます。

これを使用して、SetAlgebra値を必要とする関数にOrderedSet値を渡すことができます。

ボンネットの下を見ると、標準の順序付けられていないセットタイプは、ランダムにシードされたユニバーサルハッシュ関数を使用して、その要素をフラットなハッシュテーブルに直接格納します。

これは、要素に優れたルックアップパフォーマンスを提供しますが、元の順序を破棄します。

任意のユーザー指定の要素の順序付けをサポートするために、順序付きセットは代わりにその要素を通常の配列インスタンスに格納します。

順序付きセットは、同じ高速で安全なハッシュテーブルの実装を使用しますが、この場合、テーブルは整数インデックスをストレージ配列に格納するだけで済みます。

これらの整数の範囲はハッシュテーブルのサイズによってバインドされているため、整数値をできるだけ少ないビットにパックすることでテーブルを圧縮できます。

これにより、ほとんどの操作で競争力のあるパフォーマンスを維持しながら、通常のセットと比較してかなりの量のメモリを節約できる場合があります。

ルックアップのパフォーマンスは標準セットに匹敵します。

ランダムなメンバーを見つけるには、コレクションのサイズに関係なく、ほぼ一定の時間がかかります。

配列は各要素を苦労して見る必要があり、コレクションが成長するにつれて時間がかかります。

順序付きセットに新しい要素を追加すると、標準セットに要素を挿入することとほぼ同じくらい実行されます。

これはまだ新しい項目をハッシュする必要があり、要素がすでに存在するかどうかのチェックも含まれているので、これは単純な配列に要素を直接追加するよりもはるかに複雑な操作です。

しかし、コレクションがどんなに大きくなろうとも、これらにはまだ一定の時間がかかります。

ただし、OrderedSetは既存の要素をすばやく検索して新しい要素を追加できますが、セットの前面または中央にアイテムを削除または挿入することを効率的に実装することはできません。

配列と同様に、これらの操作はストレージ配列内の要素をスライドさせる必要がありますが、ハッシュテーブルで後続のインデックスに番号を付け直す必要があります。

これは、削除と挿入が直線的な複雑さを持つ操作に変わり、通常のセットよりも遅くなることを意味します。

常にトレードオフがあります!

しかし、これらのデータ構造がどのように機能するかに慣れると、満たす必要がある要件と最適化することが重要な操作に基づいて、問題を解決するための適切なものを自信を持って選択できるようになります。

適切なデータ構造を選択すると、アルゴリズムの改善につながり、数百倍、さらには数千倍の高速なコードが得られます。

間違ったものを選択すると、その逆の可能性があります。

だから、最終的には素晴らしいアプリと幸せなユーザーを生み出すので、これらについて学ぶことは有用だと思います。

この新しいOrderedSetタイプは、Foundationの既存のNSOrderedSetタイプの純粋なSwiftバリアントです。

ただし、OrderedSetはパッケージに実装されているため、NSOrderedSetとブリッジしません。

これは、既存のObjective-C APIが新しいタイプを使用するために自動的にインポートされないことを意味します。

これらは別々のものです。

コレクションパッケージによって提供される3番目のデータ構造は、標準辞書タイプの順序付けられたアナログです。

標準辞書と同様に、これはキーと値のペアのシーケンスで、キーを添字として使用して、対応する値をすばやく検索できます。

通常の辞書とは異なり、キーと値のペアの順序は明確に定義されています。

デフォルトでは、キーが最初に挿入された順序に従います。

新しい要素を追加するには、新しいキーに値を割り当てることができます。

既存のキーにnilを割り当てることで、要素を削除できます。

これらの操作を通して、順序付けられた辞書は明確に定義された順序で内容を維持します。

順序付き辞書は配列のような整数インデックスを使用しますが、これは興味深い問題をもたらします。

辞書の例では、インデックス付き添字操作はキー添字と競合します。

ゼロで添字するとき、キーゼロの値にアクセスすることを意味しますか、それともオフセットゼロでキーと値のペアを取得することを意味しますか?

キーベースの添字は辞書型の主な操作であると思うので、このあいまいさを防ぐために、順序付けられた辞書を添字することは、常にキーイング添字を意味します。

OrderedDictionaryは、インデックス付き添字操作をまったく提供していません。

これは、コレクションプロトコルにはそのような添字が必要なため、OrderedDictionaryはコレクションにできないことを意味します。

したがって、OrderedDictionaryはシーケンスプロトコルにのみ準拠します。

ただし、コレクションの適合性が望ましい場合、OrderedDictionaryは特別な要素ビューを提供します。

要素は、キーと値のペアを返すインデックス付き添字を提供するランダムアクセスコレクションです。

基礎となる実装を見ると、通常の辞書タイプはそれぞれキーと値を格納するために2つの別々のハッシュテーブルを使用しますが、順序付けられた辞書は代わりに単一の圧縮ハッシュテーブルと2つの並列配列を使用します。

これにより、注文されたセットよりもさらに多くのスペースを節約できます。

したがって、これらはコレクションパッケージで利用可能な3つの新しいデータ構造です。

これらの構造を使用することで、アプリのパフォーマンスを向上させたり、メモリ使用量を減らしたり、同様に重要なことに、セット内の要素の順序を保持するなど、標準タイプで簡単に満たすことができなかった制約を表現することができます。

これらの新しいタイプはすべていくつかのシーケンスとコレクションプロトコルに準拠しているため、標準ライブラリが提供するアルゴリズムや、カイルが以前に示した新しいアルゴリズムパッケージとも相互運用します。

スウィフトコレクションとスウィフトアルゴリズムは、増え続けるオープンソースパッケージのリストの新しいメンバーの2つにすぎません。

Swiftライブラリエコシステムの未来は、新しいプラットフォームや新しいドメインに参入するにつれて、今形成されています。

そして、オープンソースパッケージをますます活用するにつれて、これは目に見えるように行われています。

これらのパッケージはまだ柔軟でありながら、意図的に早期にリリースしており、GitHubでのコミュニティの取り組みとして開発しています。

だから、それらを試してみてください。

問題を提出してください。プルリクエストを開きます。

かつてないほど良い時期であり、関与して影響を与えることがかつてないほど簡単になりました。

私たちと同じように、これらの新しいSwiftパッケージに興奮していることを願っています。

あなたがこれらで何を作るかを見るのが待ちきれません!

見てくれてありがとう、そして会議の残りを楽しんでください!

♪