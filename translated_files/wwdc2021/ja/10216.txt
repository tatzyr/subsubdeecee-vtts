10216

♪ベース音楽の演奏♪

♪

メガナ・グプタ:こんにちは、私の名前はメガナです。

今日は、スウィフトのARCについて話します。

Swiftは、構造体や列挙型などの強力な値タイプを提供します。

参照型に付属する意図しない共有の危険性を避けるために、可能であれば値型を使用することを好むべきです。

クラスはSwiftの参照型であり、それらを使用することにした場合、Swiftは自動参照カウントまたはARCを介してメモリを管理します。

効果的なSwiftを書くためには、ARCがどのように機能するかを理解することが重要です。

このセッションでは、まさにそれを行います。

Swiftでのオブジェクトの寿命とARCのレビューから始めます。

次に、観測可能なオブジェクトの寿命について説明します。

オブジェクトの寿命を観察可能にする言語機能、観察されたオブジェクトの寿命に頼ることの結果、およびそれらを修正するためのいくつかの安全なテクニックを詳細に説明します。

始めましょう。

Swiftでのオブジェクトの寿命は、初期化時に始まり、最後の使用時に終了します。

ARCは、ライフタイム終了後にオブジェクトの割り当てを解除することで、メモリを自動的に管理します。

参照数を追跡することで、オブジェクトの寿命を決定します。

ARCは、主に保持およびリリース操作を挿入するSwiftコンパイラによって駆動されます。

実行時に、参照数をインクリメントし、リリースは減少します。

参照数がゼロになると、オブジェクトは割り当て解除されます。

例でどのように機能するか見てみましょう。

旅行アプリを作りたいと想像してみてください。

旅行者を表すために、名前とオプションの目的地プロパティを持つクラスを書きましょう。

Test() 関数では、まず Traveler オブジェクトが作成され、次にその参照がコピーされ、最後に宛先が更新されます。

Travelerオブジェクトのメモリを自動的に管理するために、Swiftコンパイラは参照開始時に保持操作を挿入し、参照の最後の使用後にリリース操作を挿入します。

traveler1はTravelerオブジェクトへの最初の参照であり、その最後の使用はコピーです。

ここで、Swiftコンパイラは、traveler1参照の最後の使用直後にリリース操作を挿入します。

初期化は参照カウントを1に設定するため、参照開始時に保持操作を挿入しません。

traveler2はTravelerオブジェクトへの別の参照であり、その最後の使用は目的地の更新です。

ここで、Swiftコンパイラは、参照が開始されたときに保持操作を挿入し、参照の最後の使用直後にリリース操作を挿入します。

コードをステップスルーして、実行時に何が起こるか見てみましょう。

まず、トラベラーオブジェクトがヒープ上に作成され、1の参照カウントで初期化されます。

次に、新しい参照の準備で、保持操作が実行され、参照カウントが2に増加します。

現在、トラベラー2はトラベラーオブジェクトへの参照でもあります。

Traveler1参照の最後の使用後、リリース操作が実行され、参照カウントが1に減少します。

その後、トラベラーオブジェクトの目的地がビッグサーに更新されます。

それがtraveler2参照の最後の使用だったので、リリース操作が実行され、参照カウントがゼロに減少します。

参照カウントがゼロになると、オブジェクトの割り当てを解除できます。

Swiftのオブジェクトの有効期間は使用ベースです。

オブジェクトの保証された最小寿命は、初期化時に始まり、最後の使用時に終了します。

これは、オブジェクトの寿命が閉じ中括弧で終わることが保証されているC++のような言語とは異なります。

この例では、最後の使用直後にオブジェクトが割り当て解除されたことがわかりました。

しかし、実際には、オブジェクトの寿命は、Swiftコンパイラによって挿入された保持操作とリリース操作によって決定されます。

そして、キックインするARCの最適化に応じて、観察されたオブジェクトの寿命は、オブジェクトの最後の使用を超えて終了し、保証された最小値と異なる場合があります。

そのような場合、オブジェクトは最後の使用を超えてプログラムポイントで割り当てられます。

ほとんどの場合、オブジェクトの正確な寿命は実際には重要ではありません。

しかし、弱い未所有の参照やデ初期化の副作用などの言語機能では、オブジェクトの寿命を観察することが可能です。

また、保証されたオブジェクトの寿命ではなく、観察されたオブジェクトの寿命に依存するプログラムがある場合、将来的に問題が発生する可能性があります。

観測された物体の寿命に頼ることは、今日ではうまくいくかもしれませんが、それは単なる偶然です。

観察されたオブジェクトの寿命は、Swiftコンパイラの緊急のプロパティであり、実装の詳細が変更されると変更される可能性があります。

このようなバグは、開発中に発見されず、長期間隠されている可能性がありますが、改善されたARC最適化または以前に制限されたARC最適化を可能にする無関係なソース変更によるコンパイラアップデートによってのみ発見されます。

オブジェクトの寿命を観測可能にする言語機能について説明し、観察されたオブジェクトの寿命のみに頼った場合に何が起こるか、およびそれらを修正するためのいくつかの安全なテクニックについて説明します。

強い参照であるデフォルトの参照とは異なり、弱い参照と未所有の参照は参照カウントに参加せず、このため、参照サイクルを破るために一般的に使用されます。

彼らの詳細に入る前に、参照サイクルが何であるかを見てみましょう。

これは私たちの旅行アプリの拡張機能です。

私たちは今、オプションのポイントシステムを導入したいと考えています。

旅行者はアカウントを持ち、その中にポイントを貯めることができます。

これを表すために、ポイントプロパティを持つ新しいアカウントクラスがあります。

アカウントクラスはトラベラークラスを指し、トラベラークラスはアカウントクラスに戻ります。

test()関数では、TravelerとAccountオブジェクトを作成し、traveler参照を介してprintSummary()関数を呼び出します。

コードをステップスルーして、ARCがどうなるか見てみましょう。

まず、トラベラーオブジェクトは、参照カウントが1のヒープに作成されます。

次に、アカウントオブジェクトがヒープに作成され、参照カウントが1になります。

アカウントオブジェクトはトラベラーオブジェクトを参照するため、トラベラーオブジェクトの参照数は2にインクリメントされます。

これで、トラベラーオブジェクトがアカウントオブジェクトを参照し始めるので、アカウントオブジェクトの参照数も2に増加します。

これはアカウント参照の最後の使用です。

この後、アカウント参照は消え、アカウントオブジェクトの参照カウントは1に減少します。

次に、printSummary() 関数が呼び出されて名前とポイントが印刷されます。

これはトラベラーリファレンスの最後の使用です。

この後、トラベラー参照は消え、トラベラーオブジェクトの参照数は1に減少します。

オブジェクトを到達可能にするすべての参照が消えた後でも、オブジェクトの参照数は1つのままです。

これは参照サイクルのためです。

その結果、オブジェクトは決して割り当て解除されないため、メモリリークが発生します。

弱い参照または未所有の参照で参照サイクルを中断することができます。

参照カウントに参加しないため、弱い参照または所有されていない参照が使用されている間に、参照されたオブジェクトが割り当て解除される可能性があります。

これが発生すると、Swiftランタイムは安全に弱い参照へのアクセスをnilとして、未所有の参照へのアクセスをトラップとして回します。

参照サイクルに参加している参照は、参照サイクルを中断するために、弱いまたは無所有としてマークすることができます。

アプリケーションによって異なります。

この例では、アカウントクラスの旅行者参照を弱いものとしてマークしましょう。

弱い参照は参照カウントに参加しないため、トラベラーオブジェクトを最後に使用した後、その参照数はゼロに低下します。

トラベラーオブジェクトの参照数がゼロになると、割り当てを解除できます。

Travelerオブジェクトが消えると、Accountオブジェクトへの参照は消え、参照カウントはゼロになります。

これで、アカウントオブジェクトの割り当てを解除できます。

この例では、弱い参照を使用して、参照サイクルを中断するだけです。

保証されたオブジェクトの寿命が終了している間に、弱い参照を使用してオブジェクトにアクセスし、オブジェクトが利用可能になるために観察されたオブジェクトの寿命に依存している場合、観察されたオブジェクトの寿命が無関係な理由で変更されると、将来的にバグが発生する可能性があります。

例を見てみましょう。

ここで、printSummary() 関数は Traveler クラスから Account クラスに移動されます。

そして、test()関数は、アカウント参照を介してprintSummary()関数を呼び出すようになりました。

printSummary() 関数が呼び出されると、正確にはどうなりますか?

今日は旅行者の名前とポイントを印刷するかもしれませんが、これは偶然に過ぎません。

これは、Travelerオブジェクトの最後の使用がprintSummary（）関数の呼び出し前であるためです。

この後、コンパイラが最後の使用直後にリリースを挿入した場合、Travelerオブジェクトの参照カウントはゼロに低下する可能性があります。

参照数がゼロになった場合、弱い参照を介したTravelerオブジェクトへのアクセスはnilになり、Travelerオブジェクトは割り当て解除される可能性があります。

したがって、printSummary（）関数が呼び出されると、弱いトラベラー参照の強制アンラップがトラップされ、クラッシュが発生します。

フォースアンラップがここでのクラッシュの理由であり、オプションのバインディングがそれを防いだ可能性があるかどうか疑問に思うかもしれません。

オプションのバインディングは、実際には問題を悪化させます。

明らかなクラッシュがなければ、無関係な理由で観察されたオブジェクトの寿命が変更されたときに気づかれないかもしれないサイレントバグを作成します。

弱い参照や未所有の参照を安全に処理するためのさまざまな技術があり、それぞれが先行実装コストと継続的なメンテナンスコストの程度が異なります。

私たちの例でそれらを一つずつ探りましょう。

Swiftは、オブジェクトの寿命を明示的に延長できるExtendedLifetime()ユーティリティを提供します。

withExtendedLifetime() を使用すると、printSummary() 関数が呼び出されている間に、Traveler オブジェクトの寿命を安全に延長することができ、潜在的なバグを防ぐことができます。

既存のスコープの最後にwithExtendedLifetime()への空の呼び出しを配置することで、同じ効果を達成できます。

より複雑なケースでは、deferを使用してオブジェクトの寿命を現在のスコープの終わりまで延長するようにコンパイラに依頼することができます。

withExtendedLifetime()は、オブジェクトの寿命のバグから抜け出す簡単な方法のように見えるかもしれません。

しかし、このテクニックは壊れやすく、正しさの責任をあなたに委ねます。

このアプローチでは、弱い参照がバグを引き起こす可能性があるたびにwithExtendedLifetime()が使用されていることを確認する必要があります。

制御されていない場合、withExtendedLifetime()はコードベース全体に忍び寄る可能性があり、メンテナンスコストが増加します。

より良いAPIでクラスを再設計することは、はるかに原則的なアプローチです。

オブジェクトへのアクセスを強力な参照のみに制限できる場合、オブジェクトの寿命の驚きを防ぐことができます。

ここで、printSummary() 関数は Traveler クラスに戻り、Account クラスの弱い参照は非表示になります。

テストは、強力な参照を介してprintSummary（）関数を呼び出すことを余儀なくされ、潜在的なバグを排除します。

パフォーマンスコストを運ぶことに加えて、クラス設計に注意しないと、弱い参照や未所有の参照がバグを暴露する可能性があります。

一時停止して考えることが重要です、なぜ弱くて所有されていない参照が必要なのですか?

それらは参照サイクルを破るためだけに使用されますか?

そもそも参照サイクルの作成を避ける場合はどうなりますか?

参照サイクルは、アルゴリズムを再考し、循環クラス関係をツリー構造に変換することで、しばしば回避できます。

この例では、トラベラークラスはアカウントクラスを参照する必要があります。

アカウントクラスがトラベラークラスを参照する必要はない。

アカウントクラスは、旅行者の個人情報へのアクセスのみが必要です。

旅行者の個人情報をPersonalInfoと呼ばれる新しいクラスに移動することができます。

トラベラークラスとアカウントクラスの両方がPersonalInfoクラスを参照でき、サイクルを回避できます。

弱い参照や未所有の参照の必要性を回避するには、追加の実装コストがかかるかもしれませんが、これはすべての潜在的なオブジェクトライフタイムバグを排除する明確な方法です。

オブジェクトの寿命を観察可能にするもう1つの言語機能は、デ初期化の副作用です。

デイニタライザーは割り当て解除前に実行され、その副作用は外部プログラム効果によって観察できます。

外部プログラム効果でデイニタライザーの副作用をシーケンスするためにコードを書くと、無関係な理由で観察されたオブジェクトの寿命が変更された場合にのみ発見される隠れたバグにつながる可能性があります。

そのようなバグがどのように出てくるかに入る前に、デイニタライザーが何であるかを見てみましょう。

これは最初の例の繰り返しで、今はデイニタライザーが付いています。

Deinitializerには、コンソールにメッセージを印刷するという世界的な副作用があります。

今日、「Done traveling」が印刷された後、デイニタライザーが実行される可能性があります。

しかし、Travelerオブジェクトの最後の使用は宛先の更新であるため、起動するARCの最適化に応じて、「Done traveling」が印刷される前にdeinitializerを実行できます。

この例では、デイニタライザーの副作用は観察可能でしたが、信頼されていませんでした。

初期化解除の副作用が外部のプログラム効果によって依存される、より複雑な例を見てみましょう。

現在、トラベラークラスに旅行指標を紹介します。

目的地が更新されるたびに、TravelMetricsクラスに記録されます。

最終的に、トラベラーオブジェクトを初期化解除すると、メトリクスはグローバルレコードに公開されます。

公開された指標は、旅行者の匿名ID、検索された目的地の数、および計算された旅行利息カテゴリです。

Test() 関数では、まず Traveler オブジェクトが作成され、次に travelMetrics への参照が Traveler オブジェクトからコピーされます。

旅行者の目的地は、TravelMetricsにBig Surを記録するBig Surに更新されます。

旅行者の目的地は、TravelMetricsにカタリナを記録するカタリナに更新されます。

次に、旅行の関心カテゴリは、記録された目的地を見て計算されます。

今日、デイニタライザーは旅行の関心を計算した後に実行され、関心のあるカテゴリをネイチャーとして公開する可能性があります。

しかし、トラベラーオブジェクトの最後の使用は、カタリナへの宛先の更新であり、その直後にデイニタライザーを実行できます。

旅行の関心を計算する前にデイニタライザーが実行されるため、nilが公開され、バグが発生します。

弱くて所有されていない参照と同様に、デ初期化剤の副作用を安全に処理するためのさまざまなテクニックがあります。

それらのそれぞれは、継続的なメンテナンスコストに対して、さまざまな程度の先行実装コストがあります。

それらを一つずつ見てみましょう。

withExtendedLifetime()を使用して、旅行利息カテゴリが計算されるまでTravelerオブジェクトの寿命を明示的に延長し、潜在的なバグを防ぐことができます。

前に説明したように、これはあなたに正しさの責任を移します。

このアプローチでは、初期化除去の副作用と外部プログラム効果の間に誤った相互作用の可能性があるたびにwithExtendedLifetimeが使用され、メンテナンスコストが増加することを確認する必要があります。

効果がすべて局所的である場合、デイニタライザーの副作用は観察できません。

内部クラスの詳細の可視性を制限してクラスAPIを再設計することで、オブジェクトのライフタイムのバグを防ぐことができます。

ここでは、TravelMetricsはプライベートとマークされ、外部アクセスから隠されています。

デイニタライザーは、最も関心のある旅行カテゴリを計算し、メトリクスを公開するようになりました。

これは機能しますが、より原則的なアプローチは、デイタライザーの副作用を完全に取り除くことです。

ここでは、デイニタライザーの代わりにデイタライザーが使用され、デイニタライザーは検証のみを実行します。

Deinitializerの副作用を取り除くことで、潜在的なオブジェクトの寿命のバグをすべて排除することができます。

ARC、弱い参照と未所有の参照、および初期化除去の副作用について学ぶために、教育旅行アプリの例を調べました。

驚くべき時期にバグを発見しないように、オブジェクトの寿命を観測可能にし、観察されたオブジェクトの寿命に対する潜在的に誤った依存を排除する言語機能を徹底的に理解することが重要です。

Xcode 13では、「Object Lifetimesの最適化」と呼ばれる新しい実験的なビルド設定がSwiftコンパイラで利用できます。

これにより、強力な寿命短縮ARC最適化が可能になります。

このビルド設定をオンにすると、最後の使用の直後にオブジェクトがはるかに一貫して割り当て解除され、観察されたオブジェクトの寿命が保証された最小値に近づきます。

これは、議論された例と同様に、隠されたオブジェクトの寿命のバグを公開する可能性があります。

このセッションで説明した安全なテクニックに従って、そのようなバグをすべて排除することができます。

あなたがこのセッションを楽しんだことを願っています。

見てくれてありがとう。

♪