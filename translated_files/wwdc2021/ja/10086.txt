10086

Nihar: こんにちは、「CloudKitの新機能」へようこそ。

私の名前はNihar Sharmaで、CloudKitチームのエンジニアで、同僚のQianが参加します。

まず、Swiftの並行性を利用するCloudKit APIへのいくつかの変更点を強調します。

その後、Qianはレコード上の暗号化されたフィールドの使用を案内します。

最後に、レコードゾーンを簡単に共有できる新機能を深く掘り下げます。

まず、CloudKitとSwiftの並行性があります。

ちょっとした背景として、CloudKitは、アプリケーションがiCloud上のデータベースにアクセスできるようにするフレームワークです。

これは、複数のCKDatabaseにアクセスできるCKContainerとしてAPIに公開されます。

各コンテナには、すべてのユーザーが潜在的にレコードを読み書きできる1つのパブリックデータベースがあります。

デバイスにiCloudアカウントがログインしている場合、アプリはそのユーザーのデータを含むプライベートデータベースにもアクセスできます。

また、アプリが共有をサポートしている場合、現在のiCloudユーザーに共有されたデータは、共有CKDatabaseでアプリで利用可能になります。

CloudKitに対してコードを書く場合、APIには2つの一般的な領域があります。

まず、CKContainerとCKDatabaseで利用可能な機能。

このAPIは、CloudKitの新規採用者に有用であり、参入障壁が低いことを目的としています。

利用可能なすべての設定を提供する代わりに、フレームワークは、ユーザーが対話しているUIアプリケーションに最も適したデフォルトの動作を選択します。

次は、NSOperationサブクラスのセットとして公開されるOperation APIです。

このAPIは、CKContainerまたはCKDatabase機能として利用できない多くの機能を提供します。

これには、サーバーへの単一の往復でアイテムのバッチを送受信し、サーバーから段階的にフェッチして大規模な結果セットをページングし、過去のある時点からサーバーからデータベースとレコードゾーンの変更を要求し、最後に異なる操作をグループ化することが含まれます。

これにより、それらをユニットとして記録することができ、運用にまたがるワークロードのサイズをシステムに通知することができます。

多くの開発者は、生産品質のコードを書くときに最終的にこのAPIを使用します。

新しいSwiftの並行性機能を利用して、CloudKitはいくつかの改善を行いました。

まず、CloudKit APIと一緒に新しいSwift async/await機能を使用する方法について説明します。

次に、アイテムごとと操作ごとのコールバックの違いを明確にするのに役立つ新しいAPIと、CloudKitがSwift.Resultタイプを利用して、それらのコールバックに対するパラメータの役割を明確にする方法について説明します。

そして最後に、以前は操作APIを介してのみ利用可能だった機能と構成可能性の一部をもたらすのに役立つ、コンテナとデータベース機能の機能強化について説明します。

CloudKit APIは、コンテナとデータベース上の機能に非同期バリアントを導入しています。

非同期関数を使用して、並行性を扱うコードを改善できます。

エラー処理をより自然にするのに役立ち、コードの視覚的な制御フローを簡素化します。

非同期関数の詳細については、「Swiftで非同期/待機する」セッションを参照してください。

例を見てみましょう。例を見てみましょう。

このスニペットは、PrivateDatabaseのコードサンプルから取得されています。

これは、Appleが最近GitHubに投稿したいくつかのCloudKit固有のコードサンプルの1つであり、それらが利用可能です。

この特定の機能は、サーバーからレコードを削除し、完了したら発信者に通知したいと考えています。

多くのオプションと条件付きアンラッピングが散りばめられていることに注意してください。

そして、この機能を最初に理解しようとすると、制御フローはすぐには明らかではありません。

さて、これをCloudKitの非同期機能を使用するように更新されたコードと比較してみましょう。

ここでは、オプションとアンラッピングが排除され、制御フローは直線的で従うのが簡単です。

GitHubリポジトリ上の各コードサンプルには、Swift並行性を使用するようにコードを同様にリファクタリングする方法を示すアップデートがあることを嬉しく思います。

項目ごとのコールバックについて話しましょう。

例として、理想的には4つのCKRecordペイロードを取り戻すために、4つのCKRecord.IDをサーバーに送信するCKFetchRecordsOperationです。

この操作は、3つの異なる方法のいずれかを実行できます。

最初のケースでは、操作は成功します。

エラーはなく、レコードはサーバーから正常に取得されます。

2番目の可能性は、操作全体のエラーが発生することです。

これは、操作全体が失敗するエラーです。

例として、デバイスにはネットワーク接続がない可能性があります。

その場合、操作全体がnetworkUnavailableエラーコードで失敗します。

これが3番目の選択肢です。

このシナリオでは、操作が正常にサーバーにラウンドトリッピングされました。

サーバーは、要求された4番目のレコードが存在しないことを示すエラーとともに、要求されたCKRecordsの3つを正常に返しました。

この例では、アイテムごとのエラーはunknownItemであり、partialFailureと呼ばれる操作ごとのエラーにバンドルされます。

では、これはコードでどのように処理されますか?

上部に、CKFetchRecordsOperationは、下部にこれらのそれぞれのサンプル実装とともに、perRecordCompletionBlockとper-operation完了ブロックを宣言します。

これら2つのコールバックの重複に注意してください。

以前から不足しているレコードの例から、コードはアイテムごとのエラーを2回期待しています。1回はアイテムごとのコールバックのトップレベルのunknownItemエラーとして、再び操作ごとのコールバックの部分的なFailureエラー内にバンドルされています。

同様に、正常にフェッチされたレコードの2つの場所でアイテムごとの成功も期待しています。最初は、アイテムごとのコールバックのトップレベルのパラメータとして、もう一度、操作ごとのコールバックで成功した結果のrecordsByRecordID辞書にラップされています。

Swift.Resultタイプを活用することで、CloudKitはこれらのコールバックの両方を置き換えてAPIをより明確にしました。

新しい結果ベースのコールバックにおけるブロックパラメータの分離の最上位に注目してください。

perRecordResultBlockには、CloudKitがコールバックしているアイテムを識別するIDがあります。

そして、それはアイテムごとの結果を持っています。

結果が強く入力されるようになったので、正常にフェッチされたCKRecordペイロード、またはアイテムごとのエラーのいずれかを取得していることを知っています。

同様に、操作スコープの完了ブロックも、項目ごとの結果ブロックによってすでに報告された成功または失敗を複製しなくなった操作範囲の結果ブロックに更新されました。

そのため、CloudKitは正式に懸念を分離しました。

1つのブロックはアイテムごとのレポートにのみ使用され、もう1つのブロックは操作ごとのレポートにのみ使用されます。

不足しているレコードの例に戻ると、期待されるのは、正常に取得されたCKRecordペイロードを持つアイテムごとの結果ブロックの3つの呼び出し、unknownItemエラーを持つアイテムごとの結果ブロックの1つの呼び出し、および操作全体が成功したため、エラーのない操作ごとの結果ブロックの1つの呼び出しです。

CloudKitの新しい改善点の1つは、アイテムごとと操作ごとの別々のコールバックをどこでも表示することです。

以前は、強調表示された操作にのみ、アイテムごとのエラーが表面化するアイテムごとのコールバックがありました。

すべてのCKOperationsが、必要に応じてアイテムごとのエラーをパスバックするアイテムごとのコールバックを公開したことを発表できることを嬉しく思います。

それでは、コンテナとデータベースのAPIに対して行ったいくつかの機能強化と拡張を見てみましょう。

この機能強化は、CKContainerとCKDatabaseの新機能の形をとります。

これらの新しい機能により、CKOperation APIの大部分がCKContainerとCKDatabaseの関数として利用可能になります。

重要なのは、これは操作APIの1対1のマッピングではないということです。

代わりに、デフォルトのパラメータとSwift.Resultタイプを活用して、親しみやすく、強力で、async/awaitで動作するAPIを作成しました。

つまり、各新しい関数は2回公開されます。1回はcompletionHandlerを取り、再び非同期関数として。

この強化されたAPIにより、コンテナとデータベースの機能は、複数のアイテムのバッチ処理、大規模なデータセットによるページング、変更の取得など、Operation APIの機能の一部をサポートするようになりました。

また、ロギングのために関数呼び出しをグループ化し、結合されたワークロードサイズについてシステムに通知することもできます。

タイムアウトを設定するなど、関数呼び出しも設定できるようになりました。

では、これはどのように機能しますか?

ここでもう一度、先ほど見たGitHub PrivateDatabaseのコードサンプルで、非同期関数を使用してレコードを削除します。

アイテムのバッチ処理を利用するために、このコードをどのように更新できるか見てみましょう。

この関数の動作を変更して、データベース上の拡張関数APIを利用して、2つのレコードをアトミックに削除します。

懸念の分離に注目してください。

強調表示された領域は、機能範囲で動作します。

彼らは関数をキックオフし、スローされた関数スコープのエラーをキャッチします。

そして、機能が正常に完了すると、この強調表示された領域は、項目ごとの成功または失敗を検査します。

GitHubのコードサンプルリポジトリには、これらの機能のそれぞれをカバーする同様の例があり、このセッションのメモにはそれらのリポジトリへのリンクが含まれます。

私たちは、あなたがそれらが役に立つことを願っています。

そして、それで、私はそれをQianに渡して、暗号化されたフィールドを案内したいと思います。

ありがとう、ニハール。

私はQianです。ユーザーのデータプライバシーを非常に簡単に保護できるCloudKitの新機能について話します。

これを行うには、まずCloudKitがユーザーのデータを保護する方法の概要を説明し、次に新しいデータ暗号化機能を紹介し、最後に、ユーザーのアカウントの暗号化の前提条件を紹介します。

Appleでは、プライバシーは、すべての製品に組み込むコアバリューの1つです。

多くのAppleアプリやサービスを強化するフレームワークとして、CloudKitはプライバシー技術を常に革新し、CloudKitと保存および同期されたデータの保護を提供してきました。

まず、CloudKitがユーザーのデータをどのように保護しているかを確認しましょう。

CloudKitのアプローチには、アカウントベースの保護と暗号化保護の2つの主要なデータ保護方法が含まれています。

CloudKitに保存されているデータは、デフォルトでアカウントベースの認証によって保護されています。

これには、CloudKitが支援するアプリとApple CloudKitが支援するすべてのアプリが含まれます。

ストレージと検索時に、CloudKitは安全なトークンを使用して、許可されたユーザーのみがデータにアクセスできるように強制し、Appleや第三者はアクセスできません。

念のため、プライベートデータベースと共有データベースのデータのみがアカウントベースの保護の対象となります。

これらのデータベースでは、データは特定のiCloudアカウントに属しているか、共有されており、共有データへのアクセスには認証が必要です。

ただし、公開データベースでは、すべてのユーザーがデータにアクセスできるため、アカウントベースのデータ保護はデフォルトでは適用されません。

さて、他のデータ保護技術である暗号保護に移ります。

CloudKitは、Appleが所有するアプリやサービスに保存されている機密データ、およびCKAssetの形で保存されているすべてのユーザーのデータの暗号化保護を提供します。

これらのデータは、保存のためにCloudKitサーバーに送信される前にローカルで前処理および暗号化され、取得時にローカルで復号化されます。

この暗号化機能は、デバイスにサインインしたiCloudアカウントに属するiCloudキーチェーンに保存されているキーマテリアルを使用します。

また、CloudKitの共有機能と互換性があり、CKShareのユーザーのみが関連する暗号化されたフィールドを復号化できるようにします。

暗号保護は、アカウントベースの保護の上に別のレイヤーを追加します。

なぜなら、権限のない当事者が何らかの形で承認をバイパスしたとしても、取得したデータを復号化できないからです。

暗号保護は、ユーザーにとって機密またはプライベートなデータに使用する必要があります。

Apple内の多くのCloudKitが支援するアプリは、写真とメモを2つの例として、この機能を利用しています。

これまで、ユーザーの非資産データに対するCloudKitの保護は、デフォルトでアカウントベースの保護を提供します。

CloudKitは現在、すべてのキーの導出、管理、および暗号化/復号化プロセスからあなたを救うことに加えて、暗号化保護を提供しています。これは、これまで以上に強力なプライバシーの約束でCloudKitに裏打ちされたアプリを構築するのに役立ちます。

それを行うのに役立つ新しいAPIをチェックしてみましょう。

暗号化のためにCKRecordsの新しいプロパティencryptedValuesに任意のキー値のペアを追加し、同じ正確なプロパティを追加して、復号化された元の値を取り戻すことができます。

encryptedValues APIを使用して、CloudKitサーバーを介して暗号化されたデータを同期する方法について説明します。

ここには、2つのデバイスと1つのCloudKitサーバーがあります。

encryptedValuesキー値ペアを設定すると、CloudKitはCKModifyRecordsOperationのローカルレコード値をサーバーに自動的に暗号化します。

別のデバイスでは、サーバーからレコードを取得した後、同じAPIを呼び出すことができ、CloudKitは自動的にキー値のペアをアンラップします。

このプロセスを達成するには、最低限のコードの変更が必要です。

最初のデバイスでは、encryptedValues APIを使用して、レコードにキー値のペアを設定できます。

この場合、キーは「encryptedStringField」で、値は文字列オブジェクトです。

その後、CKModifyRecordsOperationを呼び出すと、新しいレコードがサーバーに保存されます。

2番目のデバイスでは、CKFetchRecordsOperationを呼び出して暗号化されたレコードを取得し、同じencryptedValuesプロパティを使用することで、文字列を取り戻すことができます。

それでおそれ。

1つのシンプルなプロパティは、すべての暗号化および復号化プロセスを処理します。

また、CKReference以外のほぼすべてのCKRecord値タイプを暗号化できます。

前述したように、CKAssetフィールドはすでにデフォルトで暗号化を採用しているため、encryptedValueとして設定できないことに注意してください。

通常のフィールドと同様に、CloudKitデータベーススキーマに行くことで、暗号化されたフィールドを視覚化できます。

CloudKitコンソールセッション「Meet CloudKit Console」があり、コンソールに加えられた他の変更が表示され、お気軽にチェックしてください。

コンソールでは、すべての暗号化されたフィールドがレコード値データ型のドロップダウンに表示されます。

「暗号化されたダブル」、「暗号化されたタイムスタンプ」などの接頭辞「暗号化」があり、暗号化されていないものと区別するのに役立ちます。

コードを変更することなく、CloudKitコンソールを通じて暗号化されたフィールドを直接管理することもできます。

たとえば、開発データベーススキーマの新しいレコードタイプに新しい暗号化フィールドを追加できます。

暗号化を含む操作のアカウントの前提条件に進みます。

プライベートデータベースや共有データベースの他の操作と同様に、有効なログインアカウントが必要です。

CKContainer accountStatus(completionHandler:)を呼び出して、初期化ロジックで現在のアカウントのステータスを確認する必要があります。

リマインダーとして、ステータスはプライベートデータベースと共有データベースでの操作に「利用可能」である必要があります。

他の州ではエラーが発生します。「CKErrorNotAuthenticated」は、アカウントがログインしているが準備ができていないことを示すために今年導入された新しい状態を含む「一時的に利用不可」であり、設定アプリで資格情報を確認するようにユーザーに指示することができます。

ユーザーのアカウントが「利用可能」状態ではない場合は、アカウントが変更されるたびに投稿されるCKAccountChanged通知を聞いて、状態の準備ができたときに通知を受ける必要があります。

CloudKitによるデータの暗号化について知っておくべきことはそれだけです。

ユーザーのデータを保護し、独自のカスタムソリューションを実装することからすべての時間とエネルギーを節約します。

さて、私の素晴らしい同僚Niharに戻って、ゾーン共有について話します。

ありがとう、チアン！CloudKitの共有について話しましょう。

CloudKitは、すべてのユーザーのデバイスにユーザーデータを保存および同期するのに役立つ、安全でプライバシーに配慮したiCloudデータベースです。

iOS 10とmacOS Sierraは、他のiCloudユーザーと安全にデータを共有する方法であるCloudKit共有を導入しました。

共有の新機能に飛び込む前に、今日のCloudKit共有がどのように機能するかを詳しく見てみましょう。

リマインダーとして、CloudKitの共有は、共有されるデータを誰と共有しているか、それらの共有参加者がどのような許可を持っているかなど、共有関連の詳細から分離するCKShareオブジェクトの作成によって開始されます。

舞台裏では、CloudKitは、すべてのリクエストにアカウントベースの認証を要求することに加えて、参加者の共有データへの暗号アクセスを確立します。

さて、アプリに共有サポートを追加するには、主に2つの方法があります。

iOSではUICloudSharingController、macOSではNSSharingServiceを使用して、共有管理にシステムが提供するUIを使用して、すぐに始めることができます。

または、これらのフレームワーク操作を使用して、ユーザーが共有設定と対話できるように、独自のカスタムUIを構築することもできます。

先に述べたように、CKSharesは共有されているものと誰と共有されているかを分離します。

今日は、その方程式の前半に焦点を当て、より具体的には、データをモデル化できるいくつかの異なる方法と、それがCloudKit共有APIを活用する方法にどのように影響するかを見ていきます。

既存のCloudKit共有機能を利用する例から始めましょう。

iCloud Driveのフォルダ共有は、CloudKitの上に構築されています。

自分のアプリで似たようなものを構築する方法を見てみましょう。 あなた自身のアプリで似たようなものを構築しましょう。

したがって、ここでのデータモデルはファイルシステム階層を表しているため、「ファイル」と「フォルダ」タイプのレコードから始めて、その中に含まれるすべてのレコード、ファイル、またはフォルダと一緒に任意のフォルダレコードを簡単に共有できるようにしたいと考えています。

CloudKitでこの階層関係を表現し、共有に活用する方法は、子から親レコードへのCKRecord.parent参照を使用することです。

これにより、CloudKitは結果の階層を単一の共有可能なユニットとして扱うため、先に進んでこれらの参照をここに追加したいと思うでしょう。

これは非常に重要であり、CloudKitで親参照を特別なものにしています。

共有をサポートする予定がない場合は、親参照を使用する必要はなく、独自のスキーマ内のプレーンなCKReferenceフィールドで十分であることに注意してください。

その設定により、フォルダレコードをCKShareのルートレコードとして、CKShareを初期化するだけで、フォルダ共有をサポートできるようになりました。

フォルダをルートレコードとして使用すると、CloudKitは、最終的にそのフォルダレコードを指す親参照ベースの階層の一部であるすべてのレコードを自動的に共有することを意味します。

これはまた、後の時点でこの階層から追加または削除されたレコードが、それぞれ自動的に共有または共有解除されることを意味します。

では、このシンプルなフォルダ共有モデルはコードでどのように設定されていますか?

この例に引き続き、プライベートデータベースのカスタムゾーンで共有するフォルダレコードとともに、2つのファイルレコードを次に示します。

まず、親参照はフォルダレコードを指す両方のファイルレコードに設定され、ファイルレコードが保存されます。

フォルダが共有されているときに変更する必要があるレコードの数を最小限に抑えるために、親参照をできるだけ早く保存することをお勧めします。

次に、3つのレコードはすべて、CKShareをフォルダをルートレコードとして初期化し、CKShareをフォルダレコードと一緒にプライベートデータベースに保存することで共有されます。

親参照は以前にサーバーに保存されていたため、共有時に共有とともにルートフォルダレコードのみを変更する必要があることに注意してください。

そして、それだけです、あなたのアプリは今、フォルダレコードとその下のレコードを共有しています。

CloudKitは、レコード階層が重複しない限り、同じゾーン内の複数のCKShareをサポートできます。

さて、階層的なフォルダ共有モデルの代わりに、ゾーン内にいくつかの異なるタイプを表すレコードがあり、それらの間に論理的な階層がないとしましょう。

言い換えれば、ゾーンはレコードのバケットとして扱われており、その中のすべてのレコードの共有をすばやく開始したいと考えています。

理想的には、レコードゾーン内のレコードを操作することなく、レコードゾーン全体を「共有」としてマークすることができます。

今、ゾーン共有で、あなたはまさにそれを行うことができます。

では、これをコードで設定しましょう。

あなたがする必要があるのは、プライベートデータベース内の既存のゾーンのレコードゾーンIDを取るCKShareの新しい初期化子を使用することだけです。

この新しいゾーン全体の共有レコードが保存されると、サーバー上のこのゾーンに存在するすべてのレコードは自動的に共有され、ゾーンからそれらのレコードを追加または削除するだけで、新しいレコードの共有または共有解除が機能します。

ゾーン全体の共有レコードを削除することで、いつでもレコードゾーン全体を非共有にすることができます。

これらの新しいゾーン全体の共有記録をもう少し深く掘り下げてみましょう。

便宜上、ゾーン全体の共有レコードには常によく知られたレコード名CKRecordNameZoneWideShareがあり、ゾーンIDと一緒に使用して完全な共有レコードIDを作成できます。

ゾーン共有を使用するゾーンでは、そのゾーンのレコード間で親参照を設定する必要はありません。

ゾーン共有はゾーンごとに単一の共有レコードしか許可しないため、この共有のフレーバーは、同じゾーン内の階層的な共有と共存できないことに注意してください。

したがって、ゾーンに1つ以上の階層的な共有、または単一のゾーン全体の共有レコードを持つことができます。

デフォルト以外のレコードゾーンにゾーン全体のシェアを保存でき、これらは新しいゾーン機能であるCKRecordZoneCapability ZoneWideSharingでもマークされています。

CKShareレコードの作成を過ぎた既存のCloudKit共有メカニズムはすべて同じままであり、1つの例外を除いてゾーン全体の共有で完全にサポートされています。

ゾーン共有を使用する場合、ルートレコードがなくなったため、階層RootRecordIDやrootRecordなどのCKShareMetadataの関連プロパティは、ゾーン共有を受け入れるとゼロになります。

同様に、CKFetchShareMetadataOperationを使用してカスタム共有受け入れフローをブートストラップする場合、ゾーン全体の共有の共有メタデータを取得するときに、プロパティ「shouldFetchRootRecord」と「rootRecordDesiredKeys」はシステムによって無視されます。

そのため、データモデルに応じて、CloudKit共有の2つのフレーバーが利用可能になりました。

アプリのスキーマが階層を論理的に形成し、階層ツリーが共有可能な単位として理にかなっている場合は、引き続きCKRecordの親参照を使用してそれらの階層を表し、ルートレコードを共有します。

Appleでは、今日調査したのと同様の方法で、メモ、リマインダー、iCloud Driveのフォルダ共有のためにこれを行います。

また、他のすべてのケースでは、単一のゾーン全体の共有レコードを作成するだけで、レコードゾーン全体を効率的に共有し、CloudKit共有を最大限に活用できるようになりました。

Appleでは、HomeKitの安全なビデオ共有やHomePodのマルチユーザーなど、いくつかの機能にゾーン共有をすでに活用しています。

そこで今日は、アイテムごとの進行状況やエラー報告APIの強化など、Swiftでasync/awaitを使用してCloudKitコードを新しい方法で書き始める方法を検討しました。

独自の暗号化をロールすることなく、ユーザーのプライバシーに対するAppleのコミットメントを利用して、機密性の高いユーザーデータのために記録上の暗号化されたフィールドを活用する方法について話しました。

そして、データモデルがゾーン共有で階層化されていない場合に、CloudKit共有を開始するより迅速な方法について学びました。

これらの機能に関するいくつかの素晴らしい新しいドキュメントがあり、developer.apple.comでさらに多くのドキュメントが利用可能ですので、ぜひ見てください。

「Explore CloudKit」コレクションには、CloudKitの上に構築された共有機能を導入するCore Dataからのセッションを含め、チェックアウトするための多くの関連セッションがあります。

ありがとう、そして素晴らしいWWDCをお過ごしください。

[明るい音楽]。