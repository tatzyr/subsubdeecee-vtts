10157

こんにちは！私の名前はエゴールです。今日は、メタルデバッガーのすべての改善点と新機能についてお話ししたいと思います。

今年は、レイトレーシングやファンクションポインタなど、より多くのメタル機能のサポートをもたらします。

Appleプラットフォーム全体でGPUを最大限に活用できるように、GPUタイムラインや一貫したGPUパフォーマンス状態など、まったく新しいプロファイリングワークフローを追加しました。

シェーダー検証のより広範なサポートや正確なキャプチャコントロールなど、あなたが知っていて愛している他のデバッグワークフローを改善しました。

また、同僚のアマンダが後で話すテクスチャ圧縮の進歩も紹介しています。

まず、レイトレーシングについて話しましょう。

昨年、新しいメタルレイトレーシングAPIを導入し、現在、Xcode 13では、シェーダーに柔軟性をもたらす機能ポインタと関数テーブルとともに、メタルデバッガでサポートしています。

そして、ダイナミックライブラリは、よく抽象的で再利用可能なシェーダーライブラリコードを構築する方法を提供します。

また、レイトレーシングには、まったく新しいツールであるAcceleration Structure Viewerを導入しています。

メタルデバッガのレイトレーシングを見てみましょう。

ModernRendererサンプルアプリのGPUトレースを開きました。

影や周囲の閉塞などの効果を達成するために、メタルレイトレーシングを使用するように変更されました。

このエンコーダは、美しいレイトレースシャドウマップを作成します。

バインドされたリソースの加速構造を確認できるように、ディスパッチコールを選択しました。

ここから、加速構造を開いて、新しい加速構造ビューアに移動します。

ここでは、右側に馴染みのあるビストロシーンのジオメトリ、左側にそのアウトラインを見ることができます。

シーン内のインスタンスをクリックすると、ビューアとシーンアウトラインで選択されます。

展開することで、変換行列やその他のインスタンスプロパティを確認できます。

シーンビューアでOptionキーを押しながらクリックすることで、個々のジオメトリを選択することもできます。

これにより、シーンのアウトラインでも選択され、その逆も同様です。

また、加速構造で使用される関連する交差関数をビューアで確認することもできます。

しかし、加速構造ビューアは、単にジオメトリを表示するよりもはるかに多くのことができます。

右下には、シーンのプロパティの一部を視覚化するのに役立ついくつかのハイライトモードもあります。

たとえば、バウンディングボリュームトラバーサルモードは、ジオメトリの複雑さを視覚化するのに役立ちます。

より深い青色は、境界ボリューム階層が他の部分と比較して横断するのに計算コストがかかる領域を示しています。

すべてのモードについて、シーンのさまざまな部分にカーソルを合わせると、関連情報を表示するこの小さなビューがあります。

ここでは、バウンディングボックストラバーサルとプリミティブ交差点の数が表示されます。

柔軟性を高めるために、トラバーサル設定も含めました。

それらを使用すると、シェーダー内のインターセクターオブジェクトで見つけることができるのと同じプロパティを使用して、加速構造ビューアを設定できます。

レイトレーシングに関しては、話すことがたくさんあります。

詳細を知りたい場合は、今年のセッション「メタルレイトレーシングでハイブリッドレンダリングを探る」をチェックしてください。そして、一般的なAPIについてもっと知りたい場合は、昨年の講演「金属でレイトレーシングを発見する」をチェックしてください。次に、プロファイリングについて話しましょう。

アプリをプロファイリングすることは重要なステップであり、私たちはすでにあなたの処分で多くの素晴らしいツールを持っています。

たとえば、機器のメタルシステムトレースを使用すると、さまざまなレンダリングステージ、GPUカウンタ、シェーダータイムラインのCPUとGPUの期間を示すタイムラインビューを探索できます。

また、メタルデバッガでは、GPUカウンターは、エンコーダごとまたはドローごとに、GPUから直接豊富な測定セットを表示します。

どちらも優れたツールであり、アプリのパフォーマンスの補完的なビューを提供します。

しかし、これらの見解を一致させるには、さらなる努力が必要かもしれません。

だからこそ、メタルシステムトレースとGPUカウンターを統一された体験で組み合わせた新しいGPUプロファイリングツールをお見せできることを嬉しく思います。

Apple GPU用に特別に設計された新しいツール、Metal DebuggerのGPUタイムラインをご紹介します。

パフォーマンスデータについて異なる視点を提供し、アプリで潜在的な最適化ポイントを見つけるのに役立ちます。

プロファイリングツールのスイートへのこの最新の追加を見ていきましょう。

GPUタイムラインは、パフォーマンスパネルの下にあります。

アプリからフレームをキャプチャした後、デバッグナビゲーターで見つけることができます。

パフォーマンスパネルを開くと、並行して配置されたさまざまなトラックのセットが迎えられます。

続ける前に、エンコーダトラックが並列になっている理由を説明したいと思います。

Apple GPUでは、異なるレンダリングパスの頂点とフラグメントステージ、およびコンピューティングディスパッチを同時に実行できます。

これは、Apple GPUアーキテクチャと「タイルベースの遅延レンダリング」と呼ばれるレンダリング技術の使用によって可能になります。私たちは、アプリのコンテキストでApple GPUのこの並列的な性質を見ることができることが重要だと思いました。

そして、そこでGPUタイムラインが役に立ちます。

上部には、頂点、フラグメント、およびコンピュートエンコーダのタイムラインが表示され、各エンコーダは使用するリソースを一目で確認できます。

エンコーダの下には、占有、帯域幅、リミッターカウンタがあります。

エンコーダのタイムラインを詳しく見てみましょう。

各エンコーダトラックを展開して、集約されたシェーダータイムラインを見ることができます。

タイムラインをさらに拡大すると、それぞれのシェーダーが滝のような方法で表示されます。

エンコーダをナビゲートするのは簡単です。

エンコーダトラックを選択すると、右側のすべてのエンコーダのリストが表示されます。

そこでは、平均期間で並べ替えることができます。

タイムラインで個々のエンコーダをクリックすると、サイドバーに詳細情報が表示されます。

たとえば、ここでは、このレンダリングコマンドエンコーダの添付ファイルを見ることができます。

エンコーダを選択すると、アクティブな時間範囲がすべてのトラックで強調表示されることに気づいたかもしれません。

これにより、異なるステージがどのように重なるかを簡単に調べることができ、エンコーダのカウンタ値を関連付けることができます。

タイムラインビューから離れると、[カウンタ]タブに切り替えてGPUカウンタにアクセスするか、エンコーダのコンテキストメニューを開いてそこからカウンタで表示することができます。

そして、これはGPUタイムラインのスニークピークです。

Metal Debuggerを使用してアプリのパフォーマンスを理解する方法の詳細については、今年のセッション「Apple GPU用にハイエンドゲームを最適化する」をご覧ください。アプリをプロファイリングする新しい方法を紹介したので、そのパフォーマンスはいくつかの要因に依存することを理解することが重要です。

メタルについて話すとき、GPUのパフォーマンス状態は非常に重要な要素です。

オペレーティングシステムによって管理され、デバイスのサーマル、システム設定、GPU使用率、その他のパラメータに応じて状態を下げたり引き上げたりします。

これらの状態の変更は、表示されているプロファイリング結果に影響を与える可能性があります。

今年は、より一貫した結果でアプリをプロファイリングするための新しい方法を導入します。

ライブパフォーマンス録画用のInstrumentsとMetalシステムトレースから始まり、Metal Debugger、GPUトレースのプロファイリング、最後に一般的なユースケース用のXcodeのデバイス条件など、Metalツールのスイート全体でGPUパフォーマンス状態を確認および変更する方法を追加しました。

まず、楽器について話しましょう。

今年は、メタルシステムトレースにGPUのパフォーマンス状態のトラックを追加しました。

他のトラックと組み合わせて使用して、アプリのパフォーマンスとデバイスのパフォーマンス状態を関連付けます。

ただし、パフォーマンス状態を見ることができることは、方程式の一部にすぎないことを覚えておいてください。

一貫性のある再現性のあるプロファイリング結果を得るには、デバイスにGPUのパフォーマンス状態を設定する方法も必要です。

今年の新しいのは、Instrumentsにトレースを記録するときに、特定のGPUパフォーマンス状態を誘導する機能です。

録画オプションに移動し、録画が始まる前にパフォーマンス状態を選択するだけです。

その後、通常どおりパフォーマンストレースを記録できます。

機器は、デバイスがそれを維持できる場合、トレースの期間中に選択した状態を誘導します。

場合によっては、既存のInstrumentsトレースが記録中にGPUパフォーマンス状態を誘発したかどうかを確認する必要があるかもしれません。

この情報は、情報ポップオーバーの「録画設定」セクションにあります。

そして今、あなたはInstrumentsからGPUのパフォーマンス状態を表示し、誘導する方法を知っています。

一貫したGPUパフォーマンス状態を活用する2番目の方法は、Metal Debuggerを使用することです。

デフォルトでは、アプリのGPUトレースをキャプチャすると、Xcodeがトレースをプロファイリングします。

そして、キャプチャ時にデバイスがいたのと同じパフォーマンス状態を使用してそうします。

前述の要因によっては、その状態が変動した可能性があります。

代わりに、特定のパフォーマンス状態を自分で選択したい場合は、デバッグバーのストップウォッチボタンを使用します。

選択後、Metal DebuggerはGPUトレースを再度プロファイリングします。

完了後、一貫したパフォーマンス状態が達成されたことを反映してボタンが強調表示されます。

また、サマリーページの「パフォーマンス」セクションには、新しいパフォーマンスデータと選択したパフォーマンス状態が一目で表示されるようになりました。

これら2つのアプローチは、一連の金属工具に結びついています。

しかし、時には、プロファイリングワークフローの外で一貫したパフォーマンス状態を誘導したいと思うかもしれません。

GPUのパフォーマンス状態を設定する3番目の方法は、デバイス条件です。

異なるGPUパフォーマンス状態でアプリがどのように機能するかをテストしたい場合は、これがあなたのためのオプションです。

Xcode 13では、GPUのパフォーマンス状態のデバイス条件を追加しました。

オペレーティングシステムは、デバイスを維持し、Xcodeに接続したままである限り、デバイス上で指定された状態を使用することを強制します。

Xcodeからこの条件を追加できます。ウィンドウ、デバイス、シミュレータに移動し、そこでデバイスを選択し、「デバイス条件」セクションまでスクロールして、目的のレベルで「GPUパフォーマンス状態」条件を追加します。

GPUのパフォーマンス状態の変更をデバイスに適用する場合は、[スタート]を押します。

その後、完了したら、停止を押します。

当社のツールから直接GPUのパフォーマンス状態を確認および変更するこれらの新しい方法は、アプリのプロファイリングとテストに役立つはずです。

そして、プロファイリングワークフローへの最新の追加と改善を気に入っていただけると思います。アプリをさらに良くするのに役立つことを願っています。

さて、今年Metal Debuggerにもたらす他のいくつかの改善について話しましょう。

まず、シェーダー検証の改善についてお話しします。

次に、正確なキャプチャコントロールをお見せします。

その後、新しいパイプライン状態のワークフローを見ていきます。

最後に、シェーダーのデバッグとプロファイリング、別々のデバッグ情報と選択的なシェーダーのデバッグに関連する2つの新機能を紹介したいと思います。

昨年、Xcode 12では、範囲外のアクセスなど、GPUのランタイムエラーを診断するのに役立つシェーダー検証を導入しました。

シェーダーの検証が有効になっていて、エンコーダが検証エラーを発生させると、問題ナビゲーターでランタイムの問題が発生し、障害が発生したコールのCPUとGPUの両方のバックトレースが表示されることを覚えておいてください。

私たちはすでにこれをより詳細にカバーするセッションを持っているので、シェーダー検証の使用の詳細については、「MetalのGPU側エラーのデバッグ」と呼ばれる昨年の講演をチェックしてください。今年は、より多くのユースケースをサポートするためにシェーダーの検証を拡張し、間接コマンドバッファ、動的ライブラリ、関数ポインタとテーブルを使用しているときに利用できるようにします。

これにより、開発中にアプリ全体でシェーダー検証をより広範囲に使用できるはずです。

次に、新しい正確なキャプチャコントロールをお見せしたいと思います。

しかし、まず、メタルのロゴのように見えるキャプチャボタンを見てください。

これは、Xcodeウィンドウの下部にあるデバッグバーにあります。

クリックすると、新しいメニューが表示されます。

このメニューでは、キャプチャのスコープを選択できます。

デフォルトは1つのフレームをキャプチャすることですが、キャプチャするフレーム数を最大5つまで指定できます。

また、同じ親デバイスまたはコマンドキューを持つ多数のコマンドバッファ、特定のメタルレイヤーを提示するコマンドバッファ、さらにはMTLCaptureScope APIを使用してアプリのコードで定義できるカスタムスコープをキャプチャすることもできます。

これらの新しいコントロールは、メタルコールがいつどのようにキャプチャされるかを決定する際に、すぐに使える信じられないほどのパワーを提供します。

次に、金属ライブラリとパイプラインの状態について話しましょう。

これらはあなたのMetalアプリの不可欠な構成要素です。

また、Xcode 13では、アプリが使用しているすべてのパイプラインの状態とライブラリを調べることがこれまで以上に簡単になりました。

さて、それが実際にどのように見えるか見てみましょう。

ここでは、ModernRendererのサンプルアプリからGPUトレースをキャプチャしました。

GBufferパイプラインの状態がどのように機能するかを見たかったので、このドローコールを選択しました。

バインドされたリソースを見ると、使用されたパイプラインの状態がわかります。

それを開くと、パイプラインステートビューアに移動します。

ここから、関数を調べて、パイプライン状態が作成された他のプロパティを見ることができます。

さらに、ビューアから、状態に関連するパフォーマンスデータをチェックするか、メモリビューアに移動して状態を明らかにすることができます。

Xcode 13では、メモリビューアが、パイプライン状態がアプリでどれだけのメモリを消費しているかを表示するようになりました。

これらは、アプリのGPUトレースを見ているときに、メタルデバッガ全体のパイプライン状態を簡単に検査できる追加のほんの一部です。

次に、Metal Debuggerでのシェーダーのデバッグとプロファイリングについて話しましょう。

現在、これらの機能を使用したい場合は、2つの選択肢があります。

最初のオプションは、アプリの実行中にソースコードからライブラリをコンパイルすることです。

2番目のより良い選択肢は、ソースがオフラインで埋め込まれたMetallibファイルを構築し、実行時にそれらをロードすることです。

しかし、その後、App Storeのルールでは、これらのデバッグMetallibsでアプリを公開することはできません。

つまり、ライブラリをオフラインでコンパイルし、シェーダーをデバッグできるようにしたい場合は、2回コンパイルする必要があります。1回はソースが埋め込まれており、開発中に使用するため、もう1回はソースなしで配布用です。

今年、私たちはそれを変えています。

Metallibをコンパイル中に、ソースやその他のデバッグ情報を含む別のファイルを生成できるようになりました。

これらのファイルにはMetallibsym拡張子があり、ライブラリ自体に追加情報を埋め込むことなく、シェーダーをデバッグしてプロファイルすることができます。

それらを別々に持つことの最も重要な利点は、同じMetallibの2つのバージョンを持つ必要がないことです。

もう1つの利点は、これらのMetallibsymファイルを使用すると、シェーダーソースを危険にさらすことなく、アプリのリリースバージョンでもシェーダーをデバッグできることです。

シェーダーソースファイルをMetallibsymファイルと一緒にMetallibにコンパイルする方法の例を紹介します。

通常どおりMetallibをコンパイルするxcrunターミナルコマンドから始めます。

Metallibsymファイルを生成するには、「フラット」オプションでフラグ「レコードソース」を追加し、コンパイラを実行するだけです。

さて、別のデバッグ情報ファイルでコンパイルされたシェーダーをデバッグしようとすると、インポートするように求められます。

ソースのインポートをクリックすると、すべてのライブラリとソースファイルをインポートしたかどうかを一覧表示するダイアログが開きます。

ここから、任意のMetallibsymファイルをインポートでき、インポートすると、ライブラリとそのソースが自動的に一致します。

インポートが完了したら、ダイアログを閉じることができ、シェーダーのソースを確認してデバッグできます。

あなたに見せたい最後のデバッグの改善があります。

それは「選択的シェーダーデバッグ」と呼ばれています。アプリが大きなシェーダーを使用している場合、シェーダーのデバッグの開始に時間がかかる可能性があることに気付いたかもしれません。

そのような場合を支援するために、今年は選択的なシェーダーデバッグをもたらします。

デバッグスコープを絞り込むのに役立つので、シェーダーをより迅速にデバッグできます。

このような大きなシェーダーの1つで実際に見てみましょう。

このGPU ASTCDecoderをデバッグしたいと思います。

このカーネル全体をデバッグしようとすると、シェーダーデバッガの起動に長い時間がかかることを知っています。

そんなに長く待ちたくないので、代わりに、デバッグスコープをこの関数、decodeIntegerSequenceだけに絞り込むことができます。

これを行うには、右クリックして「デバッグ関数」を選択できます。

これにより、「デバッグする関数」メニューが開き、関数スコープがすでに選択されています。

これで、デバッガはほぼ瞬時に起動します。

選択的なシェーダーデバッグは、巨大なシェーダーのバグをすばやく特定する素晴らしい方法です。

これらはすべて、私が今日お見せしたかった金属工具の改善です。

そして今、アマンダは私たちがテクスチャ圧縮で成し遂げた進歩についてあなたに話します。

アマンダ？

ありがとう、エゴール。

テクスチャ圧縮ツールに今年行ったアップデートを順を追って説明します。

ツールに飛び込む前に、Appleプラットフォームでのテクスチャ圧縮の基本について簡単に説明します。

テクスチャ圧縮は、この場合、テクスチャデータの固定レート、損失圧縮です。

これは主に、デカールやノーマルマップなどの静的テクスチャデータのオフライン圧縮を目的としています。

実行時に動的テクスチャデータを圧縮できますが、それは私が今日カバーしているものではありません。

ほとんどのテクスチャ圧縮は、テクスチャをブロックに分割し、各ブロックを色のペアとして圧縮することで機能します。

このペアは、これらのエンドポイントから補間された他の色を含むローカライズされたパレットと、このパレットから選択するピクセルごとのインデックスを定義します。

各フォーマットには、異なる種類のテクスチャデータに適した異なる強みがあります。

Apple GPUは、A12デバイスからロスレスフレームバッファ圧縮もサポートしており、帯域幅の最適化に最適です。

GPUがアプリに使用しているメモリ帯域幅の測定の詳細については、昨年のセッション「GPUカウンタでMetalアプリとゲームを最適化する」をご覧ください。

もう1つのオプションは、このプレゼンテーションで取り上げているGPUテクスチャ圧縮の上にテクスチャファイルのロスレス圧縮を実行することです。

これにより、アプリのダウンロードのサイズをさらに削減できます。

この講演のためにテクスチャ圧縮を定義したので、テクスチャ圧縮がアプリにもたらす利点について話します。

テクスチャ圧縮は、アプリの開発における重要なステップです。

一般的に、ゲームのメモリフットプリントのほとんどはテクスチャで構成されています。

テクスチャ圧縮を使用すると、より多くのテクスチャをメモリにロードし、より詳細なテクスチャを使用して、より視覚的に魅力的なゲームを作成できます。

圧縮により、アプリのサイズとメモリフットプリントを削減することもできます。

基本を説明したので、Appleプラットフォームのテクスチャ圧縮ツールの現状について説明します。

iOS SDKの既存のTextureToolには、比較的シンプルなパイプラインがあります。

TextureToolは、入力画像を読み取り、必要に応じてミップマップを生成し、テクスチャを圧縮し、ブロックごとにブロックし、結果を新しい出力ファイルに書き込みます。

しかし、グラフィックアルゴリズムの複雑さが増すにつれて、テクスチャはより高度な処理が必要です。

これらのプロセスの中核は、数値精度間の変換からの丸めを最小限に抑えながら、正しい色空間で操作を実行することです。

これを理解して、テクスチャ処理の洗練さの必要な増加を処理し、多くの新しいオプションにアクセスできるように、TextureConverterと呼ばれる新しい圧縮ツールを設計しました。

Appleプラットフォームのテクスチャ処理パイプラインをどのように刷新したかを詳しく見てみましょう。 見てみましょう。

テクスチャ処理パイプラインは、TextureConverterでフル機能のテクスチャ処理パイプラインにアクセスできるように、ゼロから再構築されました。

TextureConverterは、業界で認められた一連のコンプレッサーを活用して、幅広い圧縮フォーマットをサポートし、圧縮速度と画質をトレードオフするオプションを提供します。

使用するコンプレッサーを指定するか、圧縮形式、品質レベル、その他のオプションに基づいてTextureConverterを選択できるようにしたりできます。

各ステージはあなたによって完全に設定可能になり、テクスチャ処理はガンマ認識です。

すべてのコンテンツパイプラインへの統合をサポートするために、TextureConverterはmacOSとWindowsの両方で利用でき、Apple Siliconでの使用に最適化されています。

ガンマから始めて、拡張されたパイプラインの各段階をステップスルーしましょう。

ガンマ補正は、画像の輝度をエンコードおよびデコードする非線形操作です。

テクスチャは多くのガンマ空間でエンコードできます。

最良の選択は、テクスチャが表すデータの種類に依存します。

デカールやライトマップなどのほとんどの視覚データは、sRGBのような非線形空間でエンコードされている場合に最適です。

非視覚データは、通常のマップと同様に、線形空間でエンコードする必要があります。

この選択により、必要な暗い領域での精度が向上します。

非視覚データは、通常のマップと同様に、線形空間でエンコードする必要があります。

圧縮は、「gamma_in」と「gamma_out」オプションで指定されたターゲット色空間で実行する必要があります。

線形ガンマ空間の浮動小数点数を入力するか、文字列「sRGB」を使用してその色空間を指定できます。

また、これらのオプションを使用して別のターゲットスペースに変換する柔軟性もあります。

ミップマップ生成などの他の操作は、線形空間で実行する必要があります。

今から線形空間処理の段階を歩きます。

入力が線形ガンマ空間に変換されたので、入力テクスチャが指定されたターゲットガンマ空間に変換される前に、線形空間操作が実行されます。

3つのステージは、物理変換、ミップマップ生成、アルファ処理であり、これらのいくつかにはサブステージがあります。

物理的な変換から始めます。

任意の軸の最大サイズを定義することで、トップレベルのミップマップの必要に応じて画像を縮小できます。

この段階では、サイズ変更フィルターとサイズ変更の丸めモードも制御できます。

サイズ変更フィルターオプションは、さまざまなアルゴリズムを使用して、ディメンションサイズが下がるミップマップのぼやけを減らすのに役立ちます。

サイズ変更ラウンドモードは、画像のサイズを変更するときにmax_extentと組み合わせて使用されます。

Max_extentを超えると、元の画像のアスペクトを維持することで、ソース画像のサイズが変更されます。

ターゲットの寸法を見つけるときに、指定されたラウンドモードが使用されます。

どのサイズ変更フィルターまたは丸めモードを使用するかわからない場合は、ほとんどの場合、うまく機能するデフォルトを選択しました。

また、この段階の反転オプションを使用すると、X軸、Y軸、およびZ軸の線形変換を制御できます。

変換後はミップマップ生成であり、一般的なテクスチャ処理状況の大部分で使用されます。

Mipmapsは、レンダリング速度を高め、エイリアシングを減らすために使用される、シーケンスよりも解像度を低下させる、事前に計算された画像のシーケンスです。

各レベルの高さと幅は、前のレベルよりも2つ小さいパワーです。

Mipmap生成をカスタマイズするときは、必要な最大数と使用するmipフィルタを指定します。

TextureConverterのデフォルトはKaiserフィルタリングで、「ボックス」と「トライアングル」フィルタリングのオプションがあります。

線形空間処理の最終段階はアルファ処理です。

アルファからカバレッジが有効になっている場合、指定されたアルファ参照値を使用して、これが最初に適用されます。

アルファ・トゥ・カバレッジは、アルファブレンドをカバレッジマスクに置き換えます。

アンチエイリアスまたは半透明のテクスチャを使用すると、注文に依存しない透明度が得られ、ゲームで密集した緑をレンダリングするのに特に便利なツールです。

その後、アルファチャンネルを破棄、保存、または事前乗算するオプションが表示されます。

事前に乗算されたアルファでは、画像の部分的に透明なピクセルがマットカラーで事前に乗算されます。

線形空間処理段階の終わりに、ターゲットのガンマ空間に戻り、処理されたミップレベルを圧縮する準備が整いました。

テクスチャ処理の最後のステップは圧縮です。

圧縮段階は、チャネルマッピングとエンコーディングの2つのサブステージに分けることができます。

チャネルマッピングは、特定のデータ型に対して汎用テクスチャ圧縮アルゴリズムを最適化する手法です。

TextureConverterでチャンネルマッピングを指定することはオプションです。

使用したい場合、TextureConverterは現在、チャネルマッピングの2つのモード、RGBMエンコーディングとノーマルマップエンコーディングをサポートしています。

RGBMエンコーディングから始めて、これらのフォーマットの両方をより深くカバーします。

RGBMエンコーディングは、アルファチャンネルに乗数を格納し、この乗数でRGBチャンネルをスケーリングすることにより、LDR形式でHDRデータを圧縮する手法です。

これは教室のHDR画像の例です。

そして、これは再び同じ教室の画像で、アルファチャンネルに保存された乗数がグレースケールで表示されます。

コード例を使って、RGBMにエンコードする乗数を計算する方法を紹介します。

EncodeRGBMは、RGBMへのエンコーディングの仕組みを理解するのに役立つ簡略化された疑似コード関数です。

このスニペットには、RGBMの範囲を設定するためのまったく新しいパラメータであるRGBM_Rangeの使用が含まれており、デフォルトは6.0です。

RGBMアルファ値、乗数を計算するために、まず、入力テクスチャの赤、緑、青のチャンネルの最大値を決定します。

これはMetalのmax3機能で行われます。

次に、この最大値はRGBM_Rangeで割ります。

エンコードされたRGBMの赤、緑、青のチャンネル値を計算するために、まず、以前に計算された乗数にRGBM_Rangeを掛け、アルファチャンネルのストレージの値をスケーリングするために使用します。

次に、入力テクスチャを最終的な乗数値で割ります。

シェーダーでRGBMをデコードするには、エンコーディング機能で示したように、サンプルのRGBにアルファと固定係数を掛けます。

DecodeRGBMコードスニペットを見て、これを行う方法を紹介します。

スケーリング係数は、乗数が格納されているRGBMアルファチャネルにRGBM_Rangeを乗じて再計算されます。

元のテクスチャのRGBは、RGBMサンプルに計算された乗数を掛けて計算されます。

RGBMエンコーディングを紹介したので、通常のマップエンコーディングに移ります。

ほとんどの場合、正規マップを参照するときは、特にオブジェクト空間正規マップを参照しています。

オブジェクト空間で法線をエンコードする場合、各法線は単位ベクトルであり、実行時に3番目の軸で2つの軸で表現できるという利点があります。

これにより、これら2つのチャネルを再マッピングして、テクスチャ圧縮アルゴリズムを最大限に活用し、XYZをRGBとして圧縮するよりも優れた圧縮品質を実現できます。

チャンネルの再マップ方法は、圧縮形式によって異なります。

このチャートをガイドとして、ASTCでノーマルをエンコードする例を見ていきます。

ASTCでエンコードする場合、赤、緑、青のチャンネルはXコンポーネントに設定され、アルファチャンネルはYコンポーネントに設定されます。

色は、エンコードされた法線をサンプリングするときに、X成分とY成分が再割り当てされるチャネルに対応します。

TextureConverterは、通常のマップパラメータを渡すと、選択した形式に自動的に再マッピングすることで、エンコーディングの再マッピングを処理します。

シェーダーでノーマルマップをサンプリングするときは、チャンネルマッピングを知ることが重要です。

Xコンポーネントは赤またはアルファチャンネルから読み取られますが、Yコンポーネントは圧縮形式に応じてアルファまたは緑のチャンネルから来ます。

ASTCの例に戻ると、テクスチャをサンプリングするために、Xコンポーネントは赤いチャンネルからサンプリングされ、Yコンポーネントはアルファチャンネルからサンプリングされ、通常のエンコード方法の逆です。

任意のデバイスで可能な限り最高の品質を達成するために複数のフォーマットにエンコードしている場合、このマッピングは実行時に処理する必要があります。

メタルテクスチャスウィズルを使用したランタイムノーマルサンプリングの例を見ていきます。

複数のフォーマットへのエンコードは、異なるフォーマットが異なるチャネルマッピングを使用している場合、複数のシェーダーバリアントが必要になる可能性があります。

これを避けるために、Metalを使用すると、テクスチャにカスタムスウィズルを適用できます。

Swizzlesを使用すると、XとYのコンポーネントを赤と緑のチャンネルに再マップできるため、シェーダーは圧縮フォーマットをニュートラルにすることができます。

以前の図で見たように、ASTCで圧縮された通常のマップのチャンネルを赤と緑に再マッピングする例を次に示します。

テクスチャ記述子が初期化された後、赤いチャンネルはMTLTextureSwizzleRedに設定され、緑のチャンネルはMTLTextureSwizzleAlphaに設定されます。

これは通常のマップであるため、サンプリングに必要なチャンネルは2つだけです。

赤と緑のチャンネルは、もともと赤とアルファチャンネルにエンコードされたXとYコンポーネントに割り当てられるようになったため、青とアルファチャンネルはゼロに設定されています。

それが完了したら、最後の行は、MTLTextureSwizzleChannelsMakeを使用して、再マップされたチャンネルで最終的なスウィズルを組み立てることです。

XチャンネルとYチャンネルがシェーダーでサンプリングされたら、Zコンポーネントを再構築できます。

ReconstructNormal関数を順を追って説明します。

まず、コードはXとYのコンポーネントを正しい範囲に再バイアスします。これは、通常の1対1の負です。

次のステップは、ドット積の結果が正しい符号を持っていることを確認するために、X成分とY成分のドット積を1つから減算することです。

その後、飽和関数は、この結果を0から1の範囲内にクランプするために使用されます。

Z成分を計算する最後のステップは、飽和関数の出力の平方根を取ることです。

チャネルマッピングで利用可能なRGBMとノーマルマップエンコーディングオプションを説明したので、最終的な圧縮サブステートであるエンコーディングでテクスチャ圧縮パイプラインの議論を終了します。

すべてのTextureConverterコマンドラインでは、compression_format引数を持つターゲット圧縮フォーマットの指定が必要です。

また、使用するコンプレッサーを指定したり、選択した圧縮形式やその他のオプションに基づいてTextureConverterに選択させたりすることもできます。

これらの4つのオプションから圧縮品質を選択することもできます。

圧縮速度と画質の間にはトレードオフがあり、ゲームを反復しながらより低い圧縮品質を選択したいと思うかもしれませんが、リリースされたビルドには最高の品質を使用してください。

さて、あなたが選択できるテクスチャ圧縮フォーマットについて説明します。

以下は、Appleプラットフォームでサポートされているテクスチャ圧縮フォーマットファミリーの概要です。

iOSとApple SiliconプラットフォームはASTCとPVRTCファミリーをサポートし、すべてのmacOSプラットフォームはBCnファミリーをサポートしています。

これらのフォーマットファミリーのそれぞれをより詳細に説明し、ニーズに最適なものを選択するのに役立つガイドラインを提供します。

BCn形式から始めます。

BCnは、すべて4×4ブロックのピクセルを使用して動作し、ピクセルあたり4ビットまたは8ビットを使用する7つのフォーマットのセットです。

各圧縮形式は、異なるデータ形式に最適です。

BC1とBC3はRGBとRGBAの圧縮に一般的に使用され、BC6はHDR画像に理想的であり、デュアル独立チャンネルを備えたBC5は、通常のマップエンコーディングに最適です。

次は、LDR、sRGB、HDR色空間のRGBAフォーマットのファミリーであるASTCです。

ASTCファミリのフォーマットは、すべてのサイズで最高の品質を可能にするため、PVRTCよりも一般的に推奨されます。

各フォーマットには、ピクセルごとのビット数と品質の範囲があります。

ASTCでは、各ブロックのバイトサイズはフォーマットに関係なく同じですが、表すテクセルの数は異なります。

これにより、最高品質の圧縮が、4×4のブロックサイズで最低の圧縮率と、12×12のブロックサイズで最低の圧縮品質が最高の圧縮率の間の連続性が得られます。

LDR、sRGB、およびHDRバリアントは、圧縮されたASTCテクスチャの色範囲を記述します。

LDRとsRGBはどちらもリニアまたはsRGB空間のいずれかで0対1の範囲にあり、HDRバリアントは0対1の範囲外のデータ用です。

最後に、PVRTCフォーマットは、2ビットまたは4ビットモードでRGBとRGBAで利用できます。

この形式のデータブロックは常に8バイトを占めるため、2ビットモードでは8×4ピクセルごとに1つのブロックがあり、4ビットモードでは4×4ピクセルごとに1つのブロックがあります。

サポートされているフォーマットファミリーを紹介したので、アプリのフォーマットを選択するための推奨事項をいくつか紹介します。

iOSデバイスでは、A7 GPU以前をサポートしている場合にのみ、常にASTC圧縮を使用し、PVRTC圧縮とデバイスごとのシンニングを追加する必要があります。

HDRテクスチャがある場合は、A13以降のGPUでASTC HDRを利用できます。

macOSの場合、BCnは全面的に利用可能です。

Apple Silicon Macでは、ASTCを使用するオプションもあり、iOSデバイスもターゲットにしている場合は、このオプションを検討する必要があります。

PVRTCはApple Siliconで利用できますが、このオプションはお勧めしません。また、iOSのレガシーサポートのみを対象としています。

各圧縮フォーマットファミリにはさまざまなフォーマットがあるため、アプリに最も効果的なテクスチャ圧縮フォーマットを選択するためのガイドラインは、可能な限りテクスチャごととターゲットごとを選択することです。

すべてのテクスチャがRGBまたはRGBAデータでない限り、通常のデータの2つの独立したチャネルとして圧縮を可能にするフォーマットを選択するなど、圧縮するデータの種類に基づいて圧縮フォーマットを選択する必要があります。

ASTC形式に圧縮するときは、形式のサブセットを選択することをお勧めします。

より高い圧縮率で受け入れられるものと比較して、最高の品質を必要とするテクスチャをバケット化することを検討してください。

さて、私たちがカバーした内容を見直しましょう。

新しいTextureConverterツールを使用して、パイプラインのすべての段階を完全に制御するために、TextureToolからテクスチャ処理パイプラインを完全にリメイクしました。

この新しいパイプラインの各段階を歩き、各段階で使用できるすべてのオプションを検討し、Appleプラットフォームでサポートされているチャネルマッピングとテクスチャ圧縮フォーマットファミリを紹介しました。

TextureToolからTextureConverterへのワークフローをできるだけ簡単に更新できるようにしたいので、コマンドラインを切り替えるのに役立つ互換性モードを追加しました。

TextureTool互換モードを使用するか、ネイティブオプションでTextureConverterを呼び出すかにかかわらず、xcrun TextureConverterで呼び出します。

これは、TextureToolオプションで呼び出されるTextureConverterのコマンドラインの例です。

TextureConverterは、オプションをネイティブのTextureConverterオプションに変換し、圧縮を行い、新しいネイティブオプションが何であるかを伝えるので、ビルドスクリプトを簡単に更新できます。

それはTextureConverterの紹介でした。

それを手に入れる方法は次のとおりです。

TextureConverterはXcode 13の一部として出荷され、シード1で使用できます。

Windowsでは、TextureConverterは、developer.apple.comから入手できるMetal Developer Tools for Windows 2.0パッケージの一部として出荷されます。

シード1は現在入手可能です。

Windowsでは、PVRTCはレガシーiOSプラットフォームをサポートするためにmacOSで利用できるため、PVRTC形式への圧縮はサポートされていないことに注意してください。

Windows用のMetal Developer Toolsのもう1つの重要な部分は、Windows用のMetalコンパイラです。

Windows用のMetalコンパイラは昨年導入され、Metal Shading Languageバージョン2.3をサポートしました。

年間を通してのアップデートは、Xcodeで出荷されたMetalコンパイラへのアップデートを反映しました。

最新のリリースバージョンは1.2で、Apple Silicon MacでのMetal Shading Languageのサポートが含まれています。

バージョン2.0のシード1は、Metal Shading Language 2.4のすべての素晴らしい新機能をサポートするようになりました。

以下は、今日取り上げたすべての要約です。エゴールは、レイトレーシングやファンクションポインタなど、より多くの金属機能のサポートについて議論しました。

彼は、すべてのAppleプラットフォームでGPUを最大限に活用できるように、GPUタイムラインや一貫したGPUパフォーマンス状態などのまったく新しいプロファイリングワークフローを導入しました。

そして、シェーダーの検証と正確なキャプチャコントロールをよりサポートするために、すでに慣れ親しんでいるデバッグワークフローの改善を実証しました。

そして、テクスチャ処理パイプラインとAppleプラットフォームで利用可能なサポートされているすべてのテクスチャ圧縮フォーマットを最大限に活用するのに役立つ新しいツールであるTextureConverterを紹介しました。

ありがとう、そしてWWDC 2021の素晴らしい残りをお過ごしください。

[音楽]。