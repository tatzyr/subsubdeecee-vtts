10194

♪ベース音楽の演奏♪

♪

ベン・コーエン：こんにちは、私はSwiftチームのBenです。このビデオでは、Swiftの新しい並行性機能を使用するために、既存のアプリケーションの移植について説明します。

これらの新機能が、より明確な非同期コードを作成し、可能な競合状態から保護するのにどのように役立つかを確認し、コードをこの新しい操作方法に徐々に移動するためのいくつかのテクニックを見ていきます。

私はコーヒートラッカーというアプリを使うつもりですが、それはウォッチコンプリケーションの作成と更新に関するWWDC 2020の講演に基づいています。

これは、今日飲んだすべてのコーヒーと、時計の文字盤に現在のカフェインレベルを表示するための合併症を追跡できるシンプルなアプリです。

小さなアプリですが、SwiftUIとの並行性の仕組み、watch SDKからのコールバックのデリゲート、一部のI/O、AppleのSDKの非同期APIとのインターフェースなど、私たちが考えたいさまざまなことを示しているので、私たちの目的のために使用する素晴らしい例です。

では、アプリの簡単なツアーに参加しましょう。

それは大まかに3つの層に分かれています。

まず、UIレイヤーがあります。

これは主にSwiftUIビューですが、この場合、UIレイヤーの一部としてコンプリケーションデータソースのようなものを考慮することもできます。

次に、カフェイン飲料を表すいくつかの単純な値タイプと、「コーヒーモデル」と呼ばれるモデルタイプで構成されるモデルレイヤーがあります。

さて、これはあなたがUIモデルと呼ぶかもしれないものです。

つまり、UIレイヤーで表示するためにデータを保持する場所です。

これは、SwiftUIビューを供給する観測可能なオブジェクトであり、そのすべての更新はメインスレッドで行う必要があります。

アプリケーションのすべてのデータの完全なモデルではない可能性があるため、UIモデルと呼んでいます。

それはあなたのデータモデルの投影またはそのサブセットかもしれません。現時点でUIに表示する必要があるものです。

最後に、バックエンドレイヤーとして考えることができるものがあります。おそらくバックグラウンドで発生する処理は、モデルに入力したり、アプリの外の世界と話したりします。

私たちの場合、それはユーザーのカフェイン摂取量を保存してロードするためにHealthKitへの通信を管理するこのHealthKitControllerタイプによって表されます。

さて、コードを見始める前に、アプリで並行性がどのように管理されているかについて話しましょう。

このアーキテクチャはかなりきれいに見えますが、並行性がどのように処理されるかを重ねると、はるかに乱雑な画像がわかります。

このアプリは基本的に、コードを実行できる3つの同時キューに分かれています。

UIとモデルでの作業は、メインキューで行われます。

このアプリには、バックグラウンドで作業を行うためのディスパッチキューもあります。

そして最後に、HealthKitから結果を返すものなど、完了ハンドラへの特定のコールバックは、任意のキューで行われます。

これはかなり一般的な状況です。

単純なアプリケーションアーキテクチャのように見えるものは、並行性を処理する方法の隠れた複雑さの多くを無視しています。

さて、簡単なネタバレのために。

Swiftの並行性を採用するにあたり、このアドホックな並行性アーキテクチャから、このようなものに移行します。

私たちは、メインアクターと呼ばれるものにUIビューとモデルを置くつもりです。

バックグラウンドで動作する新しいアクターを作成し、これらのタイプはasync/await機能を使用して互いにスレッドセーフ値を渡します。

完了したら、並行性アーキテクチャは、型アーキテクチャと同じくらい明確で説明しやすいものでなければなりません。

ここでは、「async/await」や「actors」など、馴染みのない用語をいくつか使用しましたが、コードで使用するときに簡単に説明します。

しかし、これらの機能のより詳細な説明のために、はるかに詳細に入る他のいくつかの講演があります。

それでは、全体的なアーキテクチャを見たので、コードに飛び込みましょう。

ここにはさまざまなファイルがあります。

まず、いくつかのSwift UIビュー。

そして、ウォッチコンプリケーションコントローラーの拡張デリゲートがあります。

カフェインドリンクを表すシンプルなモデルタイプと、これらのドリンクの配列を保持するCoffeeData UIモデルがあります。

そして最後に、HealthKitControllerがあります。

そして、このレイヤーでは、Swiftの新しい並行性機能のいくつかをアプリに導入し始めます。

HealthKitControllerには、完了ハンドラを取るHealthKit SDKへのいくつかの異なる呼び出しが含まれています。

まず、このコントローラーの保存操作を見てみましょう。

それで、Control-6を押すと、このファイル内の関数のリストが表示され、保存操作に進みます。

さて、新しい並行性機能に入る前に、今日はSwiftのスレッドの安全性について少し話しましょう。

このコードは、いくつかの変数にアクセスし、利用可能で保存します。

さて、この関数ではこれらの変数だけを読んでいるように見えます。

それは安全ですか?

まあ、いいえ、他のコードが同時に彼らに書き込むことができれば、そうではありません。

このコードがスレッドセーフかどうかを知るには、この機能を見るだけでなく、より多くの情報が必要です。

ディスパッチキューやロックは使用されていないので、このコードをスレッドセーフにするものは何でも、それがそうであると仮定すると、他の場所にある必要があります。

呼び出し者は、キューを介して保存するためにすべての呼び出しをシリアル化するかもしれません。

あるいは、アプリは何らかの形で構築されているので、大丈夫かもしれません。

しかし、この機能を見るだけではわかりません。

それを行うことができること - この機能を見て、私のプログラムの他の部分を見に行かなくても特定のことを知ることは、私たちがローカル推論と呼ぶものであり、それはSwiftにとって本当に重要な目標です。

例えば、スウィフトは価値タイプに重点を置いていますが、局所的な推論に関するものです。

参照型とは異なり、渡された値型がプログラムの他の場所で変異していることを心配する必要はありません。

Swift 5.5で並行性のために導入されている多くの言語機能は、コードについてローカルに推論するより多くの機会を与えることです。

さて、たまたま、この関数は完全にスレッドセーフですが、私はそれを自分で理解しました。コンパイラはこれらの問題を見つけるのに役立ちません。

そこで、ここでは、affeineSampleをユーザーの健康データに保存するためのHealthKit SDKへの呼び出しがあります。

そして、これは完了ハンドラを取り、その完了ハンドラは成功またはエラーの2つの値を取ります。

操作が成功した場合、エラーはありません。エラーはnilになります。

これは、ステータスを確認し、必要に応じて、ここでオプションのエラーをアンラップすることを覚えておく必要があることを意味します。

さて、これは通常、Swiftでエラーを処理する方法ではありません。

これは、失敗を投げることができる方法としてはるかに良いでしょう。

しかし、そのアプローチは完了ハンドラーでは機能しません。

しかし今、非同期メソッドを使用すると、スローできる非同期関数を持つことができます。

このHealthKit保存方法は、まさにそれを行う非同期の同等のものを持っているので、それを使用することに切り替えましょう。

これを行うには、まず完了ハンドラを削除し、メソッド呼び出しの前に「await」と書きます。

これは、それが非同期関数呼び出しであり、この時点でコードが一時停止し、他のコードの実行を許可することを思い出させます。

これが重要な理由については、少し後で戻ってきます。

したがって、コンパイルすると、これをやった今、コンパイラが「試行」が必要だと言っていることがわかります。

そして、これは非同期関数の大きな利点です。彼らは投げることができます。

オプションのエラーをチェックすることを覚えておく必要はもうありません。

そのため、このメソッド呼び出しの前に「試行」を追加でき、すぐにエラーを処理したいと考えています。

だから、私たちはこの呼び出しをdoブロックでラップします...

そして、エラーをキャッチします。

このガードを取り外すことができます。

そして今、私たちはエラーをキャッチしているので、それはもはやオプションではないので、アンラップを削除することができます。

これはまた、ハッピーパスを一番上に保つためにコードを並べ替えて、成功ロギングラインをセーブのすぐ下に移動し、キャッシュ内のエラーロギングを処理できることを意味します。

保存は値を返さないことに注意してください。

成功/失敗を返すことは、エラーと本当に重複していたので、私たちの新しい関数はスローするか、成功するかのどちらかです。

Try-catchを追加したので、コンパイラからもう1つのエラーが発生しています。

非同期関数を呼び出していますが、同期関数内から呼び出しています。

これはうまくいきません。

非同期関数には、同期関数にはない機能があります。待機中に実行中のスレッドの制御を放棄する機能です。

これを行うには、スタックフレームを処理する別の方法があり、これは同期機能と互換性がありません。

したがって、1つのオプションは、代わりにこの関数を非同期にすることです。

そのため、関数定義の後に非同期キーワードを追加するだけです。

そして今、このファイルはコンパイルされます。

しかし、プロジェクト全体はまだコンパイルされていません。

この関数を非同期にすることで、問題が呼び出されるレベルに押し上げられた。

私のデータモデルでは、この関数が非同期ではないため、同じコンパイラエラーが発生しています。

今、私はチェーンを上り続けることができますが、今のところ、変更をローカライズし続けるための別のテクニックを見てみましょう。

非同期関数を呼び出すには、非同期関数を呼び出すことが許可される新しい非同期タスクをスピンオフします。

この非同期タスクは、グローバルディスパッチキューで非同期を呼び出すのと非常によく似ています。

ブロックが同時に実行されるため、そこから外部関数に値を返すことはできません。

したがって、切り離された閉鎖で何をするにしても、自己完結型である必要があります。

この場合、saveを呼び出すだけで、値は返されないので、問題ありません。

また、他のスレッドから同時に変異する可能性のあるグローバル状態に触れないように注意する必要があります。

そして、これは、保存が完全にスレッドセーフであることに関連する場所です。そうしないと、この新しいタスクを追加することで、誤って新しいレース条件を導入する可能性があります。

それを非同期タスクに入れたので、待ち望んでいた関数がコンパイルされ、このアプリでのasync/awaitの最初の使用を終えたので、今すぐ実行できます。

これらのリファクタリングのもう1つを行い、今回は、非同期に移行するときに他のテクニックを見てみましょう。

それでは、ユーザーの健康データへのアクセス許可を要求する呼び出しを見てみましょう。

これは同様に、完了ハンドラでHealthKitを呼び出します。

しかし、以前とは異なり、この関数はそれ自体が完了ハンドラを取ります。

私がやろうとしているのは、完了ハンドラのバージョンを維持しながら、非同期になる関数の2番目のバージョンを作成することです。

そうすれば、完了ハンドラで呼び出すコードの他の部分は、リファクタリング中に作業を続けることができます。

「Create Async Alternative」リファクタリングアクションを使用することで、これは簡単にできます。

これは、コマンド-Shift-Aで表示できるコードアクションメニューで利用でき、非同期の代替オプションを追加します。

したがって、これは元の呼び出しの2番目の非同期バージョンを追加しました。

そして、元の完了ハンドラコードを、新しい非同期タスクを作成するコードに置き換えました...

...そして、関数の非同期バージョンを待つだけです。

非同期リファクタリングにより、元のリファクタリングに非推奨の警告が追加されたことに注意してください。

これらは、この新しい非同期バージョンを呼び出すためにリファクタリングから次に恩恵を受けることができる私のコードの一部に私を導くのに役立ちます。

取り消して、元の完了ハンドラーバージョンに戻りましょう。

このrequestAuthorizationコールバック内では、このコールバックは任意のスレッドで発生する可能性があります。

そのため、その中のコードはスレッドセーフであることを知っておく必要があります。

しかし、私はそうは思いません。

ここでのこの割り当ては、他のスレッドでこの値を読み取る他のコードと同時に発生する可能性があります。

そして、このコードには局所的な推論の欠如の別の例があります。

その割り当ての後、この完了ハンドラが呼び出され、その完了ハンドラ内のコードがスレッドセーフかどうかはわかりません。

この機能へのすべてのコールサイトを見て、完了ハンドラがどのように書かれているかを見て、これがOKであることを知る必要があります。

では、もう一度やり直して、リファクタリングされたバージョンを見てみましょう。

さて、非同期タスクは、ディスパッチコールバックに似た任意のスレッドでも実行されることを忘れないでください。

したがって、この転送バージョンは、以前に持っていた完了ハンドラバージョンと同様の問題を抱えています。

私たちはまだコードをより安全にしていません。

コードにアクターを導入することで、すぐにこれを修正します。

しかし、今のところ、この関数を非同期に変換したからといって、競合状態から解放されるわけではないことに注意する必要があります。

実際、非同期機能を導入するためにリファクタリングを実行する場合のみ、コードに新しい競合条件を導入するリスクを認識する必要があります。

では、この新しい非同期関数を見てみましょう。

リファクタリングアクションは、このSDK APIの新しい非同期バージョンを呼び出すために、すでに完了ハンドラで呼び出しを変換しています。

しかし、この関数を非同期に変換すると、興味深いことが強調されています。

ここでは、完了ハンドラ技術を使用していたとき、完了ハンドラを呼び出すことなくリターンがありました。

そして、これはおそらくバグでした。

発信者はぶら下がったままになっていただろう。

しかし、非同期関数では、値を返す必要があるため、コンパイルエラーが発生しており、失敗に対してfalseを返すだけで解決できます。

そして、以前と同じように、この新しい非同期バージョンのrequestAuthorizationは実際には値を返すことはなく、成功するか、スローするかのどちらかです。

したがって、この戻り値を削除するだけです。

そして、代わりにこの道で、私たちはそれが成功したと仮定する必要があります...

...そして、失敗のパスでは、falseを返す必要があります。

今コンパイルしようとすると、他の場所の古いコードがまだ完了ハンドラーバージョンを呼び続けることができるため、プロジェクトがコンパイルされ、それを行うときにこれらの非推奨の警告が表示され、リファクタリングしたいかもしれない次の場所につながる可能性があります。

さて、もう1つの非同期変換をしましょう。

HealthKitからデータをロードする機能を見つけましょう。

以前と同じように、古いコードを呼び出すためのスタブを作成することから始めます。

次に、非同期バージョンに移動すると、ちなみに、これはオプションの完了ハンドラを取ります。これと同等の非同期は、この関数に破棄可能な結果をもたらすことです。

次に、下に移動し、完了ハンドラの使用をリターンに置き換えます。

たとえば、この完了ハンドラを削除して、falseを返すことができます。

しかし、もう少し進むと、私たちは障害にぶつかり始め、それはHealthKitクエリAPIの配置方法に関係しています。

ここでは、完了ハンドラがありますが、このクエリオブジェクトにあります。実際、私が待ちたいのは、関数の下部にあるクエリの実行です。

ちなみに、この関数の上下のホッピングは、async/awaitが解決に役立つもう一つのことです。

だから私がしたいのは、クエリを作成してから実行する単一の非同期関数を作成することです。

私たちは今、継続と呼ばれる技術を使ってそれを行うつもりです。

そこで、この関数の一番上に戻り、「queryHealthKit」というヘルパー関数を作成します。

既存の機能内でこの作業をすべて行うことができますが、少し乱雑になるかもしれないので、ヘルパー機能で別々にしておくのが好きです。

この関数は非同期になるので、それを待つことができ、クエリ操作が失敗する可能性があるため、スローされます。

そして、この関数は、現在クエリの完了ハンドラに渡されている有用な値を返します。

だから、私はクエリを実行するためのロジックを取り、それをカットし、ヘルパー関数に移動するつもりです。

そして、私はまた、クエリの実行を取り、それを移動するつもりです。

さて、このコードを何とか反転して、完了ハンドラーを待って、新しい非同期関数から完了ハンドラーに渡されたこれらの値を返す必要があります。

そして、これは私が継続を使用する場所です。

したがって、この関数では、withCheckedThrowingContinuation関数の呼び出しを待とうとした結果を返します。

そして、これは継続を取るブロックを取ります。

そして、このコードをそのブロック内に移動し、次にブロック内で、継続を使用してこの関数からデータを渡すか、継続を使用してここでエラーのスローを再開します。

...または...

...受信した値を完了ハンドラに返すのを再開します。

この待機可能な関数がわかったので、元のコードで使用できます。

そこで、関数を呼び出す結果を割り当てます。

そして、スローされる可能性のあるエラーを処理する必要があります。

実際、実際には、私はここに行って、この少しのロギングを取り、ハンドラーでそれを行うつもりです。

そして、このすべての成功コードを幸せな道に移す必要があります。

最後に、この閉鎖に対処する必要があります。

ここでは、メインスレッドに戻って非同期のディスパッチを使用しています。

しかし、私たちは完了ハンドラを捨てたので、この情報を使用してメインスレッドに中継する方法はありません。

私たちは別の方法が必要です。

これを解決するために、私たちは俳優を最初に利用するつもりです。

Swiftの並行性モデルには、メインスレッド上のすべての操作を調整するメインアクターと呼ばれるグローバルアクターがあります。

ディスパッチmain.async呼び出しを、メインアクターの実行関数の呼び出しに置き換えることができます。

そして、これはメインアクターで実行するためにコードのブロックを必要とします。

実行は非同期関数なので、それを待つ必要があります。

メインスレッドがこの操作を処理する準備が整うまで、この機能を一時停止する必要がある可能性があるため、それを待つ必要があります。

しかし、それを待っているので、完了ハンドラを削除し、代わりに値を返すことができます。

さて、最後に、コンパイラは今、キャプチャされた変数について私にエラーを与えています。

これは、非同期関数内でのみ発生する新しいエラーです。

Swiftのクロージャは参照によって変数をキャプチャするため、可変変数（この場合はnewDrinks配列）をキャプチャすると、共有可変状態の可能性が作成され、それが競合条件の源になる可能性があります。

したがって、これを行うときは、この値のコピーを作成していることを確認する必要があります。

これを行う1つの方法は、このようにクロージャのキャプチャリストにnewDrinksを追加することです。

しかし、多くの場合、そもそも可変変数を持たないことで、この問題を回避する方が良いです。

ここでは、代わりに上記のコードを変更することでこれを行うことができます。

サンプルはオプションなので、このように書かれています。

しかし、代わりにできることは、newDrinksを不変の値に変更し、ifブランチで値を設定するか、「else」を追加して空の配列に設定することです。

必要に応じて、ゼロ合体演算子でこれを行うこともできます。

この値はvarではなくletで宣言されるようになったため、不変であり、追加のキャプチャを行うことなく問題を解決します。

それでは、メインスレッドで呼び出す必要があるこの関数を見て、メインアクターについて話し続けましょう。

この関数の上部には、本当に素晴らしいアイデアがあります。関数がメインスレッドで正しく実行されているというアサーションがあります。

間違いを犯し、メインスレッドへのディスパッチ非同期でラップせずにこの関数を呼び出した場合、デバッグビルドでエラーが発生し、既存のコードの一部でこのプラクティスを採用する必要があります。

しかし、このアプローチにはいくつかの制限があります。

必要な場所にアサートを置くのを忘れる可能性があり、保存されたプロパティへのアクセスをアサートすることはできません、または少なくとも多くのボイラープレートなしではアサートすることはできません。

コンパイラがこれらのルールのいくつかを適用できる方がはるかに良いので、このような間違いを犯すことはできません。

そして、それが私たちが主役を使う方法です。

「@MainActor」で関数に注釈を付けることができます。

そして、この関数が実行される前に、発信者がメインアクターに切り替える必要があります。

これをやったので、コンパイラはこの関数をメインスレッド以外の場所で呼び出すことができないため、アサーションを削除できます。

発信者に戻り、このコールをこのMainActor.runブロックの外に移動することで、これが機能していることを証明できます。

そして、コンパイラが教えてくれます、いいえ、私たちは主役ではないので、ここからそれを呼ぶことはできません。

この機能について考える方法は次のとおりです。オプションの値によく似ています。

以前はポインタのような値を持っていて、nilのチェックを覚えなければなりませんでしたが、忘れやすく、コンパイラにこのチェックが常にいくつかの言語構文砂糖と一緒に行われるようにして簡単にする方がはるかに良いです。

ここでは、同様のことをやっていますが、ゼロチェックを強制する代わりに、あなたが実行している俳優を強制しています。

この機能を主役に置いたので、厳密に言えば、このMainActor.runはもう必要ありません。

俳優の外にいる場合は、いつでもその俳優を待つことで機能を実行できます。

そして実際、それはコンパイラがここで私たちに言っていることです。

この機能を実行するためにメインアクターに切り替えるには、awaitキーワードが必要だと言っています。

したがって、それを追加すると、この呼び出しが実行ブロック内に入っていなくてもコードがコンパイルされます。

ここでは、同期関数でawaitを使用しています - updateModelは同期です - しかし、awaitは、私たちがいる関数がメインアクターに自分自身を取得するために一時停止する必要があるかもしれないことを示しています。

これはDispatchQueue.sync呼び出しを行うのと似ていると考えてください。waitを除いて、関数はブロックする代わりに一時停止し、メインスレッドへの呼び出しが完了した後に再開します。

だから、私たちはもうここでそれを必要としませんが、このMainActor.runテクニックは別の理由でまだ重要です。

待機するたびに、関数が一時停止し、他のコードが実行される可能性があります。

それが待つポイントです:ブロックするのではなく、他のコードを実行させることです。

この場合、待つ関数は1つしかなかったので、実際には問題ではありませんが、メインスレッドで複数の呼び出しを実行したい場合があります。

たとえば、テーブルビューのエントリを更新するなど、UIの更新に取り組んでいる場合、実行する操作の間にメインの実行ループを回したくない場合があります。

その場合、MainActor.runを使用して、メインアクターへの複数の呼び出しをグループ化して、それぞれがその間に中断することなく実行されるようにします。

そのため、メインアクターを使用して、メインスレッドで実行する必要があるコードを保護しています。

しかし、このクラスの他のコードはどうですか?

特に、ここで割り当てられたクエリアンカーなど、ローカル変数を変異させるコード。

それらがレース条件から自由であることをどのように保証できますか?

または、1つの方法は、メインアクターにHealthKitControllerのすべてを置くことです。

HealthKitコントローラ定義に移動し、個々のメソッドではなくクラスに「@MainActor」と書くと、このタイプのすべてのメソッドが保護され、その上に保存されたすべてのプロパティがメインスレッドで調整されます。

そして、このような簡単なアプリケーションの場合、それはおそらくOKの選択でしょう。

しかし、それも少し間違っているようです。

このHealthKitControllerは本当に私たちのアプリのバックエンドです。メインスレッドですべての作業を行う必要はないようです。

私たちは、UIに焦点を当てた活動を行うために、そのスレッドを自由に残したい。

代わりに、このクラス自体を俳優に変更することができます。

グローバルアクターであるメインアクターとは異なり、このアクタータイプは複数回インスタンス化できます。

私のプロジェクトでは、私はまだそれらの1つだけを作成するつもりですが、同じ俳優の複数のコピーをインスタンス化することができる俳優の他の多くの用途があります。

たとえば、チャットサーバーの各部屋を独自のアクターにすることができます。

それで、このクラスをアクターにしたので、コンパイラが何を言うか見てみましょう。

わかりました。コンパイルエラーが発生しています。

では、ここで一時停止して、コンパイラのエラーについて話しましょう。

これらのエラーは、コードを新しい並行性モデルに移行するときに更新する必要があるコードの場所へとあなたを導いています。

これらのエラーが発生したら、彼らがあなたに言っていることを理解していることを確認してください。

問題を解決する方法や理由がわからないときに、修正ボタンをマッシュする誘惑に抵抗してください。

警戒すべきことの1つは、エラーのカスケードに入ることです。

時々、先ほどのようにクラスをアクターに変換したり、メソッドを非同期にしたりするなど、変更を加えると、コンパイラエラーが発生します。

したがって、これらのエラーのサイトに移動し、そのメソッドを非同期にしたり、メインアクターに置いたりするなど、それらのエラーを修正するためにより多くの変更を加えるのが魅力的です。

問題は、これがさらに多くのエラーにつながる可能性があり、すぐに圧倒される可能性があることです。

代わりに、このウォークスルーで使用しているようなテクニックを使用し、変更を分離して、プロジェクトをコンパイルして実行して、一度に1ステップずつ実行してみてください。

後で削除してしまう場合でも、古いコードが機能し続けることができるようにシムを追加します。

そうすれば、ポイントから徐々に移動し、進むにつれてコードを整理することができます。

ちなみに、私がここでやったことは、まずHealthKitControllerのメソッドを非同期に変換してからアクターにすることです。

そして、俳優の変換から始めるのではなく、そのように行うと最もうまくいくと思います。

さて、これらのエラーにジャンプして見てみましょう。

彼らは私たちが主役に置いた機能についてここにいます。

そして、この関数では、新しいHealthKitControllerアクターの保存されたプロパティ、モデルプロパティに触れているので、これは理にかなっています。

アクターはその状態を保護し、メインアクターに明示的に配置したこの関数など、アクターではなく、その格納されたプロパティに触れさせません。

この関数を見ると、それが触れるアクターの唯一の状態はモデルオブジェクトのように見えます。

他のすべては関数引数として渡されます。

そして私にとって、これはこの機能がモデルに属していることを示唆しています。ここのモデルは実際には自己であるべきです。

では、モデルに移動しましょう。

そのため、この機能を取り、カットし、CoffeeData UIモデルに移動し、貼り付けることができます。

プライベートではなく内部になるので、HealthKitControllerから呼び出すことができます。

そして、モデルへのすべての参照を通過して削除する必要があります。なぜなら、それは今自己だからです。

最後に、私たちはそれが呼ばれていた場所に行く必要があります...

...そして、ここでselfをモデルへの呼び出しに置き換えます。

これで、このHealthKitControllerファイルがコンパイルされ、他のファイルから新しいエラーが発生します。

それらのエラーを見てみましょう。

ここでは、この関数を非同期に書き換えたにもかかわらず、完了ハンドラを渡し続けることができるように、以前に呼び出した完了ハンドラシムを呼び出しています。

これらの機能は現在、俳優によって保護されているので、直接呼び出すことはできません。

しかし、私たちが彼らを見ると、彼らは俳優の状態の他の部分に触れません。

彼らがやっているのは、タスクをスピンオフしてから、関数の非同期バージョンへの呼び出しを待つことだけです。

彼らは俳優の内部状態のどの部分にも触れないので、私はそれらを「nonisolated」と呼ばれるものとしてマークすることができます。

ここでも同じことをしてください。

何かを非分離としてマークすると、分離された状態のいずれにも触れないことをコンパイラに伝えるため、この関数はどこからでも呼び出すことができます。

演者への切り替えは、関数の非同期バージョンへの呼び出しを待つと、実際には自動的に行われます。

コンパイラは、この非分離された主張が真であることを確認することに注意してください。

承認ステータスを印刷するなど、アクターの状態にアクセスしようとすると、コンパイラは私を停止します。

だから今、私はHealthKitControllerを人種条件から内部状態を保護するアクターに変換する作業を完了しました。

次に、これらの非推奨のブレッドクラムに従って、次のファイル（CoffeeDataモデルタイプ）に取り組みましょう。

現在、このクラスはObservableObjectを実装し、公開されたプロパティを持っています。

SwiftUIビューに公開されたプロパティの更新は、メインスレッドで行う必要があるため、このクラスはおそらくメインアクターに置くのに適した候補です。

しかし、バックグラウンドでいくつかの作業を行うためのこのバックグラウンドDispatchQueueもあります。

それがどのように使われているかを見てみましょう。 

そして、それはロードとセーブの2つの機能です。

それは理にかなっています。あなたはおそらくメインスレッドでロードとセーブをしたくないでしょう。

このようなパターンを見ると、キューが特定のアクティビティを調整するために使用されていますが、クラスの残りの部分はメインスレッドにある必要があります。これは、その背景コードを別のアクターに因数分解したいというサインです。

だから、そうしましょう。

では、ファイルの一番上に行って、新しいプライベートアクターを作りましょう。

...私たちは「CoffeeDataStore」と呼びます。

そして、別のウィンドウでCoffeeDataを開きましょう。

そして、私たちの新しい俳優にコードを移動し始めます。

だから、私たちはそれに独自のロガーを与えることができます。

そして、俳優がいつ使用されているかがわかるように、カテゴリを微調整しましょう。

そして次に、このDispatchQueueの代わりに、新しい俳優のコピーをインスタンス化します。

次に、保存操作に行き、それを移動しましょう。

だから、私たちはこの機能を取ることができます...

...ここからそれをカットして、俳優に移します。

コンパイルして、どのような問題が発生するかを見ることから始めましょう。

まず、この現在のDrinksプロパティがあります。

これは、このメソッドをモデルからアクターに移動する前のモデルタイプのプロパティでした。

では、今どのようにアクセスできますか?

さて、俳優が情報を中継する方法は、お互いに値を渡すことです。

したがって、この関数はcurrentDrinksを引数として取る必要があります。

保存するこの引数は、モデルタイプによって渡された保存するcurrentDrinksのリストを受け取ります。

それで解決します。

次に、保存された飲み物。

これは、何も変わっていないときに不必要に保存しないように、最後に保存された値のコピーです。

この値は保存関数と負荷関数の両方によって変異するので、間違いなくアクターによって保護される必要があります。

だから、私たちのモデルでそれを見つけましょう...

...そしてそれを動かしてください。

わかった、次は何?

さて、このプロパティdataURLは、実際にはロードと保存操作だけで使用されているので、アクターのプライベートヘルパーになるように移動できます。

さて、解決すべき最後の問題です。

さて、ここでエラーが発生しており、見てみると、俳優からいくつかの状態をキャプチャしているクロージャがあるように見えるので、それを修正する必要があります。

では、なぜここに閉鎖があるのですか?

まあ、見下ろすと、同じコードが2か所で呼び出されているからです。

そして、コンパイラが私たちにとって本当に興味深いものにフラグを立てたことが判明しました。

このコードが行っていることは、時計の拡張機能がバックグラウンドで実行されているかどうかを確認することです。

そして、アイデアは、すでにバックグラウンドで実行されている場合は、バックグラウンドキューに入らないでください。メインスレッドにとどまり、同期して保存するタスクを実行するだけです。

しかし、これは正しくないようです。

アプリがバックグラウンドで実行されている場合でも、保存などのI/O操作を実行するためにメインスレッドをブロックしてはいけません。

なぜアプリはこれを行うのですか?

さて、保存操作が呼び出されている場所まで追跡することができます。

currentDrinksのdidSetから呼び出されています。

そして、プロパティが割り当てられるたびに、新しい値を保存するように発火します。

さて、didSetsはとても便利ですが、少し魅力的すぎるかもしれません。

現在のDrinksプロパティのすべての発信者を見てみましょう。

ここまでドリルダウンしたら...

...保存操作は、WatchKit拡張機能からバックグラウンドタスクを処理するための呼び出しであるこの関数から呼び出される方法のために、最終的に同期していることがわかります。

現在、このハンドルAPIには契約があります。

すべての作業を行うことになっていて、すべての作業が完了したら、このsetTaskCompletedWithSnapshotメソッドを呼び出します。

そして、時計アプリが一時停止されるため、これを呼び出すときにすべての作業が完了することを保証する必要があります。

完了したと言ったときに、私たちの保存操作のようなI/O操作がまだ実行されていることはできません。

これは、非同期がコード全体でグローバルな推論を強制する方法の完璧な例です。

ここで何が起こっているのかを視覚化しましょう。

HealthKit関数からロードを呼び出すhandle(backgroundTasks:)から始めます。

これには完了ハンドラが必要です。

しかし、その後、同期的に実行されるupdateModel（）に切り替えて、同期的に保存するdidSetを同期的に呼び出します。

これが完了すると、完了ハンドラが呼び出され、すべて完了したことをWatchKitに通知します。

メインスレッドで同期I/Oを実行することを強制するのは、同期部分です。

どうすればこれを修正できますか?

完了ハンドラで修正するには、現在同期している各メソッドを更新して、完了ハンドラを取る必要があります。

しかし、didSetではそれを行うことはできません。それは引数を取らず、プロパティを更新すると自動的に起動するだけです。

しかし、良いニュースは、関数を同期から非同期に更新する方がはるかに簡単であるため、すべての非同期リファクタリングが報われるということです。

まず、公開されたプロパティ、currentDrinksに移動し、すべての突然変異がこのファイルからのみ起こっていることを知るために、それをプライベート(セット)に変更しましょう。

そして、このdidSet操作を取り、代わりにそのロジックを新しい関数に移動しましょう...

...「drinksUpdated（）」と呼ばれています。

俳優のセーブ操作を呼び出すので、非同期にします。

そして、それは待つ必要があります...

...CoffeeDataストアで、新しいcurrentDrinks値を渡す予定です。

次に、currentDrinksが更新される場所に移動し、その後drinksUpdatedを呼び出す必要があります。

さて、この機能では、注意すべき点が1つあります。

currentDrinksのコピーを取り、それを変異させ、それを書き戻すこの操作は、すべて原子的に行われることが重要です。

そして、これがawaitキーワードが不可欠である理由です。この時点で、この操作が一時停止する可能性があり、他の関数（currentDrinksを更新する可能性のある関数）が実行される可能性があることを示しています。

したがって、待機する前に突然変異とライトバック全体が発生することを確認する必要があります。そうしないと、他の関数が来て、currentDrinksを変異させると、一貫性のない状態につながる可能性があります。

したがって、この関数は非同期である必要があります。

保存操作に移動し、この不要なバックグラウンドとフォアグラウンドブランチを排除し、毎回アクターで操作を行うことができます。

わかりました。最後に、ロード操作を見てみましょう。

ここで、ロジックは、バックグラウンドで実行する必要があるコードと、メインスレッドで実行する必要があるコードに分割されています。

では、まず前半（背景部分）を取り、それを俳優に移しましょう。

今、これを行うと、別の可能性のあるレース条件に気づきます。

ここのsaveValuesはメインキューで変異していましたが、保存操作を覚えている場合は、バックグラウンドキューから読み書きされました。

さて、たまたま、アプリの構築方法、ロードは起動時にしか起こらなかったので、これは大丈夫でした。

しかし、繰り返しますが、それはグローバルな推論に依存しており、将来の変更を行うときに微妙な方法で壊れる可能性のある仮定のようなものです。

俳優にプログラムが常に正しいことを確認させる方がはるかに良いです。

だから、私たちは今それを修正するつもりです。

まず、このキュー管理を削除しましょう...

...機能を再インデントし、この他のキュー管理を削除します。

そして、セーブと同様に、アクターのこのロード関数から値を返すだけで、ロードされた値を渡す方法が必要です。

では、元の負荷に戻りましょう。

そして、私たちはこのロジックを動かしたので、それを削除することができます...

そして、それを待つための呼び出しに置き換えてください...

...俳優からの飲み物を積み込む。

さて、私たちはアクターを待っているので、この機能は非同期である必要があります。

そして、私たちがここにいる間、これらの非推奨の警告をクリーンアップすることができます。

そして最後に、この負荷は非同期になったので、ここで待つ必要があります。

そして、私たちはここでそれを待っているので、タスクを作成する必要があります。

しかし、この時点で、非同期タスクを使用した場合、新しいレース条件を導入する可能性があります。

俳優の外では、この新しいタスクは任意のスレッドで実行されることを忘れないでください。

currentDrinksのように、任意のスレッドから共有状態を変異させるべきではありません。

さて、これを解決する1つの方法は、メインアクターに負荷関数を置くことですが、モデルタイプ全体をメインアクターに移動する方がはるかに良いです。

そこで、CoffeeModelの定義に移動し、モデルタイプに「MainActor」を追加します。

モデルをメインアクターに置くことで、CoffeeDataのプロパティへのすべてのアクセスがメインスレッドから行われることを保証します。

そして、先に述べたように、それは観測可能なオブジェクトであり、公開されたプロパティを持っているので、これは良いことです。

また、SwiftUIに公開されたプロパティは、メインスレッドでのみ更新する必要があります。

また、アクターからの非同期への呼び出しもアクターで実行されることを意味します。

そのため、先ほど追加したような他の「MainActor」アノテーションを削除できます。

だから今、私たちがコンパイルするとき、以前に他のものを俳優に移したときとは異なり、コンパイルエラーが発生しないことに気付くかもしれません。

それは、私たちがモデルに呼び込んでいる場所は、SwiftUIビューのようなものだからです。

例えば、DrinkListViewに行きましょう。

これで、このタイプは画面にボタンのリストを表示します。

そして、それは私たちのモデルタイプにあるaddDrinkを呼び出します。

しかし、このDrinkListView自体はメインアクターでもあります。

そして、その方法は...

...待たずにCoffeeDataモデルを呼び出すことができます。

このSwiftUIビューがメインアクターにあると判断するものは何ですか?

さて、それはここでのEnvironmentObjectの使用から推測されます。

環境オブジェクトや観察されたオブジェクトなど、共有状態にアクセスするSwiftUIビューは、常にメインアクターにあります。

他の場所では...

...また、この拡張デリゲートコールからモデルにアクセスしています。

この拡張デリゲートはメインスレッドで呼び出されることが保証されているため、ウォッチキットによってメインアクターで実行されていると注釈が付けられているため、モデルタイプを直接呼び出すこともできます。

最後に、私たちがここにいるので、このメソッドをリファクタリングして、この非推奨の完了ハンドラーの使用を取り除きましょう。

代わりに、このセクションを新しい非同期タスクでラップすることができます。

このハンドラはメインスレッドで実行されているため、タスクを作成すると、そのタスクもメインスレッドで実行されます。

そして、この新しいタスクの中で、私たちは今待つことができます...

...HealthKitから新しいデータをロードするための呼び出し。

そして、完了ハンドラを取り除くことについて本当に素晴らしいことは、関数を一緒に構成できるようになったことです。

したがって、必要に応じて、この待機をifステートメントに直接移動できます。

この関数呼び出しが戻ると、その中で保存操作を待つため、すべての作業が完了していることを知っています。

そして、すべてのI/O操作を完了したことを知って、自信を持ってbackground.Task.setTaskCompletedを呼び出すことができます。

私たちは今、これ以上の作業を完了する前に非同期操作を待つために、この素敵で構造化されたトップダウンのアプローチを持っています。

ちなみに、並行性に対するこの構造化されたアプローチは、Swiftの並行性機能のもう1つの本当に重要な部分です。

詳細については、関連するトークをご覧ください。この機能を利用して、複数の非同期操作が完了するのを待つなど、より複雑な例を構成する方法について説明します。

このトークを見ている間、これらの新機能のいくつかがどのように機能するかを正確に疑問に思った場合は、技術のいくつかを詳細に探求する私たちのアンダーザフードトークをチェックしてください。

では、要約しましょう。

私たちは、サウンドタイプのアーキテクチャを持つが、見つけるのが本当に難しいいくつかの隠された競合条件を持つ複雑な並行性アーキテクチャを持ついくつかのコードを取りました。

そして、新しい並行性機能の助けを借りて、並行性とタイプアーキテクチャがうまく整列するように再設計しました。

そして、コンパイラは、途中でいくつかの隠された潜在的な競合条件を見つけるのに役立ちました。

Swift 5.5には、タスクグループとの構造化された並行性、非同期シーケンス、SDK内のいくつかの素晴らしい新しい非同期APIなど、私たちがカバーしていないことがたくさんあります。

また、このプロジェクトで行わなかったリファクタリングもいくつかありますが、自分で試してみたいかもしれません。

これらのテクニックを学ぶ最善の方法は、自分のアプリで試してみることなので、楽しんで、これらのよりクリーンで安全なコーディング方法を楽しんでください。

♪