10253

♪ベース音楽の演奏♪

♪

Becca Royal-Gordon:こんにちは、私はSwift CompilerチームのBeccaです。

今日は、SwiftでDSLを実装する方法について話します。

その用語を聞いたことがないなら、DSLはドメイン固有の言語であり、名前が新しい場合でも、おそらく以前に使用したことがあるでしょう。

DSLが実際に何であり、Swiftでどのように見えるかを説明することから始めます。

次に、結果ビルダーがどのように機能するかを説明します。

これらは、Swift DSLを実装するために使用される主な機能の1つです。

その後、サンプルアプリFrutaの一部にシンプルなDSLを設計する方法を説明します。

最後に、Frutaのサンプルコードにある実装の書き方を紹介します。

しかし、その頭字語をもう少しうまく説明することから始めましょう。

DSLは、「ドメイン」と呼ばれる特定の領域で動作するプログラム用に設計されたミニチュアプログラミング言語の一種です。

言語は特定の種類の作業を念頭に置いて設計されているため、そのような作業を容易にする特別な機能を持つことができます。

したがって、汎用言語の代わりにDSLのコードを書くときは、正確な問題に固有のものを書くだけで済みます。

多くのDSLは宣言的です。

つまり、あなたは本当に問題を解決するための正確な指示を書いていません。それはあなたが言語で問題を説明しているようなもので、それはあなたのためにそれを解決します。

これを行う伝統的な方法は「スタンドアロンDSL」と呼ばれています。

言語全体をゼロから設計し、インタプリタやコンパイラを書きます。

組み込みDSLは、より現代的な代替手段です。

埋め込みDSLでは、Swiftのようなホスト言語の組み込み機能を使用して、DSLの暗黙の動作をコードの一部に追加し、ホスト言語をドメインに合わせたものに効果的に変更します。

これは、すでに構文の基本を決定し、すでにコンパイラを持っている既存の言語から始めているので、言語全体を設計してコンパイラを書くよりも明らかに簡単です。

また、DSLコードと非DSLコードを混在させるのも簡単になります。

多くの場合、DSLを使用して、はるかに大きなアプリの一部にすぎない問題を解決したいと考えています。

スタンドアロンのDSLを書いている場合は、ある言語から別の言語に電話をかける方法を設計する必要があります。

埋め込みDSLでは、DSLに書き込まれた部分はアプリの残りの部分に対して通常のコードのように見えるので、相互運用がはるかに簡単になります。

組み込みDSLは、ホスト言語用に設計されたツールを使用することもできます。

あなたはすでにSwift用のデバッガとエディタを持っており、それらはSwift DSLではうまく機能します。スタンドアロンDSL用にそれらが欲しい場合は、自分で書く必要があります。

そして、あなたはホスト言語から始めているので、すでにその言語を知っているクライアントは学ぶことがはるかに少ないです。

彼らはすでに変数を宣言する方法、または「else if」にスペースがあるかどうかを知っています。彼らが学ぶ必要があるのは、言語をどのようにカスタマイズしたかだけです。

Swiftは組み込みDSLをサポートするように設計されています。

実際、SwiftUIを使用したことがあるなら、すでに使用しています。

SwiftUIビューDSLは、デバイスの画面上のビューのレイアウトを記述することを前提としています。

したがって、SwiftUI DSLで書くとき、カスタムコードは単にビューを作成し、DSLはSwiftUIが処理するためのツリーを構築する責任があります。

DSLの価値を理解するには、代わりに通常のSwiftでビューを書いた場合、SwiftUIがどのようなものになるかを考えてください。

ビューを作成し、変更し、他のビューに追加し、最後に1つを返す必要があります。

個々のビューを保持するためにいたるところに一時的な変数を作成し、結果はDSLと同じようにビューがネストされる方法を本当に伝えません。

あなたはより多くのコードを書くだろうが、それはより少ない意味を伝えるだろう。

対照的に、SwiftUI DSLは、これらの退屈な詳細をすべて暗黙的にします。

ビューを記述するのがあなたの仕事です。あなたが記述しているビューを収集し、それらを表示する方法を理解するのがDSLの仕事です。

しかし、DSLは実装に余分な労力を費やし、使用には余分な労力を費やします。

では、いつ作成したいですか?

さて、難しいルールはありませんが、ここにあなたが1つを使用したいと思うかもしれないいくつかの兆候があります。

バニラスウィフトを使用する仕組みがコードの意味を不明瞭にする場所を探してください。

何かを変更するたびにカンマと角括弧と括弧の再配置に半分の時間を費やしたり、制御フローに対応するために一時的な配列に物事を追加する必要があります。

コードをどうするかについての指示を直接書くのではなく、コードの別の部分に何かを記述するのが最善のアプローチである状況を探してください。

サーバーサイドのWebフレームワークのように、サポートするURLのハンドラーを登録する領域があるかもしれません。

追加ハンドラメソッドを何度も呼び出す代わりに、クライアントが各URLとそのハンドラを宣言するためのDSLを設計し、フレームワークは自動的にそれらを登録することができます。

主な仕事がプログラミングではない人々によって維持されるコードの一部を探してください。

例えば、テキストアドベンチャーゲームを書いていると想像してみてください。少数の開発者だけがほとんどのコードで作業しますが、部屋のマップはゲームデザイナーによって更新され、NPCダイアログはライターによって追加されます。

たぶん、DSLは彼らの仕事を楽にするでしょう。

そして、DSLから多くの走行距離を得る状況を探してください。

図書館は、多くの異なるクライアントによって使用されるため、良い例です。

しかし、良いDSLは、あなたがたくさん定義するプロジェクト内の何かを処理したり、頻繁に読んだり更新したりしなければならないものでさえ、それをできるだけ簡単にすることもできます。

DSLを作成する理由が何であれ、設計と実装にいくらかの努力がかかるだけでなく、クライアントが学ぶのにもいくらかの努力がかかるという事実とのバランスを取る必要があります。

メソッドと配列リテラルがDSLとほぼ同じであるならば、Swiftプログラマーはすでにそれらの使用方法を正確に知っているので、それらはしばしば正しい答えです。

しかし、時には、SwiftUIのように、DSLが正しい答えです。

それで、どうやって作るの?

さて、SwiftUI DSLを構築するためにSwiftの機能がどのように一緒に使用されるかを分解してみましょう。

Swiftの一般的にクリーンな構文に加えて、SwiftUI DSLは4つのことを利用します。

プロパティラッパー。

これにより、クライアントはDSLの動作に関連付けられた変数を宣言できます。

末尾の議論。

これにより、DSLは、言語に追加されたカスタム構文のように読む関数または初期化子を提供できます。

結果ビルダー。

これらは、DSLのコードで計算された値を戻り値に収集するので、それらを処理できます。

そして最後に、修飾子スタイルのメソッド。

これらは基本的に、呼び出された値のラップまたは変更されたバージョンを返す単なるメソッドです。結果ビルダーはコードによって計算された値を収集するため、このパターンはそれらと本当にうまく機能します。

さて、プロパティラッパーは2019年からこのセッションの後半ですでにカバーされていたので、今日はそれらについてあまり話すつもりはありません。

しかし、これらの他の3つ、特に結果ビルダーは、このセッションの主要なトピックになります。

末尾のクロージャと修飾子スタイルのメソッドは、多くのSwiftプログラマーが慣れ親しんでいるものですが、結果ビルダーはより舞台裏の機能です。

それでは、彼らと一緒にDSLの構築を開始できるように、彼らがどのように機能するかについて話しましょう。

結果ビルダーは、DSLで作成された値を収集し、言語が望むデータ構造にそれらを縫い合わせるために使用されます。

それらは、特別な型を宣言し、その型を属性として使用できるという点で、プロパティラッパーに少し似ています。

具体的には、関数やメソッド、計算されたプロパティのゲッター、クロージャなど、戻り値を持つほぼすべての関数本体に結果ビルダーを適用できます。

結果ビルダーを関数本体に適用すると、Swiftは結果ビルダーに静的メソッドへのさまざまな呼び出しを挿入します。

これらは、そうでなければ破棄されていたであろうステートメントの結果をキャプチャすることになります。

したがって、Swiftは通常戻り値を無視し、代わりに結果ビルダーに渡されます。

これらの呼び出しは、最終的に関数本体から返される値を計算します。

したがって、関数を呼び出すと、その関数内のすべてのステートメントを正常に実行し、それらによって生成された値を収集し、それらを単一の値に結合して、クロージャの結果になります。

結果ビルダーはコンパイル時機能であるため、アプリが実行されるOSで動作します。

オープンソースのSwift Evolution提案289からのこの機能の最終バージョンは、Swift 5.4に含まれていたため、4月にXcode 12.5で出荷されました。

しかし、この機能のプロトタイプはその前に利用可能だったので、プロトタイプを使用する古いチュートリアルやライブラリが見られるかもしれません。

それらは「結果ビルダー」ではなく「ファンクションビルダー」と言い、最終的な機能と完全に一致しないかもしれません。

そこで、私は以前にSwiftUI DSLで使用されている機能を指摘しましたが、それらがどのように機能するかについて話しましょう。

いくつかのSwiftUIタイプの無関係な部分を削除したり、コンパイラによって生成された変数のv0のような偽の変数名を表示したりなど、いくつかの詳細を簡素化しますが、これは基本を理解するのに役立つはずです。

最初に気づくべきことは、トップレベルでは、新しい構文のように見えるブロックを持つこのVStackのものは、実際には末尾のクロージャ引数であるということです。

VStackが何であるかを調べると、SwiftUIの構造体であることがわかります。

したがって、末尾のクロージャ引数は、その構造体上のこの初期化子に渡されます。

さて、クロージャが渡されるパラメータを見ると、ViewBuilder属性があることがわかります。

その属性は、ViewBuilderという名前の結果ビルダーをクロージャに適用する必要があることをコンパイラに伝えます。

しかし、ViewBuilderとは何ですか?

さて、私たちはその名前の型を探し、再びSwiftUIでこの型を見つけます。

結果ビルダーであることをコンパイラに伝えるために、@resultBuilder属性があることに注意してください。

Swiftが結果ビルダータイプを見つけたので、それをクロージャに適用し始めます。

最初に行うことは、結果を生成するすべてのステートメントの変数を作成することです。

これらの変数が作成されると、ViewBuilderのbuildBlockメソッドへの呼び出しを書き、それらの変数をすべて渡します。

buildBlockの仕事は、すべてのパラメータを1つの値に処理または結合し、それを返すことです。

次に、コンパイラは、クロージャからbuildBlockの結果を返すreturn文を書き込みます。

したがって、基本的に、コンパイラはコードを取り、黄色のコードを追加して、ViewBuilderが作成したすべての値をVStackがコンテンツとして使用する単一の値に組み立てることができるようにしました。

さて、修飾子スタイルのメソッドがこれにどのように適合するかを指摘したいと思います。

修飾子スタイルのメソッドは、自己の変更されたコピーまたは新しい動作を追加する別のタイプでラップされた自己のコピーのいずれかを返します。

そして、それは最初に自己を創造したのと同じ声明の中でこれを行います。

そのため、結果ビルダーがそれを見る前に値を変更することになります。

また、そのメソッドの結果で他の修飾子スタイルのメソッドを呼び出すことができるので、結果ビルダーが値を見る前に、いくつかの変更を適用して一緒に構成することができます。

これらの2つのこと - 修飾子を作成する能力と、結果ビルダーがそれを見る前に値を変更するという事実 - は、Swift DSLがしばしば修飾子を使用する理由です。

二人はただうまく機能する。

さて、結果ビルダーを設計したときに心配していたことの1つは、Swiftの動作をあまりにも根本的に変更させると、クライアントはDSLの何かが通常のSwiftコードのように機能することを信頼できないということでした。

そのため、結果ビルダーを設計したとき、有用なDSLを作るのに十分な電力を持つことと、Swiftの機能がクライアントが期待どおりに機能することを確認することのバランスを取ろうとしました。

結果ビルダーは、クライアントが書き込むコードを根本的に再解釈しません。

ステートメントはまだ改行で終わり、呼び出しはまだ括弧を使用し、波括弧はまだ一致する必要があります。Swift構文の基本はすべて、クライアントが期待するとおりに機能します。

また、同じ場所に書かれた通常のコードからは見えない新しい名前も導入しません。

結果ビルダーを使用しているときにはあまり意味をなさない言語機能がいくつかあります - 主にキャッチやブレークのようなもので、ステートメントの結果をキャプチャして使用するという考えにうまく適合しない方法で制御フローを中断します。

これらの機能は、結果ビルダーを使用しているときに無効になります。

また、if、switch、for-inステートメントなど、結果ビルダーがそれらを実装するために使用される追加のメソッドを提供しない限り、無効になっているいくつかの機能があります。

しかし、Swiftがキーワードの使用を許可する場合、それは通常どおりに機能します。

Trueブロックとfalseブロックの両方を実行するif-elseステートメントや、いくつかの要素をスキップするループなどでは終わりません。

結果ビルダーは、そうでなければ捨てられたであろうステートメント結果をキャプチャするだけで、それ以上ではありません。

だから、クライアントはそれらを頼りにすることができます、あなたが知っている、理にかなっています。

OK。結果ビルダーとは何か、どのように機能するかがわかったので、それらを使用するDSLの設計を開始できます。

以前に言語に取り組んだことがない場合は、その考えが威圧的になるかもしれませんが、Swift DSLの設計は、実際にはSwift APIの設計とよく似ています。

Swift APIのように、Swift DSLはゼロから始めるのではなく、Swiftの構文と機能を使用して、解決しようとしている問題に関連するアイデアや行動を表現します。

DSLは、APIが通常使用しない追加機能を使用しているだけです。

Swift APIのように、Swift DSLはすべて問題を解決するいくつかの異なる方法で設計することができるので、あなたの仕事は代替案を考え、あなたが最善だと思うものを選択することです。DSLは、潜在的なソリューションのはるかに大きなスペースを持っています。

そして、Swift APIのように、Swift DSLの最高の経験則は、通常、最も明確な使用サイトをもたらすデザインを選択することです。

DSLは、クライアントが事前に言語学習に少し時間を投資することを前提としているため、これまでに見たことのない人々に明確にすることをあまり優先しません。

したがって、以前にAPIを設計したことがある場合は、DSLを設計するための良い出発点があります。

そして、そのことについては、私がDSLに使用する提案やテクニックのいくつかは、API設計に本当にうまく転送されます。

この講演では、アプリFruta用のDSLを設計します。

Frutaのサンプルコードで、これの実用的な実装を見つけることができます。

Frutaにはソースコードに15のスムージーレシピが含まれており、DSLの前に、メンバーワイズ初期化子を呼び出して静的定数に割り当てるだけで、各スムージーを作成しました。

そして、すべてのスムージーの配列を別の静的定数に保存し、特定のビューにアプリ内購入が必要なレシピを含めるかどうかに応じて、リスト全体を返すか、有料レシピを除外します。

さて、これは完全に出荷可能であり、あなたが望むなら、あなたはそれに固執することができます。

しかし、スムージーのレシピはかなり頻繁に更新され、アプリの残りの部分とは異なり、デザイナーやマーケティング担当者やマネージャーによって更新されるので、DSLを少し複雑にしたいかもしれません。

そして、私たちが今やっている方法を見ると、私はいくつかの欠点に気づかずにはいられません。

有料のスムージーをリストから除外する必要性は、このコードを歪めました。

allSmoothiesとhasFreeRecipeは、この機能でのみ使用されます。そうでなければ、存在する必要はありません。

しかし、それらなしでこれを実装することを想像しようとすると、私たちがそれをしなかった理由がわかります。

配列を作成し、それに要素を追加する仕組みは、この関数のポイントのようなものであるスムージーの実際のリストをあいまいにし始めます。

同様に、スムージーのリストがスムージーの定義とは別のものであるという事実は少しばかげています。

これらの定数のいくつかはプレビューで使用されますが、そのほとんどはこのリストにのみ表示されます。

また、ある場所でスムージーを定義し、別の場所でリストに追加すると、間違いの機会が生まれます。

新しいスムージー定数を宣言しても、リストに追加するのを忘れた場合はどうなりますか？

または、スムージーを2回追加するとどうなりますか?

個々のスムージーの定義を振り返ってみると、私を悩ませる他の2つのことも見られます。

1つは、成分リストが信じられないほど冗長であるということです。

例えば、各エントリは「測定」という言葉のいくつかのバージョンを3回繰り返します。

この行では、私たちが気にかけている実際の情報は1.5カップのオレンジです。

行の残りの部分は有用なことを言っていません。それはただの視覚的な混乱です。

必然的に重要な情報の周りにいくつかのサポート構文があるでしょうが、これほどあるとき、その周りの定型文は私たちが伝えようとしている情報を圧倒するだけです。

私が気づいたもう一つのことは、実際に存在する情報の量と比較して、各スムージーに捧げられた行の数です。

ここでの犯人は、議論の長さの違いだと思います。

これらの議論のいくつかは非常に短く、単一の行にまとめることができます。

他の人はより長く、本当に自分のラインが必要です。

これで、短い引数を1行に結合し、長い引数に別々の行を使用できますが、ほとんどのスタイルガイドはそれに眉をひそめます。

私たちは、異なるスタイルのスタイルが自然である構文を好みます。

これらをまとめると、スムージーリストの維持を容易にするために、DSLに達成してもらいたい目標がたくさんあります。

さて、次にやるべきことは、これらの目標を達成するためにDSLを設計できるさまざまな方法を検討することです。

これらのポイントのそれぞれに対処するさまざまなデザインがたくさんあります。

最初の3つの目標のために何をしようと決めたのかを簡単に説明し、最後の目標をより詳細に探求することができます。

すべての方法でスムージーリストを定義することにしました。

スムージーは静的変数を使用せずに体内で直接定義されるので、誰かがスムージーを定義し、それをリストするのを忘れることを心配する必要はありません。

「SmoothieArrayBuilder」と呼ばれる結果ビルダーを使用して、DSLをアクティブにし、スムージーを配列に収集します。そうすれば、配列リテラルを使用したり、一時的な変数に収集したりする必要はありません。

そして、スムージーをifステートメントに入れることを許可しますので、以前のようにリストをフィルタリングする必要はありません。

Swiftをすでに知っているクライアントは、ifステートメントがどのように使用されるかを知っているでしょうし、そうでないクライアントはおそらく「有料を含む場合」をほとんど問題なく理解しないので、これは素晴らしいことです。

修飾子スタイルの方法を使用して、成分の量を指定することにしました。

成分には、「measured(with: )」と呼ばれる方法があり、単位を取り、その単位の1つで測定された成分を返します。

その単位の異なる量が必要な場合は、測定された成分のスケーリングされた(by: )修飾子は、量に渡す数を乗じて返します。

したがって、1カップのオレンジは1.5カップのオレンジになり、1カップのアボカドは0.2カップのアボカドになります。

さて、なぜスケーリング(by: )は別の修飾子なのですか?

Frutaのスクリーンの1つには、スムージーレシピの成分量をスケーリングするために使用できるコントロールがあります。

私たちは以前、乗数を各成分行に渡し、その量を乗算しました。

しかし、私は実際にスケーリングされた(by: )修飾子を使用して、代わりに成分が行に渡される前にスケーリングできることに気づきました。これにより、行ビューを簡素化できます。

そのため、スムージーDSLのデザインを少し微調整することで、プロジェクトの別の部分でその一部を再利用することができました。

したがって、最初の3つの目標を達成するための変更により、新しいDSLが形になり始めています。

さて、最後の目標に焦点を当てましょう。個々のスムージーのエントリをよりコンパクトに再設計し、うまくいけば、クライアントがトリップできる紛らわしい句読点が少なくなります。

それを助けるためにこの情報を手配できるいくつかの異なる方法を見てみましょう。

私たちができることの1つは、修飾スタイルのメソッドを使用して説明と成分を追加することです。

これはうまくいくでしょうが、それはちょっと冗長で、誰かが説明を忘れたり、2回指定したりするのは簡単です。

もう1つできることは、各フィールドにマーカータイプを与え、結果ビルダーのクロージャに入れることです。

しかし、これはIDとタイトルを独自の行に置き、それを避けようとしています。

したがって、IDとタイトルをパラメータリストに戻し、他の2つのフィールドにマーカータイプを使用できるかもしれません。

しかし、これはまだ私たちが本当に必要としているよりも少し多くの式典であるように感じます。

レシピのユーザーインターフェースを見たとき、そのことに気づきました。

それらは常に特定の順序で表示されます:上部にタイトル、中央に説明、下部に成分のリスト。

そして、私たちはわざわざタイトルや説明にラベルを付けません。

私たちは、彼らの視覚的な階層（タイトルが説明よりも目立つように提示されているという事実）に話をさせます。

だから私はそれからいくつかのインスピレーションを得て、私たちのスムージーDSLも同じことをすべきだと決めました。

上部にタイトル、中央に説明、下部に成分のリストを置きます。

そして、説明が下にあり、タイトルよりもインデントされているため、視覚的に顕著ではないという事実は、説明文字列の意味を伝えるので、ラベルを付ける必要はありません。

結果は不必要な合併症なしにすぐに理解できると思います。

そして、それをDSL全体の文脈に入れると、私たちはかなり快適なフィット感を持っていると思います。

しかし、あなたは同意しないかもしれません、そしてそれは大丈夫です。

DSLはプログラミング言語であり、個人的な好みと主観的なトレードオフは、あらゆるプログラミング言語を設計する大きな部分を占めています。

それはあなたが厳格であるべきではないという意味ではありません。

あなたは言語から欲しいものの明確なアイデアから始めるべきです。

使い慣れた解決策を採用できれば、人々は新しい解決策を学ぶ必要がないので、ifステートメントのような既存の解決策があるかどうかを調べる必要があります。

言語の各部分が残りの部分とどのように相互作用するかを考えるべきです。

スウィフトDSLでは、他の場所で使用できるので、スケーリングされた修飾子を選んだときのように、DSLがその周りの通常のスウィフトコードとどのように相互作用するかを考えることも意味します。

コンパイル時に検出可能か、書くことが完全に不可能な間違いを犯す解決策を探すべきです。

あなたが思い出すなら、それが私たちが説明を修飾子にしなかった理由です。あなたは偶然にそれを省略したかもしれません。

そのすべてを念頭に置いて、あなたはいくつかの異なる可能性を考え出す必要があります。

それぞれがどのように使用されるかを想像し、小さなモックアップを書いてください。あなたが知っているように、お互いに重さを量ってください。

しかし、最終的には、あなたは通常、他の人が明らかに間違っているところで明らかに正しいものを見つけることができません。

あなたができることは、あなたの言語のクライアントにとって最善だと思うものを選ぶことだけです。

どちらが最適かわからない場合は、おそらく最も読みやすい方を好むべきです。

そして、その後もまだわからない場合は...

まあ、個人的には、私は大胆な選択肢を取るのが好きです。

決して試して疑問に思うよりも、うまくいかない場合は、むしろ何かを試してみて歩いて戻りたいです。

DSLがどのように見えるかを決めたので、先に進んでFrutaに追加しましょう。

以前のスムージーの定義をDSLを使用する最終的なすべての方法に置き換えましたが、実際にはまだDSLを実装していません。

当然のことながら、私たちにはたくさんのエラーがあります。

でも、それは大丈夫です。

私たちがこれに取り組むにつれて、私はこれらのエラーが私が解決する必要がある問題に私を導き、最後にはエラーなしで構築されるものを持つことになります。

では、この最初のエラー「Unknown attribute 'SmoothieArrayBuilder'」で関数の一番上から始めましょう。

結果ビルダーは実際にはまだ存在しないので、もちろんそれは機能しません。

それを直しに行きましょう。

結果ビルダー属性でマークされた「SmoothieArrayBuilder」というタイプを作ることから始めます。

今、Swiftは実際にこのタイプのインスタンスを作ることはありません。それは単なる静的メソッドの束のためのコンテナです。

だから私はそれを列挙型にしました、そして私はどんなケースも定義しません。

ケースを持たない列挙型インスタンスを作成することは不可能であるため、人々が誤って使用するのを防ぎます。

これだけをビルドすると、結果ビルダーにbuildBlock(_:)メソッドが必要だというエラーが発生します。

それは1つを挿入する修正イットを持っているので、私はその修正を受け入れ、それを実装する方法を考えます。

さて、以前から思い出すと、buildBlock(_:)の仕組みは、このようなコードが個々のステートメントの束を持つ場合、それらのステートメントのそれぞれが変数に割り当てられ、変数はすべてbuildBlock(_:)に渡され、buildBlock(_:)によって返された値はクロージャによって返されます。

したがって、buildBlock(_:)メソッドは、多くのスムージーをパラメータとして受け入れ、スムージーの配列を返す必要があるのは理にかなっています。

任意の数のスムージーをメソッドに渡すことができるように、可変パラメータを使用してそれを実装する場合...

...そして構築する...

...まあ、私たちが得るものは少し良いです。

まだ多くのエラーがありますが、スムージー配列ビルダーが無効な属性だったと言っているものはなくなり、属性は既知のタイプであることを示すために色も変更されました。

では、次のエラー、スムージーイニシャライザのエラーに移りましょう。

ある人は、文字列パラメータに末尾のクロージャを渡していると言います。

もう一人は、測定された成分の議論を見逃していると言います。

だから明らかに、私たちはパラメータとして説明と成分を期待する古い初期化子を使用しています。

私たちは新しいものを作る必要があります。 

では、ID、タイトル、および説明と成分を返す末尾のクロージャで初期化子を実装しましょう。

今すぐお伝えします。後でこのイニシャライザに戻らなければなりません。

今すぐ構築すると、スムージーイニシャライザからすべてのエラーがクリアされるので、これは完璧に機能していると思うかもしれません。

しかし、それは実際には少し誤解を招く。

ほら、スムージー配列ビルダーが完成していないことに起因するifステートメントに別のエラーがあります。

そして、そのエラーがあるので、Swiftはまだクロージャの内部をチェックしていません。

例えば、このクロージャに入って、存在しないことを知っているランダムな変数名を書いてから構築すると、Swiftはエラーにフラグを立てません。

起こっていることは、スウィフトは結果ビルダーが正しく適用されなかったことを見ているので、これらのクロージャで見つかったエラーが実際に正確であることを本当に信頼していません。

だから、まだそこでエラーを探していないだけです。

後で、スムージーアレイビルダーを終えると、突然これらのエラーが表示され始め、その時点で修正することができます。

しかし、今のところ、スムージーアレイビルダーの作業を続ける方が簡単なので、これらのクロージャを脇に置いて、次のエラーに進みましょう。

このエラーを見ると、Swiftはスムージー配列ビルダーでifステートメントを使用できないことを教えてくれますが、それをサポートするために追加できるメソッドがあります。

ステートメントがこのようないくつかのSwift機能の1つである場合、結果ビルダーがそれらをサポートするための追加のメソッドを実装しない限り、それらは無効になります。

だから、これを実装し始めるために、ここでfix-itを押して、それが何を追加するかを見てみましょう。

したがって、明らかに、オプションのスムージーの配列を取り、スムージーの配列を返すbuildOptional(_:)というメソッドを実装する必要があります。

では、この方法はどのように使用されるのですか?

さて、他の方法のないifステートメントを持つallメソッドのこの簡略化された例を見てみましょう。

If ステートメントのない前の例と同様に、これは各ステートメントの結果を変数にキャプチャし、それらの変数をbuildBlock(_:)に渡し、クロージャからbuildBlock(_:)の結果を返します。

唯一の問題は、ifステートメントの結果をどのようにキャプチャするかということです。

さて、最初に行うことは、ifステートメントの本文内のすべてのステートメントを変数にキャプチャし、トップレベルと同じようにbuildBlock(_:)を使用してそれらの変数を組み合わせることです。

しかし、これがbuildOptional(_:)の出番です。

その内部 buildBlock(_:) 呼び出しの結果を返す代わりに、Swift はそれを buildOptional(_:) に渡し、buildOptional(_:) によって返される値は if ステートメント全体の値になります。

しかし、if条件がfalseの場合、変数は初期化されないままになります。

そのため、buildOptionalのパラメータはオプションのスムージーの配列です。

Swiftは、if文の結果の値をbuildOptional(nil)からの戻り値に設定するelseブランチを追加します。

SmoothieArrayBuilderの場合、これの結果は、buildOptional(_:)がbuildBlock(_:)から渡された配列を返すか、パラメータがnilの場合は空の配列を返すことです。

今それを作れば、私たちは...

...本当に奇妙な見た目のエラー。

スムージー型の配列を可変引数として渡すことはできませんか?

何？

さて、生成されたコードに戻りましょう。

Ifステートメントは、スムージーの配列を生成することになります。

しかし、実際には、buildBlock(_:)はスムージーの配列を望んでいません。それは単一のスムージーを望んでいます。

私たちはそれを変える必要があります。

したがって、buildBlock(_:)にスムージーの配列を引数として取り、flatMap(_:)を使用して、これらの多くのスムージーの配列を単一のスムージーの配列に連結することができます。

すごい！それを構築し、そして...

...いいえ。

今、私たちのifステートメントは機能しますが、すべてのスムージーラインが壊れました。

私たちはそれらを必要としています。

スムージータイプの値をスムージーの配列に変換できません。

どうしましたか？

さて、buildOptional(_:)によって返されたスムージーの配列と一致するようにbuildBlock(_:)を変更しました。

しかし、通常のステートメントで返される個々のスムージーと一致する必要があることを忘れていました。

おっと。

基本的に、洗練された制御フローを許可する場合、buildBlockの戻り値の型は、buildBlock(_:)にパラメータとして渡すことができるものである必要があります。

これを達成するには2つの方法があります。

1つの方法は、buildBlock(_:)と他の結果ビルダーメソッドが、結果ビルダーで許可されているステートメントと互換性のある型を返すことを確認することです。

例えば、これがSwiftUIのViewBuilderの仕組みです。

SwiftUI DSLでは、buildBlock(_:)やその他のビュービルダーメソッドによって返されるタイプを含め、すべてがViewプロトコルに準拠しています。

しかし、SwiftUIビューとは異なり、他のスムージーの中にスムージーをネストしないため、それは私たちのスムージーDSLには適していません。

もう1つできることは、結果ビルダーに通常のステートメントの値をbuildBlock(_:)によって返されるのと同じタイプに変換させることです。

それはこのDSLにより適しています。

buildExpression(_:)というメソッドを追加することで、それを行うことができます。

buildExpression(_:)メソッドを追加すると、Swiftは変数にキャプチャする前に、各ベア式をそのメソッドに渡します。

それは私たちにそれらを配列に変換する機会を与えるでしょう。

しかし、buildOptional(_:)やbuildBlock(_:)によって生成されたものなど、他の結果ビルダーメソッドから来る値は、これらの呼び出しにラップされないため、この変換は適用されません。これは、すでに配列を返しているので良いことです。

したがって、私たちが行うことは、buildExpression(_:)メソッドを実装することです。

Xcodeのコード補完は、結果ビルダーメソッドについてすべて知っているので、1つの署名を書くように依頼することができます。

次に、パラメータタイプをSmoothyに変更し、配列リテラルでラップされた式パラメータを返すだけです。

だから今、私たちの単一のスムージーは、buildBlock(_:)が必要とするスムージーの配列に変わります。

それを構築し、そして...

...ファンタスティック！

私たちのifステートメントは機能し、スムージー初期化子も機能します。

しかし、ミニマップを見ると、ここに動作しない2番目のifステートメントがあることがわかります。

これは他の条項があるからです。

buildOptional(_:) は、実際にはプレーンif ステートメントでのみ機能します。

elseステートメント、else-if、またはスイッチがある場合は、buildEither(first:)とbuildEither(second:)と呼ばれるメソッドのペアを実装する必要があります。

修正機能を使用してこれらを作成し、それらがどのように機能するかについて話しましょう。

では、if-elseステートメントでこの簡略化された例を見てみましょう。

変換のほとんどは、buildOptional(_:)のようなものです。

buildOptional(_:)と同様に、if-elseステートメント全体が単一の変数を埋めます。

また、buildOptional(_:)と同様に、ifステートメントの各ブロックには、その中のステートメントが変数にキャプチャされ、buildBlockを使用してそれらを1つの値に結合します。

プレーンifステートメントとの違いは、buildOptional(_:)を使用して最終値を生成する代わりに、buildEitherメソッドの1つを使用することです。

ifとelseのような2つのブランチがある場合、最初のブランチはbuildEither(first:)を使用し、2番目のブランチはbuildEither(second:)を使用します。

これにより、どのブランチを気にする結果ビルダーがそれらを区別することができます。

さて、3つ以上のケースがある場合にどうするか疑問に思っているなら、その答えは実際にはかなりクールです。

各ブランチを葉の1つとしてバランスの取れたバイナリツリーを構築し、非リーフノードを必要な呼び出しとして扱い、エッジはbuildEither(first:)とbuildEither(second:)のどちらを使用するかを教えてくれます。

各ブランチがどの一連の呼び出しを使用すべきかに注意し、その一連の呼び出しで変数に割り当てるコードを生成します。

したがって、2つの方法しかありませんが、結果ビルダーは3つのブランチを区別できます。

悪くない。

とにかく、buildEitherメソッドがどのように機能するかがわかったので、先に進んでそれらを書くことができます。

そして、SmoothieArrayBuilderは実際にどのブランチを取ったかを気にしないので、私たちがする必要があることはあまりありません。配列引数を返すだけです。

だから今、私たちはこれを構築し、そして...

それはまだうまくいきません。

しかし、私たちは近いです!

Array-of-smoothieの問題が発生したときのこの種のエラーを覚えているかもしれませんが、今はスムージータイプについて文句を言っているのではなく、タイプ「()」です。

それは空のタプルで、おそらくボイドと考えるタイプです。

生成されたコードについて考えると、これが問題である理由は理にかなっています。

buildExpression(_:)を呼び出していますが、渡される式はlogger.logを呼び出して、SmoothyではなくVoidを返します。

したがって、voidパラメータを受け取り、空の配列を返すbuildExpression(_:)のオーバーロードを書きます。

その後、再構築し、ログコールが正しく機能します!

数え切れないほどのエラーがありますが、これは実際には良いニュースです。

ほら、これらのエラーの最初のものは、スウィフトが末尾のクロージャでエラーを見つけていないことを示すために、私が最初に追加した偽の変数からのものです。

今、それは私たちがスムージーアレイビルダーを終えたことを意味します!

だからイェーイ、エラー!

その偽の変数を削除して、残っているものを見てみましょう。

よく見ると、見た目よりもここでやることが少ないことがわかります。 

すべての説明行に同じ警告があり、すべての成分行に同じ2つのエラーがあります。

したがって、100のエラーと1ダースの警告がありますが、これは実際には何度も起こっている同じ問題です。

これらの成分ラインの1つのエラーを詳しく見てみましょう。

コンパイラには2つの不満があります。どのタイプでカップを探すべきかがわからず、Ingredientに「測定済み」と呼ばれるメンバーがいるとは思いません。

まあ、それは理にかなっています。私たちは測定された(with:)またはスケーリングされた(by:)修飾子を実装していないので、「測定」と呼ばれるものを見つけることができません。

そして、測定された(with:)が体積単位を取ることになっていることを知らないので、カップが何であるかを知りません。

それでは、MeasuredIngredient.swiftに立ち寄って、これら2つの修飾子を実装しましょう。

Measured(with:)は成分に行き、発信者が渡したユニットの1つで測定された成分を返します。

そして、scaled(by:)は測定された成分に行き、測定値に発信者が渡したスケールを乗じた新しい測定成分を返します。

Smoothie.swiftに戻ってビルド...

...そして、OK。

より多くの警告といくつかのエラーしか見られません。

そして、よく見ると、クロージャの各式が無視されているという1種類の警告と、クロージャにはリターンステートメントがないという1種類のエラーしか表示されません。

その理由を理解するために、これらの後続のクロージャと、結果ビルダーがそれらとどのように相互作用するかについて話しましょう。

この例では、SmoothyArrayBuilderは、以前に見たように外側のステートメントに影響します。

それらはbuildExpression(_:)に渡され、変数に保存され、変数はbuildBlockに渡されます。

しかし、これらの閉鎖はどうですか?

結果ビルダーは彼らに何をしますか?

まあ、それは...

...クロージャは、実際には結果ビルダーを適用した関数内にネストされた別々の関数であるため、絶対に何もありません。

結果ビルダーは1つの関数にのみ適用され、その中にネストされた関数やクロージャには影響しません。

結果ビルダーの影響を受けたい場合は、他の方法で適用する必要があります。 それらを適用する必要があります。

結果ビルダーを機能本体に適用するには、3つの方法があります。

1つ目は、SmoothyArrayBuilderで行ったように、属性を関数またはプロパティに直接書き込むことです。

結果ビルダーを適用する2番目の方法は、プロトコルの関数またはプロパティ要件に書き込むことです。その後、すべての適合タイプの実装に自動的に適用されます。

それがSwiftUIビューのボディプロパティの仕組みです。ViewBuilder属性はビューのボディ要件に適用されるため、ビューのボディプロパティにも自動的に適用されます。

結果ビルダーを適用する3番目の方法は、クロージャパラメータの前に書き込むことです。

そうすると、Swiftは、そのパラメータに渡されたクロージャには結果ビルダーが適用されるべきだと推測します。

Swiftがプロトコルまたはパラメータから結果ビルダーを推測し、実際にそれを適用したくない場合は、return文を使用して明示的に値を返すことで無効にすることができます。

しかし、この場合、クロージャを使用しているので、これらの3つのオプションの最後が必要です。クロージャパラメータから結果ビルダーを推測します。

引数ラベルの前に属性を書くことで、それを行います。

さて、私たちはここでSmoothyArrayBuilderを書くことができますが、それはおそらくこれを行うための最良の方法ではありません。

SmoothieArrayBuilderはスムージーの配列を生成しますが、私たちはこの閉鎖がスムージーを生成することを望んでいません。私たちはそれが文字列と成分の配列を生成することを望みます。

また、このクロージャでは、ステートメントやボイドリターンコールも必要ありません。

だから本当に、私たちはこのクロージャに言語ルールの別のセットを適用しており、その2番目のルールセットをSmoothieArrayBuilderに混ぜるのではなく、これらの新しいルールを実装する新しい結果ビルダーを作成する方が理にかなっています。

それをSmoothyBuilderと呼び、新しい型を作成し、buildBlock(_:)メソッドを書き始めましょう。

さて、これは少し特別です。

任意の数の測定された成分を受け入れたいが、前面にひもを付けたい。

それで、どうやってやるの?

さて、buildBlockメソッドのみを持つ単純な結果ビルダーであるSmoothyBuilderがどのように展開されるかを考えると、それらの行はそれぞれ異なるパラメータとして渡されます。

したがって、buildBlockの先頭に文字列パラメータを書くだけで、最初のステートメントはMeasuredIngredientの代わりに文字列を生成する必要があるようです。

だから、それをやってみましょう。

文字列パラメータを前面に追加し、文字列のタプルと成分の配列を返します。

そして、もし私たちが建てるなら...

ねえ、それを見て！エラーゼロ！

私たちのDSLは機能します!

現在、結果ビルダーは、フォーインループや最終リターン結果の処理など、さらにいくつかの機能をサポートしています。

それらを使用したい場合は、Swift Programming Languageの本に記載されています。

しかし、終わる前に、言語デザインの最も重要な部分の1つである良いエラーメッセージに注意を喚起したいと思います。

言語を設計するときに学ぶことの1つは、無効なコードよりも無効なコードを書く方法がたくさんあるので、無効なコードに対して発生するエラーについて考える時間を費やすべきです。

コードが間違っているときのあなたの行動は、コードが正しいときと同じくらい重要です。

これで、Swift DSLの場合、Swiftのエラー処理を無料で入手できます。

しかし、クライアントが表示するエラーメッセージは、一般的なSwiftコード用に設計されています。

彼らはあなたの言語のルールの観点から表現されていないので、彼らはあなたのクライアントに問題を明確に伝えないかもしれません。

例えば、誰かがこれらのスムージーの1つに説明を入れるのを忘れたと想像してみてください。

スウィフトはエラーメッセージを発行しますが、少し不明です。

最初の成分を文字列に変換できないと不平を言います。

では、このコードはどのようにしてこのエラーを生成するのでしょうか?

さて、SwiftコンパイラはスムージーDSLのセマンティクスを本当に理解していませんが、結果ビルダーを使用するために生成されたSwiftコードのセマンティクスのみを理解しています。

したがって、このエラーを診断しようとすると、この値をスムージーや最初の成分の説明とは考えません。

それはbuildBlockの最初の引数だと考えています。

v0、buildBlock(_:)の最初の引数はMeasuredIngredientですが、文字列パラメータに渡されています。

したがって、Swiftはこのエラーを「MeasuredIngredientを文字列パラメータに渡そうとしていますが、MeasuredIngredientを文字列に変換できません」と考えています。

エラーメッセージは技術的には間違っていませんが、あまり役に立ちません。

コンパイラエンジニアにはコツがあります。コンパイラに無効なものをサポートさせますが、それを行うとエラーが発生します。

たとえば、Swiftの関数文法には、スロー、リスロー、または何も書くことができるスロットがあります。

他のサポートされていない単語を書くと、コンパイラはそれが別のステートメントの一部であるはずだったと推測し、セミコロンを追加するか、新しい行を使用するかというエラーが表示されます。

しかし、具体的に「try」と書くと、別のエラーが発生します。

コンパイラは、それをスローに置き換えることを提案し、代わりにそこにスローを書いたかのようにファイルの残りの部分を解析します。

これは、Swiftパーサーに追加した特別なケースです。

開発者がスローを書くことを意味するときに、ここで他のエラー処理キーワードを入力することがあることに気づいたので、言語の正式な文法に小さな文書化されていない拡張を作成しました。

ここでこれらの誤ったキーワードを解析し、その特定の間違いに合わせて、通常とは異なるエラーを診断します。

エラー動作を改善するために、結果ビルダーで同様のことを行うことができるので、これを指摘します。

具体的には、不正なコードに一致する結果ビルダーメソッドのオーバーロードを行い、そのオーバーロードを使用不可としてマークした場合、それを診断するときに使用するエラーメッセージを指定できます。

そして、問題をうまく伝えない可能性のある一般的なエラーを取得する代わりに、クライアントはその間違いに合わせたより具体的なエラーメッセージを受け取ります。

buildBlock(_:)をコピーし、説明パラメータを削除して、成分リストのみでブロックを照合し、本文をfatalError()に置き換えて、戻り値を偽造する必要がないようにします。

このメソッドは正常に呼び出されないので、ボディは有効なものでなければなりません。

次に、この過負荷を利用不可としてマークし、問題をより明確に説明するメッセージを提供します。

この使用できない注釈は、このメソッドが実際に使用できないことを意味します。

あなたがそれに呼び出しを書く場合、それはエラーです。

だから今、トップに戻って再構築すると、何が間違っているのか、はるかに明確な説明が得られることがわかります。

最初の成分は文字列であるべきだと言う代わりに、説明文字列が欠落していると言います。

したがって、クライアントは成分が間違っていると考え始めたり、文字列が何のためにあるのか疑問に思う必要はありません。エラーは前もってそれを彼らに伝えます。

それははるかに良い経験です。

そして、DSLの実装について覚えておくべき最も重要なことは、それがすべてクライアントの経験を向上させることであるということです。

DSLは、クライアントが定義を組み立てる仕組みを気にせずに物事を定義できるようにすることで、非常に複雑で反復的なコードをはるかにきれいにすることができます。

結果ビルダーは、DSLが定義されている値を収集できるようにする強力なツールです。

そして、修飾子スタイルのメソッドは、結果ビルダーがそれらをキャプチャする前に、それらの値を変更するための構成可能な方法を提供します。

しかし、DSLを書く場合、クライアントはそれを使用する方法を学ばなければならないことを覚えておいてください。

時間と労力に見合う価値がある場合にのみ、DSLを提供してください。

だから、あなたの時間をありがとう、そしていくつかの小さな言語を構築することを楽しんでください。

♪