10197

♪ ♪

「コレクションを使用してSwiftパッケージを発見し、キュレーションする」セッションへようこそ。

Xcode 11では、Swiftパッケージのサポートを導入し、ライブラリをソースコードとして配布する簡単なアプローチを提供しました。

ますます多くのパッケージが公開されるにつれて、特定のユースケースに合ったパッケージの発見をよりアクセスしやすくしたいと考えています。

プロジェクトにパッケージを追加するとき、開発者はライセンスなどの詳細情報も見たいと思っています。

これを行うには、メタデータにアクセスする標準化された方法が必要です。

このため、Xcode 13では、パッケージコレクション、他の人と共有でき、プロジェクトにパッケージを追加するためのまったく新しい改善されたエクスペリエンスを促進するパッケージのキュレーションリストを導入しています。

教育者やコミュニティのインフルエンサーは、コース資料やブログ記事に合わせてパッケージコレクションを公開し、初めてパッケージを使用する際の障壁を取り除き、どのパッケージが特定のタスクに役立つかを決定する負担を取り除くことができます。

企業は、コレクションを使用して、社内のエンジニアリングチームの意思決定スペースを絞り込み、信頼できる審査されたパッケージのセットに焦点を当てることができます。

まず、講演の簡単な概要。

デモから始めて、コレクションの使い方をもっと詳しく見ていきます。

私たちは独自のコレクションの作成に飛び込み、別のデモで締めくくります。

Swift Numericsに関するブログ記事を見つけたので、Xcodeで試してみたいと思っています。

投稿から最初の例をコピーして、Xcodeに切り替えてコードを貼り付けます。

Numericsモジュールが私のプロジェクトに存在しないため、ビルドに失敗しています。

以前は、プロジェクトに数値パッケージを追加する方法を理解するために投稿に戻る必要がありましたが、Xcode 13では、オープンソースパッケージのデフォルトコレクションを提供しているため、エディタで修正を取得します。

これで、「検索」をクリックすると、数値が事前に選択された新しい「パッケージの追加」ワークフローに移動します。

Xcodeには、最新バージョン、著者、ライセンス、READMEなど、パッケージに関する多くの情報があります。

また、リリース履歴タブに切り替えて、利用可能なすべてのバージョンのリリースノートを確認することもできます。

依存関係を追加するには、バージョン要件と追加するプロジェクトを選択できます。

両方のデフォルトを受け入れ、「パッケージを追加」をクリックします。

今、パッケージはチェックアウトされ、Xcodeは指定されたバージョンから製品の選択を提供します。

Numerics製品を選択し、1つのターゲットに追加します。

終了するには、もう一度「パッケージを追加」をクリックします。

プロジェクトナビゲーターを見ると、そこに新しい依存関係が表示されます。

そして、ビルドを実行すると、プロジェクトが正常に構築されていることがわかります。

プロジェクトに加えられた「パッケージの追加」ワークフローの正確な変更を簡単に見てみましょう。

そのために、プロジェクトエディタを開き、プロジェクトを選択し、Swiftパッケージタブを開きます。

ここでは、依存関係とバージョンルールを確認できます。

さて、ターゲットエディタを開いてフレームワーク、ライブラリ、埋め込みコンテンツのフェーズを見ると、数値製品がここにリンクされていることがわかります。

これはXcodeの新しい「パッケージを追加」ワークフローです。

さて、XcodeはNumericsパッケージについてどのように知りましたか?

Xcodeには、Swift Argument ParserやSwift NIOなど、Appleが発行した一連のオープンソースパッケージを含む、事前設定されたデフォルトコレクションが付属しています。

これにより、モジュール名の自動補完と、コレクションの情報を使用してパッケージを追加するための修正を提供することで、Xcodeでのこれらのプロジェクトの使用がはるかにシームレスになります。

このデフォルトのコレクションは定期的に更新されているため、パッケージの正確なリストは変更される可能性があります。

さて、同僚のフランチェスコにコレクションの使用について詳しく教えてもらいます。

ありがとう、ボリス。

インポートステートメントから直接そのパッケージをインポートすることは簡単でした。

コレクションとは何かを詳しく見てみましょう。

コレクションはJSONファイルで、通常はHTTPS経由でフェッチされます。

コレクションには、要約、バージョン、販売された製品など、パッケージURLとそのメタデータのリストが含まれています。

これにより、豊富な情報をXcodeに表示できます。

これはコレクションのJSONのスニペットです。

通常、これを詳しく見ることはありませんが、いくつかの重要な分野を見てみましょう。

パッケージのURL、READMEのURL、要約、およびパッケージのバージョンに関するより詳細な情報を見ることができます。

Swift Package Managerは、今日では「SwiftPM」と略されることが多いため、Macにコレクションをキャッシュするためのデータベースを管理します。

これは、コマンドライン上のSwiftPMを含むXcodeだけでなく、libSwiftPMを使用する任意のツールから、設定されたコレクションにアクセスできることを意味します。

SwiftPMは、より大きなSwiftオープンソースプロジェクトの一部です。

Swift.orgのウェブサイトは、コミュニティと貢献するプロセスについて学ぶことができる素晴らしい場所です。

SwiftPMは、コレクションのサポートなど、ライブラリとしての機能を提供します。

ライブラリをlibSwiftPMと呼び、Xcodeのパッケージにも電力を供給します。

ボリスと私はウェブサイトのブログ記事をまとめています。

読者がフォローできるように、投稿で使用しているパッケージでコレクションを作成します。

ありがとう、フランチェスコ。

Alamofireを使用してネットワークリクエストを行うのが好きなので、コレクションに追加します。

さらに、プロジェクトの書式設定の一貫性を保ちたいので、swift-formatも使用します。

コレクションにどのパッケージを入れたいかがわかったので、続けて作成しましょう。

コレクションを作成するために、GitHubにツールを公開しました。

独自のコレクションを公開したい場合は、これをローカルで複製して構築できます。

ジェネレータは、情報を自動的に収集し、常にフォーマットの最新バージョンに従って出力を生成することにより、コレクションを作成するプロセスを簡素化します。

このツールは、オプションのメタデータを含むパッケージURLのリストである入力JSONファイルを受け取り、他のユーザーと共有される出力ファイルを生成します。

同じGitHubプロジェクトの一部であるコレクションに署名するための別のツールもあります。

コレクションへの署名はオプションですが、著者を確認でき、コレクションの完全性を保護します。

入力JSON形式はこんな感じです。

概要、キーワード、著者情報など、コレクション全体のメタデータが少しあります。

これは、Xcodeでコレクションを追加するときに表示されます。

そして最も重要なのは、パッケージのURLのリストです。

このツールは各パッケージに関する情報を自動的に取得しますが、コレクションをオーサリングするときにパッケージごとに追加のメタデータを提供することもできます。

これには、カスタムサマリーやキーワードなどの検索結果を改善できるメタデータ、コレクションが表すバージョンの制限、パッケージが販売する最も関連性の高い製品にユーザーを導くのに役立つ除外製品、およびREADME URLの指定が含まれます。

入力JSONファイルに基づいてコレクションを配布することは、3段階のプロセスです。

まず、ジェネレータを使用して出力JSONファイルを作成します。

次に、出力と署名キーと証明書を使用して、署名ツールで署名されたコレクションを作成します。

そして最後に、直接共有するか、ウェブサーバーに置くことで、署名されたコレクションを配布することができます。

有効な、有効期限のない、取り消しのないコード署名証明書でコレクションに署名できます。

要件の詳細については、SwiftPMのドキュメントをご覧ください。

コレクションに署名したくない場合は、生成ツールを使用した後に配布に進んでください。

しかし、フランチェスコと私が取り組んでいるこのコレクションのために、私たちは先に進んで署名するつもりです。

私はすでに署名用のファイルと、先ほどのスライドで見た入力JSONを準備しました。

また、ジェネレータと署名ツールをダウンロードして構築しました。

まず、入力JSONと出力パスで「package-collection-generate」を実行します。

より多くの情報出力を得るために`--verbose`を渡しており、より多くのメタデータを求めてGitHub APIを照会するためにGitHub認証トークンを渡しています。

このコマンドは、情報を収集するために異なるバージョンのパッケージをチェックアウトすることがわかります。

これには数秒かかるはずです。

そして、それは完了し、出力ファイルを生成しました。

次に、コレクションに署名したいと思います。

`package-collection-sign`コマンドを実行し、生成したばかりのJSONファイルを渡し、出力パスを指定します。

また、以前にエクスポートした鍵と証明書を渡します。

私はすでに生成されたコレクションをサーバーにアップロードしました。

コマンドラインを使ってそれと対話する方法を見てみましょう。

SwiftPMは、そうするために「package-collection」というサブコマンドをもたらします。

まず、設定されたコレクションのリストにコレクションを追加し、Xcodeでも利用できるようになります。

これにより、コレクションを取得して追加されます。

もちろん、フランチェスコが後で表示するXcodeのUIでもこれを行うことができます。

次に、「迅速なパッケージコレクションの説明」を使用して、内容を見てみましょう。

まず、先ほど指定したメタデータがあります。

コレクション内のパッケージのリストを取得し、最後に署名に関する情報を取得します。

これは、誰がコレクションに署名したか、および署名がSwiftPMによって検証されたことを示しています。

これは、特定のコレクションが期待する人によって作成されたかどうかを判断し、コレクションの整合性を変更から保護するために使用できます。

次に、スウィフトフォーマットのような個々のパッケージを見てみましょう。

このために、今回はパッケージURLを使用して、describeコマンドを再び使用します。

このコマンドの出力には、利用可能なバージョン、作成者、星、README URLなど、パッケージ全体に関する情報と、使用されているSwiftツールのバージョン、モジュールや製品など、最新バージョンの詳細が表示されます。

新しいコレクションが良さそうであることを確認したので、同僚のフランチェスコに送ります。フランチェスコは、デモアプリをまとめてXcodeの体験をもう少し紹介します。

ありがとう、ボリス。

デモアプリ用の新しいプロジェクトを作成しました。

「ファイル」>「パッケージを追加」に移動し、「+」ボタンをクリックしてコレクションを追加することで、新しいコレクションをXcodeに追加できます。

これで、コレクションのURLを貼り付けることができ、「ロード」をクリックした後、Xcodeはそれに含まれるパッケージの数と最後に更新された日時を教えてくれます。

コレクションを追加した後、Alamofireとswift-formatのパッケージを見ることができます。

AlamofireのネットワークAPIを使いたいので、パッケージをプロジェクトに追加します。

Alamofire製品を選択し、「パッケージを追加」をクリックして唯一のターゲットに追加します。

Xcodeが依存関係を追加したので、ソースファイルに戻ってコードを書き始めることができます。

Alamofireを使ってREADMEをダウンロードしたので、swift-cmarkパッケージを使ってMarkdownを解析したい。

「パッケージの追加」パネルに戻りましょう。

Xcode 13の新機能では、プロジェクトナビゲーターのコンテキストメニューからパッケージオプションへのクイックアクセスを追加しました。

ここから、「パッケージを追加」を選択してパネルを再度開くことができます。

どのコレクションにもswift-cmarkはなく、URLを検索バーに直接貼り付けることで追加できます。

Swift-cmarkのメインブランチを選択し、プロジェクトにパッケージを追加します。

Swift-cmarkを追加したので、ブログ投稿のアプリを完成させることができます。

今、インターネット上からこの使いやすいパッケージであり、私たちにとって最も重要なこと、つまりアプリを書くことに焦点を当てています。

Xcode 13のSwiftパッケージコレクションは、新しいパッケージの発見に役立ちます。

独自のコレクションを作成すると、キュレーションされたパッケージのリストを共有できるため、プロジェクトへの追加が合理化されます。

一般的なパッケージの詳細については、WWDC19セッション「XcodeでのSwiftパッケージの採用」と「Swiftパッケージの作成」をお勧めします。

ご覧いただきありがとうございます。

[明るい音楽]。