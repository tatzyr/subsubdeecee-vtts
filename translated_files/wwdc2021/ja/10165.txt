10165

♪ ♪

こんにちは、私の名前はYagil Burowskiで、AppleのLocation Technologiesチームのエンジニアです。

この講演では、最新の進歩と、今年近くのインタラクションフレームワークに登場する新機能について説明します。

近くのインタラクションフレームワークは、超広帯域技術のためのAppleのチップであるU1のユニークな機能を簡単に活用し、近くのデバイス間で正確で空間的に認識された相互作用を作成することを可能にします。

これは、AirTagとiPhoneとHomePod miniの間の流動的なハンドオフジェスチャーで「精密な発見」を強化するのと同じ技術です。

これは、このセッションで取り上げるものです。

ユーザー権限フローの更新から始めます。

その後、互換性のあるサードパーティのハードウェアで近くのインタラクションを実行するための新しいAPIを紹介します。

そして、アプリやサードパーティのアクセサリにこれらの新しいAPIを採用し始めるために、アプリ開発者やアクセサリーメーカー向けのリソースについて話します。

飛び込む前に、近くのインタラクションを初めて使用する人、または復習が必要な人のために、アプリでフレームワークを使用する方法をすばやく要約しましょう。

セッションインスタンスの作成から始めます。

これは、近くのデバイスとの空間インタラクションを設定して実行する主なオブジェクトです。

次に、NISessionDelegateプロトコルに準拠するようにアプリの一部を指定する必要があります。

デリゲートはフレームワークから更新を受け取ります。

次に行う必要があるのは、NIConfigurationのサブクラスとなる構成オブジェクトを作成することです。

たとえば、アプリを実行している2台のiPhone間でセッションを開始するときに、NearbyPeerConfigurationを作成できます。

作成した設定でセッションで実行を呼び出すと、Nearby Interactionは、セッションに積極的に参加している近くのデバイスへの距離とオプションで方向を含むNearbyObjectアップデートのストリームをアプリに提供し始めます。

フレームワークのAPIをより深く掘り下げることに興味がある場合は、昨年のWWDCトーク「Meet Nearby Interaction」をご覧ください。

近くのデバイスへの距離や方向などのデータにアクセスするには、アプリはユーザーの許可を得る必要があります。

では、今年行ったユーザー権限フローの改善について話しましょう。

これは、iOS 14の近くのインタラクション権限フローです。

プロンプトは、アプリが新しいアプリの有効期間中にセッションを初めて実行したときに表示されます。

アラートの「許可しない」または「一度許可する」のオプションは、非常に明確な選択肢を提供しますが、この許可は1回限りであるため、特定の状況で追加のプロンプトにつながることもあります。

だから、今年は、アプリに近くのインタラクションを使用する許可を与える新しい方法があります。

これは、iOS 15の新しい「Nearby Interaction」許可プロンプトです。

それはちょっと似ているように見えますが、いくつかの重要な点で異なります。

システムは、アプリがNISessionを初めて実行すると、自動的に許可プロンプトを表示します。

したがって、NISessionを実行するタイミングが明確なユーザーの意図と一致していることを確認することが本当に重要であるため、アプリの特定の機能が近くのインタラクションにアクセスする必要がある理由をユーザーが簡単に理解できます。

プロンプトの新しいオプションを詳しく見てみましょう。

新しい「OK」オプションは、アプリの使用中にアプリの許可を付与します。

ユーザーが近くのインタラクションを使用するというアプリの要求を受け入れるか拒否するかにかかわらず、許可プロンプトは再び表示されません。

iOS 15以降、近くのインタラクションを使用するアプリが設定に表示されます。

したがって、ユーザーが気が変わった場合は、設定アプリに移動し、アプリの「近くのインタラクション」アクセスを変更できます。

アプリを開発するときは、必ずこのシナリオをテストしてください。

新しい近くのインタラクションのユーザー権限モデルをまとめてみましょう。

新しい許可プロンプトは、承認されると、アプリの使用中に近くのインタラクションを使用する永続的な許可をアプリに与えます。

アラートには、アプリのInfo.plistで提供された使用状況の説明文字列が表示されます。

この目的文字列では、明確かつ簡潔に、近くのインタラクションへのアクセスを必要とするアプリの素晴らしい機能を説明してください。

プロンプトが最初と最後に表示された後、アプリの名前とアイコンが設定アプリに表示されます。つまり、ユーザーはいつでもアプリの許可状態を変更できます。

アプリに近くのインタラクションを使用するのに十分な権限がない場合は、権限関連のエラーコードでNISessionsが無効になります。

したがって、アプリの重要な機能が近くのインタラクションへのアクセスに依存している場合は、これをユーザーに明確に説明し、必要に応じて設定アプリに案内してください。

それがiOS 15の新しい許可プロンプトでした。

そして今、互換性のあるサードパーティのハードウェアで近くのインタラクションを使用することを可能にするいくつかの新しいAPIを導入することに興奮しています。

私たちは、このAPIが、あなたが構築を検討するかもしれない幅広いアクセサリーで動作することを望んでいました。

そのため、Nearby Interactionのサードパーティのハードウェアサポートは、業界グループと協力してきた標準に基づいています。

また、プロトタイピング、実験、アクセサリーの構築を開始するために、チップセットメーカーと協力して、iPhoneでU1と相互運用できるハードウェアとファームウェアを含む開発キットを作成しています。

そのため、開発キットと並んで、開発キットのハードウェアですぐに使えるサンプルアプリコードも用意しています。

だから、一緒に、彼らはあなたのプロジェクトの優れた出発点として役立つことができます。

また、アクセサリーメーカーの場合は、Apple開発者Webサイトの「開発者プレビュー」で利用できる近くのインタラクション、アクセサリプロトコル仕様のドキュメントをチェックしてください。

このエキサイティングな新技術をいじりたい場合でも、Ultra Widebandを独自のアクセサリに統合する準備ができている場合でも、サードパーティのアクセサリでNearby Interaction APIを使用する方法を説明する簡単な例を見てみましょう。

ユーザーのアクセサリーへの正確な距離に基づいて異なる機能を有効にすることは、そのデバイスとのやり取りを合理化する強力な方法です。

だから、あなたがアクセサリーを構築していて、それを本当に際立たせる一連の機能を可能にするために、それに超広帯域を統合したいとしましょう。

そして、超広帯域はあなたに正確な距離を与えることができるので、あなたはアクセサリーの周りのいくつかの正確なゾーンや領域を追跡するためにそれを利用することを計画しています。

では、半径1.5メートルのアクセサリの周りの領域と、半径3メートルのより大きな領域を定義したとします。

そして、ユーザーがアクセサリーの周りの大きな領域に入ると、いくつかの機能Aを有効にしたいので、これらの特定の距離を気にしているとしましょう。

また、ユーザーが小さな領域に入ると、機能Bを有効にします。

では、近くのインタラクションフレームワークを使用して、実際にアプリでこれをどのように達成しますか?

まず第一に、近くのインタラクションは、アプリとアクセサリがそれらの間でデータを交換する何らかの機能を持っていることを期待しています。

データ交換に使用する特定の技術に関しては、それは完全にあなた次第であり、あなたのアクセサリーが何をし、何をする必要がないかです。

アクセサリがすでにBluetoothをサポートしていると仮定します。

これは、データ交換の要件に既存のBluetooth機能を利用することができるため、素晴らしい場所にあなたを置きます。

アクセサリがローカルネットワークに接続されている場合、またはインターネットに安全に接続されている場合は、あなたも素晴らしい状態です。

アプリとアクセサリの間でデータをやり取りする機能は、次に何をする必要があるかに役立ちます。

アプリを実行している2台のiPhone間でセッションを開始したいときに、NearbyPeerConfigurationを作成したことを思い出してください。

アクセサリでセッションを開始するには、NearbyAccessoryConfigurationを作成します。

これはiOS 15の新しいNIConfigurationタイプです。

アクセサリ構成をインスタンス化するには、フレームワークがアクセサリ構成データと呼ばれる特定の形式で受け取ることを期待するアクセサリを記述して、いくつかの構成データを提供する必要があります。

しかし、この構成データをどのように取得し、この特定の形式は何ですか?

U1互換の超広帯域ハードウェアは、認定技術プロバイダーから入手できるタイプのように、リクエストに応じてこの構成データを生成する方法を知っています。

これは、アクセサリ自体で実行しているコードは、このデータを生成し、データチャネル上のアプリに送信する必要があることを意味します。

アクセサリから受信したデータでNearbyAccessoryConfigurationをインスタンス化するためのコード例を見てみましょう。

setupAccessoryは、私がアプリに書いたヘルパーメソッドであると仮定しましょう。

アクセサリからアクセサリ構成データを取得するたびに、アクセサリの名前とともに、この機能にルーティングするロジックがアプリにあります。

この時点で、アクセサリから受け取ったデータを使用してNINearbyAccessoryConfigurationを作成できます。

Do/catchステートメント内で設定を作成していることに気付くでしょう。

アクセサリから受け取ったデータが何らかの形で無効な場合、NIConfiguration initメソッドが例外をスローするため、これを行います。

しかし、構成オブジェクトが正常に作成された場合、アクセサリから受け取ったデータが正しい形式であり、使用できるようになりました。

設定を作成する究極の理由は、それを使用してセッションを実行するためです。

しかし、その前に、後で使用するためにいくつかの有用なデータをキャッシュする良い機会があります。

新しい NearbyAccessoryConfiguration タイプには、フレームワークが自動的に入力するアクセサリの DiscoveryToken プロパティがあります。

さらに、私が定義したセットアップアクセサリー機能には、アクセサリーの名前もあります。

したがって、この段階では、このアクセサリの名前と一緒にディスカバリートークンを保存すると本当に便利です。なぜなら、後で、このアクセサリに関するNearbyObjectの更新を受け取り始めると、トークンと名前を使用して更新をこのアクセサリに関連付け、より関連性が高く豊富なUIを表示できるからです。

わかりました。

そのため、アクセサリから有効な構成データがあり、それを使用してアクセサリ構成オブジェクトを作成しました。

今、私たちはこのアクセサリーと対話する準備をすることができます。

インタラクションを管理するには、NISessionインスタンスが必要で、セッションのデリゲートを設定する必要があります。

セッションを開始するには、作成したアクセサリ設定オブジェクトを使用して、セッションの「実行」関数を呼び出すだけです。

近くのインタラクションがアクセサリから構成データを必要とするのと同じように、アクセサリは自分自身を設定する方法を知るために、近くのインタラクションからの設定データも必要です。

このデータは「共有可能な構成データ」という形式である必要があります。

アクセサリ設定でセッションを実行すると、近くのインタラクションは、デリゲートコールバックを通じて共有可能な設定データをアプリに提供します。

そして、データチャネルを使用してアクセサリの構成データを受信したように、ここでは、共有可能な構成データをアクセサリに送り返すために再度使用します。

物事をより具体的にするために、コード例を見てみましょう。

共有可能な構成データは、iOS 15の新しいデリゲートコールバックであるdidGenerateデリゲートコールバックを通じてアプリに提供されます。

これは、アプリでのこのコールバックの可能な実装です。

このフレームワークは、共有可能な構成データを提供し、どのアクセサリに行くべきかも示します。これは、複数のアクセサリと対話する場合に本当に便利です。

データチャネルを介して、できるだけ早くアクセサリにデータを送信することを計画する必要があります。

一般的に、さまざまなアクセサリへのデータ接続を管理することは、ユースケースに応じて、さまざまな形式をとることができます。

簡単にするために、私のアプリのアーキテクチャでは、対話しているアクセサリごとに独立したデータ接続を維持することを選んだとしましょう。

そして、私のコードをうまく整理しておくために、私が与えるNearbyObjectに基づいて接続を返すヘルパー関数を定義しました。

接続への参照を取得したら、それを使用してすぐにアクセサリに共有可能な構成データを送信します。

共有可能な構成データをできるだけ遅延なくアクセサリに送信するために、アプリを最適化することが重要です。

ShareableConfigurationDataが十分に迅速に送信されない場合、セッションがタイムアウトする可能性があります。

アクセサリとのセッションでのタイムアウトは、didRemoveデリゲートコールバックを通じてアプリに通知されます。

このシナリオをどのように処理するかを見てみましょう。

Nearby Interactionが画面に表示されるdidRemoveコールバックを教えてくれたら、まず「reason」パラメータをチェックします。

理由が.timeoutで、アクセサリーがまだ近くにあるかもしれないという高い自信がある場合は、それと対話するために再試行することができます。

このアクセサリで「再試行フロー」に入るべきかどうかを決定するために、この決定を下すのに役立つ特殊なロジックを含むヘルパー関数を定義しました。

「成功せずに何回再試行したか」のような条件を想像できます。

または「アクセサリーは停止したことを私に通知しましたか?」

または他の同様の質問は、このような決定の一部である可能性があります。

再試行することにした場合、私がしなければならないのは、同じ設定でセッションを再度実行することだけです。

キャッシュされた設定は、アクセサリのセッションが終了しない限り、有効なままであることに注意してください。

セッションが終了した場合は、最初にセッションを作成して実行したのと同じフローを経なければなりません。

アクセサリのセッションは、アクセサリで実行されているコードが管理しなければならないものであり、ユースケースに応じてさまざまな方法で実行できることに注意してください。

わかりました。

共有可能な構成データをアクセサリに送信し、必要に応じて再試行を処理するロジックもあります。

次は何ですか?

アクセサリ構成データと同様に、アクセサリのU1互換ハードウェアは、アクセサリコードが提供されると、共有可能な構成データをどうするかを自動的に知ることができます。

したがって、アクセサリで実行されているコードがデータを受信したら、ボード上の超広帯域ハードウェアにそのまま、できるだけ早く提供する必要があります。

不思議に思うかもしれませんが、アクセサリの超広帯域ハードウェアは、構成データを生成または消費するためにどのように知っていますか？

アクセサリ構成データと共有可能な構成データの両方は、今春に公開した仕様書で定義されています。

このドキュメントは、チップセットとモジュールの製造を対象としており、業界標準を使用してiPhoneのU1と相互運用する超広帯域ソリューションを作成するために必要な詳細が含まれています。

チップセットメーカーの相互運用性仕様に加えて、アクセサリメーカーを対象とした仕様もリリースしています。

したがって、超広帯域ハードウェアを含むアクセサリを構築したいと思っていて、アプリの近くのインタラクションフレームワークを使用してそれと対話したい場合は、このドキュメントが目向けです。

始めるための追加のリソースとともに、開発者のウェブサイトで見つけることができます。

これが私たちが中断したところです。

共有可能な構成データをデータチャネルを介してアクセサリに送信したばかりでした。

さて、アクセサリのコードがそれを受信し、超広帯域ハードウェアに提供したらどうなるか見てみましょう。

共有可能な構成データを受け取った後、アクセサリの超広帯域ハードウェアは、アプリ内のNISessionと対話するための適切な構成ですぐに実行を開始します。

また、アクセサリとアプリを実行しているiPhoneの両方が互いに近くにある場合、セッションはアプリに距離とオプションでアクセサリへの方向を含むNearbyObjectアップデートのストリームを提供し始めます。

それぞれのセッションを作成して実行することで、複数のアクセサリを同時に操作することもできます。

アクセサリのハードウェア機能によっては、アクセサリで実行されているコードで同等の近接アップデートを取得できる場合もあります。

フレームワークからNearbyObjectのアップデートを取得したら、それらをどうしますか?

リマインダーとして、ユーザーがより大きな領域に入ったときにアプリとアクセサリが機能Aを有効にし、ユーザーがアクセサリの周りの小さな領域に入ったときに機能Bを有効にするエクスペリエンスを構築したいと考えました。

iOSアプリでNearbyObjectのアップデートを使用してこれを行う方法を示すコード例を見てみましょう。

アプリとアクセサリの間のセッションが実行されているとき、アクセサリに関する更新は、didUpdateデリゲートコールバックを通じてセッションのデリゲートに配信されます。

まず、フレームワークが私に更新を与えている近くのオブジェクトへの参照をつかみます。

次に、フレームワークがメートル単位で提供しているこのオブジェクトまでの距離を持つローカル変数を作成します。

次に行うことは、getSmoothedDistanceというアプリにあるヘルパー関数にこのデータを提供することです。

距離の急激な変化から身を守るために、この機能をアプリで定義しました。

たとえば、ユーザーが突然の動きをしたり、ゾーン間の境界に立っている場合などです。

最後に、ユーザーのアクセサリからの距離が事前定義されたしきい値を超えたかどうかを確認できます。

ここでは、現在の距離に基づいてFunctionalityAまたはFunctionityBを有効にすることを選択できます。

デバイス間の距離と方向に基づいてエクスペリエンスを設計することについてもっと知りたい場合は、今年の「空間的相互作用のためのデザイン」WWDCトークをチェックしてください。

では、このセッションで話し合ったことをまとめましょう。

新しいアクセス許可モデルにより、アプリの使用中にアプリが近くのインタラクションにアクセスする方法について話しました。

近くのインタラクション対応のサードパーティ製アクセサリーの真新しい世界と、独自のアクセサリとの空間的インタラクションを構築するために使用できるAPIを深く掘り下げました。

また、サポートされているテクノロジープロバイダーから入手できるサードパーティの開発キットや、プロジェクトをすぐに開始するために使用できるiOSアプリコードについても議論しました。

だから、先に進んで、試してみて、ユースケースの実験とプロトタイピングを始めましょう。

そして、アクセサリーに超広帯域を採用する準備ができたら、Apple開発者のウェブサイトで入手可能な関連する仕様文書を読んでください。

今年の近くのインタラクションのアップデートはこれで終わりです。

チューニングしてくれてありがとう。

このセッションが役に立ち、素晴らしいアプリやアクセサリーの構築を始めるために必要なすべての情報が含まれていることを願っています。

[明るい音楽]。