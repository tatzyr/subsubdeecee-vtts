10109

こんにちは、私の名前はトニーで、ファウンデーションチームのエンジニアです。

「ファンデーションの新機能」へようこそ。Foundationフレームワークは、すべてのアプリとフレームワークの基本機能を提供します。

ファイル処理からネットワーキングや通知まで、さまざまな機能を備えています。

今日は、すべてのアプリが必要とするもの、つまり国際化とローカリゼーションに焦点を当てたいと思います。

今年のリリースでは、このAPI史上最大の進歩を遂げています。

私たちは低いレベルから始めて、Swiftの帰属文字列が何であるかを再考しました。

Swift用のフォーマッタを再構築し、より速く、使いやすくし、新機能を追加しました。

そして最後に、自動文法契約と呼ばれるまったく新しい機能があります。

提供する必要があるローカライズされた文字列の数を劇的に減らし、同時にコードをよりシンプルにします。

帰属文字列に飛び込みましょう。

帰属文字列は、文字、範囲のセット、および辞書の組み合わせです。

属性文字列を使用すると、キーと値のペアである属性を文字列の特定の範囲に関連付けることができます。

最も一般的な属性はSDKによって定義されていますが、独自の属性を作成することもできます。

リッチテキストをサポートするAPIには、アトリビュートの文字列がよくあります。

例を見てみましょう。 例を見てみましょう。

これは私が取り組んでいるCafféというアプリです。

シンプルなメニューです。

私は欲しい食べ物、サイズ、量を選びます。

そして最後に、私が注文したすべてのもののリストが入った領収書が表示されます。

ここの一番下に、短いお礼状を追加することにしました。

これは帰属文字列です。

文字列の一部は太字で、一部はイタリック体です。

最後の言葉にもリンクがあります。

ここでわかるように、属性は重なる可能性があります。

Foundationの開始以来、NSAttributedStringという参照型がありました。

今年は、Swiftが提供するすべての機能を最大限に活用する新しい構造体AttributedStringを導入します。

まず第一に、それは値タイプです。

また、Swift Stringと同じ文字カウント動作もあります。

包括的なソフトウェアを簡単に作成するための取り組みの一環として、AttributedStringは完全にローカライズ可能になりました。

最後に、それは安全とセキュリティを念頭に置いて構築されています。

これには、強力なタイピングを使用したコンパイル時の安全性と、Codableを使用したアーカイブ解除時の安全性の両方が含まれます。

新しいAttributedStringで何ができるかを簡単に見てみましょう。 AttributedString

私たちは感謝のメッセージを作るつもりです。ありがとう。

まず、単純な初期化子を使用して属性文字列を作成します。

この文字列全体に属性を設定したい。

それはフォントプロパティを設定するのと同じくらい簡単です。

Struct AttributedStringでは、すべての属性が直接利用可能で、正しい型を使用します。

たとえば、このプロパティはSwiftUIフォントです。

次に、別の属性文字列を作成します。

これは当社のウェブサイトへの参照なので、リンクプロパティをURLに設定しました。

ここでは、文字列全体にフォントとリンクを設定しています。

後で文字列の一部だけを変更する方法を見ていきます。

もう1つの便利なツールは、属性コンテナです。

文字列なしで属性と値を単独で保持できる場所です。

ここでは、メッセージの重要性に応じて、コンテナを作成し、その上にいくつかの属性を設定します。

そして最後に、これらの属性を両方の属性文字列にマージします。

前述したように、帰属文字列は文字、範囲、辞書の組み合わせです。

帰属文字列自体は、それらの単一のもののコレクションではありません。

代わりに、これらのプロパティにアクセスするために、ビューと呼ばれるものがあります。

2つの最も重要なビューは、文字列へのアクセスを提供する文字と、属性へのアクセスを提供する実行です。

これらのビューはSwiftコレクションです。つまり、Arrayのようなタイプから慣れ親しんだ関数もここで利用できます。

別の例を見てみましょう。

私たちのデザイナーが、すべての句読点を楽しいオレンジ色にすることで、感謝のメッセージに少しピザを追加するように言ったとしましょう。

これを行うには、まず、属性文字列の句読点がどこにあるかを見つける必要があります。

他のSwiftコレクションと同様に、帰属文字列ビューは、単にコレクション内のいくつかの要素の位置であるインデックスを使用します。

インデックスで反復するには、標準のライブラリインデックス関数を使用します。

次に、isPunctuation関数を使用して、この文字が変更する必要があるかどうかを確認します。

最後に、帰属文字列の別の機能であるスライスを使用して、文字列全体のサブレンジのみに属性を適用します。

範囲はこのインデックスから始まり、その後の次のインデックスまで続くので、1文字です。

そして今、句読点はオレンジ色です。

別のビューを見てみましょう、実行します。

実行は、特定の属性の開始場所、長さ、および値です。

メッセージのすべてのランを数えることから始めることができます。

これにより、文字列内の属性値の連続した範囲が反復されます。

この文字列には4つのランがあります。

各実行には、各属性の値またはnilがあります。

文字と実行の範囲は交換可能なので、属性またはその逆の文字列を見つけることができます。

ここでは、文字ビューの添字の属性の範囲を使用し、結果をスタンドアロンの文字列に変換します。

多くの場合、特定の属性に焦点を当てて実行を見ることが最も有用です。

ここでは、キーパスリンクを使用して、リンク属性のみを合体させます。

結果のコレクションの各要素は、文字列に設定される可能性のある他の属性を考慮せず、リンク属性の値を提供します。

リンクだけを見ると、3つのランがあります。1つ目は設定されていない、2つ目は値に設定されています。3つ目は、文の最後のピリオドで、再度設定されていません。

実行を反復すると、値と範囲のタプルが得られます。

値はタイプセーフであるため、間違ったタイプをキャストしたり心配したりすることなく、URLに存在するスキームのようなAPIを使用できます。

ここでは、帰属文字列内のすべてのリンクがhttpsであることを確認しています。

もう1つの便利なテクニックは、部分文字列を探し、その範囲を使用して文字や属性を編集することです。

「訪問」という言葉をより後退の雰囲気を持つものに置き換えたいとしましょう。

まず、部分文字列の範囲を探します。

次に、その範囲を使用して、そのサブ範囲のみに属性と文字を設定します。

結果は、このように6回の実行を持つアトリビュートリビュートリス文字列です。

次に、ローカリゼーションについて話しましょう。

AttributedStringは完全にローカライズ可能です。

また、Objective-CのNSAttributedStringにローカリゼーションサポートを追加しました。

属性文字列は、通常の文字列と同じように、アプリの文字列ファイルにあります。

Swiftでは、SwiftUIのテキストビューと同様に、文字列補間を使用して、StringとAttributedStringのローカライズされた書式設定をサポートするようになりました。

これは簡単な例です。

この関数は、ユーザーのドキュメント名でカスタマイズされたローカライズされた文字列を返します。

%@ や %d などの書式指定子を使用して書式関数を呼び出す代わりに、値を直接入力できるようになりました。

同じアプローチがAttributedStringにも有効です。

Xcodeは、コンパイラを使用して、これらの新しい初期化子から文字列ファイルを生成できます。

オンにするには、ビルド設定に移動し、ローカリゼーション設定を探し、「コンパイラを使用してSwift文字列を抽出する」をオンにします。

ローカライズされた帰属文字列がどのようにその属性を取得するのか疑問に思うかもしれません。

AttributedStringにMarkdownのサポートを追加したことをお伝えできることを嬉しく思います。

SwiftUIテキストで、ローカライズされた属性文字列を使用する例を次に示します。

私は普通のひもから始めます。

テキストの周りに2つのアスタリスクを追加することで、SwiftUIが太字としてレンダリングすることを強調します。

アンダースコアを使用してテキストを強調することができ、SwiftUIはイタリック体としてレンダリングします。

リンクもサポートしています。

これは、ローカライザーがさまざまな言語にカスタマイズされたURLを提供する絶好の機会です。

また、取り消し線やコードボイスなどの他のインラインスタイルもサポートしています。

最後に、帰属文字列のアーカイブについて話しましょう。

まず、NSAttributedString参照タイプとの間で変換する機能が必要です。

アトリビュート文字列はデータモデルの一部になることができます。つまり、それらをエンコードおよびデコードできる必要があります。

最後に、Markdownでカスタム属性を指定する方法が必要です。

これらの操作はすべて相互に関連しています。

コンバージョンを見ることから始めましょう。

私たちは皆、NSAttributedStringを使用する多くのコードを書いたので、構造体からクラスタイプへの変換を簡単にしました。

NSAttributedStringプロパティを持つビューを次に示します。

変換するには、構造体AttributedStringをNSAttributedString初期化子に渡すだけです。

SDKの一部である属性については、私がする必要があるのはこれだけです。

では、エンコードとデコードを見てみましょう。

これは、Cafféアプリからの領収書を保持する構造体です。

繰り返しになりますが、SwiftUI、UIKit、AppKit、Foundationが提供する属性を使用しています。

つまり、AttributedStringのデフォルトのCodable実装は、私が必要とするすべてです。

領収書にコード可能な適合性を追加するだけで、完了です。

もう少し進んで、カスタム属性をエンコードするためのサポートを追加しましょう。

属性自体について話すことから始めます。

属性は、キーと値の2つの部分です。

キーは、新しいAttributedStringKeyプロトコルに準拠したタイプです。

これは、必要な値の種類とアーカイブの名前を定義します。

このキーは、値のエンコードまたはデコード方法をカスタマイズするために、他のプロトコルに準拠することもできます。

余分な色を持つために、帰属文字列の範囲を定義したいとしましょう。

このレインボーエフェクトには、プレーン、ファン、エクストリームの3つのレベルがあります。

列挙型を使用してその値を表し、名前をレインボーに設定します。

タイプと名前を定義することは、このプロトコルの唯一の要件です。

さて、この属性をコード可能にし、エンコードされた属性文字列の一部にしたいとしましょう。

私がしなければならないのは、このようにCodableコンフォーマンスを追加することだけです。

最後に、レインボーレベルをローカライズされた文字列の一部にしたいとしましょう。

つまり、それがどこにいても、どの言語でも、文字列の正しい部分に適用できることを意味します。

必要なのは、オプトインするためのもう1つのプロトコル適合だけです。

属性がMarkdown decodableであると言うと、Markdownから直接デコードし、アトリビュート文字列に挿入できます。

必要なのは、値がコード可能であることだけです。

次に、Markdownのカスタム属性構文を見てみましょう。

この最初の例では、リンクへの参照があります。

リンクテキストには角括弧を使用し、リンク先であるURLには括弧を使用します。

この2番目の例では、画像への参照があります。

感嘆符で始まり、画像の説明には角括弧を使用し、画像ソースには括弧を使用します。

これらの最初の2つの例は、Markdownで一般的です。

3番目の例は、カスタム属性の構文を示しています。

キャレットから始まり、テキストには角括弧を使用し、属性には括弧を使用します。

属性はJSON 5で表されます。

JSON 5はJSONと互換性があり、引用符で囲まれていないキー、コメント、その他いくつかの機能を可能にします。

このような人間に優しいひもにぴったりです。

また、Foundationの他のJSON APIにJSON 5のサポートを追加しました。

カスタム属性はJSONを使用するため、JSONDecoderでデコードできるものはすべて、新しいカスタムMarkdown構文と自動的に互換性があります。

ここでは、単一の属性、2つの属性、1つの文字列と1つの数値、および複数のプロパティを持つ単一の属性があります。

ここには1つの追加部分があります。これは、Markdownでこれらの名前をSwiftタイプに結びつける方法です。

その作品は属性スコープと呼ばれます。

スコープは属性キーのグループです。

スコープは、どの属性、名前、およびそれらをデコードする方法を教えてくれるため、JSONまたはMarkdownからデコードするときに便利です。

Foundation、UIKit、AppKit、SwiftUIのスコープをそれぞれ1つずつ定義します。

独自の属性の範囲を定義することもできます。

Cafféアプリの範囲を定義しましょう。

AttributeScopes内にスコープをネストし、AttributeScopeプロトコルに準拠します。

次に、スコープ内の属性を「let」でリストアップするだけです。これまでのところ、私たちは虹の属性だけを持っています。

次に、SwiftUIスコープを私たちの中に含めます。

それは私たち自身のものに加えて、それらの属性のすべてを可能にします。

スコープは再帰的にネストされるため、これにはFoundation属性も含まれます。

新しいスコープのプロパティを定義すると便利です。

これにより、スコープを引数として取る関数でキーパス構文を使用できます。

最後に、カスタムMarkdownからローカライズされたカラフルな属性文字列をロードできるようになりました。

また、NSAttributedStringとの間のアーカイブと変換のためのスコープ取得関数もあります。

これにより、すべてのステップで動作をカスタマイズできます。

これは再びCafféアプリの最初の画面で、タイトルにカスタムレインボー属性を見ることができます。

ローカライズされた文字列がMarkdownからアトリビュート文字列に変換された後、アプリは属性を見つけ、文字列のちょうどその範囲に楽しい効果を適用します。

この属性はローカライズされた文字列ファイルから来ているため、スペイン語など、Cafféがサポートするすべての言語で正しく機能します。

しかし、私たちはまだ始まったばかりです。

また、まったく新しいフォーマッタAPIもあります。

フォーマッタは、もう1つの長年のFoundation機能です。

彼らは、数字、日付、時刻などのデータを取り、ローカライズされたユーザーが提示可能な文字列に変換する責任があります。

フォーマッタは、かなりの構成データによって裏打ちされているため、それらをキャッシュして再利用するのは一般的なパターンです。

しかし、アプリは多くの異なるコードで構成されています。

それらすべての間でフォーマッタを共有することは必ずしも理にかなっているとは限りません。

また、人々が日付と時刻を読む多種多様な方法に加えて、私たちのデザインに合った方法でこのデータを提示したいというアプリの作者としての私たちの願望のために、エッジケースのための多くの機会があります。

今年は、Formatter APIを一から再考することで、パフォーマンスと使いやすさの両方を改善しました。

要するに、私たちの新しいAPIはフォーマットに焦点を当てています。

地震のサンプルアプリからこのコードを見てみましょう。そこでは、キャッシュパターンの動作を見ることができます。

それは2段階のプロセスを持っています。

まず、フォーマッタを作成して設定します。

次に、フォーマッタに日付を与え、文字列を取得します。

どうやればもっと簡単になるの？

さて、独自の日付フォーマッタを作成する要件を削除することから始めましょう。

これをキャッシュする必要があることを忘れるのは本当に簡単でした。これにより、テーブル内のすべてのセルに対して同じフォーマッタを再作成することになりました。

次に、書式設定のステップ。

日付をフォーマッタに渡す代わりに、日付自体を使いましょう。

今はたった1行のコードです。

必要なフォーマットを指定すれば、それだけです。

この数字の形式についてもっと話しましょう。

それは多くのコードではありませんが、いくつかの複雑さを隠しており、注意すべきいくつかの落とし穴があります。

引数が浮動小数点数でない場合は、ここで完全に間違った出力を取得します。

読者は、浮動小数点数をフォーマットするための特殊なケースの構文と、単なる文字列定数である修飾子のセットを認識する必要があります。

このコードは理解しやすく、維持しやすく、読みやすいと思います。

通常のSwift関数を使用して、番号のフォーマット方法を正確に指定します。

また、オートコンプリートとタイプの安全性も得ます。

この新しいアプローチをFoundationの10人のフォーマッタすべてに適用しました。

インターフェイスをクリーンアップして簡素化し、一般的な落とし穴を避けるために変更を加え、途中で多くの新機能を追加しました。

最も一般的なフォーマットされたタイプの2つ、日付と数字を詳しく見てみましょう。

日付の書式設定は、カレンダーとタイムゾーンを使用して、絶対的な時点を人間が日付として理解するものに変換することです。

そしてそれ以上に、それは人間が自分の日付がどのように見えるかについて持っているすべての好みを考慮に入れています。

私たちはそれらの好みをロケールと呼んでいます。

日付をフォーマットするために必要な少量のコードを見てみましょう。 日付をフォーマットする必要があります。

まず、Date.nowを使用して現在の時点を取得します。

次に、フォーマットされた関数を呼び出します。

それでおそれ。

もちろん、先ほど例で見たように、日付の書式設定には多くのオプションがあります。

だから、これを少し広げましょう。

フォーマットされた関数は、日付または時刻のみを表示するように設定できます。

これらの議論の両方には、いくつかの選択肢があります。

この新しい書式設定APIの重要な目標は、正しい書式を作成する際にできるだけ多くのコンパイル時間のヘルプを提供することです。

魔法の文字列値を使用したフォーマットは、通常の状況下ではフォーマットが正しく見えますが、年末のようなエッジケースで完全に間違った値を生成する落とし穴を作成することで悪名高いです。

ここでもデフォルトのフォーマットです。

これは、このような日付と時刻のスタイルを尋ねる短いバージョンです。

議論のないバージョンとシンプルなスタイルのバージョンの両方で、デフォルトのフォーマットを選択します。

ただし、日付を本当にカスタマイズしたい場合は、ここから関心のあるフィールドを追加するだけです。

この例では、スタイルにフィールドを追加してフォーマットを構築します。

私は年、日、月だけが欲しい。

その他の可能性には、時間、分、秒などが含まれます。

出力形式は、ユーザーのロケールに応じて自動的に調整されます。

これらのフィールドも設定可能です。

この場合、月をワイドフォーマットに変更します。つまり、完全な月名が印刷されます。

日付の一部だけをフォーマットすることは、このAPIでも簡単です。

ここで私は平日だけを手に入れたいです。

日付はさまざまなスタイルにフォーマットすることもできます。

ここでは、ISO 8601形式とiso8601を使用することを選択しますが、年、月、日のみを使用し、ダッシュで区切られています。

これらの例では、書式設定パターンが明確になります。

フォーマットしたい値から始めます。

フォーマットされた関数を呼び出し、引数はスタイルです。

タイプごとに複数の種類のスタイルがあるかもしれません。

たとえば、DateにはdateTimeとiso8601の両方があります。

スタイルは、デフォルト設定で使用することも、カスタマイズすることもできます。

この書式設定APIは、フィールドのリストを指定することで機能し、そのうちのいくつかには追加のオプションがあります。

提供するフィールドの順序は関係ありません。

各フィールドは、最終出力のどこかにどの値を含めるべきかをフォーマッタに伝えるだけです。

引数がない、またはスタイル名のみのAPIの最短バージョンの賢明なデフォルトを選択します。

フィールドの追加を開始すると、出力はカスタマイズされ、UIのプレースホルダテキストのように、表示することを選択したものだけを反映します。

また、互いに相対的な2つの日付をフォーマットするための新しいAPIもあります。

ここにいくつかの例があります。

まず、範囲内の2つの日付をフォーマットします。

2つの日付で通常のSwift範囲構文を使用できます。

書式設定範囲では、単一の日付で行ったのと同じように、日付と時刻の表示を設定できます。

この範囲は、期間、コンポーネント、または現在に対する単一の日付としてフォーマットできます。

書式設定のもう1つの新機能は、出力です。

これにより、ユーザーの好みに合わせて再配置した後、フォーマッタがフォーマットされた値の特定の部分を置いた場所を見つけることができます。

もちろん、これは新しい構造体AttributedStringを使用します。

フォーマットされた出力にスタイリングを適用すると、あらゆる種類の場所に表示されます。

watchOSでは、コンプリケーションの多くはフォーマットされた文字列です。

Apple Watchはそのような個人的なデバイスであるため、ユーザーの好みを考慮に入れることが重要ですが、日付の一部にユーザーが選択した色を与えるなど、特定の種類のデザイン言語を適用したい場所でもあります。

これを設定することは、実際にはSwiftUIではかなり楽しいです。

デモで一緒に見てみましょう。

ここに私のカフェコンパニオンアプリの出発点があります。これは、あなたの次の無料のコーヒーがいつであるかを示しています。

フォーマットされた日付を表示するSwiftUIビューがあります。

フォーマットにロケールを設定したので、ここでSwiftUIプレビューで制御できます。

かなり良いスタートですが、もう少しカスタマイズしたいと思います。 もう少しカスタマイズしたいと思います。

これを私のアプリにもう少し具体的にすることから始めましょう。

私は分、時間、平日だけを気にします。

OK、かなり良さそうだね。では、色のスプラッシュを加えましょう。

まず、戻り値の型をAttributedStringに変更し、帰属出力を要求します。

次に、属性コンテナを使用します。

これらは、文字列内の特定の文字にアタッチされることなく、属性を保持することができます。

日付形式が出力に配置する平日属性用に作成します。

平日を含む文字列の範囲に設定されています。 

次に、設定したいカラー属性のコンテナを作ります。

最後に、帰属文字列関数を使用して、最初のコンテナ内の属性に一致する属性を、帰属文字列の2番目の属性の値に置き換えます。

AttributedStringは値型であり、置換は突然変異関数であるため、「let」を「var」に変更する必要があります。素敵ですね。

さらに良いことに、それはすべてのロケールで機能します。

再確認するために、プレビューにもう少し追加しましょう。

ここでは、これらのロケールのフォーマットされた日付のどこにあっても、平日はオレンジ色であることがわかります。

さらに新しいフォーマッタAPIについて学び続けましょう。

日付を文字列に変える方法を見たので、文字列を日付に変える方法について話しましょう。

日付には、戦略引数を取る初期化子があります。

この戦略は、入力に期待されるフィールドをパーサーに伝えるために使用されます。

日付については、フォーマットも一種の戦略です。

これは、出力を表示し、ユーザーが新しい日付を入力できるテキストフィールドのように、日付をラウンドトリップするのに便利です。

これは往復の例です。

解析が投げられることに気付くでしょう。

これは、入力によっては、解析が失敗する可能性があるためです。

一部の戦略には、解析のためのより高度なオプションがあります。

ここでは、固定フォーマットを解析します。これは、日付フォーマットがサーバーから受信したものである場合に便利です。

それを使用するには、書式文字列で戦略を初期化します。

しかし、魔法の文字列値を使用する代わりに、文字列補間を使用します。

この場合、年-月-日の形式の文字列を期待します。

各補間はフィールドによって明確に識別され、それぞれが期待する形式を正確に指定します。

これの1つの本当に良い点は、オートコンプリート体験です。

別の日形式を使用したい場合、オートコンプリートは、それぞれが何を意味するかについてのドキュメントとともに有効なオプションを表示します。

いいえ、1年に解析するために何Y文字を使うべきかを推測してください。

数字に移りましょう。

数値の書式設定は、整数または浮動小数点の値を人間が読み取ることができるものに変換することです。

すべての書式設定と同様に、数字の表示方法に関する設定を考慮に入れます。

これには、使用される数字の種類から、数字をグループ化するために使用される文字まで、すべてが含まれます。

日付の書式設定と同様に、追加のパラメータを必要とせず、優れた出力を得るのは簡単です。

サポートされている多くの種類のオプションと出力があります。

ここでは、パーセンテージ、科学的表記法、通貨を示します。

最後に、いくつかのフォーマットをまとめましょう。

リストの書式設定は、配列をフォーマットするだけです。

このメンバースタイル引数は、配列内の各要素のフォーマットスタイルを指定します。

これらは数字なので、パーセンテージを使いたいです。

出力はすべてのユーザーのロケールに対して正しいです。

これまでのところ、私たちは値を直接フォーマットすることに焦点を当ててきました。

SwiftUIは、TextFieldにフォーマットスタイルを添付することもサポートしています。

フォーマットスタイルには、フォーマットされる値の種類に関するタイプ情報があるため、ここで私の領収書のチップパーセンテージには、読み取り可能で安全な構文を使用できます。

Cafféアプリをもう一度見て、フォーマットが表示される場所の数を見てみましょう。

成分にはリスト形式を使用します。

価格には通貨形式を使用しています。

数量には数値形式を使用し、注文ボタンでカウントをローカライズします。

私たちは、あなたがいつもここの隅に見る日付形式を忘れることはできません。

フォーマットされた出力は至る所にあり、この新しいAPIはアプリでも簡単に、さらに楽しくなると思います。

ローカライズされた文字列やフォーマッタに役立つリソースはもっとたくさんあります。

このトピックについては、「SwiftUIアプリをローカライズする」と「ローカライズされた文字列を合理化する」という2つのセッションがあります。次に、自動文法合意と呼ばれる新機能について話しましょう。

スペイン語のような言語のローカライザーは、自然な翻訳を表現する能力が制限されており、時には厄介な対話につながります。

これらの言語は、スピーチの異なる部分間の性別と複数化の合意を達成するために変換を必要とし、時にはユーザーの好ましい住所用語の知識を必要とすることさえあります。

英語にもこの特徴があり、単数形と複数形が異なる名詞があります。

私はそこに多くの言語の専門用語を捨てたので、例を見てみましょう。

私のカフェアプリでは、食品、サイズ、数量を選ぶことができます。

私は小さなサラダを1つ選びます。

今、私の友人は彼女が私に加わると言っているので、私はカウントを2に増やします。

英語では、「サラダ」という単語は数字の2と一致するように変更されなければなりません。

これは合意と呼ばれています。

つまり、この文の単語は互いに一致しなければならないということです。

英語では、複数形のために単語を修正することは、一般的な種類の合意です。

では、アプリをスペイン語に切り替えて、エンサラダペケーニャを1つ、または小さなサラダを1つ注文しましょう。

友人のために注文するとき、この注文ボタンは英語と同じ複数形が必要ですが、ひねりがあります。

スペイン語では、形容詞ペケニャと名詞エンサラダの両方がカウント、ドスと一致する必要があります。

だから、ensalada pequeñaの代わりに、ボタンにはensaladas pequeñasと書かれています。

次に、飲み物に進みます。

この文では、ボタンは正しい複数形化だけでなく、これらの単語の文法的な性別にも同意する必要があります。

ジュース、ジュゴは男性的です。

形容詞ペケニョも一致しなければならない。

このようなテキストを正しくローカライズするために、組み合わせの爆発に終わります。

食品、サイズ、カウントの組み合わせごとに異なるローカライズされた文字列が必要です。

コードでは、多くの場合、このように見えることになり、各アイテムを切り替えてから、各サイズを切り替える必要があります。

カウントのためにこれらの文字列のそれぞれを正しく複数形にできるstringsdictファイルもあります。

さて、キーボードの提案を強化するのと同じ技術を活用して、これらすべてのケースなどを簡単に処理できる新しいAPIを作成しました。

システムは、正しい文法を持つようにローカライズされた文字列を自動的に修正するため、この機能を自動文法合意と呼びます。

これで、コードははるかにシンプルになります。

数量、サイズ、食品を1つの文字列にまとめることができます。

自動文法合意は、inflectionと呼ばれるプロセスを使用して文字列を修正します。

それを分解しましょう。

屈折するには、文字列のどの部分を修正する必要があるかを知る必要があります。

幸いなことに、Swiftにはそれができるタイプ、AttributedString、およびMarkdownのカスタム属性があります。

この文字列では、その構文を使用して、食品、サイズ、および屈折属性でカウントをラップします。

属性の値はtrueです。

このプロジェクトのローカリゼーションをエクスポートすると、注釈付き文字列と、食品の名前やサイズなどのソースコード内の他のローカライズされた文字列を含む文字列ファイルを取得します。

これがラテンアメリカスペイン語の文字列です。

ローカライザーは、「small」や「large」のような形容詞がスペイン語の名詞の前にあるため、引数並べ替え構文%1、%3、%2を使用しました。

彼らは、文字列のこの領域を屈折するためのカスタム属性構文を保持し、食品とサイズの翻訳を提供します。

自動文法エンジンは、残りを修理します。

一部の言語は、ローカライズされたテキスト自体の単語間だけでなく、そのテキストとそれを読んでいる人との間の合意を特徴としています。

自動文法合意もそれに役立ちます。

例えば、このメモのウェルカム画面を見てみましょう。

英語では「Welcome to Notes」と言います。スペイン語では、「Te damos la bienvenida a Notas」または「Notesへようこそ」と言います。私たちはスペイン語で英語と同じ経験をしたいと思っています。

ただし、スペイン語では、「bienvenido」という単語は、ユーザーの好みの住所用語と一致する必要があります。

この用語はいくつかの選択肢の1つである可能性があり、その選択はテキストを変更します。

正しい住所用語を使用すると、より個人的で包括的な経験が得られます。

今年のリリースでは、スペイン語を使用する人々が住所の用語を指定できるようにしました。

言語と地域の設定では、新しい住所期間オプションがあります。

選択すると、好みを選択し、すべてのアプリと共有することもできます。

ここでは、女性的な住所用語のメモに新しいウェルカム画面が表示されます。

そして、ここでは男性的な住所の用語です。

わからない場合、またはユーザーが指定したくない場合は、元の文字列を代替として保持します。

先ほど見たのと同じ抑揚属性は、ユーザーを参照するローカライズされた文字列でも使用されます。

「ようこそ」の場合、bienvenidoという単語に抑揚属性を適用します。

英語の文字列は変更する必要はありません。

また、ユーザーの好みに関する情報がない場合にエンジンが使用する置換文字列である抑揚の代替を追加することもできます。

今年は、スペイン語と英語の自動契約をサポートします。

ノートのウェルカム画面など、OS全体のいくつかの場所で採用しました。

アプリにも採用できます。

必要なコードの変更は、ほとんどの場合、異なる文字列を選択するために多くのロジックを削除するだけです。

何を反転させるかについての指示は、ローカライズされた文字列自体の一部であり、ローカライザーは文字列が自分の言語でどのように表示されるかをより詳細に制御できます。

Cafféアプリの自動文法契約を見てみましょう。 

英語で実行されているカフェアプリを見てみましょう。

注文にピザを追加することから始めます。

私は大きなものを持っていると思います。そしてちょうど1。

ボタンのテキストが大きなピザ0枚から大きなピザ1枚に変わったことに注目してください。

それは自動的に行われました。

2を選べば、また直ります。

1つだけもらいます。

この画面の下部で、注文ボタンが「1項目」に変更されました。

何か飲み物はいかがですか?

小さいのは大丈夫です、そしてこれらのうちの1つだけです。

ボタンが「アイテム」ではなく「アイテム」と言うように変更されたことに気づきましたか?

その文字列は自動的に変更されました。

チェックしましょう。

これが私たちの領収書です。

ピザとジュース、およびフォーマットされた価格が記載されています。

下部には、カスタムフォントとウェブサイトへのリンクを含む、私たちの帰属文字列があります。

Xcodeに戻って、ソースを見てみましょう。 ソースを見てみましょう。

食べ物の詳細ビューから始めます。

これは、サイズ選択画面を表示するビューです。

新しいサイズを追加して、食べ物の種類、サイズ、カウントごとに1つではなく、スペイン語のローカライズされた文字列を1つ追加する必要があるかを確認できるようにしましょう。

この行はリストを示しています。

リストは私たちのモデルオブジェクトから来ています。

そこに行きましょう。

サイズ列挙型はすでに小さいものと大きいものがあります。

私は「巨大な」と呼ばれる私たちの飢えた顧客のために新しいサイズを追加するつもりです。これを行うには、ローカライズされた文字列とともに新しいケースを追加します。

今、私は巨大なサイズの価格を追加する必要があります。

このデモでは、イニシャライザに入れただけです。

今、私は巨大なサイズの価格を追加する必要があります。

このデモでは、イニシャライザに入れました。

私たちの見解をもう一度見てみましょう。

プレビューでは、私たちの新しいサイズです。

私たちのソースにはすでに英語の文字列が含まれています。

私は今、スペイン語のものが必要です。

新しい文字列を生成するには、コンパイラを使用して「巨大な」の新しいローカライズされた文字列を見つけます。これを行うには、[製品] > [ローカリゼーションのエクスポート] を選択し、スペイン語の文字列を保存します。

では、スペイン語の翻訳を追加しましょう。

新しい文字列をフィルタリングして、スペイン語の単語を入力できます。

次に、これらのローカリゼーションをインポートしてアプリに入れます。

今、私は再び私たちのアプリを実行しますが、スペイン語で。

これを行うには、[製品] > [スキーム] > [スキームの編集] を選択します。

オプションでは、テストしたい言語を選択できます。

そして走る。

私たちのヘッダーから、私たちが今スペイン語で走っていることがわかります。

サラダから始めて、別の注文をしましょう。

数量を変更すると、注文ボタンが固定されます。

私たちの新しい巨大なサイズは、2つのサラダのために正しく複数形化されています。

さらに、それは「ensalada」の文法的な性別と一致し、すべて1つの文字列で一致します。

今年はFoundationに多くの素晴らしい新機能があり、今日あなたのアプリで試す準備ができています。

AttributedStringは、文字列の範囲にキーと値のペアを追加するための、高速で使いやすいSwiftファーストのインターフェイスを提供します。

テキストでSwiftUIと一緒に使用し、ローカライズされた文字列でMarkdownを使い始めることができます。

新しいFormatter APIは、フォーマットに焦点を当て、コードを簡素化し、パフォーマンスを向上させます。

アプリでデータを表示するすべての場所でフォーマットを使用してください。

最後に、自動文法契約は、文法的な性別、カウント、およびユーザー自身のアドレス用語と一致するように、ローカライズされた文字列をインテリジェントに修正します。

これらの新機能を気に入っていただければ幸いです。

私たちはあなたのアプリでそれらを見つけるのを楽しみにしています。

ありがとうございます。

[音楽]。