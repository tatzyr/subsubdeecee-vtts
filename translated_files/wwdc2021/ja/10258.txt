10258

こんにちは、私の名前はAnubhavで、OSパフォーマンスチームのエンジニアです。

今日は、アプリケーションからのハングを理解し、排除する方法を共有することに興奮しています。

この講演を4つのセクションに分割し、「ハングとは何ですか?」を理解することから始めます。

次に、ハングの一般的な原因と、開発時に何に気付き合うべきかについて話します。

その後、ハングアップの監視と診断に使用できるツールについて説明します。

最後に、ハングをなくすための一般的な戦略と、アプリに最適なものを選択する方法を学びます。

すぐに飛び込みましょう。

私の新しいレシピアプリ、デザート、私のお気に入りの飲み物やデザートの作り方を教えてくれるアプリを見てみましょう。

このマンゴータンゴのスムージーは美味しそう。

それをタップして、それがどのように作られているかを確認します。

うーん。

何も起こっていないようです。

うわー。それは予想以上に時間がかかりました。

アプリはちょうど立ち往生していて、数秒間私のタッチを受け入れませんでした。

この経験は、「遅れている」、「遅い」、または「立ち往生」と表現できます。

これらは、私や他の誰かが彼らのアプリを説明するために使いたい言葉ではありません。

Appleでは、この無反応の時期を「ハング」と呼んでいます。

ハングとデザートで何が起こっているのかを理解するには、まずアプリの主なランループが何であるかを理解する必要があります。

メインランループは、アプリケーションのメインスレッドが入力するループで、着信イベント、主にユーザーインタラクションに応答してイベントハンドラを実行します。

ユーザーがアプリと対話すると、ランループはイベントを受信して処理し、必要に応じてUIを更新します。

これはすべて、ランループの1回転とメインスレッドで発生します。

このプロセスは、ユーザー入力ごとに繰り返されます。

これは、ランループを1回すると、メインスレッドがどのように見えるかです。

イベントの処理に時間がかかる場合、ユーザー入力とUIの更新の間に遅延が発生します。

さらに悪いことに、イベントはバッファリングされ、ハング中にメインスレッドでは処理できません。

ハング中にアプリと対話すると、現在のハングが最初に終了するまで、そのイベントは処理されません。

一般的に、1秒以上の遅延は常にハングのように見えますが、より短い遅延は1つとして認識することができます。

たとえば、スクロール中の半秒の遅延は不快ですが、ビューに入ると同じ遅延がはるかに目立ちません。

ハングをなくすことで、アプリは素早く、素早く、反応が良くなります。

ハングがわかったので、一般的に原因を調べてみましょう。

メインスレッドでの作業が多すぎると、ハングが発生します。

その作業が何であるかを正確に判断するには、イベントの処理中にメインスレッドが何をしているかを確認する必要があります。

今回は2つのケースに分けることができます。

メインスレッド自体が作業で忙しいか、これは単一の長いタスクでも多くの短いタスクでもか、メインスレッドが別のスレッドまたはシステムリソースによってブロックされています。

メインスレッドがビジーになっている一般的な原因を見ることから始めましょう。

積極的に作業を行うことは、UIを更新するために必要な以上のことを行い、メインスレッドをより長くビジー状態に保ちます。

Dessertedでは、レシピビューは、多くの成分画像のうち4つの画像タイルのみを表示します。

メインスレッドがすべての成分画像を一度にロードすると、すべての画像の読み取り、準備、合成に時間を費やします。

起こっている仕事のほとんどは、ユーザーが見ているものにさえ影響しません。

ビューには4つの画像しか表示されず、その4つだけをすぐに生成する必要があります。

ハングのもう1つの原因は、メインスレッドで無関係な作業を行うことです。

メインスレッドサービスはメインディスパッチキューからブロックしますが、ディスパッチ同期を介して他のキューからブロックをサービスすることもできます。

キューディスパッチが別のキューに同期するたびに、他のキューのすべての保留中のブロックは、新しくキューに入れられたブロックの前に実行する必要があります。

優先度の低いシリアルディスパッチキュー、おそらくメンテナンスキューを持つアプリを検討してください。

メインスレッドディスパッチがメンテナンスキューにブロックを同期した場合、キューに入れられたブロックが実行される前に、そのキュー上のすべての保留中のブロックが実行されるのを待つ必要があります。

メインスレッドのための作業に費やされた時間のほんの一部でした。

同様に、ブロックが別のキューからメインキューにディスパッチされた場合、そのブロックはメインスレッドで実行されなければなりません。

これは、ブロックがディスパッチ非同期を介してキューにされた場合でも有効です。

ハングのもう1つの原因は、最適でないAPIを使用することです。

タスクを達成する方法はたくさんあります。

手元のタスクに最適なものを使用できるように、必ずAPIドキュメントをお読みください。

Dessertedは、レシピビューのすべての画像に丸みを帯びた角を追加しますが、そうすることで、このビューに入るときにレイテンシも追加されます。

丸みを帯びた角を追加するには、 Desserted はビットマップベースのグラフィックス コンテキストを使用して画像をビットマップに変換し、そのビットマップに UIBezier パスを適用し、そのビットマップを画像に戻します。

この一連の操作はCPU集約型で、多くのメモリを使用し、長い時間がかかることがあります。

これは、間違ったハードウェアが仕事に使われているためです。

CPUを使用する代わりに、GPUを活用する必要があります。

レイヤーでCoreAnimationメソッドを使用することで、丸みを帯びた角を追加することは簡単かつ瞬時にできます。

これは、手元のジョブに間違ったAPIを使用する一例にすぎません。

アプリのメインスレッドがビジー状態になる可能性がある一般的な理由を調べたので、なぜブロックできるのかを調査しましょう。

同期APIは、呼び出された時間から戻る時間まで実行をブロックします。

APIが多くの作業を行う場合、または長期間ブロックする可能性がある場合は、これらをメインスレッドで使用しないでください。

遅延とは別に、これらはまた、追加の障害点を追加します。

そのようなケースの1つは、アプリのメインスレッドがネットワークに同期要求を行う場合です。

5Gを持っている人にとっては、遅延はないかもしれません。

ネットワーク速度が遅い人にとっては、これには時間がかかる場合があります。

そして、信号が非常に悪い人にとっては、これは無期限にハングアップする可能性があります。

これにどれくらいの時間がかかるかの保証はありません。そのため、そのような同期操作はメインスレッドで避けるべきです。

メインスレッドをブロックするもう1つの方法は、システムリソースです。これらはしばしば制約されます。

ファイルI/Oは、最も一般的に使用され、競合するシステムリソースの1つです。

レイテンシは、ハードウェアに依存し、他の読み取りと書き込みが同時に発生し、アプリの制御を超える可能性があります。

したがって、アプリはメインスレッドのI/Oを回避することで、ハングアップから守るためにできることをする必要があります。

並行性をサポートしていないデータストアは特に問題です。

書き込みがすでに発生している間にメインスレッドが1つから読み込もうとすると、すべてのライターが完了するまでその読み取りがプッシュされ、これは無制限になる可能性があります。

ハングのもう一つの原因は同期です。

定義上、同期プリミティブは実行をブロックする可能性があるため、メインスレッドからの同期を制限し、注意することが重要です。

同期するスレッドは、暗黙的または明示的なロックを解放するのに長い時間がかかることがあります。

これらは、@synchronizedディレクティブ、ディスパッチ同期、os unfairロック、posixロックなど、見るべき一般的なプリミティブです。

具体的には、優先順位を伝播せず、プリエンプションのためにハングを長くする可能性があるため、セマフォの使用に注意してください。

一般的なアンチパターンは、セマフォを待って非同期APIを同期させようとするときです。

これは常にメインスレッドで避けるべきです。

メインスレッドをブロックするもう1つの方法は、作業、IPC、またはシステムリソースを使用して、頻繁に変更されないものの値を取得することです。

Dessertedには、ソーシャル機能のアイコンがあり、連絡先を友達として追加した場合にのみ表示されます。

このビューをタップするたびにすべての連絡先を照会することは、チェックする1つの方法ですが、フレームワークのメインスレッドブロックは、ボンネットの下で高価な操作を実行しているため、不要なオーバーヘッドと遅延を追加します。

さらに、私が取得している値は頻繁に変更されないので、これを頻繁に照会することは不要であり、システムリソースに負担がかかります。

CPU、メモリ、ストレージなどのシステムリソースの状態は、ハングが発生した場合に大きく影響します。

現場でのハードウェアとデバイスの条件が異なることは、現実世界のシナリオが机の上でテスト中に遭遇したものとは大きく異なることを意味します。

堅牢なテストを行い、最も古いサポートされているハードウェアをベンチマークとして使用することで、これらのケースから防御するためにできることをすることが重要です。

ハングの高レベルの原因は、メインスレッドで、またはメインスレッドに代わって行われる作業が多すぎることです。

パフォーマンスを確保するためには、アプリケーションのメインスレッドがUIを更新するために必要なものに焦点を当てることが重要です。

ハングの一般的な原因がわかったので、開発と生産の両方で、アプリのハングを監視し、トリアージするために使用できるいくつかの便利なツールについて話しましょう。

ハングをトリアージするには、その間にアプリが何をしているのかを知りたいでしょう。

タイムプロファイラインストゥルメントでは、時間の経過とともにアプリケーションのコールスタックを表示し、実行されているものを正確に示すことで、それを行うことができます。

システムトレース機器は、システムコール、VM障害、I/O、およびプロセス間およびプロセス内の相互作用に関するデータでより多くのコンテキストを追加します。

詳細については、2016年の「System Trace in Depth」トークをご覧ください。

さて、タイムプロファイラとシステムトレース機器を使用して、デザートがハングアップする原因を見つけます。

ハングの痕跡をたどった後、インストゥルメントで開かれているように見えます。

システムトレース出力では、赤い線はシステムコールを示し、紫色のグラフは仮想メモリ障害を示し、水平の青いバーはメインスレッドが作業に忙しいことを示します。

次のステップは、この作品が何であるかを見ることです。

タイムプロファイラでは、まさにそれを行うことができます。

4.7秒のハングの間、メインスレッドのコールスタックを集約することで、コールツリーを表示します。

ツリーのハイライトされた部分は、このハングの4.6秒がレシピビューのloadAllMessagesメソッドによるものであることを示しています。

このパターンは見覚えがある。

Dessertedは、必要以上に多くの画像に読み込まれている可能性があります。

アプリケーションが出荷されたら、MetricKitを使用して、フィールドでヒットしたハングのコールツリーを収集できます。

これにより、顧客が最も一般的に発生している問題に基づいて修正に優先順位を付けることができます。

ハングにMetricKitを使用する方法を学ぶには、2020年の「MetricKitの新機能」トークをチェックしてください。

私はデザートを出荷し、MetricKitからいくつかのハングレポートを持っています。

そのうちの1つを見て、トリアージしたばかりのハングに似ているかどうかを見てみましょう。

MetricKitは、ハング中に取得したコールスタックを集約することで、コールツリーを返します。

このツリー形式は、タイムプロファイラが提示するものに似ています。

強調表示された部分は、このハングがインスツルメンツで調査したばかりのハングとは異なることを示しています。

これは、連絡先を照会するディスパッチキューをブロックする、私が追加した新しいソーシャル機能によるものです。

MetricKitがなければ、この問題は見つからなかったかもしれないし、現場に残るだろう。

ハングを修正するときは、アプリのパフォーマンスをベースライン化し、定量化することが重要です。

Xcodeオーガナイザーは、アプリバージョンごとのハングレートを表示するチャートを含むパフォーマンス指標を表示することでこれを行います。

これは、回帰をトリアージするときに特に役立ちます。

Xcodeオーガナイザーの詳細については、これら2つの講演をご覧ください。

では、アプリのハングを修正するために使用できる一般的な戦略をいくつか確認しましょう。

これらの戦略のそれぞれは、ハングの複数の原因に対処できます。

どの修正がアプリに最適かを知るには、その副作用とトレードオフを調べる必要があります。

ハングを排除して防御するために、メインスレッドでの作業量を減らします。

これは2つの方法で行うことができます。

1つ目は、メインスレッドですでに行われている作業を最適化して、実行時間を短縮することです。

2つ目は、応答性を維持するために、ノンブロッキング方法でメインスレッドから作業を移動することです。

キャッシングから始めて、メインスレッドの実行を減らす方法から始めましょう。

キャッシュは、頻繁に使用されるアセットや以前に照会された値にすばやくアクセスするのに最適な方法です。

それらはしばしばインメモリストアですが、必要に応じて複数のアプリの呼び出しでディスクに永続化できます。

Dessertedの成分画像タイルのように、後で必要になる可能性のあるフォーマットされたアセットは、必要なときに毎回これらのアセットを作成するのに費用がかかるため、キャッシングに最適な候補です。

これらをNSCacheにキャッシュすることで、資産の生成のオーバーヘッドはクイックメモリ読み取りに置き換えられます。

これにより、Instrumentsで見たハングがなくなります。

古いデータを持つことと常にキャッシュを更新することのバランスを取るために、正確なキャッシュ無効化メカニズムを持つことが重要です。

この作業は、メインスレッドがイベントに応答し続けるために、セカンダリディスパッチキューで非同期に行われるはずです。

通知オブザーバーは、メインスレッドでの作業を減らす別の方法です。

高価なオンデマンド計算を行うことなく、アプリが値や状態の変化に反応できるようにします。

どのクラスでも、自分のクラスでも通知を投稿できます。

特定のクラスからの通知を見つけるには、そのAPIドキュメントを確認してください。

観察可能なすべてのシステム通知を見つけるには、NSNotification.NameのApple開発者ドキュメントページをチェックしてください。

これの素晴らしい候補は、デザートの社会的特徴です。

abDatabaseChangedExternally通知にオブザーバーを登録することで、メインスレッドは連絡先のクエリを待つ必要がなくなりました。

通知が届くと、オブザーバーが呼び出されます。

この場合、キャッシュされた値を更新します。

メインスレッドの応答性を維持するために、これらの更新は非同期である必要があります。これは、ハンドラを別のキューにdispatch_asyncすることで達成されます。

今、私は以前と同じ機能を提供しますが、MetricKitログで見たハングはありません。

ハングをなくすもう1つの方法は、メインスレッドから作業を移動することです。

まず、この仕事がどうあるべきかを決定する必要があります。

一般に、UIに重要な情報を提供する重要なタスクは、メインスレッドに残る必要があります。

さらに、すべてのビューとビューコントローラーは、メインスレッドで作成、変更、破棄する必要があります。

ただし、UI要素を更新するために必要な計算は、メインスレッドで実際の更新を実行するための完了ハンドラを使用して、別のスレッドにオフロードすることができます。

このパターンは、計算に時間がかかることがわかっている場合に便利です。

その他の重要度の低いタスク、メンテナンス、またはタイムクリティカルでないタスクは、別のスレッドで非同期に実行する必要があります。

これらは、より低いスケジューリング優先度で実行され、メインスレッド上の作業よりも完了に時間がかかる場合があります。

これは意図的であり、メインスレッドは重要な作業のみを実行すべきであるという考えを反映しています。

メインスレッドから非同期操作を実行する最も簡単な方法は、同期APIの非同期対応を使用することです。

ネットワーキングを例に挙げてみましょう。

同期ネットワークAPIに非同期NSURL対応を使用することで、アプリは応答性が向上します。

非同期APIは、多くの場合、「非同期」という単語またはメソッド名の完了ハンドラの存在によって示されます。

Grand Central Dispatchは強力なマルチスレッドメカニズムであり、非同期APIバリアントがない場合、またはメインスレッドから移動したいコードが独自のものである場合に活用できます。

Grand Central Dispatchは、作業ブロックを同期または非同期に別のスレッドに移動する簡単なメカニズムを提供します。

これにより、GCDはハングの最も一般的な原因を排除するのに非常に効果的です。

別のスレッドで作業ブロックを非同期に実行するには、そのブロックを別のディスパッチキューに非同期にディスパッチします。

完了ハンドラは、メインキューにディスパッチバックすることで、非同期ブロック内に追加できます。

グランドセントラルディスパッチでは、計算を事前に温めることもできます。

タスクをキュー、おそらくprefetchQueueに非同期させることで、メインスレッドが他の作業を行うために自由である間にタスクが実行を開始します。

これらの結果がメインスレッドで必要な場合、prefetchQueueに同期をディスパッチして、タスクが完了するのを待つことができます。

GCDができることの表面に触れたところです。

詳細については、2017年の「Modernizing Grand Central Dispatch」トークをご覧ください。

先ほど話したソリューションとのトレードオフを理解しましょう。

キャッシュはメモリを使用するため、大きなメモリの増加を避けるために、そのサイズを認識する必要があります。

また、値が古くならないように、正確な無効化メカニズムがあることを確認することも重要です。

通知はおしゃべりにすることができます。

1つを観察するときは、その通知が発火する頻度を考慮することが重要です。

複数の通知を処理または合体する前にフィルターを追加すると、CPUの解約が減少します。

非同期APIを使用する場合は、オペレーティングシステムが非同期作業を優先しないため、特にUI更新に不可欠かどうかを最初に確認することで、問題の操作を非同期にする必要があるかどうかを知ることが重要です。

Grand Central Dispatchを使用してタスクを非同期に実行する場合、コード内のタスクが実行される順序を変更します。

アプリが壊れないようにするために、他の人にどのタスクを注文する必要があるかを覚えておくことが重要です。

シリアルキューでdispatch_syncを使用することは、必要に応じて操作を同期するのに最適な方法です。

ハングがユーザーエクスペリエンスにもたらす深刻な影響と比較して、これらのトレードオフは常に価値があります。

ハングを解消する際に心に留めておくべきいくつかの考えは、AppleフレームワークとAPIを使用することです。

これらはすでに幅広いデバイスセットと互換性があり、高性能であり、より効率的で効果的なものになるように常に更新されています。

コードで反復的に改善を実行します。

このようにして、ターゲットを絞った修正を行い、個々の変更の影響を見ることができます。

システムリソースを使用するときは、良い隣人になりましょう。

必要以上のリソースを使用すると、独自のアプリのパフォーマンスが低下するだけでなく、システム内の他の減速を引き起こす可能性があります。

一緒に、私たちはどのように不快なハングができるか、そしてあなたのアプリでハングアップから守ることがいかに重要であるかを経験しました。

今後は、Xcodeオーガナイザーを介してアプリのパフォーマンスベースラインを設定します。

開発とコードレビュー中は、ハングを引き起こす可能性のあるアンチパターンに注意してください。

私たちは最も一般的なものの7つについて話し合いました。

タイムプロファイラとシステムトレース機器で出てくる問題を診断し、MetricKitを使用して、顧客が最も頻繁に発生している問題に優先順位を付けます。

キャッシュを使用したり、通知を観察したり、非同期の代替案を探したり、グランドセントラルディスパッチを利用したりして、見つけたハングを解消します。

これらの手順に従うことで、アプリは可能な限り最高のユーザーエクスペリエンスを提供するためにさらに優れたパフォーマンスを発揮します。

ぶらぶらしてくれてありがとう。

[音楽]。