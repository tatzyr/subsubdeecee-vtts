10252

♪ ♪

こんにちは、UIKitチームのエンジニア、アディティア・クリシュナデヴァンです。

多くのアプリの中核には、リストまたはコレクションビューがあります。

超スムーズなスクロールを持つことは、これらのアプリを素晴らしい気分にさせるための大きな部分です。

このビデオは、超高速のリストとコレクションビューを作成するときに成功のためにあなたを設定します。

コレクションビューを使用して、いくつかの素晴らしい旅行先の画像投稿のリストを表示するこのアプリをここで構築します。

一見するとかなりシンプルで、目的地の写真といくつかのテキストラベルがあります。

このビデオを通して、それがどのように設定され、人々が期待するパフォーマンスをどのように達成するかについて話します。

まず、差分可能なデータソースやセル登録などのAPIを使用する際の強力な基盤から始める方法を学びます。

コレクションビューセルのライフサイクルの理解をリフレッシュします。

次に、完全に滑らかなスクロールが見えない理由と、役立つプリフェッチの進歩について話します。

最後に、Patrickは、コンテンツが非同期に届いたときにセルを正しく更新する方法と、新しいUIImage APIを使用してすべてのデバイスで最高のスクロールパフォーマンスを得る方法を説明します。

わかりました。

アプリがデータをどのように構成するかについて話すことから始めましょう。

サンプルアプリは、表示する投稿のリストを取得し、各投稿はこのDestinationPost構造体で表されます。

DestinationPostは識別可能に準拠しています。つまり、識別子を格納するこのIDプロパティがあります。

これは、他のプロパティが変更されても安定したままである各DestinationPostの一意の識別子です。

拡散可能なデータソースは、モデルオブジェクト自体ではなく、モデル内のアイテムの識別子を格納するために構築されています。

したがって、サンプルアプリでは、差分可能なデータソースは、DestinationPost自体ではなく、ここのIDプロパティを使用して入力されます。

アプリで使用されている差分可能なデータソースは次のとおりです。

先ほど説明したように、アイテム識別子にDestinationPost.IDタイプを使用します。

ここのセクションタイプは、アプリには1つのセクションしかないため、1つのケースを持つ列挙型です。

データソースに入力するには、アプリは最初に空のスナップショットを作成し、メインセクションを追加します。

次に、バッキングストアからすべての投稿を取得し、その識別子を追加します。

このようにして、DestinationPostの他のプロパティの1つが変更された場合、識別子が変更されないため、差分可能なデータソースでの表現は安定しています。

最後のステップは、スナップショットをデータソースに適用することです。

iOS 15より前では、アニメーションなしでスナップショットを適用すると、内部的にreloadDataに変換されます。

コレクションビューは画面上のすべてのセルを破棄して再作成しなければならなかったため、パフォーマンスには最適ではありませんでした。

iOS 15以降、アニメーションなしでスナップショットを適用すると、違いのみが適用され、余分な作業は実行されません。

iOS 15では、拡散可能なデータソースは、目に見えるセルの内容を非常に簡単に更新できる新しいreconfigureItemsメソッドも得られます。

それがどのように機能するかについては、このビデオの後半で説明します。

まず、データソースからセルと画面にデータを取得しましょう。

セル登録は、各タイプのセルのすべての構成を1か所に保持するのに最適な方法であり、拡散可能なデータソースからの識別子への便利なアクセスを提供します。

UICollectionViewは、登録のインスタンスごとに再利用キューを維持しているため、セルの種類ごとに一度だけ登録を作成するようにしてください。

これは、アプリ内のセルの簡略化された登録です。

渡されたpostIDは、DestinationPostと画像を含むアセットオブジェクトを取得するために使用されます。

DestinationPostのプロパティは、セルのタイトルと画像を設定するために使用されます。

登録を使用するには、データソースのセルプロバイダー内でdequeueConfiguredReusableCellを呼び出します。

登録がセルプロバイダーの外でどのように作成され、内部で使用されるかに注意してください。

プロバイダー内で登録を作成すると、コレクションビューがセルを再利用しないことを意味するため、これはパフォーマンスにとって重要です。

セルの設定方法を理解したので、セルがいつ設定され、そのライフサイクルがどのようなものかに移ります。

細胞の寿命は、準備と表示の2つの段階で構成されています。

準備の最初のステップは、作業するセルを取得することです。

UICollectionViewがセルを必要とするときはいつでも、データソースからセルを要求します。

これが差分可能なデータソースである場合、セルプロバイダーを実行し、結果を返します。

セルプロバイダーが実行されると、コレクションビューは登録を使用して新しいセルをキューからデキューするように求められます。

再利用プールにセルが存在する場合、UICollectionViewはprepareForReuseを呼び出し、セルをキューから解除します。

再利用プールが空の場合、新しいセルが初期化されます。

その後、そのセルは登録から構成ハンドラに渡されます。

これは、アプリが特定のアイテム識別子とインデックスパスを表示するためのセルを設定する場所です。

設定したセルは、次のステップのためにコレクションビューに返されます。

コレクションビューは、セルに好みのレイアウト属性を照会し、セルのサイズを適切に設定します。

この時点で、セルは完全に準備され、フェーズ2:表示の準備ができています。

willDisplayCellはデリゲートで呼び出され、セルはUICollectionView内に表示されます。

セルが画面に表示されました。

目に見えるままである間、そのライフサイクルにこれ以上の変化はありません。

画面からスクロールすると、didEndDisplayingがセルに呼び出され、再利用プールに戻ります。

再利用プールから、セルを再びキューから解除し、このプロセスを繰り返すことができます。

それでは、これらの基本でアプリがどんな感じかを確認しましょう。

このアプリは、ペルーのクスコとカリブ海のセントルシアを特集しています。

アプリをスクロールして他の目的地を見てみましょうが、スムーズにスクロールしないことに注目してください。

スクロール中のこれらの中断は「ヒッチ」と呼ばれます。

ヒッチの原因を理解するために、まずアプリがディスプレイを更新する方法を学びましょう。

フレームごとに、タッチなどのイベントがアプリに配信されます。

それに応じて、ビューとレイヤーのプロパティを更新します。

たとえば、スクロールビューのcontentOffsetは、パンジェスチャー中に変更され、含まれているすべてのビューの画面上の場所が変更されます。

これらの変更の結果、アプリのビューとレイヤーはレイアウトを実行します。

このプロセスは「コミット」と呼ばれます。

次に、レイヤーツリーがレンダリングサーバーに送信されます。

各フレームにはコミット期限があります。

これは、そのフレームのすべてのコミットを終了する必要がある時間です。

アプリが各フレームに対してコミットしなければならない時間は、ディスプレイのリフレッシュレートによって異なります。

たとえば、より高いリフレッシュレート120Hzで実行されているiPad Proでは、60Hzで実行されているiPhoneと比較して、アプリは各フレームの作業を完了する時間が少なくなります。

コレクションまたはテーブルビューでセルのリストをスクロールする典型的な例を次に示します。

新しいセルが表示されると、より長いコミットがあり、その間に新しいセルが設定され、レイアウトが実行されます。

次に、画面上で移動されている既存のセルだけであるいくつかのフレームがあります。

新しいセルが不要なため、これらのフレームのコミットは高速です。

最終的には、スクロール位置が十分に変化し、新しいセルが見えるようになり、このパターンが繰り返されます。

では、以前のデモのようなヒッチの原因は何ですか?

フレームのコミットに時間がかかりすぎて締め切りに間に合わない場合、それらの更新は意図したフレームに組み込まれません。

ディスプレイは、コミットが終了するまで前のフレームを画面に保持し、この遅延フレームをレンダリングできます。

これはコミットヒッチであり、スクロール時に一時的な中断として認識されます。

これと他のタイプのヒッチの詳細については、「UIアニメーションヒッチを探索する」ビデオをご覧ください。

これらのヒッチを避けるために、UICollectionViewとUITableViewは両方ともiOS 15でまったく新しいセルプリフェッチメカニズムを持っています。

高価なセルがスクロール中にヒッチを引き起こす例に戻ってきました。

ここからの重要なポイントは、通常、すべてのフレームにセルを必要としないということです。

私たちは、最小限の作業を行う非常に短いコミットを持ついくつかのフレームを持っています。

iOS 15でのセルプリフェッチは、短いコミットを終えた直後に次のセルを準備することで、この空き時間を利用します。

そして、セルが最終的に必要になったとき、それはそれを見えるようにするだけの問題です。

そのため、すべての作業が以前に行われたため、プリフェッチされたセルが表示されるフレームのコミットは非常に迅速です。

セルのプリフェッチに費やした時間は、ヒッチを引き起こしたときと同じです。

しかし、私たちはヘッドスタートを得ることができるので、ヒッチを避けることができます。

各コミットをステップスルーすることで、これがなぜ機能するのかを理解しましょう。

プリフェッチが発生する前に、このフレームのコミットを実行しました。

セルは必要なかったので、それは迅速なコミットであり、締め切り前に多くの時間を残して終了しました。

iOS 15では、次のフレームまで待つのではなく、システムは状況を認識し、空き時間を使って次のセルのプリフェッチを開始します。

さて、次のフレームは物事が面白くなるところです。

プリフェッチされるセルは高価であるため、実際にはそのフレームのコミットが通常よりも遅く開始されます。

しかし、そのコミットは遅く始まりますが、迅速であるため、締め切りのかなり前に終了します。

これを、プリフェッチせずに先ほど見たイラストと比較してください。

締め切りを逃したコミットがなくなり、セルプリフェッチのヒッチがなくなったことに注目してください。

これは、アプリがヒッチハイドを引き起こすことなく、各セルを準備するのに最大2倍の時間を費やすことを意味します。

さらに、この素晴らしい新機能を手に入れるために必要なのは、iOS 15 SDKでアプリを構築することだけです。

私が最後にデモを実行したとき、アプリはiOS 14 SDKで構築されました。

iOS 15 SDKで構築されたら、アプリでのスクロールをチェックしてみましょう。

これはすごい！

プリフェッチはまさに私たちが望むことをしているように見えます。

スクロールは完全にスムーズになり、1行のコードも変更する必要はありませんでした。

覚えておいて、あなたがする必要があるのは、iOS 15 SDKを使用してアプリを構築することだけです。

UICollectionViewの場合、この新しいプリフェッチはiOS 10で導入されたものを拡張します。

セルプリフェッチは、リストと他のすべての構成レイアウトでサポートされるようになりました。

この素晴らしい新しいプリフェッチは、UITableViewでも有効になりました。

プリフェッチは、ヒッチを排除することでスクロール性能を向上させることができますが、電力使用量を削減し、バッテリー寿命を延ばすこともできます。

セルが迅速に準備できる場合、システムは余分な時間を使用して、よりエネルギー効率の高い状態で実行し、それでもヒッチを避けることができます。

したがって、ヒッチに気付かなくても、セルの設定とレイアウトの実装をできるだけ効率的にすることが非常に重要です。

それでは、プリフェッチが細胞のライフサイクルにどのように影響するかについて話しましょう。

これは、2つの異なるフェーズで、プリフェッチなしで、先ほど話したライフサイクルです。

セルがプリフェッチされると、画面上で必要とされるセルの前に実行される準備フェーズです。

プリフェッチを最大限に活用するには、この段階でセルを完全に設定する必要があります。

重い作業を行うためにセルが見えるまで待たないでください。

セルがコレクションビューに戻ると、プリフェッチの一部としても、優先するレイアウト属性を取得するようにサイズが設定されます。

プリフェッチされた後、セルが表示されるのを待っているこの中間状態があります。

この新しい段階を考えると、アプリには2つの重要な考慮事項があります。

準備されたセルが表示されない可能性があります。これは、ユーザーが突然スクロール方向を変更した場合に発生する可能性があります。

その後、セルが表示されると、画面から外れた後、すぐに待機状態に戻ることができます。

同じセルを同じインデックスパスに複数回表示できます。

セルの表示が終了すると、すぐに再利用プールに追加されることはもはやありません。

プリフェッチは、スムーズなスクロールを実現するのに役立ちますが、それは私たちにより多くの時間を与えるからです。

フレームレートの高い他のデバイスでは、スクロール中にアプリがヒッチする可能性があります。

パトリックは、アプリがセルを設定する方法の詳細を提供し、画像を表示する際のコミットあたりの時間を短縮する戦略についても説明します。

ありがとう、アディ。

こんにちは、ハイレベルパフォーマンスチームのパトリックです。

次に、サンプルアプリの既存のセルを更新し、iOS 15でいくつかの新しいAPIを利用して、可能な限り最高のパフォーマンスで画像を表示する方法をご案内します。

サンプルアプリは、ディスク上のローカルイメージファイルで構築されました。

アプリをスクロールすると、セルは画面から離れて準備され、その中の画像はすぐにファイルシステムから読み込まれます。

今、私たちはリモートサーバーに保存されている画像を表示したい。

したがって、セルがスクロールすると、画像ビューに表示する画像がない可能性があります。

画像ビューが最初に表示されるとき、それは空白になり、サーバー要求が完了した後にのみ入力されます。

この新しいアプローチをサポートするために、登録の構成ハンドラを拡張することを見てみましょう。

登録の構成ハンドラでは、すでにアセットストアからアセットを取得しています。

ストアは常に画像を返しますが、完全な資産ではないかもしれません。

ダウンロードする必要があるかもしれません。

アセットオブジェクトは、isPlaceholderプロパティでこれを示します。

これが当てはまる場合は、アセットストアに完全な画像をダウンロードするよう依頼します。

ロード操作が完了したら、セルの画像ビューを更新する時間です。

ここでは、既存のセルオブジェクトを取り、その画像ビューにアセットを設定します。

これは間違いです。

セルは異なる宛先に再利用され、アセットストアが最終的なアセットをロードする頃には、キャプチャしたセルオブジェクトを別のポストに設定できます。

セルを直接更新する代わりに、必要な更新をコレクションビューのデータソースに通知する必要があります。

iOS 15では、reconfigureItemsスナップショットメソッドが導入されています。

準備されたセルでreconfigureItemsを呼び出すと、登録の設定ハンドラが再実行されます。

新しいセルのキューイングを解除して設定するのではなく、アイテムの既存のセルを再利用するため、reloadItemsの代わりにこれを使用してください。

サンプルアプリでは、渡されたIDでreconfigureItemsを呼び出すsetPostNeedsUpdateメソッドを宣言します。

さて、登録の設定ハンドラに戻って、画像がプレースホルダである場合、フルサイズのアセットをダウンロードし、新しいメソッドを呼び出します。

reconfigureItemsはこのハンドラーを再び呼び出しますが、fetchByIDはプレースホルダではなく完全なアセットを返します。

これにより、すべてのビュー更新コードを1か所に保存し、データを取得したらセルを非同期に更新することができます。

準備時間を最大化するために、prefetchingDataSource内でdownloadAssetメソッドを使用することもできます。

データソースのプリフェッチは、コレクションビューアイテムのネットワークダウンロードを開始するのに最適な場所です。

セルが表示される前にアセットをダウンロードして準備する時間が増え、ユーザーがプレースホルダコンテンツを見る時間を短縮します。

これが私たちのアプリでどのように見えるかを見てみましょう。

大丈夫に見えますが、スクロール中に目に見えるヒッチがあります。

また、新しい画像が表示されるときと一致しているように見えます。

新しいセルが準備されると、ヒッチングはありません。

ヒッチハイクするのは、画像がフル解像度の画像で更新されたときだけです。

これは、すべての画像が表示のためにデコードするのに時間がかかり、より大きな非プレースホルダ資産のような一部の画像は、表示に間に合うようにデコードするには大きすぎるからです。

セル登録の構成ハンドラが最初に呼び出され、アセットがプレースホルダである場合、コードはフルサイズイメージの非同期要求を開始し、その構成を完了します。

アセットが後で最終的にダウンロードされると、セル構成ハンドラは最終的なイメージで再実行されます。

画像ビューが新しい画像をコミットしようとすると、まずメインスレッドに表示するために画像を準備する必要があります。

これには長い時間がかかることがあり、アプリがコミット期限に間に合わなかったときにヒッチがあります。

画像の準備は、すべての画像を表示するために受けなければならない必須のプロセスです。

レンダリングサーバーは、ビットマップである画像のみを表示できます。つまり、生のピクセルデータです。

画像はPNG、HEIC、JPEGなど、さまざまな形式で表示され、表示するには処理して解凍する必要があります。

画像ビューは、新しい画像をコミットするときにこの処理を行い、メインスレッドで発生します。

理想的には、画像を事前に準備し、最終的に完成したときにのみUIを更新することができます。

そうすれば、メインスレッドをブロックしたり、ヒッチしたりしません。

iOS 15では、画像準備APIを導入し、画像準備がいつどこで行われるかを制御できます。

これらのAPIは、レンダラーが必要とするピクセルデータのみを含む新しいUIImageを生成します。

画像ビューに設定すると、追加の作業は必要ありません。

任意のスレッドで実行できる同期形式と、内部UIKitシリアルキューで実行できる非同期形式の2つの形式があります。

それを使用するには、作成したUIImageを取り、画像ビューにプレースホルダ画像を設定します。

次に、新しいAPIを呼び出すと、大きな画像のバックグラウンドで準備が開始されます。

完了したら、画像ビューで設定するだけです。

準備された画像は、画像の多いアプリで大きな問題を解決しますが、いくつかの考慮事項も付属しています。

準備された画像には、元の画像の生のピクセルデータが含まれています。

メモリに保持されている限り、画像ビューで自由に表示できます。

しかし、これはまた、多くのメモリを占有し、控えめにキャッシュする必要があることを意味します。

最後に、そのフォーマットのため、ディスクストレージには理想的ではありません。

代わりに、元のアセットをディスクに保存します。

最後の考慮事項は、画像の準備がプリフェッチをどのように活用できるかです。

プリフェッチは、画像をダウンロードして準備するための余分な時間を与えます。

プロセスにより多くの時間を与えることは、ユーザーがプレースホルダを長く見ず、おそらくまったく見ないことを意味します。

サンプルアプリには、画像検索用の非同期パスがすでにあります。

ダウンロードが完了したら、完了ハンドラを呼び出す前にアセットを準備できます。

これらの資産は大きいだけでなく、貴重なので、画像が準備されたら、それをキャッシュしたいです。

画像キャッシュは、画像のサイズを使用して、準備された画像のメモリ使用量を推定します。

さて、セルがアセットを要求すると、サーバーから取得する前にそのキャッシュをチェックします。

もっと小さい画像があれば、もっとキャッシュできるだろう。

画像は大きくなる可能性があり、iOS 15では、画像のサムネイルを準備するための同様のAPIが導入されています。

これらは、より小さなサイズに画像を拡大縮小して準備することができます。

画像が宛先サイズを念頭に置いて読み取られ、処理されることを保証し、多くのCPU時間とメモリを節約します。

画像準備APIと同じように使用します。

まず、UIImageを取り、画像ビューにプレースホルダ画像を設定します。

次に、ビューのサイズをサムネイルのターゲットサイズとして、新しいサイズ変更APIを呼び出します。

準備ができたら、新しいサムネイルで画像ビューを更新するだけです。

画像準備APIに加えて、iOS 15のどのアプリでも画像を高速化し、ヒッチを回避する方がはるかに簡単です。

画像を扱うときは、画像の準備ができたらUIを更新できる非同期APIを持つことに集中してください。

それまでの間、同期的に表示できるほど小さいか安価なプレースホルダ画像を使用してください。

プリフェッチとreconfigureItemsで使用すると、コレクションとリストビューに非同期コンテンツを表示することは、かつてないほど簡単でパフォーマンスを発揮します。

高速コレクションとテーブルビューを開始するには、まずiOS 15 SDKを使用してアプリを構築し、多くの新しい最適化のロックを解除します。

特に、新しいプリフェッチでコレクションとテーブルビューの動作を検証してください。

ここで示されているすべての新しいAPIは、この講演のサンプルコードで見つけることができます。

それをチェックして、アプリ全体で画像の準備とサイズ変更のAPIを採用するようにしてください。

これにより、コレクションとテーブルビューが高速になります。

見てくれてありがとう。

[明るい音楽]。