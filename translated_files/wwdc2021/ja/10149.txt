10149

♪ベース音楽の演奏♪

♪

フアン・ロドリゲス・クエラー:こんにちは、WWDCへようこそ。

私の名前はJuan Rodriguez Cuellarで、AppleのGPUコンパイラエンジニアです。

このセッションでは、メタルレイトレーシングAPIを強化するために今年追加した新機能について説明します。

しかし、まず、レイトレーシングについて簡単にまとめましょう。

レイトレーシングアプリケーションは、光線がシーンと相互作用するときに取る経路をトレースすることに基づいています。

レイトレーシングは、オーディオ、物理シミュレーション、AIなどの多くの分野で適用されますが、主なアプリケーションの1つはフォトリアリスティックレンダリングです。

レンダリングアプリケーションでは、レイトレーシングを使用して個々の光線をモデル化し、反射、柔らかい影、間接照明などの効果をシミュレートすることができます。

それはレイトレーシングの一般的な定義にすぎません。

それに対するメタルのアプローチについて話しましょう。

コンピューティングカーネルから始めます。

私たちのカーネルでは、シーンに放出される光線を生成します。

次に、インターセクターと加速度構造を持つシーン内のジオメトリに対する交差について、これらの光線をテストします。

各交点は、表面から跳ね返る光を表します。どのくらいの光が跳ね返り、どの方向に、物体がどのように見えるかを決定します。

次に、各交差点の色を計算し、画像を更新します。

このプロセスはシェーディングと呼ばれ、追加の光線を生成することができ、それらの光線も交差のためにテストされます。

シーンの周りで跳ね返る光をシミュレートしたいのと同じくらい何度もこのプロセスを繰り返します。

今年は、新機能を3つの主要な分野に焦点を当てました。

まず、レンダリングパイプラインにレイトレーシングサポートを追加した方法について説明します。これにより、レイトレーシングとレンダリングを混在させることができます。

次に、使いやすさと移植性に焦点を当てた新機能を紹介します。

これらの機能により、メタルレイトレーシングAPIの使用が容易になります。

最後に、よりリアルなコンテンツを作成するのに役立つ、今年追加したプロダクションレンダリング機能について説明します。

レンダリングパイプラインからのレイトレーシングから始めましょう。

単一のレンダリングパスを持つレンダリングの基本的なケースを考えてみましょう。

レンダリングパイプラインからのレイトレーシングの新しいサポートにより、レンダリングにレイトレーシングを追加することが非常に簡単になります。

ただし、このサポートがなければ、昨年のメタルレイトレーシングAPIでこのレンダリングにレイトレーシングを追加するには、コンピューティングパスを追加する必要があります。

レンダリングされた画像を拡張するために、レンダリング後にそれを追加することから始めましょう。

この余分なコンピューティングパスを追加することは、レイトレーシングに使用するコンピューティングパスのためにメモリにより多くの出力を書き込むことを意味します。

さて、レンダリングパスの途中でレイトレーシングを使用して、ピクセルあたりのシャドーイングなどの値を計算したい場合はどうなりますか?

これは、レンダリングを分割し、コンピューティングパスを導入する必要があることを意味します。

これが何を意味するのかをもっと考えて、レイトレーシングへの入力としてピクセル位置と法線をメモリに書き出し、交差結果をおそらく数回読み返す必要があります。

しかし、レンダリングステージからのレイトレーシングの新しいサポートにより、レンダリングパスを離れる必要はなく、出力をメモリに書き込むだけです。

新しいAPIをどのように使用するか見てみましょう。

レイトレーシング用のレンダリングパイプラインの準備は、コンピューティングパイプラインに似ています。

加速度構造を構築し、カスタム交差関数を定義することから始めます。

カスタム交差をサポートするには、交差関数テーブルが必要で、それを交差関数で埋める必要があります。

この部分は、昨年のAPIと比較していくつかの違いがあります。

それを行う方法を見ていきましょう。

簡単な交差関数をいくつか考えてみましょう。

ここには、球、円錐、または円錐などのオブジェクトを分析的に交差することを可能にするいくつかの機能があります。

パイプラインを作成するときに、これらの関数を呼び出す可能性のあるリンク関数として追加します。

この場合、パイプラインのフラグメント段階に追加します。

関数を使用するには、パイプラインの状態とステージから交差関数テーブルを作成する必要があります。

テーブルを取得したら、パイプラインの状態とステージから関数ハンドルを作成し、テーブルに入力できます。

フラグメントステージの関数を指定すると、昨年導入したlinkedFunctionsオブジェクトが再利用されます。

各ステージには、レンダリングパイプライン記述子に独自のlinkedFunctionsのセットがあります。

交差関数テーブルの作成は、計算パイプラインで実行した場合とほぼ同じです。

唯一の変更は、ステージ引数の追加です。

テーブルに入力するには、関数ハンドルを作成します。

繰り返しますが、ハンドルはステージに固有であるため、ハンドルを要求するときにステージを指定する必要があります。

関数ハンドルを取得したら、関数テーブルに挿入するだけです。

そして、レンダリングパイプラインで関数テーブルを準備するために必要なのはそれだけです。

今、私たちは交差するためにこれまでに構築したすべてのものを使用する必要があります。

実際の使用は簡単です。

accelerationStructureと交差関数テーブルは、どちらもレンダリングエンコーダのバッファインデックスにバインドされています。

シェーダーは、これらのリソースを使用して、コンピューティングカーネルと同じように光線とインターセクターを交差させることができます。

レイトレーシング用のパイプラインの準備方法の詳細については、昨年のプレゼンテーションを参照してください。

その講演では、加速度構造の構築、ファンクションテーブルの作成、シェーディング言語でのインターセクターの使用について学びます。

レンダリングパイプラインからのレイトレーシングサポートにより、単一のレンダリングパス内にレイトレーシングを追加し、ハイブリッドレンダリングでレイトレーシングとラスタライズを混合し、Apple Siliconのタイル機能などの最適化を活用するなど、さらに多くの機会への扉を開いています。

実際、WWDC 2019での「Modern Rendering in Metal」セッションでデモしたサンプルアプリにレイトレーシングをまもなく追加する予定です。

レンダリングパイプラインからのレイトレーシングを使用すると、コードを更新してタイル関数を使用してタイルメモリにすべてを保持できます。

これの詳細については、今年の「メタルレイトレーシングでハイブリッドレンダリングを探索する」プレゼンテーションを参照してください。

次に、メタルレイトレーシングAPIの使いやすさと移植性を向上させるために、今年追加した新機能を紹介したいと思います。

これらの機能は、メタルレイトレーシングをより簡単に使用できるだけでなく、他のレイトレーシングAPIからの移植性も提供します。

これらの新機能の1つは、交差クエリです。

交差クエリを使用すると、交差プロセスをより詳細に制御できます。

交差クエリは、インターセクターがオーバーヘッドを作成できる単純なユースケースを対象としています。

これは、インラインカスタム交差テストを実行するオプションを提供する加速構造を横断する新しい方法です。

昨年のインターセクターを使用して、現在カスタム交差点をどのように処理しているかを見てみましょう。

昨年のメタルプレゼンテーションによるレイトレーシングのアルファテストの例に戻ると、チェーンと葉で見られるように、アルファテストを使用してシーンに多くの幾何学的ディテールを追加する方法を実証しました。

また、三角形の交差関数を使用してインターセクターをカスタマイズすることで、アルファテストを実装するのがいかに簡単かを学びました。

この三角形の交差関数内のロジックは、光線が加速度構造を横断する際に交差を承認または拒否する責任があります。

この場合、テストロジックは最初の交差を拒否しますが、不透明な表面が交差しているため、2番目の交差を受け入れます。

交差関数がどのように使用されるか見てみましょう。

Intersector を使用する場合、intersect() を呼び出すと、加速度構造を横断して交差点を見つけ、intersection_result を埋めます。

インターセクター内では、潜在的な交点が見つかるたびに交差関数が呼び出されます。

そして、交差は、交差関数ロジックに基づいて受け入れられるか拒否されます。

これは、パフォーマンスと利便性の両方があるため、インターセクターを使用した優れたプログラミングモデルですが、新しい交差関数を作成してパイプラインにリンクする必要があります。

アルファテストロジックの場合と同様に、交差関数内のロジックが数行のコードしかない場合があります。

これは、アルファテストを行うためのロジックを含む交差関数です。

交差クエリを使用すると、この交差関数を必要とせずに、このロジックをインラインに配置できます。

方法は次のとおりです。

交差クエリでは、交差プロセスを開始すると、レイは加速構造を横断し、クエリオブジェクトにはトラバーサルの状態と結果が含まれます。

レイがカスタムプリミティブまたは非不透明な三角形と交差するたびに、コントロールがシェーダーに返され、交差候補を評価します。

現在の候補者がカスタム交差ロジックに合格した場合は、現在のコミットされた交差を更新し、交差プロセスを続行することをコミットします。

一方、候補者がカスタム交差ロジックに失敗した場合は、無視して続行できます。

交差クエリを使用してアルファテストを行うためのコードをお見せしましょう。

まず、トラバーサルを開始します。

すべての候補の交差点を評価するために、次にループすることに注意してください。

次に、候補者のタイプを確認することから始めて、各候補者を評価します。

アルファテストの例では、三角形タイプの交点に興味があります。

タイプを確認した後、候補者に関するいくつかの交差情報を照会したいと思うでしょう。

現在インライン化されているアルファテストロジックで必要な情報について3つのクエリを実行します。

最後に、候補交差がアルファテストに合格した場合、現在のコミットされた交差になるようにコミットします。

これまでは、候補交差点を評価する加速構造全体を横断し、アルファテストロジックに合格した交差点をコミットしています。

次に、シェーディングを行うには、コミットされた交差点情報を照会する必要があります。

まず、コミットされたタイプを照会します。

候補交差点のいずれもコミットされた交差点になるための条件を満たしていない場合、コミットされたタイプはnoneになります。これは、現在のレイが見逃したことを意味します。

一方、コミットされた交差点がある場合は、交差点タイプに適用される交差点に関する情報を照会し、シェーディングに使用することをお勧めします。

交差クエリを使用してアルファテストを実行するために必要なコードはすべてです。

交差クエリの導入とパイプラインをレンダリングするためのインターセクターの導入により、メタルレイトレーシングをアプリに導入し始める機会が増えています。

インターセクターオブジェクトと交差クエリのどちらかを選択する際に考慮すべきことがいくつかあります。

まず、コンピューティングでインターセクターを使用するなど、既存のコードがあるかどうか、そのコードを移植する計画を検討してください。

他のAPIからの既存のクエリコードがある場合、交差クエリはそのコードを移植するのに役立ちます。

次に、カスタム交差点の処理の複雑さがあります。

インターセクターには交差関数とテーブルが必要であり、交差クエリを使用してカスタム交差を自分で処理する方が簡単かもしれません。

最後の質問はパフォーマンスです。

より単純なケースでは、交差クエリはレイトレーシング用のパイプラインを構築する際のオーバーヘッドを回避できますが、カスタム交差処理では、トラバーサル中にコードに戻る必要があり、ユースケースに応じてパフォーマンスに影響を与える可能性があります。

また、複数のクエリオブジェクトを使用すると、より多くのメモリが必要になります。

一方、インターセクターは、すべての交差作業をカプセル化することで、より複雑なケースをサポートできます。

機会があれば、両方のソリューションのパフォーマンスを比較することをお勧めします。

それはすべて交差クエリについてです。

では、他の新機能に移りましょう。

次に説明する2つの機能は、ユーザーインスタンスIDとインスタンス変換です。

これらの機能は、アクセラレーション構造により多くの情報を追加し、すでにそこにあるより多くのデータにアクセスするのに役立ちます。

これが、これらが本当に便利な機能だと思う理由です。

昨年のプレゼンテーションのサンプルコードを振り返ってみると、カーネルボックスの複数のインスタンスがあります。

この下には、インスタンスに到達するまで分岐するノードのセットを持つインスタンスアクセラレーション構造があります。

これらのインスタンスのうち2つを見ると、それらはインスタンスアクセラレーション構造の最低レベルにあります。

現在、これらのインスタンスの1つを交差させると、交差結果からシステムのインスタンスIDのみを取得します。

これにより、独自のデータテーブルを維持できますが、加速構造に公開できるデータがあります。

まず、ユーザー定義のインスタンスIDについて話しましょう。

この機能を使用すると、インスタンスごとにカスタム32ビット値を指定し、交差結果の一部としてこの値を取得できます。

これは、独自のデータ構造にインデックスを作成するのに本当に便利ですが、カスタムデータをエンコードするためにも使用できます。

たとえば、ここではユーザーIDを使用して、各インスタンスのカスタムカラーをエンコードしています。

追加の資料情報を調べる必要がなく、より簡単な反射にこれを使用できます。

これはほんの一例ですが、機会は無限です。

インスタンスごとのマテリアルIDやインスタンスごとのフラグなど、どのようにエンコードしたいかがわかります。

これらのIDを指定するために使用されるインスタンス記述子タイプの拡張バージョンを作成しました。

インスタンスアクセラレーション構造記述子で使用している記述子のタイプを必ず指定してください。

シェーディング言語では、現在のユーザーインスタンスIDの値は、インスタンスタグとの交差関数への入力として使用できます。

交差後の値を取得するには、インターセクターオブジェクトを使用する場合、ユーザー定義のインスタンスIDが交差結果から利用できます。

また、交差クエリオブジェクトを使用する場合、候補とコミットされた交差の両方のユーザー定義のインスタンスIDにアクセスするための対応するクエリがあります。

ユーザーインスタンスIDと同様に、インスタンス変換マトリックスにアクセスするためのサポートを追加しました。

このデータはすでにインスタンス記述子で指定されており、アクセラレーション構造に格納されています。

今年は、シェーディング言語からこれらの行列を公開しました。

Instancingタグとworld_space_dataタグを適用すると、交差関数のインスタンス変換にアクセスできます。

同様に、インスタンス変換は、instancingタグとworld_space_dataタグを持つインターセクタを使用する場合、交差結果で提供されます。

インスタンシングタグで交差クエリを使用する場合、候補とコミットされた交差の両方のインスタンス変換にアクセスするための対応するクエリがあります。

要約すると、今年は3つの新機能を導入することで、メタルレイトレーシングAPIの使いやすさと移植性を向上させています。

交差クエリは、交差プロセスをより詳細に制御できるインターセクターの代替手段として提供されます。

また、ユーザーインスタンスIDとインスタンス変換機能の導入により、コード内の外部マッピングを処理するのではなく、アクセラレーション構造からデータにアクセスする機能を提供します。

さらに、これら3つの機能は、他のレイトレーシングAPIからの移植性を提供し、クロスプラットフォームの開発を容易にします。

これまでのセッションでは、レンダリングパイプラインでのレイトレーシングの新しいサポートと、今年追加したさまざまなユーザビリティとポータビリティ機能について話しました。

さて、プロダクションレンダリングを強化するために導入している機能をお見せしましょう。

メタルレイトレーシングAPIが昨年導入されて以来、人々はいくつかの素晴らしい高品質のコンテンツをレンダリングするためにそれを使用しています。

今年は、より良いコンテンツをレンダリングできるように、2つの新機能を追加しました。

拡張された制限から始めましょう。

メタルレイトレーシングAPIをリリースして以来、一部のユーザーは、特に生産規模のユースケースで、加速構造の内部限界に達し始めています。

そのため、さらに大きなシーンをサポートするために、拡張リミットモードのサポートを追加しています。

昨年、典型的なシーンサイズでパフォーマンスを優先するために、加速構造サイズのバランスをとるためにこれらの制限を選択しました。

この機能をオンにするには潜在的なパフォーマンスのトレードオフがあるため、どのモードがアプリケーションに最適かを判断する必要があります。

拡張リミットモードでは、プリミティブ、ジオメトリ、インスタンスの数、およびインスタンスのフィルタリングに使用されるマスクのサイズの制限が増加します。

オンにするには、加速度構造を構築するときに、まず拡張制限モードを指定します。

次に、シェーディング言語でインターセクターオブジェクトのextended_limitsタグを指定します。

拡張制限をオンにするために必要なのはそれだけです!

次に、動きについて話しましょう。

コンピュータグラフィックスでは、カメラの露出が瞬間的であると仮定することがよくあります。

しかし、実生活では、カメラの露出はゼロ以外の期間続きます。

その間に物体がカメラに対して相対的に動くと、画像がぼやけて見えます。

この極端な例では、中央の人は、他の誰もが動いている間、露出の間ずっとじっと立っていて、ぼやけています。

この効果は、コンピュータで生成された画像をより現実的に見せるのに大いに役立ちます。

この例では、球はいくつかのフレームにわたってアニメーション化されますが、各フレームは依然として瞬間的な露出であり、不安定なアニメーションになります。

モーションAPIを使用すると、ゼロ以外の時間持続するカメラの露出をシミュレートできます。

これにより、より滑らかでリアルなアニメーションになります。

ビデオを凍結すると、実際のカメラのように球の境界が動きの方向にぼやけていることがわかります。

ゲームのようなリアルタイムアプリケーションは、多くの場合、画面空間でこの効果を近似します。

しかし、レイトレーシングは、物理的に正確なモーションブラーをシミュレートすることを可能にし、影や反射などの間接的な効果にも拡張します。

モーションブラーバージョンがどのようにレンダリングされたかを見てみましょう。

モーションブラーは、レイトレーシングの簡単な拡張です。

ほとんどのレイトレーシングアプリケーションは、間接照明の入射光方向などの物理的な寸法をすでにランダムにサンプリングしています。

モーションブラーを追加するには、各光線にランダムな時間を選択することもできます。

金属は、各光線に関連付けられた時点と一致するようにシーンと交差します。

例えば、この光線はこのようなシーンを見るでしょう。

別の光線はこのようなシーンを見るでしょう。

ますます多くのサンプルを蓄積するにつれて、モーションブラード画像に収束し始めます。

実際には、カスタム交差関数を使用して、今日すでにこれを実装することができます。

露出全体にわたって各プリミティブのバウンディングボックスを計算し、これらのバウンディングボックスを使用して加速構造を構築できます。

しかし、これは非効率的です。バウンディングボックスは非常に大きく、一部の光線はプリミティブとの交差をチェックする必要があるため、実際には交差することはありません。

代わりに、このようなケースを効率的に処理するように設計されたモーションブラーに対するMetalの組み込みサポートを使用できます。

最初にする必要があるのは、メタルシェーディング言語コードの各光線にランダムな時間を関連付けることです。

まず、暴露間隔内でランダムな時間を生成し、それをインターセクターに渡します。

次に行う必要があるのは、アニメーションジオメトリをMetalに提供することです。

これは、キーフレームアニメーションと呼ばれる一般的なアニメーション方法を使用して行います。

アニメーションは、キーフレームと呼ばれる重要な時点でボールをモデル化することによって作成されます。

これらのキーフレームは、アニメーションの開始と終了の間に均一に分散されています。

光線が加速度構造を横断すると、時間値に基づいて任意のキーフレームからデータを取得できます。

たとえば、レイAは、その時間がたまたまキーフレーム11と一致するため、キーフレーム11でモデル化されたシーンを見るでしょう。

対照的に、レイBの時間はキーフレーム3と4の間です。

したがって、2つのキーフレームのジオメトリはレイBに補間されます。

モーションはインスタンスレベルとプリミティブレベルの両方でサポートされています。

インスタンスアニメーションは、オブジェクト全体を厳密に変換するために使用できます。

これはプリミティブアニメーションよりも安いですが、オブジェクトを変形させません。

一方、原始的なアニメーションはより高価ですが、スキンキャラクターアニメーションのようなものに使用できます。

インスタンスアニメーションとプリミティブアニメーションの両方がキーフレームアニメーションに基づいていることに注意してください。

まず、インスタンスモーションについて話しましょう。

インスタンスの加速構造では、各インスタンスは変換行列に関連付けられています。

このマトリックスは、ジオメトリをシーンのどこに配置するかを説明しています。

この例では、2つの原始的な加速度構造があります。1つは球体用、もう1つは静的幾何学用です。

各プリミティブアクセラレーション構造には単一のインスタンスがあります。

球体をアニメーション化するために、アニメーションの開始点と終了点を表す2つの変換行列を提供します。

次に、金属は各光線の時間パラメータに基づいてこれら2つの行列を補間します。

これは2つのキーフレームを使用する特定の例ですが、Metalは任意の数のキーフレームをサポートしていることに注意してください。

加速度構造記述子を使用してこれらの行列を提供します。

標準のMetalインスタンス記述子には、単一の変換行列の余地しかありません。

代わりに、新しいモーションインスタンス記述子を使用します。

この記述子を使用すると、変換行列は別のバッファに格納されます。

インスタンス記述子には、変換バッファ内の変換行列の範囲を表す開始インデックスとカウントが含まれます。

各行列は単一のキーフレームを表します。

新しいモーションインスタンス記述子タイプでインスタンス記述子を設定する方法を見てみましょう。

通常のインスタンスアクセラレーション構造記述子を作成することから始めます。

次に、新しいモーションインスタンス記述子タイプを使用することを指定します。

次に、モーションインスタンス記述子を含むinstanceDescriptorBufferを指定します。

最後に、各キーフレームの頂点バッファを含むtransformsBufferをバインドする必要があります。

残りのプロパティは、他のインスタンスアクセラレーション構造と同じであり、他のアクセラレーション構造と同様に構築できます。

Instance_motionタグを指定するという、シェーディング言語の変更を1つだけ行う必要があります。

これは、インターセクターにインスタンス運動を伴う加速構造を期待するように指示します。

そして、インスタンスモーションを設定するために必要なのはそれだけです。

次に、原始的な動きについて話しましょう。

プリミティブモーションでは、各プリミティブは別々に移動できます。つまり、スキンキャラクターアニメーションのようなものに使用できます。

キーフレームごとに個別の3Dモデルを提供する必要があり、Metalはそれらの間で補間することを忘れないでください。

各キーフレームの頂点データを提供する必要があります。

これを設定する方法を見てみましょう。 

まず、各キーフレームの頂点バッファを配列に収集することから始めます。

MTLMotionKeyframeDataオブジェクトを使用すると、バッファとオフセットを指定できます。

それを使用して、各キーフレームの頂点バッファを指定します。

次に、モーショントライアングルジオメトリ記述子を作成します。

これは、わずかに異なるタイプを使用することを除いて、他のジオメトリ記述子を作成するのと同じです。

そして、単一の頂点バッファを提供する代わりに、頂点バッファの配列を提供します。

最後に、通常のプリミティブ加速度構造記述子を作成します。

次に、geometryDescriptorを提供します。

次に、キーフレームの数を指定します。

インスタンスモーションと同様に、primitive_motionタグを指定するには、シェーディング言語を少し変更する必要があります。

そして、それは私たちが原始的な動きを設定するために必要なすべてです!

さらにダイナミックなシーンでは、実際に両方のタイプのアニメーションを同時に使用できることを覚えておいてください。

次に、このすべてのアクションを見てみましょう! !

これは、高度なコンテンツチームによって作成されたパストレースレンダリングです。

このビデオは、AMD Radeon Pro Vega II GPUを搭載したMac Proでレンダリングされました。

忍者のキャラクターは、各プリミティブが別々に動くことを可能にするスキン骨格アニメーション技術を使用してアニメーション化されました。

各フレームは、プリミティブモーションAPIを使用して取得した256のランダムなタイミングのサンプルを組み合わせてレンダリングされました。

違いをより明確に見るために、それを遅くすることができます。

左側のバージョンにはモーションブラーはありませんが、右側のバージョンにはモーションブラーがありません。

また、長時間露光をシミュレートするために、露光時間をさらに増やすことができます。

モーションブラーはリアリズムに大きな違いを生むことができ、新しいモーションAPIで簡単に追加できるようになりました。

だから、それは動きのためです。

この講演を見てくれてありがとう。

私たちは、アプリを強化するために必要なツールを提供するために、メタルレイトレーシングAPIに多くの労力を費やしてきました。

私たちはあなたがそれで作成する素晴らしいコンテンツを見るのが待ちきれません。

ありがとう、そして素晴らしいWWDCを!

♪