10148

WWDCへようこそ。

こんにちは、私はジョナサン・メッツガーです。

私はアップルのメタルエコシステムチームのメンバーです。

私たちはゲーム開発者と協力して、Apple GPUで最高のグラフィックスパフォーマンスを得られるよう支援します。

ダスティンと私は、Apple GPUのハイエンドゲームを最適化する方法を紹介します。

このビデオでは、ゲームを最適化するために使用するプロセスについて説明します。

次に、ゲームBaldur's Gate 3とMetro Exodusで使用されている最適化の種類を紹介します。

そして最後に、ダスティンはゲームDivinity: Original Sin 2をフィーチャーしたツールのデモンストレーションを行い、Xcode 13で新しいGPUタイムラインを紹介します。

飛び込んで最適化について話しましょう。

そのため、過去1年間、私たちはLarian Studiosと4A Gamesと協力して、Apple GPU用のゲームのグラフィックパフォーマンスを調整する方法を見つけました。

私はあなたが詳細を見ることに興奮すると確信しています、そして私は少し時間を取って、このプレゼンテーションで開発資料を表示する許可を与えてくれたLarian Studiosと4A Gamesの両方に感謝したいと思います。

今年を振り返ってみると、私たちは多くのゲームを分析し、グラフィックパフォーマンスに影響を与えるいくつかの一般的なシナリオを特定しました。

あなたはおそらくあなた自身のゲームを最適化する機会を見つけることに興味があるので、私たちはGPUツールがこれらの問題領域を特定するのに特に有用であることを強調し、それらを解決する方法を提案するためにこのセッションを調整しました。

そして、特に、私たちのチームが開発者がゲームを最適化するのを助けるために使用する原則のいくつかを共有したいと思います。

グラフィックアプリケーションを最適化するときは、方法論、特定の問題を解決する方法を定義する一連の原則を持つことが重要です。

では、4段階のプロセスをお見せしましょう。

まず、収集または測定するデータを選択する必要があるため、ゲームで何が起こっているのかを理解するのに役立ちます。

データの測定を開始するとすぐに、いくつかのパフォーマンス目標、または終了時にどこにいたいかを選択したいと思うでしょう。

GPUフレームキャプチャとメタルシステムトレース、シーンの複雑さ、グラフィックス設定、およびフレームタイムなど、あなたにとって重要なその他の指標を取るために、ゲーム内の場所を決めることができます。

次に、データを分析して、エンジンの動作について学びます。

詳細な分析は、ボトルネックが発生している場所と理由を見つけるのに役立ちます。

ボトルネックの原因がわかったら、ゲームを改善できますが、通常は一度に1つまたは2つを選択するので、各変更の影響を理解できます。

最後に、いくつかの新しい測定値を元の測定値と比較することで、改善を確認します。

最適化はプロセスであるため、パフォーマンス目標が達成されるまで戻って繰り返します。

これらのゲームでは、XcodeのMetal Debuggerを使用して、パフォーマンスとフレームグラフの構造に関する洞察を提供し、InstrumentsのMetal System Traceを使用して、時間の経過とともにゲームのパフォーマンスについて学びます。

GPUトレースファイルとInstrumentsトレースファイルを保存して、最適化の前と後の両方のデータを持つことができるのは素晴らしいアイデアです。

だから、私はあなたがあなたのゲームで考慮したり、探したりできるものの小さなリストを持っています。

前述したように、XcodeとInstrumentsは、Metalアプリケーションを理解するのに役立つ素晴らしいツールです。

最適化とは、シェーダーのパフォーマンスからメモリ帯域幅まで、いくつかの分野を最大限に活用することです。

もう1つの領域は、頂点、フラグメント、およびコンピューティングワークロード全体でうまく重複しています。

そして、飛行中にいくつかのフレームをレンダリングしている間、一部のApple GPUはそれらの間でワークロードを重ねる可能性があります。

重複を防ぐ可能性のあるリソースの依存関係に役立ついくつかのポインタを紹介します。

また、一部の開発者はシェーダーにカスタムワークフローを使用しているため、コンパイラの設定がパフォーマンスにどのように影響するかを紹介します。

最後に、冗長バインディングの影響を軽減する方法について話します。

Larian StudiosのBaldur's Gate 3から始めましょう。

Baldur's Gate 3は、20年間のゲームの遺産に基づいて構築されたRPGであり、その映画のような視覚効果で際立っています。

Larian Studiosとの関わりは、Apple GPU用の素晴らしいレンダリングエンジンを最適化する方法を特定するのに役立ちました。

まず、ここで見られるRavaged Beachのシーンのように、GPUフレームキャプチャから始めました。

次に、シーンをフレームグラフに分解します。

フレームグラフは、各レンダリングパスの順序と目的の内訳です。

ハイエンドゲームには、アンビエントオクルージョン、シャドウマッピング、ポストプロセッシングなど、特定の視覚効果を達成することに特化した多くのレンダリングパスがあります。

Baldur's Gate 3には複雑なフレームグラフがあるので、これは簡略化されたバージョンです。

Xcodeのメタルデバッガを使用して、GPUトレースをキャプチャし、それを使用してゲーム内のすべてのレンダリングパスを確認します。

「依存関係を表示」をクリックすると、パンしてズームできるビジュアライゼーションが表示されます。

これは、レンダリングパスが以前の結果にどのように依存しているかを示し、何が起こっているのかを理解するのに役立ちます。

たとえば、詳細を取得するために、この延期されたデカールレンダリングステージを拡大しています。

次に、楽器ツールをお見せします。

インスツルメントトレース、メタルシステムトレース、またはゲームパフォーマンステンプレートを使用してゲームの分析に時間を費やします。

メタルシステムトレースは、GPUの実行とスケジューリング分析に焦点を当てたい場合に理想的であり、ゲームパフォーマンスはそれを拡張し、スレッドストールや熱通知などの他の問題を支援します。

メタルシステムトレースを選択して、フレームからフレームへのエンジンの動作を見てみましょう。

機器を使用すると、タイムラインに沿って複数のチャネルのデータを表示できます。

ここでは、最初の問題を見つけます。レンダリングパスの高価なワークロードです。

高価な作業負荷は、シェーダーを最適化する必要があることを意味するかもしれません。

たとえば、長い計算シェーダーがフレームの残りの部分を保持しているのが見えます。

私たちはこれらのギャップを「バブル」と呼んでいます。

GPUトレースに戻り、これをさらに調査しましょう。

これは「前」のGPUトレースです。

グループ化をAPI CALLからPIPELINE STATEに変更しましょう。

パイプラインの状態が実行時間によってソートされていることに気付くかもしれません。

最初のコンピューティングパイプラインを確認しましょう。

計算関数の詳細を展開して、その統計を詳しく調べることができます。

ここでは、4.5千以上の指示があることに注意してください。 

それはかなり多いです。それで、他には？

この計算関数でどのようなリソースが使用されているか見てみましょう。

入力データに応じて、この関数は最大120のテクスチャを使用して出力を生成します。

しかし、実際には90%しか使用されていないことがわかりました。

では、このシェーダーをどのように改善できるかについて話しましょう。

多くの異なる条件を処理する必要があるシェーダーは、必要以上に多くのレジスタを予約することができ、これにより並列に実行されるスレッドの数を減らすことができます。

ワークロードをより小さく、より焦点を絞ったシェーダーに分割し、レジスタが少なくなると、シェーダーコアの使用率を向上させることができます。

したがって、シェーダーで適切なアルゴリズムを選択する代わりに、GPUワークロードを発行するときに適切なシェーダー順列を選択します。

さらに、あまりにも多くのレジスタを使用するシェーダー機能は、実行ユニットが高速レジスタメモリを使い果たし、代わりにデバイスメモリを使用しなければならない場合、レジスタ圧力を引き起こす可能性があります。

これは、フロートのような32ビット型よりも半分のレジスタスペースを使用するため、必要に応じて半分のような16ビット型を使用する理由の1つです。

この場合、Larian Studiosはすでに半精度の浮動小数点を使用するようにシェーダーを最適化し、代わりに専用のシェーダーバリアントを作成することにしました。

では、何が起こったのか見てみましょう。

前の数字を比較すると、左側のボックスの数字と右側のボックスの数字を比較すると、指示の数は84%減少し、ブランチは90%減少し、レジスタは25%減少し、テクスチャ読み取りは92%減少しました。

このシェーダーバリアントは90%の時間で使用されます。

メタルシステムトレースでも見ることができます。

ここで、前のトレースで、私たちが以前に見た泡に注目してください。

そしてここで、後追跡では、それらは最小限に抑えられています。

ラリアンスタジオは、このシェーダーを平均8ミリ秒減らすことができました。

それは大きな勝利です!

最も高価なパイプライン状態オブジェクトとシェーダーを見ると、簡略化できる複雑なシェーダーが見つかるかもしれません。

これは、そのシェーダーの結果が後のパスで使用される場合に特に当てはまります。

これはゲームにとって大きな改善でしたが、開発者のパフォーマンス目標には及ばなかった。

メモリを問題として言及しましたが、GPUの機能の1つは、特定の条件で有効になっているロスレス圧縮です。

だから、誤って設定したか、設定するのを忘れたフラグがあったのかもしれません。

ロスレス圧縮は、タイルからデバイスメモリに保存されたテクスチャを圧縮することで、帯域幅を削減するのに役立ちます。

概要ページの帯域幅インサイトを見ると、一部のテクスチャのロスレス圧縮警告に気付くかもしれません。

彼らは、これらのテクスチャはロスレス圧縮できないことを教えてくれ、帯域幅のペナルティを支払う可能性があります。

メタルデバッガは、これらのテクスチャを可逆圧縮できない理由も教えてくれます。

ここでは、ShaderWriteの使用フラグが原因であることがわかります。

メモリセクションに行くと、すべての使用フラグを確認できます。

メモリセクションに入ったら、レンダリングターゲットでフィルタリングできます。

次に、テーブルヘッダーを右クリックし、テクスチャを選択し、次に使用を選択します。

これで、使用法で並べ替え、ShaderWriteを使用してテクスチャを見つけることができます。

テクスチャの作成時にShaderWriteまたはPixelFormatViewフラグを設定すると、ロスレス圧縮が無効になります。

これらの旗をもっと詳しく見てみましょう。 ではもっと詳しく見てみましょう。

Unknown、ShaderWrite、およびPixelFormatViewフラグは、テクスチャがロスレス圧縮されるのを防ぎます。

一般的な経験則は、必要な場合にのみこれらのフラグを使用することです。

たとえば、write() メソッドを使用してフラグメントまたは計算関数のテクスチャに値を格納する場合は、ShaderWrite フラグを使用します。

カラーアタッチメントとしてバインドされたテクスチャにレンダリングするには、ShaderWriteフラグは必要ありません。

また、コンポーネントの値を別の順序で読み取る必要がある場合は、PixelFormatViewオプションを設定しないでください。

代わりに、スウィズルパターンを使用してテクスチャビューを作成し、新しい順序を指定します。

同様に、テクスチャビューが線形空間とsRGBの間でのみ変換する場合は、PixelFormatViewオプションを設定しないでください。

詳細については、ドキュメントを確認してください。

シェーダーの最適化と可逆圧縮は、私たちを助けた2つのテクニックですが、別の問題領域は、頂点、フラグメント、および計算チャネル全体で良好な重複を得ています。

チャネル間でワークロードを最適化する2つの方法を見てみましょう。

まず、メタルシステムトレースをもう一度見ることから始めます。

ここでは、頂点、フラグメント、および計算チャネルの重複が少ないことがわかります。

GPUを忙しく保つために、これを改善するのはいいことです。

この問題を解決する1つの方法は、フレームグラフのエンコーディング順序を再構築できるかどうかを確認することです。

言い換えれば、この作業を頂点ステージの占有率が非常に低い場所に移動したいと考えています。

以前のレンダリングパスのフラグメントステージとともに、これらの頂点を早期に処理したいと思います。

フレームグラフは、この疑似コードの例のように、レンダリングタスクのリストと考えることができます。

良いオーバーラップを得るのは、フレームグラフのレンダリングタスクの順序を変更するのと同じくらい簡単です。

一部のタスクは以前のタスクの結果に依存する場合がありますが、必ずしもそうとは限りません。

頂点シェーダーが重いCascadedShadowBufferステージは、依存関係が少ないため、いくつかのタスクを早く移動できることがわかりました。

そして今、重複の少ない地域は、頂点とフラグメントチャネルの利用率が向上し、さらに1ミリ秒の勝利が得られます。

しかし、私たちが試すことができる別の最適化があります。

ゲームはしばしば飛行中に2〜3フレームを持っています。

したがって、タイルベースの遅延レンダリング、またはTBDRアーキテクチャGPUのクールな機能は、それらの間にリソースの依存関係がない場合に、2つのフレームからワークロードを重ねることです。

では、この可能性を最適化する方法を紹介します。

インストゥルメントのGPUトラックをもう一度見てみましょう。

ここでは、これらのフレームがほぼ連続して処理されていることがわかります。

これは、blitエンコーダを使用して、フレームごとのアニメーションデータなどの一定のバッファを更新することによって引き起こされます。

ディスクリートGPUで一定のバッファデータを効率的に更新するために、CPU上の共有バッファからフレームのレンダリングに使用されるGPU上のプライベートバッファにブリットします。

この戦略は、ディスクリートメモリを持つGPUにとって効率的であるため、その目的のためにこの動作を維持したいと考えています。

デバイスにユニファイドメモリアーキテクチャがある場合は、ブリットエンコーダを使用してデータをプライベートバッファにコピーする必要はありません。

ただし、リングバッファパターンで共有バッファを使用する場合は、CPUが現在GPUによって読み込まれているデータに書き込むと、視覚的な破損が発生する可能性があるため、同期の問題に注意する必要があります。

これを実際に見てみましょう。

ここでは、この図でフレームのエンコーディングとレンダリングを見ることができます。

共有バッファを表すために色を使用しており、フレームの先頭で更新されます。バッファ1は青、バッファ2は緑、バッファ3は黄色です。

リングバッファは通常、コンパクトな量のメモリを使用する必要があるキューを実装するために使用されます。

ここでは、共有バッファの書き込みと読み取りは相互に排他的であるため、この取り決めによるデータ競合状態の懸念はありません。

フレームのエンコードとフレームのレンダリングの間にレイテンシがあるのは非常に一般的です。

これにより、レンダリングが実際に開始される時期が変化します。

レイテンシが長すぎない限り、データ競合状態はありません。

しかし、レイテンシが増加し続けるとどうなりますか?

さて、これは、GPUがフレームをレンダリングしている間にメインスレッドが共有バッファを更新しているデータ競合条件を導入します。

そして、それが起こると、フレームの要素がこのデータに依存している場合、視覚的な破損が発生する可能性があります。

Baldur's Gate 3の場合、プライベートバッファとBlitエンコーダを削除すると、同期ポイントが排除されましたが、競合状態が導入され、一時的なアンチエイリアスレンダリングパスに影響しました。

では、この状況を回避する方法を見てみましょう。

この競合状態を回避するには、GPUが読み込んでいるのと同じリソースに書き込んでいないことを確認する必要があります。

たとえば、完了ハンドラを利用して、エンコーディングスレッドの共有バッファを更新するのが安全になるまで待つことができます。

しかし、待ち時間を避けた方法をお見せしましょう。

完了ハンドラを維持しましたが、待ち時間を避けるためにリングバッファに余分なバッファを追加しました。

余分なバッファーは、下の図で紫色に着色されています。

メモリ消費量はディスクリートGPUと同じままです。

しかし、メモリを節約する必要があり、CPUの待ち時間がゲームのフレームレートに影響しない場合は、3つのバッファを使用できます。

それでは、疑似コードの例で作成する共有バッファとプライベートバッファの数を決定する簡単な方法を見てみましょう。

このコードスニペットでは、初期化時に共有バッファとプライベートバッファの数を選択する方法を確認できます。

デバイスを作成したら、デバイスにユニファイドメモリがあるかどうかを確認し、追加の共有バッファを作成するか、プライベートバッファを使用することを確認します。

この余分なバッファは、データ競合状態を回避するために使用している完了ハンドラを待つことの影響を軽減するのに役立ちます。

そして今、前のフレームのフラグメントワークロードが次のフレームの頂点ワークロードとどのように重なるかを見ることができます。

全体として、これはシーンに応じて1〜2ミリ秒を与えることができます。

そして、もちろん、このアプローチは、この例で示した一定のバッファデータだけでなく、CPUからGPUに転送するすべてのバッファデータにも適用できます。

では、復習しましょう。

Larian Studiosは、次の最適化を適用することで、パフォーマンス目標を達成することができました。バブルを減らすために最も高価なシェーダーを最適化し、帯域幅を改善するためにロスレス圧縮を選択し、頂点とフラグメントワークロードを重ねてGPUの使用率を向上させ、フレームの重複を防ぐリソースの依存関係をチェックします。

彼らが終わったとき、ラリアンスタジオはパフォーマンス目標を達成しただけでなく、ゲームのフレームタイムが33%向上しました。

そして今、私たちはゲームメトロエクソダスで異なる一連の最適化を見ていきます。

メトロエクソダスは、この一連のゲームプレイクリップでわかるように、壮大なストーリーと要求の厳しい視覚効果で知られています。

提案された最適化を統合した後、4A Gamesはパフォーマンス目標を達成することができました。

それでは、メトロエクイダスのゲーム内シーンを見てみましょう。

Metro Exodusは、カスタムワークフローを使用してレンダリングコマンドをMetal APIコマンドに変換します。これは、クロスプラットフォームゲームでは非常に一般的です。

彼らが使用している翻訳層はMetalに最適化されていますが、2つの複雑なシステムが実際に一緒になると、いくつかの問題が発生する可能性があります。

そのため、プロジェクトの目標を達成するためには、追加のパフォーマンスチューニングが必要でした。

前のゲームと同様に、フレームがどのようにレンダリングされているかを調査することから始めます。

現代のレンダラーにはさまざまな技術が含まれているため、まず高レベルのフレームグラフを理解しようとします。

繰り返しになりますが、GPUのトレースを見て分析を開始します。

それは常にゲームのパフォーマンスに関する有用な洞察を与えてくれます。

まず、開発者のパフォーマンス目標を満たしていないGPUの時間から始めましょう。

では、最も時間がかかるシェーダーやパイプラインを見つけましょう。

これを行うには、もう一度パイプラインの状態ごとにグループ化し、最も高価なものを見ていきます。

その統計をすばやく見てみましょう。

合計と比較してALU命令の数が多いことがわかります。つまり、これは数学の多いシェーダーです。

また、シェーダーで使用されているレジスタの数が非常に多いことがわかります。

特定のシェーダーで使用されるレジスタの数は、実行中にワークロードがどのように拡張されるかに直接影響します。

この数字が高ければ高いほど、GPUが並行して行う作業が少なくなります。

この例のSSAOのような複雑なシェーダーで、多くの計算とレジスタが必要になることもありますが、コンパイラの設定が生成された命令とレジスタの割り当てにも影響することもあります。

シェーダーコンパイラのオプションも見てみましょう。

そして、このシェーダーは高速数学フラグを無効にしてコンパイルされたことが判明しました。

高速数学により、シェーダーコンパイラはさまざまな命令を最適化でき、デフォルトではメタルシェーダーコンパイラで有効になっています。

ただし、カスタムシェーダーワークフローを使用して、このコンパイルフラグを無効にできる場合があります。

この場合、4A Gamesがコンパイラを呼び出すために使用していた翻訳レイヤーには、高速数学を使用しないようにデフォルトの動作が設定されていることがわかりました。

では、高速数学とは何ですか?

高速数学は、速度と正確性の間で取引する浮動小数点演算のための一連の最適化です。

たとえば、結果または引数としてNAN、無限大、または符号付きゼロがないと仮定することができます。

高速数学の最適化は、代数的に等価な変換を適用することもでき、浮動小数点結果の精度に影響を与える可能性があります。

しかし、ほとんどのシナリオでは、速い数学はゲームに最適です。

これにより、特にALUに縛られたケースでは、パフォーマンスが大幅に向上する可能性があります。

私たちの推奨事項は、シェーダーが先ほど述べたものに依存していない場合は、高速数学を有効にしていることを確認するためにコンパイラオプションを確認することです。

高速数学フラグは、フロントエンドとバックエンドのコンパイラレベルで機能します。

シェーダーソースを構築するとき、フロントエンドのシェーダーコンパイラは、中間コードで使用される高速数学関数を選択します。

これは、より最適なGPUマシンコードを生成できることをバックエンドシェーダーコンパイラに示唆します。

ここでは、このシェーダーを再コンパイルした後、右側のボックスで左側の指示と登録カウンターがどのように改善されたかを見ることができます。

したがって、すべてのシェーダーの高速数学を可能にするために翻訳レイヤーの動作を変更した後、組み込みのゲームベンチマークを使用してテストワークロードのフレーム時間が21%減少しました。

だから、私が話したい次の分野は冗長バインディングです。

要約ページに戻り、APIの洞察を見ると、フレームをレンダリングするときに多くの冗長なバインディングがあることがわかります。

冗長バインディングは、テクスチャ、バッファ、サンプラーなどのリソース、または深度ステンシル状態、ビューポート設定などのレンダリング状態のいずれかです。

繰り返しバインドされたリソースはエンコーディング時間に悪影響を及ぼす可能性がありますが、冗長なレンダリング状態の変更はGPU時間にも影響を与える可能性があります。

メタルシステムトレースのエンコーディングとGPU時間を見てみましょう。

特定のフレームでは、すべてのコマンドをエンコードするのに8ミリ秒半かかり、GPUがこのフレームをレンダリングするのに約22ミリ秒かかります。

冗長バインディングの原因を調査したところ、翻訳層を変更してそれらを減らすことができることがわかりました。

では、冗長なバインディングをチェックして減らす方法を示す疑似コードの例をお見せしましょう。

テクスチャを直接エンコーダにバインドする代わりに、それらを事前にキャッシュし、変更された場合にのみバインドすることができます。

また、APIとの相互作用を最小限に抑えるために、1つずつループで設定するのではなく、setFragmentTexturesメソッドを1回呼び出してすべてのテクスチャを設定できます。

さらに、他のシェーダーステージや、バッファやサンプラーなどの他のバインディングタイプ、レンダリング状態にも同様のアプローチを適用できます。

では、メタルシステムトレースで何が起こったのか見てみましょう。

4A Gamesは、翻訳層が同じリソースとレンダリング状態を繰り返しバインドしていなかったため、シーンに応じてエンコーディング時間を30%から50%短縮することができました。

しかし、GPU時間も最大3ミリ秒減少し、全体として、ゲーム内のベンチマークで15%のスピードアップをもたらしました。

いくつかの冗長なバインディング警告がある場合、それは問題ではありませんが、私たちは間違いなく数百または数千の冗長バインディングの影響を見ています。

したがって、冗長なバインディングを避けることで、平均フレーム時間をさらに15%短縮しました。

これら2つの改善の後、4A Gamesはパフォーマンス目標を達成することができました。

それでは、Apple GPU用のMetro Exodusの最適化から学んだことをまとめましょう。

まず、シェーダーのカスタムワークフローを使用している場合は、コンパイラの設定を確認して、Metalアプリケーションに最適なオプションを使用していることを確認する必要があります。

また、メタルデバッガに多くの冗長なバインディング警告が表示された場合は、エンコーディングとGPUの時間のオーバーヘッドを削減するテクニックを示しました。これは、エンジンまたは使用している翻訳層のいずれかに適用できます。

そして今、私はそれをDustinに引き渡したいと思います。DustinはDivinity: Original Sin 2についてあなたに話し、新しいXcode GPUタイムライン機能をデモします。

ありがとう、ジョナサン。

こんにちは、私の名前はダスティンで、ここアップルのGPUソフトウェアチームで働いています。

そして今日、Larian Studiosのヒットタイトル「Divinity: Original Sin 2」の初期ビルドを最適化する実践的なデモをお見せできることを嬉しく思います。

昨年、ラリアンは絶賛されたロールプレイングゲーム「Divinity: Original Sin 2」をiPadに持ち込むと発表した。

そして、昨年、ラリアンはApple GPUでうまく動作するようにゲームを最適化するために懸命に取り組んでおり、ゲームはプレイするのがとても楽しいです。

ラリアンは、新しいGPUタイムラインを追加することで、今年Xcode 13でさらに良くなっているMetal DebuggerとMetal System Traceの素晴らしいツールセットの助けを借りて、これらの結果を達成することができました。

先ほど撮影したDivinity: Original Sin 2のフレームを見てみましょう。

概要ページには、ゲームをデバッグして最適化するのに役立つフレームの概要が含まれています。 をデバッグして最適化するのに役立つ。

概要ページから、新しいGPUタイムラインを含む、メタルデバッガーが提供するすべての優れたツールにすばやく移動できます。

そして、アクセスは、ここで新しいパフォーマンスページをクリックするのと同じくらい簡単です。

だから、先に進んでそれをやらせてください。

新しいGPUタイムラインをご紹介します。

タイムラインは、各GPUパイプラインステージを並行して実行できるようにするApple GPUのユニークなアーキテクチャを中心に設計されています。

パフォーマンスを最大化するためには、タイムラインで簡単に見ることができるオーバーラップを最大化することで、すべてのパイプラインステージをできるだけ忙しく保つ必要があります。

タイムラインは2つのセクションで構成されています。

上部にはGPUセクションがあり、各パイプラインステージごとに別々のトラックで構成されているため、どのステージがアクティブで並行して実行されているかを本当に簡単に確認できます。

その下には、シェーダーの占有率、帯域幅、パフォーマンスリミッターなどの重要なカウンターのキュレーションされたセットを含むカウンターセクションがあり、ワークロードの過程でGPUのシステムパフォーマンスがどのように変化するかについてのより深い洞察を提供します。

GPUトラックのエンコーダは、クリックするだけで、さらに多くの有用な情報を提供します。

レンダリングエンコーダを選択すると、現在選択されているアイテムの追加情報を含むタイムラインのサイドバーが表示されます。

この場合、サイドバーには、テクスチャの詳細、ロード/ストアアクション、ドロー呼び出しの数などのレンダリングパス情報が含まれています。

レンダリングエンコーダは2つのシェーダーステージで構成されているため、頂点ステージとフラグメントステージの両方が強調表示されることに注意してください。

代わりにフラグメントトラックを選択すると、サイドバーにはタイムライン内のすべてのエンコーダが含まれており、時間に基づいて並べ替えることができます。

しかし、フラグメントトラックを展開して、実行中にエンコーダが使用するすべてのシェーダーを表示するシェーダータイムラインを表示できるため、それだけではありません。

長時間実行されるシェーダーや、他のシェーダーと並行して実行されているシェーダーを簡単に識別できます。

フラグメントトラックには、ロード/ストアアクション用の2つの追加トラックもあります。

これは、GPUがローカルメモリとメインメモリの間でアタッチメントテクスチャをロードして保存しているときに確認するのに有用であり、帯域幅の使用を削減するための重要な考慮事項です。

シェーダーを選択すると、アクティブになっているタイムライン上のすべての領域が強調表示され、サイドバーに表示されるコンパイラ統計とランタイムパフォーマンスメトリックから詳細を知ることができます。

シェーダーのタイムラインを展開すると、各シェーダーが独自のトラックに表示され、GPUワークロードの流れとシェーダーの実行順序を理解するのに役立ちます。

新しいGPUタイムラインにもう少し精通し、自分で使用できるすべての方法を考えているので、GPUタイムラインを使用してパフォーマンスのボトルネックを見つけるのがいかに簡単かをお見せしましょう。

シェーダーのパフォーマンスは、多くの要因の結果として損なわれる可能性があり、そのうちの1つはレジスタ圧力であり、これが起こると、GPUは高速レジスタメモリを使い果たし、代わりにメインメモリを使用する必要があります。

高いALUリミッターだけでは、パフォーマンスのボトルネックを示すものではありません。

あなたのシェーダーは数学が重いだけかもしれません。

ただし、シェーダーの占有率が低いと組み合わせると、シェーダーがレジスタ圧力を経験していることを示す指標となり、シェーダーの動作が遅くなる可能性があります。

今日のデモでこれをよりよく強調するために、左側の「プラス」ボタンをクリックして、ALUトラックとシェーダー占有トラックの両方をタイムラインの上部に固定します。

これら2つのトラックをスキャンすると、最初に気付いたのは、ALUが急増し、同時にシェーダーの占有率が低下するこの地域のことです。

タイムラインで領域を強調表示して、実行にかかる時間を確認できます。

これを行うと、サイドバーのカウンタは、選択した領域に基づいて動的に更新されます。

ここの領域は、実行に約3.7ミリ秒かかっています。

ズームインして詳しく見てみましょう。

私たちの問題は、アンビエントオクルージョンパスの最初の4つのエンコーダに関連しているようです。

シェーダーのタイムラインを見て、どのシェーダーが使用されているか見てみましょう。

私たちの問題は、使用されている唯一のものなので、ここでこのシェーダーに関連しているようです。

サイドバーのランタイムパフォーマンス指標から、このシェーダーALUは集中的であるだけでなく、フロートも重いので、浮動小数点利用トラックを見てみましょう。

このトラックにカーソルを合わせると、このシェーダーはF32のみを使用していることに注意してください。

F16は0%です。

タイムラインから、シェーダーを右クリックして開くことで、シェーダーソースに直接移動できます。

ここソースエディタでは、デモ用のシェーダーソースの簡略化されたバージョンを見ることができます。

ソースに加えて、シェーダープロファイラの助けを借りて、行ごとのコスト情報を見ることもできます。

シェーダープロファイラ円グラフにカーソルを合わせると、ALUとフロートヘビーの両方であるため、この機能がレジスタ圧力を引き起こしている可能性が高いことを確認できます。

このような状況は、F16を使用するための候補であり、F32の完全な精度が要求されない場所では、レジスタの量の2倍になり、レジスタの圧力を軽減するのに役立ちます。

メタルデバッガは、ソースエディタ内で直接ソースコードを更新するのが本当に便利です。

F32とF16の混合物を使用するシェーダーの更新バージョンを使用して、ここでこの変更を加えてみましょう。

この変更を行った後、下部にある「シェーダーをリロード」ボタンをクリックすると、シェーダーの更新がトリガーされ、シェーダーの再コンパイルと再プロファイルの両方がトリガーされ、ラインごとのシェーダーのコストが更新されます。

タイムラインに戻ることで、この変更がどのような影響を与えたか見てみましょう。

私が最初にしたいことは、アンビエントオクルージョンパスの最初の4つのエンコーダにどれくらいの時間がかかるかを見ることです。

ここのこの地域は、実行に約2.6ミリ秒かかるようです。

先ほどの変更により、シェーダーの実行時間が1ミリ秒以上（30%）改善されました。これは大きな改善です。

以前のカウンターのいくつかを見てみると、ALUはまだ高いですが、それは数学の重いシェーダーに期待されます。

しかし、シェーダーの占有率がほぼ2倍に改善されたため、シェーダーのレジスタ圧力が少なくなっています。

これは、浮動小数点利用トラックを使用して見ることができるF32とF16の混合物を使用して達成されました。

GPUタイムラインにより、問題を特定し、問題が存在する場所に移動し、修正することが本当に簡単になりました。

GPUタイムラインは、シェーダーのパフォーマンスの問題だけでなく、メモリ帯域幅や他の多くの種類の問題を特定するための優れたツールです。

私はあなたが真新しいGPUタイムラインのこのデモを楽しんで、すでにApple GPUでさらに良く実行するためにゲームを最適化するために使用するすべての方法を考えていることを願っています。

ありがとう、そしてWWDCの残りの部分を楽しんでください。

ジョナサンに戻る。

ダスティン、その素晴らしいデモをありがとう。

そして、見てくれてありがとう。

Apple GPUの機能を活用するために、Larian Studiosと4A Gamesとどのように協力したかを皆さんと共有できてよかったです。

それらは、ロスレス圧縮から重複するシェーダーワークロードまで、パフォーマンスを向上させる多くの方法を提供します。

また、Metal System TraceやXcodeの新しいGPUタイムラインなどのツールは、ゲームを改善する際に本当に役立ちます。

私があなたに残すことができることが1つある場合、高度に最適化されたゲームを提供するためには、あなたのレンダリングの徹底的な検査が不可欠であり、私たちのツールはこれを助けるためにそこにあります。

詳細を知りたい場合は、今年のWWDCの関連セッション「メタルデバッグ、プロファイリング、アセット作成ツールの発見」、またはWWDC20の「GPUカウンターでメタルアプリとゲームを最適化する」を参照してください。

ありがとう、そしてさようなら!

[音楽]。