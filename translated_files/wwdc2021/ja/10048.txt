10048

♪ ♪

こんにちは、私の名前はブレット・カトーで、システムエクスペリエンスチームのエンジニアです。

今日は、素晴らしいウィジェットの原則について話し、可能な限り最高のウィジェットを構築するのに役立ついくつかのホットなトピックに飛び込みます。

iOS 14では、WidgetKitを導入しました。

WidgetKitを使用すると、iOS、iPadOS、macOSのユーザーのホーム画面で、美しくダイナミックなマルチプラットフォームウィジェットを作成できます。

さて、始める前に、WWDC 2020の講演を見逃した場合、WidgetKitフレームワークとそのコアコンセプトを紹介する「Meet WidgetKit」など、本当に素晴らしいものがいくつかあります。

「ウィジェットコードアロング」は、基本から上級まで複雑さを増すウィジェットを構築する3部構成のシリーズです。

「ウィジェット用のSwiftUIビューの構築」では、ウィジェットの適応可能なビューを構築するためにSwiftUIを最大限に活用する方法について詳しく説明します。

最後に、「素晴らしいウィジェットをデザインする」は、多くの例を挙げて、ヒューマンインターフェースグループからデザインの考慮事項を探ります。

今日は、優れたウィジェットの2つのトピックに触れます。関連性を維持し、ウィジェットのカスタマイズを有効にします。

では、関連性から始めましょう。

ウィジェットが最新であり、その環境に適応できることを確認するために、3種類の関連性について深く議論します。

時間、プレゼンテーション、場所の関連性について話します。

WidgetKitの中心にはタイムラインがあります。

これは、一日を通して関連性を維持するためのウィジェットのコアメカニズムです。

タイムラインは、1つ以上のタイムラインエントリで構成されています。

この例では、午前9時、午前9時30分、午前10時の3つのエントリを見ることができます。

これで、システムがウィジェットにタイムラインを要求すると、結果のタイムラインがアーカイブされ、そのエントリは将来指定した特定の時間にレンダリングされます。

これにより、システムは一瞬の通知でユーザーインターフェイスを準備し、ユーザーが必要とするときに表示することができます。

最も単純なものから始めて、タイムラインのいくつかの例を見て、その中にある可能性のあるコンテンツの種類を見てみましょう。

これは、1つのエントリを持つ最も単純なタイムラインの例です:スクリーンタイム。

現在、スクリーンタイムは将来のデータを予測または予測できず、ユーザーのデバイスがどのように使用されたかの統計履歴に厳密に基づいているため、タイムラインで複数のエントリをうまく活用できないため、1つのエントリを使用するだけです。

これはあなたが持つことができる最も単純なタイムラインです。

とはいえ、すべてのウィジェットが単一のエントリである必要はなく、実際には、ほとんどの場合、タイムラインで複数のエントリを提供しない理由を検討し、質問することをお勧めします。

将来を見据えたコンテンツがある場合、重要な日付や締め切りがある場合、または将来のコンテンツを予測できる場合、ウィジェットはタイムラインの複数のエントリを実際に利用しているはずです。

これは天気の別の例です。

ご覧のとおり、天気のタイムラインは、1日を通して最後の時間に複数のエントリを提供します。

さて、ここでの最初のエントリは、現在の天気を表し、他のすべての後続のエントリは、その日の後半の予測データを表すため、最も正確です。

この追加の予測データは、ウィジェットのリロードは、指定した正確な時間にリロードすることが保証されていないため、非常に便利です。

そして、リロードが希望どおりにその目標日に正確にヒットしない場合、システムはユーザーエクスペリエンスを乗り越えるために追加の予測コンテンツを持っています。

これは写真の例です。

写真のタイムラインは、1日の特定の時間に表示される多くの個人的および関連性の高い写真を提供していることがわかります。

私にとって、これらは本当に、本当に素晴らしい思い出です。

そして今、ウィジェットは1日に数回しかリロードしませんが、これらの複数のタイムラインエントリから新しくて新鮮なコンテンツを提示することで、本当に活気に満ちている感覚を与えます。

ご覧のとおり、写真のこの例のように、天気のような予測可能なデータがなくても、タイムラインでこれらの複数のエントリを活用することで、驚かせ、喜ばせる方法でユーザーに関連するコンテンツを組み込むことができます。

さて、一部のウィジェットは他のウィジェットよりも多く表示されるため、ウィジェットに更新の公平性要因を与えることにしました。

私たちはこれを更新予算と呼んでいます。

予算は一日を通して割り当てられ、蓄積され、ユーザーの視聴習慣に大きく影響されます。

頻繁に表示されるウィジェットは、1日あたり約40〜70のバックグラウンド更新の球場のどこかで受け取ることが期待できます。これは、ユーザーが起きている通常の時間内に均等に配置されている場合、約15〜30分ごとに更新されます。

しかし、もちろん、すべてのリロードがこのように均等に間隔をあける必要はなく、私たちの目標は、さまざまな要件に対してさまざまな更新ケイデンスを有効にしてサポートすることでした。

たとえば、お気に入りのチームの今後の試合までほとんどアイドル状態のスポーツウィジェットがあり、試合前、試合中、試合後にスコア更新のバーストを受け取ることができます。

WidgetKitのスマートで、ユーザーが眠っているときのように、ユーザーがデバイスを長時間使用していないときに更新を保留する可能性があります。

それ以外の場合、特定のウィジェットの予算が利用可能になるまで、ウィジェットの更新が保留される可能性があります。

しかし、そうは言っても、リロードは毎秒の操作ではありません。

ウィジェットは、ホーム画面でライブランニング体験を作成することではありません。

今、あなたのウィジェットが一日を通して更新される多くの方法があります。

そして、これらのそれぞれを簡単に説明して、それらが何であるか、どのように機能し、先ほど導入した予算に関連してどのように機能するかを理解します。

1つ目は、WidgetKitのAPIであるTimelineReloadPolicyです。

これは、リロードが自動的に行われるためのコアメカニズムです。

タイムラインを提供する場合は、それと一緒にリロードポリシーも提供します。

このリロードポリシーは、バックグラウンドでウィジェットを自動的に更新したいときにシステムに通知します。

これらの自動更新は予算化され、ウィジェットの現在の利用可能な予算から引き落とされます。

次はWidgetCenterリロードAPIです。

これは、ウィジェットの既存のデータを無効にするイベントが発生したときにウィジェットを更新するAPIです。

さて、通常、このAPIを使用するリクエストは利用可能な予算を消費します。つまり、予算が利用可能になるまで更新は行われません。

しかし、これらのリロードを即時かつ予算なしで行うようにするいくつかの状況例外があります。

これらは、コンテナアプリがユーザーのフォアグラウンドである場合、またはアプリがナビゲーションや再生中オーディオなどのユーザーセッションに参加している場合です。

このAPIは、TimelineReloadPolicy APIからの自動バックグラウンド更新を本当に補完するものです。

ウィジェットは、重要な場所の変更が発生したときにも更新できます。

システムが重要な場所の変更を検出し、ウィジェットが場所を使用すると、システムは予算なしの更新を許可します。

この更新は、場所を適切に解決できるように、ユーザーが次にウィジェットを表示したときに発生します。

さて、これは場所の変更が発生したときにすぐに起こることは保証されるのではなく、ユーザーが次回ウィジェットを見たときに起こることを保証することに注意してください。

後で場所についてもう少し話します。

プレゼンテーション環境が変更された場合、システムもウィジェットを更新できます。

たとえば、ユーザーが動的テキストや太字テキストなどのアクセシビリティ設定を変更したり、言語や地域の変更、iCloudまたはApp Storeアカウントの変更、大幅な時間変更などがあるかもしれません。

最後に、予算編成のため、ユーザーがめったに見られないウィジェットを持っている場合、開発者が好むほど多くの更新を受信しない可能性があります。

システムは、タイムラインの日付、好みの更新時間、およびユーザーからの一般的なビュー履歴を知っています。

システムは、ユーザーが閲覧したときにデータが古くなっている可能性があると思われる場合、予算なしのリロードを許可する場合があります。

もちろん、これらのシステム開始の更新はすべて常に予算フリーです。

先ほど学んだように、各タイムラインには、バックグラウンドで自動的に更新するタイミングを説明するリロードポリシーが組み合わされています。

WidgetKitはここで3つの選択肢を提供します:atEnd、afterDate、never。

これら3つのリロードポリシーのうち、ウィジェットに適したものはどれですか?

文脈のためのいくつかの例を挙げて、それぞれについて話し合いましょう。そして、それぞれについて何に留意すべきかについてのgotchasについて話しましょう。

議論する最初のポリシーは、atEndリロードポリシーです。

このポリシーは、タイムラインが終了したとき、つまりもちろん最後のエントリが関連したときに、ウィジェットを更新する資格をマークします。

この場合、午前10時30分です。

また、今回は単にウィジェットが更新の対象となる時間であり、この時点で正確に更新されることを保証するものではありません。

さらに、前に説明したスクリーンタイムの例のように、シングルエントリのタイムラインを持つウィジェットでatEndを使用する場合、システムはウィジェットに適切な時間を選択します。

ウィジェットに現在のタイムラインの寿命を超えたコンテンツがすでにある場合は、atEndをお勧めします。

私はあなたのコンテンツにウィンドウを見るようにそれについて考えるのが好きです。

例を見てみましょう。 例を見てみましょう。

ここで概説されているのは、6月7日のカレンダーウィジェットの現在のタイムラインです。

4つのエントリがあります。

ウィンドウを紹介するのに役立つ過去と将来のコンテンツを含めました。

そして、6月8日のタイムラインを変更すると、そのコンテンツのウィンドウを見ることで私が何を意味するかがわかります。

そしてまた、6月9日のタイムラインについて。

私たちは、すでに利用可能で、ユーザーによって提供されているデータに対する視点を変えているだけです。

このタイプのコンテンツは、実際にatEndポリシーを使用することが輝く場所です。

さて、atEndポリシーを使用するウィジェットの例には、リマインダー、カレンダー、写真、ヒントなどがあります。

繰り返しになりますが、これらはすべて、将来的によく知られている無限のコンテンツを持つウィジェットであり、単にウィンドウを表示することができます。

システムはあなたのためにリロード時間を選択し、おそらくあなたが望むものではないので、シングルエントリーのタイムラインにはあまり適していません。

また、タイムラインに時間の経過とともに関連性や精度が失われる予測コンテンツがある場合、AtEndは推奨されません。

私たちは単にあなたのコンテンツが可能な限り最も関連性のあるものにしたいし、物事が更新の資格を得るために最も関連性の低いタイムラインの終わりまで待つと、それは最高のユーザーエクスペリエンスにつながりません。

だから、それはアットエンドです。さて、afterDateについて話しましょう。

afterDateリロードポリシーにより、ウィジェットは指定された日付以降にリロードの対象となります。

AfterDateでは、資格時間を完全に管理できます。

この例では、タイムラインが午前9時から午前11時頃まで有効であるふりをしましょう。

ウィジェットの予測データが9時45分頃に精度を失い始めるため、午前9時30分のウィジェットリロードポリシーの日付が選択されました。

これにより、9時30分にすぐにリロードされていなくても、ウィジェットには9時30分以降に十分な滑走路があり、予測データを表示できます。

afterDateは、1日を通して予測不能または予期せず変化する可能性のあるコンテンツや、正確性や関連性が定期的に変化するデータに最も適しています。

afterDateを使用するウィジェットの例には、株式、天気、ニュース、メールなどがあります。

これらはすべて、一日を通して予測不能または予期せず変化する可能性のあるコンテンツを含むウィジェットです。

さて、afterDateでは、いくつかの潜在的な問題に本当に注意する必要があります。

ほぼ即時のリロードに注意してください。

1分かそこら離れた日付を指定することは有効ですが、通常は非常に狭い時間枠でのみ有効です。

このレベルの解像度であまりにも多くのリフレッシュを求めると、後でリロードを飢えさせる可能性があります。

また、デバイス間でウィジェットの更新日を揃える場合は注意してください。

例えば、米国は。株式市場は東海岸で午前9時30分にオープンし、午前9時30分にリフレッシュをスケジュールして、その日の初期データをサーバーから取得します。

あなたのウィジェットは数千または数百万のデバイスにあり、潜在的にはそれらの各デバイスでも複数回ある可能性があることを覚えておいてください。

そして、このように時間に合わせたデータプルを行う必要がある場合は、キャッシングサーバーを打つことに加えて、これらの日付にある程度のランダムなジッターを追加することを検討する必要があります。

これらは、潜在的に計画されていないコストや不必要なコストを避けるために考慮することが特に重要です。

最後に、私のお気に入りのリロードポリシーについて話しましょう。これは決してありません。

決してリロードしないポリシーは、自動的にリロードされないため、最も単純なポリシーです。

ウィジェットのコンテンツが、フォアグラウンドであるコンテナアプリケーションを介してのみ変更できる場合、またはプッシュ通知などの個別のイベントを介してのみ変更できる場合は、ウィジェットにとって決して素晴らしい選択ではありません。

ネローポリシーを使用する場合は、コンテナやその他のアクセサリ拡張機能からのWidgetCenterリロードAPIでのみ、ウィジェットを最新の状態に保つことができます。

これにより、必要な場合にのみリロードが最小限に抑えられ、予算とユーザーのバッテリー寿命への影響を最小限に抑えます。

ウィジェットがアプリでまだ満たされていない明示的なユーザー条件を必要とする場合も、決して適切ではありません。

たとえば、サービスにログインしたり、特定のコンテンツを購入したりするかもしれません。

これらの種類の条件がアプリで満たされる前に、ウィジェットが意味のあるコンテンツを生成できない場合は、決して考慮しないでください。

決してポリシーを使用するウィジェットの良い例には、テレビ、メモ、音楽、ポッドキャスト、連絡先などがあります。

これらはすべて、コンテンツの変更を促進するためにアプリ内のユーザーインタラクションを必要とするウィジェットとアプリ、またはそれらのコンテンツ更新のプッシュを受け取ります。

要約すると、タイムラインエントリを有利に活用してください。

ウィジェットの正しいリロードポリシーを選択し、WidgetCenterのリロードAPIを使用して、個別のイベントのタイムラインイベントをリロードします。

さて、プレゼンテーションの関連性に移りましょう。

ウィジェットはiOSまたはmacOSの特定のコンテキストで表示され、ウィジェットの外観が変わる可能性があります。

ウィジェットは、タイムラインを更新せずに再レンダリングされることがあります。

そして、優れたウィジェットは常にこれらのプレゼンテーション環境に適切に適応します。

そこで、カラースキーム、ダークモードとライトモード、iOS 15で新しい部分的なプライバシーの編集、および完全なプライバシーの編集について話します。

WidgetKitは、システム設定が変更されると、ライトモードとダークモードの間のコンテンツの移動を自動的に処理します。

これは、SwiftUIのパワーを使用しているためです。

次に、これらのそれぞれのコンテキストでウィジェットをどのように見たいかを考えてください。

ここでは、明るいスキームと暗いスキームの両方でノートとカレンダーの例を見ることができます。

ただし、すべてのウィジェットが背景とテキストの色を変更することで、必ずしもライトモードとダークモードに準拠する必要はないことを覚えておいてください。

たとえば、音楽や株式など、色を変えないウィジェットがいくつかあります。

アプリケーションデザインがダークスタイルとライトスタイルのこの高コントラストコンテンツに依存しない場合は、ウィジェットにとって理にかなっている配色を自由に続けてください。

Xcodeプレビューを通じて、Xcodeでウィジェットの配色変更をプレビューすることもできます。

これは、ライトモードでsystemSmallウィジェットをプレビューする簡単な例です。

そして今、ダークモードです。

私たちがしなければならなかったのは、この環境でウィジェットがどのように見えるかをプレビューするために、colorScheme環境オーバーライドを追加することだけでした。

また、ここに示すように、ライトモードとダークモードのシステム標準の背景色が必要な場合は、塗りつぶしにBackgroundStyleを使用してください。

ウィジェットは、iOSのロック画面など、プライバシーに敏感なプレゼンテーション環境にもさらされています。

iOS 15の新機能で、ウィジェットはこのような状況で部分的なコンテンツを編集できるようになりました。

さて、それは本当に混乱しているように聞こえるかもしれないので、私がここで何を言っているのかを見るために例を挙げましょう。

特定の口座で利用可能な残高を表示している銀行ウィジェットを持っているふりをしましょう。

この場合、私の口座には128.45ドルがあります。

さて、ロック画面に移動してデバイスをロックすると、デバイスがロックされたときにWidgetKitが残高情報を動的に編集する方法がなかったため、このアカウントの残高はまだiOS 14に表示されます。

しかし、それはiOS 15で変更され、これらの状況で編集される特定のビューを文脈的にマークできるようになりました。

さて、その方法を示すために、残高を表すテキストに.privacySensitiveビュー修飾子を挿入するだけです。

したがって、パスコードがロックされていない場合でも、ここでわかるように、ビューは期待どおりに残高をレンダリングします。

しかし、デバイスをロックすると、残高がマスクされるか、または編集されます。

この修飾子は、hstacksやvstacksなどのコンテナビューを含む任意のビューに適用できることにも注意してください。

また、コンテナに適用すると、コンテナ全体が編集されます。

iOSデバイスがパスコードロックされている間、アプリが触れることができない完全なデータ保護を活用している場合、たとえば、アプリが健康データを使用していて、ウィジェットの構築をスキップしたり、ロック画面に表示しなければならないと思ったためにそれを含めることを恐れていた場合、この機能は本当にあなたのためです。

WidgetKitは、デバイスがコンテンツの完全な編集のためにパスコードロックされている場合、アクティブなタイムラインコンテンツを自動的にプレースホルダコンテンツに置き換えることができます。

また、デバイスがパスコードロックされている間は、更新を保留することもできます。

これは、ここにリストされているデフォルトのデータ保護資格を採用する場合、すべて可能です。

あなたのタイムラインデータは、あなたの希望に応じて、デバイス上のそのデータクラスに保存されます。

私たちはここであなたのデータのプライバシーを真剣に受け止めています。

最後に、場所の関連性について話したいと思います。

アプリのようなウィジェットは、現在の物理的な場所のコンテキスト情報、または単に何らかの形でユーザーに関連する場所を提供することもできます。

アプリケーションが位置情報を正常に使用する場合は、ウィジェットも使用する必要がある可能性があります。

ウィジェットはホーム画面とMacの通知センターで複数のインスタンスを持つことができるので、Intentsの力で天気ウィジェットで行うのと同じように、現在の場所を使用することに加えて、ウィジェットに事前に選択され、検索可能な場所を提供することを検討してください。

さて、ウィジェットで現在の場所を取得するには、必要な手順はほんのわずかです。

まず、Info.plistでNSWidgetUsesLocationキーを指定する必要があります。

これにより、ウィジェット拡張機能から位置情報を使用することをシステムに知らせます。

次に、ウィジェット拡張機能のTimelineProviderからのこの時間を除いて、通常どおりCLLocationManagerを使用してください。

粗い場所を解決するのが速く、超正確な場所を必要としない場合、より良いユーザーエクスペリエンスをもたらす可能性があるため、ウィジェットが必要とする解像度を検討してください。

一般的に、要求された場所が正確であればあるほど、解決に時間がかかります。

最後に、CLLocationManagerのisAuthorizedForWidgetUpdates APIを使用して、ウィジェットが位置情報の更新を許可されているかどうかを確認できます。

これにより、ユーザーがウィジェットに位置情報を使用する許可を与えたかどうかがわかります。

許可といえば、ウィジェットの場所の許可をより詳細に見て、どのように機能するかを見てみましょう。

ウィジェットの権限は、通常、そのアプリコンテナと共有されます。

ここでは、設定アプリから利用可能な場所のアクセス許可のリストを見ることができます。

ユーザーが「アプリの使用中」を選択した場合、ウィジェットのコンテナアプリがユーザーにとってフォアグラウンドである場合、またはナビゲーションセッション中など、アプリが使用中であると考えるその他の状況でのみ、ユーザーの位置がウィジェットで利用できます。

ユーザーが「アプリまたはウィジェットの使用中」を選択した場合、場所は「アプリの使用中」で以前と同じように利用できますが、ウィジェットに固有の追加手当があります。

これにより、ウィジェットのアクセス許可は、ウィジェットが最後に表示されてから最大15分後に場所を受信できます。

そして、これら2つのアクセス許可のいずれかを設定して場所を解決できない場合は、代替コンテンツ、利用可能な場合は潜在的に以前のコンテンツ、または単に場所を解決できなかったことを示すことを検討してください。

ユーザーが許可に「常に」を選択した場合、ウィジェットは常に場所にアクセスするための利用可能な許可を持っています。

最後に、カスタマイズ可能なウィジェットの構築について話しましょう。

ユーザーがウィジェット体験をパーソナライズするための手段として、サイズ、種類、構成について話します。

現在、ウィジェットにはさまざまなサイズがあります。

また、ユーザーがウィジェットを配置する際に選択できるように、できるだけ多くのサイズをサポートすることをお勧めします。

デバイス間のサイジングには小さな差異があり、可能であればシステム標準のパディング、余白、テキストスタイル、テキストサイズを使用するのが最善であることを忘れないでください。

さて、このiPadを見ると、それは本当にコンテンツショーケースに変身します。

明らかでない場合は、iPad専用の新しいサイズがiOS 15に追加され、私たちはそれをエクストララージと呼んでいます。

あなたがそれをよりよく見ることができるようにここにあります。

それは大きなウィジェットと同じ高さですが、iPadで利用可能なさらに多くのコンテンツを紹介するためにより広いです。

そして、ウィジェットに追加する方法は次のとおりです。

ここでは、すでにsystemLargeファミリーをサポートしている既存のウィジェット設定に追加しました。

デフォルトでは、ウィジェットの設定でサポートされているファミリーを指定しない場合、iOS 15 SDK以降でビルドすると、新しいサイズが自動的にサポートされます。

パーソナライゼーションの次の軸はウィジェットの種類です。

ウィジェットの種類は、データやコンテンツに異なる視点を提供します。

だから、あなたのアプリでどのようなウィジェットが最も理にかなっているかを考えてください。

これらを説明する最善の方法は、実際には例です。

これは時計の例です。

左側には、単一の都市の時刻を追跡する都市ウィジェットがあり、右側には、同じビューで多くの異なる都市を収容できる世界時計ウィジェットがあります。

これは株式からの別の例です。

左側には、特定の株式（この場合はApple）の株価を示す株式シンボルウィジェットがあり、右側には概要ウィジェットがあります。

概要ウィジェットには、ユーザーの株式アプリに反映された一連の株式が表示されます。

では、これらのさまざまな種類のウィジェットをどのように公開しますか?

まあ、複数の種類のウィジェットを公開するのは超些細なことです。

以前の株式の例を使用して、左上にシンボルウィジェットと概要ウィジェットがあります。

これらを公開するには、WidgetBundleオブジェクトに異なるウィジェット設定を返し、WidgetBundleに@main属性を含めるだけです。

それはとても簡単です。

ウィジェットがバンドルで定義されている順序も非常に重要であることに注意してください。

この順序は、ウィジェットがウィジェットギャラリーにどのように表示されるかを反映しています。

したがって、リストされている最初のウィジェットがヒーローのユースケースであることを確認してください。

最後に、アプリがインストールされると、ウィジェットの可用性を動的に公開したり、動的に撤回したりすることはできません。

したがって、時間の経過とともにウィジェットのサポートの周りにいくつかの注意と思考を適用する必要があります。

カスタマイズ性の最後の軸は、設定です。

また、ウィジェットは、静的構成とインテントベースの構成の2つのタイプをサポートしています。

静的ウィジェット構成は、ウィジェットインスタンスごとに同じコンテンツを配信します。

以前の株式概要の例を覚えていますか？

まあ、ユーザーのデバイス上の異なる場所にいても、それぞれがまったく同じコンテンツを表示します。

静的ウィジェットは非常にシンプルで、ユーザーから設定や設定を取らないため、エレガントなウィジェット定義です。

一方、Intentウィジェットの設定は、各インスタンスにユーザー設定のコンテンツを配信します。

右側のこれらのストックシンボルウィジェットをチェックしてください。

このユーザーは多くの異なるインスタンスを設定し、それぞれが異なる株式を紹介しています。

さて、これはかなり甘いものです。

また、ユーザーはこれらすべてをホーム画面のウィジェットのスタックにまとめて、スペースを節約することもできます。

では、これらはユーザーによってどのように設定されているのか、あなたは尋ねるかもしれません。

さて、ユーザーの観点から、システムは周囲のすべてのUIピースを提供します。

そして、インテントをサポートする編集モードでウィジェットをタップすると、設定プラッターが表示されます。

ユーザーが設定できるIntentのパラメータのリストを表示します。

そして、この例では、シンボルが追跡するための単一のパラメータがあり、その値は現在、アップル株の文字列AAPLです。

これで、ユーザーがパラメータをタップすると、入力コントローラがユーザーから入力を収集するように見えます。

そして、完了すると、ウィジェットは自動的に更新されます。

今、インテントでできるカスタマイズがたくさんあります。そして、WWDC 2020からの素晴らしい話があります。インテント設定が必要な場合は、すぐに始めるのを手伝います。

それまでの間、インテントに基づくウィジェットのコーディングと静的設定の違いを簡単に強調しましょう。

静的構成は本当にシンプルです。

標準のTimelineProviderでStaticConfigurationオブジェクトをインスタンス化するだけです。

それをインテント構成と対比しましょう。

ここで異なるのは、StaticConfigurationがIntentConfigurationに置き換えられ、TimelineProviderがIntentTimelineProviderに置き換えられることです。

これらのそれぞれには、インテントをサポートするためにわずかに変更されたインターフェイスがあり、タイムラインに入力するときにユーザー設定のインテントを受け取ることができます。

サポートされているさまざまなデータタイプの概要や設定UIからどのように見えるかなど、ウィジェットのインテントの作成と設定に関するより詳細な概要については、WWDC 2020の「ウィジェットに構成とインテリジェンスを追加する」トークをご覧ください。

最後に、優れたウィジェットがタイムラインエントリをどのように使用し、リロードポリシーをマスターし、プレゼンテーションや潜在的に物理的な環境に適応するかを見直しました。

ユーザーにダイナミックでカスタマイズ可能な体験を提供するために、さまざまなサイズ、種類、構成を提供する計画を立ててください。

ありがとうございます。