10114

♪ベース音楽の演奏♪

♪

ロス・ルボー:こんにちは、WWDC21へようこそ。

私の名前はロス・ルボーで、StoreKitチームのエンジニアです。

今日はStoreKitについて話します。これは実際には、クライアント側のコードを実装し、アプリ内購入用のサーバーを構築し、顧客をサポートし、払い戻しを処理するのに役立つように設計された3つのセッションの1つです。

このセッションはMeet StoreKit 2で、他の2つのセッションはWWDC21で見つけることができます。

このセッションでは、クライアント側の機能と実装に焦点を当てます。

では、始めましょう!

StoreKitはiOS 3で導入されて以来、あなたとあなたのビジネスにとって素晴らしい機会を生み出しました。

今日、それは4つのAppleプラットフォームに存在し、ゲームからニュースアプリ、インディーズタイトルから国際的なヒットまで、すべてをサポートしています。

長年にわたり、Xcodeでのオファーコード、ファミリー共有、StoreKitテストなどの優れた機能を導入してきました。

しかし、今年、私たちは最初に戻ることにしました。

今日は、StoreKit 2をご紹介できることを嬉しく思います!

StoreKit 2は、iOS、macOS、tvOS、watchOSでアプリ内購入を操作するための、モダンで柔軟なSwift APIの新しいセットです。

私たちは、Swiftファーストの考え方でStoreKitを新たに見てきました。

私たちは、シンプルでありながら強力なAPIを作成するために、非同期/待機パターンを使用したSwift並行性など、最新の言語機能のいくつかを採用しました。

また、アプリ内購入取引を大幅に更新し、作業がはるかに簡単になり、より多くの情報と高いセキュリティも提供しました。

また、ビジネスの成長に使用できるより深い洞察を提供するために、サブスクリプション専用のより強力なAPIを追加しました。

StoreKit 2 APIは、現在存在するのと同じStoreKitフレームワーク内にあり、すべてのAPIを置き換えるのではなく、コアなアプリ内購入体験に焦点を当てています。

新しいStoreKit 2 APIは、製品、購入、トランザクション情報、トランザクション履歴、サブスクリプションステータスの5つの主要な分野で構成されています。

今日は、これらの各分野の概要を説明し、同僚のJakobが、対応するStoreKit 2 APIを実際のコードで使用する方法を紹介します。

まず、StoreKitの構成要素である製品と購入から始めましょう。

StoreKit 2製品構造体は、慣れ親しんだStoreKit製品オブジェクトのスーパーチャージバージョンです。

まず、製品タイプや拡張サブスクリプション情報など、追加データを追加しました。

StoreKit 2では、顧客があなたの紹介オファーの対象となるかどうかを調べるなど、簡単に行うことができます。

また、StoreKit 2製品を新機能と前方互換性のあるものにしています。

これは、BackingValueと呼ばれるラッピングタイプを追加することで達成しました。これにより、製品を直接サブスクリプト化することで、製品に含まれるデータを取得できます。

これは、将来的に製品にデータを追加すると、古いバージョンのStoreKit 2を搭載したオペレーティングシステムを実行しているSDKやデバイスでも、StoreKit 2で常にアクセスできることを意味します。

これは、最新の機能を使用して、顧客ベースのより大きなセクションに新しい機能を提供できることを意味します。

StoreKit 2では、製品タイプ自体の静的関数を呼び出すことで製品をリクエストします。

これは、既存のSKProductsRequestと同様に、App Storeから製品メタデータを要求します。

しかし、新しいSwift並行性非同期/待機パターンのおかげで、StoreKit 2製品リクエストには1行のコードしか必要ありません。

同様に、StoreKit 2で製品を購入することは、もう1つの簡単な1行のタスクです。

購入は現在、製品タイプのインスタンスメソッドです。つまり、取得したばかりの製品を取り、直接購入を呼び出すことができます。

購入方法もasync/awaitを使用するため、コード内でインラインで購入結果が得られます。

今、私たちはすべての購入が同じではないことを知っています。

デフォルト設定を超えて購入行動を変更したい場合、StoreKit 2には購入オプションがあります。

購入オプションは、購入の単一のプロパティを記述するアイテムです。

購入オプションは、購入方法に渡すセットに構成できます。

StoreKit 2には、数量やプロモーションオファーなどの購入オプションが含まれています。

そして、StoreKit 2では、アプリアカウントトークンと呼ばれる新しいオプションを追加しています。

アプリアカウントトークンは、どのアプリのユーザーアカウントがトランザクションを開始し、完了したかを追跡する方法です。

これは、アプリが所有するアカウントにリンクできる、生成する不透明なトークンです。

唯一の要件はUUID形式に準拠することであるため、アプリアカウントトークンを生成するのは簡単です。

購入時にアプリアカウントトークンを購入オプションとして送信すると、このトークンはその購入の取引情報に返されます。

アプリアカウントトークンは、デバイス間でもトランザクション情報に永遠に残ります。

アプリが独自のアカウントシステムをサポートしている場合、購入に使用されたApple IDやデバイスに関係なく、各アプリ内アカウントが行った購入を追跡するのに役立ちます。

それで、私たちはApp Storeから製品を入手し、購入を開始することについて話しました。その購入が完了するとどうなりますか?

ご想像のとおり、StoreKitは暗号署名された情報とともに成功したトランザクションを返します。

聞き覚えがありますよね?

さて、StoreKit 2は、アプリ内購入取引にこれまでで最大のアップデートをもたらしています。

まず、StoreKit 2はすべてのトランザクションに個別に署名されたオブジェクトを提供します。

それだけでなく、StoreKit 2から、アプリ内購入トランザクション情報は、JSONという非常に一般的で使いやすい形式で提供されるようになりました。

また、安全な暗号署名がStoreKit購入の重要な部分であることを知っているので、現在、JSON Web Signatureと呼ばれるウェブ全体で使用されている共通の標準を使用しています。

さらに、署名されたオブジェクトに含まれるすべての情報は、ネイティブのStoreKit APIを通じて利用可能になり、アプリのコードでこのデータを簡単に操作できるようになります。

実際、それがどれほど簡単かをお見せします。

これは、実際のコードでこれらのAPIをデモンストレーションしたJakobです。

ヤコブ・スワンク:こんにちは、私はヤコブです。

私はStoreKitチームのエンジニアです。

今日は、アプリでStoreKit 2を起動して実行するのがいかに簡単かをお見せできることに本当に興奮しています。

右側には、私が構築しているポケットカーというアプリがあります。

このセッションのリソースセクションでこのアプリのサンプルコードをダウンロードし、それに従うことができます。

このアプリには2つの主要なビューがあります。

私の集めた車の眺めと私の店の眺めがあります。

お店に行きましょう。

現在、販売可能な商品がないので、私の店は空っぽです。

私は先に進んで、今それらを実装するつもりです。

すぐに起動して実行するために、私はXcodeでStoreKitテストを使用しています。

これにより、App Store Connectで製品を定義する前に、ストアを構築してテストすることができます。

Xcodeプロジェクトでは、販売したい製品を定義するStoreKit設定ファイルをすでに作成しました。

これは、私がStoreKitに使用していたのと同じ設定ファイルです。何も変更したり移行したりする必要はありません。

ここには、すべての製品識別子を含むplistもあります。

アプリに組み込まれたリソースファイルとして含まれているので、実行時に使用できます。

これらの製品を店舗に表示するには、まず表示したい製品識別子のセットを使用して製品リクエストを行う必要があります。

StoreKit 2では、Product構造体で静的メソッドを呼び出すだけでこれを行うことができます。

App Storeから製品を受け取ったら、タイプ別に分けたいです。

製品タイプは、App Storeサーバーで定義されているタイプのプロパティを提供するようになったため、StoreKit 2で簡単にこれを行うことができます。

私のアプリでは、燃料、車、ナビゲーションパッケージの3種類の製品を販売しています。

燃料は消耗品です。一度使用すると、なくなってしまうので、すべての消耗品を燃料アレイに入れます。

車は非消耗車です。

車を購入すると、私はそれを永遠に所有します。

だから、私はすべての非消耗品を車のアレイに入れます。

ナビゲーションパッケージは、3つのレベルのサービスを備えたサブスクリプション製品です。

私の顧客は一度に1つのレベルのサービスを購読することができ、定期的に請求されます。

また、サービスレベルを変更したい場合は、いつでもアップグレードまたはダウングレードできます。

App Storeはサービスレベルごとに製品を返すので、すべての自動更新サブスクリプションをサブスクリプション配列に入れます。

また、各タイプ内の製品を、最低から最高までの価格で並べ替えたいです。

私のアプリを実行して、私がこれまでに何をしたかを確認しましょう。

今、私は店に移動します。

うわー！

以前、私の店は空いていましたが、今では私のすべての製品が展示されてかなり素晴らしく見えます。

たった1行のコードで、App Storeからアプリの製品をリクエストすることができ、その後、受け取ったメタデータのみに基づいてそれらの製品をグループ化してソートすることができ、ストアUIを簡単に構築することができました。

今、私の製品は素晴らしく見えますが、購入ボタンをタップしても何も起こりません。

それは、私の店での購入方法が何もしないからです。

StoreKitで購入を開始する必要があります。

製品の購入方法を呼び出すだけで、これを行うことができます。

ロスが述べたように、StoreKit 2はSwiftの新しい並行性機能を使用するためにゼロから構築されました。

これにより、私のアプリは、私のコードを読みやすくするために、その購入の結果を購入して処理するためのコードを同じコンテキスト内で保持することができます。

購入が完了すると、PurchaseResultが返されます。

このPurchaseResultは、購入が成功したかどうか、またはユーザーが購入をキャンセルした、または購入が親からの追加の銀行の検証または承認を必要とするなど、他のエラーのない状態で完了したかどうかを知らせます。

各ケースを処理するために、私はそれらを切り替えるだけです。

PurchaseResultが成功状態にある場合、検証結果も得られます。

検証結果には、検証済みと未検証の2つのケースが含まれています。

StoreKit 2では、トランザクションタイプには、署名されたトランザクションを表すJWSペイロードが含まれています。

私のアプリがStoreKit 2からトランザクションを受信するたびに、トランザクションは、ペイロードがこのデバイス用の私のアプリのApp Storeによって署名されているかどうかを確認するための検証プロセスを通過しています。

あなたはそれを正しく聞きました。

StoreKit 2はあなたのために取引の検証を行います。

もちろん、検証結果をどのように処理するかは、完全に私と私のビジネスのニーズ次第です。

私のアプリでは、StoreKitから受け取ったこの取引が確認されていることを確認します。

私の店では、VerificationResultに使用できるcheckVerifiedメソッドを作成します。

結果が未確認の場合、私は自分のfailedVerificationエラーをスローして、アプリの他の部分に警告します。

結果が確認されたら、トランザクションのラップを解除して発信者に返します。

これで、購入結果にこのcheckVerifiedメソッドを使用できます。

最後に、取引が確認されると、ユーザーにコンテンツを配信します。

ユーザーがコンテンツを取得したら、StoreKitにトランザクションを完了するように指示する必要があります。

その後、UIが更新されるように、それを返却する必要があります。

私のアプリには、私が維持しているアカウントデータベースがあります。

App Storeで署名されたトランザクションを取得したときに、この情報をアプリが常に利用できるように、アプリの現在のログインユーザーをStoreKitの購入に含めたい。

ログインアカウントのトークン化されたバージョンを使用してappAccountToken購入オプションを作成し、そのオプションを購入方法に渡すことで、これを行うことができます。

わかりました。

購入方法の実装の準備が整いました。

私のアプリをもう一度実行しましょう。

今、私たちは私の店に戻って、私はかなり冒険的な気分です。

だから、私はいつもバイクが欲しかったので、バイクを購入するつもりです。

購入が適切に開始されたことを示すStoreKitからの支払いシートがあります。

タップして購入を確認します。

その後、StoreKitは購入が成功したことを示すアラートを表示します。

そのアラートを却下した後、購入ボタンが緑色のチェックマークに変わり、アプリが取引を信頼し、バイクが配達されたことを示しています。

ここで注意したい重要なことがもう1つあります。

前に言ったように、顧客はアカウントで追加の検証を行う必要があるか、購入が完了する前に親の承認が必要になることがあります。

このような場合、product.purchase()から受け取った購入結果は保留状態になります。

つまり、顧客がアカウントの確認を完了した後、または親が承認した後、私のアプリは完了した購入を反映するようにUIを更新する必要があります。

これらのトランザクションの更新を聞くには、トランザクションタイプの静的プロパティを反復する必要があります。

このプロパティは無限の非同期シーケンスです。

つまり、キャンセルするか、forループから抜け出すかを選択するまで、StoreKitから入ってくるトランザクションの更新を反復し続けることを意味します。

ここでは、ストアが割り当て解除されたときに更新リスナーを明示的にキャンセルするために使用できるタスクハンドルを返すデタッチタスクを作成しています。

StoreKit 2から受け取るすべてのトランザクションと同様に、ユーザーにコンテンツを配信する前に、検証結果が検証されているかどうかを確認したい。

以前に定義したcheckVerifiedメソッドを使用できます。

そして、購入応答と同様に、確認済みのトランザクションを取得したら、ユーザーにコンテンツを配信する必要があります。

そしてもちろん、私はいつも取引を終える必要があります。

アプリが起動したらすぐにトランザクション更新リスナーを開始し、1つも見逃さないようにすることが非常に重要です。

アプリの起動の直後に起こる、私の店が作成されたらすぐにこれを行うつもりです。

アップデートリスナーをテストするために、Xcodeテスト環境でAsk To Buyを有効にして、保留中の購入応答をシミュレートします。

これを行うには、StoreKit設定ファイルを選択し、[エディタ]メニューで[購入依頼を有効にする]を選択します。

私のアプリをもう一度実行して購入しましょう。

今回は、支払いシートで確認した後、購入を完了するために許可を求める必要があるというStoreKitからの新しいアラートが表示されます。

先に進んでAskをタップします。

購入応答は、保留中の状態で私のアプリに返されます。

購入を承認するには、XcodeトランザクションマネージャーでStoreKitテストを開き、右上隅の[承認]ボタンをクリックします。

すごい！

トランザクションを承認した直後に、アップデートリスナーは検証結果を受け取り、UIはすぐに承認された購入を表示するように変更されました。

今、私はクルーズする真新しい標準的な5人乗りを持っています。

製品をリクエストし、購入を開始し、さまざまな購入結果に対応し、トランザクションの整合性を確認し、保留中の取引の更新をApp Storeから受け取るのがいかに簡単かを示しました。すべてStoreKit 2を使用します。

それでは、ロスに戻って、ユーザーの取引履歴とサブスクリプションステータスの操作について紹介しましょう。

ロス：うわー！これらの新しいAPIが動作しているのを見るのはかなり驚くべきことです。

そして、自動検証、これ以上何が欲しいですか?

それは何ですか?

あなたは暗号が大好きで、それでも自分でデータを検証したいですか?

心配しないでください。

StoreKit 2の自動検証はセキュリティの水準を上げますが、独自の検証を完全に置き換えるものではありません。

いつものように、セキュリティは強さ、時間、複雑さのスペクトルにあります。

検証に関するスクープを少し後でお伝えします。

まず、私と同じくらいStoreKit 2の取引に興奮しているなら、私たちがあなたに彼らと一緒に働くための多くの新しい方法を提供していると聞いて気に入るでしょう。

ユーザーのトランザクション履歴に完了したトランザクションを照会するための新しいAPIセットを追加します。

StoreKit 2では、1回のAPI呼び出しでユーザーの過去のすべてのトランザクションにアクセスできます。

また、製品の最新のトランザクションにアクセスすることもできます。

したがって、サブスクリプションの最新の更新だけを見たい場合は、できます。

そして、あなたが知る必要がある一番のことは、ユーザーが今アクセスするために支払った製品であることを知っています。

そこで、私たちはその情報をCurrentEntitlementsと呼ばれる単一の関数にまとめました。

現在の資格には、ユーザーのトランザクション履歴にあるすべての非消耗品と、現在アクティブなすべてのサブスクリプショントランザクションが含まれています。

これにより、ユーザーがアプリで支払ったすべてのロックを解除するために必要なすべての情報が揃っています。

そして、これはユーザーが今すぐアクセスする必要があるもののみを表すため、取り消されたトランザクションは応答に含まれません。

トランザクション履歴の永続的な部分ではないため、消耗品も含まれていません。

今、あなたは「待ちきれない!」と考えているに違いない。

いつ私のアプリでこれらの呼び出しを開始できますか?

さて、StoreKit 2では、ユーザーがこれまでに完了したすべてのトランザクションは、あなたがそれを要求するとすぐにあなたのアプリで利用可能になります。

これは、ユーザーが新しいデバイスにアプリをインストールすると、アプリを初めて開いたときにどの製品にアクセスする権利があるかを知ることができることを意味します。

さらに、取引履歴はユーザーのデバイス間で自動的に更新されます。

顧客が1つのデバイスで購入すると、アプリはインストールされている他のすべてのデバイスで購入を見ることができます。

実際、別のデバイスでの購入時にアプリが実行されている場合は、新しいトランザクションについて通知されます。

ヤコブは、アプリが起動したらすぐに取引に耳を傾けることが重要であり、これが真実であるもう一つの理由であると述べました。

したがって、これはすべて、アプリが新しいデバイスに再インストールまたはダウンロードされたときに、ユーザーが完了したトランザクションを復元する必要がないことを意味します。

すべてがStoreKitによって自動的に取得され、最新の状態に保つ必要があります。

しかし、人々は何百万もの場所で何百万もの方法でAppleデバイスを使用しています。

まれに、ユーザーがトランザクションを持つべきだと思っているが、それが表示されない場合は、App Storeの同期APIを使用できます。

これにより、すべてのStoreKit 2トランザクションがすぐに再同期されます。

これはrestoreCompletedTransactions APIの代替品であり、ユーザーが同期を開始できるUIをアプリに提供する必要があります。

しかし、StoreKit 2の自動同期のおかげで、ユーザーが手動で同期を開始する必要があることは非常にまれです。

自動同期は、ほとんどのケースをカバーする必要があります。

ユーザーが手動同期を開始する必要がある場合は、アカウントを認証する必要があります。

このため、このAPIはユーザーの入力に応じてのみ使用してください。

最後に、StoreKit 2 APIを使用して行われたすべてのトランザクションは、元のStoreKit APIで利用可能であり、その逆も同様です。

したがって、アプリに既存のトランザクションがある場合は、使用を開始するとすぐにStoreKit 2 APIでそれらを見ることができます。

元のStoreKit APIで行われた新規購入は、StoreKit 2 APIを介してすぐに利用可能になり、StoreKit 2で行われた購入は、更新されると統一されたレシート内でも利用可能になります。

取引履歴に加えて、StoreKit 2は、ユーザーのサブスクリプションステータスに関する詳細情報を取得する方法も追加しています。

サブスクリプションステータスには3つの部分があります。

1つ目は最新の取引です。

これにより、このサブスクリプションで発生した最後のトランザクションにアクセスでき、先ほど話した最新のトランザクションに電話した場合と同じです。

2つ目は更新状態です。

これは、サブスクリプションの現在の状態を伝える列挙です。

今、サブスクリプションで何が起こっているのかを知りたい場合は、この値を見てください。

現在購読されているか、期限切れか、猶予期間内かなどを教えてくれます。

私たちは、この値からアプリのロジックを簡単にするために、あなたに見るための単一の場所を提供するように設計しました。

そして、サブスクリプションステータスの最後の部分は更新情報です。

ここでは、ユーザーのサブスクリプションに関するすべての詳細を確認できます。

このデータは実際にトランザクションなしで変更される可能性があるため、トランザクション情報にないあらゆる種類の情報が含まれています。

たとえば、更新情報では、自動更新ステータスを確認できます。これは、ユーザーがこのサブスクリプションの自動更新をオンまたはオフにしているかどうかを示します。

自動更新が設定されている製品IDを確認することもできます。

したがって、ユーザーが最近サブスクリプションをダウングレードした場合は、ここでそれを見ることができ、より高い層にとどまるためのウィンバックオファーを提示する機会として利用できるかもしれません。

サブスクリプションがすでに有効期限が切れている場合は、更新情報を使用して有効期限の理由を確認できます。

そして、完全な更新情報には、これらすべてのデータと、さらに別の重要な機能があります。

そうです、すべての暗号愛好家、更新情報はJWSを使用して署名されています!

取引情報と同様に、更新情報はサービスのロックを解除し、マーケティングの決定を下す上で重要な部分です。

だから、私たちはあなたにそれが有効であり、Appleから直接であることを知る自信を与えています。

そして、私が今あなたの頭の中を駆け巡っていると確信している質問に答えるために、はい、StoreKit 2は自動的に更新情報を検証します。

サブスクリプションステータスAPIについて知っておくべき最後の1つは、ステータスの配列を返すことです。

これは、場合によっては、ユーザーが同じ製品に複数のサブスクリプションを持つことができるためです。

たとえば、ユーザーが製品を購読し、ファミリー共有を通じてサブスクリプションを受け取る可能性があります。

配列をチェックして、彼らが受ける資格のある最高レベルのサービスが何であるかを確認する必要があります。

今、私はそれをヤコブに返して、あなたのアプリコードでこれらのトランザクション履歴とサブスクリプションステータスAPIで動作するようにどのように見えるかをお見せします。

ヤコブ:ありがとう、ロス。

私が取り組んできたアプリに戻り、ロスが先ほど話した新しいトランザクション履歴とサブスクリプションステータスAPIを使用するように更新しましょう。

以前に購入したオートバイにはグリーンチェックがなく、店舗ビューから移動した後、標準の5人乗りにもグリーンチェックはありません。

ユーザーとして、私はすでに購入したものがわかりません。

これはStoreKit 2で簡単に解決できる問題です。

いつでも、私のアプリはどの製品が購入されたかをStoreKitに照会できるので、アプリのUIを常に最新の状態に保つことができます。

私のStore.swiftファイルでは、isPurchasedメソッドは現在falseのみを返します。

Transaction.latest(for:)への簡単な呼び出しでそれを修正しましょう。

次に、製品識別子を渡して、最新のトランザクションを取得します。

このStoreKitメソッドは、トランザクションがStoreKit 2の検証チェックを通過したことを知らせる別の検証結果を返します。

トランザクションが検証されていることを確認し、以前に書いたcheckVerifiedメソッドを使用してラップを解除します。

次に、失効日がnilに等しいことを確認することで、アプリが返金されたトランザクションのコンテンツを配信しないことを確認します。

また、期間の途中で顧客がより高いレベルのサービスにアップグレードしたサブスクリプションでは、isUpgradedフラグがtrueに設定されます。

私のアプリが顧客が購読している最高レベルのサービスを提供していることを確認したいので、isPurchasedメソッドはアップグレードされたトランザクションを無視する必要があります。

サブスクリプション製品の場合、トランザクションタイプはストーリーの一部のみを伝えます。

取引日とサブスクリプションの有効期限に加えて、次の更新日がいつなのか、顧客がサブスクリプションの自動更新をオフにしたかどうか、または次の更新期間が購読しているサービスのレベルを変更するかどうかも知りたいです。

これらすべての情報を取得するために、StoreKit 2はサブスクリプションステータスAPIを提供しています。

私のSubscriptionsView.swiftファイルでは、updateSubscriptionStatusメソッドは、StoreKitからサブスクリプションステータスを取得し、ユーザーに表示する責任があります。

私のサブスクリプション製品はすべて同じグループに属しているため、それらのいずれかを使用してグループの現在のステータスを取得できます。

お店から最初のサブスクリプション商品を選ぶだけです。

製品を入手したら、サブスクリプションからステータスプロパティを取得できます。

それはとても簡単です。

ロスが述べたように、ユーザーが家族によって共有されているサブスクリプションを持っている間、ユーザーは自分の個人的なサブスクリプションを支払う可能性があります。

したがって、statusプロパティは、各サブスクリプションのすべてのステータスを含む配列を返します。

今、彼らは個人的にプロティアを購読している間、標準ティアを彼らと共有することができます。

ユーザーがアクセスできる最高レベルのサービスを受けられるようにしたいので、各ステータスを反復します。

次に、ステータスの有効期限が切れているか取り消されているかを確認します。

これらのケースを無視して、ユーザーに何も表示したくない。

他のすべてのケースについては、newalInfoを取得し、店舗のcheckVerifiedメソッドを使用して検証されていることを確認します。

更新情報を確認したら、サービスレベルを以前の製品と比較します。

このチェックでは、サブスクリプションステータスに対応する製品を取得し、以前の製品と比較され、より高い階層の場合は、新しいサブスクリプションにhighestStatusとhighProductを設定します。

すべてのステータスを確認し、最高レベルのサービスを決定したら、ビューのステータスと現在のサブスクリプションを設定します。

今すぐ構築して実行しましょう。

私の店舗ビューでは、以前に購入した製品には、すでに所有していることを示す緑色のチェックマークが表示されており、再度購入する必要はありません。

サブスクリプション製品の1つを購入するとどうなるか見てみましょう。

購入を確認すると、ステータスがストアに表示されます。

StoreKit 2に組み込まれたAPIを使用して、購読しているものと、サブスクリプションがいつ更新されるかをユーザーに知らせることができます。

さて、このマイカーズビューはどうですか?

購入したすべての製品が表示されるはずですが、現在は空です。

これを埋めるために、私はすべての製品を反復し、それぞれの最新のトランザクションを取得し、トランザクションの有効期限と返金されたかどうかを確認することができますが、それは多くのように聞こえます。

ありがたいことに、StoreKit 2のパワーと新しいシンプルで便利なAPIを使用して、currentEntitlementsと呼ばれるすべてのユーザーの有効なトランザクションを取得できます。

マイカーズビューでは、ビューがロードされたときに購入した製品をリフレッシュするこの方法があります。

トランザクションの更新と同様に、現在の資格を反復します。

しかし、トランザクションの更新とは異なり、現在のエンタイトルメントの非同期シーケンスは有限であるため、forループで永遠に待つことはできず、ユーザーがより多くの購入を行うにつれて新しいエンタイトルメントを提供します。

資格ごとに、他のすべての取引と同様に検証結果を確認したいです。

それらが検証されたら、元の製品リクエストで行ったのと同じように、productTypeプロパティを切り替えて、資格を異なる配列にフィルタリングします。

現在の資格は、非消耗型および自動再生可能な製品のトランザクションのみを返します。

他の製品タイプを無視してswitchステートメントを完成させ、Swiftコンパイラを幸せに保つことができます。

トランザクションを取得したら、関連する製品をUIに表示する必要があります。

非消耗取引の場合、この取引に一致する製品識別子を車の製品配列で検索します。

同様に、自動更新可能なトランザクションと一致するようにサブスクリプション製品配列を検索します。

もう一度実行して、私のUIをチェックしてみましょう。

今、マイカーズビューに入ると、購入したすべてのものが見えます。

私の車はすべて上部にグループ化されており、私のサブスクリプションは以下です。

今、私のアプリは完全に機能するストアを持っており、それは素晴らしく見えます!

そして、トランザクション履歴とサブスクリプションステータスAPIを使用して、ユーザーが見るUIについてアプリで情報に基づいた決定を下す方法です。

では、JSON Web Signatureオブジェクトについてより深く話すRossに戻りましょう。

ロス：素晴らしいデモをありがとう、ヤコブ。

新しいトランザクションとサブスクリプションAPIがどのように役立つかを本当に見ることができます。

StoreKit 2がセキュリティのためにJWSを使用する2つの方法を見たので、私はそれを詳しく見て、あなた自身の検証を行う方法を約束しました。

JSON Web Signatureは3つの部分で構成されています。

1つ目は、オブジェクトに関するメタデータを含むヘッダーです。

これには、署名に使用されるアルゴリズムや、署名の検証に使用される証明書を見つける場所などの重要な情報が含まれています。

StoreKit 2は現在、CryptoKitでSwiftでネイティブにサポートされているECDSAアルゴリズムを使用しています。

証明書の場合、StoreKit 2はx5cヘッダーを使用します。これは、証明書チェーン全体がJWSデータに含まれていることを示します。

これは、これらのJWS署名を検証するためにインターネット接続が不要であることを意味します。

JWSデータの次の部分はペイロードです。

これは、トランザクションID、製品ID、購入日などの主な情報です。

署名を検証したら、トランザクションまたはサブスクリプションについて知りたいすべてのデータを読み取るのがここです。

そして、JWSデータの最後の部分は署名そのものです。

これは、ヘッダーとペイロードの両方を使用して生成されます。

JWS署名の検証は、標準の十分に文書化された部分であるため、独自の実装を書くことに興味がある場合は、元のソースに直接行くことをお勧めします。

このセッションに関連するリソースに、このドキュメントへのリンクを含めました。

JWSデータから署名を検証したら、署名された情報がアプリと現在のデバイスに有効であることを確認するために、さらにいくつかのことを行う必要があります。

まず、署名された情報ペイロードに存在するバンドルIDが、アプリのバンドルIDと一致していることを確認する必要があります。

セキュリティを強化するために、API呼び出しに頼るのではなく、アプリのバンドルIDをアプリのどこかに埋め込み、その値を使用してペイロードのバンドルIDと比較することをお勧めします。

そして、あなたがすべき最後のことは、デバイスの検証チェックを実行することです。

これにより、署名された情報が、現在使用しているデバイスに対して実際に生成されたことが保証されます。

StoreKit 2 API AppStore.deviceVerificationIDを使用して、現在のデバイス検証識別子を取得します。

次に、署名された情報からデバイス検証ノンスを取り、StoreKitから受け取ったばかりのデバイス検証識別子を追加します。

この値に対してSHA384ハッシュを実行し、結果を署名された情報からデバイス検証フィールドと比較します。

それらが一致する場合、このデバイスに対して署名された情報が生成され、署名された情報の検証が完了します。

最後に注意すべきことは、これらの新しいJWSオブジェクトはアプリ内購入専用であるということです。

したがって、アプリの領収書を検証する必要がある場合は、既存のAPIとプロセスを使用する必要があります。

そしてもちろん、これらの新しいJWSオブジェクト用の新しいApp StoreサーバーAPIを提供しているので、サーバー上で直接取得して検証することができます。

さて、私たちが今日あなたに紹介するのと同じくらいStoreKit 2に会うことに興奮していたことを願っています。

StoreKit 2は、より多くの情報を提供し、これまで以上に使いやすい新しいAPIで、アプリ内購入をさらに良くしています。

これには、各トランザクションの新しいJSONベースの情報オブジェクトと、ネイティブコードでトランザクションの詳細と過去のトランザクションデータを提供するAPIが含まれます。

それを新しいサブスクリプションステータスAPIと組み合わせると、StoreKit 2はアプリ内購入の豊富な可能性を解き放ちます。

アプリ内購入の詳細については、サーバーサイドのコーディングと顧客サポートのために、これらの他のセッションを見ることをお勧めします。

ヤコブと私は、StoreKit 2を紹介できることに興奮しています。

WWDC21にご参加いただきありがとうございます!

♪