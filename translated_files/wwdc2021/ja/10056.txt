10056

こんにちは、私の名前はニルス・ベックです。「M1を搭載したMac上の素晴らしいiPadとiPhoneアプリの資質」へようこそ。

100万以上のiPadとiPhoneアプリがすでにMac App Storeで入手可能です。

macOS Big Surでの体験は素晴らしく、macOS Montereyでさらに改善しました。

このビデオでは、いくつかのiOS APIを対応するMac機能にマッピングする方法、M1でMacでアプリを輝かせるのに役立ついくつかの一般的なベストプラクティス、macOS Big SurソフトウェアアップデートとmacOS Montereyで行った改善について議論し、Mac App Storeの展開の考慮事項で締めくくります。

M1を搭載したMac上のiPadとiPhoneアプリは、既存のアプリのリーチをMacに拡大する最も簡単な方法です。

これは、iOS App Storeに提出および承認された未変更のiPadまたはiPhoneアプリで、Mac App Storeを通じてM1 Macを持っている人に提供されます。

これを可能にするために、私たちは互換性に重点を置いています。

システムAPIは、可能な限り自然なMacと同等のものにマッピングされます。

私たちの目的は、あなたが何も変更を加えることなく、Macでスムーズなアプリ体験を確保することです。

そして、ほとんどの既存のアプリはうまく機能します!

これには、小さなiPhoneユーティリティから最先端のiPadゲームやProアプリまで、あらゆるものが含まれます。

さまざまな拡張機能もサポートされています。

たとえば、共有拡張機能、WidgetKitウィジェット、写真編集拡張機能、VPNネットワーク拡張機能、オーディオユニットなどです。

したがって、既存のiPadまたはiPhoneアプリは、箱から出してすぐにMacですでにうまく機能する可能性が非常に高いです。

もちろん、テキストインタラクション、コピー&ペースト、Macメニューバーなど、すべての基本的な機能をサポートしていますが、バックグラウンドアプリの更新、ユーザー通知、カメラアクセス、Siriの意図など、多くの高度な機能もあります。

これらのトピックの多くは、ビデオ「AppleシリコンMacのiPadとiPhoneアプリ」で議論されているので、詳細についてはそれをチェックしてください。

また、アプリがMacが提供するものをさらに活用したい場合は、アプリのMac Catalystバージョンを構築することを検討してください。

それについては、ビデオ「優れたMac Catalystアプリの資質」と「Mac Catalystの新機能」で詳しく知ることができます。

さて、先ほど述べたAPIのいくつかについて詳しく調べてみましょう。

あなたはすでにiPadとiPhoneであなたのアプリを素晴らしいものにするためにこれらを使用している可能性があり、私たちはMacで同じ素晴らしい機能をシームレスに提供するためにそれらをブリッジしました。

当然のことながら、テキストフィールドへのテキスト入力やUIKeyCommandキーボードショートカットにMacキーボードを使用できます。

しかし、より多くの制御が必要で、独自のキープレス処理を書きたい場合は、UIResponderのUIPress APIでそれを行うことができます。

すべてのMacには物理的なキーボードが搭載されているため、iPadとiPhoneで物理的なキーボードのサポートを追加するのに時間がかかったアプリは、同時にMacで大幅に改善されます。

次に、メニューバーについて話しましょう。

念のため、Macのメニューバーは、アプリの機能とキーボードショートカットの発見可能性を支援することを目的としています。

メニューバーの構造は起動時に決定され、その後は多かれ少なかれ一定のままである必要があります。

アイテムは追加または削除されませんが、現在適用されているかどうかに応じて、有効または無効になります。

アプリの機能を考慮して、アプリのメニューバーに自動的に入力します。

たとえば、メニュー項目を追加して、新しいウィンドウを作成したり、リッチテキストを操作したり、デバイスの向きを変更したりできます。

keyCommandsプロパティを介してUIRespondersに直接接続されているUIKeyCommandsはメニューバーには表示されませんが、適用されるたびにキーボードショートカットがメニュー項目のショートカットよりも優先されることに注意してください。

iOS 13で導入した最新のUIMenuBuilder APIをすでに使用しているかもしれません。

これにより、UIKeyCommandsにセマンティック構造が追加されます。

この構造は、キーボード付きのiPadでCommandキーを押したままに表示されるキーボードショートカットメニューに表示されます。

Macでは、ビルダーに渡されるデフォルトの構造は異なりますが、構造へのカスタマイズはメインメニューに反映されます。

UIKeyCommandsは、アクションに適用可能なターゲットを見つけるためにレスポンダーチェーンに依存しており、これはメニュー項目が有効になっているかどうかを決定します。

これについては、「iPadアプリを次のレベルに引き上げる」、「iPadキーボードナビゲーションに焦点を当てる」、「優れたMac Catalystアプリの資質」などのビデオをご覧ください。

iPadとiPhoneでドラッグアンドドロップを使用するアプリの場合、UIDragInteractionとUIDropInteractionを使用すると、これは自動的にMacにも引き継がれます。

これにより、QrafterからデスクトップにQRコードをドラッグしているこの例のように、人々はあなたのアプリと他のアプリの間でコンテンツをシームレスにドラッグすることができます。

また、UIPrintInteractionControllerで印刷するアプリの場合、コードで印刷が開始されると、これは自動的にMacの印刷ダイアログにブリッジされます。

さらに良いことに、新しいInfo.plistキー「UIApplicationSupports PrintCommand」を採用し、対応する標準印刷アクションを実装すると、PDFメニュー項目として印刷とエクスポートが自動的にアプリのメニューバーに追加されます。

この新しいAPIの詳細については、「Mac Catalystの新機能」をご覧ください。

多くのアプリは設定バンドルを使用しており、ここからMacスタイルの環境設定パネルを自動的に生成します。

設定バンドルにクレジットを入れることも一般的であり、そのようなケースを特定し、そのテキストを[About]ボックスに移動します。

しかし、Macの「情報」ボックスに表示されている内容をより詳細に制御したい場合は、バンドルにクレジットファイルを追加するオプションもあります。

Macアプリと同じように、RTF、RTFD、またはHTMLファイルを使用できます。

アプリを素晴らしいiPadアプリにするのに役立つiPad中心のAPIがいくつかあります。

これらはすべてMacで素晴らしく出くわします。

だから、素晴らしいiPadアプリを作ることで、M1を搭載したMacでもアプリをより良くすることができます。

アプリがUIApplicationSupports MultipleScenes Info.plistキーに従って複数のシーンをサポートしている場合、各シーンは別々のウィンドウに変換され、新しいシーンを作成するためにメニュー項目を自動的に追加します。

Macでは、システム全体の設定は、アプリが終了したときにすべてのウィンドウが閉じられるかどうか、または次の起動時に既存のウィンドウが復元されるかどうかを決定します。

アプリが複数のシーンをサポートしている場合は、この設定を尊重しますので、すべてのシーンが切断されたり、場合によっては状態の復元が行われなくても驚かないでください。

一方、iPadのマルチタスクサポートは、macOSでサイズ変更可能なウィンドウに自動的に変換されます。

あなたのアプリはすでにiPadで動的なレイアウト変更をサポートしているので、Macではライブサイズ変更ウィンドウを取得できます。

UIWindowSceneのminimumSizeとmaximumSize APIを使用して、許容されるシーンサイズの範囲を制限できます。

ウィンドウのサイズが変更されると、ウィンドウのシーンサイズのみが変更されることに注意してください。

一方、UIの画面サイズは引き続きデバイスサイズを報告し続けますが、この場合は変更されません。

したがって、iPadでもレイアウト計算に画面サイズを使用しないでください。そうしないと、UI要素が間違った場所になります。

アプリがデバイスの画面全体を制御することを期待している場合は、固定のシーンサイズとアスペクト比を使用します。

しかし、ウィンドウの内容は、アプリに透過的な方法で、必要に応じてスケールアップまたはスケールダウンすることができます。

また、アプリが複数のユーザーインターフェイスの向きをサポートしている場合は、自動的に追加されたメニューバーの項目を使用するか、ウィンドウの端をドラッグすることで、ウィンドウの向きを変更できます。

ここでは、メニューバーの項目を使用してChess.comアプリの向きを変更しており、ユーザーインターフェイスは各デバイスの向きを最適に活用するように適応します。

これらのマッピングやその他のマッピングは、iPadやiPhoneアプリをMacに持ち込む際の摩擦のほとんどを取り除くことができますが、Macを含むすべてのプラットフォームでアプリがうまく機能するようにするために従うべきコーディングプラクティスに触れましょう。

Appleフレームワークを使用する場合は、当社のフレームワークの文書化されていないメソッドがMacに存在しないか、いつでも変更される可能性があるため、公式にサポートされているAPIのみを使用することが重要です。

Macでは異なる可能性があるため、ファイルシステムの場所へのハードコーディングパスは避けてください。

たとえば、パスの前に「/private」または「var mobile」を付けないでください。

代わりに、適切なAPIを使用して、実行時に各パスを決定します。

同様に、直接制御下にないUIの場合、Macでは大きく異なる可能性があるため、ビューやアラートの画面上の配置、またはそのようなビュー階層の正確な設定について、コードで仮定しないことが最善です。

また、Macでは、利用可能なカメラの解像度と向きがかなり異なる可能性があることに注意してください。

たとえば、写真が撮影されたときにiPhoneアプリが縦向きの場合、結果のカメラ写真も縦向きになると予想されるかもしれません。

しかし、アプリがMacで縦向きになっている場合、これは必ずしも当てはまるとは限りません。

それがカメラの配置方法なので、代わりに横向きの画像を受け取るかもしれません。

多くのアプリとの互換性を向上させるために、すでに多くのヒューリスティックを含めています。

たとえば、背面カメラを依頼した場合でも、Macの前面カメラの写真を提供します。

しかし、AVCaptureDeviceDiscoverySessionと関連するAVFoundation APIを使用して、利用可能なカメラとその真のプロパティ（プレビューディメンションなど）に関する情報を収集すると、はるかに優れています。

そして、すべての可能な設定をUIでうまく処理することを目指すべきです。

また、一部のハードウェア機能はMacでは利用できないことを覚えておいてください。

あなたのコードは、そのような状況を優雅に処理し、代替案を提供できるはずです。

例えば、ARKitによる拡張現実はMacではサポートされていません。

ARKitがアプリのコア機能である場合、必要なデバイス機能にした可能性が高いため、アプリはMac App Storeに表示されません。

しかし、ARKitがオプション機能である場合は、適切なARConfigurationサブクラスのisSupportedプロパティをすでにチェックしている必要があります。

そして、Macや他の場所で最高の体験を得るには、この機能を持つデバイスのUIでのみ拡張現実機能を表示するようにしてください。

アプリがダイレクトマルチタッチまたはCoreMotionに依存している場合は、Macのキーボードとトラックパッドにより適した代替案をさらに提供することを検討してください。

とはいえ、この場合、Touch Alternativesが役立つかもしれません。

すぐにそれについてもっと話します。

また、CoreLocationを使用している場合、正確な位置データがなくても、アプリは引き続き使用可能である必要があります。

たとえば、Lowe'sアプリがここで行うように、代替手段として手動の位置入力を提供できます。

次に、M1を搭載したMacを最初に出荷し始めて以来、私たちが行った改善点のいくつかをいくつか見ましょう。

macOS Big Sur 11.3では、iPadとiPhoneアプリのWindowsがMacでどのように動作するかをいくつか改善しました。

アプリがマルチタスクをサポートしていないが、大きなデバイスサイズをサポートしているため、コンテンツサイズが固定されている場合は、起動時に、アプリが起動している画面に収まる最大のサポートされているデバイスサイズを選択します。

アプリに関する限り、デバイスのサイズはセッション全体で固定されたままですが、ウィンドウは利用可能なスペースをより良く利用します。

代わりに、サポートされている最小のデバイスサイズを使用するという好みもあります。

そして、先に述べたように、ウィンドウの内容は必要に応じてスケールアップまたはスケールダウンされます。

たとえば、ウィンドウをフルスクリーンにすると、元のシーンのアスペクト比を維持しながら、ウィンドウの内容は使用可能なスペースに合わせて自動的にスケールアップされます。

または、起動後にウィンドウが小さな画面に移動した場合、ウィンドウがまだ収まるように、必要に応じて自動的にスケールを下げます。

ウィンドウズーム機能を使用して、2つのズームファクターを切り替えることもできます。1つはUI要素の自然なサイズを優先し、もう1つはピクセル完璧な精度を優先します。

ここでは、この機能を使用して、Chess.comアプリの2つのズームファクターを切り替えています。

ゲームコントローラーは、ゲーム対応のすべてのプラットフォームで利用可能なGameController.frameworkを通じて、初日からサポートされています。

macOS Big Sur 11.3から、Macのキーボードとトラックパッドを仮想ゲームコントローラーとして使用できるようになりました。

したがって、実際のコントローラーが手元になくても、キーボードを使用して、ゲームがコントローラーボタンにマップするすべての機能にアクセスするのは簡単です。

そして、macOS Montereyでは、対応する環境設定パネルのこの写真に示すように、感度スライダーとポインタの非表示を追加して、これをさらに洗練しました。

このフレームワークの詳細については、「ゲームコントローラーの進歩」をご覧ください。

さらに、初日から、Touch Alternativesは、キーボードとトラックパッドを、マルチタッチ、ドラッグ、タップ、スワイプなど、Macでは使用が容易ではないいくつかのインタラクションスタイルにマッピングしています。

また、MacOS 11.3では、多くの改善を行いました。

たとえば、デバイスを仮想的に傾けることができます。

これにより、多くの追加ゲームへの扉が開かれます。

また、環境設定パネルには、キーボードとトラックパッドを介して5つのインタラクションスタイルのそれぞれにアクセスする方法を説明する便利なグラフィカル表現が含まれています。

さらに、アプリがTouch Alternativesに自動的に選択できるようにしました。

オプトインすると、この機能の発見を支援するために、最初の起動時にオンボーディングダイアログが表示されます。

グラフィックは環境設定パネルのものと似ていますが、選択したインタラクションスタイルのみを強調します。

この例では、チルトとマルチタッチのみが表示されます。

アプリがこれらのTouch Alternativesのいずれかの恩恵を受けると判断した場合、最初からアプリのTouch Alternativesを有効にする方法は次のとおりです。

「Com.apple.uikit.inputalternativ es.plist」という名前のnew.plistファイルをバンドルに追加するだけです。

次に、スニペットに表示されているキーと値を追加します。

また、必要なオンボーディングアレイには、アプリに役立つ機能のみを含めてください。

そうすれば、オンボーディングダイアログではこれらの機能のみが強調表示されます。

あなたのためにこれを実演させてください。

例えば、「Assoluto Racing」と呼ばれるこのiPadゲームは、M1を搭載したMacで変更されずに実行されています。

このアプリは最初からTouch Alternativesを自動的に有効にするので、最初の起動時に、このオンボーディングダイアログはキーボードコントロールを表示します。

しかし、まず、ソフトウェアキーボードを見せて、ウィンドウをフルスクリーンにしましょう。

コンテンツは画面に合わせてスケールアップされ、iPadのアスペクト比を維持しています。

フリースタイルドリフトのために「空港」レベルに向かいましょう。

このアプリはCoreMotionを使用しているので、iPadではデバイスを傾けて操縦できます。

M1を搭載したMacでTouch Alternativesを有効にすると、W、A、S、Dキーは傾きをシミュレートします。

そして、ここで私はトラックパッドを使って画面上のアクセルボタンを押しながら、そのように車を制御します。

そして、これらすべてはアプリにとって完全に透明です。

私がどうするか見てみましょう。

うまくいったよ！

しかし、私は漂流スキルに少し取り組む必要があります。

macOS Montereyでは、さらに多くの改善を行いました。

Apple Payは、macOS Big SurのMac Catalystアプリケーションに導入したのと同じ強化されたクロスプラットフォームAPIを使用して、M1 MacのiPadおよびiPhoneアプリで利用可能になりました。

これは、単一の実装を使用して、Apple Payが利用可能なすべてのプラットフォームで支払いを受け入れることができることを意味します。

PKPaymentAuthorizationControllerデリゲートで「paymentAuthorizationController、didRequestMerchantSessionUpdate」デリゲートコールを実装していることを確認してください。

詳細については、ビデオ「ウォレットとApple Payの新機能」をご覧ください。

また、AVKitでフルスクリーンビデオをさらに良くしました。

AVPlayerViewとAVPlayerViewControllerは、別のウィンドウを使用して自動的にフルスクリーンでビデオを撮影できるようになりました。

これは、ウィンドウが起動時の解像度とアスペクト比に制限されているアプリでも、ビデオコンテンツに応じてMacディスプレイを最大限に活用することを意味します。

また、フルスクリーンエクスペリエンスをさらに制御する必要がある場合は、AVPlayerViewDelegateとAVPlayerViewControllerDelegateに新しいAPIを追加しました。

さらに、AVFoundationはM1を搭載したMacでHDR再生とストリーミングをサポートしています。

アプリでは、Mac固有の採用作業は必要ありません。

最後に、iPadとiPhoneアプリのAVKitコントロールは、他のMacアプリと同じように見えるようになりました。

私たちは、新しいジェスチャーをサポートするMacトラックパッドを最大限に活用しています。

詳細については、「AVKitの新機能」というビデオをご覧ください。

また、アプリがインテントフレームワークを使用してカスタムSiriKitショートカットを提供する場合、macOS Montereyでは、M1 MacのiPadおよびiPhoneアプリでサポートされるようになりました。

ショートカットの詳細については、「macOSのショートカットに会う」と「ショートカット、Siri、提案のための素晴らしいアクションをデザインする」のトークをチェックしてください。

朗報！

Mac App Storeに載るのは簡単です。

実際、ほとんどのアプリは自動的にそこにあります。

先に述べたように、ほとんどの場合、Macにいるのは理にかなっています。

結局のところ、モバイルになるように設計されたBluetoothドアロックアプリでさえ、携帯電話なしで家からロックアウトしたが、M1を手にしたMacを持っている場合に役に立つかもしれません。

したがって、以前にMac App Storeからアプリをオプトアウトしたことがある場合は、今が再考する時かもしれません。

タッチオルタナティブや強化されたフルスクリーンビデオ再生などの改善により、あなたのアプリはMacにぴったりかもしれません。

その場合は、App Store Connectの「このアプリを利用可能にする」チェックボックスに再度チェックを入れるだけで、Mac App Storeでアプリを利用できるようになります。

以前にオプトアウトしたかどうかにかかわらず、あなたのアプリがM1を搭載したMacで本当にうまく機能することを確認する必要があります。

ユーザーエクスペリエンスが基準を満たしていると確信したら、ここに示されているApp Store Connectの「互換性の確認」リンクをクリックしてください。

これにより、Mac App Storeのアプリの横に表示される「Not verified for macOS」テキストが削除され、「Designed for iPad」に置き換えられます。

アプリの買い物客は、あなたがMacであなたのアプリで良い経験を持っていることを確認するために時間をかかったというサインとしてこれを取るでしょう。

これはアプリごとに1回だけ行う必要があります。

ああ、私たちはまた、iPadとiPhoneのアプリをMac App Storeではるかに見つけやすくしました。

顧客が名前で検索すると、iPhoneとiPadのアプリタブに切り替える必要がなくなります。

Appleは、互換性に必要な推奨される最小macOSバージョンを自動的に選択し、ほとんどの場合、これは問題ありません。

しかし、まれに、カスタムmacOSの可用性でこれをオーバーライドしたいと思うかもしれません。

たとえば、ビデオアプリはBig Surで正常に動作するかもしれませんが、AVKitのフルスクリーン改善にアクセスできるようにしたい場合は、モントレー以降でのみ利用可能であると判断できます。

この場合、2つの選択肢があります。

まもなく、App Store Connectの「価格と可用性」ページで、別の最小macOSバージョンを選択できるようになります。

これは、新しいバージョンを再提出する必要がないため、すでにストアにあるアプリに最適です。

または、Info.plistでLSMinimumSystemVersionを指定し、次の更新の一部としてこの変更を送信することもできます。

これは、積極的に開発中のアプリに推奨されるアプローチです。

これは、iOSの最小システムバージョンを指定するMinimumOSVersionキーを置き換えるものではないことに注意してください。

しかし、実際には、両方のオプションはめったに必要ないはずです。

最後に、テストについて少し話しましょう。

macOSでのテストは、iPadでのテストと非常によく似ています。

すでに慣れ親しんでいるのと同じワークフローを使用できます。

Xcodeでのローカルテストでは、実行先としてMy Mac（Designed for iPad）を選択するだけで、デバッグ、単体テストなど、すべて他のデバイスと同じように機能します。

ベータテストでは、iPhoneやiPadアプリを含むmacOS MontereyのすべてのアプリにTestFlightサポートを追加したので、M1を搭載したMacを使用しているベータテスターにアプリを配布できるようになりました。

これの詳細については、ビデオ「Meet TestFlight on Mac」をご覧ください。

だから、Macへようこそ!

アプリを確認してオプトインしてください。

それは簡単です。

そして、iPadとiPhoneのアプリを改善し続けるにつれて、M1を搭載したMacでもそれらのアプリをより良くしていることを忘れないでください。

どうもありがとうございます。

[明るい音楽]。