10180

こんにちは、私の名前はタヌジャで、OSパフォーマンスチームのエンジニアです。

今日、ステファンと私は、アプリケーションのメモリの問題を検出して診断する方法について話します。

まず、アプリケーションのメモリフットプリントの影響を調べます。

次に、メモリ使用量をプロファイリングするためのツールと、遭遇する可能性のあるメモリの問題の種類について説明します。

すぐに飛び込みましょう。

あなたがすぐに尋ねるかもしれない1つの質問は、なぜ私のアプリケーションのメモリフットプリントを気にする必要があるのですか?

主な理由は、アプリのユーザーエクスペリエンスを大幅に向上させるためです。

システムには限られた量のメモリがあり、アプリのメモリ使用量を監視することで、システムがアプリを終了してそのメモリを取り戻すのを防ぐことができます。

これは、アプリがバックグラウンドでその状態を維持できることを意味します。これは素晴らしいことです。メモリへの読み込みには時間がかかり、メモリフットプリントをコンパクトに保つと、アプリケーションがメモリに残る可能性が高まり、アプリのアクティベーションが速くなるからです。

メモリ使用量を減らすと、ダイナミックでレスポンシブなエクスペリエンスも得られます。これは、ユーザーが新機能を探索する際にまさに望むものです。

アプリがメモリにロードされたものについて戦略的にすることで、アプリはユーザーがアプリと対話するときにメモリを取り戻すのを待つコストを回避できます。

メモリ使用量について戦略的であることは、アニメーションを含むビデオの読み込みなど、アプリに追加できる幅広い機能への扉を開きます。

最後に、私たちのデバイスは時間の経過とともに絶えず進化しており、新しいデバイスは以前よりも多くの物理メモリを持っています。

メモリフットプリントを削減することで、アプリは古いデバイスでも同じようにパフォーマンスを発揮し、アプリを楽しめるオーディエンスを増やします。

アプリのメモリフットプリントを監視することで、アプリはより速くアクティブ化し、より応答性が高く、複雑な機能を処理し、より幅広いデバイスでパフォーマンスを発揮します。

それでは、あなたの記憶の足跡を構成するものを見てみましょう。

アプリケーションのメモリプロファイルを分解するために使用する3つのカテゴリがあります。ダーティ、圧縮、クリーンメモリです。

これらのそれぞれに何が含まれているかを簡単に見てみましょう。

ダーティメモリは、アプリケーションによって書かれたメモリで構成されています。

また、malloc、デコードされたイメージバッファ、フレームワークを使用する場合など、すべてのヒープ割り当ても含まれます。

圧縮メモリとは、メモリコンプレッサーが圧縮した、最近アクセスされていないダーティページを指します。

これらのページはアクセス時に解凍されます。

macOSに固有のiOSでのスワップの概念がないことに注意してください。

そして最後に、私たちはきれいな記憶を持っています。

クリーンメモリとは、書き込まれていないメモリ、またはページアウトできるデータです。

たとえば、これらは、ディスク上にあるがメモリにロードされたイメージなどのメモリマップされたファイルです。

または、それらはフレームワークになることができます。

アプリケーションのメモリフットプリントを参照するとき、私たちは本当にあなたのアプリの汚れたメモリと圧縮されたメモリを一緒に話しています。

クリーンメモリはここではカウントされません。

これはあなたのメモリフットプリントの高度な理解です。

より詳細で詳細な説明については、WWDC 2018のiOSメモリディープダイブトークをチェックすることをお勧めします。

それでは、メモリフットプリントをプロファイリングするために使用できるツールを見てみましょう。

Xcodeは、開発と本番の両方のワークフローを通じて、アプリのメモリパフォーマンスを監視するのに役立つ一連のツールを提供しています。

XCTestフレームワークは、プロジェクトのユニットテストとUIテストでメモリフットプリントを直接監視するのに役立ちますが、MetricKitとXcodeオーガナイザーを使用すると、顧客から本番環境のメモリメトリクスを監視できます。

この講演の続きは、パフォーマンスXCTestsを使用する文脈で行われます。

しかし、これらの技術は依然として一般的なメモリトリアージと調査に適用されることに注意してください。

パフォーマンスXCTestsを使用すると、メモリ使用率、CPU使用率、ディスク書き込みなどのシステムリソースを測定できます。

一緒にテストの例を見てみましょう。 一緒に見てみましょう。

私が1週間で食べるものを整理するのに役立つアプリであるMeal Plannerのアプリ開発者であるとしましょう。ユーザーが自分のデバイスにレシピをダウンロードできるように追加したこの新しい食事保存機能のメモリ使用量を測定したいと思います。

パフォーマンステストでは、measures(metrics:options:block:) APIを使用しており、ターゲットアプリケーションのメモリ使用量を測定することを指定しています。

測定ブロックの本文で、アプリケーションを起動し、手動で測定APIに測定を開始するように指示し、[食事の保存]ボタンをタップします。

UIでアップデートをチェックして、レシピのダウンロードが完了するまで最大30秒待ちます。

これで、XcodeのUIで直接このテストを実行して、測定値を表示できます。

テストの横にある灰色のダイヤモンドをクリックすると、測定値にアクセスできます。

結果のポップオーバーUIには、どのメトリクスが測定されたかを示すドロップダウンがあります。

下部の棒グラフは、個々の反復の測定値を示しています。

5つの反復すべての平均が計算され、表示されます。

将来のテストと比較するためのベースラインとして、この実行の平均を設定するかどうかを決定できます。

平均が設定されたベースラインよりも大きい場合、テストの将来の実行は失敗します。

私たちは、設定されたベースラインからのこの偏差を回帰と呼びます。

回帰は、テストが合格することを確認するために、コードを停止、調査、修正する必要があることを示します。

Xcode 13では、これらのテスト回帰のトリアージに役立つ診断を収集する新機能を追加しました。

価値があると思う診断は2つあります。ktraceファイルとメモリグラフです。

Ktraceファイルは強力で汎用性があります。

一般的なシステム調査に使用したり、ヒッチを調査する際にレンダリングパイプラインに飛び込んだり、メインスレッドがブロックされ、ハングする理由を調べるなど、特定の問題に焦点を当てることができます。

これらのktraceファイルは、通常のワークフローを使用してInstrumentsで開いて分析できます。

2番目の診断は、メモリ固有の調査に最適なメモリグラフです。

メモリグラフは、Xcodeのビジュアルデバッガやさまざまなコマンドラインツールで使用できます。そのうちのいくつかは、この講演の後半で説明します。

メモリグラフは、基本的にインスタンス内のプロセスのアドレス空間のスナップショットです。

Memgraphは、各仮想メモリ領域と割り当てられた各mallocブロックのアドレスとサイズ、およびそれらの領域とブロック間のポインタを記録します。

これにより、ヒープ上の個々のオブジェクトを検査したり、リンクされたフレームワークに関連付けられたデータ領域を表示したりできます。

XCTestは、新しく割り当てられたオブジェクトのバックトレースをキャプチャするmallocスタックロギングを自動的に有効にします。

診断コレクションを有効にするには、enablePerformanceTestsDiagnosticsフラグと組み合わせてxcodebuildコマンドラインツールを使用します。

このフラグは、非メモリメトリクスのktraceコレクションとメモリメトリクスのmemgraphを有効にします。

以前に書かれたパフォーマンステストの実行が完了すると、以下がコンソールに印刷されます。

これはかなり多いですが、探すべき重要なことがいくつかあります。

最初に探すべきことは、テストに失敗したか合格したかどうかです。

この場合、テストは失敗しました。

出力はまた、回帰のためにテストが特に失敗したことを呼び出します。

私たちの新しい平均はベースラインよりも12%悪いです。

最後に、xcresultバンドルへのパスを見つけることができます。

Xcodeでxcresultバンドルを開くと、テスト名の横に上部にメモリ測定値が表示されます。

その後、テストログを展開し、下部に向かって、添付のメムグラフを見つけることができます。

ダウンロードして解凍すると、2つのmemgraphが見つかります。

これは、mallocスタックロギングを有効にするために、テストに追加の反復を追加するためです。

測定された反復の開始時にプレの接頭辞が付いた最初のメムグラフを収集し、反復の最後にポストの接頭辞が付いた2番目のメムグラフを収集します。

これにより、必要に応じて、1回の反復期間中のメモリの成長を分析できます。

Mallocスタックロギングが有効になっているktraceファイルとメモリグラフを使用すると、回帰が発生したかどうかだけでなく、なぜ回帰が発生したのかを答える準備が整いました。

同僚のステファンに渡して、収集したメモリグラフ診断を調べるときに遭遇する可能性のあるメモリの問題の種類について話します。

ありがとう、タヌジャ。みなさん、こんにちは。

私はOSパフォーマンスチームのエンジニア、ステファンです。

アプリで見つかる可能性のある一般的なメモリの問題と、それらを診断、修正、防止する方法について説明します。

リークとヒープの問題の2種類のメモリの問題について説明します。これは、ヒープ割り当て回帰とフラグメンテーションの問題に分類できます。

これは網羅的なリストではありませんが、最も一般的な問題のいくつかをカバーしています。

また、これらの問題を診断するために使用できるコマンドラインワークフローについても説明します。

コマンドラインツールのより詳細な要約については、WWDC 2018のiOSメモリディープダイブトークをご覧ください。

メモリリークについて議論することから始めましょう。

リークは、プロセスがオブジェクトを割り当て、割り当てを解除せずにオブジェクトへのすべての参照を失うときに発生します。

ここにオブジェクトグラフの例があり、灰色の矢印はオブジェクト間の参照を示します。

すべてのオブジェクトには、少なくとも1つの参照があることに注意してください。

オブジェクトAからオブジェクトBへの点線参照に注目してください。

この参照をnilに設定して削除したとしましょう。

その参照がなくなったので、オブジェクトBは漏洩しました。

それへの言及は全くありません。

それはまだ汚れていますが、プロセスにはそれを参照する方法がなく、それが終わるまでそれを解放する方法はありません。

このため、常にリークを修正する必要があります。

Swiftでオブジェクトが漏れる一般的な方法は、リテンションサイクルです。

この図では、オブジェクトAとBは保持サイクルにあります。

彼らは互いに参照しますが、どちらにも外部参照はありません。

これは、プロセスがそれらのいずれかにアクセスまたは解放できないことを意味するため、漏洩したと見なされます。

幸いなことに、Swiftのほとんどのオブジェクトは、多くのリークを防ぐSwiftの自動参照カウントシステム（ARC）によって管理されています。

安全でないポインタなど、ARCによって管理されていないオブジェクトで作業している場合は、それらへの参照を失う前に、それらの割り当てを解除してください。

ARCが管理するオブジェクトでさえ、保持サイクルの一部になりやすい。

したがって、コードに強力な循環参照を作成することは避けてください。

循環参照が絶対に必要な場合は、弱い参照はオブジェクトの割り当て解除を妨げないため、代わりに弱い参照を検討してください。

ミールプランナーアプリの例を見てみましょう。

Tanujaは、失敗したXCTestからいくつかのプレとポストのメモリグラフを送ってくれました。

すぐに、ポストメムグラフのリークを確認したいです。

これを行うには、memgraphでリークを実行します。

これは、私が持っているリークに関するいくつかの有用な情報を示しています。

出力は、合計240のリークバイトで4つのリークがあることを示しています。

さらに下には、出力には各リークのオブジェクトグラフの詳細なビューが含まれており、何がリークしている可能性があるかについていくつかの手がかりが得られます。

オブジェクトグラフの上部にはROOT CYCLEと書かれていますが、これは保持サイクルを扱っていることを意味します。

ここには便利なシンボルがいくつかあります。

この保持サイクルには、おそらく食事プランとメニュー項目のオブジェクトが含まれているようです。

XCTestsではmallocスタックロギングが有効になっているため、出力にはリークごとに割り当てコールスタックも含まれています。

これは、どのオブジェクトが漏洩したかを見つけるのに非常に便利です。

多くの場合、コードのシンボルを含むコールスタックのセクションを見つけたいと思うでしょう。

これが私のコードからのコールスタックの部分です。

漏洩した食事プランオブジェクトは、populateMealData関数に割り当てられます。

Xcodeを開いて、問題を解決できるかどうかを確認します。

これは私がリークで見たpopulateMealData関数です。

ここでは、私の保持サイクルで見た2つのオブジェクトである食事プランオブジェクトとメニュー項目オブジェクトを割り当てています。

うーん、このaddMealToMealPlan関数は少し怪しげに見えます。

見てみます。

うーん、食事プランでaddItemを呼んでいるように見えますが、メニュー項目でaddPlanも呼んでいます。

これは、プランのすべてのアイテムだけでなく、アイテムがどのプランに関連付けられているかを見ることができる機能用です。

ここ食事プランでは、addItemはメニュー項目を配列に追加し、それへの参照を保存します。

そして、このメニュー項目で、addPlanは食事プランへの参照を保存します。

だから、彼らは両方ともお互いに強い参照を持っているので、これは間違いなく保持サイクルです。

populateMealDataが終了すると、食事プランとメニュー項目オブジェクトの両方が範囲外になるため、外部参照はありません。

しかし、彼らはまだお互いを参照し、リークを引き起こします。

私はおそらく、周期的な参照なしで解決策を見つけようとするべきです。

しかし、今のところ簡単な修正として、メニュー項目を変更して、食事プランオブジェクトに弱い参照を使用します。

これは、もはや2つの周期的な強い参照を持たないため、保持サイクルを中断します。

では、ヒープ割り当て回帰にギアをシフトしましょう。

ヒープは、動的に割り当てられたオブジェクトが格納されるプロセスのアドレス空間のセクションにすぎません。

ヒープ割り当て回帰は、以前よりも多くのオブジェクトをヒープに割り当てるプロセスによるメモリフットプリントの増加です。

ヒープ回帰を減らすために、未使用の割り当てを削除し、不必要に大きな割り当てを縮小してください。

また、一度にどれだけの記憶を持っているかに注意を払う必要があります。

使用しなくなったメモリを割り当て解除し、必要になるまでメモリを割り当てるのを待ちます。

これにより、アプリのピークフットプリントが削減され、終了する可能性が低くなります。

それでは、MealPlannerアプリから失敗したXCTestに戻り、ヒープ回帰を確認しましょう。

どこを見るべきかを理解するために、プレメモリグラフとポストメモリグラフの両方でvmmap-summaryを実行して、メモリが使用されている場所の概要を把握します。

プレメモリグラフの私のフットプリントは約112メガバイトです。

そして、ポストメモリグラフでは、私のフットプリントは125メガバイトなので、それは約13メガバイトの差です。

さらに下では、出力は地域ごとに分類された私のプロセスのメモリ使用量を示しています。

これはヒープ割り当ての問題ではないかと思うので、これらの領域にはすべてのヒープオブジェクトが含まれているため、MALLOC_で始まる領域を見てみたいと思います。

タヌジャの方程式を覚えておいてください:メモリフットプリント=ダーティメモリ+圧縮メモリ。

このツールでは、「スワップ」という用語は「圧縮」を意味します。

だから、これらのコラムの中で、私は「汚いサイズ」と「スワップサイズ」だけを気にしています。

そして確かに、出力はMALLOC_LARGE領域が約13メガバイトのダーティメモリを保持していることを示しています。

それは私の回帰サイズとほぼ同等なので、間違いなくそれを調べたいです。

次のステップは、この13メガバイトの回帰にどのような種類のオブジェクトが寄与しているかを把握することです。

その情報を取得するには、投稿のmemgraphでheap -diffFromを実行します。

私はプレとポストのメムグラフを引数として渡します。

これは、ポストメムグラフヒープに存在するが、プレメムグラフヒープには存在しないオブジェクトを示しています。

上部付近では、出力は、ポストmemgraphに約13メガバイトの新しいオブジェクトがあることを示しています。

以下では、ヒープメモリはオブジェクトクラス別に分解されています。

各オブジェクトクラスについて、出力はオブジェクトの数とそれらのオブジェクトのバイト単位の合計を示します。

すぐに、私はこの「非オブジェクト」タイプの約13メガバイト分を持っていることに気づきました。

Swiftでは、これは通常、生のmallocedバイトを示します。

このタイプのオブジェクトは追跡するのが少し難しいかもしれませんが、情報を取得するために使用できるツールがいくつかあります。

まず、これらの非オブジェクトのアドレスが欲しいです。

私はそれらをつかむためにヒープアドレスを実行します。

サイズが少なくとも500キロバイトの非オブジェクトのみが欲しいと指定します。

はは。

この非物体は約13メガバイトなので、この調査の主な容疑者です。

私はその住所を手に入れて、それが何であるかについてのいくつかの手がかりを見つけることができるかどうかを確認します。

現時点ではいくつかの選択肢があります。

それぞれに状況に応じてメリットがありますので、それぞれを簡単に説明します。

私が持っている1つの選択肢は、このアドレスでリーク--traceTreeを実行することです。

これにより、このアドレスを参照するオブジェクトのツリーが表示されます。

これは、より多くの情報を入手したい特定のオブジェクトがあり、memgraphにmallocスタックロギングやMSLが有効になっていない場合に便利です。

XCTestのmemgraphは自動的にMSLが有効になっていることを覚えておいてください。ただし、そうでないmemgraphで作業している場合は、このツールを念頭に置いてください。

関連性があると思われるツリー内のオブジェクトを強調しました。

私の大きな非オブジェクトは、おそらくMKTCustomMeal PlannerCollectionViewCellのこの食事データオブジェクトと関係があります。

リーク--referenceTreeを実行することもできます。

これにより、どのオブジェクトがルートであるかを最もよく推測して、私のプロセス内のすべてのメモリのトップダウン参照ツリーが得られます。

この出力で、私のアプリでメモリが集約されている場所の感覚を得ることができます。

このツールは、私が大きな回帰を持っていることを知っているが、どの特定のオブジェクトが責任を負うのか分からない場合に非常に役立ちます。

--groupByType引数を渡して、タイプをグループ化して、出力を縮小して解析を少し簡単にすることができます。

多くの場合、回帰の大部分がこのツリー内の単一のノードの下にグループ化され、そのメモリが何であるかについての手がかりを見つけやすくなります。

繰り返しになりますが、関連するオブジェクトを示すセクションを強調表示しました。

これは私がリーク-traceTree出力で見たのと同じ食事データオブジェクトです。

出力は、この食事データオブジェクトに約13メガバイト分のメモリが割り当てられていることを示しています。

このオブジェクトがどのように割り当てられているのか知りたいです。

私のmemgraphはMSLが有効になっているので、malloc_history -fullStacksを使ってそれを理解することができます。

先ほどヒープアドレスから取得した大きな非オブジェクトのアドレスを渡します。

そして、そのアドレスでオブジェクトの割り当てコールスタックを取得します。

これは、MSLが有効になっていて、気になるオブジェクトのアドレスを持っている場合に非常に便利です。

したがって、私の食事データオブジェクトは、ここ3行目に示されているsaveMeal関数に割り当てられていたようです。

Xcodeに行って、何が起こっているのか見てみます。 様子を見ます。

これが私のカスタムセルビューコントローラー内のsaveMeal機能です。

そして、これが犯人です。

この生のバッファをここに割り当てて、食事データオブジェクトでラップしています。

このバッファを割り当てているのは、それを入力して結果をディスクに保存できるようにすることです。

ディスクへの保存が終わったら、このバッファはもう必要ありません。

では、なぜそれがくっついているのですか?

さて、食事データはクラスメンバーなので、このクラスインスタンスが存在する限り、参照は残ります。

これは、任意のセルでsaveMealを押すと、そのセルが割り当てられ、そのセルが破壊されるまで固執する大きなバッファを保持することを意味します。

私が複数の食事を保存している場合、その記憶は本当に加算される可能性があります。

では、どうすればこれを修正できますか?

1つのオプションは、saveMeal関数でmealDataを定義することですが、私はそれがクラスの他の場所で使用されていることを知っているので、私はそれをしたくありません。

もう1つの方法は、ディスクへの書き込みが終わったら、mealDataをnilに設定することです。

Swiftのデータオブジェクトは、最終的な参照を失った後にバッファを自動的に割り当て解除するのに十分賢いので、バッファはこの関数の終わりを過ぎても固執しません。

最後に、断片化について話しましょう。

iOSでページがどのように機能するかを簡単に見てみましょう。

ページは、システムがプロセスに付与する固定サイズの分割不可能なメモリの塊です。

ページは不可分であるため、プロセスがページの任意の部分に書き込むと、ページ全体が汚れていると見なされ、そのほとんどが未使用であっても、プロセスに対して課金されます。

断片化は、プロセスに100%利用されていない汚れたページがある場合に発生します。

これがどのように起こるかを理解するために、例を見てみましょう。

まず、私は3つの連続したクリーンページを持っています。

プロセスが実行されると、割り当てはこれらのページをいっぱいにし始め、それらを汚します。

オブジェクトが割り当て解除されると、図で「空きメモリ」とマークされていた空のスロットが作成されます。

しかし、これらのページはまだいくつかの割り当てられたオブジェクトがあるため、まだ汚れています。

システムは、これらの空のスロットを将来の割り当てで埋めようとします。

ここでは、右側のボックスで示された大きな着信割り当てがあります。

残念ながら、この着信割り当ては大きすぎて、私の空きメモリスロットに収まります。

空のスロットの合計サイズは十分に大きいですが、それらは連続しておらず、単一の割り当てには使用できません。

そのため、既存の空きスロットに収まらなかったため、システムは図の右側にある新しいダーティページに私の割り当てを配置しました。

空きメモリスロットは未充填のままで、断片化されたメモリと見なされます。

断片化を減らす最善の方法は、メモリ内で互いに近い同様のライフタイムを持つオブジェクトを割り当てることです。

これは、これらのオブジェクトがすべて一緒に解放されることを確実にするのに役立ち、プロセスに将来の割り当てのために作業するための連続したメモリの大きな塊を与えます。

この例では、「マイオブジェクト」とマークされたすべてのオブジェクトを手動で割り当て、同時に解放する予定です。

しかし、私はコードに注意を払わず、システムは私のオブジェクトを他のオブジェクトとインターリーブすることになりました。

さて、すべてのオブジェクトを解放すると、空きメモリのスロットが4つありますが、これらの割り当てられたオブジェクトによって分割されているため、どれも連続していません。

これにより、50%の断片化と4つの汚いページになります。

良くない。

代わりに、すべてのオブジェクトを一緒に割り当てるコードを書いたらどうなりますか?

今、それらはすべて2ページで一緒に終わります。

そして、オブジェクトを解放すると、プロセスはシステム用の2つのクリーンページを解放し、その結果、わずか2つのダーティページと0%の断片化になります。

断片化がいかにフットプリント乗数であるかに注目してください。

50%の断片化により、フットプリントが2ページから4ページに倍増しました。

ほとんどの実際のシナリオでは、いくつかの断片化は避けられません。

したがって、経験則として、約25%以下の断片化を目指します。

断片化を減らす1つの方法は、自動リリースプールを使用することです。

自動解放プールは、スコープ外になるとすぐに、その中に割り当てられたすべてのオブジェクトを解放するようにシステムに指示します。

これは、自動リリースプールで作成されたすべてのオブジェクトが同様の寿命を持つことを保証するのに役立ちます。

フラグメンテーションはすべてのプロセスで問題になる可能性がありますが、アドレス空間を断片化する可能性のある割り当てや割り当て解除がたくさんあるため、長時間実行中のプロセスは特に起こりやすい場合があります。

たとえば、アプリが長時間実行中の拡張機能を使用している場合は、これらのプロセスの断片化を必ず確認してください。

プロセスの断片化を簡単に確認するには、vmmap -summaryを実行し、出力の一番下までスクロールできます。

このセクションはmallocゾーンに分かれています。

各ゾーンには異なるタイプの割り当てが含まれています。

通常、私はDefaultMallocZoneだけを気にします。なぜなら、それは私のヒープ割り当てがデフォルトで終わる場所だからです。

しかし、このmemgraphはMSLが有効になっているので、私は実際にMallocStackLoggingLiteZoneを気にしています。

MSLが有効になっている限り、このゾーンはすべてのヒープ割り当てが終わる場所です。

% FRAG列は、各mallocゾーンの断片化のためにメモリの何パーセントが無駄になっているかを示しています。

これらの数字のいくつかはかなり大きいですが、私はMallocStackLoggingLiteZoneに集中するだけです。

これは、MallocStackLoggingLiteZoneがダーティメモリのシェアが最も大きく、合計5メガバイトのうち4.3メガバイトであるためです。

だから、今回は他のゾーンを無視することができます。

「Dirty+swap frag size」列は、各mallocゾーンの断片化によってどれだけのメモリが無駄になっているかを正確に示しています。

私の場合、断片化のために約800Kを無駄にしています。

これは多くのように思えますが、前に述べたように、いくつかの断片化は避けられません。

だから、私が25%の断片化の下に座っている限り、私はこれだけの無駄を許容できると思います。

MallocStackLoggingLiteZoneで約19%の断片化に座っているようです。

これは25%の経験則を快適に下回っているので、私は心配していません。

断片化の問題がある場合は、Instrumentsツールの割り当てトラックを使用できます。

具体的には、割り当てリストビューを見て、興味のある分野でどのオブジェクトが永続化され、破壊されたかを確認したいと思います。

フラグメンテーションの文脈では、破壊されたオブジェクトは空きメモリスロットを作成し、永続オブジェクトは残りのオブジェクトであり、ページを汚しておく責任があります。

断片化を調べているとき、両方とも調査する価値があります。

インスツルメンツツールの使用方法の詳細については、WWDC 2019の「インスツルメンツを使い始める」トークをご覧ください。

リークとヒープ回帰に対処し、フラグメンテーションが問題ではないことを確認したので、XCTestを再度実行します。

素晴らしい。

XCTestは合格し、回帰は解決されました。

メモリの問題の検出と診断について学んだので、自分のアプリに使用できるワークフローを確認しましょう。

新しい機能を追加するときはいつでも、メモリ、および/または他の提供されたシステムメトリックを監視するためのパフォーマンスXCTestを書いてください。

テストごとに、ベースラインを設定します。

次に、テストを使用して回帰をキャッチし、収集されたktraceファイルとmemgraphファイルを使用して調査します。

失敗したXCTestsのmemgraphを使用して、メモリの問題を診断してください。

最初にすべきことは、漏れがないか確認することです。

リークツールを実行し、MSLバックトレースを使用して、リークを見つけて修正します。

回帰にリークが含まれていない場合は、ヒープをチェックしてください。

Vmmap -summaryから始めて、メモリがヒープ内にあることを確認します。

もしそうなら、heap -diffFromを実行して、どのオブジェクトタイプが成長の原因かを確認します。

犯人が明らかな場合は、ヒープアドレスを使用して住所を取得します。

そうでない場合は、いくつかの手がかりについては、リーク-referenceTreeを見てください。

最後に、リーク-traceTreeおよび/またはmalloc_historyで犯人オブジェクトアドレスを調査します。

最後に、これらの記憶のベストプラクティスを念頭に置いて開発していることを確認してください。

アプリのリークをゼロにするように努めてください。

安全でないタイプで作業している場合は、割り当てたすべてのものを解放することを忘れないでください。

また、コードの保持サイクルにも目を光らせてください。

ヒープの割り当てを縮小したり、より短い期間保持したり、不要な割り当てを完全に取り除いたりするなど、ヒープの割り当てを減らす方法を見つけてください。

断片化を念頭に置いてください。

似たようなライフタイムを持つオブジェクトを隣同士に割り当てて、後で素敵で大きな空きメモリの塊を作成します。

これらのベストプラクティスとXCTestワークフローを使用すると、アプリのメモリの問題を検出、診断、修正することができます。

タヌジャと私を代表して、チューニングしてくれてありがとう。

[パーカッシブミュージック]。