10039

♪ ♪

그렉: 안녕하세요, 저는 그렉입니다.

StoreKit 테스트의 새로운 기능에 오신 것을 환영합니다.

이 세션에서 피터와 저는 StoreKit에서 인앱 구매를 테스트하는 데 사용할 수 있는 몇 가지 훌륭한 새로운 기능을 강조할 것입니다.

Xcode 14를 사용하여 인앱 구매 테스트를 간소화할 수 있는 몇 가지 방법을 살펴보는 것으로 시작하겠습니다.

다음으로, 인앱 구독 구현에서 더 많은 코너 사례를 다루기 위해 활용할 수 있는 몇 가지 새로운 기능을 살펴보겠습니다.

그리고 마지막으로, 피터는 샌드박스 테스트 환경에 대한 새로운 개선 사항을 보여줄 것이다.

우리는 도넛을 판매하는 푸드 트럭 운영자에게 강력한 기능을 제공하는 앱인 푸드 트럭과 협력할 것입니다.

저는 이미 StoreKit과 통합하여 푸드 트럭 판매 이력 기능의 정식 버전과 향상된 버전의 소셜 피드 서비스에 대한 구독을 제공합니다.

세션 내내 Xcode에서 StoreKit 테스트를 사용하여 앱의 인앱 구매 기능을 테스트할 것입니다.

WWDC 2020에서 우리는 Xcode에서 StoreKit 테스트를 도입하여 Xcode에서 직접 인앱 구매를 테스트할 수 있도록 했습니다.

올해 Xcode 14와 함께 StoreKit 앱의 테스트 수명 주기에 대한 몇 가지 업데이트를 공유하게 되어 기쁩니다.

이전과 마찬가지로, Xcode에서 StoreKit 구성 파일을 만들고 App Store Connect에서 앱을 설정하지 않고도 인앱 구매 구현 테스트를 시작할 수 있습니다.

App Store Connect에서 앱을 구성할 준비가 되면, Xcode의 StoreKit 테스트와 함께 App Store Connect에 입력한 것과 동일한 인앱 구매 제품을 사용할 수 있도록 Xcode 14에 새로운 기능을 도입합니다.

스토어에 이미 앱이 있다면, StoreKit 구성 파일을 처음부터 설정할 필요 없이 지금 바로 Xcode에서 StoreKit 테스트를 사용할 수 있습니다.

이 편리한 기능을 사용하면 인앱 구매를 한 번 구성할 수 있으며, Xcode, 단위 테스트 내부, 샌드박스 환경 및 App Store에서 출시 준비가 되었을 때 동일한 구성을 사용할 수 있습니다.

App Store Connect에서 Xcode와 제품을 쉽게 동기화할 수 있습니다.

먼저, 예를 들어 이 소셜 피드+ 구독과 같은 App Store Connect에서 제품을 구성합니다.

그런 다음 Xcode에서 동기화된 구성 파일을 만들어 제품 데이터를 Xcode에 로드합니다.

예를 들어 미국 영어 제목을 업데이트하는 등 변경하려면 App Store Connect에서 변경하고 Xcode에서 구성을 다시 동기화할 수 있습니다.

또한 동기화한 구성을 로컬 편집 가능한 파일로 변환하여 즉시 변경할 수 있습니다.

동기화된 구성을 로컬 구성으로 변환하는 것은 단방향 작업이며, 다시 동기화하려면 새 구성 파일을 만들어야 합니다.

저는 이미 푸드 트럭 앱이 제공하는 소셜 피드 서비스의 향상된 버전인 소셜 피드+의 구독 그룹을 설정하는 것으로 시작했습니다.

Xcode로 뛰어들어 Xcode에서 StoreKit 테스트와 함께 이 제품을 사용하는 방법을 살펴봅시다.

내 Mac에 푸드 트럭 프로젝트가 열려 있어.

시작하려면 파일 메뉴로 이동하여 새 파일을 만들고 StoreKit으로 필터링하고 다음을 클릭하여 새 StoreKit 구성 파일을 만들 것입니다.

Xcode 14에서 새 구성 파일을 만들 때, App Store Connect의 앱과 파일을 동기화할 수 있는 이 확인란이 표시됩니다.

로컬 파일을 만들려면, 이름을 입력하고 상자를 선택하지 않은 상태로 두세요.

동기화를 설정하려면, 확인란을 선택하고 올바른 팀과 앱이 선택되었는지 확인하기만 하면 됩니다.

원한다면, 우리는 피커 메뉴를 사용하여 다른 팀과 앱을 선택할 수 있습니다.

우리는 다음을 클릭하고, 파일을 저장할 곳을 선택합니다.

파일을 저장하자마자, 앱 내 구매 메타데이터가 App Store Connect에서 동기화되기 시작합니다.

데이터가 다운로드되는 동안, 우리는 앱에서 계속 작업하고 활동 표시줄에서 진행 상황을 추적할 수 있습니다.

동기화가 완료되면, 이 파일이 일반적인 StoreKit 구성 파일과 다르게 보인다는 것을 알게 될 것입니다.

그것은 동기화된 파일이 읽기 전용 상태에 있기 때문이다.

Xcode의 모든 데이터를 한 눈에 볼 수 있지만, 변경하려면 App Store Connect를 열어야 합니다.

저는 사파리에 소셜 피드+ 월간 제품을 가지고 있습니다.

연간 계획과 제품을 차별화하는 데 도움이 되도록 접미사를 추가하여 이 제품의 영어 제목을 업데이트합시다.

이제 이것이 업데이트 되었으니, 저장하고 Xcode로 돌아가자.

이 변경 사항을 구성 파일에 반영하려면 왼쪽 하단 모서리에 있는 이 동기화 버튼을 누르기만 하면 됩니다.

동기화가 완료되면, Xcode에 반영된 변경 사항을 볼 수 있습니다.

동기화된 파일은 읽기 전용이지만, 우리는 여전히 데이터를 로컬 파일로 복사하여 Xcode 내부에서 빠르게 변경할 수 있습니다.

구성 파일에서 항목을 복사하는 것 외에도, 동기화된 전체 파일을 로컬 편집 가능한 파일로 변환할 수도 있습니다.

동기화된 파일을 열고, 편집기 메뉴로 이동한 다음, "로컬 스토어킷 구성으로 변환"을 클릭하기만 하면 됩니다.

파일을 변환한 후에는 이 작업을 취소할 수 없다는 것을 명심하세요.

앱과 다시 동기화하려면, 새로운 StoreKit 구성 파일을 만들어야 합니다.

이 파일을 App Store Connect와 동기화하고 싶으니, 이 알림을 취소합시다.

이제 파일을 동기화했으니, 테스트 환경을 구성해 봅시다.

시작하기 위해, 우리는 계획 편집기를 열 것이다.

실행 동작을 선택하고, 옵션을 선택하세요.

옵션에서, 우리는 피커 메뉴에서 다른 StoreKit 환경 사이를 전환할 수 있습니다.

"없음"을 선택하면 샌드박스에 연결하고, "푸드 트럭"을 선택하면 Xcode 환경에 연결할 것입니다.

현재 테스트 요구에 따라 환경 간에 전환하는 것은 매우 쉬우며, 두 환경 모두 이제 정확히 동일한 제품 및 구독 메타데이터를 사용할 것입니다.

지금은 동기화된 구성 파일을 선택합시다.

이제 Xcode에서 StoreKit을 설정했으니, 테스트를 시작합시다.

SwiftUI 앱을 사용하고 있기 때문에, Xcode에서 바로 구독 스토어를 미리 볼 수 있습니다.

Xcode 14부터 StoreKit 구성 파일의 제품은 SwiftUI 미리보기에 바로 로드됩니다.

이를 통해 실제 인앱 구매 데이터를 사용하여 멋진 매장 사용자 인터페이스를 매우 쉽게 구축하고 테스트할 수 있습니다.

우리 제품에 대한 자막을 포함하여 제품 옵션에 세부 사항을 추가해 봅시다.

우리는 제품의 현지화된 설명이 포함된 텍스트 보기를 추가할 것입니다.

그리고 App Store Connect에서 설정한 설명과 함께 미리보기 업데이트를 즉시 시청하세요.

내 생각에 이건 지금 훨씬 더 좋아 보이는 것 같아.

이제 UI가 양호한 상태입니다. iPhone에서 앱을 실행하고 기능 테스트를 시작합시다.

Xcode 14에는 StoreKit 트랜잭션 관리자에 몇 가지 강력한 새로운 도구가 있습니다.

앱이 실행되면, 디버그 표시줄에서 구매 아이콘을 눌러 거래 관리자를 열 수 있습니다.

오른쪽에는 거래에 대한 모든 세부 사항을 시각화할 수 있는 새로운 거래 검사관이 있습니다.

이 도구는 인앱 거래의 상태를 이해하는 데 유용할 수 있다.

예를 들어, 우리는 소셜 피드+ 구독이 만료된 날짜와 다가오는 갱신에 대한 정보를 볼 수 있습니다.

우리는 또한 제품, 구독 그룹 또는 구독 제안에 대한 구성 파일로 이동할 수 있습니다.

이 구독 그룹 옆에 있는 점프 버튼을 클릭하기만 하면 됩니다.

그리고 우리는 구성 파일에서 소셜 피드+로 바로 옮겨졌다.

이 검사관은 우리가 더 고급 테스트 사례를 살펴볼 때 세션 후반에 우리를 도울 것이다.

우리는 또한 지금 거래를 필터링할 수 있으며, 이는 이러한 모든 소셜 피드+ 갱신으로 거래 목록을 탐색하는 데 정말 유용합니다.

우리 앱에서 당신은 우리가 연간 판매 이력 기능에 접근할 수 있다는 것을 알게 될 것입니다.

우리는 이러한 모든 구독 갱신을 가지고 있기 때문에 어떤 거래가 우리에게 그 기능을 받을 자격이 있는지 말하기가 어렵습니다.

우리는 ID를 입력하기 시작하여 제품에 대한 거래를 쉽게 찾을 수 있습니다...

그리고 자동 완성 메뉴에서 제품 ID 필터를 선택하세요.

우리는 또한 구매일별로 필터링할 수 있으므로, 지금 하고 있는 구매에만 집중할 수 있습니다.

소셜 피드+ 구독이 만료되었기 때문에, 앱에 들어가서 다시 구독합시다.

이제 구독을 확인했으므로, 새로운 거래가 나타나는 것을 볼 수 있습니다.

우리는 방금 App Store Connect에서 제품과 구독을 동기화하고, StoreKit 구성을 SwiftUI Previews와 사용하고, Transaction Manager의 새로운 도구를 활용하여 Xcode에서 인앱 구매 테스트를 향상시키는 몇 가지 방법을 살펴보았습니다.

이제, 우리는 고급 구독 사례를 다루기 위해 Xcode의 몇 가지 새로운 기능을 사용하여 Food Truck의 인앱 구매 기능을 계속 테스트할 것입니다.

먼저, 우리는 사람들이 푸드 트럭에서 구매한 것에 대한 환불을 요청할 수 있도록 환불 요청을 테스트할 것입니다.

다음으로, 우리는 소셜 피드+ 구독자에게 프로모션을 제공하기 위해 제안 코드를 테스트한 다음, 푸드 트럭의 사용자 인터페이스에서 가격 인상을 처리하는 것을 살펴보고, 마지막으로, 청구 재시도 및 유예 기간을 지원하여 소셜 피드+ 비자발적 이탈을 줄일 것입니다.

환불 요청 테스트를 시작하려면 앱에서 이 지원 보기로 이동하여 환불할 최근 거래를 선택할 수 있습니다.

이것에 대한 코드는 간단하다.

방금 refundRequestSheet 보기 수정자를 추가했고, 환불 버튼을 누르면 isPresented Binding을 true로 전환할 것입니다.

이제, 이것이 실제로 실행되는지 봅시다.

바인딩이 사실일 때, 환불 요청 시트가 우리의 보기 위에 나타납니다.

Xcode 환경에서 테스트할 때, 우리가 선택한 문제는 StoreKit API의 RevocationReason과 1:1에 해당합니다.

"개발자 문제"를 선택하고 "환불 요청"을 누르자.

App Store에서 환불 요청은 처리하는 데 시간이 좀 걸리지만, Xcode 또는 Sandbox로 테스트할 때 환불 요청은 즉시 거래를 환불합니다.

거래 관리자에서, 우리는 이 업데이트된 거래에 대한 검사관을 보고 우리가 방금 선택한 해지 이유와 해지 날짜를 볼 수 있습니다.

거래 관리자에서 환불 버튼을 클릭하기만 하면 환불을 테스트할 수 있습니다.

환불 요청 API는 푸드 트럭을 사용하는 사람들에게 훌륭한 고객 지원을 제공하는 데 도움이 됩니다.

이제 Xcode에서 환불 요청을 테스트하는 방법을 살펴보았으니, StoreKit을 사용하여 환불된 거래를 처리할 수 있는 몇 가지 방법을 살펴보겠습니다.

거래를 환불한 후, 업데이트된 거래 값은 Transaction.updates 시퀀스에서 방출될 것이다.

우리는 revocationDate와 revocationReason 속성을 사용하여 이러한 환불된 거래를 감지할 수 있습니다.

Xcode의 환불 요청 시트에서 해당 옵션을 선택하여 두 가지 취소 이유 사례를 쉽게 테스트할 수 있습니다.

그것이 Xcode에서 환불 요청 시트를 테스트하는 방법입니다.

이것은 Xcode 환경이나 샌드박스를 사용할 때 iOS와 macOS에서 작동합니다.

Xcode로 테스트하려면, iOS 또는 iPadOS 15.2 이상을 실행하려면 iPhone 또는 iPad가 필요합니다.

Mac에서 Xcode로 테스트하려면, macOS 12.1 이상이 필요합니다.

이제, 구독 제안 코드 테스트를 살펴봅시다.

이를 위해, 우리는 로컬 StoreKit 구성 파일을 사용할 것입니다.

코드에 대한 새로운 제안을 하려면, 우리는 구독을 선택하고, 제안 코드 테이블 아래의 "+"를 누릅니다.

그러면 우리는 우리의 제안을 구성할 수 있다.

우리는 이것을 "무료 달"이라고 명명하고 한 달 동안 무료 제안을 할 것이다.

App Store Connect와 마찬가지로, 우리는 어떤 고객이 자격이 있는지, 그리고 입문 제안이 이 제안으로 교환될 수 있는지 여부를 선택합니다.

지금은 기본 설정을 그대로 두자.

이제 코드가 구성되었으므로, 우리는 "완료"를 누를 것이다.

물론, App Store Connect와 동기화하는 경우 구성된 제안이 이 표에 자동으로 표시됩니다.

이제 우리의 제안이 구성되었으니, 앱에서 상점 보기로 이동해 봅시다.

구독 제안을 사용하기 위해 보기 하단 근처에 이 버튼을 추가했습니다.

Xcode에서 스토어 뷰의 구현을 열면, 제안 코드를 구현하는 것은 우리의 뷰에 offerCodeRedemption 수정자를 추가하고 누군가가 버튼을 탭할 때 isPresented 바인딩을 true로 전환하는 것만큼 쉽습니다.

이게 어떻게 작동하는지 보자.

버튼을 누르면, 상환 시트가 앱 위에 나타납니다.

App Store에서 사람들은 App Store Connect에서 생성하는 제안 코드를 입력할 수 있지만, Xcode에서는 테스트 경험이 훨씬 더 간소화됩니다.

우리는 그들이 잠금 해제하는 구독에 따라 그룹화된 구성 파일에 코드에 대한 모든 제안 목록을 가지고 있습니다.

교환하려면, 우리가 방금 만든 제안을 탭하고, 교환 버튼을 누르자.

지불 시트가 나타나고, 우리는 당신이 소개 제안으로 갈 때 코드에 대한 제안이 지불 직후에 시작되는 것을 볼 수 있습니다.

구독 후, 우리는 확인 화면을 받게 될 것이며, 이제 시트를 닫고 앱이 소셜 피드+에 대한 액세스를 잠금 해제하는지 확인할 수 있습니다.

이 새로운 거래에 대한 검사관을 살펴보면, 소개 제안이 현재 적용되는 것을 볼 수 있습니다.

제안은 당신이 가는 대로 지불하기 때문에, 갱신 섹션은 우리가 입문 제안의 갱신을 두 번 더 받을 수 있다는 것을 보여줍니다.

그 후, 우리가 방금 사용한 무료 월 코드.

그러면, 표준 구독은 무기한 갱신될 것이다.

검사관은 여러 제안과 같은 복잡한 시나리오에도 불구하고 구독 상태에 무슨 일이 일어나고 있는지 매우 분명하게 합니다.

우리는 방금 로컬 StoreKit 구성에서 제안 코드를 구성하는 방법과 iPhone에서 교환을 테스트하는 방법을 살펴보았습니다.

오퍼 코드는 미래와 기존 구독자에게 유연한 프로모션을 제공할 수 있는 좋은 방법이며, 이제 푸드 트럭에서 오퍼 코드를 사용하는 것이 그 어느 때보다 쉬워졌습니다.

이제, StoreKit을 사용하여 이러한 제안을 처리하는 방법을 살펴봅시다.

코드를 교환한 후, Transaction.updates와 Status.updates 시퀀스는 모두 새로운 값을 방출할 것이다.

거래 값의 offerType 속성을 확인하여 현재 거래에 적용된 제안이 있는지 확인할 수 있습니다.

우리가 방금 offerType의 가치를 살펴본 경우, 구독자가 코드에 대한 제안으로 입문 제안을 사용할 수 있도록 허용했기 때문입니다.

renewalInfo 값에서, 우리는 다음 갱신에 어떤 종류의 제안이 나타날지 확인하기 위해 offerType 속성을 확인할 수 있습니다.

우리가 방금 살펴본 경우, 우리는 당신이 제안할 때 급여를 사용했기 때문에 초기 가치가 도입될 것으로 기대할 수 있습니다.

두 번의 구독 기간이 지나면 코드 제안이 쌓여 있기 때문에 값이 코드로 전환되는 것을 볼 수 있습니다.

offerType이 코드인 경우, offerID 속성을 사용하여 코드에 적용된 제안의 참조 이름을 얻을 수 있습니다.

그것이 Xcode에서 코드에 대한 제안을 테스트하는 방법입니다.

Xcode 13.3에서 시작하는 코드에 대한 제안을 구성하고, iOS 15.4 이상을 실행하는 iPhone 및 iPad에서 테스트할 수 있습니다.

이제 푸드 트럭에서 코드 작업에 대한 제안을 확인했으므로, 앱이 소셜 피드+의 가격 인상을 어떻게 처리하는지 테스트해 봅시다.

가격 인상을 테스트하는 것은 Xcode에서 정말 간단하다.

시작하기 위해, 우리는 월간 소셜 피드 구독 가격을 인상할 것입니다.

이 단계는 선택 사항입니다.

가격을 동일하게 두고 여전히 가격 인상을 시뮬레이션할 수 있습니다.

거래 관리자로 돌아가서, 구독에 대한 최신 거래를 선택하고 도구 모음에서 "가격 인상 동의 요청"을 누르기만 하면 됩니다.

우리는 거래 관리자에서 우리의 거래가 현재 "가격 인상 보류 중" 상태에 있다는 것을 알 수 있으며, 장치를 보면 가격 인상에 대한 동의를 요청하는 시트가 앱 위에 나타나는 것을 알 수 있습니다.

이 시트는 코드를 추가하지 않고 자체적으로 나타나지만, 우리는 새로운 메시지 API를 활용하여 동작을 사용자 정의했습니다.

코드에서 메시지 API와 어떻게 통합되었는지 살펴봅시다.

여기에 메시지 시퀀스를 반복하는 루프가 있으며, 가격 인상과 같은 메시지를 받으면 도넛 편집기와 같은 민감한 보기가 없는지 확인하십시오.

그렇지 않으면, 우리는 DisplayMessageAction을 사용하여 메시지를 표시할 것입니다.

도넛 편집기가 표시되면, 우리는 메시지 값을 잡고 도넛 편집이 끝난 후 표시할 것입니다.

테스트로 돌아가자.

App Store에서 기존 구독자는 가격 인상을 취소하거나 동의하기로 결정할 때까지 다른 시간에 여러 가격 인상 메시지를 받을 수 있습니다.

Xcode에서, 우리는 이 메시지가 언제 오는지 완전히 통제할 수 있다.

거래 관리자에서 버튼을 누를 때마다, 거래가 이미 가격 인상 상태에 있더라도 다시 메시지를 받게 될 것입니다.

이제 우리는 연기 논리가 실제로 작동하는지 테스트할 수 있다.

그래서 내가 도넛 편집기를 열게...

그리고 시트를 다시 열려면 메시지를 보내세요.

시트는 아직 나타나지 않지만, 도넛 편집기를 떠나면 시트가 예상대로 나타납니다.

우리는 가격 인상을 수락하거나 시트에서 구독을 취소할 수 있지만, 실제로 사용자는 이메일과 같은 외부 소스를 통해 가격 인상에 응답할 수 있습니다.

이것을 시뮬레이션하기 위해, 우리는 거래 관리자의 승인 및 거절 버튼을 사용할 수 있습니다.

도넛 편집 경험이 너무 좋았기 때문에, 나는 거래 관리자에서 승인을 눌러 새로운 가격에 동의할 것이다.

Xcode에서 StoreKit을 사용하면 가격 인상과 같은 복잡한 코너 케이스를 매우 원활하게 테스트할 수 있습니다.

이제 가격 인상을 시뮬레이션하는 방법을 살펴보았으니, StoreKit을 사용하여 앱에서 가격 인상을 처리하는 방법을 살펴봅시다.

가격 인상 상태를 테스트할 때, 상태 업데이트 순서는 모든 상태 변경과 함께 새로운 값을 방출할 것이다.

RenewalInfo 값의 priceIncreaseStatus 속성을 확인하여 앱에서 이러한 업데이트를 감지할 수 있습니다.

고객이 가격 인상으로 인해 구독을 취소하는 경우, expirationReason 속성에서 didNotConsentToPriceIncrease를 확인하여 이를 감지할 수 있습니다.

우리는 또한 테스트 가격 인상에 대한 단위 테스트를 작성할 수 있다.

우선, 대화상자를 비활성화하면 앱 위의 가격 인상 UI를 실제로 표시하지 않고도 테스트할 수 있습니다.

구독을 구매한 후, requestPriceIncreaseConsentForTransaction API를 사용하여 구독에 대한 최신 거래 ID를 전달하여 프로세스를 시작할 수 있습니다.

테스트 거래가 가격 인상을 기다리고 있는지 확인하기 위해, 우리는 isPendingPriceIncreaseConsent 속성을 확인할 것입니다.

마지막으로, 우리가 테스트하는 것에 따라, 우리는 consentToPriceIncreaseForTransaction 또는 declinePriceIncreaseForTransaction을 호출하여 앱이 완성된 가격 인상 사례에 어떻게 반응하는지 확인할 수 있습니다.

그것은 모두 가격 인상을 테스트하기 위한 것이다.

가격 인상은 모든 플랫폼에서 Xcode 13.3으로 테스트할 수 있습니다.

가격 인상 메시지는 iOS 15.4 이상에서만 테스트할 수 있습니다.

마지막으로, 구독 청구 재시도와 유예 기간을 살펴봅시다.

청구 재시도는 만료된 신용 카드와 같이 구독을 갱신하려고 할 때 오류가 발생한 상태입니다.

App Store에서, 청구 재시도하는 동안 App Store는 문제를 해결하고 구독을 복구하려고 시도할 것입니다.

청구 재시도 상태가 시작될 때 제한된 시간 동안 구독을 계속 사용할 수 있는 유예 기간을 선택적으로 활성화할 수 있습니다.

Xcode에서 테스트할 때 이것을 시뮬레이션하는 방법을 보여드리겠습니다.

구독 갱신 시 청구 문제를 시뮬레이션하기 위해, 테스트 중인 StoreKit 구성에서 "편집자" 메뉴를 열고 "갱신 시 청구 재시도"를 활성화합니다.

저는 푸드 트럭이 청구 유예 기간을 지원하기를 원하므로, 메뉴에서도 "청구 유예 기간"을 활성화합시다.

우리는 또한 구독률의 속도를 높일 것이므로, 상태가 어떻게 변하는지 볼 수 있습니다.

먼저 소셜 피드+를 구독합시다.

이제, 갱신할 시간이 될 때까지 기다리자.

거래가 만료되면, 우리가 먼저 청구 유예 기간 상태에 들어간다는 것을 알아두세요.

우리는 거래 검사관을 보고 각 주가 끝날 시간을 볼 수 있다.

청구 유예 기간이 방금 만료되었고, 이제 우리는 표준 청구 재시도 상태에 있습니다.

언제든지 "거래 문제 해결" 버튼을 사용하여 청구 오류 수정을 시뮬레이션할 수 있습니다.

문제를 해결하는 것을 시험해 봅시다.

이제 문제가 해결되었으므로, 우리는 새로운 거래를 얻는다.

"갱신 시 청구 재시도"가 활성화되어 있는 한, 각각의 새로운 거래는 계속해서 청구 재시도에 들어갈 것이므로, 우리가 원하는 만큼 이 테스트를 반복할 수 있습니다.

청구 재시도 및 유예 기간을 적절하게 처리하는 것은 비자발적 이탈을 줄임으로써 구독자를 유지하는 데 중요합니다.

우리는 방금 Xcode로 이러한 상태를 시뮬레이션하는 것이 얼마나 간단한지 살펴보았으므로, 이제 StoreKit을 사용하여 처리하는 방법을 살펴봅시다.

청구 재시도 및 유예 기간 상태가 변경됨에 따라, 상태 업데이트 순서는 새로운 값을 방출할 것이다.

우리는 푸드 트럭에서 청구 유예 기간을 제공하기 때문에, 가입자가 유예 기간에 있는 동안 소셜 피드+에 대한 액세스를 제공해야 합니다.

갱신 정보에서 구독자의 유예 기간이 gracePeriodExpirationDate 속성을 얼마나 오래 사용해야 하는지 알 수 있습니다.

청구 재시도를 확인하려면, isInBillingRetry를 확인하기만 하면 됩니다.

우리는 또한 상태의 국가 재산으로 이 주들 중 하나를 쉽게 감지할 수 있다.

고객이 이러한 주 중 하나에 있는 것을 본다면, 청구 문제를 해결하기 위해 App Store의 딥 링크로 안내할 수 있습니다.

현재 자격 API를 사용하는 경우, 유예 기간에 있는 동안 만료된 구독에 대한 거래를 받게 됩니다.

또한 StoreKit 테스트 세션에서 billingGracePeriodIsEnabled 및 shouldEnterBillingRetryOnRenewal을 설정하여 단위 테스트에서 청구 재시도 및 유예 기간을 제어할 수 있습니다.

앱이 구독이 청구 재시도에 들어간다는 것을 알게 된 후, 테스트 거래의 hasPurchaseIssue 속성은 사실일 것입니다.

다양한 상태 업데이트를 기다리고 예상대로 앱 업데이트를 주장한 후, 우리는 거래 방법에 대한 문제 해결을 사용하여 구독을 복구하는 App Store를 시뮬레이션할 수 있습니다.

청구 재시도 및 유예 기간은 모든 플랫폼에서 Xcode 13.3 이상에서 테스트할 수 있습니다.

세션 후반부에서, 피터는 iOS와 iPadOS 16의 샌드박스에서 이러한 상태를 테스트하는 방법에 대해 더 자세히 설명할 것이다.

우리는 환불 요청부터 청구 재시도 및 유예 기간에 이르기까지 고급 테스트 사례를 다루었습니다.

이러한 사례 중 일부를 지원하기 위해 새로운 StoreKit API를 사용하는 방법에 대한 자세한 내용은 "인앱 구매의 새로운 기능"을 확인하세요.

이것은 올해 Xcode에서 StoreKit 테스트의 새로운 기능에 대한 간략한 개요였지만, 우리는 모든 것을 다루지는 않았다.

새로운 구독 갱신율이 있으며, Xcode에서 StoreKit 2 인앱 관리 구독 시트를 테스트할 수 있으며, StoreKitTest를 사용하여 SKAdNetwork 구현에 대한 단위 테스트를 작성할 수 있습니다.

자세한 내용은 "SKAdNetwork의 새로운 기능"을 확인하세요.

이제 피터는 올해 샌드박스 테스트 환경의 새로운 것을 안내할 것입니다.

피터: 고마워, 그렉.

안녕하세요, 저는 App Store 서버 엔지니어인 Peter입니다.

우리는 Xcode의 StoreKit 테스트를 통한 새로운 기능이 더 복잡한 인앱 구매 구현을 테스트하는 데 어떻게 도움이 될 수 있는지 보았습니다.

우리는 당신의 피드백을 지속적으로 듣고 있으며, 많은 사람들이 인앱 구매와 서버 구현을 테스트하기 위해 App Store 샌드박스 환경에 의존한다는 것을 알고 있습니다.

온라인 테스트 환경에서 앱과 서버를 더 쉽게 테스트할 수 있도록 샌드박스에서 만들고 있는 몇 가지 새로운 개선 사항을 공유하게 되어 기쁩니다.

우리는 샌드박스 Apple ID 생성, App Store Connect API 및 청구 실패 시뮬레이션에 대한 개선 사항을 도입할 것입니다.

샌드박스 환경을 사용하려면, 먼저 App Store Connect에서 샌드박스 Apple ID를 설정해야 합니다.

샌드박스 테스터 목록을 사용자 및 액세스 페이지의 탐색 모음으로 옮겼다는 것을 알게 될 것입니다.

여기서, 우리는 플러스 버튼으로 새로운 테스터를 만들 수 있습니다.

우리는 새로운 테스터 창에서 여러 필드를 제거하여 생성 프로세스를 간소화했습니다.

우리는 이제 최소한의 정보만 요구하고 있으므로, 불필요한 정보 없이 계정을 만들 수 있습니다.

이메일 주소에 "플러스 기호"를 사용할 수도 있으므로, 각 테스터에 대해 새로운 이메일 주소를 만들 필요가 없습니다.

우리는 강력한 비밀번호를 만드는 것이 지루할 수 있다는 것을 알고 있으며, 이것을 더 쉽게 만들었습니다.

우리는 또한 당신의 비밀번호를 더 안전하게 만들기 위해 인라인 제안을 추가했습니다.

간소화된 Apple ID 생성 양식과 더 나은 비밀번호 복잡성 힌트가 계정 설정 시간을 줄이고 앱을 개발하는 데 더 많은 시간을 할애하는 데 도움이 되기를 바랍니다.

App Store Connect는 Sandbox Apple ID를 만들고 관리하고 앱 콘텐츠와 조직을 관리하는 중앙 위치입니다.

지난 몇 년 동안, 우리는 샌드박스 계정 지역을 변경하고 구매 내역을 지우는 것과 같이 당신이 요청한 기능을 샌드박스에 추가해 왔습니다.

이러한 기능의 대부분은 App Store Connect 또는 Sandbox 구독 관리 페이지의 온디바이스에서 액세스할 수 있습니다.

올해 말에, 우리는 샌드박스 애플 ID 목록 쿼리, 구매 내역 지우기, 중단된 구매 상태 설정을 포함하여 이러한 샌드박스 기능 중 몇 가지를 App Store Connect API에 가져올 것입니다.

이를 통해 샌드박스 계정으로 더 빠른 테스트를 할 수 있으며 일반적으로 사용되는 테스트 도구에 대한 자동화 클라이언트를 설정하는 데 도움이 됩니다.

마지막으로, 샌드박스에서 청구 실패 시뮬레이션에 대한 지원을 발표하게 되어 기쁩니다.

2018년에, 우리는 비자발적 이탈을 줄이기 위해 자동 갱신 구독에 대한 청구 재시도 및 유예 기간을 발표했습니다.

2019년에 출시된 이후, 청구 유예 기간을 통해 고객에게 3억 일의 유료 서비스를 복구할 수 있습니다.

이것은 당신의 고객이 서비스 중단을 경험하지 않는 동안 당신의 사업에 대한 수익 증가를 초래합니다.

여러분 중 많은 사람들이 이미 프로덕션에서 청구 실패 사례를 처리하고 있지만, 우리는 샌드박스에서 더 많은 테스트 시나리오를 제공하고자 하므로 앱이 App Store에 게시되기 전에 청구 실패를 테스트하고 처리할 수 있습니다.

새로운 샌드박스 계정 설정 페이지를 사용하여 계정에 대한 청구 실패 시뮬레이션을 활성화하고, 앱의 맥락에서 포그라운드 및 백그라운드 구독 실패를 테스트하고, 샌드박스에서 verifyReceipt, App Store Server API 및 App Store Server Notifications V2로 구독 상태를 확인할 수 있습니다.

청구 재시도 및 비자발적 이탈 감소에 대한 자세한 정보는 2018 WWDC 세션인 "엔지니어링 구독"을 추천합니다.

올해, 우리는 실패한 인앱 구매 시도를 시뮬레이션하기 위해 새로운 샌드박스 계정 설정에 스위치를 도입하고 있습니다.

이곳은 또한 샌드박스 구독 페이지의 새로운 집이기도 하다.

청구 실패 시뮬레이션을 활성화하면, 포그라운드 인앱 구매가 실패할 것이다.

이 행동은 고객의 결제 방법이 거절되었을 때의 행동과 일치합니다.

청구 실패 시뮬레이션은 또한 자동 갱신 구독 상태가 생산의 청구 실패 상태와 일치하도록 보장합니다.

즉, 청구 문제가 있는 고객을 위해 인앱 메시징을 테스트할 수 있습니다.

이러한 구독 상태는 V2 알림으로 확인된 인앱 구매 영수증에 반영됩니다.

구독 수명 주기를 검토해 봅시다.

샌드박스에서 자동 갱신 구독을 구매하면, 이미 구독 및 DID_RENEW와 같은 V2 알림을 받게 됩니다.

활성 구독이 있는 계정에 대해 실패한 인앱 구매 시도를 테스트하면, 다음 갱신은 청구 재시도 상태로 전환됩니다.

이제 DID_FAIL_TO_RENEW와 같은 샌드박스에서 청구 재시도 알림을 받게 됩니다.

구독 갱신을 복구하려는 시도를 중단하기 전에 청구 실패 시뮬레이션을 비활성화하면 다음 갱신 시도가 성공하고 하위 유형 BILLING_RECOVERY와 함께 DID_RENEW 알림을 받게 됩니다.

재시도 시도 한도에 도달하고 청구 실패 시뮬레이션이 활성화되면 구독이 만료되고 하위 유형 BILLING_RETRY와 함께 EXPIRED를 받게 됩니다.

이미 프로덕션에서 유예 기간과 샌드박스에서 V2 알림을 사용하고 있다면, GRACE_PERIOD 하위 유형으로 DID_FAIL_TO_RENEW 알림을 받을 수 있습니다.

다음은 유예 기간과 함께 청구 재시도 상태의 구독 예시입니다.

유예 기간이 끝날 때 청구 실패 시뮬레이션이 여전히 활성화된 경우 GRACE_PERIOD 하위 유형으로 DID_FAIL_TO_RENEW 알림과 GRACE_PERIOD_EXPIRED를 받게 됩니다.

App Store Server API로 구독 정보를 확인할 때, signedRenewalInfo의 페이로드를 디코딩하여 구독 상태를 확인할 수 있습니다.

여기서, 우리는 만료 의도와 청구 재시도 필드가 채워져 있는 것을 볼 수 있습니다.

청구 재시도 상태의 구독 영수증으로 /verifyReceipt를 호출하면 is_in_billing_retry_period 플래그가 1로 설정되어 있는 것을 볼 수 있습니다.

또한, 유예 기간을 사용할 때, 이제 유예 기간 만료일 필드가 채워질 것으로 예상할 수 있습니다.

샌드박스에서 청구 실패 테스트를 완료하면, 샌드박스 계정 설정에서 스위치를 비활성화할 수 있습니다.

우리는 이 새로운 테스트가 당신의 고객을 위한 최상의 경험을 구축하는 데 도움이 되기를 바랍니다.

오늘 우리는 앱의 인앱 구매 기능 테스트를 간소화하는 데 사용할 수 있는 몇 가지 새로운 테스트 기능에 대해 논의했습니다.

App Store Connect에서 구성을 Xcode와 동기화하면 로컬 또는 샌드박스 환경에서 테스트할 때 동일한 인앱 구매 구성을 사용할 수 있습니다.

Xcode에서 코드 및 환불 테스트와 같은 새로운 기능은 복잡한 StoreKit 구현을 확인하는 데 도움이 될 것입니다.

그리고 구독 관리 테스트 기능을 통해 서비스가 중단되더라도 훌륭한 고객 경험을 보장하기 위해 앱을 발전시킬 수 있습니다.

청구 실패가 구독 영수증에 미치는 영향과 샌드박스의 App Store 서버 알림 V2에 대한 자세한 내용은 WWDC 21 세션인 "서버에서 인앱 구매 관리"를 추천합니다.

또한, App Store Server API 및 V2 알림의 새로운 기능에 대해 들으려면, "인앱 구매의 새로운 기능"을 확인하세요.

우리는 이러한 새로운 기능에 대한 당신의 피드백을 듣기를 기대합니다.

참여해 주셔서 감사합니다.