110364

♪ ♪

안녕하세요, WWDC 2022에 오신 것을 환영합니다.

제 이름은 벤이고, 저는 Xcode 빌드 시스템 팀의 엔지니어입니다.

안녕하세요, 제 이름은 아르템이고, 저는 스위프트 컴파일러 팀의 엔지니어입니다.

이 강연에서 우리는 빌드 내부의 병렬화를 신비화하기 위해 Xcode의 빌드 프로세스에 대해 자세히 알아볼 것입니다.

벤은 빌드에 대한 핵심 개념을 소개하고 빌드 성능 문제를 조사하는 데 도움이 되는 Xcode가 제공하는 사용 가능한 도구를 살펴볼 것이다.

그런 다음 그는 Xcode가 목표를 구축하는 동안 어떻게 병렬화를 증가시키는지 설명할 것이다.

그 위에, 나는 많은 목표로 구성된 프로젝트를 구축하는 동안 Xcode가 어떻게 빌드를 전체적으로 병렬화하는지 설명하고 결국 테이크아웃을 요약할 것이다.

벤?

앱을 만들기 위해 Xcode에서 CMD+B를 누를 때 어떤 일이 일어나는지 다시 반복해 봅시다.

Xcode의 일부로 빌드 시스템은 모든 소스 파일, 자산, 빌드 설정 및 실행 대상과 같은 기타 구성을 포함하여 전체 프로젝트의 표현으로 호출됩니다.

빌드 시스템은 앱이 어떻게 구축되어야 하는지에 대한 진실의 단일 원천이다.

그것은 결국 앱을 만들기 위해 어떤 설정과 어떤 중간 파일을 사용하여 호출할 것인지 알고 있다.

다음 단계에서, 빌드 시스템은 컴파일러와 같은 프로젝트의 입력 파일을 처리하는 도구를 호출합니다.

Clang과 Swift의 두 컴파일러는 링커가 앱을 나타내는 실행 프로그램을 연결하는 데 필요한 객체 파일을 생성할 것이다.

이 순서는 말이 되지만, 그것이 어디에서 왔는지는 분명하지 않다.

그래서 그 과정의 한 가지 예와 빌드 시스템이 모든 작업을 실행할 순서를 결정하는 방법을 살펴봅시다.

스위프트 컴파일러는 입력 소스 파일을 사용하여 프로그래머의 의도를 캡처하고 기계 실행 가능한 바이너리로 변환하여 소스 코드에서 오류를 확인합니다.

이 프로세스는 실패할 수 있으며, 이는 빌드를 취소할 수 있지만, 성공하면 각 입력에 대한 개체 파일을 생성합니다.

이러한 개체 파일은 그것들을 결합하고 외부에 연결된 라이브러리에 대한 참조를 추가하여 실행 파일을 생성하는 링커를 호출하는 데 사용됩니다.

두 가지 작업은 그들이 소비하고 생산하는 것에 따라 의존성을 가지고 있다.

컴파일러에 의해 생성된 객체 파일은 링커에 의해 소비된다.

이것은 빌드 시스템 그래프에 대한 의존성을 만든다.

파일 내용 자체는 빌드 시스템에 관심이 없지만, 작업 간의 의존성은 그렇다.

빌드를 실행하는 동안, 해당 작업이 시작되기 전에 다른 작업의 입력을 생성하는 작업이 완료되는지 확인해야 합니다.

그리고 이 핵심 개념은 모든 종류의 작업에 유효하기 때문에, 작업 A와 작업 B 사이의 의존성을 보여주는 보다 일반적인 시각화로 전환합시다.

이 경우, A는 B의 입력의 일부 또는 전부를 생산한다.

컴파일 및 연결은 전체 대상을 구축하기 위해 실행해야 하는 다양한 작업 유형 중 일부에 불과하므로, 자산 컴파일, 파일 복사 또는 공동 설계와 같은 다른 유형을 나타내는 그래프에 좀 더 일반적인 작업을 추가해 봅시다.

함께, 그들은 프레임워크 목표를 세우는 것을 대표한다.

다시 말하지만, 그 작업들은 입력과 출력에 따라 종속성을 정의했다.

따라서 실행 작업 A를 완료하면 실행 중인 작업 B와 C를 차단 해제하고, 작업 B를 완료하면 작업 D와 E를 차단 해제합니다.

차단 해제되는 작업을 '다운스트림'이라고 하고 '업스트림'을 차단하는 작업이라고 합니다.

많은 프로젝트에는 하나 이상의 프레임워크 대상이 포함되어 있으므로, 앱과 앱 확장을 나타내는 두 개의 대상을 더 추가해 봅시다.

대상은 명시적 또는 암시적 종속성을 통해 프로젝트에서 서로 간의 종속성을 정의합니다.

예를 들어, 'Link Binary with Libraries' 빌드 단계에 추가함으로써.

이 경우, 앱은 앱 확장을 삽입하고 프레임워크에 대한 링크를 포함합니다.

앱 확장 프로그램은 프레임워크를 사용하지 않기 때문에 의존 관계가 없습니다.

빌드 그래프를 실행할 때, 다른 작업은 다른 시간이 걸린다.

이것은 필요한 계산과 입력 크기에 따라 작업을 완료하는 데 필요한 복잡성 수준으로 귀결됩니다.

많은 파일을 컴파일하는 것은 보통 몇 개의 헤더 파일을 복사하는 것보다 훨씬 더 많은 시간이 걸리며, 이것을 고려하면 이와 같은 것으로 끝날 것이다.

빌드 시스템이 이 빌드를 실행하면, 종속성이 없는 작업을 실행하는 것으로 시작됩니다.

그리고 일단 그것들이 완료되면, 그들은 모든 계획된 작업이 끝날 때까지 이 과정을 따라 다운스트림 작업 등 차단을 해제합니다.

다음 빌드에서, 빌드 시스템은 출력이 최신 상태인 동안 입력이 변경되지 않은 작업을 건너뛸 수 있습니다.

이 경우 앱 대상의 B와 같이 변경된 입력으로 인해 작업을 다시 실행해야 하는 경우, 출력이 변경되면 다운스트림 작업도 다시 실행해야 합니다.

다른 모든 작업을 건너뛰면 프로젝트를 반복적으로 작업할 때 매우 빠른 처리 시간을 허용합니다.

이것은 증분 빌드라고 불리지만, 지금은 전체 빌드를 고수합시다.

작업 실행의 종속성과 기간은 다운스트림 작업이 시작할 수 있는 첫 번째 시간을 정의합니다.

이 정보를 사용하면 이론적 무제한 자원으로 빌드를 실행하는 데 필요한 가장 짧은 시간인 중요한 경로를 계산할 수 있습니다.

이 강연 전반에 걸친 일반적인 패턴은 고도로 병렬화 가능하고 확장 가능한 빌드 그래프를 만들기 위해 이 경로를 단축하는 것이다.

더 짧은 임계 경로가 반드시 전체 빌드 시간을 단축하는 것은 아니지만, 빌드가 하드웨어와 함께 확장되도록 보장합니다.

중요한 빌드 경로는 빌드가 얼마나 빠를 수 있는지에 대한 제한 요소를 정의합니다. 하드웨어가 허용하더라도 더 빨리 완료할 수 없습니다.

중요한 경로를 단축하는 것은 그 안의 종속성을 해체함으로써 이루어진다.

빌드가 어떻게 수행되었는지 살펴보고 실행에 대해 더 많이 이해할 때, 데이터는 실행된 시간에 따라 플로팅되어야 합니다.

너비는 여전히 작업의 길이를 나타낸다.

이 두 가지와 같은 넓은 요소는 긴 실행 작업을 나타내는 반면, 이와 같은 좁은 요소는 빠른 마무리 작업을 나타낸다.

그래프의 높이는 주어진 시간에 병렬로 실행하는 작업의 수를 보여준다.

이것은 CPU 또는 메모리 사용률에 직접 매핑되지 않는다는 점에 유의하십시오.

빈 공간은 두 시나리오와 같이 다운스트림 작업을 차단하는 작업에서 비롯됩니다.

그리고 마지막으로, 요소의 색상은 관련 목표를 나타낸다.

이 시각화가 Xcode 14의 새로운 기능이며 완료된 후 빌드의 성능을 이해하는 데 도움이 될 것이라고 발표하게 되어 매우 기쁩니다.

Xcode 빌드 타임라인은 빌드 로그에 훌륭한 새로운 추가 기능입니다.

빌드의 성능을 이해하기 위해 계층 구조가 아닌 병렬화를 기반으로 시각화합니다.

주어진 시간의 행 수는 그 시간 동안의 병렬 처리 수준을 나타낸다.

개별 작업의 수평 길이는 작업을 완료하는 데 필요한 기간을 나타낸다.

그래프의 빈 공간은 미완성 작업이 다운스트림 작업이 실행을 시작하는 것을 막았던 곳을 보여준다.

타임라인 요소에 적용된 다른 색상은 빌드의 일부였던 다른 목표를 구별하는 데 도움이 됩니다.

그리고 증분 빌드에서, 타임라인은 실제로 실행된 작업만 포함할 것이며, 장기 실행 작업, 특히 이 빌드 중에 실행될 것으로 예상되지 않았을 수도 있는 작업을 발견할 수 있습니다.

여기 Xcode 14의 빌드 타임라인 데모가 있습니다.

이 창에서 나는 문서 컴파일러를 만드는 Github에서 swift-docc 프로젝트의 복사본을 열었다.

계획을 위해 만들어진 목표에 대한 개요를 얻으려면, 계획 편집기를 확인해 봅시다.

그것을 열려면 계획을 클릭하고 "계획 편집"을 선택합니다.

'빌드' 탭에는 모든 대상 목록이 포함되어 있습니다.

대상은 이미 계획의 일부인 대상의 종속성이 됨으로써 계획에 명시적으로 추가되거나 암시적으로 추가될 수 있다.

이 경우 저는 패키지에 대해 자동으로 생성된 구성표가 있는 스위프트 패키지를 사용하고 있으므로, 매니페스트의 모든 대상은 명시적으로 정의됩니다.

이 로그는 내가 이전에 실행한 그 계획의 빌드를 나타낸다.

빌드 시스템이 실행한 모든 작업에 대한 항목이 포함되어 있습니다.

항목은 여기에 있는 'docc' 대상과 같이 그들이 속한 대상에 따라 계층 구조로 구성됩니다.

그 대상의 실행 파일을 성공적으로 구축하기 위해, Xcode는 이 노드의 자식이 나타내는 모든 작업을 실행했다.

빌드 로그는 현재 '모두' 상태에 있기 때문에, 증분 빌드에서 다시 실행할 필요가 없었던 이전 빌드의 작업도 보여줍니다.

'최근'을 선택하면 실제로 실행된 작업만 표시되며, 건너뛴 모든 작업을 숨깁니다.

그 외에도, 빌드 로그는 문제가 있거나 실패한 작업만 표시하는 필터를 지원합니다.

이 빌드의 빌드 타임라인을 열려면, 편집기 옵션으로 이동하여 어시스턴트를 엽니다.

빌드 타임라인은 빌드 로그 옆에 열립니다.

평소와 같이, 편집기 옵션은 오른쪽이나 하단에 조수를 표시하는 설정을 제공합니다.

지금은 바닥과 함께 있을 거야.

타임라인은 빌드의 병렬화를 기반으로 '최근' 빌드 로그와 동일한 데이터를 시각화합니다.

한 요소에서 요소를 선택하면 다른 요소에서도 선택됩니다.

이것은 맥락에서 작업의 실행을 볼 수 있게 해준다.

여기의 타임라인은 선택한 작업과 병행하여 실행된 작업에 대한 감각을 제공한다.

나는 다시 축소하기 위해 트랙패드에서 핀치 제스처를 사용하고 있다.

타임라인에서 요소를 선택하면 빌드 로그에 표시됩니다.

그리고 빌드 로그는 계층 구조를 기반으로 시각화되기 때문에, 이 컴파일러 호출의 일부로 컴파일된 파일을 볼 수 있습니다.

또한 그 호출의 전체 명령줄을 볼 수 있다.

빌드 타임라인에서 영역을 선택하는 동안 옵션을 길게 누르면 이 시간대에 맞게 뷰 포트가 조정됩니다.

여기서 우리는 대상 ArgumentParser의 연결이 실제로 동일한 대상의 컴파일을 기다리고 있다는 것을 확인할 수 있습니다.

위로 스크롤하는 동안 옵션을 누르면 빠르게 축소할 수 있습니다.

타임라인의 행 수는 그 당시 병렬로 실행된 작업의 수를 나타낸다.

이와 같은 빈 공간은 생산되지 않은 입력을 기다리는 작업을 나타냅니다.

이상적으로, 타임라인은 수직으로 채워지고 빈 공간이 가능한 한 적다.

이것은 빌드 그래프를 가장 잘 확장하고 빌드를 더 빠르게, 하드웨어를 더 빠르게 만든다.

이를 달성하기 위해, Xcode는 중요한 경로를 단축하기 위해 올해 많은 개선 사항을 제공합니다.

다음으로, Xcode가 개별 목표를 정의하고 구축하는 방법과 병렬화를 증가시킬 수 있는 방법을 확인해 봅시다.

대상을 구성할 때, 빌드 단계는 대상의 제품을 생산하기 위해 수행해야 할 작업을 설명합니다.

그것들은 프로젝트 편집기에서 정의되며 컴파일할 소스 코드 파일과 자산 세트, 헤더나 리소스와 같이 복사해야 하는 파일, 연결해야 하는 라이브러리 또는 실행해야 하는 스크립트를 포함할 수 있습니다.

많은 빌드 단계는 다른 빌드 단계의 입력이나 출력으로 작업을 설명하여 그들 사이에 종속성을 만듭니다.

예를 들어, 대상의 소스 파일은 연결되기 전에 컴파일되어야 합니다.

그러나, 이것은 모든 빌드 단계에 적용되지는 않는다.

각 빌드 단계에서 작업을 선형 순서로 실행하는 대신, 빌드 시스템은 빌드 단계의 입력과 출력을 고려하여 병렬로 실행할 수 있는지 결정합니다.

예를 들어, 컴파일과 리소스 복사는 둘 다 다른 출력에 의존하지 않기 때문에 병렬로 실행될 수 있다.

그러나, 링크는 그 단계에서 생성된 객체 파일에 의존하기 때문에 여전히 편집을 따라야 한다.

이제, '스크립트 실행' 빌드 단계가 포함된 다른 목표를 고려해 봅시다.

다른 빌드 단계와 달리, 스크립트 단계의 입력과 출력은 대상 편집기에서 수동으로 구성해야 합니다.

결과적으로, 빌드 시스템은 빌드 프로세스에서 데이터 경쟁을 도입하는 것을 피하기 위해 한 번에 하나씩 연속적인 스크립트 단계를 실행할 것이다.

대상의 스크립트가 종속성 분석을 기반으로 실행되고 입력 및 출력의 전체 목록을 지정하도록 구성된 경우, 빌드 설정 FUSE_BUILD_SCRIPT_PHASES를 YES로 설정하여 빌드 시스템이 병렬로 실행해야 함을 나타낼 수 있습니다.

그러나, 스크립트 단계를 병렬로 실행할 때, 빌드 시스템은 지정된 입력과 출력에 의존해야 한다.

따라서 스크립트 단계의 입력 또는 출력의 불완전한 목록은 디버깅하기 매우 어려운 데이터 경주로 이어질 수 있다는 점에 유의하십시오.

이를 완화하기 위해, Xcode는 각 스크립트 단계의 종속성을 정확하게 선언하기 위해 사용자 스크립트 샌드박싱을 지원합니다.

샌드박싱은 단계의 입력 또는 출력으로 명시적으로 선언되지 않는 한 셸 스크립트가 실수로 소스 파일과 중간 빌드 객체에 액세스하는 것을 차단하는 옵트인 기능입니다.

이 예에서, input나 output.txt는 해당 스크립트 단계의 종속성으로 선언되지 않습니다.

샌드박스는 프로젝트를 작성할 때 스크립트가 두 파일을 모두 읽고 쓰는 것을 차단할 것이다.

스크립트가 샌드박스를 위반하면, 0이 아닌 종료 코드로 실패하여 빌드가 실패합니다.

그 외에도, Xcode는 스크립트 단계가 제대로 선언하지 않고 액세스하려고 했던 모든 경로를 나열할 것이다.

이 스크립트 단계에 두 파일을 종속성 정보로 추가하면 이 문제가 해결됩니다.

이런 식으로 샌드박스는 스크립트가 선언된 입력과 출력 이외의 파일에 실수로 접근하지 않도록 합니다.

이제, 하나 이상의 스크립트 단계가 있는 예를 살펴보고 샌드박싱이 어떻게 데이터 경쟁과 잘못된 빌드를 방지하는지 봅시다.

두 개의 대본 단계가 있다.

첫 번째는 텍스트 파일을 읽고, 내용의 체크섬을 계산하고, 그 값을 DERIVED_FILE_DIR의 중간 파일에 씁니다.

다른 스크립트는 생성된 체크섬뿐만 아니라 동일한 텍스트 파일을 읽고 나중에 앱에 표시하기 위해 html 파일에 주입합니다.

이러한 단계에 대한 정확한 입력 및 출력 종속성 집합이 선언되지 않으면, Xcode는 FUSE_BUILD_SCRIPT_PHASES가 켜져 있을 때 두 스크립트를 병렬로 실행합니다.

이 문제가 있는 시나리오를 자세히 살펴봅시다.

"Generate HTML"이 "checksum.txt"의 입력 선언이 누락되었다고 가정해 봅시다. 하지만 두 스크립트의 다른 모든 입력과 출력은 올바르게 선언되었습니다.

샌드박싱이 없다면, 이 잘못된 구성은 눈에 띄지 않을 수 있으며, 빌드에 문제를 일으킬 수 있다.

이는 Xcode가 두 단계 간의 종속성 관계를 추론하지 못하고 FUSE_BUILD_SCRIPT_PHASES가 켜져 있을 때 병렬로 실행되도록 일정을 잡는다는 것을 의미합니다.

여기에는 몇 가지 위험이 있다.

Checksum.txt는 깨끗한 빌드 중에 "HTML 생성"에 대한 입력 종속성으로 나열되지 않기 때문에 스크립트는 파일 시스템에서 사용할 수 없는 파일을 읽으려고 시도할 것입니다.

또 다른 위험은 "체크섬 계산"의 이전 실행으로 인해 disk에서 checksum.txt를 사용할 수 있는 경우, "HTML 생성"은 두 스크립트가 병렬로 실행될 때 오래된 파일을 선택할 수 있습니다.

이것은 사용자 오류이며, 샌드박스에서 스크립트를 실행하면 이 문제를 방지하는 데 도움이 됩니다.

샌드박싱을 켜면, "HTML 생성"은 "checksum.txt"를 읽으려고 할 때 즉시 실패합니다.

오류 메시지는 그 빌드 단계에 대한 누락된 입력을 추가하는 것을 안내할 것이다.

입력과 출력이 올바르게 정의되면 Xcode는 두 단계 간의 종속성 관계를 존중하여 "체크섬 계산"이 "HTML 생성" 전에 실행되도록 합니다.

관련이 없는 빌드 단계는 여전히 병렬로 실행될 수 있다.

대상에 대한 샌드박스 셸 스크립트를 활성화하려면, 빌드 설정 편집기 또는 xcconfig 파일에서 ENABLE_USER_SCRIPT_SANDBOXING을 YES로 설정하십시오.

요약하자면, 샌드박스 셸 스크립트는 입력이 변경되지 않고 출력이 여전히 유효한 경우 빌드 시스템이 스크립트 단계를 건너뛸 수 있기 때문에 올바른 종속성 정보를 사용하여 더 빠르고 강력한 증분 빌드를 가능하게 할 수 있습니다.

스크립트의 대상에 대한 빌드 설정을 활성화하면 프로젝트의 소스 루트 내의 파일과 프로젝트에서 스크립트의 입력 또는 출력으로 명시적으로 정의되지 않은 경우 파생된 데이터 디렉토리에 대한 액세스를 차단합니다.

샌드박스는 다른 디렉토리에 대한 무단 액세스를 방지하지 않으므로, 이것을 보안 기능으로 간주하지 마십시오.

이 기능을 사용하면 기존 스크립트 단계의 누락된 입력이나 출력을 디버깅하여 유효한 구성을 보장하는 데 도움이 되며, 이전에 설명한 빌드 설정 FUSE_BUILD_SCRIPT_PHASES와 함께 샌드박싱을 통해 올바르게 정의된 종속성 가장자리가 있는 스크립트 단계는 빌드의 중요한 경로를 줄이기 위해 병렬로 실행할 수 있습니다.

그것은 목표를 세우는 단계를 병렬화하기 위한 것이다.

이제 Artem은 많은 목표를 구축하는 병렬화를 신비화할 것이다.

아르템: 고마워, 벤.

이제 프로젝트에서 대상을 구축하는 데 들어갈 수 있는 빌드 시스템 작업과 단계의 기본 사항을 다루었으므로, 보다 글로벌한 관점을 취하고 Xcode가 Swift 대상 간의 종속성을 사용하여 빌드에서 최대 병렬성을 추출하는 방법과 프로젝트의 구조와 조직이 빌드 시간에 어떤 영향을 미칠 수 있는지 살펴보겠습니다.

당신의 프로젝트를 구성하는 여러 수준의 계층 구조가 있을 가능성이 높습니다.

예를 들어, 로컬 라이브러리 컬렉션에 따라 앱 타겟은 의미론적 경계를 따라 여러 프레임워크에서 타겟으로 나뉩니다.

각 대상은 다양한 빌드 단계와 단계를 포함하며, 다른 대상의 빌드 단계와 파일 종속성을 생성하고 소비합니다.

프로젝트의 크기가 커짐에 따라, 이러한 작업 그래프는 크기와 복잡성이 증가하는 경향이 있습니다.

Xcode 빌드 시스템이 이러한 계층을 평평하게 하는 동안, 빌드를 모든 대상의 빌드 단계에 해당하는 작업의 바다로 나뉈다.

스위프트 대상에게 특별한 한 가지 작업은 편집이다.

스위프트 타겟의 소스 코드를 바이너리 제품으로 구축하는 것은 일반적으로 빌드 계획, 컴파일 및 연결을 위한 많은 하위 작업으로 구성된 복잡한 작업입니다.

이러한 작업의 조정은 Xcode 툴체인의 특수 도구인 Swift Driver에 위임됩니다.

드라이버는 대상의 소스 코드에 필요한 컴파일러와 링커 호출을 구성하는 시기와 방법에 대한 전문 지식을 가지고 있다.

스위프트 코드를 포함하는 모든 대상은 코드 배포 단위인 모듈에 해당한다.

이 대상의 공용 인터페이스를 캡처하는 이진 모듈 파일은 다운스트림 대상에서 컴파일을 시작하는 데 필요한 빌드 제품입니다.

스위프트 드라이버가 목표 중 하나를 구축하기 위해 무엇을 하는지에 대한 예를 자세히 살펴봅시다.

당신의 목표는 아마도 여러 소스 파일 모음으로 구성되어 있을 것입니다.

릴리스 또는 최적화된 빌드에서 드라이버는 최적화 기회를 극대화하기 위해 모든 소스 파일을 포함한 하나의 컴파일러 작업을 예약합니다.

이 단일 컴파일 작업은 또한 대상의 스위프트 모듈을 생성할 것이다.

디버그 또는 증분 컴파일 모드에서, 스위프트 드라이버는 필요한 컴파일 노력을 병렬로 실행할 수 있는 더 작은 하위 작업으로 분류하며, 그 중 일부는 증분 빌드에서 다시 실행할 필요가 없을 수도 있습니다.

스위프트 모듈을 생산하려면 각 컴파일 작업의 부분 중간 제품을 병합하는 추가 단계가 필요합니다.

이 예와 같이 대상의 소스 파일 수가 많은 경우, 빌드 시스템의 휴리스틱에 따라 개별 파일이 배치 컴파일 하위 작업에 할당될 수도 있습니다.

빌드 로그는 각 파일의 진단에 대한 별도의 항목과 함께 배치 컴파일 작업에 할당된 소스 파일을 강조 표시합니다.

다른 소스 파일에서 대상의 빌드를 병렬화할 수 있는 것은 더 빠르고 작은 증분 빌드 모두에서 매우 중요하므로 디버그 빌드가 증분 컴파일 모드 설정을 사용하고 있는지 확인하십시오.

Xcode 14 이전에는 Xcode 빌드 시스템과 스위프트 드라이버 사이의 경계로 인해 대상 빌드 단계의 오케스트레이션과 각 대상의 드라이버 인스턴스에 의해 생성된 컴파일 하위 작업이 서로 독립적으로 발생했으며, 각 구성 요소는 사용 가능한 시스템 리소스를 최대한 활용하기 위해 최선을 다했습니다.

이 예를 들어 그래프를 만들고 서로에 대한 컴파일 단계의 스케줄링에 들어가는 것에 대해 더 깊이 파고들자.

앞서 배웠듯이, 스위프트 대상 종속성은 종속자가 종속의 공용 인터페이스를 캡처하는 이진 모듈 파일을 제공하도록 함으로써 해결됩니다.

이러한 종속성 관계를 해결하면 각 대상에 대한 최상위 스위프트 드라이버 작업과 개별 하위 작업을 보여주는 타임라인에 캡처된 다음 순서로 이어집니다.

Xcode 14를 사용하면, 현재 Swift로 작성된 Swift Driver의 완전히 새로운 구현 덕분에 빌드 시스템과 컴파일러가 완전히 통합되었습니다.

Xcode 빌드 시스템은 코드를 컴파일하기 위해 수행해야 하는 모든 작업의 중앙 스케줄러 역할을 합니다.

이 중앙 계획 메커니즘을 통해 Xcode는 세분화된 스케줄링 결정을 내릴 수 있으며, 프로젝트를 구축하는 것이 CPU를 과도하게 구독하지 않고 전체 시스템 성능을 저하시키지 않고도 가능한 한 많은 리소스만 사용할 것이라는 더 나은 보장을 제공합니다.

그리고 이전에 Xcode 빌드 시스템의 범위 밖의 하위 작업의 섬 모음이었던 것은 이제 완전히 빌드 시스템의 스케줄러의 도메인에 있습니다.

중앙 작업 풀의 모든 개별 하위 작업과 함께, 빌드 스케줄러가 만든 절충안을 고려하는 것이 중요합니다.

예를 들어, 8코어 컴퓨터에서 스케줄러의 기본값은 종속성이 충족되고 갈 준비가 된 사용 가능한 작업을 8개의 사용 가능한 실행 슬롯 중 하나에 할당하는 것입니다.

슬롯 중 하나가 해제되자마자, 빌드 시스템은 더 뛰어난 작업으로 채우려고 시도한다.

더 높은 코어 카운트 기계에서, 우리는 더 많은 동시 작업을 수행할 수 있다.

하지만 그것은 우리가 더 많은 작업을 수행할 수 있는 유휴 코어를 가질 가능성이 더 높다는 것을 의미하지만, 모든 뛰어난 작업은 현재 비행 중이거나 대기 중인 다른 작업에서 생성되는 것처럼 여전히 입력을 기다리고 있습니다.

새로운 통합 빌드 시스템은 스케줄러가 이 유휴 시간을 크게 줄일 수 있게 해준다.

방법을 보기 위해, 컴파일, 이진 모듈 파일에 대한 대상의 종속성이 어떻게 해결되는지 다시 살펴봅시다.

앞서 다루었듯이, 컴파일 하위 작업의 부분적인 결과는 대상의 최종 모듈 제품으로 병합됩니다.

이 제품을 사용할 수 있게 되면, 다운스트림 타겟이 편집을 시작할 수 있습니다.

Xcode 14와 Swift 5.7의 새로운 기능인 대상 모듈의 구성은 모든 프로그램 소스 파일에서 직접 별도의 방출 모듈 작업으로 수행됩니다.

이것은 대상의 종속성이 종속성 대상의 다른 모든 컴파일러 작업을 기다리지 않고 emit-module 작업이 완료되는 즉시 컴파일을 시작할 수 있다는 것을 의미합니다.

다운스트림 대상 컴파일을 훨씬 더 빨리 차단 해제할 수 있기 때문에 빌드 타임라인에서 활동 스퍼 사이의 빈 공간인 유휴 CPU 코어로 사용 가능한 작업을 기다리는 데 소요되는 시간을 줄일 수 있습니다.

이것을 프로젝트의 나머지 부분으로 확장하는 것은 우리가 비슷한 양의 전반적인 작업을 수행하고 있지만, 빌드 시스템은 컴퓨터의 자원을 더 효율적으로 사용할 수 있으며, 종종 빌드를 훨씬 더 빨리 완료할 수 있다는 것을 보여준다.

이제, Swift-Eager Linking을 빌드할 때 빌드 시스템이 수행할 수 있는 두 번째 교차 대상 최적화를 살펴봅시다.

이전 예제를 바탕으로, 우리는 빌드의 중요한 경로에 있는 각 대상에 대한 링커 작업을 추가했습니다.

이 경우, 대상 B가 대상 A를 연결하기 때문에, 대상 B의 링크 작업은 대상 A의 연결된 출력이 생성되고 실행되기 전에 자체 컴파일 작업이 완료될 때까지 기다려야 합니다.

그러나, 열렬한 링크로, 타겟 B의 링크 작업은 대신 타겟 A의 방출 모듈 작업에 의존할 수 있다.

결과적으로, 타겟 B는 빌드 초반에 연결을 시작할 수 있으며, 타겟 A를 연결하고 중요한 경로를 단축하는 것과 병행하여 실행할 수 있다.

이건 어떻게 작동해?

일반적으로, 연결된 제품 종속성을 가진 두 대상의 종속성 그래프는 다음과 같이 보인다.

종속 대상을 연결하려면 대상의 자체 컴파일 출력 외에도 종속성의 연결된 제품이 필요합니다.

열심히 연결할 때, 이 종속성은 깨져서 종속 대상이 더 일찍 연결을 시작할 수 있게 해준다.

종속성의 연결된 제품에 의존하는 대신, 이제 emit-module 작업에 의해 빌드 프로세스 초기에 생성된 텍스트 기반 동적 라이브러리 스텁에 의존합니다.

이 스텁에는 부양가족이 사용하기 위해 연결된 제품에 나타날 기호 목록이 포함되어 있습니다.

화면에 표시된 Xcode 빌드 설정을 사용하여 이 최적화를 활성화할 수 있습니다.

Eager Linking은 부양가족에 의해 동적으로 연결된 모든 순수 스위프트 대상에 적용됩니다.

요약하자면, Xcode 빌드 시스템은 빌드 단계를 병렬로 실행하여 가능한 한 많은 병렬성을 추출하고자 하는 정교한 스케줄링 엔진입니다.

그리고 스크립트 샌드박싱과 같은 기능을 사용하면 빌드가 최대한 병렬적이고 신뢰할 수 있도록 할 수 있습니다.

Xcode와 Swift는 그 어느 때보다 통합되어 있다.

그리고 프로젝트 구조: 모듈화, 대상 제품 간의 종속성과 그 내의 빌드 단계의 수와 복잡성으로 구성된 그래프의 전반적인 모양, 기계의 사용 가능한 계산 자원과 결합 - 이 모든 것은 Xcode가 빌드를 병렬화하고 속도를 높일 수 있는 정도에 기여하는 요인입니다.

이 지식과 빌드 타임라인과 같은 강력한 새로운 도구를 사용하면 프로젝트를 검토하고 빌드에 대한 통찰력을 얻을 수 있습니다.

그리고 비하인드 스토리 기술 세부 사항에 대해 더 알고 싶다면, Xcode에서 사용하는 우리가 설명한 많은 기술은 오픈 소스에서 개발되었습니다.

아래 링크에서 GitHub에서 Swift Driver 저장소를 찾을 수 있습니다.

Xcode에 대한 더 훌륭한 세션을 보려면, "Xcode의 새로운 기능"에서 올해의 모든 새로운 기능과 개선 사항을 확인하세요.

그리고 Xcode 14의 링커가 "빠른 링크: 빌드 및 실행 시간 개선" 세션에서 링크 시간을 최대 두 번까지 개선하는 방법을 알아보세요.

따라와줘서 고마워.

우리는 당신이 Xcode 빌드에 대한 새로운 통찰력을 배웠기를 바랍니다.

우리는 당신이 무엇을 만들 것인지 빨리 보고 싶습니다.

남은 회의 잘 보내.