110362

♪ ♪

Nick Kledzik: 안녕하세요, 저는 Apple Linker 팀의 수석 엔지니어인 Nick Kledzik입니다.

오늘, 저는 당신과 빠르게 연결하는 방법을 공유하고 싶습니다.

Apple이 링크를 개선하기 위해 무엇을 했는지 알려드리고, 앱의 링크 성능을 향상시킬 수 있도록 링크 중에 실제로 어떤 일이 일어나는지 이해할 수 있도록 도와드리겠습니다.

그래서 링크가 뭐야?

당신은 코드를 작성했지만, 다른 사람이 라이브러리나 프레임워크의 형태로 작성한 코드도 사용합니다.

당신의 코드가 그 라이브러리를 사용하려면, 링커가 필요합니다.

이제, 실제로 두 가지 유형의 연결이 있다.

앱을 빌드할 때 발생하는 "정적 연결"이 있습니다.

이것은 앱이 빌드되는 데 걸리는 기간과 앱이 얼마나 커지는지에 영향을 미칠 수 있습니다.

그리고 "동적 연결"이 있다.

이것은 당신의 앱이 실행될 때 발생합니다.

이것은 고객이 앱이 실행될 때까지 얼마나 기다려야 하는지에 영향을 미칠 수 있습니다.

이 세션에서 나는 정적 연결과 동적 연결에 대해 이야기할 것이다.

먼저, 몇 가지 예와 함께 정적 링크가 무엇이고 어디에서 왔는지 정의할 것입니다.

다음으로, 나는 애플의 정적 링커인 ld64의 새로운 것을 공개할 것이다.

그런 다음, 정적 연결에 대한 배경과 함께, 정적 연결에 대한 모범 사례를 자세히 설명하겠습니다.

이 이야기의 후반부는 역동적인 연결을 다룰 것이다.

나는 동적 링크가 무엇인지, 그것이 어디에서 왔는지, 그리고 동적 링크 중에 무슨 일이 일어나는지 보여줄 것이다.

다음으로, 나는 올해 dyld의 새로운 것을 밝힐 것이다.

그런 다음, 앱의 동적 링크 시간 성능을 개선하기 위해 할 수 있는 일에 대해 이야기하겠습니다.

그리고 마지막으로, 우리는 당신이 커튼 뒤를 들여다보는 데 도움이 될 두 가지 새로운 도구로 마무리할 것입니다.

바이너리에 무엇이 있는지, 그리고 동적 연결 중에 무슨 일이 일어나고 있는지 볼 수 있습니다.

정적 연결을 이해하기 위해, 모든 것이 시작되었을 때로 돌아가자.

처음에, 프로그램은 간단했고 소스 파일이 하나밖에 없었다.

건물은 쉬웠어.

당신은 방금 하나의 소스 파일에서 컴파일러를 실행했고 실행 가능한 프로그램을 생성했습니다.

하지만 모든 소스 코드를 하나의 파일에 두는 것은 확장되지 않았다.

여러 소스 파일로 어떻게 구축하나요?

그리고 이것은 단지 당신이 큰 텍스트 파일을 편집하고 싶지 않기 때문이 아닙니다.

진정한 절약은 당신이 만들 때마다 모든 기능을 다시 컴파일하는 것이 아니다.

그들이 한 일은 컴파일러를 두 부분으로 나누는 것이었다.

첫 번째 부분은 소스 코드를 새로운 중간 "재적용 가능한 객체" 파일로 컴파일한다.

두 번째 부분은 재배치 가능한 .o 파일을 읽고 실행 가능한 프로그램을 생성합니다.

우리는 이제 두 번째 부분을 정적 링커인 'ld'라고 부른다.

이제 당신은 정적 연결이 어디에서 왔는지 알고 있습니다.

소프트웨어가 진화함에 따라, 곧 사람들은 .o 파일을 전달하고 있었다.

하지만 그건 번거로워졌어.

누군가는 "우리가 .o 파일 세트를 '라이브러리'로 포장할 수 있다면 좋지 않을까요?"라고 생각했다.

당시 파일을 함께 묶는 표준 방법은 보관 도구 'ar'였다.

그것은 백업과 배포에 사용되었다.

그래서 작업 흐름이 이렇게 되었다.

여러 개의 .o 파일을 아카이브로 'ar'할 수 있으며, 링커는 아카이브 파일에서 직접 .o 파일을 읽는 방법을 알 수 있도록 향상되었습니다.

이것은 공통 코드를 공유하기 위한 큰 개선이었다.

그 당시 그것은 단지 도서관이나 기록 보관소라고 불렸다.

오늘날, 우리는 그것을 정적 도서관이라고 부른다.

하지만 그 기능들 중 몇 개만 사용되었음에도 불구하고, 이 라이브러리의 수천 개의 기능이 복사되었기 때문에 최종 프로그램은 커지고 있었다.

그래서 영리한 최적화가 추가되었다.

링커가 정적 라이브러리의 모든 .o 파일을 사용하도록 하는 대신, 링커는 정의되지 않은 기호를 해결할 수 있는 경우에만 정적 라이브러리에서 .o 파일만 가져옵니다.

그것은 누군가가 모든 C 표준 라이브러리 기능을 포함하는 큰 libc.a 정적 라이브러리를 만들 수 있다는 것을 의미했다.

모든 프로그램은 하나의 libc.a와 연결할 수 있지만, 각 프로그램은 프로그램이 실제로 필요한 libc의 부분만 얻었다.

그리고 우리는 오늘도 여전히 그 모델을 가지고 있다.

하지만 정적 라이브러리의 선택적 로딩은 분명하지 않으며 많은 프로그래머들을 괴롭힌다.

정적 라이브러리의 선택적 로딩을 조금 더 명확하게 하기 위해, 간단한 시나리오가 있습니다.

Main.c에는 "foo" 함수를 호출하는 "main"이라는 함수가 있습니다.

Foo.c에는 바를 부르는 foo가 있다.

Bar.c에는 bar의 구현뿐만 아니라 사용되지 않는 다른 기능의 구현도 있다.

마지막으로, baz.c에는 undef라는 함수를 호출하는 함수 baz가 있다.

이제 우리는 각각을 자체 .o 파일로 컴파일합니다.

Foo, bar 및 undef는 정의되지 않았기 때문에 회색 상자가 없다는 것을 알게 될 것입니다.

즉, 정의가 아닌 상징의 사용이다.

이제, bar.o와 baz.o를 정적 라이브러리로 결합하기로 결정했다고 가정해 봅시다.

다음으로, 두 개의 .o 파일과 정적 라이브러리를 연결합니다.

실제로 일어나는 일을 한 단계 살펴보자.

먼저, 링커는 명령줄 순서대로 파일을 통해 작동합니다.

가장 먼저 찾은 것은 main.o.이다.

그것은 main.o를 로드하고 기호 표에 표시된 "메인"에 대한 정의를 찾습니다.

하지만 또한 메인이 정의되지 않은 "foo"를 가지고 있다는 것을 발견한다.

그런 다음 링커는 foo.o인 명령줄에서 다음 파일을 구문 분석합니다.

이 파일은 "foo"의 정의를 추가합니다.

그것은 foo가 더 이상 정의되지 않았다는 것을 의미한다.

하지만 foo.o를 로드하는 것은 또한 "바"에 대한 새로운 정의되지 않은 기호를 추가합니다.

이제 명령줄의 모든 .o 파일이 로드되었으므로, 링커는 정의되지 않은 기호가 남아 있는지 확인합니다.

이 경우 "bar"는 정의되지 않은 상태로 남아 있으므로, 링커는 라이브러리가 누락된 정의되지 않은 기호 "bar"를 충족하는지 확인하기 위해 명령줄에서 라이브러리를 보기 시작합니다.

링커는 정적 라이브러리의 bar.o가 기호 "bar"를 정의한다는 것을 발견한다.

그래서 링커는 아카이브에서 bar.o를 로드합니다.

그 시점에서 더 이상 정의되지 않은 기호가 없기 때문에, 링커는 라이브러리 처리를 중단한다.

링커는 다음 단계로 넘어가며, 프로그램에 있을 모든 기능과 데이터에 주소를 할당합니다.

그런 다음 모든 기능과 데이터를 출력 파일에 복사합니다.

그리고 짜잔! 당신은 출력 프로그램을 가지고 있습니다.

Baz.o가 정적 라이브러리에 있었지만 프로그램에 로드되지 않았다는 것을 주목하세요.

링커가 정적 라이브러리에서 선택적으로 로드되는 방식 때문에 로드되지 않았다.

이것은 분명하지 않지만, 정적 도서관의 핵심 측면이다.

이제 당신은 정적 연결과 정적 라이브러리의 기초를 이해합니다.

Ld64로 알려진 Apple의 정적 링커에 대한 최근 개선 사항으로 넘어갑시다.

대중의 요구에 따라, 우리는 올해 ld64를 최적화하는 데 시간을 보냈다.

그리고 올해의 링커는...

많은 프로젝트에서 두 배 더 빠르다.

우리가 이걸 어떻게 했어?

우리는 이제 당신의 개발 기계의 코어를 더 잘 활용합니다.

우리는 병렬로 링커 작업을 하기 위해 여러 코어를 사용할 수 있는 많은 영역을 발견했다.

여기에는 입력에서 출력 파일로 콘텐츠를 복사하고, LINKEDIT의 다른 부분을 병렬로 구축하고, UUID 계산을 변경하고 해시를 병렬로 공동 설계하는 것이 포함됩니다.

다음으로, 우리는 많은 알고리즘을 개선했다.

각 기호의 문자열 슬라이스를 나타내기 위해 C++ string_view 객체를 사용하도록 전환하면 exports-trie 빌더가 정말 잘 작동합니다.

우리는 또한 바이너리의 UUID를 계산할 때 하드웨어 가속을 활용하는 최신 암호화 라이브러리를 사용했으며, 다른 알고리즘도 개선했습니다.

링커 성능을 개선하기 위해 노력하는 동안, 우리는 링크 시간에 영향을 미치는 일부 앱에서 구성 문제를 발견했습니다.

다음으로, 링크 시간을 개선하기 위해 프로젝트에서 무엇을 할 수 있는지 이야기하겠습니다.

나는 다섯 가지 주제를 다룰 것이다.

먼저, 정적 라이브러리를 사용해야 하는지 여부.

그리고 당신의 링크 시간에 큰 영향을 미치는 거의 알려지지 않은 세 가지 옵션.

마지막으로, 당신을 놀라게 할 수 있는 정적 연결 행동에 대해 논의하겠습니다.

첫 번째 주제는 정적 라이브러리에 빌드되는 소스 파일을 적극적으로 작업하는 경우 빌드 시간이 느려졌다는 것입니다.

파일이 컴파일된 후, 목차를 포함하여 전체 정적 라이브러리를 재구성해야 하기 때문입니다.

이것은 단지 많은 추가 I/O일 뿐이다.

정적 라이브러리는 안정적인 코드에 가장 적합합니다.

즉, 코드가 적극적으로 변경되지 않습니다.

빌드 시간을 줄이기 위해 정적 라이브러리에서 활성 개발 중인 코드를 이동하는 것을 고려해야 합니다.

이전에 우리는 아카이브에서 선택적 로딩을 보여주었다.

하지만 그것의 단점은 링커의 속도를 늦춘다는 것이다.

그것은 빌드를 재현하고 전통적인 정적 라이브러리 의미를 따르기 위해, 링커는 고정된 직렬 순서로 정적 라이브러리를 처리해야 하기 때문이다.

그것은 ld64의 병렬화 승리 중 일부는 정적 라이브러리와 함께 사용할 수 없다는 것을 의미한다.

하지만 이 역사적 행동이 정말로 필요하지 않다면, 링커 옵션을 사용하여 빌드 속도를 높일 수 있습니다.

그 링커 옵션은 "모든 로드"라고 불린다.

그것은 링커에게 모든 정적 라이브러리의 모든 .o 파일을 맹목적으로 로드하도록 지시한다.

이것은 당신의 앱이 어쨌든 모든 정적 라이브러리에서 대부분의 콘텐츠를 선택적으로 로드하는 경우 유용합니다.

-All_load를 사용하면 링커가 모든 정적 라이브러리와 그 내용을 병렬로 구문 분석할 수 있습니다.

하지만 앱이 동일한 기호를 구현하는 여러 정적 라이브러리가 있는 영리한 트릭을 하고, 어떤 구현이 사용되는지 구동하기 위해 정적 라이브러리의 명령줄 순서에 의존한다면, 이 옵션은 당신을 위한 것이 아닙니다.

왜냐하면 링커는 모든 구현을 로드하고 반드시 일반 정적 연결 모드에서 발견된 기호 의미를 얻지는 않기 때문입니다.

-All_load의 또 다른 단점은 "사용하지 않은" 코드가 추가되고 있기 때문에 프로그램을 더 크게 만들 수 있다는 것입니다.

그것을 보상하기 위해, 당신은 링커 옵션 -dead_strip을 사용할 수 있습니다.

그 옵션은 링커가 도달할 수 없는 코드와 데이터를 제거하게 할 것이다.

이제, 데드 스트리핑 알고리즘은 빠르고 보통 출력 파일의 크기를 줄임으로써 비용을 지불한다.

하지만 -all_load와 -dead_strip을 사용하는 데 관심이 있다면, 특정 경우에 대한 승리인지 확인하기 위해 이러한 옵션이 있거나 없는 링커의 시간을 정해야 합니다.

다음 링커 옵션은 -no_exported_symbols입니다.

여기 약간의 배경이 있어.

링커가 생성하는 LINKEDIT 세그먼트의 한 부분은 내보내기 트리이며, 이는 내보낸 모든 기호 이름, 주소 및 플래그를 인코딩하는 접두사 트리입니다.

모든 딜리브는 내보낸 기호가 있어야 하는 반면, 메인 앱 바이너리는 일반적으로 내보낸 기호가 필요하지 않습니다.

즉, 보통 어떤 것도 주요 실행 파일에서 기호를 찾는 것이 없다.

그렇다면, 앱 대상에 -no_exported_symbols를 사용하여 LINKEDIT에서 trie 데이터 구조 생성을 건너뛸 수 있으며, 이는 링크 시간을 향상시킬 수 있습니다.

하지만 앱이 메인 실행 파일로 다시 연결되는 플러그인을 로드하거나 xctest 번들을 실행하기 위해 호스트 환경으로 앱과 함께 xctest를 사용하는 경우, 앱에는 모든 내보내기가 있어야 합니다. 즉, 해당 구성에 -no_exported_symbols를 사용할 수 없습니다.

이제, 수출이 크면 수출을 억제하려고 노력하는 것이 합리적이다.

여기에 표시된 dyld_info 명령을 실행하여 내보낸 기호의 수를 셀 수 있습니다.

우리가 본 하나의 큰 앱에는 약 백만 개의 내보낸 기호가 있었다.

그리고 링커는 그 많은 기호에 대한 수출 시도를 만드는 데 2초에서 3초가 걸렸다.

그래서 -no_exported_symbols를 추가하면 해당 앱의 링크 시간이 2~3초 단축되었습니다.

이 이야기의 뒷부분에서 dyld_info 도구에 대해 더 자세히 알려드리겠습니다.

다음 옵션은: -no_deduplicate.

몇 년 전 우리는 같은 지침이지만 다른 이름을 가진 기능을 병합하기 위해 링커에 새로운 패스를 추가했습니다.

C++ 템플릿 확장을 사용하면 많은 것을 얻을 수 있다는 것이 밝혀졌습니다.

하지만 이것은 비싼 알고리즘이다.

링커는 중복을 찾기 위해 모든 함수의 명령을 재귀적으로 해시해야 한다.

비용 때문에, 우리는 알고리즘을 제한하여 링커가 약한 정의 기호만 볼 수 있도록 했다.

그것들은 C++ 컴파일러가 인라인되지 않은 템플릿 확장을 위해 방출하는 것들이다.

이제, de-dup은 크기 최적화이며, 디버그 빌드는 크기가 아니라 빠른 빌드에 관한 것입니다.

따라서 기본적으로 Xcode는 디버그 구성을 위한 링커에 -no_deduplicate를 전달하여 디업 최적화를 비활성화합니다.

그리고 clang은 또한 -O0로 clang 링크 라인을 실행하면 링커에 no-dedup 옵션을 전달할 것입니다.

요약하자면, C++를 사용하고 사용자 지정 빌드가 있는 경우, 즉 Xcode에서 비표준 구성을 사용하거나 다른 빌드 시스템을 사용하는 경우, 디버그 빌드가 링크 시간을 개선하기 위해 -no_deduplicate를 추가하도록 해야 합니다.

내가 방금 이야기한 옵션은 ld에 대한 실제 명령줄 인수이다.

Xcode를 사용할 때, 제품 빌드 설정을 변경해야 합니다.

빌드 설정에서 "다른 링커 플래그"를 찾으세요.

여기 당신이 -all_load로 설정할 것이 있습니다.

그리고 "데드 코드 스트리핑" 옵션도 여기에 있습니다.

그리고 -no_exported_symbols가 있다.

그리고 여기 -no_deduplicate가 있습니다.

이제 정적 라이브러리를 사용할 때 경험할 수 있는 몇 가지 놀라움에 대해 이야기해 봅시다.

첫 번째 놀라움은 앱이 연결된 정적 라이브러리에 빌드되는 소스 코드가 있고 그 코드가 최종 앱에서 끝나지 않을 때입니다.

예를 들어, 일부 기능에 "사용된 속성"을 추가했거나 Objective-C 카테고리가 있습니다.

링커가 하는 선택적 로딩 때문에, 정적 라이브러리의 개체 파일이 링크 중에 필요한 기호를 정의하지 않으면, 그 개체 파일은 링커에 의해 로드되지 않습니다.

또 다른 흥미로운 상호 작용은 정적 라이브러리와 데드 스트리핑이다.

데드 스트리핑은 많은 정적 라이브러리 문제를 숨길 수 있다는 것이 밝혀졌다.

일반적으로 기호나 중복 기호가 누락되면 링커에 오류가 발생합니다.

하지만 데드 스트리핑은 링커가 메인에서 시작하여 모든 코드와 데이터에 걸쳐 도달 가능성 패스를 실행하게 하며, 누락된 기호가 도달할 수 없는 코드에서 나온 것으로 밝혀지면, 링커는 누락된 기호 오류를 억제할 것이다.

마찬가지로, 정적 라이브러리에서 중복된 기호가 있다면, 링커는 오류가 아닌 첫 번째 기호를 선택할 것이다.

정적 라이브러리를 사용하는 마지막 큰 놀라움은 정적 라이브러리가 여러 프레임워크에 통합될 때이다.

각 프레임워크는 개별적으로 잘 실행되지만, 어느 시점에서 일부 앱은 두 프레임워크를 모두 사용하며, 여러 정의로 인해 이상한 런타임 문제가 발생합니다.

가장 일반적인 경우는 동일한 클래스 이름의 여러 인스턴스에 대한 Objective-C 런타임 경고입니다.

전반적으로, 정적 라이브러리는 강력하지만, 함정을 피하려면 그것들을 이해해야 합니다.

그것은 정적 연결을 마무리한다.

이제, 동적 연결로 넘어가자.

먼저, 정적 라이브러리와의 정적 연결에 대한 원본 다이어그램을 살펴봅시다.

이제 점점 더 많은 소스 코드가 있기 때문에 시간이 지남에 따라 이것이 어떻게 확장될지 생각해 보세요.

점점 더 많은 도서관을 이용할 수 있게 됨에 따라, 최종 프로그램의 크기가 커질 수 있다는 것은 분명해야 한다.

그것은 그 프로그램을 구축하기 위한 정적 링크 시간도 시간이 지남에 따라 증가할 것이라는 것을 의미한다.

이제 이 도서관들이 어떻게 만들어지는지 봅시다.

만약 우리가 이 스위치를 했다면?

우리는 'ar'를 'ld'로 변경하고 출력 라이브러리는 이제 실행 가능한 바이너리입니다.

이것은 90년대에 역동적인 도서관의 시작이었다.

속기로서, 우리는 동적 라이브러리를 "dylibs"라고 부른다.

다른 플랫폼에서는 DSO 또는 DLL로 알려져 있다.

그래서 여기서 정확히 무슨 일이 일어나고 있는 거야?

그리고 그것이 확장성에 어떻게 도움이 되나요?

핵심은 정적 링커가 동적 라이브러리와의 연결을 다르게 취급한다는 것이다.

라이브러리에서 최종 프로그램으로 코드를 복사하는 대신, 링커는 일종의 약속을 기록한다.

즉, 동적 라이브러리에서 사용된 기호 이름과 런타임에 라이브러리의 경로가 무엇인지 기록합니다.

이게 어떻게 장점이야?

그것은 당신의 프로그램 파일 크기가 당신의 통제 하에 있다는 것을 의미합니다.

그것은 단지 당신의 코드와 런타임에 필요한 동적 라이브러리 목록을 포함합니다.

당신은 더 이상 프로그램에서 라이브러리 코드의 복사본을 받지 못합니다.

프로그램의 정적 링크 시간은 이제 코드의 크기에 비례하며, 연결하는 딜리브의 수와는 무관합니다.

또한, 가상 메모리 시스템은 이제 빛날 수 있다.

여러 프로세스에서 사용되는 동일한 동적 라이브러리를 볼 때, 가상 메모리 시스템은 해당 딜리브를 사용하는 모든 프로세스에서 해당 딜리브에 대해 동일한 물리적 RAM 페이지를 재사용합니다.

동적 라이브러리가 어떻게 시작되었고 어떤 문제를 해결하는지 보여드리겠습니다.

하지만 그 "이익"에 대한 "비용"은 무엇인가요?

첫째, 동적 라이브러리를 사용하는 것의 이점은 우리가 빌드 시간을 가속화했다는 것이다.

하지만 비용은 이제 앱을 실행하는 것이 더 느리다는 것입니다.

이것은 실행이 더 이상 하나의 프로그램 파일을 로드하는 것이 아니기 때문이다.

이제 모든 딜리브도 함께 로드하고 연결해야 합니다.

즉, 당신은 빌드 시간에서 시작 시간까지 연결 비용의 일부를 연기했습니다.

둘째, 동적 라이브러리 기반 프로그램은 더 더러운 페이지를 가질 것이다.

정적 라이브러리의 경우, 링커는 모든 정적 라이브러리의 모든 전역을 메인 실행 파일의 동일한 데이터 페이지로 공동 배치할 것이다.

하지만 딜리브와 함께, 각 라이브러리에는 데이터 페이지가 있다.

마지막으로, 동적 연결의 또 다른 비용은 새로운 것에 대한 필요성을 도입한다는 것이다: 동적 링커!

빌드 타임에 실행 파일에 기록된 그 약속을 기억하시나요?

이제 우리는 런타임에 도서관을 로드하겠다는 약속을 이행할 무언가가 필요하다.

그것이 다이나믹 링커인 dyld를 위한 것이다.

런타임에 동적 연결이 어떻게 작동하는지 알아봅시다.

실행 가능한 바이너리는 세그먼트로 나뉘며, 보통 적어도 TEXT, DATA 및 LINKEDIT이다.

세그먼트는 항상 OS의 페이지 크기의 배수이다.

각 세그먼트는 다른 허가를 가지고 있다.

예를 들어, TEXT 세그먼트에는 "실행" 권한이 있습니다.

그것은 CPU가 페이지의 바이트를 기계 코드 명령으로 처리할 수 있다는 것을 의미한다.

런타임에, dyld는 여기에 표시된 바와 같이 각 세그먼트의 권한으로 실행 파일을 메모리로 mmap()해야 합니다.

세그먼트는 페이지 크기와 페이지 정렬이기 때문에 가상 메모리 시스템은 프로그램이나 dylib 파일을 VM 범위의 백업 저장소로 쉽게 설정할 수 있습니다.

즉, 해당 페이지에 메모리 액세스가 있을 때까지 RAM에 로드되지 않으며, 이는 페이지 오류를 유발하여 VM 시스템이 파일의 적절한 하위 범위를 읽고 필요한 RAM 페이지를 콘텐츠로 채우게 합니다.

하지만 매핑만으로는 충분하지 않다.

어떻게든 그 프로그램은 "연결"되거나 딜립에 바인딩되어야 한다.

그것을 위해 우리는 "픽스업"이라는 개념을 가지고 있다.

다이어그램에서, 우리는 프로그램이 사용하는 딜리브의 부분에 대한 포인터를 설정한 것을 볼 수 있다.

픽업이 무엇인지 알아봅시다.

여기 우리 친구, 마흐오 파일이 있습니다.

이제, 텍스트는 불변이다.

그리고 사실, 그것은 코드 서명을 기반으로 하는 시스템에 있어야 한다.

그래서 malloc()을 호출하는 함수가 있다면 어떨까요?

그게 어떻게 작동할 수 있어?

프로그램이 구축되었을 때 _malloc의 상대적인 주소를 알 수 없습니다.

음, 정적 링커는 malloc이 dylib에 있는 것을 보고 콜 사이트를 변형시켰다는 것이다.

호출 사이트는 동일한 TEXT 세그먼트의 링커에 의해 합성된 스텁에 대한 호출이 되므로, 상대 주소는 빌드 시간에 알려져 있으며, 이는 BL 명령이 올바르게 형성될 수 있음을 의미합니다.

그것이 도움이 되는 방법은 스텁이 데이터에서 포인터를 로드하고 그 위치로 점프한다는 것이다.

이제, 런타임에 텍스트를 변경할 필요가 없습니다. 데이터만 dyld에 의해 변경됩니다.

사실, dyld를 이해하는 비결은 dyld가 수행한 모든 수정이 데이터에서 포인터를 설정하는 dyld일 뿐이라는 것이다.

그러니 딜드가 하는 수정에 대해 더 자세히 알아보자.

LINKEDIT의 어딘가에는 수정을 추진하는 데 필요한 정보가 있다.

두 종류의 수정이 있다.

첫 번째는 리베이스라고 불리며, 딜리브나 앱에 그 자체를 가리키는 포인터가 있을 때이다.

이제 dyld가 임의의 주소에서 dylibs를 로드하도록 하는 ASLR이라는 보안 기능이 있습니다.

그리고 그것은 그 내부 포인터가 빌드 시간에만 설정될 수 없다는 것을 의미한다.

대신, dyld는 출시 시 포인터를 조정하거나 "리베이스"해야 한다.

디스크에서, dylib가 주소 0에 로드될 경우, 그 포인터는 대상 주소를 포함한다.

그렇게 하면, LINKEDIT이 기록해야 하는 모든 것은 각 리베이스 위치의 위치이다.

그런 다음 Dyld는 dylib의 실제 로드 주소를 각 리베이스 위치에 추가하여 올바르게 수정할 수 있습니다.

두 번째 종류의 수정은 바인딩이다.

바인딩은 상징적인 참고 문헌이다.

즉, 그들의 목표는 숫자가 아니라 기호 이름이다.

예를 들어, "malloc" 함수에 대한 포인터.

문자열 "_malloc"은 실제로 LINKEDIT에 저장되며, dyld는 그 문자열을 사용하여 libSystem.dylib의 내보내기 트리에서 malloc의 실제 주소를 찾습니다.

그런 다음, dyld는 바인딩에 의해 지정된 위치에 그 값을 저장합니다.

올해 우리는 "체인 픽스업"이라고 부르는 픽스업을 인코딩하는 새로운 방법을 발표합니다.

첫 번째 장점은 LINKEDIT을 더 작게 만든다는 것이다.

LINKEDIT은 모든 수정 위치를 저장하는 대신, 새로운 형식은 각 데이터 페이지에 첫 번째 수정 위치가 있는 곳과 가져온 기호 목록을 저장하기 때문에 더 작습니다.

그런 다음 나머지 정보는 수정이 궁극적으로 설정될 장소인 데이터 세그먼트 자체에 인코딩됩니다.

이 새로운 형식은 픽스업 위치가 함께 "연결"되어 있다는 사실에서 체인으로 연결된 픽업이라는 이름을 얻었다.

LINKEDIT는 첫 번째 수정이 어디에 있었는지 말하고, 데이터의 64비트 포인터 위치에서 일부 비트는 다음 수정 위치에 대한 오프셋을 포함합니다.

또한 픽업이 바인드인지 리베이스인지를 말하는 것이 조금 포장되어 있다.

그것이 바인드라면, 나머지 비트는 기호의 인덱스이다.

리베이스라면, 나머지 비트는 이미지 내의 대상의 오프셋이다.

마지막으로, 체인 수정에 대한 런타임 지원은 이미 iOS 13.4 이상에 존재합니다.

즉, 배포 대상이 iOS 13.4 이상인 한, 오늘 이 새로운 형식을 사용할 수 있습니다.

그리고 체인 수정 형식은 우리가 올해 발표하는 새로운 OS 기능을 가능하게 한다.

하지만 그것을 이해하기 위해, 나는 dyld가 어떻게 작동하는지에 대해 이야기해야 한다.

Dyld는 주요 실행 파일로 시작합니다 - 앱을 말하세요.

종속적인 딜리브, 즉 필요한 동적 라이브러리를 찾기 위해 mach-o를 구문 분석한다.

그것은 그 딜리브와 mmap()를 찾는다.

그런 다음 그들 각각에 대해, 그것은 그들의 mach-o 구조를 재귀하고 구문 분석하여 필요에 따라 추가 딜리브를 로드합니다.

모든 것이 로드되면, dyld는 필요한 모든 바인딩 기호를 찾고 수정을 할 때 그 주소를 사용합니다.

마지막으로, 모든 수정이 완료되면, dyld는 이니셜라이저를 아래에서 위로 실행합니다.

5년 전에 우리는 새로운 딜드 기술을 발표했다.

우리는 위의 녹색 단계가 당신의 앱이 시작될 때마다 동일하다는 것을 깨달았습니다.

따라서 프로그램과 dylibs가 변경되지 않는 한, 녹색의 모든 단계는 첫 번째 출시 시 캐시되고 후속 출시에서 재사용될 수 있다.

올해 우리는 추가적인 성능 개선을 발표할 것이다.

우리는 "페이지 인 링크"라고 불리는 새로운 딜드 기능을 발표하고 있습니다.

실행 시 모든 딜립에 모든 픽업을 적용하는 대신, 커널은 이제 페이지인에서 데이터 페이지에 게으르게 픽업을 적용할 수 있습니다.

Mmap()ed 영역의 일부 페이지에서 일부 주소를 처음 사용하면 커널이 해당 페이지에서 읽도록 트리거되었습니다.

하지만 이제, 그것이 데이터 페이지라면, 커널은 페이지에 필요한 수정 사항도 적용할 것이다.

우리는 10년 넘게 딜드 공유 캐시의 OS dylibs에 대한 페이지인 링크의 특별한 경우가 있었다.

올해 우리는 그것을 일반화하고 모든 사람이 이용할 수 있도록 했다.

이 메커니즘은 더러운 메모리와 발사 시간을 줄인다.

그것은 또한 DATA_CONST 페이지가 깨끗하다는 것을 의미하며, 이는 메모리 압력을 줄이는 TEXT 페이지처럼 쫓겨나고 다시 만들 수 있다는 것을 의미합니다.

이 페이지인 링크 기능은 iOS, macOS 및 watchOS의 출시에 포함될 것입니다.

하지만 페이지인 링크는 체인 고정으로 만들어진 바이너리에서만 작동합니다.

그것은 체인 수정을 통해 대부분의 수정 정보가 디스크의 데이터 세그먼트에 인코딩되기 때문에, 이는 페이지 입력 중에 커널에서 사용할 수 있다는 것을 의미합니다.

한 가지 주의할 점은 dyld가 출시 중에만 이 메커니즘을 사용한다는 것이다.

나중에 dlopen()된 모든 dylibs는 페이지인 링크를 받지 못한다.

이 경우, dyld는 전통적인 경로를 취하고 dlopen 통화 중에 수정을 적용합니다.

그것을 염두에 두고, dyld 워크플로우 다이어그램으로 돌아가자.

5년 동안, dyld는 첫 번째 발사에서 작동하는 작업을 캐싱하고 이후 발사에서 재사용함으로써 위의 단계를 녹색으로 최적화해 왔다.

이제, dyld는 실제로 수정을 하지 않고 커널이 페이지에서 게으르게 하도록 함으로써 "적용 수정" 단계를 최적화할 수 있다.

이제 dyld의 새로운 기능을 보았으니, 동적 연결에 대한 모범 사례에 대해 이야기해 봅시다.

동적 링크 성능을 개선하기 위해 무엇을 할 수 있나요?

내가 방금 보여줬듯이, dyld는 이미 동적 연결의 대부분의 단계를 가속화했다.

당신이 통제할 수 있는 한 가지는 당신이 얼마나 많은 딜리브를 가지고 있는지입니다.

딜리브가 많을수록, 그것들을 로드하기 위해 더 많은 일을 해야 한다.

반대로, 딜리브가 적을수록, 딜드가 수행해야 하는 일이 줄어든다.

다음으로 볼 수 있는 것은 항상 사전 메인으로 실행되는 코드인 정적 이니셜라이저입니다.

예를 들어, 정적 이니셜라이저에서 I/O나 네트워킹을 하지 마세요.

몇 밀리초 이상 걸릴 수 있는 모든 것은 이니셜라이저에서 해서는 안 됩니다.

아시다시피, 세상은 점점 더 복잡해지고 있으며, 사용자들은 더 많은 기능을 원합니다.

그래서 그 모든 기능을 관리하기 위해 라이브러리를 사용하는 것이 합리적이다.

당신의 목표는 동적 라이브러리와 정적 라이브러리 사이의 스윗 스팟을 찾는 것입니다.

정적 라이브러리가 너무 많고 반복적인 빌드/디버그 주기가 느려집니다.

반면에, 너무 많은 동적 라이브러리와 출시 시간이 느리고 고객이 알아차립니다.

하지만 우리는 올해 ld64를 가속화했기 때문에, 이제 더 많은 정적 라이브러리 또는 더 많은 소스 파일을 앱에서 직접 사용할 수 있고 여전히 같은 시간에 빌드할 수 있기 때문에 당신의 스윗 스팟이 변경되었을 수 있습니다.

마지막으로, 설치된 기반에서 작동하는 경우, 새로운 배포 대상으로 업데이트하면 체인 수정을 생성하고, 바이너리를 더 작게 만들고, 출시 시간을 개선할 수 있습니다.

여러분 모두가 알고 싶은 마지막 것은 연결 과정을 들여다보는 데 도움이 될 두 가지 새로운 도구입니다.

첫 번째 도구는 dyld_usage이다.

당신은 그것을 사용하여 딜드가 무엇을 하고 있는지 추적할 수 있습니다.

이 도구는 macOS에서만 사용할 수 있지만, 시뮬레이터에서 앱 실행을 추적하거나 앱이 Mac Catalyst용으로 빌드된 경우 이를 사용할 수 있습니다.

다음은 macOS에서 텍스트 편집기에 대해 실행되는 예입니다.

상위 몇 줄에서 알 수 있듯이, 출시는 전체적으로 15ms가 걸렸지만, 페이지인 링크 덕분에 수정에는 1ms밖에 걸리지 않았습니다.

대부분의 시간은 이제 정적 이니셜라이저에 소비된다.

다음 도구는 dyld_info입니다.

디스크와 현재 딜드 캐시 모두에서 바이너리를 검사하는 데 사용할 수 있습니다.

이 도구에는 많은 옵션이 있지만, 수출과 수정을 보는 방법을 보여드리겠습니다.

여기서 -fixup 옵션은 처리될 모든 수정 위치와 목표를 보여줍니다.

출력은 파일이 이전 스타일 픽업이든 새로운 체인 픽업이든 상관없이 동일합니다.

여기서 -exports 옵션은 dylib에서 내보낸 모든 기호와 dylib의 시작부터 각 기호의 오프셋을 표시합니다.

이 경우, 딜드 캐시의 딜리브인 Foundation.framework에 대한 정보를 보여주고 있다.

디스크에는 파일이 없지만, dyld_info 도구는 dyld와 동일한 코드를 사용하므로 찾을 수 있습니다.

이제 정적 대 동적 라이브러리의 역사와 절충을 이해했으므로, 앱이 하는 일을 검토하고 스윗 스팟을 찾았는지 결정해야 합니다.

다음으로, 큰 앱이 있고 빌드가 연결하는 데 시간이 걸린다는 것을 알아차렸다면, 새로운 더 빠른 링커가 있는 Xcode 14를 사용해 보세요.

여전히 정적 링크 속도를 높이고 싶다면, 내가 자세히 설명한 세 가지 링커 옵션을 살펴보고 빌드에서 의미가 있는지 확인하고 링크 시간을 개선하세요.

마지막으로, iOS 13.4 이상용 앱과 임베디드 프레임워크를 구축하여 체인 수정을 활성화할 수도 있습니다.

그런 다음 iOS 16에서 앱이 더 작고 더 빨리 실행되는지 확인하세요.

봐줘서 고마워, 그리고 멋진 WWDC 보내.