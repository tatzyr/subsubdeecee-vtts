10101

♪ 기악 힙합 음악 ♪

안녕 그리고 환영해.

제 이름은 Apple의 GPU 소프트웨어 팀의 Alè Segovia Azapian입니다.

그리고 저는 GPU 소프트웨어 팀의 Mayur입니다.

Alè: 이 세션에서 우리는 바인딩리스 렌더링에 대해 이야기할 것입니다.

바인드리스 바인딩 모델은 셰이더에 리소스를 제공하는 현대적인 방법으로, 레이 트레이싱과 같은 고급 렌더링 기술을 잠금 해제합니다.

오늘은 바인드리스 바인딩 모델이 어떻게 작동하는지, 그리고 메탈 3로 게임과 앱에서 어떻게 바인드리스를 쉽게 채택할 수 있는지에 대한 간략한 요약부터 시작하겠습니다.

바인드리스 렌더링은 데이터를 집계하여 CPU와 GPU의 성능을 향상시킬 수 있는 새로운 기회를 열어줍니다.

오늘 CPU와 GPU 시간을 개선하기 위한 두 가지 구체적인 팁을 드리겠습니다.

그런 다음 나는 그것을 Mayur에게 넘길 것이고, 그는 그 도구가 당신이 바인딩리스 모델을 채택하는 데 어떻게 도움이 될 수 있는지 보여줄 것이다.

바인딩리스 모델에서, 자원은 집계되고 인수 버퍼와 함께 연결된다.

개념적으로, 이것이 이것의 모습이다.

이 예에서, 배열은 장면의 모든 메쉬를 집계한다.

각 리소스를 파이프라인의 특정 슬롯에 독립적으로 바인딩하는 전통적인 바인딩 모델과 달리, 바인딩리스 모델에서 리소스는 먼저 메모리에서 함께 연결됩니다.

이를 통해 셰이더가 자유롭게 탐색하고 정교한 표면과 조명을 계산하는 데 필요한 리소스에 액세스할 수 있는 단일 버퍼를 바인딩할 수 있습니다.

앱이 바인딩이 없어진 후, 레이 트레이싱 셰이더는 반사를 아름답게 음영하는 데 필요한 모든 데이터에 액세스할 수 있습니다.

이 앱은 바닥, 트럭, 재료, 심지어 하늘을 포함한 3D 모델과 텍스처를 모든 데이터를 인수 버퍼에 배치하여 레이 트레이싱 셰이더에서 사용할 수 있도록 합니다.

더 좋은 것은, 바인드리스 렌더링이 힙과 같은 다른 금속 기능과 페어링될 때, 앱 및 게임은 CPU에 대한 압력이 적기 때문에 더 나은 성능을 즐길 수 있습니다.

바인딩리스 렌더링에 유용할 수 있는 메탈 3의 네 가지 특정 개선 사항에 대해 이야기하겠습니다.

인수 버퍼는 자원을 함께 연결할 수 있는 기본적인 금속 구조입니다.

그들은 텍스처와 다른 버퍼와 같은 자원을 참조한다.

메탈 3은 이제 더 이상 인수 인코더 객체가 필요하지 않기 때문에 인수 버퍼를 그 어느 때보다 쉽게 작성할 수 있습니다.

그리고 무제한 배열도 마찬가지입니다.

이제 메탈 힙에서 가속 구조를 할당할 수 있으며 셰이더 유효성 검사 레이어는 리소스가 GPU 메모리에 상주하지 않을 때 알려줍니다.

함께, 이 네 가지 기능은 그 어느 때보다 쉽게 바인딩을 할 수 있게 해준다.

특히, 메탈 3에서 논쟁 버퍼를 쓰는 것은 기쁨이다.

장면을 인수 버퍼로 인코딩하려면, 인스턴스, 메쉬, 재료 및 텍스처와 같은 장면 데이터를 이러한 버퍼에 기록합니다.

메탈 2에서, 이것은 인수 인코더로 이루어진다.

그래서 먼저, 이 객체들이 어떻게 작동하는지 요약한 다음, Metal 3가 당신의 코드를 단순화하는 데 어떻게 도움이 되는지 보여드리겠습니다.

인수 인코더를 사용하면, 첫 번째 단계는 인코더 인스턴스를 만드는 것이다.

셰이더 함수 반사를 통해 또는 구조체 멤버를 금속에 설명함으로써 이것을 합니다.

인코더 인스턴스를 사용하여, 기록 대상을 설정하고 대상 인수 버퍼로 오프셋하십시오.

그리고 그 방법을 사용하여 버퍼에 데이터를 쓰세요.

인수 버퍼와 인수 인코더에 대한 자세한 재교육을 위해 작년의 바인딩리스 세션을 확인하세요.

이제 이 메커니즘은 훌륭하지만, 인코더 객체는 때때로 관리하기 어려울 수 있다.

금속은 인수 인코더를 만들기 위한 두 가지 메커니즘을 제공한다.

어느 것이 당신의 앱에 적합한지 명확하지 않을 수 있습니다.

또한, 여러 스레드에서 인수 인코더를 사용하려면 주의가 필요합니다.

개발자들은 C 구조자를 작성하는 방법을 직관적으로 이해하고, Metal 3을 사용하면 이제 인수 버퍼를 위해 그렇게 할 수 있습니다.

메탈 3은 다른 CPU 측 구조와 마찬가지로 직접 쓸 수 있도록 하여 인수 버퍼 쓰기를 단순화합니다.

이제 가상 GPU 주소와 리소스 ID에 액세스할 수 있습니다.

이것들을 인수 버퍼에 직접 쓸 때, Metal은 이제 당신이 어떤 자원을 참조하고 있는지 이해합니다.

인코더가 더 이상 필요하지 않다는 점을 제외하고는 인수 인코더를 사용하여 참조를 인코딩하는 것과 기능적으로 동일합니다.

이 기능은 인수 버퍼 계층 2를 지원하는 모든 장치를 지원합니다.

즉, 2016년 이상의 모든 Mac과 A13 바이오닉 칩 이상이 장착된 모든 iOS 기기입니다.

장치가 인수 버퍼 2 계층을 지원하는지 확실하지 않은 경우, 사용할 수 있는 MTLDevice 객체에 편리한 기능 쿼리가 있습니다.

이것이 현재 메탈 3의 과정이다.

먼저, 버퍼 주소의 경우 64비트 유형과 텍스처의 경우 MTLResourceID를 사용하여 CPU가 보이는 구조체를 정의하십시오.

그런 다음, 인수 버퍼를 할당하세요.

MTLDevice 또는 MTLHeap에서 직접 버퍼를 할당합니다.

버퍼의 내용을 가져와 인수 버퍼 구조체 유형으로 캐스팅합니다.

그리고 마지막으로, 구조와 구성원에게 주소와 리소스 ID를 작성하세요.

하이브리드 렌더링 데모에서 이것이 어떻게 이루어지는지 보세요.

여기 코드가 있습니다. 그게 얼마나 간단한지 알아봐.

호스트 측 구조체는 노멀 버퍼의 GPU 주소를 직접 저장합니다.

이것은 64비트 부호 없는 정수이기 때문에 나는 uint64_t를 사용했다.

이제 인코더 객체가 없기 때문에, 인수 버퍼에 구조체의 크기를 사용하기만 하면 됩니다.

메탈은 GPU와 CPU 구조체의 크기와 정렬이 클랭과 메탈 셰이더 컴파일러와 일치하도록 보장합니다.

다음으로, 평소와 같이 버퍼를 할당하세요.

그리고 버퍼의 저장 모드가 관리되거나 공유되는 경우, 버퍼에 대한 직접 포인터를 가져와 구조체 유형으로 캐스팅하십시오.

그리고 마지막으로, 노멀 멤버를 gpuAddress로 설정하고, 선택적으로 GPU의 메모리 요구 사항에 맞춰야 하는 오프셋을 설정하십시오.

내가 강조하고 싶은 한 가지는 금속 셰이딩 언어와 C 선언 사이에서 구조 선언이 어떻게 변하는지이다.

이 예에서, 이것들은 별도로 유지되지만, 원한다면, 공유 헤더에 단일 구조체 선언을 가질 수 있으며 조건부 컴파일을 사용하여 셰이더 컴파일러 유형과 C 유형을 구별할 수 있습니다.

여기 C로 통일된 선언이 있습니다.

__METAL_VERSION__ 매크로는 셰이더 코드를 컴파일할 때만 정의됩니다.

헤더 선언에서 GPU와 CPU 코드를 분리하는 데 사용하세요.

앱이 C++를 대상으로 하는 경우, 이를 더 발전시키고 템플릿을 사용하여 선언을 더욱 균일하게 만들 수 있습니다.

모범 사례를 위해 인수 버퍼 샘플 코드를 확인하세요.

이제 그것이 하나의 구조자를 작성하는 방법이지만, 무제한 배열을 사용하여 많은 구조자를 작성할 수도 있습니다.

이미 인수 인코더를 사용하여 Metal에서 무제한 배열을 구현할 수 있지만, Metal 3은 구조체 배열을 작성하는 데 더 가깝게 하여 프로세스를 더욱 단순화합니다.

하나의 구조체만 쓰는 것과 다른 것은 다음과 같습니다.

이제 저장하려는 모든 구조체에 충분한 저장 공간을 할당해야 합니다.

그런 다음, 배열을 반복하여 각 구조체에 대한 데이터를 작성하세요.

코드 샘플로 돌아가서, 먼저, 장면에서 메쉬만큼 많은 구조자를 저장하기 위해 버퍼의 크기를 확장하세요.

이것이 CPU 버퍼에 대해 하는 것과 정확히 같은지 주목하세요: 구조체의 크기에 메쉬 수를 곱하세요.

나는 잠시 시간을 내어 이것이 얼마나 강력한지 주목하고 싶다.

이 단일 변수는 배열의 크기를 완전히 제어한다.

셰이더는 어느 시점에서든 이 크기를 메탈 셰이더 컴파일러에 선언할 필요가 없으며 어떤 위치에든 자유롭게 인덱싱할 수 있습니다.

이것은 바인딩리스 모델이 메탈에서 매우 유연한 이유의 일부입니다. 제약 없이 모든 크기의 배열에 액세스하는 셰이더를 작성하기 때문입니다.

그건 그냥 작동해!

다음으로, 이 크기의 버퍼를 할당하고 올바른 메쉬 구조체 유형으로 내용으로 포인터를 캐스팅하세요.

이제 버퍼가 충분히 크기 때문에, 메쉬 구조체의 크기에 걸쳐 간단한 루프로 걸어보세요.

그리고 마지막으로, 배열의 각 구조체의 GPUAddress를 직접 설정하고, 선택적으로 정렬된 오프셋을 설정하십시오.

셰이더의 GPU 측면에서, 이것은 무제한 배열을 나타내는 한 가지 방법이다.

여기서, 나는 그것을 셰이더에 전달하는 메쉬 포인터 매개 변수로 선언한다.

이를 통해 C 어레이와 마찬가지로 콘텐츠에 직접 자유롭게 접근할 수 있습니다.

또 다른 옵션은 모든 무제한 배열을 구조체로 가져오는 것이다.

이것은 한 곳에서 데이터를 집계하여 셰이더를 깔끔하게 유지하는 데 도움이 됩니다.

이 예에서, 모든 메쉬와 재료는 장면 구조체로 합쳐진다.

장면 구조체를 사용하여, 장면은 모든 무제한 배열을 별도로 전달하는 대신 단일 버퍼를 바인딩하여 셰이더로 직접 전달됩니다.

그리고 접근은 이전과 같지만, 이제 메쉬 배열은 장면 구조를 통해 도달된다.

그리고 그것이 Metal 3에서 인수 버퍼와 무제한 배열을 작성하는 방법입니다.

완전히 개선된 API는 이제 더 직관적이고 CPU 구조체 또는 구조체 배열에 대해 수행하는 것과 일치합니다.

올해의 레이 트레이싱 업데이트를 통해, 레이 트레이싱 가속 구조는 버퍼와 텍스처와 함께 메탈 힙에서 할당될 수 있습니다.

이것은 그들이 그들 자신과 다른 자원 유형과 함께 통합될 수 있다는 것을 의미한다.

이것은 훌륭합니다. 왜냐하면 모든 가속 구조를 힙으로 집계할 때, 힙을 사용하기 위한 단일 호출에서 모든 거주자를 표시할 수 있기 때문입니다.

이것은 애플리케이션의 렌더링 스레드에서 상당한 CPU 절감을 위한 큰 기회입니다.

다음은 힙에서 가속 구조로 작업하기 위한 몇 가지 팁입니다.

첫째, 힙에서 할당될 때, 가속 구조는 장치마다 다른 정렬 및 크기 요구 사항을 가지고 있다.

힙 할당을 위한 가속 구조의 크기와 정렬을 확인하는 새로운 쿼리가 있습니다.

MTLDevice의 heapAccelerationStructureSize 및 AlignWithDescriptor 방법을 사용하여 구조 설명자의 SizeAndAlignment를 결정하십시오.

명심하세요, 이것은 MTLDevice의 accelerationStructureSizes WithDescriptor 방법과 다릅니다.

이제 가속 구조가 MTLHeap 객체에 있으니, useHeap을 호출하세요: 한 번의 호출에 모두 상주하도록 하세요.

이것은 각 개별 자원에서 useResource를 호출하는 것보다 빠르다.

그리고 위험 추적에 힙을 선택하지 않는 한, 금속은 그들로부터 할당된 자원에 대한 경쟁 조건을 방지하지 않으므로, 서로와 레이 트레이싱 작업과 가속 구조를 동기화해야 합니다.

하지만 걱정하지 마, 내가 잠시 후에 이것에 대해 더 얘기할게.

메탈 3의 이것과 다른 레이 트레이싱 성능 향상에 대한 자세한 내용은 올해 "메탈 레이 트레이싱 성능 극대화" 강연을 확인하십시오.

힙 할당 가속 구조를 사용하면 가장 중요할 때 앱의 CPU 사용량을 줄일 수 있는 기회를 제공합니다.

마지막으로, 올해 제가 가장 좋아하는 기능 중 하나가 있습니다: 셰이더 유효성 검사 향상.

useResource와 useHeap의 주제에서, 앱이 간접적으로 접근한 모든 자원에 대해 Metal에 거주지를 표시하는 것이 매우 중요합니다.

그것을 하는 것을 잊는 것은 그 자원을 뒷받침하는 메모리 페이지가 렌더링 시간에 존재하지 않을 수도 있다는 것을 의미한다.

이것은 명령 버퍼 실패, GPU 재시작 또는 심지어 이미지 손상을 일으킬 수 있다.

불행히도, 바인드리스 여행을 시작할 때 이러한 문제에 직면하는 것은 매우 일반적입니다. 왜냐하면 바인드리스에서는 대부분의 장면 리소스가 간접적으로 접근되고 셰이더는 런타임에 포인터 탐색 결정을 내리기 때문입니다.

올해 Metal 3은 명령 버퍼 실행 중에 누락된 리소스의 상주를 추적하는 데 도움이 되는 셰이더 유효성 검사 계층에 새로운 기능을 소개합니다.

내가 너에게 구체적인 예를 보여줄게.

하이브리드 렌더링 앱의 업데이트 과정에서, 우리는 반사가 때때로 잘못 보이는 실제 문제에 직면했다.

검증 계층이 이 문제를 진단하고 해결하는 데 어떻게 도움이 되었는지 보여드리겠습니다.

메탈에 레지던시를 표시하기 위해, 앱은 힙에 의해 뒷받침되지 않는 모든 개별 리소스를 로드 시간에 가변 세트에 저장합니다.

이 앱은 버퍼를 추가하고 텍스처를 추가합니다.

렌더링 시간에, 앱이 레이 트레이싱 커널을 발송하기 전에, 그것은 메탈에게 세트의 모든 자원을 사용한다는 것을 나타낸다.

이것은 앱이 세트를 반복하고 각 요소에서 useResource를 호출하는 간단한 과정이다.

그런 다음 금속은 광선 추적 작업을 시작하기 전에 이 모든 자원을 상주하게 한다.

다음은 앱이 이 세트로 리소스를 수집하는 코드의 일부입니다.

이 앱은 인수 버퍼 작성 과정의 일부로 이것을 한다.

앱의 로딩 기능은 각 서브메시를 반복한다.

인수 버퍼에 쓰는 데 필요한 데이터, 즉 재료에 대한 인덱스 데이터와 텍스처 데이터를 수집한 다음 인덱스 버퍼의 주소를 인수 버퍼에 저장합니다.

재료의 경우, 텍스처 배열을 반복하여 텍스처 GPU 리소스 ID를 인수 버퍼에 기록합니다.

그리고 마지막에, 서브메시 자료의 모든 개별 텍스처를 장면 리소스 세트에 추가하여 파견 시간에 거주자를 표시할 수 있습니다.

불행히도, 여기에 미묘한 버그가 있다.

앱은 명령 버퍼를 실행할 것이며, 어떤 경우에는 반사가 누락될 것이다.

이전에는 이것을 추적하기가 어려웠다.

이제 메탈 3에서 셰이더 검증 레이어가 구출된다.

이러한 종류의 문제는 이제 명령 버퍼 실행 중에 오류가 발생하여 문제가 무엇인지 나타냅니다.

오류 메시지는 문제를 유발한 셰이더 함수의 이름, 패스의 이름, 액세스를 감지한 금속 파일 및 코드 줄, 심지어 버퍼의 레이블, 크기 및 거주자가 아니라는 사실을 나타냅니다.

프로 팁으로, 이것이 금속 물체에 라벨을 붙이는 것이 항상 좋은 관행인 이유입니다.

이 도구는 라벨을 사용하며, 이는 앱을 디버깅하는 동안 어떤 객체인지 식별하려고 할 때 유용합니다.

이 모든 세부 정보를 가지고 있기 때문에, 이제 셰이더 코드에서 누락된 리소스를 쉽게 찾을 수 있습니다.

더 좋은 점은 디버그 중단점이 활성화되면 Xcode가 셰이더 유효성 검사가 문제를 감지하는 셰이더 코드의 정확한 줄을 편리하게 보여준다는 것입니다.

데모 앱의 경우, 상주하지 않는 것은 인덱스 버퍼이다.

그 해결책은 이제 간단하다.

코드로 돌아가서, 앱은 이제 누락된 인덱스 버퍼를 상주 리소스 세트에 저장합니다.

이러한 변화와 함께, 나중에 레이 트레이싱 시간에, 메탈은 GPU에서 인덱스 버퍼를 사용할 수 있도록 하여 문제를 해결하는 것을 알고 있다.

이것은 필수적인 도구이자 완전한 게임 체인저이며, 잠재적으로 바인딩 없는 여정에서 몇 시간의 디버깅 시간을 절약할 수 있습니다.

그래서 그것들은 당신이 바인드리스 자원을 구성하고 참조하는 데 도움이 되는 Metal 3가 제공하는 개선 사항입니다.

이제 저는 기어를 바꾸고 바인딩이 없을 때 게임의 성능을 극대화하는 방법에 대해 이야기할 것입니다.

이 섹션에서, 나는 두 가지 주제를 다룰 것이다: 유지되지 않은 자원과 추적되지 않은 자원.

이러한 팁은 수명이 길고 집계된 리소스가 있을 때 CPU와 GPU 모두에서 더 많은 성능을 얻는 데 도움이 될 것입니다.

이제, 수명이 긴 자원으로 CPU 성능을 개선하는 방법에 대해 이야기하기 위해, 저는 먼저 금속 자원 수명 주기를 요약할 것입니다.

Objective-C와 Swift는 참조 계산을 통해 객체 수명 주기를 처리합니다.

금속 자원은 이 모델을 따른다.

리소스는 1의 retainCount로 시작하고 모든 강력한 참조가 사라지면 런타임이 할당됩니다.

CPU와 GPU는 병렬로 작동하기 때문에, CPU가 GPU가 여전히 사용하는 동안 retainCount가 0에 도달하도록 허용하여 리소스를 할당하면 문제가 될 것이다.

이를 방지하기 위해, 금속 명령 버퍼는 그들이 사용하는 모든 리소스에 대한 강력한 참조를 생성하여 retainCount가 항상 최소 1이 되도록 합니다.

금속은 setVertexBuffer 또는 setFragmentTexture와 같은 기능을 사용하여 파이프라인에 직접 바인딩하는 리소스에 대한 강력한 참조를 생성합니다. 여기에는 렌더링 첨부 파일도 포함됩니다. useHeap API를 통해 상주 플래그를 지정하는 금속 힙 객체와 useResource API를 통해 상주하는 간접 리소스가 힙의 일부인 경우에도 포함됩니다.

메탈 오브젝트 라이프사이클에 대한 자세한 내용은 올해 "Program Metal in C++ with metal-cpp" 강연을 확인하세요.

이제, Metal이 이러한 참조를 만드는 것은 매우 유용합니다. 왜냐하면 프로그래머로서 GPU가 여전히 사용하는 동안 객체를 할당할 수 있다는 것에 대해 걱정할 필요가 없기 때문입니다.

Metal이 제공하는 이 안전 보증은 실행이 매우 빠르지만, 적은 CPU 비용이 듭니다.

이제, 바인드리스 모델에서, 앱은 리소스를 힙으로 집계하며, 이것들은 애플리케이션의 도메인과 일치하여 오래 지속되는 경향이 있다.

예를 들어, 게임에서, 자원은 전체 레벨의 기간 동안 살아 있다.

이 경우, 금속이 자원 수명 주기에 대한 추가 보증을 제공하는 것은 불필요해진다.

당신이 할 수 있는 것은 메탈 명령 버퍼에게 참조하는 자원을 보유하지 말라고 요청함으로써 이 CPU 비용을 회수하는 것입니다.

메탈의 자동 리소스 유지를 끄려면, 유지되지 않은 참조로 명령 버퍼를 만들기만 하면 됩니다.

일반 명령 버퍼를 만드는 것처럼 MTLCommandQueue에서 직접 이 작업을 수행하십시오.

이미 리소스 수명 주기를 보장하고 있는 한, 앱을 변경할 필요가 없습니다.

이 설정의 세분성 수준은 전체 명령 버퍼라는 것을 명심하세요.

그것은 참조된 모든 자원을 보유하거나 그 중 어느 것도 보유하지 않을 것이다.

작은 마이크로벤치마크에서, 우리는 유지되지 않은 참조가 있는 명령 버퍼로 전환하여 명령 버퍼의 수명 주기에서 2%의 CPU 사용량 감소를 측정했습니다.

하지만 이 시간은 완전히 불필요한 강력한 참조를 만들고 파괴하는 데 쓰였다.

요약하자면, 보유되지 않은 자원은 이미 자원 수명 주기를 보장하고 있을 때 추가 CPU 절감의 기회를 제공합니다.

유지되지 않은 자원과 마찬가지로, 추적되지 않은 자원은 더 많은 성능을 얻기 위해 안전 기능을 비활성화할 수 있는 기회를 제공한다.

많은 시각적 기술은 중간 텍스처로 렌더링하고 버퍼에 쓴 다음 나중에 그것들을 소비하는 것으로 구성되어 있다.

그림자 매핑, 스키닝 및 후처리는 이것의 좋은 예이다.

이제, 자원을 생산하고 즉시 소비하는 것은 읽기 후 쓰기 위험을 초래한다.

또한, 두 개의 렌더링이 동일한 첨부 파일로 드로잉을 통과하거나 두 개의 blit 인코더가 동일한 리소스에 쓰기와 같은 동일한 리소스에 쓰기를 통과할 때, Metal이 GPU에서 작동하는 방식 때문에 쓰기 후 쓰기 위험을 생성합니다.

추적된 리소스를 사용할 때, Metal은 GPU 타임라인의 위험을 피하기 위해 동기화 프리미티브를 자동으로 사용합니다.

예를 들어, 메탈은 GPU가 동일한 버퍼에서 읽는 장면 렌더링 패스를 시작하기 전에 컴퓨팅 스키닝 패스가 버퍼에 쓰기를 마칠 때까지 기다리게 한다.

이것은 훌륭하며, Metal이 접근하기 쉬운 그래픽 API인 이유의 큰 부분이지만, 리소스를 힙으로 집계하는 앱에 대한 몇 가지 성능 고려 사항이 있습니다.

이 예시를 생각해 보세요.

여기서, GPU는 바빠서, 정점 스키닝을 하고, 장면을 렌더링하고, 톤 매핑을 적용하는 두 개의 프레임을 차례로 그립니다.

앱이 GPU를 바쁘게 유지함에 따라, 메탈은 리소스 종속성을 기반으로 렌더링과 컴퓨팅 작업이 겹칠 수 있는 기회를 식별합니다.

의존성이 없고 조건이 맞을 때, 금속 일정은 겹치고 병렬로 실행된다.

이것은 GPU를 포화시키고 같은 양의 벽시계 시간에 더 많은 작업을 수행할 수 있게 해준다.

이제, 앱이 리소스를 힙으로 함께 집계할 때, 모든 하위 리소스는 메탈에 단일 리소스로 나타납니다.

이것이 힙을 작업하기에 매우 효율적으로 만드는 것이다.

하지만 이것은 메탈이 동일한 자원에 대한 읽기 및 쓰기 작업을 보고 실제 위험이 존재하지 않더라도 경쟁 조건을 피하기 위해 보수적으로 작업을 예약해야 한다는 것을 의미합니다.

이 상황은 "거짓 공유"라고 불리며, 예상할 수 있듯이 GPU 작업의 실행 벽시계 시간을 증가시킵니다.

그래서 여기 공연 팁이 있습니다.

힙의 자원 사이에 종속성이 없다는 것을 알고 있다면, 이 행동을 피할 수 있습니다.

잘못된 공유를 피하기 위해, 위험 추적에서 자원을 선택하고 금속에 대한 세밀한 의존성을 직접 알릴 수 있습니다.

리소스 설명자의 hazardTracking 속성을 Untracked로 설정하여 리소스 추적을 선택 해제합니다.

이것은 매우 중요하기 때문에, GPU가 게이트에서 바로 병렬로 작업을 실행할 수 있는 더 많은 기회를 열 수 있기 때문에 힙의 기본 동작입니다.

추적되지 않은 리소스를 사용하기 시작하면, 다음 기본 요소를 사용하여 종속성을 표현합니다.

상황에 따라 울타리, 이벤트, 공유 이벤트 또는 메모리 장벽을 사용하세요.

금속 울타리는 단일 명령 대기열의 컨텍스트 내에서 다른 렌더링 및 컴퓨팅 패스에서 하나 이상의 리소스에 대한 액세스를 동기화합니다.

이것은 일종의 분할 장벽이기 때문에, 소비자 패스는 생산자가 울타리에 신호를 보낼 때까지 기다린다.

Fences를 사용할 때 명심해야 할 유일한 요구 사항은 명령 버퍼를 소비하기 전에 생산자 명령 버퍼를 커밋하거나 대기열에 두는 것입니다.

이 주문을 보장할 수 없거나, 같은 장치에서 여러 대기열을 동기화해야 하는 경우, MTL 이벤트를 사용하세요.

이벤트를 사용하여, 소비자 명령 버퍼는 생산자 명령 버퍼가 주어진 값으로 이벤트에 신호를 보낼 때까지 기다린다.

그것이 값을 신호한 후, 자원을 읽는 것이 안전하다.

이벤트를 사용하여 명령이 이벤트를 나타낼 때까지 GPU에 작업을 일시 중지하도록 지시하십시오.

MTLSharedEvents는 일반 이벤트와 매우 유사하게 작동하지만, 단일 GPU를 넘어서는 더 큰 범위에서 작동합니다.

이것들을 사용하여 다른 금속 장치와 심지어 CPU와도 리소스에 대한 액세스를 동기화하세요.

예를 들어, 공유 이벤트를 사용하여 CPU에서 GPU 계산 결과를 처리하세요.

여기 예시가 있어.

이 경우 GPU는 컴퓨팅 패스에서 메쉬를 벗기고 CPU는 포즈를 디스크에 저장합니다.

이 두 가지는 독립적인 장치이기 때문에, 공유 이벤트를 사용하여 GPU가 리소스를 생성할 때까지 CPU를 기다리게 하십시오.

처음에, CPU는 무조건적으로 GPU가 공유 이벤트에 신호를 보낼 때까지 기다리기 시작한다.

GPU가 리소스를 생성하고 통합 메모리에 배치하면 공유 이벤트에 신호를 보냅니다.

이 시점에서, CPU의 대기 스레드가 깨어나서 자원을 안전하게 소비한다.

마지막 원시 유형은 기억 장벽이다.

메모리 배리어는 단일 렌더링 또는 컴퓨팅 패스 내의 모든 후속 명령을 이전의 모든 명령이 완료될 때까지 기다리도록 합니다.

장벽 비용은 거의 모든 경우에 울타리 비용과 비슷하다.

그러나, 한 가지 예외가 있다.

그 예외는 렌더링 패스의 조각 단계 이후의 장벽이다.

이러한 장벽은 렌더링 패스를 분할하는 것과 유사한 매우 높은 비용을 가지고 있다.

금속은 Apple GPU의 조각 단계 후에 장벽을 비활성화하여 앱이 가장 빠른 드라이버 경로를 유지할 수 있도록 도와줍니다.

Metal 디버그 레이어는 Apple GPU에 사후 조각 장벽을 추가하면 유효성 검사 오류를 생성합니다.

조각 단계 후에 자원을 동기화하기 위해 울타리를 사용하는 것이 좋습니다.

다음은 동기화 프리미티브와 언제 사용해야 하는지에 대한 간략한 요약입니다.

생산자의 단일 명령 대기열에 작업을 커밋하거나 대기열에 넣을 때 가장 낮은 오버헤드를 위해 울타리를 사용하는 것을 선호합니다.

울타리는 대부분의 일반적인 경우에 좋다.

제출 주문을 보장할 수 없거나 여러 명령 대기열이 있는 경우, Metal Events를 사용하세요.

공유 이벤트를 사용하면 여러 GPU와 CPU를 동기화할 수 있습니다.

이러한 특정 다중 장치 경우에만 사용하세요.

패스 내에서 동기화하고 싶은 경우 메모리 장벽을 사용하세요.

장벽은 대부분의 경우 동시 컴퓨팅 패스와 드로우 호출 사이의 정점 단계와 같은 빠른 원시적이다.

하지만 친근한 알림, 조각 단계 후에 동기화하기 위한 장벽 대신 패스 사이에 울타리를 사용하세요. 왜냐하면 이러한 장벽은 매우 비싸고 Apple GPU는 그것을 허용하지 않기 때문입니다.

추적되지 않은 리소스와 수동 미세 추적을 사용하여 이제 GPU 병렬성을 극대화하면서 데이터 집계의 모든 이점을 누릴 수 있습니다.

그리고 그것들은 바인딩이 없을 때 CPU와 GPU를 최대한 활용할 수 있는 성능 팁입니다.

나는 Metal 3가 어떻게 단순화되고 효율적인 바인딩 없는 워크플로우를 잠금 해제하는지에 대해 많이 이야기했다.

하지만 코드를 작성하는 것은 방정식의 절반에 불과하다.

나머지 절반은 사용 가능한 도구가 GPU가 어떻게 작업을 보고 실행하는지 확인하는 데 어떻게 도움이 될 수 있는지입니다.

나는 이제 그것을 Mayur에게 넘겨서 bindless를 위한 Metal 3 툴링의 새로운 기능에 대해 이야기할 것이다.

마유르: 고마워 알레.

오늘, 바인드리스 앱을 디버깅하고 최적화하는 데 도움이 될 메탈 디버거의 훌륭한 새로운 기능 중 일부를 보여드리게 되어 기쁩니다.

방금 알레가 당신에게 보여준 하이브리드 렌더링 앱의 프레임 캡처를 찍었습니다.

메탈 디버거에서 프레임을 캡처하면, 앱의 성능을 개선하는 방법에 대한 유용한 통찰력과 함께 프레임에 대한 개요를 제공하는 요약 페이지에 도착합니다.

하지만 오늘, 저는 당신에게 새로운 의존성 뷰어를 보여드리게 되어 기쁩니다.

그것을 열려면, 여기 왼쪽에 있는 종속성을 클릭하세요.

여기에 새로운 종속성 뷰어가 있으며 강력한 새로운 기능으로 가득 찬 새로운 디자인을 특징으로 합니다.

종속성 뷰어는 작업량의 그래프 기반 표현을 보여줍니다.

그래프의 각 노드는 명령 인코더로 인코딩된 패스와 출력 리소스를 나타냅니다.

가장자리는 패스 간의 자원 의존성을 나타낸다.

올해, 두 가지 유형의 종속성에 집중하여 작업량을 분석할 수 있습니다.

데이터 흐름과 동기화.

실선은 데이터 흐름을 나타내며 앱에서 데이터가 어떻게 흐르는지 보여줍니다.

점선은 동기화를 나타내며 패스 간의 GPU 동기화를 도입하는 종속성을 보여줍니다.

자세한 내용을 보려면 인코더, 리소스 또는 에지를 클릭하면 디버거가 새 사이드바에 많은 자세한 정보를 표시합니다.

예를 들어, 이 에지는 동기화를 추가하고 이러한 패스 사이에 데이터 흐름이 있다.

기본적으로 종속성 뷰어는 데이터 흐름과 동기화 종속성을 모두 보여주지만, 하단의 이 메뉴를 사용하여 종속성 유형 중 하나에만 집중할 수 있습니다.

여기서, 나는 단지 동기화에 집중할 것이다.

Alè가 앞서 말했듯이, 잘못된 공유는 추적된 힙에서 다른 자원을 읽고 쓸 때 일반적인 문제이다.

의존성 뷰어는 이러한 문제를 쉽게 잡을 수 있게 해준다.

내가 캡처한 이 데모는 이 문제가 있는 초기 개발 버전에서 가져온 것이다.

이 힙을 클릭하면, 종속성 뷰어는 이 힙이 추적되어 이 두 패스 간의 동기화를 추가한다는 것을 보여줍니다.

종속성 뷰어는 또한 렌더링 인코더가 저장하는 렌더링 대상 텍스처와 컴퓨팅 인코더가 읽고 쓰는 버퍼와 같은 힙 내부에 할당된 리소스를 강조합니다.

문제는 컴퓨팅 인코더가 이전 인코더의 리소스를 사용하지 않기 때문에 이 두 패스 간의 동기화가 필요하지 않다는 것입니다.

이 종속성을 제거하기 위해, 추적되지 않은 힙을 사용하고 동기화가 필요한 울타리를 삽입하도록 앱을 수정할 수 있습니다.

그 변화로, 이 두 패스는 이제 병렬로 실행될 수 있다.

바인딩리스 앱을 디버깅하는 데 도움이 되는 Xcode 14의 또 다른 큰 개선 사항은 새로운 리소스 목록입니다.

디버깅하고 열고 싶은 드로우 호출로 이동할 수 있습니다.

바인딩리스를 사용할 때, 언제든지 GPU에서 수백 또는 수천 개의 리소스를 사용할 수 있습니다.

올해 메탈 디버거는 상단의 "액세스" 모드를 클릭하여 이러한 리소스 중 어떤 리소스에 액세스했는지 확인할 수 있는 기능을 제공합니다.

이제 디버거는 이 드로우 호출이 액세스하는 소수의 리소스와 각 액세스 유형만 보여줍니다.

이것은 셰이더가 인수 버퍼에서 어떤 리소스에 접근했는지 이해하는 데 정말 유용합니다.

드로우 콜이 어떤 리소스를 사용하는지 아는 것은 좋지만, 예상하지 못했던 리소스를 보여준다면, 셰이더 디버거를 사용하여 무슨 일이 일어나고 있는지 알아낼 수 있습니다.

셰이더 디버거를 시작하려면, 하단 막대에 있는 디버그 버튼을 클릭하고, 디버깅할 픽셀을 선택하고, 디버그 버튼을 누르세요.

그리고 이제 당신은 셰이더 디버거에 있습니다.

셰이더 디버거는 어떤 리소스에 액세스했는지를 포함하여 코드가 한 줄씩 어떻게 실행되었는지 보여줍니다.

이 줄의 경우, 이 셰이더는 인수 버퍼에서 텍스처를 읽습니다.

오른쪽 사이드바에서 자세한 보기를 확장하여 어떤 리소스를 읽었는지 확인할 수 있습니다.

이것은 셰이더가 잘못된 인수 버퍼 요소에 접근하는 문제를 식별하는 데 도움이 될 수 있습니다.

이 데모에서는 새로운 종속성 뷰어를 사용하여 리소스 종속성을 분석하고 검증하는 방법, 새로운 리소스 목록을 사용하여 드로우 호출이 액세스한 리소스를 이해하는 방법, 셰이더 디버거를 사용하여 라인별로 셰이더가 어떻게 실행되었는지 분석하는 방법을 보여주었습니다.

이 새로운 기능을 사용하여 훌륭한 메탈 바인드리스 앱을 만드는 방법을 빨리 보고 싶습니다.

너에게 돌아가, 알레.

알레: 고마워, 마유르. 그건 멋진 데모였어.

마무리하기 위해, 메탈 3은 바인딩리스를 위해 테이블에 많은 것을 가져온다.

단순화된 인수 버퍼 인코딩, 힙의 가속 구조, 유효성 검사 계층 및 도구 개선으로 Metal 3는 게임과 앱에 효과적이고 성능이 뛰어난 바인드리스를 제공하는 훌륭한 API입니다.

올해의 개선 사항으로, 하이브리드 렌더링 앱은 그 어느 때보다 좋아 보인다.

우리는 Metal 샘플 코드 갤러리에 전체 소스 코드가 있는 이 업데이트된 버전의 앱을 출시하고 있습니다.

당신은 그것을 다운로드하고, 공부하고, 수정할 수 있으며, 운동으로, 나는 당신이 그것을 더 나아가 거울 표면에 재귀 반사를 추가하도록 도전합니다.

네가 그걸로 뭘 하는지 빨리 보고 싶어.

메탈 3로 바인드리스로 가기에 더 좋은 시기는 없었다.

봐줘서 고마워.

♪ 기악 힙합 음악 ♪