10114

♪ 기악 힙합 음악 ♪

모두 환영합니다. 제 이름은 데이비드 헤이워드이고, 저는 코어 이미지 팀의 소프트웨어 엔지니어입니다.

오늘은 코어 이미지 애플리케이션에서 확장 다이내믹 레인지 콘텐츠를 표시하는 방법을 설명하겠습니다.

내 이야기는 네 부분으로 나눌 것이다.

먼저, 우리 플랫폼에서 EDR에 대한 몇 가지 중요한 용어를 소개하겠습니다.

둘째, EDR에 대한 지원을 추가하는 방법을 시연하는 데 사용할 새로운 핵심 이미지 샘플 프로젝트를 설명하겠습니다.

마지막으로, CIFilters를 사용하여 EDR 콘텐츠를 생성하는 이미지를 만드는 방법을 보여드리겠습니다.

그래서 몇 가지 핵심 용어부터 시작합시다.

SDR 또는 표준 동적 범위는 검은색의 경우 0에서 흰색의 경우 1의 정규화된 범위를 사용하여 RGB 색상을 나타내는 전통적인 방법입니다.

대조적으로, EDR 또는 확장된 동적 범위는 정상 범위를 넘어서는 RGB 색상을 나타내는 권장되는 방법입니다.

SDR과 마찬가지로, 0은 검은색을 나타내고, 1은 SDR 흰색과 같은 밝기를 나타낸다.

하지만 EDR을 사용하면 1보다 큰 값을 사용하여 더 밝은 픽셀을 나타낼 수 있습니다.

하지만, 하나보다 큰 값은 허용되지만, 헤드룸 위의 값은 잘릴 것이라는 점을 명심하세요.

헤드룸은 디스플레이의 현재 최대 니트를 SDR 흰색의 니트로 나눈 것에서 파생됩니다.

헤드룸 값은 디스플레이마다 또는 주변 조건이나 디스플레이 밝기가 변함에 따라 달라질 수 있습니다.

이러한 개념에 대한 더 깊은 논의를 위해 "iOS에서 EDR 탐색" 프레젠테이션을 보는 것이 좋습니다.

응용 프로그램에 제시할 수 있는 EDR 콘텐츠에 대한 몇 가지 출처가 있습니다.

첫째, TIFF 및 OpenEXR과 같은 일부 파일 형식은 EDR의 부동 소수점 값을 저장할 수 있습니다.

또한, AVFoundation을 사용하여 HDR 비디오 포맷에서 프레임을 얻을 수 있습니다.

Metal API는 EDR 환경을 텍스처로 렌더링하는 데 사용할 수 있습니다.

또한, ProRAW DNG 파일은 EDR 하이라이트를 공개하기 위해 렌더링될 수 있다.

2021년 프레젠테이션 "ProRAW 이미지 캡처 및 처리"는 이것을 자세히 설명합니다.

프레젠테이션의 다음 부분에서는 SwiftUI 애플리케이션에서 Metal과 함께 Core Image를 사용하는 방법을 설명하겠습니다.

나중에, 나는 이 응용 프로그램에 EDR 지원을 추가하는 방법을 간략하게 설명할 것이다.

우리는 최근 SwiftUI 멀티플랫폼 앱에서 Core Image와 Metal Kit View를 결합하는 방법에 대한 모범 사례를 보여주는 새로운 샘플 코드 프로젝트를 발표했습니다.

샘플을 다운로드하고 코드를 보는 것을 추천하지만, 이 기회를 빌어 그것이 어떻게 보이고 작동하는지 보여드리겠습니다.

샘플은 금속 보기에 표시되는 애니메이션, 절차적 CIImage를 그립니다.

최적의 성능을 위해, 샘플은 MTKView를 사용합니다.

코드를 간단하게 유지하기 위해, 앱은 애니메이션 체커보드 CIImage를 앱이 원하는 콘텐츠의 프록시로 표시합니다.

또한, 이 앱은 SwiftUI를 사용하여 macOS, iOS 및 iPadOS 플랫폼에서 공통 코드 기반을 사용할 수 있습니다.

이 프로젝트는 몇 개의 짧은 소스 파일로 만들어졌으므로, 수업이 어떻게 상호 작용하는지 설명하겠습니다.

이 응용 프로그램에는 세 가지 중요한 부분이 있다.

첫 번째이자 가장 중요한 것은 "메탈뷰"이다.

MTKView 클래스를 래핑하는 SwiftUI 호환 View 구현을 제공합니다.

MTKView 클래스는 macOS의 NSView와 다른 플랫폼의 UIView를 기반으로 하기 때문에 MetalView 구현은 ViewRepresentable을 사용하여 SwiftUI와 플랫폼별 MTKView 클래스를 연결합니다.

그러나 MTKView는 렌더링에 대한 직접적인 책임이 없다.

대신, 그것은 그 일을 하기 위해 대리인을 사용한다.

이 앱에서 렌더러 클래스는 MTKView의 대리인이다.

메탈 명령 큐와 코어 이미지 컨텍스트와 같은 그래픽 상태 객체를 초기화하는 역할을 한다.

또한 MetalView 대리자가 되어야 하는 draw() 메소드를 구현합니다.

그러나 렌더러는 어떤 이미지를 그릴지 결정할 직접적인 책임이 없다.

대신, 그것은 imageProvider 블록을 사용하여 CIImage를 그립니다.

이 앱에서 ContentView 클래스는 렌더링할 CIImage를 제공하는 코드 블록을 구현합니다.

간단히 요약하자면, MetalView는 대리인에게 그림을 그리라고 부른다.

Renderer draw() 메서드는 ContentView를 호출하여 그릴 이미지를 제공합니다.

MetalView 클래스의 makeView() 코드부터 시작하여 이 세 클래스의 코드에 대해 좀 더 자세히 이야기하겠습니다.

makeView()가 MTKView를 만들기 위해 호출되면, 뷰의 대리자를 Renderer 상태 객체로 설정합니다.

이것은 NSView 또는 UIView를 감싸는 SwiftUI 뷰를 구현하는 표준적인 접근 방식이다.

다음으로, 보기가 렌더링되어야 하는 빈도를 지정하기 위해 preferredFramesPerSecond를 설정합니다.

이 속성은 뷰의 드로잉을 이끄는 것을 결정하기 때문에 중요하다.

이게 어떻게 작동하는지 설명할게요.

이 샘플은 애니메이션 응용 프로그램이므로 코드는 view.preferredFramesPerSecond를 원하는 프레임 속도로 설정합니다.

이것을 설정함으로써, MTKView는 뷰 자체가 그리기 이벤트의 타이밍을 유도하도록 구성됩니다.

이로 인해 뷰의 렌더링 대리자가 주기적으로 draw()를 하게 되며, 이는 차례로 콘텐츠 공급자에게 현재 시간에 대한 CIImage를 만들도록 요청할 것이다.

그리고 그 과정은 애니메이션이 일시 중지될 때까지 반복되고 반복될 것이다.

이미지 편집 앱과 같은 다른 경우, 보기를 그려야 할 때 컨트롤과의 사용자 상호 작용이 가장 좋습니다.

enableSetNeedsDisplay를 true로 설정하면, MTKView는 컨트롤이 그리기 이벤트의 타이밍을 제어할 수 있도록 구성됩니다.

컨트롤이 이동되면, updateView() 메소드를 호출해야 합니다.

그런 다음, 뷰의 대리인은 draw()로 한 번 호출될 것이다.

그리고 각 추첨은 콘텐츠 제공자에게 현재 제어 상태에 대한 CIImage를 만들도록 요청할 것이다.

이 접근 방식은 비디오 프레임의 도착이 추첨 이벤트를 주도해야 할 때도 적절하다.

그것은 MetalView 수업에 대한 나의 토론을 마무리한다.

다음으로, 렌더러 대리자에서 가장 중요한 코드는 draw() 메소드이다.

렌더러의 draw() 메서드는 주기적인 프레임 속도로 호출됩니다.

Draw() 메서드가 호출되면, 뷰가 켜져 있는 디스플레이의 해상도를 반영하는 콘텐츠 스케일 계수를 결정해야 합니다.

이것은 CIImages가 점이 아닌 픽셀로 측정되기 때문에 필요하다.

보기가 다른 디스플레이로 이동하면 이 속성이 변경될 수 있기 때문에 draw() 메서드가 호출될 때마다 이 작업을 수행하는 것이 중요합니다.

다음으로, mtlTextureProvider로 CIRenderDestination을 만듭니다.

그런 다음 콘텐츠 제공자를 호출하여 현재 시간과 규모 요인에 사용할 CIImage를 만듭니다.

그런 다음 이 반환된 이미지는 뷰의 보이는 영역을 중심으로 불투명한 배경 위에 혼합된 다음, CIImage를 뷰 대상에 렌더링하는 작업을 시작합니다.

ContentView 클래스에서 가장 중요한 코드는 init() 메서드입니다.

Init() 메서드는 콘텐츠 뷰의 본문을 만드는 역할을 한다.

이렇게 하면 렌더러와 메탈뷰 클래스에 대한 연결이 확립될 것이다.

먼저, 이미지 제공자 블록으로 렌더러 객체를 만듭니다.

그 블록은 요청된 시간과 규모에 대해 CIImage를 반환할 책임이 있다.

그리고 마지막으로, ContentView의 본문을 그 렌더러를 사용하는 MetalView로 설정합니다.

좋아요, 이제 끝났습니다, 우리는 Core Image를 사용하여 렌더링할 수 있는 간단한 SwiftUI 앱이 있습니다.

다음으로 EDR 헤드룸으로 렌더링을 지원하기 위해 이 앱을 어떻게 수정할 수 있는지 봅시다.

이 응용 프로그램에 EDR 지원을 추가하는 것은 정말 쉽다.

1단계는 EDR에 대한 뷰를 초기화하는 것이고, 2단계는 모든 렌더링 전에 헤드룸을 계산하는 것이며, 3단계는 사용 가능한 헤드룸을 사용하는 CIImage를 구축하는 것입니다.

이 추가 사항에 대한 실제 코드를 보여드리겠습니다.

먼저, MetalView 클래스에서 하나의 작은 추가가 필요합니다.

보기를 만들 때, 확장된DynamicRangeContent를 원하는 레이어에게 말하고 pixelFormat은 .rgba16Float이어야 하며 색상 공간은 확장되고 선형이어야 한다고 뷰에 말해야 합니다.

둘째, Renderer 클래스의 draw() 메서드에 몇 가지 변경 사항이 필요합니다.

Draw() 메서드에서, 우리는 보기에 대한 현재 화면을 얻은 다음 화면에 현재 EDR 헤드룸을 요청하는 코드를 추가해야 합니다.

그런 다음 헤드룸은 이미지 제공자 블록에 매개 변수로 전달됩니다.

Draw() 메서드가 호출될 때마다 이것을 하는 것이 중요하다는 점에 유의하십시오.

헤드룸은 주변 조건이나 디스플레이 밝기가 어떻게 변하는지에 따라 변하는 동적 속성이다.

그리고 세 번째 변경 사항은 ContentView 클래스의 제공자 블록입니다.

여기서 우리는 이미지 제공자 블록 선언에 헤드룸 인수를 추가해야 합니다.

그런 다음 CIFilters와 함께 헤드룸을 사용하여 사용자의 EDR 디스플레이에서 멋지게 보이는 CIImage를 반환할 수 있습니다.

요약하자면, 이것들은 이 응용 프로그램에 EDR 지원을 추가하는 세 가지 간단한 단계였습니다: EDR에 대한 뷰를 초기화하고, 모든 렌더링 전에 헤드룸을 결정하고, 헤드룸을 감안할 때 표시할 CIImage를 구축하십시오.

이것은 이 프레젠테이션의 나머지 부분에 대한 주제가 될 것이다.

이제 앱이 EDR을 지원하므로, CIImages를 만들기 위해 CIFilters를 사용하여 일부 EDR 콘텐츠를 표시하도록 합시다.

코어 이미지에 내장된 150개 이상의 필터가 EDR을 지원합니다.

이것은 이러한 모든 필터가 EDR 콘텐츠로 이미지를 생성하거나 EDR 콘텐츠가 포함된 이미지를 처리할 수 있다는 것을 의미합니다.

예를 들어, CIColorControls 및 CIExposureAdjust 필터를 사용하면 앱이 EDR 색상으로 이미지의 밝기, 색조, 채도 및 대비를 변경할 수 있습니다.

그리고 그라디언트 필터와 같은 여러 필터는 EDR 색상 매개 변수가 주어진 이미지를 생성할 수 있습니다.

우리가 올해 추가한 세 가지 새로운 필터는 EDR 이미지도 지원합니다.

특히, CIAreaLogarithmicHistogram은 임의의 밝기 값에 대한 히스토그램을 생성할 수 있다.

CIColorCube 필터는 EDR 입력 이미지와 더 잘 작동하기 위해 올해 업데이트한 필터의 예입니다.

이 모든 내장 필터는 코어 이미지 작업 색상 공간이 클램프되지 않고 선형적이기 때문에 작동하며, 이는 RGB 값을 0 대 1 범위 밖으로 허용합니다.

앱을 개발할 때, 주어진 필터가 EDR을 지원하는지 확인할 수 있습니다.

이렇게 하려면, 필터의 인스턴스를 만든 다음, 필터의 범주에 대한 속성을 요청한 다음, 배열에 kCICategoryHighDynamicRange가 포함되어 있는지 확인합니다.

또한, 우리가 추가한 새로운 기능은 CIFilter 변수에 대한 Xcode QuickLook 디버깅 지원입니다.

이것은 각 입력 매개 변수의 범주와 요구 사항을 포함하여 각 필터 클래스에 대한 문서를 보여줄 것이다.

이러한 모든 EDR 필터를 감안할 때, 앱이 콘텐츠에 적용할 수 있는 무한한 다양한 효과가 있습니다.

오늘 설명할 예에서, 샘플 앱의 바둑판 패턴에 밝은 반사 반사로 파급 효과를 추가할 것입니다.

이 효과를 만들기 위해, 우리는 rippleTransition 필터의 인스턴스가 필요하다.

다음으로, 우리는 입력과 대상 이미지를 모두 체커 이미지로 설정합니다.

그런 다음 우리는 리플의 중심과 전환 시간을 제어하는 필터 입력을 설정합니다...

그리고 셰이딩 이미지를 리플에 반사 하이라이트를 생성하는 그라디언트로 설정하세요.

그리고 마지막으로, 우리는 우리가 설정한 모든 필터 입력을 감안할 때 출력 이미지에 대한 필터를 요청합니다.

또한 파급 효과를 위한 반사 하이라이트를 만드는 데 사용될 셰이딩 이미지를 만드는 방법을 설명하겠습니다.

우리는 비트맵 데이터에서 이 이미지를 만들 수 있지만, 더 나은 성능을 얻기 위해 이 CIImage를 절차적으로 생성할 수 있습니다.

이를 위해, 우리는 linearGradient 필터의 인스턴스를 만듭니다.

이 필터는 두 개의 점과 두 개의 CIColor가 주어진 그라디언트를 생성합니다.

우리는 반사가 현재 헤드룸을 기반으로 한 밝기와 함께 흰색이지만 합리적인 최대치로 제한되기를 원합니다.

당신이 사용하는 한도는 당신이 적용하고자 하는 효과의 모양에 달려 있습니다.

Color0은 고정되지 않은 선형 색 공간에서 흰색 레벨을 사용하여 만들어야 합니다.

색상1은 선명한 색상으로 설정되어 있다.

Point0과 point1은 반사가 왼쪽 상단 방향에서 나타나도록 좌표로 설정됩니다.

그런 다음 필터의 출력 이미지는 리플 필터에 필요한 크기로 잘립니다.

반사 효과가 있는 결과 리플은 앱에서 할 수 있는 일에 대한 간단한 프록시일 뿐입니다.

그러나, 그것은 중요한 원칙을 보여준다.

보통 밝은 픽셀을 적당히 사용하는 것이 가장 좋습니다.

적은 것이 더 많다.

밝은 픽셀은 그런 식으로 더 영향력이 있을 것이다.

우리는 이제 EDR 효과를 위해 두 개의 내장 CIFilters를 사용하는 작동하는 앱이 있습니다.

다른 내장 EDR 필터로 자유롭게 실험해 보세요.

다음으로, 몇 분 동안 CIColorCube 필터를 가장 잘 사용하는 방법과 사용자 지정 필터를 작성할 때 해야 할 일과 하지 말아야 할 일에 대해 논의하고 싶습니다.

매우 인기 있는 필터 중 하나는 CIColorCubeWithColorSpace이다.

전통적으로, 이 필터는 SDR 이미지에 모양을 적용하는 데 사용된다.

이 필터는 Process, Instant 및 Tonal과 같은 사진 앱에서 효과를 구현하는 데에도 사용됩니다.

전통적으로, 사용되는 큐브 데이터는 중요한 제한이 있습니다: 데이터는 0-to-1 범위의 RGB 색상만 입력하고 출력합니다.

이 제한을 피하는 한 가지 방법은 CIColorCubeWithColorSpace 필터에 HLG 또는 PQ와 같은 EDR 색상 공간을 사용하도록 말하는 것입니다.

이것은 EDR 콘텐츠에 대한 최상의 결과를 얻을 수 있지만, 색상 공간 범위에서 유효한 새로운 큐브 데이터를 만들어야 합니다.

또한, 큐브 크기를 늘려야 할 수도 있습니다.

대신, EDR 이미지에 SDR 큐브 데이터를 계속 사용하고 싶을 수도 있습니다: 올해 새로운, SDR 큐브 데이터를 추정하기 위해 필터를 말할 수 있습니다.

이 기능을 활성화하려면, 평소처럼 SDR 큐브 데이터를 설정하세요.

그런 다음 필터의 새로운 추정 속성을 설정하세요.

이 설정을 'true'로 설정하면 필터에 EDR 입력 이미지를 제공하고 EDR 출력 이미지를 얻을 수 있습니다.

오늘 제가 다루고 싶은 마지막 주제는 자신만의 맞춤형 CIKernels를 만드는 경우 몇 가지 모범 사례입니다.

먼저, 클램프, 최소 또는 최대와 같은 기능을 사용하여 RGB 값을 0 대 1 범위로 제한하는 수학에 대한 커널 코드를 검토하십시오.

많은 경우에, 이러한 제한은 안전하게 제거될 수 있으며, 커널은 올바르게 작동할 것이다.

둘째, RGB 값이 0-to-1 범위를 초과할 수 있지만, 알파 값은 0에서 1 사이여야 하며, 그렇지 않으면 이미지를 혼합하거나 표시할 때 정의되지 않은 동작이 발생합니다.

이 예에서, 올바른 동작이 RGB 값에 5만 곱하는 것일 때, 커널은 실수로 알파 채널에 5를 곱하고 있다.

그것으로 내 발표를 마칩니다.

마무리하기 위해, 오늘 우리는 Core Image SwiftUI 애플리케이션에 EDR 헤드룸에 대한 지원을 추가하는 방법과 다양한 내장 CIFilters를 사용하여 EDR 콘텐츠를 만들고 수정하는 방법을 배웠습니다.

봐줘서 고마워!

♪ 기악 힙합 음악 ♪