10137

♪ 부드러운 기악 힙합 음악 ♪

♪

안녕하세요, 저는 동하오입니다.

이 세션에서, 우리는 스위프트 차트로 훌륭한 데이터 시각화를 구축하는 방법에 대해 더 배울 것입니다.

즉, 우리는 당신이 앱의 차트로 할 수 있는 것의 기준을 높일 것입니다.

훌륭한 데이터 시각화는 앱을 더 유익하고 매력적으로 만듭니다.

우리 앱에서 훌륭한 차트를 만들기 위해, 고려해야 할 많은 것들이 있다.

물론, 우리는 우리의 차트가 기본 데이터를 충실하게 전달하고 모든 사람이 접근할 수 있기를 원합니다.

하지만 앱의 차트는 진공 상태에서 살지 않는다.

그것들은 앱의 사용자 인터페이스의 일부이다.

우리는 다크 모드와 같은 현지화와 OS 기능을 지원해야 합니다.

차트에는 나머지 UI에 완벽하게 맞는 적절한 레이아웃이 있어야 합니다. 동적 유형과 장치 화면 크기를 지원해야 합니다.

우리는 또한 차트가 모든 플랫폼에서 작동하고, 최고의 모양과 느낌을 위한 훌륭한 애니메이션을 갖기를 원할 것입니다.

스위프트 차트는 이러한 많은 기본 기능을 자동으로 처리하므로, 고유한 데이터를 전달하고 모든 사람이 액세스할 수 있도록 최고의 차트를 만드는 데 더 집중할 수 있습니다.

Swift Charts는 SwiftUI처럼 느껴지는 선언적 구문을 제공함으로써 이를 달성합니다.

소량의 코드로 차트에서 원하는 것을 지정하면, 스위프트 차트는 자동으로 훌륭한 차트를 생성합니다.

스위프트 차트는 또한 다양한 사용자 지정 옵션을 제공하므로 고유한 응용 프로그램에 맞게 차트를 스타일링할 수 있습니다.

이 세션은 스위프트 차트에 대한 더 깊은 이해를 제공하는 것입니다.

우리는 선언적 구문의 기본 구성 요소를 다루는 것으로 시작할 것이다: 마크와 마크의 구성.

다음은 Apple 제품에서 차트를 사용하는 몇 가지 예입니다.

보시다시피, 다양한 데이터, 차트 유형 및 스타일이 있습니다.

각 유형의 차트에 대해 사전 구축된 구성 요소를 제공하는 대신, 스위프트 차트는 구성으로 차트를 만드는 아이디어를 기반으로 합니다.

다양한 방식으로 결합하여 소수의 기본 빌딩 블록을 제공하며, 다양한 차트를 만들 수 있습니다.

그게 어떻게 작동하는지 보여줄게.

그렇게 하려면, 나는 예시가 필요할 것이다.

내 팀원들은 모두 팬케이크를 좋아하기 때문에, 우리는 다양한 종류의 팬케이크를 판매하는 푸드 트럭 주문을 추적하는 앱을 가지고 있다.

여기 스타일별로 분류된 지난 30일 동안 배달된 팬케이크 수를 보여주는 차트가 있습니다.

이것은 막대 차트로 널리 알려져 있다.

스위프트 차트에서, 우리는 여섯 개의 파란색 직사각형 각각을 표시로 간주한다.

마크는 데이터를 나타내는 그래픽 요소이다.

이것은 지난 30일 동안 판매된 카차파의 수를 보여주는 바 마크입니다.

이 차트에는 여섯 개의 막대 표시가 있으며, 각각 팬케이크 스타일과 해당 판매 번호를 보여줍니다.

이것이 코드로 어떻게 쓰여지는지 봅시다.

여기에는 "가장 많이 팔린 스타일, 카차파"와 같은 설명적인 제목과 빈 차트가 포함된 SwiftUI 보기가 있습니다.

여기 차트 유형은 단일 차트를 정의하는 최상위 보기입니다.

다른 보기를 추가하는 것처럼 SwiftUI 애플리케이션에 차트를 추가할 수 있습니다.

나머지 이야기 동안, 우리는 차트 부분에 집중할 것이다.

차트에 표시를 추가할 수 있습니다.

여기 cachapa와 판매 번호를 보여주는 단일 BarMark가 있습니다.

이것은 하나의 막대 표시가 있는 차트를 만든다.

스크린샷에서 볼 수 있듯이, 차트는 나머지 사용자 인터페이스에 잘 맞고 훌륭한 기본 스타일을 가지고 있습니다.

예를 들어, X축에서 잘 반올림된 숫자.

이름과 판매가 다른 다른 막대 표시를 추가하면, 두 번째 막대를 얻을 수 있습니다.

이것을 반복하여 더 많은 막대를 추가할 수 있습니다.

실제 앱에서, 우리는 아마도 이러한 표시를 프로그래밍 방식으로 생성할 것이다.

차트에 구조체나 튜플 배열을 제공하여 그렇게 할 수 있으며, ForEach를 사용하여 각 요소의 값으로 막대 표시를 만들 수 있습니다.

ForEach가 이 경우와 같이 차트의 유일한 콘텐츠인 경우, 차트에 데이터를 직접 넣을 수도 있습니다.

많은 SwiftUI 수정자를 마크에 사용할 수 있습니다.

예를 들어, .foregroundStyle 수정자로 막대의 색상을 설정할 수 있습니다.

여기서 우리는 Xcode에서 명명된 자산으로 만들 수 있는 명명된 색상으로 설정하고 있습니다.

모든 사람이 차트에 접근할 수 있다는 것은 매우 중요하다.

기본적으로, 차트는 자동으로 생성된 접근성 요소가 있는 VoiceOver 사용자에게 노출됩니다.

.accessibilityLabel과 .accessibilityValue 수정자로 이것들을 사용자 정의할 수 있습니다.

예를 들어, 우리는 라벨을 팬케이크의 이름으로 설정하고, 접미사 "판매"로 판매 값을 설정합니다.

결과적으로, 우리는 VoiceOver 사용자를 위한 맞춤형 경험을 얻을 수 있습니다.

보이스오버: 카차파, 916 판매. 인제라, 850이 팔렸다.

크레이프, 802 판매.

동하오: 우리의 앱은 또한 며칠 동안 팬케이크 배달을 추적합니다.

여기, 지난 30일 동안 판매된 팬케이크의 수를 보여주는 전망이 있습니다.

그 차트는 각 일일에 대한 상세한 견해를 제공한다.

이 차트를 어떻게 만드는지 봅시다.

여기, 우리는 날짜와 판매가 있는 데이터 배열을 가지고 있습니다.

그 날은 하루가 시작될 때 날짜 값으로 표현된다.

우리는 x가 날짜를 보여주는 막대 표시로 데이터를 시각화하고, 여기서 단위 매개 변수는 날짜 값이 달력 일의 기간을 나타내고 y는 그 날의 판매를 나타낸다는 것을 의미합니다.

오른쪽에서 보시다시피, 우리는 며칠 동안의 판매량을 보여주는 막대 차트를 얻을 수 있습니다.

막대 차트가 이 데이터를 시각화하는 유일한 방법은 아니다.

꺾은선형 차트를 시도해 보자.

우리가 해야 할 유일한 변화는 BarMark를 LineMark로 대체하는 것이다.

선언적 구문을 사용하면 스위프트 차트에서 차트 유형 간에 전환하는 것이 매우 쉽습니다.

이전 차트는 시간에 대한 총 매출을 보여준다.

하지만 푸드 트럭 서비스는 두 도시에서 운영되고 있으며, 우리는 매주 두 도시 간의 판매를 비교하여 어디로 갈지 결정하는 데 도움을 주고 싶습니다.

이 차트의 선은 월요일부터 일요일까지의 판매량을 보여준다.

각 선은 도시를 나타낸다.

이게 어떻게 만들어졌는지 보자.

이제 여기에 튜플 배열로 정의된 두 도시의 데이터가 있다고 가정해 봅시다. 각 도시는 도시 이름과 평일 판매를 포함합니다.

그런 다음, 우리는 시리즈 데이터를 반복하는 ForEach로 이전에 가지고 있던 라인 차트를 래핑할 수 있습니다.

두 도시를 구별하기 위해, 우리는 도시 이름으로 두 줄의 스타일을 지정하기 위해 .foregroundStyle(by:) 수정자를 사용합니다.

보시다시피, 스위프트 차트는 자동으로 두 도시의 두 가지 색상을 선택하고, 선을 색칠한 다음, 각 색상이 무엇을 의미하는지 나타내는 범례를 추가합니다.

기본 색상은 구별하기 쉬운 시스템 색상으로 선택됩니다.

색맹이 있는 사람들을 위해 차트를 더 쉽게 읽을 수 있도록, 우리는 그것들을 더 구별하기 위해 선에 기호를 추가할 수 있습니다.

이것은 도시로 .symbol(by:) 수정자를 데이터로 추가하여 수행할 수 있습니다.

마지막으로, 선을 더 매끄럽게 보이게 하기 위해, 우리는 곡선을 선의 보간 방법으로 사용할 수 있다.

두 시리즈 라인 차트에도 불구하고, 우리는 여전히 바 마크로 돌아가서 그것이 어떻게 생겼는지 볼 수 있다.

마크 유형을 BarMark로 변경하고, 막대와 관련이 없는 수정자를 제거하면, 누적 막대 차트를 얻을 수 있습니다.

바는 이제 매달 두 개의 바가 있기 때문에 자동으로 쌓인다.

쌓인 막대 차트는 두 도시의 총 판매 가치를 보여주는 데 좋지만, 두 도시를 비교하는 데는 그다지 좋지 않다.

비교를 더 쉽게 하기 위해, 우리는 이것을 .position(by:) 수정자로 그룹화된 막대 차트로 바꿀 수 있습니다.

지금까지, 우리는 막대 표시와 선 표시를 보았다.

스위프트 차트는 포인트 마크, 영역 마크, 규칙 마크 및 직사각형 마크를 포함한 몇 가지 다른 마크 유형을 지원합니다.

이 표시들을 결합하여 더 복잡한 차트를 만들 수 있습니다.

예를 들어 보자.

매달 평균 일일 매출을 보여주는 라인 차트로 시작합시다.

평균은 유용하지만, 우리는 또한 더 극단적인 가치에 대한 아이디어를 얻기 위해 최소 및 최대 일일 매출을 보고 싶습니다.

이 값들을 데이터에 추가하는 것으로 시작합시다.

우리는 데이터 배열의 각 요소에 일일 최소 및 일일 최대치를 소개합니다.

그런 다음 x가 월을 보여주는 영역 표시로 최소값과 최대값을 시각화할 수 있으며, y는 일일 최소값에서 시작하여 일일 최대값에서 끝납니다.

이렇게 하면, 우리는 선이 있는 일일 평균값과 선 주변 면적이 있는 일일 최소값과 최대값을 보여주는 차트가 있습니다.

라인 플러스 영역이 이런 종류의 데이터를 시각화하는 유일한 방법은 아니다.

다른 마크 유형으로 쉽게 전환하여 더 많은 디자인 옵션을 탐색할 수 있습니다.

예를 들어, 여기서 우리는 BarMark를 사용하고 있다.

하지만, 그 라인은 바와 잘 맞지 않는 것 같다.

선 표시를 높이가 두 점인 RectangleMark로 바꾸자.

이런 식으로, 직사각형 표시는 평균값을 보여주는 막대 안에 수평선을 만든다.

이 표시의 너비를 조정할 수도 있습니다.

예를 들어, 우리는 너비를 .6의 비율로 설정하고 있습니다. 이것은 스크린샷에서 볼 수 있듯이 막대와 직사각형의 너비가 한 달 전체의 너비의 60%가 될 것임을 의미합니다.

마지막으로, 우리는 모든 달 동안 평균 일일 매출을 보여줄 수 있는 옵션을 갖고 싶습니다.

그렇게 하기 위해, 우리는 먼저 전경 스타일을 페이드 그레이 색상으로 설정하여 강조하지 않는다.

그런 다음, 우리는 Y가 평균값을 보여주는 ForEach 외부에 규칙 표시를 추가합니다.

이것은 수평 규칙을 추가한다.

규칙이 연간 평균을 보여주고 있다는 것을 분명히 하기 위해, 우리는 .annotation 수정자를 사용하여 규칙에 주석을 추가할 수 있습니다.

이것은 선행 정렬과 함께 규칙 표시 상단에 텍스트 라벨을 추가합니다.

우리는 구성에 따른 빌딩 차트의 몇 가지 예에 대해 논의했다.

이러한 기본 마크를 사용하고 결합하는 방법에는 여러 가지가 있습니다.

상자 플롯, 다중 시리즈 라인 차트, 인구 피라미드, 범위 플롯, 스트림 그래프, 다중 시리즈 산란 플롯, 히트 맵 또는 벡터 필드의 플롯과 같습니다.

이것들은 스위프트 차트로 만들 수 있는 다양한 차트의 몇 가지 예일 뿐입니다.

다음 주제로 뛰어들자.

마크 속성으로 데이터 플로팅.

스위프트 차트는 세 가지 주요 유형 또는 데이터를 지원합니다: 양적, 명목적, 시간적.

양적 데이터는 판매된 제품의 수, 방의 온도 또는 주식 가격과 같은 수치이다.

스위프트 차트는 Int, Float 및 Double과 같은 스위프트 수치 유형을 정량 데이터로 취급합니다.

명목 데이터 또는 범주형 데이터는 개별 범주 또는 그룹을 나타냅니다.

예를 들어, 사람의 이름, 대륙 또는 제품의 종류.

문자열이나 사용자 지정 문자열 값 열거형을 명목 데이터로 사용할 수 있습니다.

시간 데이터는 시간의 지점이나 간격을 나타낸다.

예를 들어, 특정 날의 기간 또는 거래의 정확한 시간.

스위프트 차트는 "날짜"를 일시적인 데이터로 취급한다.

차트는 판매 가치와 같은 추상적인 데이터를 마크의 속성으로 변환하여 작동합니다.

X, Y 및 Foreground Style 속성으로 데이터를 플로팅할 수 있는 BarMark를 살펴봅시다.

이 예에서, 우리는 x 속성과 함께 양적인 판매 가치와 y 속성과 함께 명목상의 이름을 플로팅합니다.

결과 차트는 각각 X의 판매와 Y의 이름을 보여주는 가로 막대로 구성되어 있다.

이름과 판매를 바꾸면, 이름이 X에 있고 판매가 Y에 있다면, 대신 수직 막대 차트를 얻을 수 있습니다.

보시다시피, BarMark의 동작은 X와 Y 속성으로 플로팅된 데이터 유형에 따라 다릅니다.

바의 방향은 양적 특성이 어디에 있는지에 달려 있다.

이제, 데이터를 플로팅하는 데 사용되는 세 가지 속성이 모두 있는 다른 차트를 살펴봅시다.

여기서 우리는 X와 함께 일시적인 평일, Y와 함께 판매, 그리고 전경 스타일의 도시를 계획합니다.

결과 차트는 X축이 평일을 보여주고, Y축이 판매를 보여주고, 막대가 도시별로 채색되는 누적 막대 차트이다.

스위프트 차트에는 여섯 가지 마크 유형과 데이터를 플로팅할 수 있는 여섯 가지 마크 속성이 있습니다.

데이터는 세 가지 종류일 수 있으므로, 가능한 조합의 배열이 있다는 것을 기억하세요.

이것은 스위프트 차트가 소수의 기본 빌딩 블록으로 광범위한 차트 디자인을 지원할 수 있게 해준다.

예를 들어, Y를 사용한 판매와 같은 마크 속성으로 데이터를 플로팅할 때, 스위프트 차트는 추상 데이터를 속성의 적절한 값으로 변환하는 매핑을 만듭니다.

이 경우, 그것은 판매 가치를 화면 공간의 Y 좌표로 변환할 것이다.

우리는 Y 위치와 같은 속성을 표시하기 위해 판매와 같은 추상 데이터의 매핑을 지칭하기 위해 "규모"라는 용어를 사용합니다.

스케일은 데이터 값을 취하고 속성 값을 반환하는 함수로 생각할 수 있습니다.

예를 들어, 여기에 판매를 받고 막대의 Y 위치를 반환하는 yScale 함수가 있습니다.

"스케일"이라는 이름은 위치 속성의 경우, 우리는 종종 합리적인 화면 좌표로 변환하기 위해 입력 값을 어떤 요소로 확장한다는 사실에서 비롯됩니다.

마크 속성으로 데이터를 플로팅할 때, 데이터를 해당 마크 속성으로 변환하기 위한 스케일이 생성됩니다.

예를 들어, 이 차트에는 세 가지 척도가 있는데, 각각 평일을 X로, 판매를 Y로, 도시를 포그라운드 스타일로 변환합니다.

기본적으로, 스위프트 차트는 데이터에서 자동으로 스케일을 추론하므로, 즉시 멋진 차트를 얻을 수 있습니다.

스케일 수정자를 사용하여 차트에서 스케일을 구성할 수 있습니다.

몇 가지 예를 살펴봅시다.

이 예에서, Y 척도는 자동으로 0에서 150으로 추론된다.

그러나, 우리는 Y 스케일을 수정하여 현재 판매가 어떻게 생겼든, 우리는 항상 일관된 Y 스케일을 가지고 있습니다.

Y 스케일이 항상 0에서 시작해서 200에서 끝나도록 바꾸자.

그렇게 하기 위해, 우리는 .chartYScale 수정자를 사용하고, 스케일의 도메인을 0에서 200으로 설정할 수 있습니다.

이제, 보시다시피, 축은 0에서 200으로 간다.

마찬가지로, 우리는 .chartForegroundStyleScale 수정자를 사용하여 두 도시가 전경 스타일로 매핑되는 방식을 변경할 수 있습니다.

이제 우리는 두 도시를 위한 새로운 색을 가지고 있다.

이제 우리는 마크 속성을 사용하여 마크를 작성하고 데이터를 플로팅하는 방법을 알고 있습니다.

스위프트 차트가 제공하는 더 많은 사용자 지정 옵션을 살펴봅시다.

차트는 축, 아마도 전설, 그리고 플롯 영역으로 구성되어 있다.

도끼와 전설은 우리가 차트를 해석하는 데 도움을 준다.

플롯 영역은 두 축 사이의 영역이다.

이것은 우리가 마크로 데이터를 플로팅하는 곳이다.

이 모든 요소는 스위프트 차트에서 사용자 정의할 수 있습니다.

먼저 축과 전설을 사용자 정의하는 방법에 대한 몇 가지 예를 봅시다.

여기 총 월간 매출을 보여주는 차트가 있습니다.

사용자 지정 없이, 스위프트 차트는 잘 반올림된 값을 특징으로 하는 기본 축을 생성합니다.

지금, X축은 매 분기마다 라벨을 보여준다.

매달 라벨을 표시하도록 변경하고, 단일 문자 월 라벨을 사용합시다.

AxisMarks를 콘텐츠로 사용하여 X축을 사용자 정의하기 위해 .chartXAxis 수정자를 추가하는 것으로 시작하겠습니다.

매개 변수가 없는 AxisMarks는 기본 축을 다시 만듭니다.

축 값을 바꾸는 것으로 시작합시다.

우리는 정기적인 달력 간격을 원하기 때문에, 표준 라이브러리의 스트라이드 함수와 유사한 스트라이드(by:)를 사용할 수 있습니다.

이제 우리는 매달 라벨을 가지고 있다.

그러나, 스크린샷에서 볼 수 있듯이, 기본 라벨은 너무 붐비는 것처럼 느껴집니다.

일부 라벨은 충분한 공간이 없기 때문에 잘립니다.

단일 문자 형식을 사용하도록 라벨을 변경해 봅시다.

그렇게 하려면 AxisGridLine, AxisTick 및 AxisValueLabel을 포함한 개별 구성 요소에서 축 마크를 구축합시다.

좁은 월 이름을 사용하도록 라벨 형식을 설정해 봅시다.

이제 우리는 매달 한 통의 편지를 가지고 있다.

결과 빌더에 전달된 값 매개 변수는 현재 축 값에 대한 정보를 제공합니다.

이것을 사용하여 축 표시의 존재와 스타일을 조건부로 결정할 수 있습니다.

예를 들어, 여기서 우리는 날짜로서의 값이 한 달의 1/4분기인지 여부를 테스트하는 조건이 있습니다.

그렇다면, 우리는 각 분기의 첫 달을 다른 전경 스타일로 강조할 수 있다.

그렇지 않다면, 우리는 틱과 라벨 없이 격자선만 표시합니다.

우리가 지금 분기를 보여주고 있기 때문에, 우리는 형식을 분기 스타일로 바꿀 수 있다.

우리가 방금 한 사용자 지정으로, 우리는 매달 서브그리드 라인과 함께 분기 데이터를 보여주는 더 독특한 X축을 얻을 수 있습니다.

값 외에도, 축 표시에는 일반적인 모양과 스타일을 구성할 수 있는 다른 속성이 있습니다.

Y축이 기본 후행 가장자리 대신 차트의 앞쪽 가장자리에 나타나기를 원하면, 위치 매개 변수를 앞쪽 가장자리로 이동하도록 설정할 수 있습니다.

스위프트 차트는 축과 시각화되는 데이터 유형을 기반으로 축 표시에 대한 기본 사전 설정을 제공합니다.

사전 설정 매개 변수를 사용하여 기본값을 재정의할 수 있습니다.

예를 들어, 여기서 우리는 나머지 사용자 인터페이스와의 시각적 정렬을 돕기 위해 Y축에 대한 .extended 프리셋을 사용하고 있습니다.

일부 차트에서는 축이 보이는 것을 원하지 않을 수도 있습니다.

예를 들어, 여기서 최고 판매 차트의 목적은 사람들에게 간략한 개요를 제공하는 것이므로, 축은 실제로 필요하지 않습니다.

.Hidden을 차트 축 수정자로 전달하여 축을 숨길 수 있습니다.

범례 구성은 축과 비슷하다.

예를 들어, 최고의 날과 위치를 강조하는 이 차트에서, 우리는 이미 불투명도를 사용하여 최고의 도시를 강조하므로 자동으로 생성된 범례를 숨길 수 있습니다.

그렇게 하기 위해, 우리는 .chartLegend 수정자를 매개 변수로 .hid로 추가할 수 있습니다.

이제 줄거리 영역에 대해 이야기해 봅시다.

.chartPlotStyle 수정자를 사용하여 차트의 플롯 영역을 구성할 수 있습니다.

후행 클로저에서, 우리는 원래 플롯 영역을 취하고 수정된 플롯 영역을 반환하는 함수를 작성할 것입니다.

몇 가지 예를 들어 봅시다.

어떤 경우에는, 우리는 플롯 영역이 정확한 크기나 종횡비를 갖기를 원할 수도 있다.

예를 들어, 이 경우, 우리는 플롯 영역의 높이가 차트의 카테고리 수에 의해 구동되기를 원합니다.

이를 달성하기 위해, 우리는 플롯 영역에 .frame 수정자를 적용하고 수정된 플롯 영역을 반환할 수 있습니다.

이것은 플롯 영역의 높이를 설정할 것이다.

우리는 또한 특별한 시각 효과를 얻기 위해 수정자를 사용할 수 있다.

예를 들어, 이 다크 모드 차트에서, 우리는 .background 수정자를 사용하여 불투명도가 .2인 분홍색 배경을 추가하여 차트를 조금 돋보이게 합니다.

그리고 같은 분홍색으로 1-pt 테두리를 추가하세요.

이것은 차트에 독특한 시각 효과를 만들어낸다.

세션의 앞부분에서 우리는 X와 Y와 같은 속성을 표시하기 위해 데이터 값을 매핑하는 함수인 스케일을 언급했습니다.

스위프트 차트는 차트에서 X와 Y 스케일에 액세스할 수 있는 ChartProxy를 제공합니다.

ChartProxy의 position(for:) 메서드를 사용하여 주어진 데이터 값의 위치를 얻거나, value(at:) 메서드를 사용하여 주어진 위치에서 데이터 값을 얻을 수 있습니다.

이것은 당신이 차트와 다른 견해를 조정할 수 있게 해준다.

예를 들어 봅시다.

우리는 이 인터랙티브 브러시 뷰를 만들 것이다.

여기서 드래그 제스처로 차트에서 간격을 선택할 수 있으며, 그 간격은 세부 정보 보기에서 행을 필터링하는 데 사용됩니다.

.chartOverlay 또는 .chartBackground 수정자에서 차트 프록시 객체를 얻을 수 있습니다.

이 두 수정자는 SwiftUI의 오버레이 및 배경 수정자와 유사하지만, 차트 프록시를 제공합니다.

이 예시를 만들기 위해, 우리는 이전과 같이 기본 차트를 정의하는 것으로 시작할 것이다.

그런 다음 차트 프록시를 제공하는 .chartOverlay 수정자를 추가합니다.

내부에는 오버레이 뷰의 기하학에 접근할 수 있는 기하학 리더가 있습니다.

그런 다음, SwiftUI의 DragGesture에 응답하도록 구성된 직사각형 보기가 있습니다.

드래그 제스처가 발생하면, 우리는 먼저 시작의 x 좌표와 차트의 플롯 영역 내부의 현재 위치를 찾습니다.

이것은 제스처에 의해 제공된 위치에서 플롯 영역의 기원을 빼서 이루어진다.

이러한 좌표가 있으면, 차트 프록시를 사용하여 해당 날짜 값을 찾고, 마지막으로 현재 날짜 간격을 추적하는 SwiftUI 상태로 설정할 수 있습니다.

범위 상태로, 우리는 차트에서 직사각형 표시를 정의하여 현재 선택된 날짜 범위를 시각화할 수 있습니다.

이 상태는 또한 차트 아래의 세부 사항 보기의 내용을 필터링하기 위해 응용 프로그램의 다른 부분을 제어하는 데 사용될 수 있습니다.

이것은 차트 프록시가 어떻게 작동하는지 설명하는 간단한 예입니다.

예를 들어, 막대사탕처럼 보이는 오버레이로 선택한 날짜와 판매 가치를 보여주는 이 대화형 차트와 같은 많은 흥미로운 기능을 만드는 데 사용할 수 있습니다.

이 세션에서, 우리는 마크를 구성하여 차트를 만드는 방법, 마크 속성으로 데이터를 플로팅하는 방법, 차트를 사용자 정의하는 방법에 대해 논의했습니다.

디자인 세션에 가서 차트로 훌륭한 앱 경험을 디자인하는 방법과 효과적인 차트를 디자인하는 방법에 대해 자세히 알아볼 수 있습니다.

우리는 당신이 스위프트 차트로 데이터 시각화를 구축하는 것을 좋아할 것이라고 생각합니다.

봐줘서 고마워.

♪