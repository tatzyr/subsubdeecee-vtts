10071

앤디: 안녕.

"데스크톱 수업 편집 상호 작용 채택"에 오신 것을 환영합니다.

저는 UIKit 프레임워크 엔지니어인 앤디이고, 나중에 제 동료인 제임스와 합류할 것입니다.

iPad는 간단하고 사용하기 쉬운 상호 작용을 손상시키지 않으면서 지속적으로 진화하고 있다.

이 비디오에서는 앱을 더 많은 데스크톱 클래스로 변환할 흥미진진한 새로운 편집 상호 작용에 대해 배우게 될 것입니다.

먼저, iOS 16에서 주요 안면 성형을 받은 새로운 편집 메뉴를 살펴볼 것입니다.

나중에, 제임스는 새로운 시스템에 뛰어들어 경험을 찾고 대체할 것이다.

iOS 16에서 편집 메뉴는 친숙하지만 더 인터랙티브하고 행동을 더 쉽게 발견할 수 있는 완전히 새로운 디자인을 특징으로 한다.

편집 메뉴에는 이제 사용된 입력 방법에 따라 대체 프레젠테이션이 있습니다.

터치 상호 작용의 경우, 편집 메뉴는 여전히 친숙한 컴팩트한 외관을 가지고 있지만, 페이징 동작이 개선되어 이전보다 더 많은 작업을 발견할 수 있습니다.

매직 키보드 또는 트랙패드를 사용하면 더 많은 데스크톱 수업 경험을 위해 컨텍스트 메뉴가 보조 또는 오른쪽 클릭으로 표시됩니다.

마찬가지로, iPhone의 터치 상호 작용에는 새로운 편집 메뉴가 표시됩니다.

그리고 Mac Catalyst 앱의 경우, Mac 사용자가 익숙한 컨텍스트 메뉴가 제공됩니다.

iOS 16에서 텍스트 편집 메뉴는 새로운 데이터 탐지기 통합으로 주요 파워업을 받습니다.

여기에는 인라인 단위 및 통화 변환뿐만 아니라 선택한 텍스트에 따라 문맥 작업을 표시하는 스마트 조회가 포함됩니다.

예를 들어, Safari에서 주소를 선택하면 기존 편집 메뉴 작업 위에 "길 찾기" 또는 "지도에서 열기"와 같은 지도 기반 작업을 얻을 수 있습니다.

가장 좋은 점은, 입양이 필요하지 않다는 것이다!

이러한 기능은 텍스트 상호 작용 보기, WebKit 및 Safari뿐만 아니라 PDFKit을 포함한 모든 텍스트 편집 메뉴에서 사용할 수 있습니다.

텍스트 보기의 메뉴에 작업을 삽입하려면, 새로운 TextViewDelegate 방법을 구현하여 시스템 제공 작업으로 주어진 범위의 텍스트에 대해 표시된 메뉴를 사용자 정의하십시오.

아무것도 사용자 정의할 필요가 없다면, 표준 시스템 메뉴를 얻기 위해 nil을 반환하세요.

UITextFieldDelegate와 UITextInput에도 메뉴를 사용자 정의할 수 있는 유사한 방법이 있습니다.

UIMenuController를 사용하여 메뉴 항목을 삽입하는 것은 이제 iOS 16에서 더 이상 사용되지 않으며, 대신 새로운 방법을 사용하여 텍스트 편집 메뉴에 메뉴 요소를 추가해야 합니다. 왜냐하면 우리가 가는 곳은 메뉴 컨트롤러가 필요하지 않기 때문입니다!

다음은 몇 가지 사용자 지정 작업이 있는 텍스트 보기의 예입니다.

일부 텍스트 선택에 메뉴가 표시되면, 시스템이 제안한 작업 후에 사용자 지정 "하이라이트" 및 "사진 삽입" 작업이 표시됩니다.

하이라이트 액션을 선택하면 예상대로 텍스트에 하이라이트가 표시됩니다.

다음으로, 강조할 것이 없는 텍스트 선택 없이 메뉴가 표시되면, 메뉴는 시스템이 제안한 작업 후에 "사진 삽입" 작업만 표시합니다.

새로운 API를 사용하여 이러한 작업을 추가하는 방법을 보여드리겠습니다.

프레젠테이션에서 동적으로 메뉴에 작업을 삽입하려면 UITextViewDelegate 메서드 textView editMenuForTextIn 범위 suggestedActions를 구현하십시오. 이 예제에서는 선택한 텍스트가 있을 때만 "하이라이트" 작업을 추가하고 싶기 때문에 이 방법을 통해 동적으로 작업을 추가할 수 있습니다.

"사진 삽입" 작업은 항상 유효하므로, 배열에 추가하여 항상 메뉴에 작업을 표시할 수 있습니다.

마지막으로, 잘라내기, 복사 및 붙여넣기와 같은 항목을 포함하는 시스템 제안 작업에 내 작업을 추가하고 메뉴를 반환할 것입니다.

그리고 그게 다야!

UIEditMenuInteraction은 새로운 편집 메뉴를 지원하는 UIInteraction API입니다.

상호 작용을 통해 자신의 제스처를 기반으로 텍스트 보기 외부에 가벼운 편집 메뉴를 프로그래밍 방식으로 표시할 수 있으며, 보조 클릭 시 컨텍스트 메뉴를 표시할 수 있는 기본 지원이 있습니다.

iOS 16에서 UIMenuController와 모든 관련 API는 새로운 편집 메뉴 상호 작용으로 대체됩니다.

처음부터 편집 메뉴를 표시하려면, 먼저 상호 작용을 만들고 보기에 추가하세요.

다음으로, 메뉴를 표시하도록 제스처 인식기를 구성하세요.

메뉴가 간접 포인터 클릭이 아닌 직접 터치에만 나타나도록 하려면, 제스처 인식기의 allowedTouchTypes 속성을 직접 터치로만 설정해야 합니다.

그런 다음, 제스처 인식기를 보기에 추가하세요.

마지막으로, 제스처 인식기가 실행되면, 메뉴를 표시할 수 있는 제스처 위치에 콘텐츠가 있는지 결정하십시오.

그런 다음, 제스처의 위치에 소스 포인트로 편집 메뉴 구성을 만드세요.

소스 포인트는 메뉴에 표시할 상호 작용 보기에서 수행 가능한 작업을 결정하는 데 사용됩니다.

구성되면, presentEditMenu(with: configuration)를 호출하여 메뉴를 표시하세요.

선택한 "Jello there!" 내의 아무 곳이나 마우스 오른쪽 버튼으로 클릭하면 보기, 컨텍스트 메뉴에는 앱 콘텐츠에 대한 실행 가능한 시스템 작업이 표시됩니다.

더군다나, 선택한 보기를 탭하면, 내 터치가 발생한 곳에 편집 메뉴가 표시되며, 상황에 맞는 메뉴와 동일한 동작을 보여줍니다.

이것은 좋지만, 더 나을 수 있다.

터치가 발생한 곳에 메뉴가 나타나는 것은 좋지만, 실제로 선택한 보기의 콘텐츠를 차단하고 있습니다.

게다가, 저는 시스템 기본 작업이 아닌 새로운 "중복" 작업을 메뉴에 삽입하고 싶습니다.

돌아가서 이걸 바꾸자.

선택한 보기 주위에 메뉴를 표시하려면 대리자 메서드 editMenuInteraction targetRectFor 구성을 구현하십시오. 이 메서드는 메뉴를 표시할 위치를 결정하는 데 사용되는 CGRect를 반환하고 상호 작용 보기의 좌표 공간에 있습니다.

방법이 구현되지 않거나 null CGRect가 제공되는 경우, 메뉴는 구성의 소스 지점에서 표시됩니다.

이 경우, 메뉴가 선택한 보기를 닫는 것을 방지하려면, 프레임을 반환하십시오.

다음으로, "복제" 작업을 추가하려면, editMenuInteraction 메뉴를 구현하고, 이전에 텍스트 보기의 메뉴에 작업을 삽입하는 방법과 유사하게 시스템이 제안한 작업 후에 사용자 지정 작업을 추가합니다.

이제, 내가 선택한 보기를 다시 탭하면, 메뉴는 더 이상 "Jello there!"를 막지 않습니다. 그리고 대신 그 주변에 선물해.

메뉴가 표시될 때 새로운 "중복" 작업도 포함되며, 모두 몇 줄의 코드만 있으면 됩니다.

훌륭해!

Mac Catalyst 앱의 경우, 편집 메뉴는 사용자가 상호 작용 보기를 마우스 오른쪽 버튼으로 클릭할 때 Mac에서 기대하는 친숙한 컨텍스트 메뉴로 연결됩니다.

iPad 관용구 Mac Catalyst 앱의 경우, 프로그래밍 방식으로 제시된 편집 메뉴는 컨텍스트 메뉴로 연결됩니다.

편집 메뉴의 프로그래밍 방식 프레젠테이션은 Mac 관용구 앱에서 지원되지 않습니다.

다양한 프레젠테이션 스타일 간의 원활한 브리징을 제공하기 위해, UIEditMenuInteraction은 UIMenuElement API 제품군 위에 구축되었습니다.

이것들은 하위 메뉴와 이미지에 대한 지원을 포함하여 이전보다 더 많은 유연성과 사용자 정의 가능성을 제공합니다.

UIMenus를 처음 사용하는 경우, "iOS 13용 UI 현대화"를 시청하여 메뉴와 작업에 대해 자세히 알아보세요.

UIMenuElement 위에 구축한다는 것은 또한 편집 메뉴가 이미 메뉴를 지원하는 UIMenuSystem과 같은 다양한 API에 액세스할 수 있다는 것을 의미합니다.

편집 메뉴는 기존 UIMenuSystem.context 시스템을 사용하여 메뉴를 만듭니다.

메뉴 빌더에 대해 자세히 알아보고 응답자 체인 횡단 및 명령 유효성 검사에 대해 자세히 알아보려면 "iPad 앱을 한 단계 끌어올리기"를 시청하세요.

메뉴에 대해 말하자면, iOS 16의 UIMenu에는 몇 가지 새로운 개선 사항이 있습니다.

UIMenu에는 이제 컨텍스트 메뉴에서 다른 레이아웃 중에서 선택할 수 있는 선호하는 요소 크기 속성이 있습니다.

작은 크기는 메뉴에 더 컴팩트한 나란히 모양을 제공하여 한 줄에 더 많은 동작을 제공합니다.

중간 크기는 또한 나란히 보이는 동작을 표시하지만 조금 더 자세하게 보여준다.

이것은 표준 편집 메뉴를 표시하기 위해 텍스트 편집 메뉴에서 사용됩니다.

그리고 마지막으로, 큰 요소 크기는 메뉴에 기본, 전체 너비 모양을 제공한다.

또한, 작업이 수행된 후 메뉴를 유지하기 위해 UIMenuElement에 새로운 .keepsMenuPresented 속성이 있습니다.

이 속성을 사용하면 메뉴를 다시 표시하지 않고도 작업을 여러 번 수행할 수 있습니다.

그것은 새로운 편집 메뉴의 빙산의 일각에 불과하다.

텍스트 편집 메뉴를 사용자 정의하여 텍스트 편집 기능을 확장하세요.

메뉴가 다른 프레젠테이션 스타일로 완벽하게 보이도록 행동에 제목과 이미지가 있는지 확인하세요.

가장 중요한 것은 플랫폼과 다양한 입력 방법 전반에 걸쳐 더 나은 사용자 정의 가능성과 향상된 일관성을 위해 새로운 UIEditMenuInteraction을 채택하는 것입니다.

새로운 편집 메뉴에 대한 지원을 추가하는 것은 훌륭한 첫 번째 단계이다.

데스크톱 수업 편집 경험을 완성하기 위해, 나는 새로운 시스템 찾기 및 교체 경험에 대해 이야기하기 위해 그것을 제임스에게 넘길 것이다.

제임스 마가헤른: 아, 저기 있어!

안녕하세요, 저는 UIKit 엔지니어인 James Magahern입니다. 찾기와 교체에 대해 이야기하기 위해 왔습니다.

iOS 16의 새로운 기능, 우리는 앱에서 텍스트를 찾고 대체하기 위한 새로운 UI 구성 요소를 도입했습니다.

그것은 시스템 전반에 걸쳐 표준이며 많은 내장 앱에 포함되어 있으며, 사용자가 훨씬 더 일반적으로 사용되는 편집 단축키로 근육 메모리를 조정할 수 있습니다.

이것은 iPad에서 실행되는 새로운 찾기 패널입니다.

우리는 하드웨어 키보드가 부착될 때 단축키바와 함께 인라인으로 뜨는 것에서 하드웨어 키보드 없이 사용할 때 소프트웨어 키보드 위에 놓이는 것으로 자동으로 전환할 것입니다.

iPhone에서, 우리는 더 컴팩트한 레이아웃을 사용하여 더 작은 화면 크기에 적응할 것입니다.

자동 해고, 최소화 및 키보드 회피는 모두 시스템에 의해 처리됩니다.

Mac에서 앱을 실행할 때, 우리는 당신의 콘텐츠와 인라인으로 찾기 패널을 제시하고, AppKit 찾기 바처럼 작동하며, 사용자가 Mac에서 기대하는 친숙한 레이아웃을 사용할 것입니다.

UITextView, WKWebView 또는 PDFViews를 사용하여 앱에 텍스트 콘텐츠를 표시하는 경우, 시작하려면 내장된 찾기 상호 작용에서 isFindInteractionEnabled를 true로 설정하기만 하면 됩니다.

그렇게 간단해!

또한, QuickLook을 사용하여 텍스트 콘텐츠를 표시하는 경우, 작업 없이 이미 사용할 수 있습니다.

하드웨어 키보드를 사용하면 find를 위한 command+F, 다음 찾기를 위한 command+G, 이전 찾기를 위한 command+shift+G 등과 같은 모든 표준 시스템 단축키가 예상대로 작동합니다.

Mac에서 실행할 때 메뉴 표시줄을 통해 이러한 명령에 액세스할 수 있습니다.

콘텐츠를 표시하는 보기가 첫 번째 응답자가 될 수 있는지 확인하기만 하면 됩니다.

하드웨어 키보드를 사용하지 않는 사용자의 경우, 포함된 찾기 상호 작용 속성에서 presentFindNavigator를 통해 프로그래밍 방식으로 찾기 상호 작용을 호출할 수 있습니다.

예를 들어, 내비게이션 바 항목을 통해 이것을 사용할 수 있도록 하는 것이 좋은 생각일 수 있습니다.

Mac에서 실행할 때, 명심해야 할 몇 가지 다른 사항이 있습니다.

예를 들어, iOS에서 찾기 패널은 소프트웨어 키보드 또는 단축키 바의 일부로 표시됩니다.

Mac에서, 우리는 당신의 콘텐츠와 함께 인라인으로 표시할 것입니다.

스크롤 보기에 찾기 상호 작용을 설치하는 경우, 찾기 패널을 수용하기 위해 콘텐츠 삽입을 자동으로 조정하고 특성 수집 변경 사항에 자동으로 적응합니다.

그렇지 않으면 macOS의 UI에서 찾기 패널을 호스팅할 충분한 공간이 있는지 확인해야 합니다.

또한, 돋보기 아이콘을 탭할 때 사용할 수 있는 표준 찾기 옵션이 포함된 메뉴를 보여줄 것입니다.

UIFindInteraction의 optionsMenuProvider 속성을 사용하여 이 메뉴의 내용을 사용자 정의할 수 있습니다.

이것은 사용자 지정 구현에서 더 중요할 것이다.

그리고 내가 전에 언급한 내장 뷰 중 하나를 사용하는 경우 그것이 필요한 전부입니다.

앱이 여기에 표시된 완전히 사용자 지정 보기 또는 목록 보기와 같은 다른 방법으로 텍스트 콘텐츠를 표시하는 경우, 여전히 앱에 찾기 상호 작용을 추가할 수 있습니다.

어떻게 하는지 보여줄게.

상호 작용을 찾는 것에 대한 좋은 소식은 임의의 보기에 설치할 수 있다는 것입니다.

앱에 기존 찾기 및 교체 구현이 있다면, UIFindInteraction으로 연결하여 시스템의 UI를 활용할 수 있습니다.

사용자 지정 보기에 대한 기존 찾기 구현이 아직 없다면, 특히 시스템 키보드로 작업하기 위해 UITextInput 프로토콜을 이미 구현한 경우 시작하기가 매우 쉽습니다.

UIFindInteraction이 사용자 지정 보기와 함께 작동하는 방법은 다음과 같습니다.

사용자 지정 보기에 UIFindInteraction을 설치한 후, 찾기 상호 작용 대리자를 설정하십시오.

찾기 상담 대리인은 찾기 세션이 시작되거나 끝날 때 알림을 받는 것 외에도 UIFindSessions를 처리할 책임이 있습니다.

UIFindSession은 현재 강조 표시된 결과와 같이 주어진 세션의 모든 상태를 캡슐화하는 추상적인 기본 클래스입니다.

또한 "다음 결과로 이동" 또는 "이 문자열 검색"과 같이 UI에서 요청된 모든 작업을 제공합니다.

이 모든 상태를 직접 관리하고 싶다면, 찾기 상호 작용 대리인으로부터 UIFindSession의 하위 클래스를 판매하도록 선택할 수 있습니다.

앱에 이미 기존 찾기 및 교체 구현이 있고 시스템 UI에 연결하고 싶다면 이것은 좋은 옵션입니다.

그렇지 않으면, 시스템이 당신을 위해 상태를 처리하도록 하고, 대신 표시되는 문서의 내용을 캡슐화하는 모든 클래스에 UITextSearching 프로토콜을 채택하는 것이 훨씬 더 좋은 생각일 것입니다.

이렇게 하려면, UITextSearchingFindSession을 반환하고 문서 클래스와 연결해야 합니다.

아직 사용자 지정 보기에 대한 구현을 찾지 못한 경우 이것이 최선의 선택입니다.

코드에서 이것을 하는 방법은 다음과 같습니다.

이 예제에는 사용자 지정 문서 클래스와 이 문서를 표시하는 사용자 지정 보기가 있습니다.

UIFindInteraction이 이 보기에 설치되며, UITextSearchingFindSession은 이 문서와 함께 "검색 가능한 객체"로 제공됩니다.

키보드 단축키가 예상대로 작동하도록 뷰 컨트롤러 또는 사용자 지정 뷰가 첫 번째 응답자가 될 수 있는지 확인하십시오.

찾기 상호 작용을 만들고, 찾기 세션을 처리하기 위해 세션 대리인을 제공하세요.

여기서, 뷰 컨트롤러는 세션 대리인이다.

그런 다음, 상호 작용으로 찾기 세션을 요청하면, 문서를 검색 가능한 객체로 제공하는 새로운 UITextSearchingFindSession을 반환하기만 하면 됩니다.

물론 문서 클래스가 UITextSearching 프로토콜을 준수하는지 확인해야 합니다.

UITextSearching 프로토콜을 구현하는 클래스는 실제로 문서에서 텍스트를 찾는 역할을 합니다.

시스템은 performTextSearch를 호출하고 결과를 제공할 수 있는 애그리게이터 객체를 건네줄 것입니다.

애그리게이터는 UITextRange와 함께 작동하여 문서의 결과를 나타냅니다.

이것은 텍스트를 저장하는 방법에 맞는 데이터를 캡슐화하는 데 사용할 수 있는 또 다른 추상 클래스입니다.

예를 들어, 이것은 WebKit을 사용하여 텍스트를 렌더링하는 클라이언트의 DOM 범위를 나타낼 수 있습니다.

애그리게이터는 또한 스레드로부터 안전하므로, 백그라운드 스레드에서 결과를 제공할 수 있습니다.

마지막으로, 찾기 상호 작용은 사용자 지정 보기를 사용하여 결과를 표시하는 방법을 모르기 때문에, decorate()가 호출될 때 주어진 스타일에 대한 결과를 장식해야 합니다.

UITextSearching 찾기 세션과 프로토콜은 또한 동일한 상호 작용을 사용하여 여러 눈에 보이는 문서에서 다중화를 지원합니다.

즉, 앱이 Mail의 대화 보기와 유사한 방식으로 콘텐츠를 표시하는 경우, 이 경우 각 "문서"가 메일 메시지인 경우, 루트 레벨 컬렉션 보기에 단일 찾기 상호 작용을 설치하고 모든 문서에서 동시에 찾기를 수행하여 사용자가 다른 문서의 결과 사이를 쉽게 이동할 수 있습니다.

그래서 그것이 iOS 16에서 새로운 찾기 상호 작용을 시작하는 데 필요한 전부입니다.

많은 텍스트 콘텐츠를 표시하는 시스템 뷰의 경우, isFindInteractionEnabled를 활성화해야 합니다.

기존 찾기 구현을 UIFindInteraction으로 옮기세요.

아직 앱에 텍스트 검색이 없다면 UITextSearching을 구현하고 UITextSearchingFindSession을 사용하세요.

그리고 마지막으로, 앱에 충돌하는 키보드 단축키가 없는지 확인하세요.

그리고 그것이 iOS 16에 대한 앱의 편집 상호 작용을 새로 고치고 진정한 데스크톱 클래스로 만드는 데 필요한 것입니다.

앱에서 새로운 텍스트 편집 메뉴를 시도하고, 사용자 지정 UI를 위한 편집 메뉴 상호 작용을 채택하세요.

그리고 앱의 텍스트 콘텐츠를 검색할 수 있게 하여 생산성을 높이세요.

저는 당신의 앱에서 이 훌륭한 새로운 기능을 찾기를 고대하고 있습니다.

봐줘서 고마워! 좋아요를 누르고, 댓글을 달고, 구독하세요.

.