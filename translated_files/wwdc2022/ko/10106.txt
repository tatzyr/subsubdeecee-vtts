10106

♪ ♪

프로필에 오신 것을 환영하며 게임의 메모리를 최적화하세요.

저는 Apple의 GPU 소프트웨어 팀의 Jack Xu(许)입니다.

우리는 내 동료 Seth Lù (陆)와 합류했다.

지난 몇 년 동안, 우리 팀은 게임 메모리를 함께 이해하고 개선하기 위해 당신과 같은 게임 개발자들과 협력해 왔습니다.

오늘, 우리는 우리의 학습을 공유하고 싶기 때문에, 게임의 메모리를 디버깅하고 최고의 플레이어 경험으로 멋진 게임을 만들 때 앞서 시작할 수 있습니다.

우리는 CPU와 GPU 객체 모두에서 게임의 메모리 사용량을 분류할 것입니다.

게다가, 게임의 할당, 물리적 메모리의 실제 사용 및 객체 간의 참조를 분석하십시오.

기억의 많은 측면이 있기 때문에, 우리의 개발자 도구는 또한 다양한 각도에서 기억의 신비를 드러낸다.

우리는 가이드 투어를 하고, 터미널의 Xcode, Instruments 및 명령줄 도구를 포함하여 모든 것을 사용하는 방법을 경험할 것입니다.

오늘의 가이드 투어에서, 우리는 게임 기억을 이해하기 위한 전주곡으로 시작할 것이다.

그리고 세스가 우리에게 악기에 대해 말해줄 기억과 기억 성장 프로파일링을 시작하세요.

인스트루먼트로 일시적인 접근 방식을 취한 후, 우리는 우리의 여정을 발전시키고, Xcode와 터미널의 도구를 사용하여 게임의 메모리 그래프를 분석할 것입니다.

이러한 워크플로우는 메모리 사용의 현재 상태와 총 게임 메모리의 분해에 중점을 둡니다.

마지막으로, 세스는 메탈 디버거를 사용하여 게임 메모리의 핵심 영역인 메탈 리소스를 최적화하는 방법을 공유할 것입니다.

이제, 게임 메모리를 이해하기 시작합시다.

Metal 샘플 코드를 사용한 현대 렌더링과 같은 Xcode에서 게임을 시작할 때, Xcode의 디버그 네비게이터에서 이 메모리 보고서를 열 수 있습니다.

게임의 현재 및 최근 메모리 사용량과 시스템에 미치는 영향 수준에 대한 첫 번째 견해입니다.

게이지의 숫자는 게임의 현재 메모리 사용을 보여줍니다.

메모리 디버깅의 중요한 첫 번째 단계는 이 숫자가 무엇을 의미하는지 이해하는 것이다.

한 줄에 넣으면, 게임의 실제 메모리 사용은 할당과 같지 않습니다.

실제 메모리 사용은 물리적 메모리에 있다.

할당은 가상 메모리 주소 공간에서 게임에서 요청한 메모리입니다.

그리고 다른 종류의 할당은 자연스럽게 별도로 계산된다.

게임이 메모리를 할당할 때, 이러한 새로운 할당은 즉시 또는 직접 물리적 메모리의 공간을 차지하지 않습니다.

반대로, 그들은 시스템이 각 프로세스에 제공하는 가상 메모리 주소 공간에 약간의 공간을 예약할 것이다.

그리고 프로그램이 실제로 나중에 이 할당을 사용할 때, 시스템은 물리적 메모리에 공간을 준비할 것이다.

같은 종류의 할당은 범주로 그룹화되며, 가상 주소 공간을 거의 차지하지 않는다.

이러한 범주에는 프로그램의 실행 가능한 바이너리, 모든 라이브러리 및 프레임워크, 일부 함수 인수뿐만 아니라 로컬 및 임시 변수에 대한 스토리지를 제공하는 스택, 힙으로도 알려진 동적 메모리 영역, 프로그램이 수동으로 할당하는 클래스 인스턴스 스토리지 및 메모리, 게임 자산 파일과 같은 읽기 전용 리소스에서 매핑된 영역, 그리고 물론 버퍼, 텍스처 및 파이프라인 상태 객체와 같은 게임의 금속 개체가 포함될 수

그리고 이 카테고리들은 지역으로 이루어져 있다.

후드 아래에서, 메모리 작업은 최신 Apple 장치에서 각각 16키비바이트인 메모리 페이지의 세분성에서 작동합니다.

이것은 각 지역이 하나 이상의 페이지를 차지하며, 적어도 16키비바이트의 크기라는 것을 의미한다.

게임이 계속됨에 따라, 메모리의 상태는 계속 진화한다; 새로운 물체가 할당되고, 오래된 아이템이 파괴되고, 지역은 계속 변한다.

하지만 지역에서 사용된 페이지만 물리적 메모리에 있으며, 시스템은 다른 앱과 마찬가지로 게임에 부지런히 청구합니다.

게임의 메모리 페이지는 세 가지 종류 중 하나가 될 수 있습니다: 더럽고, 압축되고, 깨끗합니다.

그들이 무엇인지 확인해 보자.

더러운 메모리 페이지에는 당신의 게임이 쓴 메모리가 포함되어 있습니다.

여기에는 게임이 변수나 기호를 수정하면 힙의 메모리 할당과 프레임워크가 포함됩니다.

애플 실리콘이 있는 장치에서, 접근한 금속 자원도 이 범주에 속하는데, 이는 CPU와 GPU가 동일한 고속 통합 메모리 풀을 공유하기 때문이다.

그러나, 일부 더러운 페이지를 오랫동안 사용하지 않으면, 시스템은 이러한 페이지를 압축하거나 스와핑이라고 부르는 플래시 또는 디스크에 저장하여 물리적 메모리의 존재를 줄일 수 있습니다.

이것은 장치가 더 많은 앱과 서비스를 실행할 수 있게 해줄 것이다.

나중에, 당신의 게임이 이 페이지들을 다시 요청하면, 시스템은 디스크에서 압축을 풀거나 페이지를 넘길 것입니다.

참고로, 당신의 게임은 여전히 압축되지 않은 크기로 청구될 것입니다.

깨끗한 메모리 페이지의 경우, 텍스처 또는 오디오 자산과 같은 디스크에서 매핑된 읽기 전용 파일과 프로세스에 로드된 프레임워크가 포함됩니다.

시스템은 언제든지 디스크에서 비우거나 다시 로드할 수 있으므로, 게임의 메모리 풋프린트에 포함되지 않습니다.

그러나, 그것들은 메모리에 상주할 수 있으며, 과도한 사용은 시스템과 게임을 느리게 할 것이다.

우리가 메모리 발자국이라고 부르는 처음 두 부분을 보는 것이 보통 가장 흥미롭다.

그리고 시스템은 메모리 제한을 시행하기 위해 이것을 사용한다.

일부 용어에서, 사람들은 더러운 것이 깨끗한 것의 반대이기 때문에 기억 발자국을 의미할 때 "더러운 기억"이라고 말한다.

하지만 걱정하지 마세요, 상황이 흐릿해지면, 우리는 우리가 어떤 것을 의미하는지 말할 것입니다.

이제 메모리가 어떻게 작동하는지, 그리고 시스템이 게임에 어떻게 충전하는지 알 수 있습니다.

이 Xcode 메모리 게이지 외에도, Mac의 활동 모니터 앱을 포함하여 시스템의 많은 곳에서 메모리 풋프린트를 찾을 수 있습니다.

그리고 일부 애플 플랫폼은 앱 메모리 제한을 위해 그것을 사용한다.

당신의 게임은 또한 이 메트릭을 사용하여 메모리 사용을 안내할 수 있습니다.

현재 풋프린트와 사용 가능한 메모리를 쿼리하는 유용한 API가 있습니다.

여기 잠깐 봐.

iOS, iPadOS 또는 tvOS 게임에 사용 가능한 시스템 메모리를 얻으려면, os/proc.h 헤더 파일에 있는 os_proc_available_memory를 호출하십시오.

그리고 모든 Apple 플랫폼의 메모리 풋프린트의 경우, 현재 버전 6인 "get pid", "rusage_info_current" 및 데이터 저장소의 프로세스 ID와 함께 proc_pid_rusage를 통해 얻을 수 있습니다.

그리고 물리적 발자국 또는 평생 최대 물리적 발자국 속성을 검색합니다.

요약하자면, 이 첫 번째 섹션에서, 우리는 기억에 대한 몇 가지 개념을 검토했다.

게임의 할당은 가상 메모리 주소 공간에서 발생하며, 게임에서 액세스하면 16키비바이트 페이지로 물리적 메모리 공간을 차지할 것입니다.

메모리 풋프린트는 게임의 실제 메모리 사용을 결정하기 위한 Apple 플랫폼의 기본적이고 보편적인 지표입니다.

메모리 풋프린트에는 더럽고, 압축되고, 교체된 페이지가 포함되어 있습니다.

그것은 애플 실리콘에 CPU와 GPU 객체를 모두 포함한다.

그리고 그것은 메모리 제한 시행에 사용된다.

당신의 게임은 시스템 API를 호출하여 발자국과 사용 가능한 메모리를 얻을 수 있습니다.

이제 메모리가 무대 뒤에서 어떻게 작동하는지 알았으니, 게임에서 어떻게 보이는지 알아봅시다.

내가 Seth에게 넘겨줄게, 너에게 더 말해줄게.

세스 루: 고마워, 잭.

이제, 게임의 메모리 성장을 포착하는 것을 시작합시다.

그리고 나는 모던 렌더러 샘플 프로젝트를 계속 사용할 것이다.

Xcode에서 게임을 실행할 때, 메모리 게이지는 시간이 지남에 따라 메모리 공간을 보여줍니다.

그러나, 인스트루먼트에서 게임을 프로파일링하여 메모리 사용을 훨씬 더 자세히 살펴볼 수 있습니다.

종종 게임이 출시 시간에 많은 메모리를 할당할 수 있기 때문에, 기존 실행에 첨부하는 대신 새로운 게임 출시에서 프로파일링을 시작할 수 있습니다.

Xcode에서 게임 프로파일링을 빠르게 시작하려면 실행 버튼을 길게 누른 다음 "프로필"을 선택하십시오.

이것은 자동으로 당신을 악기로 데려갈 것입니다.

인스트루먼트 앱에는 시스템의 다양한 측면을 기록하고 타임라인에 기록된 데이터를 시각화하는 프로파일링 도구 모음이 포함되어 있습니다.

올해의 새로운 것은 메탈 게임의 메모리 성장을 더 잘 이해하는 데 도움이 될 수 있는 게임 메모리 템플릿입니다.

이 템플릿은 기록과 함께 메모리 할당을 기록하는 할당 및 금속 자원 이벤트 도구, 메모리 풋프린트를 기록하는 VM 트래커, 가상 메모리 활동을 기록하는 가상 메모리 추적, 금속 관련 이벤트를 기록하는 금속 응용 프로그램 및 GPU와 함께 제공됩니다.

그리고 이 데모에서, 나는 처음 세 가지 도구를 강조할 것이다: 할당, 금속 자원 이벤트, 그리고 VM 트래커.

하지만 먼저, 게임에 대한 흔적을 기록해 봅시다.

여기서 녹음 버튼을 눌러 녹음을 시작할 수 있습니다.

그리고 나중에, 녹음을 중단하려면, 같은 버튼을 누르거나 게임을 종료할 수 있습니다.

악기가 모던 렌더러를 녹음하는 동안, 추적을 기록하는 다른 방법을 보여드리겠습니다.

Xctrace 명령을 사용하면 프로그래밍 방식으로 녹음을 수행할 수 있으며, 이는 자동화 워크플로우에 유용할 수 있습니다.

또한, 장치 이름을 지정하여 iPhone, iPad 또는 Apple TV를 대상으로 선택할 수 있습니다.

이제 악기 추적을 캡처했으니, 먼저 할당을 살펴봅시다.

할당 도구는 메모리 할당, 크기 및 객체 참조 수에 대한 자세한 보기를 제공합니다.

그러나, 그것은 민간 금속 자원을 포함하지 않는다.

통계 보기는 모든 힙 할당과 익명의 VM을 표시합니다.

모든 힙 할당에는 객체를 포함할 수 있는 malloc'ed 버퍼가 포함되어 있으며, 모든 익명 VM에는 더러울 수 있는 흥미로운 VM 영역이 포함되어 있습니다.

그리고 우리는 잠시 후에 일부 금속 자원이 이 범주에 속한다는 것을 알게 될 것이다.

이제, 모든 힙 할당 내부를 살펴봅시다.

보통, 더 큰 할당은 최적화에 더 흥미롭다.

가장 큰 단일 할당을 찾으려면, 크기 테이블 열을 클릭하여 크기별로 할당을 정렬할 수 있습니다.

할당의 경우, 이 화살표를 클릭하여 Swift 및 Objective-C 개체의 참조 개수 변경 사항을 볼 수 있습니다.

그리고 목록에서 이 큰 할당을 선택하면, 인스펙터에 할당 이력의 스택 추적이 있습니다.

버튼을 클릭하면 시스템 라이브러리나 프레임워크를 숨길 수 있습니다.

그리고 여기서, 스택 추적에 따르면, Modern Renderer가 자산을 로드했을 때 할당이 발생했다.

프레임을 두 번 클릭하면 소스 코드로 갈 수 있습니다.

이제 돌아가서 "모든 익명 VM" 카테고리를 살펴봅시다.

메탈 게임에서는 IOAccelerator와 IOSurface 카테고리에서 많은 할당을 찾을 수 있습니다.

IOAccelerator의 할당은 금속 자원에 해당한다.

스택 추적에서 자산을 로드하는 동안 이 할당이 일어난 것을 볼 수 있습니다.

IOSurface의 할당은 드로어블에 해당한다.

그리고 여기서, 스택 추적은 드로어블을 요청한 MetalKit 뷰를 보여줍니다.

할당 도구는 기본적으로 할당 크기를 시각화합니다.

그러나, 그것은 또한 대안적인 외모와 함께 온다.

할당 트랙의 화살표 버튼에서 할당 밀도를 시각화하기 위해 디스플레이 모드를 사용자 정의할 수 있습니다.

이것은 그래프를 업데이트하여 시간이 지남에 따라 수행된 할당의 양을 보여주고 메모리 할당에 대한 스파이크를 드러낼 것입니다.

이 스파이크는 기억 성장의 원천이 될 수 있다.

그래서 할당에 표시된 데이터는 꽤 낮은 수준이다.

할당된 금속 자원을 더 잘 이해하려면, 금속 자원 이벤트로 넘어가자.

금속 자원 이벤트 도구는 금속 자원을 중심으로 설계되었다.

자원 이벤트 보기에서 금속 자원 할당 및 할당 해제의 기록을 찾을 수 있습니다.

여기서, 당신은 또한 Metal API를 통해 프로그래밍 방식으로 지정할 수 있는 라벨로 Metal 자원을 식별할 수 있습니다.

그리고 할당 도구와 마찬가지로, 인스펙터에서 할당 기록에 대한 스택 추적을 찾을 수 있습니다.

이 악기는 또한 금속 장치 아래에 할당 및 할당 트랙을 추가합니다.

그들은 사건의 밀도를 시각화하는 데 도움을 준다.

지금까지, 할당과 금속 자원 이벤트는 메모리 할당을 이해하는 데 도움이 될 수 있다.

그러나, 할당이 항상 메모리 풋프린트로 변환되는 것은 아니다.

그럼 실제 메모리 사용을 조사하기 위해 VM 트래커로 넘어가자.

VM 트래커 기기는 압축되지 않은 더럽고 압축되거나 교체된 메모리를 보여줍니다.

더러운 크기는 압축되지 않은 더러운 메모리를 나타낸다.

그리고 스왑된 크기는 압축되거나 스왑된 메모리를 나타냅니다.

이 녹음에는 모던 렌더러에서 압축되거나 교환된 메모리 사용이 없습니다.

자세한 요약 보기는 VM 지역을 보여줍니다.

그리고 "매핑된 파일" 영역에서 게임 자산과 같은 메모리 매핑된 리소스를 찾을 수 있습니다.

여기서, 모던 렌더러는 비스트로 자산 파일을 메모리에 매핑한다.

그래서 그것은 인스트루먼트의 할당, 금속 자원 이벤트 및 VM 트래커에 대한 간략한 개요입니다.

메모리 성장을 프로파일링하는 방법을 빠르게 요약하려면: 먼저 게임 메모리 템플릿을 선택한 다음 추적을 기록하고 분석하십시오.

때때로, 당신은 기억 성장 패턴을 재현하거나 확인할 때 이 과정을 몇 번 반복할 수 있습니다.

새로운 게임 메모리 템플릿이 게임의 메모리 할당이나 발자국 증가를 더 잘 이해하는 데 도움이 되기를 바랍니다.

그리고 악기 사용에 대해 자세히 알아보려면 이 다른 비디오를 확인하세요.

이제, 잭에게 돌아가.

게임 메모리 템플릿은 정말 멋져 보이며, 시간이 지남에 따라 메모리 사용의 변화를 이해하는 데 매우 유용할 것이다.

또한, 주어진 시간에 게임의 메모리 상태를 캡처하고 싶을 수도 있으므로, 그 메모리 상태를 더 깊이 파고들어 다른 렌즈를 통해 검사할 수 있습니다.

그리고 그것을 위해, 우리는 메모리 그래프와 도구 모음을 가지고 있다.

메모리 그래프는 개체 생성 기록, 참조 및 압축 또는 스왑을 포함하여 게임의 메모리 상태의 전체 스냅샷을 효율적으로 저장하는 파일입니다.

비교를 위해 문제가 발생하기 전과 후에 문제가 발생하거나 한 쌍의 경우와 같이 언제든지 스냅샷을 찍을 수 있습니다.

양념을 더하기 위해, 메모리 그래프로 메모리를 분석하는 방법에 대한 요리책 비유를 사용합시다.

그것은 재료와 준비 부분을 포함한다.

재료를 위해, 음, 당신은 당신의 게임이 필요할 것입니다; Malloc Stack Logging이라고 불리는 것; 그리고 캡처된 메모리 그래프.

Malloc Stack Logging을 구성하고 메모리 그래프를 캡처하는 것은 빠릅니다.

Malloc Stack Logging은 게임 과정에서 할당 정보를 기록합니다.

Scheme 설정에서 찾을 수 있습니다.

실행 동작을 선택하고, 진단으로 이동한 다음, Malloc Stack Logging 확인란을 선택하십시오.

두 가지 옵션이 무엇인지 궁금하다면; 모든 할당과 무료 기록은 할당이 해제된 후에도 모든 객체를 추적합니다.

로깅 데이터는 더 많은 메모리를 차지할 수 있지만, 단편화와 같은 문제를 디버깅하는 데 유용합니다.

반면에, 라이브 할당은 역사에서 할당된 객체만 폐기하므로 더 가볍다.

이 경우, 저는 살아있는 물체에 있는 참조만 조사하고 있으므로, 이 옵션을 선택할 수 있습니다.

사실, 대부분의 경우, Live Allocation Only가 권장되는 옵션이 될 것입니다.

또는, Xcode에서 시작하지 않으면 환경 변수를 설정할 수 있습니다.

몇 가지 추가 녹음 모드는 malloc 매뉴얼 페이지를 확인하세요.

그 후, 메모리 그래프도 준비하세요.

디버그 영역에서 디버그 메모리 그래프 버튼을 클릭하기만 하면 됩니다.

Xcode는 메모리 스냅샷을 찍고, 처리하고, 메모리 디버거를 입력할 것이다.

Xcode 메모리 디버거는 게임의 메모리 사용에 대한 직관적인 관점을 제공합니다.

잠시 시간을 내어 경치를 탐험해 봅시다.

왼쪽에서 디버그 네비게이터는 객체 인스턴스의 계층적 목록을 제공합니다.

오른쪽의 파일 인스펙터는 메모리 풋프린트, 가동 시간 및 캡처 날짜와 같은 유용한 정보를 제공합니다.

중간 영역에서는 왼쪽에서 선택한 개체가 있는 메모리 그래프 보기와 참조가 이 개체에 어떻게 연결되는지 표시됩니다.

조금 있다가 이 그래프로 돌아올게.

그리고 파일 메뉴는 향후 분석을 위해 이 메모리 그래프를 저장하거나 팀과 쉽게 공유할 수 있는 옵션을 제공합니다.

Mac 게임의 경우, 프로세스 ID 또는 이름을 사용하여 누출 명령줄 프로그램으로 메모리 그래프를 캡처할 수도 있습니다.

이것은 보안 셸에서 원격으로 할 수 있다는 것을 의미하므로, 게임이 전체 화면으로 실행되고 초점을 유지해야 할 경우를 대비하여 커서가 게임에 남아 있습니다.

그래서 그것이 당신이 메모리 그래프 분석을 시작하는 데 필요한 것입니다.

이제 Xcode 메모리 디버거와 터미널의 다양한 명령줄 도구를 사용하여 할당, 풋프린트 등을 찾기 위해 이 메모리 그래프를 검토할 때입니다.

좋은 첫 번째 단계는 카테고리별로 메모리 사용을 나누는 것이다.

발자국 프로그램은 바로 그것을 한다.

발자국은 메모리 그래프의 정보를 사용하여 이 높은 수준의 요약을 재현합니다.

일반적으로, 당신은 먼저 더 큰 범주에 집중하고 싶을 것입니다.

현대 렌더링 샘플 코드의 이것과 같은 게임 메모리 그래프의 경우, IOAccelerator는 일반적으로 가장 큰 것이다.

세스가 말했듯이, 그것은 금속 자원을 포함한다.

여기서, 힙 할당은 여러 MALLOC_(접두사) 범주로 이동한다. 왜냐하면 시스템은 성능을 향상시키기 위해 크기 풀에 힙 할당을 그룹화하기 때문이다.

이러한 물체는 게임이 음향 효과나 물리 시뮬레이션을 하는 타사 플러그인이나 라이브러리와 같은 많은 곳에서 올 수 있습니다.

여기 윌리엄 "치어" 스튜디오가 만든 멋진 애플 아케이드 게임 매니폴드 가든의 메모리 그래프가 있습니다.

그들이 당신에게 게임의 메모리 사용량을 보여줄 수 있게 해줘서 기쁩니다.

게임이 유니티를 사용하는 매니폴드 가든이나 메모리 맵 상단의 사용자 지정 할당자와 같은 게임 엔진을 사용하는 경우, 해당 메모리는 다음과 같이 태그가 지정되지 않은 VM_ALLOCATE로 표시됩니다.

여기 프로 팁이 있습니다: Apple 플랫폼에서, 당신의 게임은 최대 16개의 앱별 태그를 사용할 수 있으므로, 메모리 사용량을 드릴다운할 때 더 많은 명확성을 가질 수 있습니다.

그것은 한 줄을 바꾸는 것만큼 쉽다.

먼저, 16가지 옵션 중 하나에서 태그를 만드세요.

그런 다음 "em map"을 호출할 때 마이너스를 이 새 태그로 "파일 설명자"로 바꾸세요.

태그와 카테고리가 어떻게 정의되는지 알아보려면 "em map's" 매뉴얼 페이지를 확인하세요.

"Mach VM allocate"를 사용하는 경우, 할당할 때 플래그 인수에 동일한 플래그를 포함하세요.

발자국 프로그램의 세계에서, 더러운 크기는 또한 스왑과 압축을 포함하므로, 각 카테고리에 대한 총 청구로 생각하십시오.

그것은 현재 메모리 사용의 구성과 그것이 어떻게 발자국을 구성하는지에 대한 간략한 생각이다.

이 메모리 중 일부는 덜 사용되고 압축되거나 교체된다.

그것들은 메모리 절약의 원천이 될 수 있다.

다음 단계는 게임이 얼마나 많은 압축되거나 교체된 메모리를 사용하는지 알아내고 최적화하는 것이다.

이를 위해, 당신은 vmmap으로 메모리 그래프를 실행할 수 있습니다.

그것은 당신에게 두 개의 결합된 대신 더럽고 교환된 크기를 제공합니다.

이 더러운 열에는 현재 교환되거나 압축되지 않은 일반 더러운 메모리가 포함되어 있으며, 교환된 열에는 압축되거나 교환된 메모리의 원래 크기가 포함됩니다.

그 시스템은 발자국을 결정하기 위해 이 두 열을 함께 추가한다.

하지만 교체된 크기 열의 콘텐츠는 자주 사용되지 않기 때문에, 게임의 메모리를 최적화하기 위해 무엇을 찾아야 하는지에 대한 좋은 지표입니다.

오, 그건 그렇고, 여기 가상 크기 열이 있는 할당 크기가 있습니다.

그리고 상주 크기는 실행 파일과 메모리 매핑 파일과 같은 깨끗한 페이지를 포함한다.

편리하게, vmmap은 별도의 테이블로 힙 할당을 보여준다.

출력의 하단에서, vmmap은 힙 메모리를 영역별로 그룹화한다.

이 구역들은 당신의 게임에서 그들의 사용이나 수명 주기를 반영합니다.

MallocStackLogging을 켰기 때문에, 힙의 할당은 도구 영역에 있습니다.

그렇지 않으면, 그들은 할당 크기에 따라 MallocHelperZone과 DefaultMallocZone이라는 두 개의 기본 영역에 있을 것이다.

그리고 보통 QuartzCore 영역과 같은 더 작은 시스템 유틸리티 영역을 건너뛸 수 있습니다.

또한, 수십 또는 수백 메가바이트와 같은 높은 단편화 크기 또는 백분율로 표시된 단편화가 의심되는 경우, WWDC 2021 세션은 단편화 문제에 대해 더 많이 다룹니다.

그리고 대시 대시 요약 없이 vmmap을 실행하거나 표준 모드에서 vmmap을 사용하려면 해당 범주 내의 각 vm 영역을 한 줄씩 보여줍니다.

우리가 앞서 논의했듯이, 가상 주소 공간이 어떻게 생겼는지와 같다.

따라서 vmmap을 사용하면 적극적으로 사용되는 메모리에서 덜 사용되는 더러운 메모리를 추출할 수 있습니다.

그리고 일반적으로, 게임에서 다양한 크기의 동적 할당 또는 malloc'd 힙 메모리 사용량도 있습니다.

그들은 특별한 모습이 필요해.

힙 도구는 클래스별로 malloc'd 리소스를 그룹화하고 인스턴스 수별로 정렬합니다.

이 클래스는 VTable, Objective-C 또는 Swift를 사용하여 C++로 결정됩니다.

우리는 일부 메타데이터에 대한 헤더를 건너뛰기 위해 —quiet 인수를 사용하고 있습니다.

올해 새로운, 힙은 물체 유형을 식별하는 데 더 지능적이다.

그것은 Malloc Stack Logging에 의해 기록된 정보를 사용하여 발신자 또는 책임 있는 라이브러리를 제시하므로, 거대한 비 객체는 과거의 일이다.

그리고 여기 매니폴드 가든의 메모리 그래프가 있습니다.

이 예에서, FMOD Studio와 같은 플러그인과 GameAssembly.dylib와 같은 게임 구성 요소에 의해 얼마나 많은 힙 사용량이 사용되는지 처음으로 밝혀졌습니다.

그래서 이제 당신은 메모리가 어떻게 분산되는지에 대해 더 많은 정보를 얻을 수 있습니다.

그리고 그것은 또한 이 물건들에 대한 더 많은 정보를 얻기 위해 어느 방향으로 가야하는지 암시한다.

이 예에서 개발자는 FMOD Studio를 열어 게임의 사운드트랙과 음향 효과를 미세 조정하거나 Unity로 이동하여 게임 코드 최적화를 찾을 수 있습니다.

때때로, 클래스 인스턴스 수가 아닌 클래스 총 크기로 정렬하는 것이 더 도움이 된다.

현대 렌더링 샘플 프로젝트의 메모리 그래프에서, 최고 기여자는 2억 5천 8백만 바이트 이상을 사용하는 클래스이다.

현대 렌더링 샘플에서 더 큰 객체를 계속 찾으려면, 힙을 사용하여 —sortBySize로 클래스 총 크기별로 객체를 정렬하고, 각 클래스의 요약이 아닌 —showSizes로 모든 객체를 나열하십시오.

그리고, 바이트 스토리지에 크기가 2억 5천 5백만 바이트인 NSConcreteMutableData의 객체가 하나 있다: 그것은 볼 가치가 있는 것처럼 보인다.

다음으로, 나는 그것이 무엇인지 알고 싶다.

그리고 나는 그것의 주소를 알고 싶어.

나는 -주소를 추가하고 NSConcreteMutableData 패턴과 와일드카드- 도트 스타를 입력하고, 괄호 안에 크기 필터를 입력하여 10메가바이트의 크고 위쪽의 개체만 나열합니다.

그리고 여기 그 물건의 주소가 있습니다.

나는 더 심층적인 분석을 위해 다음 단계에서 그것을 사용할 것이다.

그래서 그것은 인스턴스에 대한 객체 식별이 개선된 힙 도구이다.

지금까지, 당신은 게임에서 어떤 물체가 메모리를 사용하고 있는지 이해하는 세 가지 도구를 보았고, 모두 다른 견해를 제공합니다.

내가 보여준 것은 단지 하나의 작업 흐름이었다.

특정 메모리 패턴이나 게임에 사용되는 기술에 따라, 필요에 맞는 방식으로 사용할 수 있습니다.

우리가 그들의 존재에 대해 확신할 수 없는 물체에 대한 발견으로, 다음 단계는 할당 호출 스택인 그 기원을 얻는 것이다.

현대 렌더링에서 2억 바이트 객체의 경우, 나는 —callTree 모드를 사용하고 그 주소를 malloc_history에 전달한다.

추가적인 반전 인수와 함께, 나는 할당에 가장 가까운 기능에 집중할 수 있다.

그리고 짜잔.

여기 할당의 뒷 흔적이 있습니다.

마찬가지로, Xcode 메모리 디버거는 인스펙터에서도 객체의 할당 기록을 보여줍니다.

개체를 선택하고, 메모리 인스펙터를 클릭하면, 거기에 있습니다.

또 다른 예로, 사용자 지정 할당자 디버깅과 같은 게임이나 플러그인에서 익명의 VM 사용을 확인하기 위해 주소 대신 VM_ALLOCATE를 클래스 패턴으로 전달하십시오.

Xcode를 사용하든 malloc_history를 사용하든, 할당 추적을 알 수 있으며, 시작하기 위해 줄에 중단점을 설정하는 것을 포함하여 더 깊이 파고들고 싶은지 결정할 수 있습니다.

그리고 마지막으로, 객체 참조를 조사하는 것도 도움이 된다.

메모리 그래프는 여러 가지 이유로 MallocStackLogging이 활성화되지 않은 경우에도 항상 객체 참조를 기록합니다.

우리는 전에 Xcode 외부의 메모리 그래프를 캡처하기 위해 누수를 사용한 적이 있다.

누출은 더 많은 것을 한다.

그것은 메모리 그래프의 모든 참조를 확인하며, 그것이 누출에 대해 알고 주기를 유지하는 이유이다.

Leaks는 추적 트리 인수와 힙의 객체 주소를 사용하여 객체에 대한 참조 트리를 가져옵니다.

그러나, 이것은 이 예에서 다소 큰 나무이기 때문에, 터미널에서 보는 것보다 다소 더 나은 방법이 있다.

Xcode 14를 사용하여, 우리는 선택한 개체의 나가는 가장자리와 나가는 가장자리를 모두 보여주기 위해 메모리 그래프 보기를 재설계했습니다.

심지어 Xcode가 그릴 가장자리를 선택할 수 있는 새로운 이웃 선택 팝오버가 있습니다.

이것은 복잡한 게임 상태에서 객체 참조를 이해하려고 할 때 생산성을 크게 향상시킬 것이다.

잠시 둘러본 후, 나는 텍스처 관리자가 이 물체에 접근하고 있다고 확신한다.

게임의 경우, 누수 도구와 메모리 그래프 보기를 사용하여 중요한 객체 참조 관계를 찾고 게임에서 이러한 객체에 어떻게 접근하는지 알아보십시오.

그래서 누출이나 Xcode를 사용하여 객체의 중요한 참조를 보고 찾는 방법.

이러한 도구의 더 많은 사용을 위해 누출의 매뉴얼 페이지와 Xcode 도움말을 확인하세요.

이 메모리 그래프 분석 요리책에서, 각 단계는 몇 가지 특정 도구를 사용한다.

그들 모두는 메모리 그래프에 대한 분석을 완료하기 위해 함께 일한다.

요약하자면, 첫 번째는 메모리 그래프로 메모리를 캡처하고 분석할 때 MallocStackLogging을 활성화하는 것입니다.

그런 다음 게임을 위해 Xcode로 메모리 그래프를 캡처하거나, Mac 게임을 위해 누출 도구를 사용하세요.

다음으로, 크고 성가신 물건을 찾으세요.

풋프린트, vmmap 및 힙 도구는 높은 수준과 세부 사항 모두에서 메모리 고장을 제공합니다.

Malloc_history를 사용하면 객체가 할당된 위치를 찾을 수 있으며 누출은 객체 사용이나 참조를 분석할 수 있습니다.

이러한 이전 세션에는 심층적인 연습과 이러한 도구의 더 많은 사용에 대한 데모가 포함됩니다.

지금까지, 우리는 금속 자원에 대한 탐색을 연기했다.

음, 지금이 시간이야.

더 말씀드리자면, 여기 세스가 있습니다.

또 안녕!

게임에서, 금속 자원은 많은 양의 메모리를 사용할 수 있다.

하지만 그들의 메모리 사용을 최적화하는 방법이 있다.

여기서 저는 게임에서 금속 자원을 최적화할 때 사용할 수 있는 메모리 절약 목록을 요약했습니다.

우리는 메탈 디버거가 리소스를 감사하고 게임 메모리를 더욱 줄이기 위한 몇 가지 고급 기술을 배우는 데 어떻게 도움이 될 수 있는지 살펴볼 것입니다.

메탈 디버거는 메탈 게임을 디버깅하기 위한 원스톱 상점입니다.

GPU 프레임 캡처 후, 요약 페이지를 찾을 수 있습니다.

이것은 캡처된 작업량에 대한 몇 가지 일반적인 통계를 제공합니다.

페이지의 아래쪽 절반에는 네 가지 범주로 나누어진 통찰력 목록이 있다.

"메모리" 카테고리의 통찰력은 게임을 위한 메모리 절약을 제안합니다.

이 추적에 대한 메모리 통찰력은 많지 않다; 우리는 이러한 통찰력을 해결한 후 몇 메가바이트의 메모리만 저장할 수 있다.

그러나, 당신의 게임과 관련된 더 많은 메모리 절약이 있을 수 있습니다.

금속 자원이 사용하는 메모리에 대한 더 완전한 그림을 얻으려면, 메모리 보기 버튼을 클릭하여 메모리 뷰어를 사용할 수 있습니다.

메모리 뷰어는 게임에서 캡처한 리소스의 전체 목록을 제공합니다.

위쪽 절반은 필터링을 위한 다른 범주를 보여준다.

당신은 이것을 빠르게 사용하여 자원, 예를 들어 텍스처를 찾을 수 있습니다.

그리고 아래쪽 절반에서, 테이블은 질감만 보여준다.

일단 필터를 꺼내자.

리소스 테이블에는 게임을 최적화하는 데 도움이 되는 열 모음이 있습니다.

그리고 흥미로운 자원을 빠르게 식별하는 데 도움이 될 수 있는 몇 가지 칼럼을 강조하고 싶습니다.

인사이트 칼럼은 우리가 방금 요약 페이지에서 본 것과 비슷하다.

이 열로 테이블을 정렬할 때 통찰력이 있는 모든 리소스를 빠르게 볼 수 있습니다.

그리고 통찰력 아이콘을 클릭하면 발견을 설명하고 몇 가지 가능한 행동을 제공하는 팝오버가 표시됩니다.

이 열 바로 옆에 할당된 크기가 있습니다.

가장 큰 자원을 보려면 이 열로 정렬할 수 있습니다.

일부 자원이 실제로 메모리 크기를 잘 활용한다면 감사하는 것이 유용할 수 있다.

예를 들어, 일부 텍스처는 더 작은 해상도로 크기가 조정될 수 있으며 버퍼에 로드된 일부 모델은 게임의 시각적 품질에 영향을 미치지 않는다는 점을 감안할 때 더 낮은 폴리 카운트를 사용할 수 있습니다.

잠시 후에 언급할 텍스처 메모리를 저장하는 몇 가지 다른 방법이 있습니다.

여기서 또 다른 흥미로운 칼럼은 마지막 바운드 이후의 시간이다.

이 열로 리소스를 정렬하여 최근에 사용되지 않은 리소스를 찾을 수 있습니다.

자원이 사용되지 않는다면, 자산을 적재할 가치가 있는지 다시 확인하는 것이 좋은 생각일 수 있다.

한동안 구속되지 않은 자원의 경우, 미래에 다시 사용되지 않을 경우 출시를 고려할 수 있습니다.

또는, 제거 가능한 상태를 휘발성으로 설정할 수 있습니다.

금속 자원은 세 가지 제거 가능한 상태 중 하나에 있을 수 있다: 비휘발성, 휘발성, 그리고 비어 있다.

기본적으로, 자원은 비휘발성이다.

제거 가능한 상태를 휘발성으로 설정함으로써, 금속은 시스템의 메모리 압력이 높을 경우 메모리에서 자원을 제거할 수 있다.

자원이 비면, 시스템은 더 이상 게임의 발자국을 향해 충전하지 않을 것이다.

게임에 리소스가 다시 필요할 때, 콘텐츠가 여전히 있는지 확인하고, 필요한 경우 다시 로드하세요.

자주 사용되지 않는 자원에 대해서만 휘발성을 사용하는 것을 고려하면, 제거 가능한 상태가 당신에게 불리하게 작용하지 않습니다.

그래서 그것들은 모든 자원에 대한 일반적인 메모 중 일부이다.

그리고 이제, 질감을 좀 더 자세히 살펴봅시다.

모든 열이 메모리 뷰어에 기본적으로 표시되는 것은 아닙니다.

테이블 헤더를 마우스 오른쪽 버튼으로 클릭하면 텍스처의 픽셀 형식과 같은 열을 표시하고 숨길 수 있습니다.

텍스처를 위해 픽셀 형식을 최적화하면 다른 금액을 절약할 수 있습니다.

게임의 많은 텍스처는 메모리 사용과 대역폭을 줄이기 위해 16비트 반정밀 픽셀 형식을 사용할 수 있다.

단일 알파 구성 요소가 있는 텍스처가 필요한 경우, 여러 색상 채널을 피할 수 있습니다.

그리고 마지막으로, 일부 읽기 전용 텍스처는 낮은 메모리 사용을 위한 블록 압축의 혜택을 받을 수 있다.

블록 압축 픽셀 형식의 경우, ASTC와 BC와 같은 옵션이 있습니다.

또한, A15 바이오닉 이후, 가능한 한 품질을 유지하면서 메모리를 절약하기 위해 텍스처와 렌더링 대상에 손실 압축을 사용할 수 있습니다.

자세한 내용은 이 이전 비디오를 확인하세요.

그리고 그것들은 메모리 뷰어를 사용하여 빠르게 발견할 수 있는 메모리 절약의 일부입니다.

하지만 게임을 더욱 최적화하기 위해 취할 수 있는 몇 가지 추가 기술이 있습니다.

텍스처가 단일 패스로만 사용되는 경우, 메모리와 대역폭을 절약하기 위해 저장 모드를 메모리리스로 설정할 수 있습니다.

메모리리스 텍스처는 깊이, 스텐실 또는 다중 샘플링 텍스처와 같은 임시 렌더링 대상에 잘 작동합니다.

그렇지 않으면, 텍스처가 GPU에서만 사용되는 경우, 저장 모드를 비공개로 설정하거나 공유하거나 관리할 수 있습니다.

이미 잘 알고 계시겠지만, iPhone과 iPad와 마찬가지로 Apple Silicon Mac에서는 관리 모드가 필요하지 않습니다.

여기 예시 사례가 있습니다.

그 게임은 Depth32Float_Stencil8 텍스처를 가지고 있다

깊이 텍스처는 패스에 걸쳐 사용되지만, 스텐실 텍스처의 내용은 폐기되고 나중에 프레임에서 사용되지 않습니다.

그래서 대신, 게임은 메모리와 대역폭을 절약하기 위해 두 개의 텍스처를 사용하고 스텐실 텍스처를 메모리 없이 만들 수 있다.

마지막으로, 저는 당신의 게임에서 기억을 최대한 활용하기 위해 당신에게 흥미로울 수 있는 또 다른 기술을 언급하고 싶습니다.

게임이 동시에 사용하지 않는 경우 힙에서 별칭 리소스를 사용할 수 있습니다.

그들은 동일한 할당으로 뒷받침되는 메모리를 공유할 수 있다.

하지만 그 자원에 대한 접근을 동기화할 때 각별히 주의하세요.

"Go bindless with Metal 3" 토크를 확인하여 힙에서 할당된 리소스 사용에 대해 자세히 알아볼 수 있습니다.

그래서 그것은 우리의 메모리 절약 체크리스트를 마무리한다.

그리고 이 체크리스트가 게임에서 금속 자원을 감사하는 데 도움이 되기를 바랍니다.

게임 메모리를 최적화하기 위해 메탈 디버거를 사용하는 것에 대해 자세히 알아보려면, 다른 WWDC 회담을 확인하세요.

그리고 너에게 돌아가, 잭.

고마워, 세스.

오늘, 우리는 가이드 투어를 했고 게임의 메모리 사용을 이해하고 개선하기 위해 할 수 있는 많은 흥미로운 것들을 탐구했습니다.

첫째, 메모리 풋프린트는 게임의 메모리 사용량을 이해하는 주요 지표이며, 더러움과 압축 및 교환된 메모리를 포함합니다.

그런 다음, 우리는 강력한 메모리 디버깅 도구를 경험했다.

세스는 악기가 유용한 원격 측정 트랙으로 어떻게 메모리 프로파일링을 강화하는지 보여주었다.

새로운 게임 메모리 템플릿은 이 작업에 정확히 맞춰져 있다.

그 후, 나는 게임 메모리 상태의 스냅샷을 저장하기 위해 메모리 그래프를 제시했다.

객체, 참조 및 할당 기록에 대한 메모리 그래프를 분석하는 유연하고 강력한 명령줄 프로그램이 있습니다.

힙 도구의 개선과 재설계된 Xcode 메모리 디버거는 게임 메모리 분석을 강화할 것이다.

마지막으로, 세스는 금속 자원에 대한 메모리 절약 체크리스트와 금속 디버거가 게임에서 금속 자원 사용에 대한 질문에 답하는 데 어떻게 도움이 될 수 있는지 공유했습니다.

당신은 또한 다른 WWDC 세션, 문서 및 매뉴얼 페이지에서 더 많은 것을 배울 수 있습니다.

우리는 당신을 위해 최고의 가장 유연한 도구를 지속적으로 발전시키고 있습니다.

그래서 그것들을 시도해 보는 게 어때?

그것들은 그냥 네가 찾고 있는 것일 수도 있어.

그리고 피드백 어시스턴트와 같은 모든 채널을 통해 당신이 가질 수 있는 피드백을 우리와 공유하는 것을 주저하지 마세요.

기억의 여정을 즐겁게 보내, 그리고 봐줘서 고마워. ♪ ♪