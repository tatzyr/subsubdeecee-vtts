10119

안녕하세요, 저는 여기 애플 코어 데이터 팀의 엔지니어인 닉 길렛입니다.

이 세션에서는 개발자 도구를 사용하여 NSPersistentCloudKitContainer를 사용하는 애플리케이션에 대해 자세히 알아보는 방법을 보여드리겠습니다.

우리는 생산적이고 교육적인 방식으로 응용 프로그램을 탐색하는 방법에 대한 자세한 살펴보는 것으로 시작할 것입니다.

그런 다음, 우리는 응용 프로그램이 어떻게 작동하는지 분석하기 위해 내가 가장 좋아하는 도구 중 일부를 사용할 것이다.

그리고 마지막으로, NSPersistentCloudKitContainer에 대한 경험에 대한 상세하고 실행 가능한 피드백을 제공할 수 있는 방법을 살펴보겠습니다.

나는 물 순환과 같은 공학을 생각하는 것을 좋아한다.

일반적으로, 나는 기능이 존재하는 공간을 탐험함으로써 기능에 대한 작업을 시작한다.

그런 다음, 내가 배운 것을 바탕으로, 나는 재현 가능한 환경에서 내 작업을 분석하기 위해 도구와 테스트의 조합을 사용한다.

마지막으로, 나는 동료들과 동료들과 결과를 검토하고 그들의 피드백을 수집한다.

이 주기의 목표는 내가 일하면서 배운 것들을 지속적으로 포착하는 것이다.

Apple 플랫폼에는 내가 배운 것을 캡처하는 데 사용하는 Xcode, Instruments 및 XCTest와 같은 다양한 도구가 포함되어 있습니다.

이러한 도구는 또한 실행 가능한 피드백을 제공하는 데 사용할 수 있는 풍부한 진단 정보를 수집할 수 있게 해준다.

이 세션은 지난 몇 년 동안의 많은 지식을 참조한다.

저는 NSPersistentCloudKitContainer와 Core Data CloudKit 샘플 애플리케이션에 대해 논의했습니다. 오늘 "CloudKit 및 Core Data를 통해 데이터를 공유하는 앱 빌드" 세션과 "CloudKit과 함께 핵심 데이터 사용" 세션에서 자세히 보여드리겠습니다.

또한 Xcode와 Instruments를 사용하여 테스트를 실행하는 방법과 장치 주최자를 사용하여 장치에서 데이터를 캡처하는 방법을 시연할 것입니다.

필요한 경우, "도구 시작하기" 및 "Xcode Organizer로 성능 문제 진단" 세션을 검토하여 툴체인의 두 가지 중요한 부분에 대해 자세히 알아보는 것이 좋습니다.

좋아, 사이클의 첫 번째 부분인 탐험을 시작하자.

나에게 탐험의 주요 목표는 배우는 것이다.

나는 지원서가 어떻게 작동할지에 대한 모든 가정에 도전하고 확인하고 싶다.

물어볼 수도 있습니다: 이 버튼을 누르면 어떻게 되나요?

데이터를 영구 저장소에 저장할 때 NSPersistentCloudKitContainer가 동기화되나요?

대용량 데이터 세트로 작업할 때 애플리케이션에 메모리가 부족합니까?

코어 데이터의 관점에서 볼 때, 이 모든 질문은 애플리케이션이 작동하는 데이터의 영향을 받는다.

예를 들어, Core Data CloudKit 샘플 애플리케이션은 이 데이터 모델을 사용합니다.

제목과 콘텐츠에 대한 텍스트 필드가 있는 일련의 게시물을 관리합니다.

게시물은 첨부 파일, 일반적으로 이미지와 관련이 있을 수 있으며, 이는 꽤 클 수 있다.

따라서 ImageData는 주문형으로 로드할 수 있도록 일대일 관계에 걸쳐 저장됩니다.

그리고 저는 그 데이터 세트, 특히 그 데이터의 모양, 구조 및 분산을 변경할 때 샘플 애플리케이션에 어떤 일이 일어나는지에 대한 탐구에 집중할 것입니다.

출시 이후, 샘플 애플리케이션에는 그것을 탐색할 수 있는 내장 방법이 포함되어 있다.

1000개의 게시물 생성 버튼은 라벨에 적힌 것과 정확히 일치한다.

탭하면, 짧은 제목을 가진 1,000개의 게시물의 샘플 데이터 세트를 생성합니다.

포스트 테이블 뷰는 이 수준의 데이터를 쉽게 처리합니다.

그래서 제가 묻고 싶은 다음 질문은, 이 응용 프로그램에서 다른 모양이나 크기의 데이터 세트를 어떻게 탐색할 수 있을까요?

1000개의 게시물 생성 버튼은 내가 알고리즘 데이터 생성기라고 부르는 것을 실행한다.

알고리즘 데이터 생성기는 "1000개의 객체 삽입" 또는 "모든 필드에 값이 있는지 또는 필드에 값이 없는지 확인"과 같은 미리 정해진 규칙을 따릅니다.

알고 보니, 우리는 또한 데이터 생성기이다.

우리는 코드, SQL 또는 응용 프로그램과 직접 상호 작용하여 특정 데이터 세트를 수작업으로 만들 수 있으며, 이러한 생성된 데이터 세트는 나중에 사용하거나 분석할 수 있도록 보존할 수 있습니다.

더 큰 데이터 세트를 탐색하기 위해, 나는 새로운 데이터 생성기인 LargeDataGenerator를 정의하고, 새로운 데이터 세트를 구축하기 위해 단일 방법인 generateData를 제공할 수 있다.

루프를 위한 단 두 개로, 나는 각각 11개의 이미지 첨부 파일이 있는 60개의 게시물 세트를 생성할 수 있다.

그것은 총 660개의 이미지이다.

이미지당 10-20메가바이트의 평균 크기로, 생성된 데이터 세트는 거의 10GB의 데이터를 소비한다.

이러한 간단한 인터페이스로, 데이터 생성기는 이와 같은 테스트에서 쉽게 호출됩니다.

이 한 줄의 코드는 이 테스트가 사용할 수 있는 10GB 이상의 대표 데이터를 생성합니다.

또한, 우리는 각 게시물이 실제로 11개의 이미지 첨부 파일을 얻는다고 주장하는 것과 같이 데이터 생성기가 올바르게 작동하는지 확인하는 테스트에서 유효성 검사 방법을 구축할 수 있습니다.

물론, 우리가 이 데이터를 동기화하지 않았다면 이것은 NSPersistentCloudKitContainer에 대한 이야기가 아닐 것이다.

그래서 그것을 하기 위한 새로운 테스트를 만들자.

내가 가장 먼저 필요한 것은 사용할 NSPersistentCloudKitContainer의 인스턴스이다.

나는 그것을 쉽게 만들기 위해 도우미 방법을 만들었다.

다음으로, 저는 LargeDataGenerator를 사용하여 원하는 데이터 세트로 컨테이너를 채웁니다.

그리고 마지막으로, 나는 컨테이너가 데이터 내보내기를 마칠 때까지 기다린다.

이 특정 테스트에서, 나는 큰 데이터 세트를 업로드할 시간을 주기 위해 최대 20분을 기다린다.

여러분 중 독수리는 이 테스트가 다양한 유형의 이벤트를 많이 기다리는 것처럼 보인다는 것을 알아차렸을 것입니다.

여기서, 내가 컨테이너를 만들 때, 나는 컨테이너가 설정을 마칠 때까지 기다린다.

그리고 여기서, 저는 컨테이너에서 내보내기 이벤트에 대한 XCTestExpectations를 만들기 위해 작성한 도우미 방법을 사용합니다.

그것을 자세히 살펴봅시다.

이 방법은 원하는 이벤트 유형과 NSPersistentCloudKitContainer의 인스턴스를 인수로 사용합니다.

NSPersistentCloudKitContainer의 eventChanged 알림을 관찰하기 위해 XCTestCase의 expectationForNotification 방법을 사용하여 컨테이너의 각 영구 저장소에 대한 하나의 기대치를 만듭니다.

알림 핸들러 블록에서, 들어오는 이벤트가 이 기대에 대한 특정 저장소에 대한 올바른 유형이며, endDate가 nil과 같지 않은지 확인하여 완료되었음을 확인합니다.

이 기술을 사용함으로써, 우리는 테스트의 제어 지점을 NSPersistentCloudKitContainer의 이벤트와 강력하게 연관시킬 수 있습니다.

테스트로 돌아가서, 방금 내보낸 데이터를 가져오기 위해 새 컨테이너를 추가합니다.

이 기술은 트릭을 사용한다.

빈 저장소 파일로 NSPersistentCloudKitContainer의 새로운 인스턴스를 만듭니다.

이를 통해 테스트는 NSPersistentCloudKitContainer의 최초 가져오기를 활용하여 이 모든 데이터가 장치에서 다운로드될 때 어떤 일이 일어나는지 탐색할 수 있습니다.

이제, 테스트는 훌륭하지만, 때때로 나는 데이터 세트가 애플리케이션에서 어떻게 작동하는지 느끼고 싶다.

그렇게 하기 위해, 나는 우리가 샘플 응용 프로그램에서 했던 것처럼 데이터 생성기를 사용자 인터페이스에 바인딩할 수 있다.

대용량 데이터 생성 버튼을 탭하면 데이터 생성기가 데이터 세트를 채우는 것을 볼 수 있습니다.

두 번째 장치에서 NSPersistentCloudKitContainer가 생성된 데이터를 다운로드하는 것을 진행함에 따라 테이블 뷰가 채워지는 것을 볼 수 있습니다.

개별 게시물을 탭하면 이 응용 프로그램의 사용자와 마찬가지로 첨부 파일을 다운로드하고 점진적으로 채울 수 있습니다.

이 특정 사용자 인터페이스는 경고 컨트롤러에 의해 구동됩니다.

LargeDataGenerator의 간단한 인터페이스를 사용하면 이 두 줄의 코드만으로 새로운 경고 동작을 쉽게 추가할 수 있습니다.

그것은 명확하고, 간결하며, 쉽게 이해된다.

이 섹션에서, 우리는 데이터 생성기의 개념을 사용하여 애플리케이션의 동작을 탐구했습니다.

데이터 생성기는 테스트나 사용자 지정 UI, 또는 명령줄 인수와 같은 것, 또는 특정 사용 사례에서 작동하는 다른 어떤 것이든 우리가 선택한 방식으로 응용 프로그램에서 구동될 수 있습니다.

이제 애플리케이션에 데이터를 채우는 방법을 알았으므로, 애플리케이션 동작을 어떻게 바꾸는지 분석할 준비가 되었습니다.

이 섹션에서는 애플리케이션이 큰 데이터 세트로 어떻게 작동하는지 분석하기 위한 몇 가지 도구와 기술에 대해 배울 것입니다.

특히, 우리는 Instruments를 사용하여 LargeDataGenerator가 만든 데이터 세트의 시간과 메모리 복잡성을 분석할 것입니다.

그런 다음, 우리는 시스템 로그에서 사용할 수 있는 풍부한 정보를 살펴볼 것입니다.

그곳에서 우리는 NSPersistentCloudKitContainer, CloudKit, 시스템 스케줄러 및 푸시 알림에서 활동 기록을 찾을 수 있습니다.

악기를 쳐다보자.

내가 테스트를 좋아하는 이유 중 하나는 Xcode가 테스트의 동작을 쉽게 분석할 수 있기 때문이다.

테스트 케이스에서, 시궁창에서 테스트 공개를 마우스 오른쪽 버튼으로 클릭하고 프로필을 선택할 수 있습니다.

Xcode는 테스트를 빌드한 다음 자동으로 도구를 실행합니다.

Time Profiler 도구를 두 번 클릭하여 내 시험이 어디에서 일을 하는 데 시간을 보내는지 검사할 수 있습니다.

기록 버튼을 클릭하면, Instruments는 응용 프로그램을 실행하고 선택한 테스트를 실행할 것입니다.

이 테스트는 실행하는 데 꽤 시간이 걸리는 것으로 보인다.

건너뛰고 이유를 봅시다.

악기는 이미 메인 스레드를 선택했고, 오른쪽에서 테스트 실행의 가장 무거운 스택 흔적을 볼 수 있다.

그걸 좀 더 읽기 쉽게 만들자.

우리가 간다.

이제, 하단으로 스크롤하면, LargeDataGenerator가 썸네일을 생성하는 데 많은 시간을 소비하고 있다는 것을 알 수 있습니다.

이것이 버그인지 기능인지 어떻게 결정할 수 있을까요?

LargeDataGenerator에는 각 첨부 파일에 대한 새 썸네일을 생성하는 이 코드 줄이 있습니다.

하지만, 나는 애플리케이션의 데이터 모델에서 썸네일이 특별하다는 것을 알고 있다.

그것들은 관련 이미지 데이터에서 필요에 따라 계산됩니다.

그것은 이 라인이 불필요하다는 것을 의미하며, 내 데이터 생성기는 그들에게 많은 시간을 낭비하고 있다.

그래서 난 그냥 그걸 제거할 수 있어.

그것이 시험의 성과를 어떻게 바꾸는지 봅시다.

업데이트된 데이터 생성기로 앱을 재구성한 후, 인스트루먼트에서 테스트를 다시 실행할 수 있습니다.

그리고 솔직히 나는 많은 변화가 보이지 않지만, 몇 초 후에 시험이 끝난다.

그것은 이전 실행보다 훨씬 빠르다.

시험이 대부분의 시간을 어디에 보냈는지 봅시다.

오른쪽 서랍에서, 나는 이제 가장 무거운 스택 추적이 영구 저장소에 이미지를 저장하고 있다는 것을 알게 되며, 그것이 바로 내가 이 많은 데이터를 관리하는 테스트에서 기대하는 것이다.

그 한 가지 변화는 generateData 테스트의 런타임을 이것에서 이것으로 줄였다.

그것은 십분의 일 안에 실행된다.

이러한 방식으로 테스트를 분석하는 것이 항상 버그를 발견하는 것은 아닙니다. 때때로 우리는 특정 데이터 세트로 작업할 때 애플리케이션이 어디에 시간을 보내는지에 대해 더 많이 배웁니다.

하지만 어느 쪽이든, 그것은 가치 있는 배움이다.

그래서 그것이 Time Profiler 도구가 애플리케이션이 데이터 세트로 시간을 보내는 곳을 탐색하는 데 도움이 될 수 있는 방법입니다.

이제, 이 데이터 세트의 크기 때문에, 나는 또한 테스트가 얼마나 많은 메모리를 사용하는지 궁금하다.

그러니 할당 도구를 사용하여 실행해 봅시다.

나는 내 테스트를 프로파일링하기 위해 Instruments를 실행하기 위해 Xcode를 사용할 것이다.

시간 프로파일러 도구를 선택하는 대신, 할당을 두 번 클릭하겠습니다...

그리고 나서 기록을 클릭하세요.

이 테스트는 빠르게 실행되고 있지만, 사실 10GB가 넘는 많은 메모리를 사용하고 있다.

이것은 테스트 실행 중에 거의 모든 데이터 세트가 메모리에 보관되고 있다는 것을 말해준다.

왜 그런지 알아보자.

나는 살펴볼 다양한 할당을 선택할 수 있다.

하단 창에서, 나는 많은 큰 할당이 있다는 것을 알 수 있다.

나는 이 공개를 클릭하여 그것들을 파헤칠 수 있고, 테스트를 위해 할당된 큰 데이터 덩어리 중 하나를 클릭할 수 있다.

이 특정 덩어리는 할당되었지만 거의 2초 동안 해제되지 않았다.

그것은 시험 시간의 영원이다. 왜 그렇게 오래 살았어?

나는 오른쪽에 있는 스택 추적을 확장함으로써 그것을 탐구할 수 있다.

경험상, 할당 및 할당 해제 스택 추적은 이 객체가 CoreData에 의해 잘못되었고 관리되는 객체 컨텍스트가 작업을 마쳤을 때 해제되었다는 것을 알려줍니다.

그것은 보통 객체가 가져오기, 자동 해제 풀 또는 테스트의 객체에 의해 유지되었다는 표시이다.

코드의 문제가 있는 부분은 여기 내 검증자에 있다.

첨부 파일에서 이미지를 로드하고 확인합니다.

그러나, 이것은 관리되는 객체 컨텍스트에 등록된 첨부 파일과 관련 이미지 데이터를 유지합니다.

우리가 이것을 해결하기 위해 노력할 수 있는 방법은 여러 가지가 있다.

예를 들어, 테이블 보기에서, 테이블이 게시물을 스크롤할 때 이미지를 해제하기 위해 일괄 가져오기를 사용할 수 있습니다.

그러나, 이 테스트는 효과가 있기에는 너무 빨리 실행되고 있다.

나는 내 접근 방식을 바꿔야 해.

게시물을 가져와서 확인하는 대신, 대신 첨부 파일을 가져올 수 있습니다.

객체 ID만 가져오면, 관리되는 객체 컨텍스트는 내가 요청할 때까지 로드된 객체를 캡처하지 않을 것이다.

NSManagedObjectContext의 objectWithID 메소드를 사용하여 유효성 검사를 위해 첨부 파일을 가져올 수 있습니다.

마지막으로, 내가 검증하는 10개의 첨부 파일에 대해 컨텍스트를 재설정하여 모든 캐시된 상태와 관련 메모리를 해제합니다.

이 변경 사항으로 테스트를 다시 실행하면 훨씬 더 예측 가능하고 조정 가능한 수준의 메모리 소비가 발생한다는 것을 알 수 있습니다.

사실, 검증자는 LargeDataGenerator가 이러한 객체를 삽입할 때보다 훨씬 적은 메모리를 사용한다.

수정이 어떻게 작동하는지 알아보기 위해 특정 할당을 자세히 살펴봅시다.

먼저, 나는 함께 일할 다양한 할당을 선택할 것이다.

그런 다음, 검사할 특정 크기를 선택하고, 이 시간 동안 해방된 물체를 찾기 위해 파괴된 물체를 활성화해야 하며, 그런 다음 검사할 특정 할당을 선택할 수 있습니다.

오른쪽에서, 인스트루먼트는 나에게 할당 스택 추적을 보여주지만, 나는 그것이 어디에서 해제됐는지 알고 싶기 때문에, 할당 해제 이벤트를 선택할 것이다.

나는 이 스택 추적이 NSManagedObjectContext가 이 BLOB을 유지한 객체를 비동기적으로 할당 해제하여 소비된 메모리를 확보한다는 것을 의미한다는 것을 알고 있다.

이 기술을 통해 테스트를 위한 높은 워터 마크를 설정할 수 있으며, 메모리가 적은 시스템에서 실행할 수 있습니다.

테스트를 Instruments와 결합함으로써, 나는 이 특정 테스트가 바람직하지 않은 행동을 했다는 것을 발견할 수 있었다.

나는 그 행동을 직접 해결하고 결과를 확인하기 위해 목표 변경을 했다.

또한, 시스템 로그에는 CloudKit, 스케줄링 및 푸시 알림과 같이 애플리케이션과 그에 의존하는 시스템 서비스에 대한 풍부한 정보가 포함되어 있습니다.

나는 내 맥북 프로와 아이폰 사이에 하나의 게시물을 동기화할 것이다.

Mac에 새 게시물을 삽입하고, 짧은 제목을 지정하고, iCloud에 업로드할 때, 시스템 로그는 많은 이벤트를 캡처합니다.

내 iPhone과 동기화될 때, 때로는 중간 상태를 캡처할 때도, 시스템 로그는 해당 이벤트 세트를 캡처합니다.

맥북 프로에서 NSPersistentCloudKitContainer는 애플리케이션 프로세스 내부에서 작동하며, 이 경우 CoreDataCloudKitDemo입니다.

데이터가 영구 저장소에 기록될 때, DASD라는 시스템 서비스에 지금이 그 데이터를 CloudKit으로 내보내기에 좋은 시기인지 묻습니다.

만약 그렇다면, DASD는 NSPersistentCloudKitContainer에게 활동을 실행하라고 말할 것이다.

그런 다음 NSPersistentCloudKitContainer는 변경된 개체를 CloudKit으로 내보내기 위해 cloudd라는 프로세스로 작업을 예약합니다.

우리는 콘솔 앱을 사용하여 이러한 각 프로세스의 로그를 관찰할 수 있습니다.

애플리케이션 로그의 경우, 우리는 단순히 애플리케이션 프로세스인 CoreDataCloudKitDemo를 찾습니다.

여기서, 저는 수출 완료를 보여주는 것을 선택했습니다.

로그를 예약하기 위해, 우리는 프로세스 dasd와 애플리케이션의 특정 저장소에서 로그를 보고 싶습니다.

여기서, 저는 애플리케이션의 개인 상점에 대한 수출 활동의 시작을 선택했습니다.

이 로그를 좀 더 자세히 살펴봅시다.

NSPersistentCloudKitContainer가 dasd와 함께 만든 활동은 특정 형식을 따릅니다.

활동 식별자는 NSPersistentCloudKitContainer가 활동이 속한 상점의 상점 식별자와 함께 사용하는 특정 접두사로 구성됩니다.

Dasd 로그에는 서비스가 활동을 실행할 수 있는지 결정하는 방법에 대한 정보가 포함되어 있습니다.

애플리케이션의 작업 능력에 영향을 미치는 정책은 최종 결정과 함께 로그에 나열될 것이다.

마지막으로, 프로세스 클라우드는 CloudKit의 정보를 기록하며, 작업 중인 컨테이너 식별자로 이러한 로그를 필터링하는 것을 좋아합니다.

여기서 저는 앞서 언급한 수출에 대한 해당 수정 기록 작업을 선택했습니다.

변경 사항을 수신 장치에서 가져올 때, 관찰해야 할 한 가지 추가 프로세스가 있습니다.

프로세스 apsd는 푸시 알림을 받고 애플리케이션으로 전달할 책임이 있다.

그로 인해 NSPersistentCloudKitContainer는 수출 과정과 유사한 일련의 활동을 시작합니다.

Dasd에게 가져오기를 수행할 시간을 요청한 다음 cloudd와 함께 작동하여 CloudKit에서 업데이트된 모든 개체를 가져와 로컬 저장소로 가져옵니다.

Apsd는 애플리케이션에 대한 푸시 알림을 받을 때 로그를 기록하며, 이 로그는 많은 중요한 세부 사항을 캡처합니다.

로그 메시지에는 여기에 컨테이너 식별자와 푸시 알림을 트리거한 구독 이름 및 영역 식별자가 포함되어 있습니다.

이것들은 NSPersistentCloudKitContainer에 의해 관리되며 항상 접두사 com.apple.coredata.cloudkit으로 시작합니다.

이제 콘솔 앱은 훌륭하다.

하지만 Mac에서 개발할 때, 터미널의 로그 스트림 명령을 사용하여 앱과 함께 이러한 로그를 표시하는 것을 좋아합니다.

다음 각 술어에 대해 하나의 터미널 창이나 탭을 엽니다. 먼저 응용 프로그램입니다.

다음으로, CloudKit 서버에서 무슨 일이 일어나고 있는지 볼 수 있도록 cloudd의 로그입니다.

다음으로, 푸시 알림 로그를 위한 apsd.

그리고 마지막으로, NSPersistentCloudKitContainer가 나를 대신하여 예약하는 활동에서 무슨 일이 일어나고 있는지 볼 수 있도록.

이 술어는 또한 콘솔 앱에서 쿼리를 안내하는 데 사용될 수 있습니다.

우리가 사용하는 장치에는 우리가 사용할 수 있는 많은 정보가 있다.

도전은, 정말로, 그것을 찾고 분석하기 위해 어떤 도구를 사용해야 하는지 아는 것이다.

악기만으로, 우리는 런타임과 메모리 성능 등과 같은 다양한 주제에 대해 배울 수 있습니다.

시스템은 애플리케이션이 수행하는 작업과 시스템이 무대 뒤에서 무엇을 하고 있는지 설명하는 캡처 이벤트를 기록합니다.

내 개발 주기의 마지막 단계는 실행 가능한 피드백을 수집하고 제공하는 것이다.

이 섹션에서는 장치에서 진단 정보를 수집하는 방법을 보여드리겠습니다.

우리의 목표는 이 정보를 사용하여 실행 가능하고 특정 목표에 부합하는 피드백을 생성하는 것입니다.

이러한 기술은 당신이 소유한 장치이든 고객 장치이든 모든 장치에서 피드백을 수집하는 데 도움이 될 수 있습니다.

장치에서 진단 정보를 수집하는 데는 세 단계가 있습니다.

먼저, 문제를 식별하고 효과적으로 분류하는 데 사용할 수 있는 로그를 가능하게 하는 CloudKit 로깅 프로필을 설치해야 합니다.

다음으로, 우리는 영향을 받은 장치에서 sysdiagnose를 수집할 것입니다.

그리고 마지막으로, 장치에 물리적으로 접근할 수 있다면, Xcode에서 영구 저장소 파일을 수집할 수도 있습니다.

로깅 프로필을 설치하려면, 개발자 포털의 프로필 및 로그 페이지를 방문하기만 하면 됩니다.

CloudKit 프로필을 검색하고 프로필 링크를 탭하여 다운로드할 수 있습니다.

일부 장치에서는 프로필을 설치하라는 알림이 나타날 것이다.

그러나, 여기 iOS에서는 설정 앱을 통해 수동으로 설치해야 합니다.

설정에서, 프로필 다운로드 셀을 탭하기 위해 탐색할 수 있습니다.

그런 다음 다운로드한 프로필을 탭하여 설치할 수 있습니다.

설치를 완료하려면 단계를 따르세요.

프로필이 설치된 후, 장치를 재부팅할 수 있으며, 효력을 발휘할 것이다.

장치가 재부팅되면, 캡처하고 싶은 동작을 재현한 다음 sysdiagnose를 수행할 수 있습니다.

Sysdiagnose는 특별한 일련의 버튼인 키코드를 사용하여 수행됩니다.

이것들은 프로필에 대한 지침 페이지에 설명되어 있습니다.

나는 아이폰의 경우, 볼륨 버튼과 측면 버튼을 몇 초 동안 누른 다음 놓는다는 것을 알고 있다.

잠시 후, 설정에서 sysdiagnose를 사용할 수 있습니다.

그것을 찾기 위한 지침은 프로필에 대한 지침 파일에 포함되어 있습니다.

설정에서 개인 정보 보호 및 보안, 분석 및 개선으로 이동한 다음 분석 데이터를 선택하고 sysdiagnose를 찾을 때까지 로그를 스크롤합니다.

Sysdiagnose를 탭한 다음 공유 버튼을 탭하면 여러 가지 공유 방법을 선택할 수 있습니다.

예를 들어, 나는 분석을 위해 그것들을 내 Mac으로 에어드랍하는 것을 좋아한다.

마지막으로, 가능하다면, 장치 주최자를 사용하여 Xcode에서 저장 파일을 수집할 수 있습니다.

설치된 앱 목록에서 샘플 애플리케이션을 클릭하고, 공개 버튼을 클릭하고, 다운로드 컨테이너를 선택하고, 다운로드 디렉토리에 저장하여 이 iPhone에서 파일을 수집할 수 있습니다.

이 모든 것이 완료되면, 이제 시스템 로그와 저장소 파일을 모두 분석할 수 있습니다.

우리는 이미 로그 스트림 명령에 대해 이야기했지만, sysdiagnose를 사용하면 로그 쇼 명령을 사용하여 sysdiagnose에서 로그를 인쇄할 수 있습니다.

여기, 저는 우리가 앞서 이야기했던 apsd 로그의 술어입니다.

로그 쇼 명령의 마지막 인수는 사용할 로그 아카이브이다.

아무것도 지정되지 않으면, 실행 중인 기계의 시스템 로그가 표시됩니다.

여기서, sysdiagnose에서 가져온 로그를 읽을 수 있도록 system_logs.logarchive를 지정했습니다.

예를 들어, 내가 관심 있는 이벤트가 발생한 시간에 초점을 맞추기 위해 정확한 시간 범위를 지정할 수 있습니다.

나는 또한 우리가 이전에 논의한 많은 조건자를 결합하여 애플리케이션과 관련된 모든 활동의 통합 로그를 형성할 수 있습니다. 여기의 애플리케이션 로그, 여기의 클라우드 로그, 여기의 apsd 로그, 그리고 마지막으로 여기의 dasd 로그로 시작합니다.

이 강력한 명령은 피드백 보고서에 포함되거나 팀원들과 공유되어 모든 사람이 분석을 위한 특정 로그 세트에 집중할 수 있습니다.

이 세션에서, 우리는 데이터 생성기로 애플리케이션 동작을 탐구하고, 도구와 시스템 로그로 애플리케이션을 분석하고, NSPersistentCloudKitContainer를 사용하는 애플리케이션에서 실행 가능한 피드백을 제공하거나 수집하는 방법에 대해 이야기했습니다.

저는 닉 길렛이고, 이 프레젠테이션을 가져다드리게 되어 기쁩니다.

시청해 주셔서 감사합니다, 활동적으로 지내세요, 반지를 닫으세요, 그리고 멋진 WWDC를 보내세요.

.