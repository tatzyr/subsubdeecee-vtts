10068

♪ 기악 힙합 음악 ♪

- iOS 16의 "UIKit의 새로운 기능"에 오신 것을 환영합니다.

저는 디마이고, UIKit 팀의 엔지니어링 매니저입니다.

UIKit은 앱의 핵심에 있는 강력한 프레임워크입니다.

iOS 16의 새로운 기능을 지원하도록 업데이트되었습니다.

이 비디오에서는 생산성, 제어 향상, API 개선을 위한 UI 개선을 다룰 것이며, UIKit과 SwiftUI를 함께 사용하는 흥미로운 새로운 방법에 대해 이야기할 것입니다.

우리는 UIKit에서 새로운 제목 메뉴를 특징으로 하는 개선된 탐색 막대를 통해 간소화되고 발견 가능한 사용자 인터페이스를 개발하고, 잘라내기, 복사 및 붙여넣기를 위한 편집 상호 작용을 다시 상상했습니다.

문서 기반 애플리케이션을 향상시킬 수 있습니다.

데스크톱 클래스 도구 모음 기능을 지원하도록 업데이트된 내비게이션 바를 자세히 살펴보는 것으로 시작하겠습니다.

iOS 16에서 UIKit은 문서 기반 앱의 요구를 더 잘 지원하기 위해 두 가지 새로운 탐색 스타일을 소개합니다: 브라우저와 편집기.

브라우저 스타일은 웹 및 문서 브라우저와 같은 탐색을 위해 기록이나 폴더 구조를 사용하는 앱을 위해 설계되었습니다.

편집기는 문서 편집을 중심으로 한 인터페이스를 위한 것이다.

iOS 16에서는 다양한 바 버튼 항목을 앱에 추가할 수 있으며, 그 중 하위 집합은 탐색 모음 중앙에 표시됩니다.

메뉴에서 "구제어 도구 모음 사용자 지정" 항목을 탭하면 항목 팝업으로 드래그하여 항목을 재정렬할 수 있습니다.

그 결과 새로운 구성은 앱 실행 전반에 걸쳐 지속된다.

크기 변경을 수용하기 위해, 예를 들어, 다른 앱과 나란히 모드로 들어갈 때, 시스템은 맞지 않는 항목에 액세스할 수 있는 오버플로 메뉴를 자동으로 제공합니다.

우리는 새로운 탐색 스타일과 함께 작동하고 몇 가지 표준 기능을 지원하는 제목 메뉴를 추가했습니다: 복제, 이동, 이름 바꾸기, 내보내기 및 인쇄.

이것들은 해당 위임 방법이 구현될 때 메뉴에 자동으로 표시됩니다.

제목 메뉴에 완전히 사용자 지정 항목을 추가하는 것도 가능합니다.

또한, Mac Catalyst로 구축된 앱은 추가 코드 없이 NSToolbar와 원활하게 통합하여 향상된 내비게이션 바를 활용합니다.

iOS 16은 다양한 앱에서 텍스트를 일관되게 조작하는 새로운 방법을 소개합니다.

첫 번째는 새로운 발견과 교체이다.

개념적으로, 그것은 사진이나 달력 이벤트와 같은 데이터 모델 객체에서 작동하는 더 높은 수준의 인앱 검색과 다르다.

대신, 찾기 및 바꾸기는 텍스트로 작동하도록 의도적으로 만들어졌다.

UITextView 및 WKWebView와 같은 내장 UIKit 뷰의 기능을 활성화하려면 플래그를 설정하기만 하면 됩니다.

게다가, 그것은 이 시스템을 선택한 여러 뷰와 문서에서 원활하게 작동합니다.

다음으로, 편집 메뉴는 주요 업그레이드를 받았다.

이제 사용된 입력 방법에 따라 다르게 보인다.

터치 상호 작용에서, 당신은 더 인터랙티브한 재설계된 메뉴를 얻을 수 있습니다.

포인터를 사용할 때, 더 완전한 기능을 갖춘 컨텍스트 메뉴를 얻을 수 있습니다.

이 두 가지 경험을 원활하게 제공하기 위해, 우리는 현재 더 이상 사용되지 않는 UIMenuController의 완전한 대체품으로 UIEditMenuInteraction을 도입했습니다.

텍스트 보기 메뉴에 작업을 삽입하는 새로운 API도 있습니다.

"데스크탑 클래스 편집 상호 작용 채택"을 보고 새로운 편집 메뉴의 모든 세부 사항을 배우고, 사용자 지정 보기에 대한 상호 작용을 찾는 방법을 배우세요.

제가 다루고 싶은 시각적 UI 업데이트가 하나 있습니다.

iOS 16에서 슬라이드 오버 모드의 사이드바는 추가 코드 없이 자동으로 생생해집니다.

이를 달성하기 위해, UIKit은 당신을 대신하여 일련의 비공개 뷰를 관리합니다.

그것들은 UIKit의 새로운 생산성 기능입니다: 새로운 사용자 정의 가능한 탐색 표시줄, 찾기 및 교체, 상호 작용 편집, 강력한 제목 메뉴.

난 그냥 여기서 표면을 긁고 있어.

더 많은 것을 배우려면, "데스크탑 클래스 iPad 만나기" 세션과 iOS 16의 새로운 고급 UIKit 기능으로 샘플 앱을 개선하는 더 자세한 "데스크탑 클래스 iPad 앱 구축"을 확인하세요.

이제 저는 우리가 추가한 두 가지 새로운 컨트롤을 소개하고 UIPageControl의 몇 가지 개선 사항에 대해 논의할 것입니다.

UIDatePicker의 인라인 캘린더 스타일은 이제 UICalendarView의 형태로 모든 기능을 갖춘 독립형 구성 요소로 사용할 수 있습니다.

UICalendarView는 선택적 단일 날짜와 같은 다양한 유형의 선택 동작과 여러 날짜 선택을 지원합니다.

사용 가능한 날짜 범위 외에도, 그것은 또한 선택에서 개별 날짜를 비활성화하는 것을 지원합니다.

게다가, 당신은 장식으로 개별 날짜에 주석을 달 수 있습니다.

UICalendarView와 UIDatePicker의 한 가지 주요 차이점은 UICalendarView가 날짜를 NSDate가 아닌 NSDateComponents로 나타낸다는 것입니다.

NSDate와 달리, 날짜 구성 요소는 더 좋고, 날짜의 더 정확한 표현인 반면, NSDate는 시점의 표현이다.

NSDateComponents는 많은 유연성을 제공하기 때문에, 구성 요소가 어떤 NSCalendar로 표시되는지에 대해 매우 명확해야 합니다.

현재 달력의 유형에 대해 가정해서는 안 된다는 점에 유의하십시오.

달력이 그레고리력이어야 한다면, 그레고리력을 명시적으로 지정하세요.

앞서 표시된 것과 같은 캘린더 보기를 구성하려면, 먼저 캘린더 보기를 만들고 대리자를 설정하십시오.

달력이 그레고리안 NSCalendar에 의해 뒷받침되도록 하려면, calendarView의 캘린더 속성을 그레고리안 NSCalendar로 설정하세요.

다음으로, 다중 날짜 선택을 구성하기 위해.

UICalendarSelectionMultiDate 객체를 만들고, 선택 객체의 선택한 날짜 속성을 데이터 모델에서 캘린더 보기에 표시할 기존 날짜로 설정하십시오.

그런 다음, 선택 개체를 달력 보기의 선택 동작으로 설정하세요.

달력에서 개별 날짜를 선택하지 않으려면, 달력의 선택 대리인의 multiDateSelection:canSelectDate: 메소드를 구현하여 어떤 날짜를 선택할 수 있는지 제어하십시오.

선택할 수 없는 날짜는 달력 보기에서 회색으로 표시됩니다.

장식으로 개별 날짜에 주석을 달려면, 달력 대리인의 calendarView:decorationForDateComponents: Method를 구현하십시오.

장식이 없다면, 그냥 nil을 돌려주세요.

기본 회색 원의 경우, 기본 장식을 반환하세요.

색상을 사용자 정의할 수 있는 옵션으로 이미지 장식을 만들 수도 있습니다.

그리고 더 필요하다면, customView 장식을 사용하고 보기 공급자에서 보기를 반환하세요.

사용자 지정 보기 장식은 상호 작용을 허용하지 않으며 사용 가능한 공간으로 잘립니다.

페이지 컨트롤도 개선되었다.

현재 페이지에 대한 사용자 지정 표시기 이미지에 대한 지원을 추가했으므로, 이제 페이지가 선택되었는지 여부에 따라 다른 이미지를 선택할 수 있습니다.

이제 페이지 컨트롤의 방향과 방향을 모두 완전히 사용자 정의할 수 있습니다.

다음은 현재 페이지와 비현재 페이지 간에 지표가 변경되는 수직 페이지 컨트롤을 구성하는 예입니다.

페이지 컨트롤의 방향을 위에서 아래로 설정하고 선호하는 표시기 이미지와 선호하는 현재 표시기 이미지를 설정했습니다. 그게 다입니다!

애플은 사용자의 사생활과 보안을 보호하기 위해 최선을 다하고 있다.

iOS 15에서 애플리케이션이 시스템 제공 붙여넣기 인터페이스를 사용하지 않고 프로그래밍 방식으로 붙여넣기 보드에 액세스했을 때, 배너는 붙여넣기 보드에 액세스했음을 나타내는 것으로 보입니다.

iOS 16의 새로운 기능, 시스템 동작이 변경되었습니다.

이제, 배너 대신, 우리는 페이스트보드 사용 허가를 요청하는 경고를 표시할 것이다.

사용자가 상호 작용하는 시스템 붙여넣기 인터페이스는 붙여넣기 보드에 대한 암시적 액세스를 제공하고 경고를 피할 수 있습니다.

사용자 지정 붙여넣기 컨트롤이 있는 경우, 채워진 UIButton처럼 보이고 작동하는 새로운 UIPasteControl으로 대체할 수 있습니다.

붙여넣기 보드가 컨트롤의 붙여넣기 대상과 호환되는 콘텐츠를 얻을 때마다 활성화됩니다.

그래서 그것들은 새로운 강력한 UICalendarView, 개선된 UIPageControl, 그리고 보안 지향적인 UIPasteControl이다.

가서 그것들을 시도해봐.

이제 우리가 만든 몇 가지 API 개선 사항을 안내해 드리겠습니다.

iOS 15에서, 유연하고 역동적인 UI를 구축할 수 있는 시트에 디텐트가 추가되었습니다.

iOS 16에서는 사용자 지정 멈춤에 대한 지원을 추가하여 모든 크기의 시트를 만들 수 있습니다.

이 기능을 활용하려면, 새로운 ".custom" 디텐트를 사용하고 관련 블록의 포인트로 시트의 높이를 지정하십시오.

상수 값 또는 최대 디텐트 높이의 백분율을 반환할 수 있습니다.

그리고 예를 들어, 사용자 지정 디텐트 위의 디밍을 비활성화하기 위해 다른 API에서 참조해야 하는 경우 사용자 지정 디텐트에 식별자를 제공할 수도 있습니다.

사용자 지정 블록에서 반환하는 값은 하단 안전 영역 삽입을 설명해서는 안 됩니다.

이것은 플로팅 시트와 에지 부착 시트 모두에서 동일한 계산이 작동한다.

시스템 멈춤쇠 및 기타 옵션으로 시트를 사용자 정의하는 방법에 대해 자세히 알아보려면, UIKit 비디오에서 시트 사용자 정의 및 크기 조정을 시청하십시오.

그 비디오의 샘플 코드도 이러한 새로운 사용자 지정 디텐트 API를 보여주기 위해 업데이트되었습니다.

UIKit에는 SF 기호에 대한 새로운 기능이 있습니다.

기호는 네 가지 렌더링 모드를 지원합니다: 흑백, 다색, 계층 및 팔레트.

UIKit은 기호가 다른 렌더링 모드로 구성되지 않는 한 기본적으로 흑백 렌더링을 사용합니다.

iOS 16에서 UIKit은 렌더링 모드가 지정되지 않은 경우 흑백 이외의 모드로 개별 기호를 렌더링할 수 있습니다.

예를 들어, 이 장치 기호를 가져가세요.

iOS 15 이하에서, 이 기호는 렌더링 모드가 지정되지 않은 경우 흑백 렌더링을 사용합니다.

iOS 16에서, 이 기호들은 대신 계층적 렌더링으로 기본 설정됩니다.

일반적으로, 기호의 기본 렌더링 모드는 기호를 표시하는 선호되는 방법입니다.

따라서 이 경우, 기본 계층적 렌더링이 적용되도록 허용해야 합니다.

그러나, 흑백 렌더링은 새로운 UIImage.SymbolConfiguration. preferringMonochrome() API로 명시적으로 요청할 수 있습니다.

UIKit은 앱이 0에서 1까지의 값을 기준으로 기호의 변형을 표시할 수 있는 변수 기호에 대한 지원을 추가했습니다.

앱이 현재 볼륨 레벨을 기호로 묘사하고 싶다고 가정해 봅시다.

이 앱은 가변 렌더링을 지원하도록 업데이트된 speaker.3.wave.fill 기호를 사용할 수 있습니다.

0의 값에서, 스피커 웨이브는 희미해져, 가장 낮은 볼륨 레벨을 나타낸다.

값이 최대 1까지 증가함에 따라, 스피커는 점진적으로 채워져 더 높은 볼륨 레벨을 나타냅니다.

기호가 변수 렌더링을 지원하는 경우, 앱은 0에서 1 사이의 값을 반영하는 기호 버전을 요청할 수 있습니다.

변수 기호를 사용하는 것은 간단하다.

UIImage에서 표준 SF Symbols API를 사용하여 기호의 일반 비변수 버전을 얻을 수 있습니다.

특정 변수 값을 가진 기호의 버전을 얻으려면, variableValue 매개 변수를 추가하기만 하면 됩니다.

가변 렌더링을 팔레트와 같은 다른 렌더링 모드와 혼합하여 기호의 스타일을 더 지정할 수도 있습니다.

많은 시스템 기호는 이제 변수 렌더링을 지원하며, 앱은 가변성을 지원하기 위해 사용자 지정 기호를 업데이트할 수 있습니다.

사용자 지정 변수 기호를 만드는 방법을 배우려면, "SF 기호에서 가변 색상 채택" 세션과 "SF 기호 4의 새로운 기능"을 확인하세요.

우리는 UIImage 및 UIColor와 같은 불변 유형을 Sendable에 적합하게 만드는 것을 포함하여 새로운 Swift Concurrency 기능과 함께 작동하도록 UIKit을 현대화하여 컴파일러 경고 없이 MainActor와 사용자 지정 액터 간에 보낼 수 있습니다.

예를 들어, 여기에는 프로세서라는 사용자 지정 액터와 MainActor에 바인딩된 ImageViewer라는 뷰 컨트롤러가 있습니다.

sendImageForProcessing 방법에서, ImageViewer는 처리를 위해 프로세서 액터에게 이미지를 보내 반짝이와 무지개를 추가하는 것처럼 멋지게 만듭니다.

UIImage는 불변하기 때문에 안전하기 때문에 프로세서는 무지개와 반짝이를 추가하기 위해 새 복사본을 만들어야 합니다.

원본 이미지에 대한 참조가 있는 모든 코드는 이러한 수정을 보여주지 않으며, 공유 상태는 안전하지 않게 변이되지 않습니다.

이것을 가변적이기 때문에 보낼 수 없는 UIBezierPath와 대조하세요.

이전에 문서에서만 표현될 수 있었던 것이 이제 컴파일러에 의해 확인될 수 있다는 것이 얼마나 멋진가요?

Sendable과 Swift Concurrency에 대해 자세히 알아보려면, "Eliminate data races using Swift Concurrency"와 "Visualize and optimize Swift Concurrency" 비디오를 확인하세요.

iOS 16은 외부 디스플레이에 대한 새로운 강력한 지원을 제공합니다.

좋은 소식은 오래된 UIScreen API를 사용하지 않는 한, 이것을 활용하기 위해 앱을 업데이트할 필요가 없다는 것입니다.

더 이상 앱이 메인 화면에 있다고 가정할 수 없습니다.

대신, 필요한 정보를 얻기 위해 특성 수집 및 UIScene API와 같은 더 구체적인 API를 연기하십시오.

앱이 여전히 UIScene을 사용하지 않는다면, 이제 업그레이드하고 여러 창을 지원해야 할 더 많은 이유가 있습니다.

UICollectionView와 UITableView의 자체 크기 조정 셀이 크게 업그레이드되었습니다.

이제 세포도 스스로 크기를 조정하고 있다!

iOS 16에서, 보이는 셀 내부의 콘텐츠가 변경되면, 새 콘텐츠에 맞게 셀의 크기가 자동으로 조정됩니다.

이 새로운 동작은 기본적으로 활성화되며, UICollectionView와 UITableView는 각각 이 새로운 기능을 제어할 수 있는 새로운 selfSizingInvalidation 속성을 가지고 있습니다.

작동 방식은 다음과 같습니다: selfSizingInvalidation이 활성화되면, 셀은 포함된 컬렉션 또는 테이블 보기로 크기 조정을 요청할 수 있습니다.

UIListContentConfiguration을 사용하여 셀을 구성하는 경우, 셀의 구성이 변경될 때마다 무효화가 자동으로 발생합니다.

다른 경우, 셀 또는 contentView에서 invalidateIntrinsicContentSize 메서드를 호출하여 셀의 크기를 조정할 수 있습니다.

기본적으로 셀은 애니메이션으로 크기가 조정되지만, performWithoutAnimation 내부의 invalidateIntrinsicContentSize 호출을 래핑하여 애니메이션 없이 크기를 조정할 수 있습니다.

UICollectionView와 UITableView는 셀의 크기 무효화를 최적의 시간에 수행된 단일 업데이트로 지능적으로 결합합니다.

셀에서 자동 레이아웃을 사용하는 경우, enabledIncludingConstraints를 선택하여 훨씬 더 포괄적인 동작을 선택할 수 있습니다.

즉, 셀이 contentView 내부의 자동 레이아웃 변경을 감지하면 invalidateIntrinsicContentSize를 자동으로 호출하여 포함된 컬렉션 또는 테이블 뷰가 필요한 경우 크기를 조정할 수 있습니다.

이것은 콘텐츠나 레이아웃 업데이트에 반응하여 크기를 자동으로 조정하는 셀을 믿을 수 없을 정도로 쉽게 만든다.

UIKit은 강력하고 유연하다.

또한 SwiftUI를 사용하여 UI를 구현하는 표현력을 활용할 수 있습니다.

우리는 두 프레임워크를 같은 앱에 통합하는 것을 훨씬 쉽게 만들었습니다.

iOS 16에는 SwiftUI를 사용하여 컬렉션과 테이블 뷰를 위한 셀을 만드는 완전히 새로운 방법이 있습니다.

이것은 UIHostingConfiguration이라는 새로운 콘텐츠 구성 유형에 의해 가능합니다.

한 줄의 코드로, 당신은 셀 내에서 바로 SwiftUI를 작성할 수 있습니다. 추가 뷰나 뷰 컨트롤러가 전혀 필요하지 않습니다.

다음은 UIHostingConfiguration을 사용하여 SwiftUI로 작성된 간단한 사용자 지정 셀입니다.

이 세포를 만드는 것은 매우 쉽다.

이것은 SwiftUI를 앱에 통합하기 시작하는 좋은 방법일 뿐만 아니라, SwiftUI의 표현력은 UIKit에서 사용자 지정 셀을 구축하는 더 강력한 방법이 없었다는 것을 의미합니다.

이 주제에는 더 많은 것이 있으므로, "UIKit과 함께 SwiftUI 사용" 비디오를 확인하여 자세히 알아보세요.

당신이 알아야 할 몇 가지 작지만 중요한 변화가 있습니다.

사용자가 지문을 채취하는 것을 방지하기 위해, UIDevice.name은 이제 사용자의 사용자 지정 장치 이름이 아닌 모델 이름을 보고합니다.

이제 사용자 지정 이름을 사용하려면 자격을 받아야 합니다.

UIDevice.orientation 설정은 더 이상 지원되지 않습니다.

대신, preferredInterfaceOrientation과 같은 UIViewController API를 사용하여 인터페이스의 의도된 방향을 표현하십시오.

다음은 뭐야?

iOS 16 SDK를 사용하여 앱을 컴파일하세요.

텍스트 편집 메뉴와 같은 새로운 기능을 테스트하고 찾고 바꾸세요.

새로운 UIKit API를 채택하여 새로운 향상된 컨트롤과 생산성 기능을 사용하세요.

그리고 UIKit 앱에 SwiftUI를 통합하는 새로운 흥미로운 방법을 실험해 보세요.

고마워. ♪ ♪