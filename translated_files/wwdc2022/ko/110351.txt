110351

♪ 부드러운 기악 힙합 음악 ♪

♪

안녕.

저는 스위프트 팀의 더그이고, 데이터 경쟁을 없애기 위한 스위프트 동시성의 접근 방식에 대해 이야기하기 위해 왔습니다.

우리는 동시 프로그램을 더 쉽게 작성할 수 있는 일련의 언어 기능으로 Swift Concurrency를 도입했습니다.

이러한 개별 언어 기능의 메커니즘을 위해, 우리는 그들 각각을 다루는 2021년 WWDC 회담을 참조합니다.

이 강연은 데이터 경쟁을 도입하지 않고 동시성을 효율적으로 사용할 수 있도록 프로그램을 구조화하는 방법으로 Swift Concurrency에 대한 다른, 보다 전체적인 관점을 취합니다.

하지만 그렇게 하기 위해, 우리는 훌륭한 비유가 필요하므로, 우리는 당신이 동시성의 공해에서 우리와 함께 항해하도록 초대합니다.

동시성의 바다는 예측할 수 없으며, 많은 일들이 한 번에 일어나고 있지만, 당신이 지휘하고 스위프트가 당신이 바다를 항해하는 것을 도우면 놀라운 것들을 만들어낼 수 있습니다.

뛰어들자!

우리는 스위프트의 동시성 모델의 핵심 아이디어 중 하나인 격리에 대해 이야기하는 것으로 시작하여 데이터가 데이터 경쟁을 도입할 수 있는 방식으로 공유되지 않도록 할 것입니다.

작업 격리부터 시작합시다.

우리의 동시성의 바다에서, 작업은 보트로 대표된다.

보트는 우리의 주요 노동자이다 - 그들은 해야 할 일이 있고, 처음부터 끝까지 순차적으로 수행한다.

그것들은 비동기적이며, 그들의 작업은 코드의 "대기" 작업에서 여러 번 중단될 수 있다.

마지막으로, 그들은 독립적이다: 각 작업에는 자체 자원이 있으므로, 바다의 다른 모든 보트와 독립적으로 자체적으로 작동할 수 있다.

만약 우리의 보트가 완전히 독립적이라면, 우리는 데이터 경주 없이 동시성을 가지고 있지만, 통신할 수 있는 방법 없이는 그다지 유용하지 않다.

소통을 좀 추가하자!

예를 들어, 한 보트에는 다른 보트와 공유하고 싶은 파인애플이 있을 수 있다.

그래서 보트들은 바다에서 만나고, 우리는 파인애플을 한 보트에서 다른 보트로 옮긴다.

이제, 이것은 물리적 비유가 조금 무너지는 곳입니다. 왜냐하면 이 파인애플은 한 보트에서 다음 보트로 이동하는 물리적 아이템이 아니기 때문입니다.

그것은 데이터이며, 스위프트에는 그 데이터를 표현할 수 있는 몇 가지 다른 방법이 있습니다.

파인애플 종류를 어떻게 정의하나요?

우리는 스위프트의 가치 유형을 좋아하기 때문에, 파인애플을 무게와 성숙도에 의해 정의된 구조체로 만들어 봅시다.

이게 어떻게 작동하는지 보자.

보트가 바다에서 만날 때, 우리는 실제로 파인애플 인스턴스의 복사본을 한 보트에서 다음 보트로 전달하고 있으며, 각 보트는 자체 복사본을 가지고 떠난다.

Slice() 및 ripen() 메서드를 호출하여 복사본을 변경하는 경우, 다른 메서드에는 아무런 영향을 미치지 않습니다.

스위프트는 정확히 이러한 이유로 항상 가치 유형을 선호해 왔다 - 돌연변이는 국소적 영향만 있다.

그 원칙은 가치 유형이 고립을 유지하는 데 도움을 준다.

이제, 데이터 모델을 조금 확장하고 닭을 추가합시다!

먹기에만 좋은 파인애플과 달리, 닭은 그들만의 독특한 성격을 가진 아름다운 생물이다.

그래서, 우리는 이와 같은 수업으로 그들을 모델링할 것이다.

우리의 용감한 선원들이 닭을 교환하도록 하자.

우리 보트가 만날 때, 우리는 치킨을 공유하지만, 치킨과 같은 참조 유형을 복사하면 치킨의 또 다른 전체 복사본을 제공하지 않으며, 특정 대상에 대한 참조를 제공합니다.

그래서 일단 우리의 보트가 각자의 길을 가면, 우리는 문제가 있다는 것을 알 수 있다: 두 보트 모두 동시에 일을 하고 있지만, 둘 다 같은 닭 물체를 참조하기 때문에 독립적이지 않다.

그 공유된 가변 데이터는 한 보트가 닭에게 먹이를 주려고 하고 다른 보트가 그것을 가지고 놀고 싶어할 때와 같이 데이터 경주가 발생하기 쉬우며, 이는 매우 혼란스러운 닭으로 이어진다.

우리는 보트들 사이에서 파인애플을 공유하는 것이 안전하다는 것을 알 수 있는 방법이 필요하지만, 닭은 그렇지 않다.

그리고 나서 우리는 닭이 실수로 한 보트에서 다른 보트로 전달되지 않도록 스위프트 컴파일러에서 체크인해야 합니다.

스위프트 프로토콜은 유형을 분류하는 좋은 방법이므로 그들의 행동에 대해 추론할 수 있습니다.

전송 가능한 프로토콜은 데이터 경쟁을 만들지 않고도 다른 격리 도메인에서 안전하게 공유할 수 있는 유형을 설명하는 데 사용됩니다.

유형은 적합성을 작성하여 보낼 수 있습니다.

파인애플 구조는 값 유형이기 때문에 Sendable을 준수하지만, 치킨 클래스는 동기화되지 않은 참조 유형이기 때문에 할 수 없습니다.

Sendable을 프로토콜로 모델링하면 격리 도메인에서 데이터가 공유될 장소를 설명할 수 있습니다.

예를 들어, 작업이 값을 반환할 때, 이 값은 그 값을 기다리는 모든 작업에 제공됩니다.

여기서, 우리는 작업에서 치킨을 반환하려고 하는데, 치킨을 보낼 수 없기 때문에 이것이 안전하지 않다는 오류가 발생합니다.

실제 Sendable 제약 조건은 Success라고 불리는 Task의 결과 유형이 Sendable 프로토콜을 준수해야 한다는 것을 지정하는 Task 구조 자체의 정의에서 비롯됩니다.

다른 격리 도메인에 걸쳐 값이 전달될 일반 매개 변수가 있는 Sendable 제약 조건을 사용해야 합니다.

이제, 보트 간에 데이터를 공유하는 아이디어를 다시 살펴봅시다.

두 척의 보트가 공해에서 만나 데이터를 공유하고 싶을 때, 우리는 그들이 안전하게 공유할 수 있는지 확인하기 위해 모든 물품을 지속적으로 확인할 누군가가 필요하다.

그것은 Sendable 유형만 교환되도록 하기 위해 Swift 컴파일러가 수행한 우리의 친절한 세관 검사관의 역할입니다.

파인애플은 괜찮고 보낼 수 있기 때문에 자유롭게 교환할 수 있다.

그러나, 치킨은 교환할 수 없으며, 우리의 친절한 세관 검사관은 우리가 그 실수를 저지르는 것을 막을 것이다.

컴파일러는 여러 지점에서 전송 가능한 정확성을 확인하는 데 관여한다.

전송 가능한 유형은 건설에 의해 정확해야 하며, 공유 데이터가 이를 통해 밀수되는 것을 허용할 수 없습니다.

열거형과 구조체는 일반적으로 독립적인 값을 생성하기 위해 모든 인스턴스 데이터를 복사하는 값 유형을 정의한다.

따라서, 그들은 모든 인스턴스 데이터도 보낼 수 있는 한 보낼 수 있다.

Sendable은 조건부 적합성을 사용하여 컬렉션 및 기타 일반 유형을 통해 전파될 수 있습니다.

Sendable 유형의 배열은 Sendable이므로, 파인애플으로 가득 찬 상자도 보낼 수 있습니다.

이러한 모든 Sendable 적합성은 비공개 유형에 대한 Swift 컴파일러에 의해 추론될 수 있으므로 Ripeness, Pineapple 및 Crate는 모두 암시적으로 보낼 수 있습니다.

하지만 우리가 닭 떼를 수용하기 위해 둥지를 만든다고 가정해 봅시다.

이 유형은 보낼 수 없는 상태를 포함하기 때문에 보낼 수 있는 상태로 표시할 수 없습니다: 닭고기는 보낼 수 없으므로 닭 배열은 보낼 수 없습니다.

우리는 이 유형을 안전하게 공유할 수 없다는 것을 나타내는 컴파일러로부터 오류 메시지를 받게 될 것입니다.

클래스는 참조 유형이므로, 최종 클래스에 불변의 저장 공간만 있는 경우와 같이 매우 좁은 상황에서만 보낼 수 있습니다.

치킨 클래스를 보낼 수 있도록 하려는 우리의 시도는 가변적인 상태를 포함하고 있기 때문에 오류가 발생할 것이다.

이제, 예를 들어, 잠금을 일관되게 사용하여 자체 내부 동기화를 수행하는 참조 유형을 구현할 수 있습니다.

이러한 유형은 개념적으로 보낼 수 있지만, 스위프트가 그것에 대해 추론할 방법은 없다.

선택되지 않은 Sendable을 사용하여 컴파일러의 검사를 비활성화하십시오.

@Unchecked Sendable을 통한 변경 가능한 상태를 밀수하는 것은 스위프트가 제공하는 데이터 경쟁 안전 보장을 약화시키기 때문에 이에 주의하십시오.

작업 생성은 보트에서 노 젓는 보트를 보내는 것과 같은 새롭고 독립적인 작업에서 폐쇄를 실행하는 것을 포함합니다.

우리가 이것을 할 때, 우리는 원래 작업에서 값을 캡처하여 새로운 작업으로 전달할 수 있으므로, 데이터 경쟁을 도입하지 않도록 Sendable 확인이 필요합니다.

우리가 이 경계를 넘어 보낼 수 없는 유형을 공유하려고 한다면, 스위프트 컴파일러는 이와 같은 오류 메시지를 생성합니다.

이것은 작업 생성을 위한 마법이 아니다.

그 폐쇄는 At-Sendable과 함께 명시적으로 쓰여질 수 있는 Sendable 폐쇄로 추론되고 있다.

전송 가능한 클로저는 전송 가능한 함수 유형의 값입니다.

At-Sendable은 함수 유형이 Sendable 프로토콜을 준수한다는 것을 나타내기 위해 함수 유형에 쓸 수 있습니다.

그것은 그 함수 유형의 값이 다른 격리 도메인으로 전달되고 캡처된 상태에 데이터 경쟁을 도입하지 않고 호출될 수 있다는 것을 의미한다.

일반적으로 함수 유형은 프로토콜을 준수할 수 없지만, 컴파일러가 의미론적 요구 사항을 검증하기 때문에 Sendable은 특별하다.

Sendable 프로토콜을 준수하는 Sendable 유형의 튜플에 대한 유사한 지원이 있으며, 이를 통해 전체 언어에서 Sendable을 사용할 수 있습니다.

우리가 설명한 시스템은 서로 분리된 많은 작업을 동시에 실행하고 있다.

Sendable 프로토콜은 작업 간에 안전하게 공유할 수 있는 유형을 설명하며, Swift 컴파일러는 작업의 격리를 유지하기 위해 모든 수준에서 Sendable 적합성을 확인합니다.

그러나, 어디서나 공유된 가변 데이터에 대한 개념이 없다면, 작업이 의미 있는 방식으로 조정되는 것은 어렵다.

그래서 우리는 데이터 경쟁을 다시 도입하지 않는 작업들 사이에서 데이터를 공유할 수 있는 방법이 필요하다.

여기가 배우들이 들어오는 곳이다.

배우들은 다른 작업으로 접근할 수 있는 상태를 분리하는 방법을 제공하지만, 데이터 경쟁을 제거하는 조정된 방식으로 제공한다.

배우들은 우리의 동시성의 바다에 있는 섬이다.

보트와 마찬가지로, 각 섬은 자급자족하며, 바다의 다른 모든 것과 고립된 자체 상태를 가지고 있다.

그 주에 접근하려면, 당신의 코드가 섬에서 실행되어야 합니다.

예를 들어, advanceTime 방법은 이 섬에 고립되어 있다.

그것은 섬에 살고 있으며 섬의 모든 주에 접근할 수 있다.

실제로 섬에서 코드를 실행하려면 보트가 필요합니다.

보트는 섬에서 코드를 실행하기 위해 섬을 방문할 수 있으며, 그 시점에서 그 주에 접근할 수 있다.

한 번에 하나의 보트만 섬을 방문하여 코드를 실행할 수 있으며, 이는 섬의 주에 동시에 접근할 수 없도록 한다.

다른 배들이 나타나면, 그들은 섬을 방문할 차례를 기다려야 한다.

그리고 주어진 보트가 섬을 방문할 기회를 얻기까지는 오랜 시간이 걸릴 수 있기 때문에, 배우에 들어가는 것은 "기다림" 키워드로 표시된 잠재적인 정지 지점이다.

섬이 풀려나면 - 다시, 정지 지점에서 - 다른 보트가 방문할 수 있다.

두 척의 보트가 바다에서 만나는 것처럼, 보트와 섬 사이의 상호 작용은 보낼 수 없는 유형이 둘 사이를 통과하지 않도록 함으로써 둘 다의 격리를 유지해야 한다.

예를 들어, 아마도 우리는 우리 배의 닭을 섬의 무리에 추가하려고 할 것이다.

이것은 다른 격리 도메인에서 동일한 치킨 객체에 대한 두 개의 참조를 만들 것이므로, 스위프트 컴파일러는 그것을 거부한다.

마찬가지로, 우리가 섬에서 애완용 닭을 입양하여 보트에 가져가려고 한다면, Sendable 검사는 우리가 이 데이터 경주를 만들 수 없도록 합니다.

액터들은 참조 유형이지만, 클래스와 달리, 동시 액세스를 방지하기 위해 모든 속성과 코드를 분리합니다.

그러므로, 다른 격리 영역의 배우를 참조하는 것은 안전하다.

그것은 섬으로 가는 지도를 갖는 것과 같습니다: 지도를 사용하여 섬을 방문할 수 있지만, 그 상태에 접근하려면 도킹 절차를 거쳐야 합니다.

따라서, 모든 배우 유형은 암시적으로 보낼 수 있다.

당신은 어떤 코드가 배우에게 고립되어 있고 어떤 코드가 그렇지 않은지 어떻게 알 수 있는지 궁금할 것입니다.

배우의 고립은 당신이 있는 맥락에 의해 결정됩니다.

배우의 인스턴스 속성은 그 배우와 분리되어 있다.

액터의 인스턴스 메서드 또는 액터의 확장도 이 advanceTime 메서드와 같이 기본적으로 격리됩니다.

감소 알고리즘에 전달된 폐쇄와 같이 보낼 수 없는 폐쇄는 배우에 머물며 배우 격리 컨텍스트에 있을 때 배우 격리됩니다.

작업 이니셜라이저는 또한 컨텍스트에서 액터 격리를 상속하므로, 생성된 작업은 시작된 것과 동일한 액터에 예약됩니다.

여기, 그것은 양떼에 대한 접근을 허용한다.

반면에, 분리된 작업은 그것이 만들어진 맥락과 완전히 독립적이기 때문에 문맥으로부터 배우의 고립을 상속받지 않는다.

우리는 고립된 "음식" 속성을 언급하기 위해 "기다림"을 사용해야 하기 때문에 여기 폐쇄의 코드가 배우 외부에 있는 것으로 간주된다는 것을 알 수 있습니다.

우리는 이 폐쇄에 대한 용어가 있다: 그것은 격리되지 않은 코드이다.

격리되지 않은 코드는 어떤 행위자에서도 전혀 실행되지 않는 코드이다.

격리되지 않은 키워드를 사용하여 액터 외부에 배치하여 격리되지 않은 액터 내에 있는 함수를 명시적으로 만들 수 있습니다.

분리된 작업에 사용된 폐쇄로 암묵적으로 일어난 것과 같다.

그것은 우리가 배우에게 고립된 주의 일부를 읽고 싶다면, 우리는 섬을 방문하고 우리가 필요한 주의 사본을 잡기 위해 "기다림"을 사용해야 한다는 것을 의미한다.

격리되지 않은 비동기 코드는 항상 글로벌 협력 풀에서 실행됩니다.

보트가 바다에 있을 때만 달리는 것으로 생각하세요, 그래서 당신은 일을 하기 위해 방문하는 섬을 떠나야 합니다.

그것은 당신이 보낼 수 없는 데이터를 가져가지 않는지 확인하는 것을 의미합니다!

여기서, 컴파일러는 보낼 수 없는 치킨의 인스턴스가 섬을 떠나려고 하는 잠재적인 데이터 경쟁을 감지한다.

격리되지 않은 코드의 사례를 하나 더 고려해 봅시다.

"인사" 작업은 격리되지 않은 동기 코드입니다.

그것은 일반적으로 보트나 섬 또는 동시성에 대해 아무것도 모른다.

그리고 여기, 우리는 그것을 배우로 격리된 greetOne 기능에서 부르고 있어, 그리고 그건 괜찮아!

이 동기 코드는 섬에서 호출될 때 섬에 머무를 것이므로, 무리의 닭을 자유롭게 조작할 수 있다.

대신 우리가 "greet"이라고 부르는 격리되지 않은 비동기 작업이 있었다면, "greet"은 바다에서 보트를 타고 그곳에서 달릴 것이다.

대부분의 스위프트 코드는 다음과 같습니다: 동기적이고, 모든 액터와 격리되지 않으며, 주어진 매개 변수에서만 작동하므로 호출되는 격리 도메인에 남아 있습니다.

배우들은 프로그램의 나머지 부분과 고립된 상태를 가지고 있다.

한 번에 하나의 작업만 액터에서 실행할 수 있으므로, 그 상태에 대한 동시 액세스가 없습니다.

전송 가능한 검사는 동기화되지 않은 가변 상태가 이스케이프하지 않도록 작업이 액터에 들어가거나 나갈 때마다 적용됩니다.

전체적으로, 이것은 배우들을 스위프트의 동시 프로그램의 구성 요소 중 하나로 만든다.

우리가 자주 이야기하는 주연 배우라고 불리는 또 다른 특별한 배우가 있다.

주연 배우를 바다 한가운데에 있는 큰 섬으로 생각하세요.

사용자 인터페이스에 대한 모든 도면과 상호 작용이 발생하는 메인 스레드를 나타냅니다.

그래서 무언가를 그리고 싶다면, 주인공의 섬에서 코드를 실행해야 합니다.

그것은 당신의 UI에 매우 중요하기 때문에, 우리는 그것을 "U-I-land"라고 불러야 할 수도 있습니다.

우리가 주요 배우가 "크다"고 말할 때, 우리가 의미하는 것은 그것이 프로그램의 사용자 인터페이스와 관련된 많은 상태를 포함하고 있다는 것이다.

UI 프레임워크와 앱 모두에서 실행해야 하는 많은 코드가 있습니다.

하지만, 그것은 여전히 배우이기 때문에, 한 번에 하나의 직업만 운영한다.

따라서 UI가 반응하지 않을 수 있기 때문에 메인 배우에게 너무 많이 또는 장기 작업을 하지 않도록 주의해야 합니다.

주인공에 대한 고립은 MainActor 속성으로 표현된다.

이 속성은 코드가 메인 액터에서 실행되어야 함을 나타내기 위해 함수 또는 클로저에 적용될 수 있습니다.

그런 다음, 우리는 이 코드가 주인공에게 고립되어 있다고 말한다.

스위프트 컴파일러는 다른 행위자에 대한 상호 배타적인 액세스를 보장하는 동일한 메커니즘을 사용하여 메인 액터 격리 코드가 메인 스레드에서만 실행되도록 보장합니다.

메인 액터와 격리되지 않은 컨텍스트에서 updateView를 호출하는 경우, 메인 액터로의 전환을 설명하기 위해 "대기"를 도입해야 합니다.

주요 행위자 속성은 유형에도 적용될 수 있으며, 이 경우 이러한 유형의 인스턴스는 주요 행위자에게 격리될 것이다.

다시 말하지만, 이것은 다른 배우와 같다 - 속성은 메인 액터에 있는 동안에만 접근할 수 있으며, 방법은 명시적으로 옵트아웃하지 않는 한 메인 액터에게 격리된다.

일반 배우와 마찬가지로, 메인 액터 클래스에 대한 참조는 데이터가 격리되어 있기 때문에 전송할 수 있다.

이것은 메인 액터 주석을 UI 뷰와 뷰 컨트롤러에 적합하게 만들며, 이는 반드시 프레임워크 자체에 의해 메인 스레드에 연결되어 있습니다.

보기 컨트롤러에 대한 참조를 프로그램의 다른 작업 및 행위자와 공유할 수 있으며, 비동기적으로 보기 컨트롤러로 다시 호출하여 결과를 게시할 수 있습니다.

이것은 앱의 아키텍처에 직접적인 영향을 미칩니다.

앱에서, 당신의 뷰와 뷰 컨트롤러는 메인 액터에 있을 것입니다.

다른 프로그램 논리는 주요 행위자와 분리되어야 하며, 다른 행위자를 사용하여 공유 상태와 작업을 안전하게 모델링하여 독립적인 작업을 설명해야 합니다.

그리고 그 작업들은 필요에 따라 주요 배우와 다른 배우들 사이를 왕복할 수 있다.

동시 앱에서 많은 일이 일어나고 있기 때문에, 우리는 당신이 그것을 이해하는 데 도움이 되는 몇 가지 훌륭한 도구를 만들었습니다.

더 자세히 알아보려면 "스위프트 동시성 시각화 및 최적화" 강연을 확인하시기 바랍니다.

원자성에 대해 이야기하기 위해 더 깊은 바다로 뛰어들자.

스위프트 동시성 모델의 목표는 데이터 경쟁을 제거하는 것이다.

그것이 실제로 의미하는 것은 데이터 부패와 관련된 낮은 수준의 데이터 경쟁을 제거한다는 것이다.

당신은 여전히 높은 수준의 원자성에 대해 추론해야 합니다.

우리가 전에 이야기했듯이, 배우들은 한 번에 하나의 작업만 실행한다.

그러나, 당신이 배우를 실행하는 것을 멈추면, 배우는 다른 작업을 실행할 수 있습니다.

이것은 프로그램이 진행되도록 보장하며, 교착 상태의 가능성을 제거한다.

그러나, 대기 진술에 대해 배우의 불변성을 신중하게 고려해야 합니다.

그렇지 않으면, 데이터가 실제로 손상되지 않았음에도 불구하고 프로그램이 예상치 못한 상태에 있는 높은 수준의 데이터 경쟁으로 끝날 수 있습니다.

이것의 예를 분석해 봅시다.

여기에 섬에 파인애플을 추가로 보관하려는 기능이 있습니다.

그것은 배우 밖에 있기 때문에, 격리되지 않은 비동기 코드이다.

그것은 그것이 여기 바다에서 흘러나간다는 것을 의미한다.

파인애플 몇 개와 그 파인애플을 보관해야 하는 섬으로 가는 지도가 주어졌다.

이곳의 첫 번째 흥미로운 작업은 섬에서 음식 배열의 사본을 얻는다.

그렇게 하기 위해, 보트는 "기다림" 키워드로 신호를 받은 섬을 방문해야 한다.

음식 사본을 얻자마자, 배는 일을 계속하기 위해 탁 트인 바다로 돌아간다.

그것은 파인애플 매개 변수에서 파인애플을 섬에서 얻은 두 개에 추가하는 것을 의미한다.

이제, 우리는 그 기능의 마지막 줄로 이동할 수 있다.

우리 배는 이제 그 세 개의 파인애플에 섬의 음식 배열을 설정하기 위해 섬을 다시 방문해야 한다.

여기, 모든 것이 잘 풀렸고, 우리는 섬에 파인애플 세 개가 있어!

하지만 상황은 조금 달라질 수 있었다.

우리의 첫 번째 보트가 섬을 방문할 차례를 기다리는 동안 해적선이 몰래 들어와 모든 파인애플을 훔쳤다고 가정해 봅시다.

이제, 우리의 원래 배는 섬에 세 개의 파인애플을 보관하고, 우리는 문제를 발견했다.

세 개의 파인애플이 갑자기 다섯 개의 파인애플으로 변했어!

여기서 무슨 일이 있었어?

음, 우리는 같은 배우에 대한 주에 대한 접근을 위해 두 개의 대기가 있다는 것을 주목하세요, 그리고 우리는 여기서 섬의 음식 배열이 그 둘 사이에서 변하지 않는다는 가정을 하고 있습니다.

하지만 이것들은 기다리고 있으며, 이는 우리의 작업이 여기서 중단될 수 있고 배우가 해적과 싸우는 것과 같은 다른 우선 순위가 높은 일을 할 수 있다는 것을 의미한다.

이 특정한 경우, 스위프트 컴파일러는 다른 액터의 상태를 완전히 수정하려는 시도를 거부할 것이다.

그러나, 우리는 이와 같이 입금 작업을 액터에 대한 동기 코드로 다시 작성해야 합니다.

이것은 동기 코드이기 때문에, 중단 없이 액터에서 실행될 것이다.

그래서 우리는 섬의 상태가 전체 기능 전반에 걸쳐 다른 사람에 의해 변하지 않을 것이라고 확신할 수 있다.

배우를 쓸 때, 어떤 식으로든 인터리브할 수 있는 동기식 거래 작업의 관점에서 생각해 보세요.

그들 모두는 배우가 나갈 때 좋은 상태에 있는지 확인해야 한다.

비동기 액터 작업의 경우, 단순하게 유지하고, 주로 동기식 트랜잭션 작업에서 형성하고, 액터가 각 대기 작업에서 양호한 상태에 있도록 주의하십시오.

이렇게 하면, 낮은 수준과 높은 수준의 데이터 경쟁을 모두 제거하기 위해 배우를 최대한 활용할 수 있습니다.

동시 프로그램에서는 많은 일들이 한 번에 일어나고 있으므로, 그러한 일들이 일어나는 순서는 실행마다 다를 수 있다.

그럼에도 불구하고 프로그램은 종종 일관된 순서로 사건을 처리하는 데 의존한다.

예를 들어, 사용자 입력이나 서버의 메시지에서 들어오는 이벤트 스트림.

이러한 이벤트 스트림이 들어올 때, 우리는 그 효과가 순서대로 일어날 것으로 예상한다.

스위프트 동시성은 주문 작업을 위한 도구를 제공하지만, 행위자는 그렇게 하기 위한 도구가 아니다.

배우들은 전체 시스템이 반응성을 유지할 수 있도록 우선 순위가 높은 작업을 먼저 실행한다.

이것은 같은 배우에 대한 우선 순위가 높은 작업 전에 우선 순위가 낮은 작업이 끝나는 우선 순위 반전을 제거합니다.

이것은 엄격하게 선입선출 순서로 실행되는 직렬 디스패치 대기열과 상당한 차이가 있다는 점에 유의하십시오.

Swift Concurrency에는 작업을 주문하기 위한 몇 가지 도구가 있습니다.

우리가 이미 많은 것에 대해 이야기한 첫 번째 것 - 과제.

작업은 당신이 익숙한 정상적인 제어 흐름으로 처음부터 끝까지 실행되므로 자연스럽게 작업을 주문합니다.

AsyncStream은 실제 이벤트 스트림을 모델링하는 데 사용할 수 있습니다.

하나의 작업은 대기 루프로 이벤트 스트림을 반복하여 각 이벤트를 차례로 처리할 수 있습니다.

AsyncStream은 원하는 수의 이벤트 제작자와 공유할 수 있으며, 순서를 유지하면서 스트림에 요소를 추가할 수 있습니다.

우리는 스위프트의 동시성 모델이 작업과 액터 경계에서 Sendable에 의해 유지되는 격리 개념을 사용하여 데이터 경쟁을 제거하도록 설계된 방법에 대해 많은 이야기를 나눴습니다.

그러나, 우리 모두는 모든 곳에서 모든 Sendable 유형을 표시하기 위해 우리가 하고 있는 일을 멈출 수는 없다.

대신, 우리는 점진적인 접근이 필요하다.

스위프트 5.7은 스위프트 컴파일러가 전송 가능성을 얼마나 엄격하게 확인해야 하는지 지정하는 빌드 설정을 소개합니다.

기본 설정은 최소입니다. 즉, 컴파일러는 명시적으로 무언가를 Sendable로 표시하려고 시도한 장소만 진단합니다.

이것은 스위프트 5.5와 5.6의 동작 방식과 유사하며, 위의 경우 경고나 오류가 없을 것이다.

이제, Sendable 적합성을 추가하면, 컴파일러는 Chicken이 Sendable이 아니기 때문에 Coop 유형을 보낼 수 없다고 불평할 것이다.

그러나, 이것과 다른 Sendable 관련 문제는 문제를 하나씩 더 쉽게 해결할 수 있도록 Swift 5에서 오류가 아닌 경고로 표시될 것이다.

데이터 경주 안전을 향해 더 나아가려면, "표적" 엄격한 동시성 설정을 활성화하세요.

이 설정을 사용하면 비동기/대기, 작업 또는 배우와 같은 스위프트 동시성 기능을 이미 채택한 코드를 보낼 수 있습니다.

예를 들어, 이것은 새로 생성된 작업에서 보낼 수 없는 유형의 값을 캡처하려는 시도를 식별할 것이다.

때때로 보낼 수 없는 유형은 다른 모듈에서 나온다.

아마도 그것은 아직 Sendable을 위해 업데이트되지 않은 패키지일 수도 있고, 심지어 당신이 아직 찾지 못한 당신만의 모듈일 수도 있습니다.

이를 위해, @preconcurrency 속성을 사용하여 해당 모듈에서 오는 유형에 대해 전송 가능한 경고를 일시적으로 비활성화할 수 있습니다.

이것은 이 소스 파일 내의 치킨 유형에 대한 전송 가능한 경고를 침묵시킬 것이다.

어느 시점에서, FarmAnimals 모듈은 전송 가능한 적합성으로 업데이트될 것이다.

그런 다음, 두 가지 중 하나가 일어날 것이다: 치킨은 어떻게든 보낼 수 있게 되며, 이 경우 사전 동시성 속성은 가져오기에서 제거될 수 있다.

또는 치킨은 보낼 수 없는 것으로 알려질 것이며, 이 경우 경고가 돌아올 것이며, 이는 치킨을 보낼 수 있다는 당신의 가정이 사실 정확하지 않다는 것을 나타냅니다.

목표 엄격함 설정은 기존 코드와의 호환성과 잠재적인 데이터 경쟁을 식별하는 것 사이의 균형을 맞추려고 한다.

그러나, 경주가 발생할 수 있는 모든 곳을 보고 싶다면, 한 가지 옵션이 더 있습니다: 완전한 확인.

완전한 검사는 데이터 경쟁을 완전히 제거하기 위해 의도된 스위프트 6 의미에 가깝다.

그것은 이전의 두 모드가 확인하는 모든 것을 확인하지만 모듈의 모든 코드에 대해 그렇게 한다.

여기서, 우리는 실제로 스위프트의 동시성 기능을 전혀 사용하지 않고 있다.

오히려, 그것은 그 코드를 동시에 실행할 디스패치 큐에서 작업을 수행하고 있다.

디스패치 대기열의 비동기 작업은 실제로 전송 가능한 클로저를 취하는 것으로 알려져 있으므로, 컴파일러는 보낼 수 없는 본문이 디스패치 대기열에서 실행되는 코드에 의해 캡처될 때 데이터 경쟁이 있음을 나타내는 경고를 생성합니다.

우리는 본문 매개 변수를 보낼 수 있게 함으로써 이것을 고칠 수 있다.

그 변화는 이 경고를 없애고, 이제 doWork의 모든 발신자들은 그들이 Sendable 폐쇄를 제공해야 한다는 것을 알고 있다.

그것은 우리가 데이터 경주를 더 잘 확인할 수 있다는 것을 의미하며, 이제 방문 기능이 데이터 경주의 원천이라는 것을 알 수 있다.

완전한 검사는 당신의 프로그램에서 잠재적인 데이터 경쟁을 씻어내는 데 도움이 될 것입니다.

데이터 경쟁을 없애는 스위프트의 목표를 달성하기 위해, 우리는 결국 검사를 완료해야 할 것이다.

우리는 당신이 그 목표를 향해 점진적으로 노력할 것을 권장합니다: 스위프트의 동시성 모델을 채택하여 데이터 레이스 안전을 위해 앱을 설계한 다음, 코드에서 오류 클래스를 제거하기 위해 점진적으로 더 엄격한 동시성 검사를 가능하게 합니다.

그리고 가져온 유형에 대한 경고를 억제하기 위해 @preconcurrency로 수입을 표시하는 것에 대해 걱정하지 마세요.

그 모듈들이 더 엄격한 동시성 검사를 채택함에 따라, 컴파일러는 당신의 가정을 다시 확인할 것입니다.

이 길의 끝에서, 당신의 코드는 메모리 안전과 데이터 경쟁 안전 모두의 혜택을 받을 것이며, 훌륭한 앱을 만드는 데 집중할 수 있도록 도와줄 것입니다.

그리고 동시성의 바다에서 저와 함께 항해해 주셔서 감사합니다.

♪