10022

♪ ♪

안녕 그리고 환영해.

저는 카메라 소프트웨어 엔지니어링 팀의 브래드 포드입니다.

이 세션에서는 macOS용 최신 카메라 드라이버 아키텍처이자 DAL 플러그인을 대체하는 CoreMedia IO의 카메라 확장을 소개합니다.

DAL 플러그인은 Mac 또는 가상 카메라에 연결하는 하드웨어용 카메라 드라이버를 만들 수 있는 기술입니다.

그들은 macOS 10.7 이후로 아주 오랫동안 주변에 있었다.

DAL 플러그인은 macOS를 리치 미디어 플랫폼으로 확장할 수 있는 힘을 제공하여 전문가와 소비자에게 훌륭한 타사 카메라 제품에 대한 지원을 제공합니다.

그것은 Mac, Mac을 만드는 것의 일부이다.

하지만 DAL 플러그인에는 몇 가지 문제가 있다.

그들은 신뢰할 수 없는 코드를 앱의 프로세스에 직접 로드하여 플러그인에 버그가 있거나 맬웨어 공격이 있는 경우 충돌에 취약하게 만듭니다.

이러한 이유로, 그들은 FaceTime, QuickTime Player 및 PhotoBooth와 같은 Apple 앱에서 작동하지 않습니다.

또한 앱이 의도적으로 라이브러리 유효성 검사를 비활성화하거나 사용자가 시스템 무결성 보호를 끄지 않는 한 많은 타사 카메라 앱에서 작동하지 않습니다.

이들 중 어느 것도 시스템을 덜 안전하고 덜 안정적으로 만들기 때문에 권장되는 관행이 아니다.

그들도 발전하기 어렵다.

그들은 2011년경 C API와 당신이 배울 수 있는 C++ 도우미 클래스의 두꺼운 SDK를 가지고 있습니다.

그리고 무엇보다도, 그들은 거의 문서화되지 않는다.

업그레이드할 시간이야.

macOS 12.3은 카메라 확장이라고 불리는 DAL 플러그인의 완전히 현대적인 대체품을 소개합니다... 사용자 보안을 최우선으로 하는 아키텍처입니다.

그게 어떻게 작동하는지 알아보자.

먼저, 기술 개요를 제공하겠습니다.

다음으로, 처음부터 카메라 확장 프로그램을 만드는 방법을 보여드리겠습니다.

다음으로, API의 주요 클래스와 기능을 소개하겠습니다.

CoreMedia IO 확장을 출력 장치로 어떻게 사용할 수 있는지 설명하겠습니다.

그리고 마지막으로, 나는 우리의 DAL 플러그인 사용 중단 계획을 다룰 것이다.

시작하자.

CoreMedia IO 확장으로 알려진 카메라 확장은 Mac 응용 프로그램에 카메라 드라이버를 패키징하고 제공하는 새로운 방법입니다.

그들은 안전해.

확장 코드는 샌드박스되고 역할 사용자로 실행되는 자체 데몬 프로세스로 차단됩니다.

확장 프로그램이 제공하는 모든 버퍼는 앱에 전달되기 전에 검증됩니다.

그들은 빨라.

프레임워크는 성능에 중점을 두고 확장 프로세스와 앱 사이의 IPC 레이어를 처리합니다.

이 프레임워크는 또한 여러 동시 고객에게 버퍼를 전달할 수 있다.

그들은 현대적이야.

확장 프로그램은 Swift 또는 Objective-c로 작성할 수 있습니다.

그들은 간단해.

배워야 할 수업이 몇 개 있고, 시작하고 실행하기 위해 구현해야 할 몇 가지 프로토콜이 있다.

그 프레임워크는 상용구 코드를 처리한다.

그것들은 배치하기 쉽다.

App Store에서 앱으로 배송할 수 있습니다.

그리고 카메라 확장은 기존 AVFoundation 캡처 API와 100% 역호환됩니다.

카메라 확장 프로그램은 Apple 앱을 포함한 모든 카메라 앱의 내장 카메라와 마찬가지로 나타납니다.

FaceTime 카메라 선택기에서 카메라 확장 프로그램이 어떻게 나타날 수 있는지에 대한 예는 다음과 같습니다.

카메라 확장 프로그램으로 어떤 종류의 경험을 할 수 있나요?

세 가지 일반적인 용도를 연구해 봅시다.

가장 간단한 사용은 컬러 바를 표시하는 카메라, 독특한 테스트 패턴, 다양한 프레임 속도 또는 해상도로 프로그래밍 방식으로 생성된 이미지 또는 A/V 동기화를 테스트하기 위해 영화의 프레임과 같은 사전 렌더링된 콘텐츠를 스트리밍하는 카메라와 같은 소프트웨어 전용 카메라입니다.

두 번째 사용 사례는 Mac에 물리적으로 연결하거나 무선으로 발견하려는 카메라의 드라이버입니다.

카메라 확장은 핫플러그와 플러그를 완전히 지원합니다.

당신의 하드웨어를 다루기 위해, 당신은 몇 가지 선택지가 있습니다.

선호하는 방법은 사용자 공간에서 완전히 실행되는 DriverKit 확장 또는 DEXT를 사용하는 것입니다.

하드웨어가 커널 수준에서 해결되어야 하는 경우, 레거시 IOVideoFamily kext 경로를 사용할 수 있습니다.

Kext는 본질적으로 덜 안전하며 시스템 불안정에 기여할 수 있기 때문에 새로운 kext 코드의 개발은 권장되지 않습니다.

Apple은 USB 비디오 클래스 또는 UVC 카메라에 대한 클래스 호환 확장 프로그램을 제공합니다.

그것은 UVC 사양을 준수하는 카메라에 잘 작동합니다.

그러나 비표준 프로토콜을 사용하는 USB 카메라를 지원해야 하고 UVC 사양 이외의 추가 기능이 있는 경우, Apple의 UVC 확장을 무시하는 카메라 확장을 만들어 특정 제품 및 공급업체 ID를 청구할 수 있습니다.

그것에 대해 더 알고 싶다면, developer.apple.com의 "기본 USB 비디오 클래스 확장 오버라이드"라는 제목의 기사를 참조하십시오.

최소한의 DEXT 번들을 만드는 방법과 Info.plist에서 재정의해야 하는 IOKitPersonalities 키를 설명합니다.

세 번째 일반적인 용도는 소프트웨어와 하드웨어의 하이브리드인 창의적인 카메라이다.

확장 프로그램은 Mac에 연결된 다른 물리적 카메라의 비디오 스트림에 액세스하고, 버퍼에 효과를 적용하고, 고객에게 새로운 카메라 스트림으로 보냅니다.

또는 여러 카메라에서 비디오 스트림에 액세스하고, 합성하여 앱으로 보내는 창의적인 카메라.

이와 같은 창의적인 카메라는 구성 앱을 사용하여 합성을 제어하거나 필터를 매개 변수화할 수 있습니다.

창의적인 카메라의 가능성은 정말 무한하다.

이제 주요 사용 사례를 살펴보았으니, CoreMedia IO 확장의 해부학을 살펴봅시다.

먼저 "CoreMedia IO" 부분.

CoreMedia IO는 카메라 드라이버를 게시하거나 발견하기 위한 낮은 수준의 프레임워크이다.

당신은 이미 레거시 DAL API와 그것을 대체하는 새로운 카메라 확장 API가 포함되어 있다는 것을 알고 있습니다.

하지만 앱 개발자가 시스템에서 카메라를 찾고 검사할 수 있는 강력한 저수준 C API 세트도 포함되어 있습니다.

이제, 그 "확장" 부분은 어때?

CoreMedia IO 확장은 macOS Catalina에서 처음 등장한 SystemExtensions 프레임워크 위에 구축되었습니다.

그것은 일회용 설치자의 필요성을 없애줍니다.

대신, 앱 내에서 확장 프로그램을 배송합니다.

확장 실행 파일은 앱 번들 내에 있습니다.

SystemExtensions 프레임워크를 호출함으로써, 앱은 시스템의 모든 사용자를 위해 확장 프로그램을 설치, 업그레이드 또는 다운그레이드할 수 있습니다.

그리고 제거하는 것은 간단하다.

앱을 삭제하면 SystemExtensions 프레임워크는 모든 사용자의 카메라 확장 프로그램을 제거합니다.

이 전달 메커니즘은 App Store 사용을 위해 승인되어 카메라 확장 프로그램을 광범위한 청중에게 쉽게 배포할 수 있습니다.

시스템 확장 프레임워크에 대해 자세히 알아보려면, developer.apple.com/ documentation/systemextensions에서 문서를 읽을 수 있습니다.

그리고 "시스템 확장 및 DriverKit"이라는 제목의 WWDC 2019 비디오를 꼭 확인하세요.

그것이 카메라 확장에 대한 우리의 기술 개요를 위한 것입니다.

이제, 실제로 하나를 만들자.

다음은 몇 분 안에 카메라 확장 프로그램을 시작하고 실행하는 방법에 대한 빠른 데모입니다.

저는 Xcode에서 ExampleCam이라는 단일 창 macOS 애플리케이션을 만들었습니다.

이 시점에서, 나는 단지 몇 줄의 코드만 추가했다.

앱 대리인은 변경되지 않았습니다.

메인 스토리보드에서, 저는 두 개의 버튼을 추가했는데, 하나는 설치하기 위한 것이고 다른 하나는 확장 프로그램을 제거하기 위한 것이고, 그리고 상태를 표시하기 위한 텍스트 필드입니다.

ViewController 클래스에서 설치 및 제거 버튼을 연결하기 위해 IBActions를 추가했습니다.

이러한 기능은 앱 번들 내에 있는 확장 프로그램을 활성화하거나 비활성화하기 위해 OSSystemExtensionRequests를 생성합니다.

하단에, 저는 상태를 기록하는 OSSystemExtensionRequestDelegate 함수의 골격 구현을 추가했습니다.

앱의 자격 파일에는 일반적인 App Sandbox=YES가 있으며 AppGroup을 정의합니다.

앱이 시스템 확장을 설치하는 경우 필요한 "시스템 확장" 키라는 하나의 새로운 키만 추가했습니다.

이 시점에서, 앱을 실행하고 확장 설치 버튼을 클릭하면, 앱이 아직 존재하지 않는 번들에서 확장을 찾고 있기 때문에 치명적인 오류가 발생할 것입니다.

시스템 확장을 만들고 삽입하려면 File, New, Target으로 이동하고 macOS에서 시스템 확장이 있는 하단까지 스크롤합니다.

그런 다음 "카메라 확장"을 선택하고, 다음을 누르고, 이름을 지정하세요. "확장"을 선택하겠습니다. "임베디케이션"이 설정되어 있는지 확인한 다음, 완료를 클릭합니다.

새로운 확장 폴더 안에, 나는 네 개의 새로운 파일을 얻는다.

Info.plist는 MachServiceName을 정의하여 CMIOExtension으로 식별합니다.

이것은 중요한 정보이다.

CoreMedia IO의 registerassistant는 존재하지 않는 한 확장을 시작하지 않을 것입니다.

우리가 여기 있는 동안, 시스템 확장에 대한 사용 설명을 합시다.

자격 파일은 앱이 샌드박싱되었음을 보여줍니다.

그리고 유효성 검사를 통과하기 위해 내 확장 프로그램의 앱 그룹에 MachServiceName 접두사가 붙도록 해야 합니다.

그래서 나는 그것을 앱 확장 프로그램에서 확장 권한 파일로 복사하여 붙여넣을 것이다.

그리고 그게 다야.

Main.swift 파일은 확장자의 진입점 역할을 하며 서비스를 시작합니다.

그리고 ExtensionProvider.swift 파일은 우리에게 완전한 기능을 갖춘 카메라를 제공합니다.

여기에는 DeviceSource, StreamSource 및 ProviderSource가 포함되어 있으며, 순수한 소프트웨어 카메라를 만드는 데 필요한 모든 것이 있습니다.

나쁘지 않은 작은 템플릿.

이 파일에서 "SampleCapture"를 검색하고 "ExampleCam"로 대체하여 카메라의 이름, 모델 및 제조업체가 모두 적절한 이름을 갖도록 할 것입니다.

그게 다야. 컴파일하고 실행하자.

내가 설치 버튼을 눌렀을 때, 어-오, 그것은 실패한다.

시스템 확장은 /Applications에 있는 앱에서만 설치할 수 있기 때문입니다.

그걸 옮기고 다시 해보자.

이번에는 성공했다.

개인 정보 보호 및 보안을 찾은 시스템 설정에서 인증하여 차단된 확장 프로그램을 설치하도록 허용하고 허용 버튼을 클릭하라는 메시지가 표시됩니다.

비밀번호로 인증한 다음, "오류 없음"에 대한 결과가 0으로 변경된 것을 알 수 있습니다.

Systemextensionsctl 목록 도구를 사용하면, 성공했음을 확인하고, 이제 시스템에 하나의 확장 프로그램이 활성화되어 있습니다.

이제 나는 모든 카메라 앱을 열고 내 작품을 찾고 감탄할 수 있다.

페이스타임을 시작하자.

ExampleCam은 카메라 선택기에 나타난다.

그것은 70년대의 오래된 퐁 게임처럼 보이며, 초당 60프레임으로 프레임을 위아래로 움직이는 수평 흰색 선을 그린다.

카메라를 없애려면, 내가 해야 할 일은 앱을 삭제하는 것뿐이다.

시스템에서 앱을 삭제하여 확장 프로그램을 제거하고 있는지 확인하라는 메시지가 표시됩니다.

ExampleCam 데모는 소프트웨어 카메라를 처음부터 만드는 것이 얼마나 쉬운지 보여줍니다.

이제 그 소프트웨어 카메라를 창의적인 카메라로 바꾸면서 한 단계 더 올라가 봅시다.

나는 이 두 번째 예시를 CIFilterCam이라고 부른다.

CI는 스틸이나 비디오에 적용할 수 있는 모든 종류의 효과 필터가 있는 프레임워크인 CoreImage의 약자입니다.

CIFilterCam을 만들기 위해, 저는 ExampleCam 셸로 시작했지만, 앱을 구성 앱과 설치 프로그램으로 만들기로 결정했습니다.

카메라 선택기 버튼, 필터 선택기 버튼, 효과 바이패스 버튼을 추가했습니다.

나는 또한 라이브 비디오 미리보기를 위한 보기를 추가했다.

이것은 필터 카메라가 무엇을 하고 있는지 보여주기 위해 AVCaptureVideoPreviewLayer에 의해 뒷받침되는 표준 보기입니다.

바이패스 버튼을 선택 해제하면 색상 효과에서 왜곡 필터에 이르기까지 비디오에 적용된 다양한 필터를 볼 수 있습니다.

나는 범프 왜곡에 좀 편파적이야.

나는 이것들을 내장 FaceTime 카메라나 내 Mac에 부착된 모든 물리적 카메라에 적용할 수 있다.

나는 내 아이폰을 근처에 연속성 카메라로 설정했다.

그걸 사용하자.

CIFilterCam 앱은 그 자체로 특별한 것이 아니다.

그냥 효과 카메라 앱.

하지만 정말 흥미로워지는 것은 앱이 모든 앱이 사용할 수 있는 가상 필터 카메라의 프런트 엔드라는 것을 깨달을 때입니다.

나는 FaceTime과 PhotoBooth를 실행하고 둘 다 CIFilterCam을 가리키고 있는지 확인할 것이다.

이제, 구성 앱에서 필터를 변경하면서, CIFilterCam을 사용하는 모든 앱은 함께 변경됩니다.

다른 소스 카메라를 고르면, 모든 카메라 앱이 변경 사항을 선택합니다.

앱의 모든 버튼 클릭은 필터 캠 확장에 대한 간단한 속성 호출로 변환되며, "이봐, 확장, 이 카메라를 사용하세요" 또는 "이봐, 확장, 이 다른 필터를 사용하세요."라고 말합니다.

아니면 이 다른 필터.

아니면 이 다른 필터.

확장 프로그램 내에서 하드웨어 카메라를 실행하려면 macOS Ventura가 필요합니다.

또한 확장자의 권한 파일에 com.apple.security.device.camera 키를 추가해야 하며, 이는 다른 카메라를 사용할 것임을 나타냅니다.

그리고 카메라를 사용할 것이기 때문에, 사용자에게 확장 프로그램에 대한 권한을 부여하라는 메시지가 표시되므로, Info.plist에 NSCameraUsageDescription을 제공해야 합니다.

그것은 카메라 확장을 만드는 기본 사항을 마무리한다.

이제 API로 넘어가자.

스택의 하단에는 각 제1자 또는 제3자 카메라 확장에 대해 하나씩 데몬 프로세스가 있습니다.

카메라 앱 프로세스 내에서, IPC를 통해 카메라 확장과 통신하는 개인 프레임워크 코드로 시작하는 여러 레이어가 있습니다.

한 레벨 업은 CoreMedia IO 확장 호출을 레거시 DAL 플러그인 호출로 변환하는 또 다른 개인 계층입니다.

다시, 우리는 DAL 플러그인을 게시하는 공개 CoreMedia IO API를 찾습니다.

이 인터페이스의 클라이언트에게 CoreMedia IO 확장과 DAL 플러그인 사이에는 차이가 없습니다.

모든 것이 DAL 플러그인처럼 보인다.

그리고 마지막으로, 맨 위에는 CoreMedia IO의 고객인 AVFoundation이 있다.

DAL 플러그인을 AVCaptureDevices로 다시 게시합니다.

이것을 레거시 DAL 플러그인 아키텍처와 대조하세요.

DAL 플러그인은 데몬 조각을 포함할 수도 있고 포함하지 않을 수도 있지만, 모두 앱 프로세스에서 직접 CoreMedia IO 프레임워크에 의해 로드된 코드를 실행합니다.

이것은 앱을 악성코드에 취약하게 만든다.

카메라 확장은 이 공격 벡터를 완전히 제거합니다.

확장 프로그램은 앱 샌드박싱되어야 하며, 그렇지 않으면 실행할 수 없습니다.

애플의 registerassistantservice는 CMIOExtensionMachServiceName으로 식별하고 _cmiodalassistants라는 역할 사용자 계정으로 시작합니다.

샌드박스는 당신의 프로세스에 사용자 지정 샌드박스 프로필을 적용합니다.

그것은 카메라 사용 사례에 맞춰져 있다.

사용자 지정 샌드박스 프로필을 사용하면 예상되는 일반적인 하드웨어 인터페이스를 통해 통신할 수 있습니다.

USB, 블루투스, 와이파이는 클라이언트이지만 포트를 여는 서버는 아닙니다. 심지어 파이어와이어.

또한 확장 프로그램을 자체 컨테이너와 tmp에서 읽고 쓸 수 있습니다.

카메라 확장 샌드박스 프로필은 일반 앱보다 더 잠겨 있다.

할 수 없는 일의 몇 가지 예는 포크, 실행 또는 자식 프로세스를 생성하거나, 창 서버에 액세스하거나, 포그라운드 사용자 계정에 연결하거나, 글로벌 네임스페이스에 자신의 mach 서비스를 등록하는 것입니다.

확장 프로그램을 개발할 때 샌드박스가 합법적인 캡처 케이스에 너무 제한적이라고 생각되면, 피드백 어시스턴트를 통해 피드백을 제공해 주시면 제한 완화를 신중하게 고려할 것입니다.

이전 아키텍처 다이어그램은 버퍼를 앱 레이어로 직접 전달하는 카메라 확장 프로그램의 데몬 프로세스를 보여주었습니다.

실제로 보안 계층이 하나 더 있다.

데몬과 앱 사이에는 registerassistantservice라는 프록시 서비스가 있습니다.

그것은 투명성, 동의 및 통제 정책을 시행한다.

앱이 처음으로 카메라를 사용하려고 할 때, 시스템은 사용자에게 괜찮은지 묻는다.

그 동의는 내장된 카메라뿐만 아니라 모든 카메라에 대해 부여되어야 한다.

프록시 서비스는 당신을 대신하여 이 동의를 처리합니다.

사용자가 카메라 액세스를 거부한 경우, 프록시는 버퍼가 해당 앱으로 가는 것을 멈춥니다.

또한 속성을 처리합니다. 시스템이 특정 카메라가 특정 앱에서 사용 중임을 알려주므로 데몬이 소비하는 전력이 카메라를 사용하는 앱에 기인할 수 있습니다.

CoreMedia IO 확장에는 네 가지 주요 클래스가 있습니다: 공급자, 장치 및 스트림.

공급자는 장치를 가지고 있고 장치에는 스트림이 있으며, 세 가지 모두 속성을 가질 수 있다.

각각 ProviderSource, DeviceSource 및 StreamSource를 제공하여 이 세 가지 주요 클래스를 각각 만듭니다.

ExtensionProvider는 가장 낮은 수준의 객체입니다.

핫플러그 이벤트와 같이 필요에 따라 장치를 추가하고 제거할 수 있습니다.

연결하려고 할 때 클라이언트 프로세스에 대한 정보를 얻으며, 이는 장치 게시를 특정 앱으로 제한할 수 있는 기회를 제공합니다.

또한 부동산 구현을 위해 공급자 소스 객체를 참조합니다.

확장의 주요 진입점은 다음과 같습니다.

CMIOExtensionProviderSource 프로토콜을 준수하고 ExtensionProvider를 만드는 자신만의 ExtensionProviderSource를 만듭니다.

서비스를 시작하려면, 공급자 클래스 메소드 startService를 호출하고 공급자 인스턴스를 전달합니다.

ExtensionProvider는 확장 수명 동안 변경되지 않는 두 가지 읽기 전용 속성을 구현합니다.

제조업체와 공급자의 이름.

둘 다 끈이야.

다음은 CMIOExtensionDevice입니다.

그것은 필요에 따라 스트림을 관리하고, 추가하거나 제거합니다.

당신의 장치는 여러 스트림을 표시할 수 있지만, AVFoundation은 첫 번째 입력 스트림을 제외한 모든 스트림을 무시한다는 점에 유의하십시오.

장치를 만들 때, 장치 소스와 현지화된 이름, UUID로 장치 ID, 그리고 선택적으로 레거시 ID 문자열을 제공합니다.

이 속성들은 AVFoundation까지 스며든다.

장치의 localizedName은 AVCaptureDevice의 localizedName이 됩니다.

레거시DeviceID도 제공하지 않는 한, 지정된 장치 ID는 AVCaptureDevice의 고유 식별자가 됩니다.

DAL 플러그인을 현대화하고 이전에 배송한 고유 식별자와의 이전 버전과의 호환성을 유지해야 하는 경우에만 이것을 제공해야 합니다.

레거시디바이스ID를 제공한다면, AVCaptureDevice는 그것을 고유 식별자로 사용할 것입니다.

CMIOExtensionDeviceSource로 CMIOExtensionDevice를 만들면, 이는 동일한 모델의 모든 카메라에 대해 동일해야 하는 deviceModel과 같은 다른 속성을 선택적으로 구현할 수 있습니다.

장치가 개인 정보 보호 아이리스가 있는 경우와 같이 정지된 상태로 들어갈 수 있는 경우 isSuspended를 구현해야 합니다.

애플 노트북의 내장 카메라는 조개껍질이 닫힐 때 정지 상태로 들어갑니다.

장치의 전송 유형은 USB, 블루투스 또는 파이어와이어와 같이 어떻게 연결되어 있는지 보여줍니다.

마지막으로, 카메라와 물리적으로 페어링된 마이크가 있다면, 연결된 장치로 노출할 수 있습니다.

이 모든 속성은 읽기 전용입니다.

다음은 CMIOExtension에서 무거운 작업을 수행하는 가장 중요한 CMIOExtensionStream입니다.

비디오 형식을 게시하고 유효한 프레임 속도를 정의하고 활성 형식을 구성합니다.

그것은 호스트 시간 클럭과 같은 표준 시계를 사용하거나, 그것이 생성하는 각 버퍼의 타이밍을 구동하기 위해 자체 사용자 지정 시계를 제공한다.

그리고 가장 중요한 것은, 그것은 고객에게 샘플 버퍼를 보낸다는 것이다.

확장 스트림 소스는 CMIOExtensionStreamFormats를 게시합니다.

그것들은 AVCaptureDeviceFormats가 된다.

클라이언트는 활성 형식 인덱스를 읽고 작성하여 활성 형식을 변경할 수 있습니다.

최대 프레임 속도와 동등한 프레임 지속 시간.

그리고 최대 프레임 지속 시간은 최소 프레임 속도와 동일합니다.

DAL 플러그인 세계는 DAL 컨트롤이라고 불리는 네 번째 인터페이스를 노출한다.

플러그인 개발자는 이를 사용하여 자동 노출, 밝기, 선명도, 팬 및 줌 등과 같은 기능을 노출합니다.

강력하지만, 그것들은 일관성 없이 구현되었기 때문에, 앱 개발자들이 그것들을 사용하는 것은 어렵다.

CMIOExtension 아키텍처에서, 우리는 DAL 제어 교체를 제공하지 않습니다.

대신, 모든 것은 재산이다.

당신은 이미 공급자, 장치 및 스트림 수준에서 많은 표준 속성에 대해 배웠습니다.

CIFilterCam 데모에서 했던 것처럼 자신만의 사용자 지정 속성을 만들어 앱 레이어로 전파할 수도 있습니다.

CoreMedia IO의 C 속성 인터페이스는 C 구조체를 사용하여 속성의 선택기, 범위 및 요소를 식별합니다.

이것들은 그것의 주소로 여겨진다.

선택기는 사용자 지정을 위한 cust와 같은 4자 코드로서의 속성의 이름이다.

범위는 전역, 입력 또는 출력이 될 수 있으며, 요소는 원하는 숫자가 될 수 있습니다.

주요 요소는 항상 0이다.

CMIOExtensions를 사용하면 속성 주소 요소를 사용자 지정 속성 이름으로 코딩하여 속성을 구세계에 연결할 수 있습니다.

먼저, 문자 4cc_, 그 다음 선택기, 범위 및 요소는 밑줄로 구분된 네 개의 문자 코드입니다.

이 방법을 사용하면 모든 문자열이나 데이터 값을 앱 레이어에 전달할 수 있습니다.

AVFoundation은 사용자 지정 속성에서 작동하지 않으므로, 구성 앱이 사용자 지정 속성으로 작동해야 하는 경우 CoreMedia IO C API를 고수해야 합니다.

그것이 API에 대한 우리의 높은 수준의 시각이다.

이제 출력 장치에 대해 이야기해 봅시다.

DAL 플러그인의 덜 알려진 기능은 앱의 비디오를 제공하기보다는 실시간으로 소비하는 출력 장치인 카메라의 반대를 제시할 수 있는 능력이다.

이것은 CoreMedia IO의 "O" 부분이다.

입력과 출력.

출력 장치는 프로 비디오 세계에서 흔하다.

몇 가지 일반적인 용도는 비디오 신호가 외부 레코더로 전송되는 인쇄 테이프 또는 SDI 입력이 있는 프로 데크와 같은 실시간 미리보기 모니터링입니다.

주목해야 할 한 가지 중요한 점은 출력 장치에 AVFoundation API가 없다는 것입니다.

프레임을 출력 장치로 보내려면, CoreMedia IO C API를 직접 사용해야 합니다.

CMIOExtension 스트림은 소스 또는 싱크 방향으로 생성됩니다.

싱크 스트림은 앱의 데이터를 소비한다.

고객은 샘플 버퍼를 간단한 대기열에 삽입하여 싱크 스트림을 공급합니다.

그것은 확장 프로그램의 consumeSampleBuffer 호출로 변환되며, 그 버퍼를 소비하면 notifyScheduledOutputChanged로 알립니다.

출력 장치에 특정한 많은 스트림 속성이 있다.

그들은 주로 대기열 크기 조정, 시작하기 전에 버퍼링할 프레임 수, 그리고 모든 데이터가 소비되었을 때의 신호를 다룬다.

이제 오늘의 다섯 번째이자 마지막 주제로 진행합니다.

프레젠테이션 초반에, 나는 DAL 플러그인 아키텍처의 이 다이어그램을 보여주었고 많은 보안 문제를 강조했다.

우리는 카메라 확장으로 이러한 단점을 해결했으며 지속적인 개발에 전념하고 있습니다.

그들은 앞으로 나아가는 길이다.

그래서 그게 DAL 플러그인에 무슨 뜻이야?

끝이 가까웠다는 뜻이야.

macOS 12.3부터 DAL 플러그인은 이미 더 이상 사용되지 않으므로 빌드할 때 컴파일 경고가 표시됩니다.

그것은 좋은 시작이지만, 충분하지 않다.

레거시 DAL 플러그인을 로드할 수 있는 한, 카메라 앱은 여전히 위험에 처할 것이다.

보안 취약점을 완전히 해결하고 모든 사용자를 위해 시스템을 더 강력하게 만들기 위해, 우리는 macOS Ventura 이후의 다음 주요 릴리스에서 DAL 플러그인을 완전히 비활성화할 계획입니다.

이게 너한테 무슨 의미야?

음, 우리는 그 메시지가 명확하기를 바랍니다.

현재 DAL 플러그인을 유지하고 있다면, 이제 코드를 카메라 확장 프로그램으로 포팅하기 시작할 때입니다.

그리고 어떤 마찰에 부딪치는지 알려주세요.

우리는 이러한 문제를 해결하고 풍부한 기능 세트를 제공하기를 열망합니다.

우리는 당신과 함께 일하기를 정말 기대하고 있습니다.

이것으로 macOS용 카메라 확장 프로그램에 대한 오늘의 프레젠테이션을 마칩니다.

우리는 당신이 Mac에 어떤 신선하고 창의적인 카메라 경험을 가져올지 빨리 보고 싶습니다.

그리고 네가 그걸 하면서 즐거운 시간을 보내길 바라.