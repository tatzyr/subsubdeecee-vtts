10032

♪ 부드러운 기악 힙합 음악 ♪

♪

안녕하세요, 여러분. 제 이름은 Shortcuts Engineering의 Michael Gorbach입니다.

앱의 기능을 시스템에 노출하기 위한 새로운 프레임워크인 앱 인텐트에 대한 심층 조사를 조정해 주셔서 감사합니다.

여기 우리의 다이빙 계획이 있습니다.

간단한 소개 후에, 나는 의도와 그 매개 변수, 그리고 엔티티를 정의하는 방법에 대해 이야기할 것이다.

당신이 만들 수 있는 몇 가지 강력한 발견 및 필터링 기능, 그리고 당신의 의도가 사용자와 어떻게 상호 작용할 수 있는지 살펴보겠습니다.

마지막으로, 나는 앱 인텐트 아키텍처와 수명 주기를 다룰 것이다.

처음부터 시작하자.

iOS 10에서는 앱의 기능을 메시징, 운동 및 결제와 같은 Siri 도메인에 연결할 수 있는 SiriKit Intents 프레임워크를 도입했습니다.

이제 우리는 앱 인텐트라고 불리는 새로운 프레임워크를 도입하고 있습니다.

그것은 세 가지 주요 구성 요소를 가지고 있다.

의도는 시스템 전체에서 사용할 수 있는 앱에 내장된 작업입니다.

의도는 엔티티를 사용하여 앱의 개념을 나타냅니다.

앱 단축키는 당신의 의도를 감싸서 자동으로 발견할 수 있게 합니다.

앱 인텐트가 더 많은 곳에서 앱의 기능을 사용할 수 있고 고객에게 혜택을 줄 수 있는 몇 가지 방법에 대해 이야기해 봅시다.

앱 단축키를 사용하면 모든 사람이 먼저 설정할 필요 없이 Siri를 통해 음성으로 앱의 기능을 사용할 수 있습니다.

동일한 채택은 또한 사람들이 당신의 앱을 검색할 때 그리고 당신의 앱이 제안될 때 당신의 의도가 Spotlight에 나타나게 합니다.

이것은 당신의 일을 최우선으로 할 것입니다.

앱 인텐트를 사용하면 포커스 필터를 구축하여 고객이 특정 포커스에 맞게 앱을 사용자 정의할 수 있습니다.

예를 들어, 그들은 실제로 일하는 동안에만 작업 일정을 표시하도록 캘린더 앱을 설정할 수 있습니다.

포커스 필터를 채택하는 방법에 대해 자세히 알아보려면 이 세션을 확인하세요.

앱 단축키를 사용하면 수동으로 추가할 필요 없이 단축키 앱에 의도가 자동으로 표시됩니다.

작업을 단축키에 통합하는 것은 고객이 시스템 전체의 많은 곳에서 단축키를 실행하고 앱의 기능을 활용할 수 있기 때문에 고객에게 매우 중요합니다.

그들은 홈 화면, macOS의 메뉴 표시줄 및 기타 여러 가지 방법으로 한 번의 탭으로 단축키를 실행할 수 있습니다.

그들은 자동화로 자동으로 실행되도록 단축키를 설정할 수도 있다.

단축키 지원은 앱의 힘과 기능을 전체 단축어 생태계에 연결하여 앱의 힘을 배가시키고, Apple 및 기타 개발자의 다양한 앱의 힘을 활용합니다.

바로 가기는 여러 앱의 작업을 결합할 수 있기 때문에 사용자가 작업을 할 필요 없이 완전히 새로운 기능과 기능을 발명할 수 있기 때문입니다.

당신의 행동이 다른 사람들과 잘 작동하고 이 생태계에 매끄럽게 적응하는 방법을 배우고 싶다면, 우리의 디자인 토크를 확인하세요.

앱 인텐트를 구축하는 우리의 목표는 그것을 발전시키는 기쁨을 만드는 것이었다.

앱 의도는 간결하다.

간단한 의도를 작성하는 것은 몇 줄의 코드만 사용할 수 있지만, API는 또한 더 깊고 사용자 정의 가능한 작업으로 확장됩니다.

앱 인텐트는 현대적이다.

우리는 결과 빌더, 속성 래퍼, 프로토콜 지향 프로그래밍 및 제네릭을 활용하여 Swift를 모두 활용했습니다.

이 API는 최첨단 언어 기능 없이는 존재할 수 없다.

앱 인텐트를 채택하는 것도 쉽습니다. 왜냐하면 제품과 목표를 재설계하거나 프레임워크를 만들 필요가 없기 때문입니다.

확장이 필요하지 않으며 앱에서 바로 채택할 수 있습니다.

그리고 앱 인텐트 코드는 유지 관리가 가능합니다.

SwiftUI와 마찬가지로, 앱 인텐트는 코드를 진실의 기본 소스로 사용하여 별도의 편집기나 정의 파일이 필요하지 않습니다.

이를 통해 채택을 빠르게 구축하고 반복할 수 있으며, 모든 것이 한 곳에 있기 때문에 유지 보수를 단순화할 수 있습니다.

그렇긴 하지만, 우리의 새로운 프레임워크의 중심 빌딩 블록인 의도부터 시작하여 이 새로운 API를 탐구해 봅시다.

앱 의도 또는 줄여서 "의도"는 앱이 시스템에 노출하는 하나의 고립된 기능 단위입니다.

예를 들어, 의도는 새로운 달력 이벤트를 만들거나, 특정 화면을 열거나, 주문할 수 있다.

사용자가 요청 시 바로 가기를 실행하거나 Siri에게 요청하거나 초점 필터나 단축키 자동화를 사용하는 것과 같이 자동으로 의도를 실행할 수 있습니다.

의도가 실행되면, 결과를 반환하거나 오류를 발생시킬 것이다.

인텐트는 세 가지 핵심 부분을 포함합니다: 메타데이터 또는 현지화된 제목을 포함한 인텐트에 대한 정보; 인텐트가 실행될 때 사용할 수 있는 입력인 매개 변수; 그리고 인텐트가 실행될 때 실제 작업을 수행하는 수행 방법.

오늘 우리의 출발점은 이 도서관 앱이다.

나는 거대한 책벌레이기 때문에, 내가 읽었거나, 읽고 싶거나, 현재 읽고 있는 책을 추적하는 것에 관한 것이다.

각 카테고리는 내가 선반이라고 부르는 앱의 별도의 탭에 표시됩니다.

내 사용자들은 항상 현재 읽고 있는 선반을 방문하기 때문에, 나는 그것을 더 빠르고 편리하게 열 수 있도록 앱 의도를 노출할 것이다.

AppIntent 프로토콜을 준수하는 Swift 구조를 정의하여 OpenCurrentlyReading 인텐트를 만들 것입니다.

나는 perform라고 불리는 한 가지 방법만 구현해야 한다.

내 앱에는 이미 탭을 열 수 있는 네비게이터가 있으므로, 나를 위해 의도를 구현하는 것은 몇 줄의 코드에 불과하다.

내 네비게이터가 메인 스레드를 기대하기 때문에, @MainActor로 수행 방법에 주석을 달 것이다.

내 의도도 제목이 필요해.

오늘 보여줄 다른 모든 문자열과 마찬가지로, 문자열 파일에 키를 추가하면 자동으로 현지화됩니다.

이것이 내가 기본적인 앱 의도를 작동시키기 위해 해야 할 전부이다.

이제 내 코드에 정의되어 있으므로, 사용자가 단축키에 추가할 수 있는 단축키 편집기에 자동으로 나타납니다.

이 의도를 노출하는 것만으로도 엄청난 영향력을 얻을 수 있습니다. 왜냐하면 일단 고객이 이 의도를 지름길로 바꾸면, 이 모든 것을 포함하여 시스템의 수많은 장소에서 사용할 수 있기 때문입니다.

나의 새로운 의도를 쉽게 사용하고 발견할 수 있도록, 나는 또한 앱 단축키에 대한 지원을 추가할 것이다.

약간의 코드로, 나는 내 의도를 스포트라이트와 단축키 앱에 자동으로 표시할 수 있으며, 사람들이 Siri에게 이 의도를 목소리로 사용하기 위해 말할 수 있는 문구를 정의할 수 있다.

모든 세부 사항을 보려면 "앱 의도로 앱 단축키 구현" 세션을 확인하세요.

지금까지, 나는 현재 읽고 있는 선반을 열려고 하는 의도를 드러냈다.

다음으로, 선반을 열 수 있도록 매개 변수를 추가하여 일반화해 봅시다.

선반을 나타내는 열거형을 가지고 있다.

의도 매개 변수로 사용하려면 AppEnum 프로토콜을 준수해야 합니다.

AppEnum은 문자열 원시 값이 필요하므로, 먼저 추가하겠습니다.

또한 각 열거형 사례에 대해 지역화 가능하고 사람이 읽을 수 있는 제목을 제공해야 합니다.

컴파일러가 빌드 시간에 이 코드를 읽을 것이기 때문에, 이것들은 사전 리터럴로 제공되어야 한다.

마지막으로, 저는 typeDisplayName을 추가할 것입니다: 이 열거형 유형 전체에 대해 사용자가 볼 수 있고 지역화 가능한 이름입니다.

나는 "선반"을 사용할 거야.

의도에서, 각 매개 변수는 제목과 같은 매개 변수에 대한 정보로 초기화되는 @Parameter 속성 래퍼를 사용하여 선언됩니다.

여기서, 나는 내 수행 방법에서 읽은 새로운 선반 매개 변수를 정의한다.

매개 변수는 숫자, 문자열, 파일 등을 포함한 이러한 모든 유형과 앱의 엔티티 및 열거형을 지원합니다.

단축키 편집기에서 이 의도가 어떻게 보이는지는 다음과 같습니다.

선반 매개 변수는 테이블 행에 나타납니다.

ParameterSummary API를 사용하여 UI를 더 간소화하고 단축키에 더 잘 맞도록 만들 수 있습니다.

매개 변수 요약은 "열기"와 같이 편집기에서 당신의 의도와 매개 변수를 나타내는 문장입니다.

단축키에서 최상의 결과를 얻으려면, 항상 당신이 만드는 모든 의도에 대한 매개 변수 요약을 제공해야 합니다.

또한 어떤 매개 변수가 접힘 아래에 표시되고 어떤 매개 변수가 숨겨져 있는지 정의할 수 있습니다.

이 API는 언제 및 기타 API 또는 스위치, 케이스 및 기본 API를 사용하여 의도의 매개 변수의 실제 값에 따라 요약을 변경하는 것과 같은 꽤 멋진 작업을 수행할 수 있습니다.

매개 변수 요약을 추가하기 위해, 나는 이 정적 속성을 구현한다.

여기서 나는 "Open" 문자열을 반환하고 선반 매개 변수를 보간할 것이다.

오픈 쉘프를 작동시키기 위해 내가 해야 할 마지막 일은 의도가 실행될 때 라이브러리 앱을 이렇게 여는지 확인하는 것이다.

앱을 여는 것은 정적 속성인 openAppWhenRun에 의해 제어됩니다.

그것은 기본적으로 거짓이며, 이는 대부분의 의도에 좋다.

하지만 이것과 같은 UI에서 무언가를 여는 의도를 위해, 나는 그것을 true로 설정해야 할 것이다.

나는 방금 선반을 열려고 의도를 만들었다.

선반 세트가 고정되어 있기 때문에 이것은 매우 간단하다.

하지만 고정된 것이 아니라 역동적인 책을 여는 의도를 만들고 싶다면 어떨까요?

그것을 위해, 나는 실체가 필요할 것이다.

엔티티는 앱이 앱 인텐트에 노출되는 개념입니다.

노트의 메모나 사진의 사진이나 앨범과 같이 값이 동적이거나 사용자 정의할 때 열거형 대신 엔티티를 사용해야 합니다.

엔티티 인스턴스를 제공하기 위해, 앱은 쿼리를 구현하고 인텐트의 결과로 엔티티를 반환할 수 있습니다.

나는 앱에서 책을 열려고 의도하는 것으로 시작할 것이다.

단축키 편집기에서, 그것은 이렇게 보여야 한다.

사람들이 책 매개 변수를 탭하면, 내 앱이 제공한 제안된 엔티티 세트를 포함하여 책을 선택할 수 있는 선택자를 얻을 것이다.

그들은 또한 선택기 상단에 있는 이 검색 필드로 도서관에서 어떤 책이든 찾을 수 있다.

의도 자체를 구축하기 전에, 책 엔티티와 해당 쿼리를 만들어야 합니다.

엔티티는 적어도 세 가지를 포함한다: 식별자, 디스플레이 표현, 그리고 엔티티 유형 이름.

엔티티를 추가하려면, AppEntity 프로토콜에 구조체를 준수하는 것으로 시작하세요.

여기서, 나는 BookEntity의 새로운 구조를 정의할 것이지만, 내 모델에서 기존 유형을 준수할 수도 있다.

당신은 당신의 엔티티를 식별 가능한 프로토콜에 준수함으로써 식별자를 제공합니다.

앱 인텐트는 이 식별자를 사용하여 앱과 시스템의 다른 부분 간에 전달되는 엔티티를 참조합니다.

식별자는 고객이 만든 바로 가기에 저장될 수 있기 때문에 안정적이고 지속적이어야 합니다.

디스플레이 표현은 이 엔티티를 사용자에게 보여주는 데 사용됩니다.

이것은 책 제목처럼 일련의 텍스트처럼 간단할 수 있다.

자막과 이미지를 제공할 수도 있습니다.

typeDisplayName은 엔티티의 유형을 나타내는 사람이 읽을 수 있는 문자열이다.

이 예에서, 그것은 "책"이다.

이제, 책 엔티티를 마무리하기 위해, 나는 질문을 추가해야 한다.

쿼리는 시스템에 앱에서 엔티티를 검색할 수 있는 인터페이스를 제공합니다.

쿼리는 몇 가지 방법으로 엔티티를 찾을 수 있다.

모든 쿼리는 식별자를 기반으로 엔티티를 찾을 수 있어야 합니다.

문자열 쿼리 검색을 지원합니다.

그리고 나중에, 당신은 더 유연한 부동산 쿼리를 만나게 될 것입니다.

모든 쿼리는 또한 사용자가 목록에서 선택할 수 있는 제안된 엔티티를 제공할 수 있다.

모든 엔티티는 시스템이 해당 엔티티의 인스턴스를 조회할 수 있도록 쿼리와 연관되어야 합니다.

EntityQuery 프로토콜을 준수하는 Swift 구조체를 만들어 쿼리를 제공합니다.

기본 쿼리에는 식별자 배열이 주어진 엔티티를 해결하기 위해 구현하는 하나의 필수 방법만 있습니다.

나는 내 모델 데이터베이스로 가서 그 식별자와 일치하는 책을 찾아서 이것을 구현했다.

이제, 나는 그 실체에 질의를 연결해야 한다.

나는 BookEntity 유형에 defaultQuery 정적 속성을 구현하고 내 BookQuery의 인스턴스를 반환함으로써 이것을 한다.

사용자가 책을 고르면, 그 식별자는 바로 가기에 저장됩니다.

단축키가 실행되면, 앱 인텐트는 BookEntity 인스턴스를 검색하기 위해 내 쿼리에 식별자를 전달할 것이다.

이제 BookEntity 유형이 AppEntity 프로토콜을 준수하기 때문에, OpenBook 인텐트의 매개 변수로 사용할 수 있습니다.

수행 방법은 내 네비게이터를 사용하여 책으로 이동한다.

책 선택기를 지원하기 위해, 내 질문은 또한 제안된 결과를 제공해야 한다.

그렇게 하려면, 쿼리에 대한 방법을 하나 더 구현해야 하며, 라이브러리 앱에 추가된 모든 책을 반환해야 합니다.

단축키는 이러한 결과로 피커를 채울 것이다.

단축키 UI의 상단에 검색 필드가 있다는 것을 주목하세요.

내 앱에는 많은 책 엔티티가 있을 수 있으므로, 내 데이터베이스에 대해 직접 앱 프로세스에서 검색을 실행해야 합니다.

StringQuery API는 내가 그것을 할 수 있게 해준다.

StringQuery 하위 프로토콜을 채택하면 문자열이 주어진 결과를 반환하기 위해 엔티티(문자열 일치:)라고 불리는 구현할 수 있는 방법을 하나 더 제공합니다.

여기서, 나는 그것을 책의 제목에 대해 대소문자를 구분하지 않는 간단한 일치로 구현했지만, 예를 들어 저자나 시리즈 이름을 검색하는 것과 같은 더 멋진 일을 할 수 있었다.

거대한 책 목록과 더 작은 즐겨찾기 목록이 있다면, suggestedEntities에서 즐겨찾기만 반환할 수 있고, 사용자가 더 긴 목록에서 검색할 수 있도록 엔티티(스트링 문자열:)에 의존할 수 있습니다.

이제 나는 내 앱에서 책을 여는 방법을 노출했고, 그 과정에서 책 엔티티와 책 쿼리를 구축했다.

나는 같은 엔티티와 쿼리를 사용하여 더 많은 의도를 만들 수 있다.

내 다음 임무는 도서관에 책을 추가할 의도를 만드는 것이다.

고객은 공유 시트 단축키를 사용하여 온라인으로 검색하는 동안 책을 빠르게 추가하거나, HomePod의 Siri에게 화면을 보고도 책을 추가하라고 말할 수 있습니다.

UI를 보여주지 않고 모델을 직접 조작하는 이와 같은 의도를 구축하면 사용자에게 힘을 실어줄 수 있습니다.

여기 책의 제목과 저자의 선택적 이름을 매개 변수로 취하는 내 AddBook 의도의 구현이 있습니다.

그것은 또한 어떤 친구가 그 책을 추천했는지 기록하기 위한 선택적 메모를 포함한다.

수행 방법은 async/await를 사용하여 API 호출로 찾아 라이브러리에 책을 추가할 것이다.

일치하는 것을 찾을 수 없다면 오류가 발생할 것이다.

이 오류를 현지화하기 위해, 저는 오류 유형을 CustomLocalizedString ResourceConvertible 프로토콜에 따릅니다.

이 속성에서 현지화된 문자열 키를 반환하고, 문자열 파일에 키를 추가할 것입니다.

이 책 추가 의도는 Siri, 위젯 등과 함께 믿을 수 없을 정도로 유용합니다.

하지만 다른 의도와 결합될 수 있다면 훨씬 더 유연해진다.

약간의 작업으로, 나는 내 Add Book 의도를 내가 이전에 구축한 Open Book 의도와 결합하여 결과를 서로 전달하도록 허용할 수 있다.

그렇게 하기 위해, 나는 Add Book 의도가 결과의 일부로 값을 반환하도록 할 것이다.

내 수행 방법의 반환 유형이 내가 반환하는 값을 나타내는 새로운 프로토콜을 선택했다는 것을 주목하세요.

이제 사용자는 이 인텐트의 결과 값을 책 엔티티를 매개 변수로 사용하는 다른 인텐트에 연결할 수 있습니다.

책 추가 인텐트와 오픈 북 인텐트는 자연스럽게 함께 짝을 이루므로, 책을 추가한 다음 라이브러리에서 즉시 여는 단축키를 만들 수 있습니다.

의도의 결과를 반환하고 앱에서 여는 것은 일반적인 패턴이다.

앱 인텐트는 오픈인텐트라고 불리는 이것을 표현하는 방법이 내장되어 있다.

내가 openIntent를 추가하면, 고객은 "실행 시 열기"라는 단축키에서 새로운 스위치를 받게 될 것이다.

그들이 스위치를 끄면, 중단 없이 백그라운드에서 바로 가기의 일부로 이 의도를 사용할 수 있을 것이다.

그들이 스위치를 켜두면, 새로 추가된 책은 내 도서관 앱에서 즉시 열릴 것이다.

오픈 인텐트를 채택하는 것은 오픈 북 인텐트의 인스턴스를 만들고 결과의 일부로 반환하는 것만큼 쉽다.

이 인텐트가 실행될 때, Open When Run 스위치가 켜져 있으면, Add Book 인텐트가 완료된 후 Open Book 인텐트가 자동으로 수행됩니다.

엔티티와 쿼리로 할 수 있는 일이 훨씬 더 많습니다.

다음 API 세트로, AppIntents는 SiriKit Intents 프레임워크로 이전에는 없었던 강력한 능력을 열어줍니다.

당신의 단체로부터 더 많은 정보를 노출하고, 고객이 그것을 기반으로 찾고 필터링할 수 있도록 하는 방법을 살펴봅시다.

지금까지, 나는 내 책 엔티티에 모든 기본 요구 사항을 추가했다.

하지만 사람들이 책을 그들의 지름길에 더 깊이 통합하도록 하기 위해, 나는 내 책에 대해 조금 더 노출해야 할 것이다.

엔티티는 사용자에게 노출하려는 엔티티에 대한 추가 정보를 보유하고 있는 속성을 지원합니다.

이 경우, 나는 사람들이 단축키에서 그 속성을 사용할 수 있도록 책의 저자, 출판 날짜, 읽기 날짜, 그리고 누가 그것을 추천했는지를 추가할 것이다.

@Property라는 속성 래퍼를 사용하여 BookEntity에 속성을 추가합니다.

속성은 매개 변수와 동일한 모든 유형을 지원하며, 각각은 현지화된 제목을 사용합니다.

이러한 새로운 속성을 통해 고객은 이제 단축키의 마법 변수를 사용하여 책 엔티티와 작업할 때 각각의 새로운 정보를 꺼낼 수 있습니다. 이전 책 추가 인텐트를 사용할 때 단축키에서 새로 추가된 책의 저자 또는 출판 날짜를 사용할 수 있습니다.

속성과 쿼리를 결합하면, 앱은 이 유연한 조건자 편집기 UI를 통해 단축키에서 이러한 믿을 수 없을 정도로 강력한 찾기 및 필터 작업을 자동으로 가져옵니다.

이제, 내 고객들은 읽은 날짜, 제목, 저자 등을 기준으로 책을 찾고 필터링할 수 있을 것이다.

예를 들어, 델리아 오웬스의 모든 책을 찾는 것은 쉬운 일이다.

정렬 기준 및 제한 옵션을 사용하면 Delia Owens가 가장 최근에 출판한 세 권의 책을 찾는 것과 같은 훨씬 더 고급 쿼리를 지원할 수 있습니다.

고객은 이 빌딩 블록을 사용하여 컬렉션에서 가장 흔한 세 명의 작가를 찾는 것과 같은 꽤 멋진 일을 할 수 있다.

이 모든 것을 가능하게 하려면, 나는 속성 쿼리라고 불리는 또 다른 종류의 쿼리를 채택해야 할 것이다.

속성 쿼리는 문자열이나 식별자가 아니라 엔티티 내의 속성을 기반으로 엔티티를 찾습니다.

부동산 쿼리를 구현하는 데는 세 단계가 있습니다.

먼저, 속성을 사용하여 엔티티를 검색할 수 있는 방법을 지정하는 쿼리 속성을 선언합니다.

그런 다음, 쿼리 결과를 정렬하는 방법을 정의하는 정렬 옵션을 추가합니다.

그리고 마지막으로, 검색을 실행하기 위해 엔티티(매칭:)를 구현합니다.

쿼리 속성은 AppIntents가 이 쿼리와 관련된 엔티티를 검색할 수 있는 모든 방법을 선언합니다.

각각은 내 엔티티의 속성을 나열하고, 비교 연산자를 나열합니다. 예를 들어 포함, 같거나, 그보다 작습니다.

여기서, 나는 내 날짜 속성에 대해 "보다 작음"과 "보다 큰" 비교자를 나열하고, 내 소유권 속성에 대해 "함"과 "동등하다"를 나열한다.

쿼리 속성은 속성과 비교기의 각 조합을 비교기 매핑 유형이라고 하는 원하는 유형으로 매핑합니다.

여기서, 저는 CoreData를 사용하고 있으므로, NSPredicate를 사용할 것입니다.

사용자 지정 데이터베이스나 REST API를 사용하고 있다면, 나만의 비교기 유형을 설계하고 대신 사용할 수 있습니다.

여기 제 책에 대한 쿼리 속성을 설정하는 코드가 있습니다.

저는 BooksQuery를 EntityPropertyQuery 프로토콜에 준수합니다.

그런 다음 QueryProperties 결과 작성기를 사용하여 정적 var 속성을 구현합니다.

각 항목은 쿼리할 수 있는 속성의 keyPath를 지정하고, 그 안에는 해당 속성에 적용할 수 있는 각 비교기를 지정합니다.

비교기 매핑 유형으로 NSPredicate를 선택했기 때문에 각 비교기에 대해 NSPredicate를 제공합니다.

시스템이 내 앱에 쿼리 결과를 반환하도록 요청할 때, 내가 여기서 구성하고 있는 NSPredicates를 다시 제공할 것이다.

분류에 대한 비슷한 정의가 있다.

이것은 내 모델이 책을 정렬할 수 있는 모든 속성의 목록이다.

이 경우, 제목, 읽은 날짜 및 게시된 날짜별로 정렬할 수 있습니다.

마지막으로, 나는 내 데이터베이스를 쿼리하고 일치하는 엔티티를 반환하는 엔티티(매칭:)를 구현한다.

이 방법은 이전에 정의된 쿼리 매개 변수에서 사용한 비교기 매핑 유형의 배열을 취합니다. 이 경우 NSPredicate입니다.

이 술어들은 내가 쿼리하고 싶은 내 엔티티의 속성에 대한 기준을 설명하고 있다.

또한 술어와 "and" 또는 "or", 정렬할 키 경로 및 결과 수에 대한 선택적 제한을 결합할지 여부를 나타내는 모드가 필요합니다.

내 구현은 이러한 매개 변수를 사용하여 CoreData 데이터베이스에 대한 쿼리를 수행합니다.

고객들은 이 부동산 질의로 무엇을 할 수 있나요?

그들은 도서관에서 읽을 책을 무작위로 고를 수 있다.

그들은 20세기 초에 출판된 모든 책을 찾을 수 있다.

그들은 단축키 생태계를 활용하고 내 앱을 다른 사람들과 연결하여 더 유용하게 만들 수 있다.

예를 들어, 그들은 스프레드시트 앱을 사용하여 올해 읽은 모든 책을 CSV 파일로 내보낼 수 있다.

또는, 그들은 그래프 앱을 사용하여 지난 10년 동안 매년 얼마나 많은 책을 읽었는지 차트를 만들 수 있다.

그리고 그건 시작에 불과해.

이러한 종류의 깊은 앱 인텐트 채택은 고객이 앱을 사용하여 필요한 일을 할 수 있게 하여 워크플로우의 중요한 부분이 됩니다.

예를 들어, 그래프를 만드는 것과 같은 이러한 각각의 통합은 구축할 필요가 없는 기능입니다.

의도가 수행되면, 앱은 Siri 요청이든 바로 가기이든 결과를 표시하거나 말하거나 모호함을 해결하기 위해 사용자와 상호 작용해야 할 수도 있습니다.

앱 인텐트는 이러한 많은 상호 작용을 지원합니다: 인텐트가 완료되었을 때 사용자에게 텍스트 및 음성 피드백을 제공하기 위한 대화 상자와 시각적 피드백을 제공하기 위한 스니펫.

사용자에게 의도 매개 변수에 대한 값을 명확히 하고 매개 변수 값을 확인하거나 거래적이거나 파괴적인 의도에 대해 사용자와 확인하기 위한 확인을 요청하기 위한 값과 명확성을 요청하십시오.

대화는 의도를 실행하는 사람에게 음성 또는 텍스트 응답을 제공한다.

음성 경험에서 의도가 잘 작동하도록 대화를 제공하는 것은 정말 중요하다.

이전 책 추가 인텐트에서, 책 제목과 수행 방법에서 반환된 결과 대화상자를 요청할 때 말하는 needsValueDialog를 추가할 것입니다.

이것들은 우리의 많은 플랫폼에서 단축키나 Siri에 의해 읽히거나 표시될 것이다.

당신은 스니펫을 대화의 시각적으로 동등한 것으로 생각할 수 있으며, 의도의 결과에 시각적 표현을 추가할 수 있습니다.

스니펫을 사용하려면, 의도 결과에 후행 클로저로 선택한 SwiftUI 보기를 추가하기만 하면 됩니다.

위젯과 마찬가지로, SwiftUI 보기는 보관되어 단축키 또는 Siri로 전송됩니다.

앱 인텐트는 또한 requestValue를 던져 사용자에게 값을 요청하는 것을 지원합니다.

예를 들어, 이것은 때때로 선택 사항인 매개 변수에 대한 값이 필요할 때 유용합니다.

여기서, requestValue는 문자열 검색이 하나 이상의 책을 반환할 때 도움이 됩니다.

이 경우, 나는 저자에게 책 검색 범위를 좁혀달라고 요청한다.

requestValue는 내가 던질 수 있는 오류를 제공하여 사용자에게 메시지를 표시하고 업데이트된 저자 이름으로 작업을 다시 실행합니다.

한편, 명확성은 사용자가 매개 변수에 대한 값 세트 중에서 선택해야 할 때 좋습니다.

이것은 내 책 추가 작업에서 여러 가지 가능한 결과를 처리할 수 있는 더 나은 방법을 제공한다.

여기서, 나는 생성된 책에서 저자 이름 목록을 얻고, 그 가능한 값에 대한 명확성을 요청한다.

사용자는 그들 중 하나를 선택하라는 요청을 받을 것이고, 나는 결과를 돌려받을 것이다.

마지막으로, 앱 인텐트는 두 가지 종류의 확인을 지원합니다.

첫 번째 종류는 매개 변수 값을 확인하는 것이다.

그 가치가 무엇인지 추측할 수 있지만 확실히 하기 위해 확인하고 싶을 때 이것을 사용할 수 있습니다.

책을 추가할 때, 때때로 내가 제목으로 책을 찾기 위해 부르는 웹 서비스는 몇 개의 일치를 반환하지만, 그 중 하나는 훨씬 더 인기가 있다.

이러한 경우, 나는 사용자가 그 인기 있는 책을 추가하려고 했다고 가정할 것이지만, 내가 제대로 이해했는지 확인하기 위해 확인을 추가할 것이다.

그렇게 하기 위해, 나는 제목 매개 변수에 대해 requestConfirmation에 전화할 것이다.

두 번째 종류는 의도의 결과에 대한 확인이다.

예를 들어, 이것은 주문하는 데 좋습니다.

도서관 앱에서 수익을 창출하고 서점을 통해 주문을 추가하고 싶다면, 주문이 올바른지 확인하고 싶습니다.

이것을 하기 위해, 나는 배치 순서를 전달하면서 내 의도에 대한 requestConfirmation을 요청할 수 있다.

주문의 미리보기를 보여주는 스니펫도 여기에 지정하겠습니다.

사용자가 확인하는 대신 취소하면 requestConfirmation에 오류가 발생하기 때문에 호출에 "try"라는 접두사가 붙습니다.

제가 당신을 떠나기 전에, 제가 다루고 싶은 앱 인텐트 아키텍처의 몇 가지 측면이 있는데, 프레임워크를 채택할 때 알아야 합니다.

실제로 앱 인텐트를 구축하는 두 가지 방법이 있습니다: 앱 내에서 또는 별도의 확장 프로그램.

이 중, 앱에서 직접 의도를 구현하는 것이 가장 간단합니다.

이것은 프레임워크가 필요하거나 코드를 복제할 필요가 없고, 프로세스 전반에 걸쳐 조정할 필요가 없기 때문에 좋습니다.

앱을 사용하면 더 높은 메모리 제한을 제공하며, 오디오 재생과 같은 확장에서 더 어려운 몇 가지 종류의 작업을 할 수 있는 기능을 제공합니다.

True를 반환하려는 의도로 openAppWhenRun을 구현하면 앱을 포그라운드에서 실행할 수 있습니다.

그렇지 않으면, 백그라운드에서 실행될 것이다.

백그라운드에서 실행할 때, 앱은 성능을 극대화하기 위해 장면을 가져오지 않고 특별한 모드로 실행됩니다.

사실, 앱에서 백그라운드 앱 인텐트를 구현하는 경우, 장면 지원도 구현하는 것이 좋습니다.

또는, 확장 프로그램에서 앱 인텐트를 구축할 수 있습니다.

여기에는 몇 가지 장점이 있다.

확장 프로세스는 앱 의도만 처리하고 앱을 회전할 필요가 없기 때문에 더 가볍습니다.

포커스 인텐트를 처리하는 경우, 확장 프로그램을 사용하면 앱이 포그라운드에서 먼저 실행될 필요 없이 포커스가 변경될 때 확장 프로그램에서 인텐트가 즉시 수행된다는 것을 의미합니다.

확장은 새로운 대상을 추가하고, 일부 코드를 프레임워크로 옮기고, 앱과 확장 프로그램 간의 조정을 처리해야 하기 때문에 조금 더 많은 작업입니다.

앱 인텐츠 확장자를 만들려면, Xcode에서 파일 > 새 타겟으로 이동하여 앱 인텐츠 확장을 선택하세요.

앱 인텐트와 함께, 당신의 코드는 진실의 유일한 원천입니다.

앱 인텐트는 빌드 시 인텐트, 엔티티, 쿼리 및 매개 변수에 대한 정보를 정적으로 추출하여 우아한 개발자 경험을 제공합니다.

Xcode는 빌드 프로세스 중에 앱 또는 확장 번들 내부에 메타데이터 파일을 생성하며, 코드에서 실행될 때 스위프트 컴파일러에서 받은 정보를 포함합니다.

이 모든 것이 작동하는지 확인하려면, 앱 인텐트 유형을 프레임워크가 아닌 대상이나 확장에 직접 보관하십시오.

마찬가지로, 현지화된 문자열은 앱 인텐트 유형이 있는 동일한 번들 내의 문자열 파일에서 찾아야 합니다.

업그레이드하고 싶은 SiriKit Intents가 있는 기존 앱이 있는 사람들을 위해, 위젯이나 메시징이나 미디어와 같은 도메인과 통합하기 위해 의도를 채택한다면, SiriKit Intents 프레임워크를 계속 사용해야 합니다.

하지만 Siri와 단축키에 대한 사용자 지정 인텐트를 추가한다면, 앱 인텐츠로 업그레이드해야 합니다.

SiriKit Intents 정의 파일에서 Convert to App Intent 버튼을 클릭하여 업그레이드 프로세스를 시작할 수 있습니다.

앱 인텐트와 함께 앱을 바로 가기에 통합하는 것은 개발자로서의 레버리지를 극대화할 수 있는 좋은 방법입니다. 왜냐하면 앱 인텐트를 채택하기 위해 소량의 작업을 수행하면 고객에게 많은 가치를 창출할 수 있기 때문입니다.

참여해줘서 고마워!

오늘 앱 인텐트를 사용해보고 피드백을 주셨으면 합니다.

이 새로운 프레임워크가 당신의 앱을 사용하는 사람들을 놀라게 하고, 기쁘게 하고, 권한을 부여하는 데 어떻게 도움이 될 수 있는지에 대해 흥분됩니다!

행복한 독서와 당신의 WWDC가 서사시적이길 바랍니다!

♪