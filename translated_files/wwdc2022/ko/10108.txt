10108

♪ ♪

펠릭스 아세로: 안녕하세요, 제 이름은 펠릭스 아세로이고, 저는 보안 엔지니어링 및 아키텍처 팀의 소프트웨어 엔지니어입니다.

이 비디오에서는 LocalAuthentication 프레임워크를 사용하여 앱의 인증 및 인증 흐름을 개선하는 방법을 보여드리겠습니다.

우리는 인증과 권한의 일반적인 개념과 그것이 당신의 신청서에 어떻게 적용되는지 살펴보는 것으로 시작할 것입니다.

그런 다음 기존 LocalAuthentication API, 특히 LAContext가 광범위한 인증 체계를 구현하는 데 어떻게 도움이 될 수 있는지 검토할 것입니다.

그리고 마지막으로 우리는 올해 LocalAuthentication에 추가하는 새로운 API가 인증 코드를 더욱 간소화하는 데 어떻게 도움이 될 수 있는지 볼 것입니다.

그래서 인증과 권한 부여에 대해 이야기하는 것으로 시작합시다.

인증과 권한 부여는 뚜렷하지만 밀접하게 관련된 보안 개념이다.

한편으로, 인증은 사용자의 신원을 확인하는 행위이다.

반면에, 권한 부여는 주어진 사용자가 구체적인 자원에 대한 특정 작업을 수행할 수 있는지 여부를 확인하는 행위이다.

종합하면, 우리가 어떤 자원과 작업을 사용할 수 있는지 평가하기 전에 먼저 사용자가 그들이 주장하는 사람인지 확인해야 하기 때문에, 우리는 인증이 실제로 권한을 가능하게 한다고 말할 수 있다는 것을 알 수 있다.

이러한 개념을 설명하기 위해, Secure Enclave 키와 같은 애플리케이션에서 관리하는 일반적인 보안 리소스와 관련된 구체적인 예를 살펴보겠습니다.

보안 엔클레이브 키는 특정 장치에 바인딩되고 메인 프로세서와 분리된 하드웨어 기반 키 관리자에 의해 보호되는 특별한 유형의 비대칭 키입니다.

이 키를 특별하게 만드는 것은 Secure Enclave에 개인 키를 저장할 때 실제로 키를 처리하지 않고 대신 Secure Enclave에 작업을 수행하도록 지시한다는 것입니다.

보안 엔클레이브 키는 액세스 제어 목록 또는 ACL과 간단히 연관될 수 있습니다.

액세스 제어 목록은 BLOB 서명 또는 암호 해독과 같은 특정 작업을 수행하기 위해 충족해야 하는 요구 사항을 지정합니다.

그들은 예를 들어 장치 잠금 해제 후 주어진 항목을 사용할 수 있는 시기와 특정 작업의 실행을 허용하는 데 필요한 인증 요구 사항을 지정할 수 있습니다.

이 예에서, 앱이 생체 인식 인증으로 키의 서명 및 해독 작업을 보호하고 장치가 잠금 해제된 후에만 키를 사용할 수 있도록 하기를 원한다고 가정해 봅시다.

이제 이 키와 관련된 서명 작업에 대한 승인 흐름이 어떻게 생겼는지 봅시다.

먼저, 당신의 애플리케이션은 개인 키를 사용하여 BLOB에 서명하도록 요청합니다.

그런 다음, 애플리케이션이 키에 액세스할 수 있는지 확인한 후, 시스템은 서명 작업에 대한 인증 요구 사항을 식별하기 위해 진행합니다.

이 경우, 서명 작업은 현재 등록된 사용자로부터 성공적인 생체 인증이 필요합니다.

그런 다음 시스템은 표준 UI를 통해 생체 인증 프로세스를 통해 사용자를 안내할 것이다.

인증이 성공하면, 시스템은 마침내 서명 작업을 수행하고 서명된 BLOB을 앱에 반환하기 전에 나머지 모든 인증 요구 사항이 충족되었는지 확인합니다.

이 흐름과 관련된 주요 구성 요소를 분해하여 초기 정의에 어떻게 맞는지 봅시다.

먼저, 우리는 자원이 있다: 보안 엔클레이브 키.

둘째, 우리는 열쇠로 수행할 수 있는 작업이 있다.

그리고 셋째, 우리는 무엇보다도 누가 작업을 수행할 수 있는지와 신원을 확인하는 데 사용해야 하는 인증 수단을 명시하는 일련의 요구 사항을 가지고 있습니다.

이 예제의 매개 변수를 우리의 정의에 연결하면, 우리는 인증을 위해 이것이 올바른 사용자인지 여부에 대한 질문이 생체 인증을 통해 답변된다는 것을 알 수 있습니다. 인증의 경우, 사용자가 개인 키를 사용하여 서명 작업을 수행할 수 있는지에 대한 질문은 액세스 제어 목록에 지정된 요구 사항을 확인함으로써 답변됩니다.

이제 이것이 높은 수준에서 어떻게 작동하는지 보았으므로, LocalAuthentication의 현재 API를 사용하여 이와 같은 흐름을 구현할 수 있는 방법을 살펴볼 수 있습니다.

프레임워크의 핵심 구성 요소 중 하나인 LAContext가 제공하는 기능을 빠르게 검토하는 것으로 시작합시다.

LAContext는 사용자의 신원을 평가하는 데 사용될 수 있다.

생체 인식 또는 암호 인증이 필요할 때 사용자 상호 작용을 처리합니다.

또한 생체 인식 데이터의 안전한 관리를 가능하게 하기 위해 Secure Enclave와 인터페이스합니다.

이러한 관점에서, LAContext는 인증 사용 사례를 지원하는 데 사용될 수 있습니다.

LAContext는 또한 인증 흐름을 지원하기 위해 다른 프레임워크와 관련하여 사용될 수 있다.

예를 들어, 이전 예에서 본 것과 같은 액세스 제어 목록을 평가하는 데 사용할 수 있습니다.

좀 더 자세히 살펴보자.

우리가 해야 할 첫 번째 일은 개인 키와 관련된 ACL에 접근하는 것이다.

우리는 보안 프레임워크에서 제공하는 SecItemCopyMatching API의 도움으로 이것을 할 수 있으며, 쿼리 내부에 반환 속성 키를 제공해야 합니다.

액세스 제어 목록에 액세스하면 LAContext와 evaluateAccessControl API를 사용하여 직접 평가할 수 있습니다.

이 접근 방식이 제공하는 가장 큰 장점은 사용자에게 이 승인을 요청하기 위해 애플리케이션에서 적절한 순간과 적절한 장소를 결정할 수 있다는 것입니다.

이 경우, 액세스 제어 목록에는 서명 작업에 생체 인증이 필요하기 때문에, LAContext는 친숙한 Face ID 또는 Touch ID UI를 제공합니다.

ACL이 LAContext 내에서 승인되면, 키에 대한 참조를 얻기 위한 쿼리의 일부로 사용할 수 있습니다.

우리는 use-authentication-context 키 아래의 SecItem 쿼리에 LAContext를 추가하여 이를 수행한다.

LAContext를 개인 키 참조에 바인딩함으로써, 우리는 서명 작업을 실행하는 것이 다른 인증을 트리거하지 않도록 보장하며, 불필요한 프롬프트 없이 작업을 계속할 수 있도록 합니다.

이러한 바인딩은 또한 LAContext가 무효화될 때까지 향후 서명에 추가 사용자 상호 작용이 필요하지 않다는 것을 의미합니다.

LAContext는 많은 유연성을 제공하며 인증 흐름과 관련된 각 단계와 매개 변수를 제어할 수 있습니다.

보안 프레임워크와 같은 다른 프레임워크와 함께 사용할 수 있으며, 이는 다양한 사용 사례를 잠금 해제합니다.

그러나 이러한 다양성은 더 높은 코드 복잡성의 비용으로 인해 여러 프레임워크에서 제공하는 API를 신중하게 조정해야 합니다.

사용 사례에 따라, LAContext는 특히 앱의 주요 가치 제안이 키, 비밀, 컨텍스트 및 액세스 제어 목록에 대한 낮은 수준의 액세스를 요구하는 경우 적합한 도구가 될 수 있습니다.

그러나, 앱에 필요한 모든 것이 콘텐츠나 민감한 리소스에 대한 액세스를 승인하는 방법이라면, 이러한 유연성 중 일부를 더 간단한 API로 교환하고 싶을 수도 있습니다.

이것은 우리를 당신의 앱을 간소화하는 마지막 주제로 데려옵니다.

iOS 16과 macOS 13의 새로운 기능인 LocalAuthentication은 더 높은 수준의 인증에 중점을 둔 API를 도입하고 있습니다.

새로운 API는 LAContext와 같은 LocalAuthentication의 기존 개념을 기반으로 하며 공통 인증 흐름의 구현을 단순화하여 앱의 핵심 가치 제안에 모든 에너지를 집중할 수 있도록 합니다.

새로운 API에 의해 도입된 가장 중요한 추상화는 LARight이다.

LARight에 제공할 수 있는 가장 간단한 사용 사례는 애플리케이션 정의 리소스에 대한 작업을 승인하는 데 도움을 주는 것입니다.

예를 들어, 먼저 사용자의 성공적인 생체 인증을 요구함으로써 애플리케이션의 사용자 프로필 섹션에 대한 게이트 액세스를 도울 수 있는 권리를 사용할 수 있습니다.

기본적으로 권한은 사용자가 사용 중인 장치에 따라 Touch ID, Face ID, Apple Watch 또는 장치 암호를 사용하여 인증할 수 있는 일련의 인증 요구 사항에 의해 보호됩니다.

또한 귀하의 권리를 보다 세분화된 요구 사항과 연관시키도록 선택할 수 있으며, 이를 통해 인증 수단을 더욱 제한할 수 있습니다.

코드에서 LARights를 어떻게 사용할 수 있는지 살펴봅시다.

우리가 해야 할 첫 번째 일은 우리의 권리를 인스턴스화하는 것이다.

우리는 요구 사항을 명시함으로써 이것을 한다.

이 경우, 우리의 로그인 권리는 사용자가 생체 측정법을 사용하여 인증하거나 장치 암호를 제공해야 합니다.

그런 다음 현재 사용자가 로그인 권한을 얻을 수 있는지 확인합니다.

우리는 이 정보를 사용하여 로그인 작업을 계속할 수 있는지 또는 대신 사용자를 앱의 공개 섹션으로 리디렉션해야 하는지 결정합니다.

마지막으로, 우리는 인증 UI에서 사용자가 볼 수 있는 현지화된 이유를 제공하는 실제 인증 작업을 진행할 수 있습니다.

이런 식으로 권리를 승인할 때, 새로운 시스템 기반 UI가 제공됩니다.

UI는 애플리케이션 창 내에서 렌더링되며 사용자에게 작업의 기원과 목적을 이해하는 데 도움이 되는 관련 정보를 제공합니다.

우리는 새로운 모습을 통해 애플리케이션과 더 원활하게 통합되고 사용자에게 더 많은 맥락과 정보를 제공하는 인증 흐름을 만들 수 있다고 믿습니다.

이제 권리를 만들고 승인하는 방법을 보았으니, 수명 주기를 자세히 살펴봅시다.

권리는 알려지지 않은 상태에서 그들의 생애주기를 시작한다.

당신의 신청서가 승인 요청을 발행하자마자, 권리 상태는 승인으로 바뀝니다.

이 시점에서 사용자에게 이전 슬라이드에서 본 인증 UI가 표시됩니다.

작업의 성공 또는 실패에 따라, 권리는 승인되거나 승인되지 않은 상태로 전환될 수 있다.

이것은 당신의 지원서에서 가장 중요한 상태 전환입니다.

마지막으로, 권리는 또한 승인된 상태에서 승인되지 않은 상태로 이동할 수 있다.

이것은 애플리케이션이 오른쪽에 승인 해제 요청을 명시적으로 발행하거나 올바른 인스턴스가 할당 해제될 때 발생합니다.

승인된 상태를 보존하기 위해 당신의 권리에 대한 강력한 참조를 유지해야 합니다.

권리가 승인되지 않은 후, 당신의 신청서는 주기를 다시 시작하기 위한 승인 요청을 계속 발행할 수 있습니다.

이전의 모든 상태 전환을 조회하고 관찰할 수 있다.

LARight 인스턴스에 접근할 수 있다면, 주 속성을 직접 쿼리할 수 있습니다.

또한 KVO 또는 Combine을 사용하여 모든 상태 전환을 관찰할 수 있습니다.

또한, 애플리케이션이 여러 권한을 처리하는 경우, 인증 상태의 변경이 감지된 후 기본 NotificationCenter에 게시되는 didBecomeAuthorized 및 didBecomeUnauthorized 알림을 듣고 한 곳에서 모든 상태를 관찰할 수 있습니다.

계속 진행하기 전에, 예시로 돌아가서 로그인 권한을 해제하기 위해 로그아웃 작업을 추가해 봅시다.

이렇게 함으로써, 우리는 다음에 사용자가 로그인할 때 새로운 인증이 필요하다는 것을 보장합니다.

지금까지, 우리는 애플리케이션 정의 리소스에 대한 작업을 승인하기 위해 올바른 인스턴스를 사용하는 방법을 보았습니다.

우리는 또한 이러한 권한의 수명 주기와 상태가 궁극적으로 런타임과 어떻게 연결되어 있는지 보았습니다. 즉, 애플리케이션의 모든 세션에서 이러한 권한을 올바르게 인스턴스화하고 구성해야 합니다.

그래서 권리가 어떻게 지속될 수 있는지, 그리고 이것이 당신의 앱에 어떤 종류의 가능성을 가능하게 하는지 살펴봅시다.

LARights는 올바른 상점의 도움으로 지속될 수 있다.

지속되면, 권한은 권리의 인증 요구 사항과 일치하는 액세스 제어 목록 또는 ACL로 보호되는 고유한 Secure Enclave 키에 의해 지원됩니다.

이 접근 방식은 권리가 지속된 후에도 승인 요건이 불변으로 유지되도록 하는 데 도움이 된다.

또한 권리를 뒷받침하는 개인 키에 액세스하여 암호 해독, 서명 및 키 교환과 같은 보호된 암호화 작업을 수행하는 데 사용할 수 있습니다.

해당 공개 키도 액세스할 수 있으며 암호화 및 서명 확인과 같은 작업을 수행하는 데 사용할 수 있습니다.

이것은 공개 키이기 때문에, 당신은 또한 그것과 관련된 바이트를 내보낼 수 있습니다.

개인 키 작업은 권리가 성공적으로 승인된 후에만 허용됩니다.

대조적으로, 공개 키 작업은 항상 허용됩니다.

당신의 권리를 지속할 때, 당신은 또한 그것과 함께 하나의 불변의 비밀을 저장할 기회가 있습니다.

비밀은 또한 귀하의 권리의 승인 요구 사항과 일치하는 액세스 제어 목록과 관련이 있으며 권리가 승인된 후에만 접근할 수 있습니다.

요약하자면, LAPersistedRights는 올바른 상점의 도움으로 만들어졌다.

그것들은 한 번만 구성되며 인증 요구 사항은 변경할 수 없습니다.

그것들은 저장되어 있기 때문에, 애플리케이션의 다른 세션에서 사용할 수 있습니다.

내부적으로, 그들은 특정 장치에 바인딩되며 권리의 인증 상태에 따라 다양한 암호화 작업을 수행하는 데 사용할 수 있는 고유한 Secure Enclave 키에 의해 뒷받침됩니다.

마지막으로, 그들은 권리가 승인된 후에만 사용할 수 있는 불변의 단일 비밀을 보호하는 데 사용될 수 있다.

이제 우리는 지속된 권리에 의해 제공되는 기능 중 일부를 이해했으므로, 우리가 서명 작업을 승인하고 싶었던 프레젠테이션 초반에 논의한 시나리오를 구현하는 데 어떻게 도움이 될 수 있는지 봅시다.

우리는 승인 요구 사항을 명시하는 정기적인 권리를 인스턴스화하는 것으로 시작합니다.

이 경우, 우리는 권리를 창출하는 순간에 장치에 생체 인식 등록이 있는 사용자에게만 권리가 부여되도록 하고 싶습니다.

그러므로, 우리는 biometryCurrentSet 요구 사항을 사용합니다.

그런 다음 우리는 올바른 상점의 도움으로 권리를 유지할 수 있으며, 고유 식별자를 제공할 수 있습니다.

이 식별자는 다음에 애플리케이션의 향후 세션에서 권리를 가져와야 할 때 유용할 것입니다.

권리가 지속되면, 우리는 공개 키에 즉시 접근할 수 있으며 명시적인 승인 없이 보호되지 않은 작업을 수행할 수 있습니다.

이 예에서, 우리는 단순히 공용 바이트를 수출하고 있다.

나중에, 서명 작업을 수행할 때가 되면, 생성 중에 제공한 고유 식별자를 사용하여 상점에서 권리를 검색할 수 있습니다.

그런 다음 우리는 우리의 오른쪽에 있는 승인 작업을 통해 현재 사용자를 승인할 수 있습니다.

이 시점에서, 시스템은 사용자에게 인증 과정을 안내하고 모든 인증 요구 사항이 충족되었는지 확인할 것이다.

권리가 승인된 후, 우리는 개인 키를 사용하여 보호된 암호화 작업을 수행할 수 있습니다.

이 경우, 우리는 애플리케이션의 백엔드 서버에서 발행한 챌린지에 서명하기 위해 개인 키를 사용하고 있습니다.

요약하자면, 우리는 인증과 권한의 일반적인 개념 사이에 존재하는 관계, 특히 인증이 어떻게 권한을 가능하게 하는지에 대해 이야기했다.

우리는 LAContext가 제공하는 기능 중 일부와 보안과 같은 프레임워크와 결합하여 매우 강력하고 확장 가능한 인증 흐름을 잠금 해제하는 방법을 검토했습니다.

그리고 마지막으로, 우리는 새로 추가된 LARight가 특정 인증 사용 사례를 구현하기 위해 코드를 간소화하는 데 어떻게 도움이 될 수 있는지 조사했습니다.

앱에서 LocalAuthentication의 기존 사용을 살펴보고 오늘 논의한 기능 중 일부가 사용자의 개인 정보 보호와 보안을 보호하면서 코드를 단순화하는 데 도움이 될 수 있는지 고려하십시오.

고마워.