10098

♪ ♪

브래디 아이드슨: 안녕하세요. 제 이름은 브래디 아이드슨입니다.

저는 WebKit 아키텍처 팀의 엔지니어입니다.

사파리에서 웹 푸시를 소개하게 되어 기쁩니다.

웹 푸시를 사용하면 웹 애플리케이션 사용자에게 원격으로 알림을 보낼 수 있습니다.

여기, 화면 오른쪽 상단에 webkit.org의 알림이 표시됩니다.

알림을 클릭하면 새 창에서 WebKit 블로그 게시물이 열립니다.

이것이 어떻게 작동하는지에 대한 다른 세부 사항에 들어가기 전에, 저는 여러분 중 많은 사람들이 가질 것이라는 것을 알고 있는 몇 가지 질문에 미리 대답하고 싶습니다.

웹 푸시는 macOS Ventura부터 Mac Safari에서 지원됩니다.

그리고 웹 푸시는 내년에 iOS와 iPadOS에 출시될 것이다.

애플의 사파리 푸시 알림은 꽤 오랫동안 맥 사파리 사용자에게 다가가기 위한 옵션이었다.

계속 작동할 것이지만, 오늘 저는 우리가 웹 푸시에 대한 지원을 추가했다고 발표하게 되어 기쁩니다. 그리고 이것은 정말 웹 푸시입니다!

다른 브라우저에서 구현된 것과 동일한 다양한 웹 표준의 조합.

우리는 나중에 그 표준을 더 검토할 것이지만... 가장 중요한 요점은 응용 프로그램을 웹 표준으로 코딩했다면 사파리에서 작동하기 위해 변경할 필요가 없다는 것입니다.

물론, 브라우저 감지를 통해 사파리를 제외한다면, 앞으로 해야 할 일이 있습니다.

지금은 항상 모범 사례였던 브라우저 감지에서 기능 감지로 전환하기에 좋은 시간이 될 것이다.

우리는 모든 Mac과 iOS 장치에서 기본 푸시를 지원하는 동일한 Apple 푸시 알림 서비스를 사용하고 있지만, Safari 사용자에게 도달하기 위해 Apple Developer 계정이 필요하지 않습니다.

우리는 웹 푸시를 위한 새로운 엔드포인트 URL을 사용하고 있으며, 이는 의도치 않게 사파리를 제외하기 위해 당신이 할 수 있는 또 다른 일을 불러옵니다.

서버에서 푸시 엔드포인트를 긴밀하게 관리하는 경우, push.apple.com의 하위 도메인에서 URL을 허용해야 합니다.

그 중요한 질문에 대한 답을 넘어, 더 자세히 알아봅시다.

먼저, 우리는 사용자의 관점에서 사파리의 웹 푸시 경험을 살펴볼 것입니다.

그런 다음 우리는 허가를 요청하는 것부터 알림 센터의 항목 클릭을 처리하는 것까지 전체 웹 푸시 흐름을 다룰 것입니다.

마지막으로, 우리는 기존 웹 앱에 웹 푸시를 추가하는 데 무엇이 필요한지 볼 것입니다.

하지만 먼저, 맥 사파리 사용자 경험.

그리고 나는 데모로 그것을 다루는 것보다 더 좋은 방법을 생각할 수 없다.

여기 macOS Ventura의 Safari가 있습니다.

이 브라우저 탭에 webkit.org가 열려 있습니다.

나는 WebKit 오픈 소스 프로젝트를 최신 상태로 유지해야 하며, 웹 푸시는 그것을 할 수 있는 좋은 방법이다.

Webkit.org는 사용자가 사용자 제스처로 요청하지 않고 푸시할 수 있는 권한을 요청할 수 없습니다.

그래서 나는 알림을 구독하기 위해 이 종 모양의 버튼을 클릭할 것이다.

여기서 볼 수 있는 것은 시스템 알림 프롬프트입니다. 다른 응용 프로그램에서 볼 수 있는 것과 동일합니다.

이 경우, 그것은 webkit.org를 대신하는 것이다.

나는 "허용"을 클릭할 거야, 그리고 난 다 준비됐어.

Webkit.org는 새로운 블로그 게시물과 소스 코드 저장소에 대한 새로운 커밋에 대한 알림을 받을 수 있는 옵션을 제공합니다.

나는 모든 커밋에 대한 통지를 받는 것이 중요한 일에서 나를 산만하게 할 것이라는 것을 알고 있지만, 나는 새로운 블로그 게시물에 대해 알림을 받고 싶다.

그래서 내가 지금 그 상자를 체크할게.

공교롭게도, 누군가는 방금 웹 푸시에 대한 WebKit 블로그 게시물을 게시했을 것이다.

이 알림은 다른 것과 똑같이 보이며 webkit.org에 기인합니다.

활성화하려면 클릭할 수 있으며, 사파리에서 열리는 블로그 게시물이 있습니다.

사용자가 웹사이트에 권한을 부여하면, 그들은 그 권한에 대한 통제권을 유지한다.

macOS 사용자로서, 저는 시스템 설정 내에서 알림 기본 설정을 관리하는 데 익숙하며, webkit.org의 알림을 구성할 수 있는 곳입니다.

다른 앱이나 서비스에 대해 찾을 수 있는 것과 동일한 풍부한 구성.

사파리 사용자로서, 저는 사파리 환경 설정에서 웹사이트 설정을 관리하는 데 익숙합니다.

나는 또한 webkit.org의 권한을 켜거나 끄기 위해 거기에 갈 수 있다.

그리고 그것이 웹 푸시가 맥 사파리의 사용자를 위해 작동하는 방식이다.

우리가 넘어가기 전에, 나는 그 데모에서 다룬 몇 가지를 반복하고 싶다.

첫째, 우리는 사용자가 요청하지 않은 구독 요청에 의해 스팸을 받는 것을 원하지 않습니다.

따라서 웹사이트는 마우스 클릭이나 키 입력에 대한 응답으로 푸시 구독을 요청할 수 있습니다.

웹사이트가 사용자에게 알림을 표시할 수 있는 권한이 있으면, 사용자는 그 권한을 제어합니다.

그들은 사파리의 환경 설정이나 시스템 설정에서 그것을 관리하도록 선택할 수 있다.

그리고 만약 그들이 둘 다 관리한다면 그 설정은 동기화된 상태로 유지될 것이다.

마지막으로, 다양한 유형의 이벤트에 대한 알림을 제공하는 경우, 다른 앱과 마찬가지로 웹 앱 내의 알림 유형에 대한 세밀한 컨트롤을 제공하는 것이 가장 좋습니다.

이제 웹 푸시가 작동하는 것을 보았으니, 각 단계에서 무슨 일이 일어나고 있는지 살펴봅시다.

여러분 중 몇몇은 이미 이것에 익숙합니다.

하지만 웹 푸시를 처음 접하는 분들을 위해, 저는 단계별로 진행하여 관련 표준과 문서를 참조하겠습니다.

가장 먼저 일어나는 일은 사용자가 브라우저 탭에서 당신의 웹사이트를 방문하는 것입니다.

여기 사파리에서 열린 webkit.org가 있습니다.

탭에서 열려 있기 때문에, 서비스 워커를 설치할 수 있습니다.

서비스 워커는 현재 열려 있는 브라우저 탭과 별도로 전체 도메인을 대신하여 작동하는 자바스크립트의 단위이다.

서비스 워커 스크립트가 설치되면, 웹 앱은 푸시 구독을 요청할 수 있습니다.

이미 언급했듯이, 이 요청은 사용자 제스처와 연결되어야 합니다.

Webkit.org는 사용자 제스처 요구 사항을 충족하는 이 종 모양의 버튼을 클릭할 때 권한을 요청합니다.

사이트에서 푸시 구독을 요청하면, 사용자는 이 시스템 프롬프트를 볼 수 있습니다.

여기가 그들이 당신의 웹사이트에 이 강력한 능력을 부여하는 것에 대한 최종 결정을 내릴 수 있는 곳입니다.

사용자가 요청을 거부할 수도 있다.

당신의 자바스크립트는 그것을 처리할 준비가 되어 있어야 합니다.

하지만 사용자가 권한을 부여한다고 가정하면, 자바스크립트는 PushSubscription 객체를 다시 가져옵니다.

여기에는 서버가 이 브라우저에서 이 사용자에게 푸시 메시지를 보내는 데 필요한 모든 것이 포함됩니다.

사용할 정확한 URL 끝점과 같은 정보.

웹 앱에 가장 적합한 방식으로 이 PushSubscription 페이로드를 서버로 다시 보냅니다.

많은 인기 있는 서버 패키지에는 구독을 관리하기 위한 웹 푸시 지원이 있거나, 직접 롤할 수 있습니다.

서버가 알고 있는 URL 엔드포인트에 푸시 메시지를 실제로 보내는 방법과 시기와 관련이 있습니다.

나는 너에게 언제 그렇게 해야 하는지 말할 수 없어. 그건 너와 네 웹사이트에 달렸어.

하지만 일단 당신이 그 푸시 메시지를 보내기로 결정하면, 저는 다음에 일어나는 일을 도울 수 있습니다.

푸시에 설치된 서비스 작업자가 얼마나 필요한지 기억하세요?

서버가 푸시 메시지를 보내고 사파리가 수신하면, 사파리는 서비스 워커를 깨우고 자바스크립트 푸시 이벤트를 보냅니다.

알림 센터에서 사용자에게 알림을 표시하는 것은 푸시 이벤트를 처리하는 동안 요구 사항입니다.

웹사이트가 현재 브라우저 탭에서 열려 있는 경우 푸시 이벤트를 수신하고 알림을 표시합니다.

또한 당신의 웹사이트가 현재 브라우저 탭에서 열려 있지 않은 경우에도 발생합니다.

macOS Ventura의 Safari의 경우, Safari가 현재 실행되고 있지 않더라도 발생합니다.

마지막 단계: 사용자가 해당 알림을 클릭하면, 알림 클릭 이벤트가 서비스 워커에게 전송되어 적절하게 응답할 수 있습니다.

예를 들어, 해당 알림과 관련된 URL에 대한 새 창을 열면.

웹 푸시 흐름에 대한 이해와 함께, 실제로 기존 웹 앱에 웹 푸시 지원을 추가하여 더 자세히 설명할 때입니다.

Webkit.org 외에도, 브라우저 펫은 사파리와 웹킷 팀을 위한 가장 중요한 내부 도구입니다.

부서의 모든 사람들이 Safari에서 가장 좋아하는 WebKittens와 Pups를 최신 상태로 유지하는 것은 항상 Browser Pets의 사명 선언문이었고, Web Push는 그 어느 때보다 쉽게 만들었습니다.

내부 BrowserPets 도메인에는 이미 페이지 로드 속도를 높이고 여러 탭 간에 동기화하기 위해 ServiceWorker 스크립트가 등록되어 있습니다.

높은 수준에서, ServiceWorker 스크립트는 이것과 많이 닮았다.

엔지니어가 탭의 브라우저 펫 페이지를 방문하면, 이 자바스크립트 발췌문은 서비스 워커 스크립트가 이미 등록되었는지 확인하거나 필요한 경우 등록합니다.

우리는 이전에 모범 사례로 언급된 기능 감지를 연습하고 있습니다.

서비스 워커 전제 조건을 처리하면서, 우리는 푸시를 구독할 준비가 되었습니다.

명시적인 사용자 제스처 없이는 푸시 구독을 요청할 수 없다는 것을 기억하십시오.

버튼의 온클릭 핸들러에 응답하여 이 스크립트를 실행하는 것은 그 요구 사항을 충족시키는 많은 방법 중 하나입니다.

사용자가 그 버튼을 클릭하면, 여기에 푸시 구독을 요청할 수 있는 코드가 있습니다.

나는 이 점들 각각에 대해 더 자세히 설명할 것이다.

먼저, 푸시 구독 요청을 구성해야 합니다.

그것을 위한 중요한 부분은 우리 서버가 애플의 푸시 서버에 자신을 식별하는 데 사용하는 공개 키이다.

여기서 우리는 다른 브라우저와 마찬가지로 VAPID라는 표준 기술을 사용합니다.

여기서 VAPID의 때때로 복잡한 세부 사항을 검토하지는 않겠지만, 웹에는 서버 설정에 가장 적합한 솔루션을 제공하는 리소스가 있습니다.

VAPID 키 세트로 구독 요청을 구성할 준비가 되었습니다.

우리가 항상 푸시 사용자를 볼 수 있도록 약속한다는 것을 명시적으로 언급하고 있습니다.

자바스크립트 푸시 API의 표준은 선택적으로 푸시에 대한 응답으로 자동 자바스크립트 런타임을 수용하지만, 대부분의 브라우저는 그것을 지원하지 않습니다.

사파리는 그것을 지원하지 않는다.

그리고 대부분의 웹사이트와 마찬가지로, 브라우저 펫은 그것을 필요로 하지 않는다.

그런 다음 우리는 밀 수 있는 허가를 요청합니다.

이 자바스크립트 라인은 사용자가 승인하거나 거부할 수 있는 권한 프롬프트를 생성합니다.

사용자가 모든 Safari 팀 구성원이 Browser Pets에 대해 수행하는 권한을 부여한다고 가정하면 브라우저에서 이 사용자에게 도달하는 방법에 대한 세부 정보가 포함된 PushSubscription 객체를 제공합니다.

URL 끝점과 전송을 위한 푸시 메시지를 암호화하는 데 사용되는 키와 같은 것들.

마지막으로, 우리는 그 모든 세부 사항을 서버로 보내야 합니다.

앞서 언급했듯이, 이것의 세부 사항은 당신의 정확한 신청에 따라 달라질 것입니다.

우리의 BrowserPets 서버는 이미 표준 웹 푸시를 지원하는 몇 가지 플러그인이 있는 WordPress를 사용합니다.

백엔드에도 마찬가지일 가능성이 높으며, 웹에는 거의 모든 설정에 적합한 솔루션을 찾는 데 도움이 되는 리소스가 있습니다.

이제 우리는 서비스 워커 자바스크립트 코드로 돌아가야 합니다.

푸시 이벤트부터 시작하여 몇 가지 새로운 이벤트를 처리해야 할 것이다.

푸시 메시지가 브라우저 펫 서버에서 이 브라우저로 전달될 때, 이 서비스 워커는 푸시 이벤트를 전송합니다.

그 이벤트에는 서버에서 보낸 데이터에 액세스하는 여러 가지 방법이 있는 PushMessageData 객체가 포함되어 있습니다.

우리는 여기서 JSON 접근자를 사용합니다.

우리가 푸시를 구독했을 때, 우리의 자바스크립트가 항상 사용자가 볼 수 있을 것이라고 약속한 것을 기억하십니까?

그것은 우리가 항상 각 푸시에 대한 응답으로 플랫폼 네이티브 알림을 보여줘야 한다는 것을 의미합니다.

푸시 이벤트 핸들러에서 가능한 한 빨리 이것을 하는 것이 가장 좋습니다.

우리는 URL로 작업을 설정하는 것을 포함하여 알림을 구성하기 위해 JSON BLOB에서 필요한 모든 것을 꺼내고 있습니다.

그것은 잠시 후에 유용할 것이다.

알림이 표시된 후, 우리는 그것을 클릭하는 사용자를 처리해야 합니다.

서비스 워커 스크립트가 처리해야 할 이벤트가 하나 더 있습니다.

이 알림 클릭 핸들러에서 BrowserPets는 새 창을 열기 위해 클릭한 알림에서 URL을 가져옵니다.

참고하세요: 이것은 매우 흔한 패턴입니다.

그것이 우리가 웹 푸시를 지원하기 위해 작성해야 하는 모든 자바스크립트이다.

물론, 개발하는 동안 도움을 받는 것이 가장 좋습니다.

평소와 같이, 그것이 웹 인스펙터가 들어오는 곳이다.

웹 인스펙터는 브라우저 탭에서 열리는 웹사이트를 디버깅하는 데 도움을 주는 것 외에도 서비스 워커 인스턴스를 검사하고 이벤트 핸들러에 중단점을 설정할 수 있습니다.

이 모든 것을 함께 사용하면 푸시를 구독하는 자바스크립트와 푸시 이벤트 및 알림 이벤트를 처리하는 서비스 작업자 코드를 검사하고 디버깅할 수 있습니다.

또한, Apple 푸시 알림 서버는 푸시 메시지를 게시하려고 할 때 문제가 발생하면 사람이 읽을 수 있는 오류를 제공합니다.

추가 문서를 보려면 이 세션과 관련된 링크를 확인하세요.

나는 또한 사용자 개인 정보 보호 및 전력 사용과 관련하여 그 코드를 작성하는 동안 나온 몇 가지 점에 대해 더 자세히 설명하고 싶습니다.

중요한 것은 - 그리고 내가 이것을 말한 것은 이번이 처음이 아니다 - 푸시를 구독하려면 사용자 제스처가 필요하다.

웹 플랫폼의 다른 특권 기능과 마찬가지로, 사용자가 실제로 웹 푸시를 활성화하도록 요청하는 것은 사용자 신뢰가 옳은 일입니다.

푸시 구독을 요청하는 방법에 대한 코드를 보여줬을 때 언급했듯이, 푸시가 사용자에게 보일 것이라고 약속해야 합니다.

푸시 이벤트를 처리하는 것은 자바스크립트가 자동 백그라운드 런타임을 얻도록 초대하는 것이 아닙니다.

그렇게 하면 사용자의 신뢰와 사용자의 배터리 수명을 모두 위반할 수 있습니다.

푸시 이벤트를 처리할 때, 실제로 알림 센터에 알림을 게시해야 합니다.

다른 브라우저들은 모두 푸시 사용자를 보이게 하겠다는 약속을 위반하는 것에 대한 대책을 가지고 있으며, 사파리도 마찬가지입니다.

macOS Ventura의 베타 빌드에서, 적시에 알림을 게시하지 못한 세 번의 푸시 이벤트 후, 사이트의 푸시 구독이 취소됩니다.

권한 워크플로우를 다시 거쳐야 합니다.

그게 다야.

우리는 웹 푸시를 지원하는 것을 진심으로 자랑스럽게 생각하며 모든 사이트에서 사용할 수 있게 되어 기쁩니다. Apple 개발자 계정이 필요하지 않습니다.

표준에 따라 코딩하고 기능 감지를 사용하는 한, 무의식적으로 Safari를 제외하지 않는 한, 사용자는 이미 macOS Ventura의 Safari 16에서 웹 푸시의 이점을 얻을 수 있습니다.

평소와 같이, 우리는 올해 Safari와 WebKit에 수많은 다른 새로운 것들을 추가했으며, 더 많은 것을 배우기 위해 그 세션을 확인하길 바랍니다.

봐줘서 고마워.

나는 네가 WWDC 2022에서 좋은 휴식을 보내길 바라.