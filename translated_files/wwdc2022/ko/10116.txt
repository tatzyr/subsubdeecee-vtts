10116

- 안녕! 저는 켄트이고 CloudKit 팀의 엔지니어입니다.

CloudKit에 액세스하는 데 사용할 수 있는 새로운 라이브러리를 소개하게 되어 기쁩니다.

먼저, 이 새로운 라이브러리를 구성하는 방법을 다루겠습니다.

그런 다음 스키마를 관리하는 방법과 CKTool JS로 사용자 데이터에 액세스하는 방법을 배우게 될 것입니다.

시작하자!

CloudKit은 앱의 데이터를 컨테이너 내의 iCloud에 저장할 수 있는 지속성 기술입니다.

앱에서 CloudKit을 사용하면 장치와 웹에서 데이터를 최신 상태로 유지할 수 있습니다.

앱을 구축하기 위해, Apple 플랫폼의 CloudKit 프레임워크 또는 웹의 CloudKit JS를 사용하여 iCloud 스토리지에 액세스할 수 있습니다.

자동화와 툴링을 구현하기 위해, Xcode는 macOS에서 사용할 수 있는 cktool을 제공합니다.

그리고 이제 CKTool JS를 사용하여 변경 사항을 자동화하고 iCloud와 상호 작용할 수 있는 새로운 방법이 있습니다.

CKTool JS를 사용하면 Xcode 13에 도입된 cktool 명령줄 유틸리티와 동일한 작업을 수행할 수 있으며 유사한 사용 사례를 지원합니다.

사실, CKTool JS는 레코드 유형을 추가하고 레코드를 쿼리하는 것과 같은 CloudKit 콘솔의 기능을 구현하는 데 사용됩니다.

CKTool JS를 사용하면 앱 컨테이너를 관리하고 스키마에 대한 업데이트 재설정 및 적용과 같은 스키마 작업을 수행할 수 있습니다.

이것은 이전에 자바스크립트에서 할 수 없었던 일입니다.

CKTool JS를 사용하면 고유 식별자를 사용하거나 복잡한 쿼리를 통해 기존 레코드를 가져올 수 있습니다.

그리고 새 레코드를 만들고 업데이트할 수 있습니다.

CKTool JS는 TypeScript에 대한 엄격한 유형 정의와 함께 제공됩니다.

이러한 유형 정의는 클라이언트 라이브러리의 잘못된 사용을 플래그하는 컴파일 타임 검사를 가능하게 하고 지원되는 IDE에서 코드 완성을 가능하게 합니다.

이것 때문에 CKTool JS 코드를 더 쉽게 편집할 수 있습니다.

또한, 이 새로운 라이브러리는 Node.js와 브라우저를 모두 지원합니다.

CKTool JS는 자바스크립트 빌드 파이프라인의 일부로 통합할 수 있는 npm 패키지 세트로 배포됩니다.

그렇게 하면 나무를 흔들고 묶는 것과 같은 기능을 사용할 수 있다.

릴리스 기록이 npm에서 투명하게 제공되기 때문에 이러한 패키지에 대한 업데이트를 추적할 수도 있습니다.

다음 패키지는 CKTool JS 배포판의 일부입니다.

이 패키지들은 @apple 범위 내에 있으며 이름의 시작 부분에서 cktool을 사용하는 규칙을 따릅니다.

당신이 사용할 주요 패키지는 cktool.database입니다.

iCloud와의 통신을 활성화하려면, 대상 플랫폼에 다른 패키지, Node.js용 cktool.target.nodejs 또는 웹 브라우저용 cktool.target.browser를 사용해야 합니다.

Cktool.database는 cktool.core, cktool.api.base 및 cktool.api.database의 세 가지 패키지를 자동으로 가져옵니다.

CKTool JS는 iCloud와 직접 통신하기 때문에, 먼저 승인을 받아야 합니다.

호출하려는 작업에 따라 관리 토큰이나 사용자 토큰이 필요합니다.

두 종류의 토큰 모두 CloudKit 콘솔에서 얻을 수 있습니다.

관리 토큰은 관리 작업에 액세스하는 데 사용되며 팀과 사용자에게 적용됩니다.

이러한 작업에는 스키마 가져오기 및 내보내기, 스키마 유효성 검사, 컨테이너를 생산으로 재설정하는 것이 포함됩니다.

사용자 토큰은 팀과 컨테이너로 범위가 지정되며 해당 컨테이너 내의 개인 사용자 데이터에 액세스할 수 있습니다.

이러한 인증 토큰과 CloudKit과의 지속적인 통합을 얻는 방법을 배우려면, WWDC21의 "cktool 및 선언적 스키마로 CloudKit 테스트 자동화"를 확인하세요.

스크립트에서 CKTool JS를 사용하고 싶을 때마다, 먼저 사용하도록 구성해야 합니다.

하지만 CKTool JS를 구성하기 전에, CloudKit 스키마를 구성하는 것에 대한 빠른 검토를 할 것이다.

CloudKit에서 데이터는 구조화된 방식으로 저장됩니다.

같은 종류의 값을 가진 데이터는 레코드로 함께 저장됩니다.

레코드는 레코드 유형의 인스턴스이며, 레코드 유형이 설명하는 레코드의 속성은 필드로 알려져 있다.

CloudKit은 사용자 정의 필드 외에도 레코드의 ID인 recordName과 같은 시스템 필드를 추가합니다.

나는 내가 작업하고 있는 동전 수집 앱의 예시를 사용할 것이다.

나는 국가 컬렉션을 저장하고 싶기 때문에, 어떤 종류의 자산을 저장해야 하는지 설명할 수 있는 기록 유형이 있다.

저는 이름과 ISO 코드를 저장하고 있으며, 레코드 유형을 "국가"라고 명명하고 있습니다.

ISO 코드는 국가를 고유하게 식별하므로, 내 기록 유형에 포함시키는 것이 중요합니다.

나는 그들의 이름과 함께 이 정보를 저장하기 위해 국가 유형의 기록을 만든다.

나는 또한 특정 국가의 동전에 대한 기록 유형을 가지고 있으며, 그것들을 서로 연관시키고 싶다.

동전 기록 유형은 동전에서 국가와의 관계를 저장한다.

레코드 유형과 관계가 결합되어 스키마를 만든다.

나는 이 요소들의 현재 상태를 내 스키마의 현재 버전으로 간주할 수 있다.

앱을 개발할 때, 스키마를 발전시킬 것이며, 앱의 수명 동안 여러 버전을 갖게 될 것입니다.

내 앱의 스키마는 내가 iCloud에 저장하고 싶은 데이터의 구조를 설명하지만, 내 앱 컨테이너는 그 데이터가 저장되는 곳이다.

컨테이너는 고유 식별자를 가지고 있으며 개발자 팀과 연결되어 있다.

CloudKit으로 작업할 때 명심해야 할 두 가지 환경이 있습니다.

개발 환경은 사용자를 방해하지 않고 변경할 수 있는 안전한 장소이다.

이것은 당신이 당신의 스키마에 대한 변경 사항을 테스트하고 개발해야 하는 곳입니다.

사용자가 당신의 앱과 상호 작용할 때, 그들은 생산 환경과 상호 작용할 것입니다.

프로덕션 환경에는 앱의 라이브 데이터가 포함되어 있습니다.

이제 CloudKit이 데이터를 저장하는 방법을 검토했으므로, CKTool JS를 구성하는 방법을 다루겠습니다.

CKTool JS는 iCloud와 대화하기 때문에, 올바른 컨테이너로 작업하는 방법과 스크립트가 그렇게 할 수 있도록 몇 가지 정보를 수집해야 합니다.

작업하고 싶은 컨테이너의 팀 ID와 컨테이너 ID가 필요합니다.

스키마로 작업하려면 관리 토큰이 필요하며, 스크립트가 데이터에 액세스하는 경우 사용자 토큰도 필요합니다.

이 모든 값은 CloudKit 콘솔에서 얻을 수 있습니다.

또한 스크립트가 실행될 환경, 개발 또는 프로덕션을 지정해야 합니다.

나는 개발을 앞으로의 예로 사용할 것이다.

CKTool JS를 사용하도록 구성할 때마다, 이 값이 필요합니다.

예를 들어, 저는 Node.js를 위한 스크립트를 쓰고 있습니다.

그것들을 사용하기 위해 CKTool JS에서 객체와 함수를 가져옵니다.

이 경우, CommonJS require 문을 사용하여 이러한 기호를 가져올 수 있습니다.

구성 정보를 수집하면, 그 정보를 보관할 개체를 만들 수 있습니다.

인증 토큰을 저장하려면 관리 토큰을 보관할 개체를 만들고, 있는 경우 사용자 토큰을 만듭니다.

teamId, containerId 및 환경은 CKTool JS에 전달되는 공통 값이므로, 이러한 값을 보유할 객체를 만들 수 있습니다.

createConfiguration 공장 기능을 사용하여 CKTool JS에게 iCloud와 대화하는 방법을 알려주는 구성 객체를 인스턴스화합니다.

createConfiguration은 플랫폼에 따라 다릅니다.

이 경우, 대상 패키지에서 가져온 함수이기 때문에 Node.js에 대한 적절한 구성을 반환합니다.

그런 다음 구성 객체와 이전에 선언된 보안 객체를 전달하여 API 객체를 초기화합니다.

API 객체에는 iCloud와 대화할 수 있는 비동기 메서드가 포함되어 있습니다.

이제 스크립트에서 CKTool JS를 사용하는 단계를 완료했습니다.

CKTool JS를 사용하여 컨테이너의 스키마를 관리하는 방법에 대해 알아봅시다.

제 앱에는 2007년에 발행된 미국 동전과 같은 정보를 저장하고 싶습니다.

이 동전은 구리와 니켈로 구성되어 있으며 그 위에 찍힌 가치는 미국 달러의 1/10이다.

이 데이터를 저장하는 방법에 대해 생각한 후, 나는 동전의 구성에 대한 정보를 동전에 대한 다른 세부 사항과 별도의 기록으로 저장하기로 결정했다.

그래서 나는 10센트의 구리 백분율과 니켈 백분율을 별도의 기록에 저장한다.

나는 컨테이너의 스키마에서 원하는 두 가지 레코드 유형을 확인했다.

국가 참조, 발행 연도 및 명목 가치를 저장하는 동전.

그리고 그것이 설명하는 동전에 대한 참조와 동전의 재료와 비율을 저장하는 구성 요소 레코드 유형.

이제 앱의 스키마를 결정했으므로, CloudKit 스키마 언어로 텍스트 파일을 만들어 설명할 수 있습니다.

규칙은 스키마 파일에 .ckdb 확장자를 사용하는 것입니다.

CloudKit 스키마 언어에 대한 자세한 내용은 "텍스트 기반 스키마를 워크플로우에 통합" 문서 문서를 참조하십시오.

컨테이너에 대해 만든 스키마 파일은 CKTool JS를 사용하여 적용할 수 있습니다.

새로운 스키마를 적용하기 전에, 일반적으로 컨테이너의 개발 스키마를 프로덕션의 것과 일치하도록 재설정합니다.

resetToProduction 방법으로 이것을 할 수 있습니다.

이전에 선언한 defaultArgs 객체를 전달하여 이 메서드를 호출합니다.

스키마가 생산되지 않으면, 모든 레코드 유형이 삭제됩니다.

그렇지 않으면, 이것은 개발 스키마를 생산 환경의 상태로 되돌릴 것이다.

이것은 비동기 호출이므로, 이 메서드는 약속 객체를 반환합니다.

CKTool JS에는 컨테이너의 스키마를 내보내고 가져올 수 있는 방법이 있습니다.

exportSchema와 importSchema 메소드는 당신이 이것을 할 수 있게 해주며 컨테이너의 관점에서 명명됩니다.

그래서 exportSchema를 사용하여 컨테이너에서 내보낼 스키마를 다운로드하고, importSchema를 사용하여 컨테이너로 가져올 스키마를 업로드합니다.

이것들은 함께 스키마의 진화를 관리할 수 있게 해준다.

스키마를 컨테이너에 적용하는 도움말 함수를 만들 수 있습니다.

먼저, CKTool JS에서 파일 객체를 가져온 다음, Node.js에서 fs 및 경로 모듈을 가져옵니다.

이제 다음을 수행할 비동기 함수를 정의하십시오: 스키마 파일의 내용을 Node.js 버퍼로 읽습니다.

업로드를 위한 CKTool JS 파일 인스턴스를 만듭니다.

마지막으로, importSchema를 사용하여 파일의 내용을 서버에 업로드합니다.

이전에 선언된 defaultArgs 객체는 importSchema에 전달된다는 점에 유의하십시오.

이제 넌 그걸 조립할 수 있어.

resetToProduction과 스키마를 가져오는 데 사용되는 도우미 기능은 비동기이기 때문에 올바른 순서로 실행되도록 해야 합니다.

그렇게 하기 위해 당신은 약속을 묶습니다.

오류가 발생하면, 그 약속은 거절될 것이다.

CKTool JS가 가지고 있는 관리 기능 외에도 데이터를 읽고 쓸 수 있습니다.

CKTool JS 레코드에 사용되는 필드 값은 서버로 전송되기 전에 클라이언트 측에서 유형 및 범위가 확인됩니다.

전달된 값이 올바른 종류의 값이 아니거나 허용된 값 범위를 벗어나면 예외가 발생합니다.

자바스크립트에서 기본적으로 표현할 수 없는 큰 숫자의 경우, 대신 사용되는 CKTool JS 유형이 있습니다.

예를 들어, CKTool JS Int64에 숫자를 강요하려면 toInt64 함수를 사용합니다.

숫자를 Double 부동 소수점 값으로 강제하려면, toDouble 함수를 사용합니다.

TypeScript를 작성하는 경우, 이러한 강제 함수가 사용되지 않으면 컴파일러가 잘못된 값 유형 사용에 플래그를 지정할 것입니다.

CKTool JS 레코드의 필드 값은 필드 값 팩토리 함수를 사용하여 생성됩니다.

2007년에 발행된 동전의 경우, 나는 Int64를 포함하는 레코드 필드 값을 만들기 위해 그 값을 makeRecordFieldValue.int64 공장 함수에 전달할 것이다.

일반적으로, 공장 함수가 전달된 값에서 레코드 필드 값을 만들 수 없다면, 예외가 발생합니다.

여기서, 나는 레코드와 함께 작동하는 방법으로 보내는 공통 값을 보유하기 위한 객체를 만들었다.

containerId, environment, databaseType 및 zoneName이 종종 필요하기 때문에, 저는 이 databaseArgs 객체에 그것들을 포함하고 있습니다.

레코드를 쿼리하기 위해, 저는 queryRecords 메소드를 사용합니다.

이것을 더 쉽게 하기 위해, 나는 독특한 3자 ISO 코드와 일치하는 국가를 찾는 도우미 기능을 만든다.

이 경우, 쿼리가 포함된 본문 외에도 databaseArgs 객체의 내용을 전달합니다.

쿼리 객체의 경우, recordType 값과 단일 필터 객체를 지정하고 있습니다.

필터 객체는 국가의 isoCode3가 이 함수가 찾고 있는 것과 같은 쿼리를 설명합니다.

성공하면, 발견된 기록의 수집은 response.result.records 속성에 있을 것이다.

나는 이 컬렉션의 첫 번째 물건을 돌려줘.

원시 값을 createRecord가 사용할 수 있는 필드 값으로 변환하기 위해, makeCoinFieldValues라는 도우미 함수가 있습니다.

필드 값으로 변환하고 싶은 동전의 각 원시 속성에 대해 적절한 RecordFieldValue 공장 함수를 호출합니다.

그러나, 국가 분야의 경우, 나는 레퍼런스를 만들어야 한다.

나는 이 동전 기록에서 해당 국가 기록으로 참조하기 위해 전달된 국가 기록 이름을 사용한다.

여기서, 저는 코인 레코드 필드 값을 취하고 createRecord 요청을 서버에 보내는 도우미 함수를 만듭니다.

이 기능에서, 나는 이전에 선언된 databaseArgs의 내용과 본문을 전달하고 있다.

본문 사전에는 recordType과 필드 값이 포함되어 있습니다.

성공하면, response.result.record가 반환됩니다.

도우미 기능을 호출하기 전에, 이 동전에서 참조될 올바른 국가 기록을 가져와야 합니다.

나는 이전에 정의된 국가 쿼리 기능을 사용한다.

그런 다음 이전에 작성한 makeCoinFieldValues 도우미 함수로 만든 필드 값 사전을 전달하여 coinCreateRecord를 호출합니다.

원시 동전 값은 그 도우미 함수로 전달된다.

이것은 비동기적으로 기록을 만들고 새 기록을 반환할 것이다.

레코드를 업데이트하려면, updateRecord 방법을 사용하세요.

이 도우미에게 전달된 필드와 레코드 이름과 일치하는 동전을 업데이트하는 도우미 함수를 만듭니다.

그런 다음 databaseArgs 객체, recordName 및 레코드 유형과 새 레코드의 필드 값을 포함하는 본문의 내용으로 updateRecord를 호출합니다.

성공하면, 업데이트된 레코드는 내가 도우미 함수에서 반환하는 response.result.record 속성에 있을 것이다.

이전에 만든 코인 레코드를 업데이트하기 위해, 이 도우미 함수를 호출하여 레코드 이름과 필드 값을 업데이트합니다.

필드 값은 makeCoinFieldValues로 생성됩니다.

레코드를 삭제하려면, API 객체에서 비동기 deleteRecord 메소드를 호출합니다.

삭제할 레코드의 recordName뿐만 아니라 databaseArgs 객체의 내용을 전달합니다.

CKTool JS를 알아가는 것을 즐겼기를 바랍니다.

직접 사용해 보세요: 자동화 및 툴링 목적으로 CKTool JS를 구성하세요.

스키마를 재설정하고 가져오고 자바스크립트를 사용하여 데이터를 읽고 쓰세요.

지속적인 통합 시나리오에서 CKTool JS를 사용하려면, GitHub의 CloudKit 샘플 저장소를 확인하세요.

그리고 더 자세한 문서는 developer.apple.com에서 CKTool JS를 확인하세요.

오늘 나와 함께 해줘서 고마워, 그리고 남은 WWDC22를 즐겨.