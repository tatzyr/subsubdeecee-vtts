10120

♪ ♪

David Stites: 안녕하세요, "핵심 데이터 스키마를 발전시키세요"에 오신 것을 환영합니다.

제 이름은 David Stites이고 저는 Core Data 팀의 엔지니어입니다.

이 세션에서는 앱에서 핵심 데이터 스키마를 업데이트하고 마이그레이션하는 방법에 대해 이야기하게 되어 기쁩니다.

이 세션의 의제는 스키마 마이그레이션이 무엇인지, 데이터 모델을 업데이트한 후 앱이 수행해야 하는 이유, 기존 스키마를 마이그레이션하는 방법, CloudKit과 스키마 마이그레이션이 어떻게 상호 작용하는지 배우는 것입니다.

먼저, 스키마 마이그레이션은 무엇이며 데이터 모델을 업데이트할 때 앱이 마이그레이션해야 하는 이유.

애플리케이션이 발전함에 따라, 데이터 모델을 변경해야 할 수도 있습니다.

데이터 모델을 업데이트하려면 이러한 변경 사항이 기본 스토리지 스키마에서 구체화되어야 합니다.

이 데이터 모델을 고려하세요.

그것은 두 가지 속성, 유형 및 엔진 수를 가진 항공기 엔티티를 가지고 있다.

이러한 속성은 기본 저장소에 반영됩니다.

많은 승객 속성을 추가하면, 해당 저장소를 추가해야 합니다.

마이그레이션 후, 변경 사항은 기본 저장소에 완전히 반영됩니다.

기본 스토리지의 변경 사항을 마이그레이션하지 않고, Core Data는 새로 변경된 모델이 스토리지에 사용된 모델과 일치하지 않기 때문에 영구 저장소를 여는 것을 거부할 것입니다.

호환되지 않는 저장소를 열려고 하면 NSPersistentStore- IncompatibleVersionHashError 코드로 오류가 발생합니다.

이 오류를 받으면, 마이그레이션이 필요하다는 표시가 되어야 합니다.

이제 스키마 마이그레이션이 무엇이고 앱을 발전시키는 데 왜 필수적인지 설명했으니, 마이그레이션이 어떻게 이루어지는지 알려드리겠습니다.

Core Data에는 앱의 데이터 저장소를 현재 데이터 모델로 최신 상태로 유지하는 데 도움이 되는 데이터 마이그레이션 도구가 내장되어 있습니다.

총체적으로, 이 도구들은 "경량 이동"이라고 불린다.

경량 이동은 선호되는 이동 방법이다.

경량 마이그레이션은 소스와 대상 관리 객체 모델의 차이점에서 마이그레이션을 자동으로 분석하고 추론합니다.

런타임에, Core Data는 NSBundle 클래스의 .allBundles 및 .allFrameworks 메소드에서 반환된 번들에서 모델을 찾습니다.

그런 다음 경량 마이그레이션은 매핑 모델을 생성하여 데이터베이스 스키마에서 앱의 변경 사항을 구체화합니다.

경량 마이그레이션을 사용하려면 명백한 마이그레이션 패턴에 맞게 데이터 모델을 변경해야 합니다.

속성과 관련된 가벼운 작업에는 속성을 추가하고, 속성을 제거하고, 선택 사항이 아닌 속성을 선택적으로 만들고, 선택 속성을 선택 사항이 아닌 것으로 만들고, 기본값을 정의하고, 속성의 이름을 바꾸는 것이 포함됩니다.

속성의 이름을 바꾸려면, 대상 모델의 이름 바꾸기 식별자를 소스 모델의 해당 속성의 이름으로 설정하십시오.

이름 바꾸기 식별자는 Xcode 데이터 모델 편집기의 속성 관리자에서 찾을 수 있습니다.

예를 들어, 항공기 엔티티 색상 속성의 이름을 paintColor로 바꿀 수 있습니다.

이름 바꾸기 식별자는 표준 이름을 생성하므로, 해당 속성에 이미 이름 바꾸기 식별자가 없는 한, 이름 바꾸기 식별자를 소스 모델의 속성 이름으로 설정하십시오.

즉, 모델의 버전 2에서 속성의 이름을 바꾼 다음, 버전 3에서 다시 이름을 바꿀 수 있습니다.

이름 변경은 버전 2에서 버전 3으로, 또는 버전 1에서 버전 3으로 올바르게 작동합니다.

가벼운 이동은 또한 땀을 흘리지 않고 관계의 변화를 처리할 수 있다.

새로운 관계를 추가하거나 기존 관계를 삭제할 수 있습니다.

속성과 마찬가지로 이름 바꾸기 식별자를 사용하여 관계의 이름을 바꿀 수도 있습니다.

또한, 관계 카디널리티를 변경할 수 있습니다. 예를 들어, a to-one에서 a to-many로, 또는 정렬되지 않은 to-many에서 주문 to-many로 마이그레이션하거나, 그 반대의 경우도 마찬가지입니다.

엔티티도 경량 마이그레이션을 받을 자격이 있다고 추측했다면, 당신 말이 맞습니다.

새 엔티티를 추가하고, 기존 엔티티를 제거하고, 엔티티의 이름을 바꿀 수 있습니다.

또한 새로운 부모 또는 자식 엔티티를 만들고 엔티티 계층 내에서 속성을 위아래로 이동할 수 있습니다.

엔티티를 계층 구조 안팎으로 옮길 수 있습니다.

그러나 엔티티 계층을 병합할 수는 없습니다.

두 개의 기존 엔티티가 소스에서 공통 부모를 공유하지 않으면, 대상에서 공통 부모를 공유할 수 없습니다.

경량 마이그레이션은 두 가지 옵션 키로 제어됩니다: NSMigratePersistent- StoresAutomaticallyOption 및 NSInferMappingModelAutomaticallyOption.

저장소가 영구 코디네이터에 추가될 때 이 두 키의 존재가 실제 값으로 설정되면 Core Data는 영구 저장소가 더 이상 현재 모델과 일치하지 않는 것을 감지하면 자동으로 경량 마이그레이션을 수행하게 됩니다.

NSPersistentContainer 또는 NSPersistentStoreDescription을 사용하는 경우, 이러한 옵션은 자동으로 설정되며 아무것도 할 필요가 없습니다.

NSPersistentStoreCoordinator .addPersistentStore (type:configuration:at:options:)와 같은 대체 API를 사용하는 경우, NSMigratePersistent- StoresAutomaticallyOption 및 NSInferMappingModelAutomaticallyOption을 YES 값으로 설정하여 옵션 사전을 설정하고 전달하여 경량 마이그레이션을 요청할 수

Core Data는 영구 저장소가 더 이상 현재 모델과 일치하지 않는 것을 감지하면 자동으로 경량 마이그레이션을 수행합니다.

이것이 코드에서 작동하는 방식은 다음과 같습니다.

먼저, 나는 CoreData를 가져오고 관리되는 객체 모델을 만들 것이다.

그런 다음, 방금 만든 모델을 사용하여 지속적인 매장 코디네이터를 만들 것입니다.

내가 만든 옵션 사전을 참고하고 영구 코디네이터에 상점을 추가할 때 전달할 것이다.

마지막으로, 필요한 경우 마이그레이션이 자동으로 발생하는 코디네이터에 상점을 추가할 것입니다.

어떤 API를 사용하든, 데이터 모델의 변경은 응용 프로그램과 함께 배송되는 동일한 모델에서 직접 이루어질 수 있습니다.

변경하기 위해 새 버전의 모델을 만들 필요가 없습니다.

Core Data가 실제로 마이그레이션 작업을 수행하지 않고 소스와 대상 모델 간의 매핑 모델을 추론할 수 있는지 여부를 미리 결정하려면 NSMappingModel .inferredMappingModel 방법을 사용할 수 있습니다.

이 방법은 Core Data가 만들 수 있다면 추론된 모델을 반환합니다.

그렇지 않으면, 그것은 0을 반환한다.

때때로, 스키마의 결합된 변화는 경량 마이그레이션 기능을 초과할 수 있다.

나는 그 문제를 어떻게 처리하고 여전히 경량 마이그레이션을 사용하는지 설명할 것이다.

이전 예제 모델로 돌아가서, 이전에 FLIGHT_DATA에 저장된 파일 경로로 표시된 이진 데이터에 외부 저장소를 사용하는 "flightData"라는 속성을 추가했다고 가정합니다.

또한, 내부적으로 데이터를 저장하고 외부 저장소를 제거하기 위해 그 속성을 변경할 필요가 있다고 가정해 봅시다.

이 마이그레이션이 경량 마이그레이션의 기능에 맞는지 확인하면서, 그렇지 않다는 것이 밝혀졌다.

겉으로 보기에, 우리는 갇혀서 이 변화를 만들 수 없는 것처럼 보인다.

하지만, 두려워하지 마!

경량 마이그레이션은 여러 단계임에도 불구하고 더 복잡하고 부적합한 마이그레이션을 수행하는 데 여전히 사용될 수 있다.

목표는 경량 마이그레이션을 받을 수 없는 마이그레이션 작업을 경량 마이그레이션을 받을 수 있는 최소 일련의 마이그레이션으로 분해하는 것입니다.

일반적으로, 원래 모델이 A이고 목표 모델이 B이지만, 모델 B에 경량 마이그레이션을 적용할 수 없는 변경 사항이 있는 경우, 이러한 변경 사항을 분해하는 하나 이상의 모델 버전을 도입하여 브리지를 만들 수 있습니다.

도입된 각 모델은 부적합한 변화를 구성하는 기능 내에 있는 하나 이상의 작업을 가질 것이다.

이것은 각 모델이 이제 경량으로 마이그레이션할 수 있지만 부적합한 마이그레이션과 동등한 일련의 마이그레이션을 초래한다.

경량 마이그레이션을 받을 수 없었던 내 예로 돌아가서, 우리의 원래 모델은 모델 A이다.

새로운 모델 버전인 A 프라임을 도입하여 작업을 분해하기 시작하고 외부 파일에서 가져온 데이터를 저장하는 데 일시적으로 사용될 새로운 속성 "tmpStorage"를 추가할 것입니다.

다음으로, 나는 외부 파일의 데이터를 우리의 새로운 속성으로 가져올 것이다.

이 데이터를 가져오는 코드는 코어 데이터에서 제공하는 기능과는 별개입니다.

이 수입의 실행은 이주 사이에 끼어 있다.

데이터가 안전하게 가져오면, 나는 A 프라임에서 A 더블 프라임 모델의 또 다른 새 버전을 만들 것이다.

더블 프라임에서, 나는 새로운 속성의 이름을 바꾸면서 동시에 오래된 외부 저장소 속성을 삭제할 것이다.

설명된 각 단계는 경량 마이그레이션 기능 내에 있습니다.

직관적으로, 가벼운 마이그레이션 옵션으로 설정된 영구 저장소를 열고 연속 순서로 처리되지 않은 각 모델을 반복적으로 단계하는 이벤트 루프를 구축할 수 있으며, Core Data는 저장소를 마이그레이션할 것입니다.

이전 예제에서 외부 파일에서 데이터를 가져온 방법과 같이 마이그레이션 중에 앱별 로직을 수행하는 경우, 프로세스 종료로 인해 마이그레이션이 중단되는 경우 해당 로직은 "재시작 가능"해야 합니다.

앱이 Core Data와 CloudKit을 사용하는 경우, Core Data에서 데이터 모델을 설계할 때 명심해야 할 몇 가지 중요한 사항이 있습니다.

코어 데이터 저장소와 CloudKit 데이터베이스 간에 레코드를 전달하려면 데이터 모델에 대한 공유된 이해가 필요합니다.

코어 데이터 모델 편집기에서 이 모델을 정의합니다.

그 모델은 나중에 CloudKit 스키마를 생성하는 데 사용된다.

생성된 스키마는 처음에 개발 환경에서 생성된 다음 생산으로 승격된다.

CloudKit이 Core Data 모델의 모든 기능을 지원하지 않는다는 점에 유의해야 합니다.

모델을 설계할 때, 다음과 같은 제한 사항을 인식하고 호환 가능한 데이터 모델을 만드세요.

예를 들어, 엔티티에 대한 고유한 제약은 지원되지 않습니다.

정의되지 않은 개체 ID 속성 유형은 속성 유형으로 지원되지 않습니다.

그리고 관계는 선택 사항이어야 하며 역관계가 있어야 한다.

또한, CloudKit은 삭제 거부 규칙을 지원하지 않습니다.

앱을 개발할 때, 당신은 개발 환경을 사용하게 될 것입니다.

CloudKit 스키마는 이 환경에서 자유롭게 수정할 수 있습니다.

그러나, 스키마를 프로덕션으로 홍보한 후, 레코드 유형과 필드는 변경할 수 없습니다.

경량 마이그레이션은 다양한 시나리오를 처리하지만, CloudKit은 지원하는 것이 더 제한적이다.

앞서 설명한 많은 경량 작업은 지원되지 않습니다.

특히, CloudKit에서 지원되는 것은 기존 레코드 유형에 새로운 필드를 추가하고 새로운 레코드 유형을 추가하는 것입니다.

기존 레코드 유형이나 필드를 수정하거나 삭제할 수 없습니다.

모델 스키마를 수정할 때 이러한 제한 사항을 고려하십시오.

데이터 모델을 업데이트할 때가 되면, 가벼운 마이그레이션은 로컬 저장소 파일의 스키마 변경만 구체화한다는 것을 명심하세요.

특정 저장소가 CloudKit과 함께 사용되는지 여부에 관계없이, 마이그레이션은 디스크의 저장소만 변경하고 CloudKit 스키마를 변경하지 않습니다.

스키마 이니셜라이저를 실행한 다음 CloudKit 콘솔을 사용하여 개발의 변경 사항을 프로덕션으로 홍보하여 개발 데이터베이스에서 이러한 변경 사항을 구체화해야 합니다.

앱 사용자는 이전 버전과 새 버전을 사용할 것이라는 점을 명심하세요.

최신 버전의 앱은 물론 스키마에 새로 추가된 것에 대해 알게 될 것이다.

이전 버전의 앱은 새로운 필드나 레코드 유형에 대해 알지 못할 것이다.

CloudKit 스키마는 본질적으로 추가적이기 때문에, 이전 버전의 앱을 실행하는 장치에 대한 스키마 마이그레이션의 영향을 고려하십시오.

예를 들어, 한 가지 일반적인 함정은 이전 버전의 앱이 사용하지만 최신 버전은 사용하지 않는 오래된 필드를 업데이트하는 것을 잊어버리는 것입니다.

다음은 CloudKit 스키마를 마이그레이션하기 위한 몇 가지 전략입니다.

첫 번째 옵션은 기존 레코드 유형에 새로운 필드를 점진적으로 추가하는 것이다.

이 접근 방식을 채택하면, 이전 버전의 앱은 사용자가 만드는 모든 레코드에 액세스할 수 있지만, 모든 필드는 아닙니다.

두 번째 옵션은 버전 속성을 포함하여 엔티티를 버전한 다음, 가져오기 요청을 사용하여 현재 버전의 앱과 호환되는 레코드만 선택하는 것입니다.

이 접근 방식을 채택하면, 이전 버전의 앱은 사용자가 최신 버전으로 만든 레코드를 가져오지 않아 해당 장치에 효과적으로 숨깁니다.

마지막 전략은 NSPersistentCloudKitContainerOptions를 사용하여 완전히 새로운 컨테이너를 만들어 새 저장소를 새 컨테이너와 연결하는 것입니다.

사용자가 큰 데이터 세트를 가지고 있다면, 데이터 세트를 iCloud에 업로드하는 데 오랜 시간이 걸릴 수 있습니다.

어떤 방법을 사용하든, 데이터 모델을 설계할 때 주의하세요.

교차 버전 호환성 문제를 고려하고 다른 버전의 데이터 모델을 함께 테스트하십시오.

이제 데이터 모델, 마이그레이션 및 CloudKit에 대해 철저히 논의했으므로, 저는 이것을 실제로 시연할 것입니다.

짐작하셨겠지만, 저는 조종사입니다.

나는 비행 시간을 기록하기 위해 작은 앱을 만들었다.

여기 그 앱의 데이터 모델이 있습니다.

저는 "LogEntry"라는 단일 엔티티를 가지고 있으며 필요한 경험 정보를 기록할 수 있도록 항공기 유형, 비행 기간, 출발지, 목적지 및 꼬리 번호와 같은 여러 속성을 추가했습니다.

내가 이 애플리케이션을 처음 실행할 때, Core Data는 저장소를 만들고 그 저장소에서 스키마를 구체화할 것이다.

애플리케이션을 실행하기 전에 com.apple.CoreData.SQLDebug와 com.apple.CoreData.MigrationDebug 환경 변수를 켤 것입니다.

이것은 Core Data가 취하고 있는 단계를 기록하게 할 것이다.

이러한 논쟁이 제자리에 있으면, 나는 앱을 실행할 것이다.

앱이 실행됨에 따라, Core Data는 파일을 만들고, 저장소의 메타데이터를 만들고, 스키마를 구체화하는 단계를 기록하고 있습니다.

SQLite는 우리의 스키마와 함께 ZLOGENTRY 테이블을 만들었다.

이것은 또한 sqlite3 명령줄 도구를 사용하여 저장소 파일을 보고 확인할 수 있습니다.

여기 LogEntry 테이블이 있으며, 데이터 모델에서 만든 속성에 해당하는 열이 있습니다.

이제 나는 가벼운 변화를 만들 거야.

나는 새로운 단체, 항공기, 조종사, 그리고 공항을 추가하고 있다.

이것은 내가 스키마를 정상화하는 데 도움이 될 것이다.

나는 LogEntry 엔티티의 속성 중 일부를 관계로 바꾸고 있다.

예를 들어, 목적지와 출발지는 문자열 속성에서 공항과의 관계로 이동한다.

공항 법인은 또한 icaoIdentifier와 faaIdentifier라는 두 가지 새로운 속성을 가지고 있다.

유형 속성은 새로운 엔티티로 승격됩니다; 항공기와 저는 두 개의 새로운 속성인 tailNumber와 registrationNumber를 추가하고 있습니다.

LogEntry에서, 나는 LogEntry에서 항공기와 일대일 관계를 맺고 있다.

마지막으로, 이름과 인증서 ID가 있는 파일럿 엔티티를 추가했습니다.

각 로그 항목은 파일럿 엔티티와 관련이 있을 것이다.

이제 데이터 모델에 대한 변경을 완료했으므로, 앱을 다시 실행할 것입니다.

이런! 앱을 실행하는 동안 오류가 발생했습니다.

코드를 검사하면, NSPersistentStore- IncompatibleVersionHashError입니다.

그 오류는 내 현재 모델이 더 이상 매장의 모델 스키마와 일치하지 않는다는 것을 의미한다.

나는 상점 스키마를 마이그레이션해야 해.

나는 세 가지 방법 중 하나로 그것을 할 수 있다.

첫 번째 방법을 사용하면 경량 마이그레이션 옵션이 자동으로 설정되므로 코드를 NSPersistentContainer로 변환할 수 있습니다.

두 번째 방법을 사용하면 NSPersistentStoreDescription을 사용할 수 있습니다. 다시 말하지만, 가벼운 마이그레이션 옵션이 자동으로 설정되기 때문입니다.

마지막으로, 세 번째 방법을 사용하여 옵션 사전에서 경량 마이그레이션 옵션을 수동으로 설정하고 상점을 열 때 해당 사전을 코디네이터에게 전달할 수 있습니다.

나는 NSPersistentContainer를 사용하여 첫 번째 옵션을 선택할 것이라고 생각한다.

이제 NSPersistentContainer를 사용하기 위해 코드를 변환했으므로, 앱을 실행하고 Core Data가 저장소 파일의 스키마를 마이그레이션하는 것을 다시 관찰할 것입니다.

다시 말하지만, 이것은 sqlite3 명령줄 도구를 사용하여 확인할 수 있습니다.

새로운 스키마는 경량 마이그레이션을 사용하여 Core Data에 의해 자동으로 구체화되었습니다.

뭐가 더 쉬울 수 있을까?

데모를 끝내기 전에, 나는 옵션 번호 3을 보여주고 싶었다.

이 옵션을 기억하세요, 저는 옵션 사전에서 경량 마이그레이션 옵션을 수동으로 설정한 다음 상점을 열 때 그 사전을 코디네이터에게 전달하고 있습니다.

최종 결과는 상점이 새로운 스키마로 마이그레이션된다는 점에서 동일합니다.

데이터 모델을 변경할 때, 가벼운 마이그레이션을 사용하여 도움을 받으세요.

경량 마이그레이션은 대부분의 데이터 모델 변경에 매우 유연하고 사용하기 쉽습니다.

더 복잡한 데이터 모델이 있다면, 그 모델을 가벼운 변화로 구성된 모델로 나누세요.

마지막으로, 앱과 함께 CloudKit을 사용하는 경우, 데이터 모델 변경의 영향을 신중하게 고려하십시오.

데이터 모델 변경 사항을 철저히 테스트하세요.

이 정보가 유용하고 멋진 새로운 기능을 구축하기 위해 프로젝트의 모델을 업데이트하는 것을 고려하기를 바랍니다.

나와 함께 비행해줘서 고마워, 그리고 멋진 WWDC를 보내.