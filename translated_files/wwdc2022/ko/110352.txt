110352

♪ 부드러운 기악 힙합 음악 ♪

♪

안녕하세요 여러분, 저는 스위프트 컴파일러 팀의 홀리입니다.

"Embrace Swift generics"에 오신 것을 환영합니다.

제네릭은 Swift에서 추상 코드를 작성하는 기본 도구이며, 코드가 진화함에 따라 복잡성을 관리하는 데 중요합니다.

추상화는 아이디어를 구체적인 세부 사항과 분리한다.

코드에는 추상화가 유용한 다양한 방법이 있다.

항상 사용할 수 있는 추상화의 한 형태는 코드를 함수나 지역 변수로 분해하는 것이다.

같은 기능이나 가치를 여러 번 사용해야 하는 경우 이것은 정말 유용할 수 있습니다.

기능을 함수로 추출하면 세부 사항이 추상화되며, 추상화를 사용하는 코드는 세부 사항을 반복하지 않고 무슨 일이 일어나고 있는지에 대한 아이디어를 표현할 수 있습니다.

스위프트에서는 구체적인 유형을 추상화할 수도 있습니다.

세부 사항이 다른 모두 같은 아이디어인 유형 집합이 있다면, 모든 구체적인 유형으로 작업하기 위해 추상 코드를 작성할 수 있습니다.

오늘, 우리는 구체적인 유형으로 코드를 모델링하는 워크플로우를 살펴보고, 일련의 구체적인 유형의 공통 기능을 식별하고, 그 기능을 나타내는 인터페이스를 구축하고, 마지막으로, 그 인터페이스를 사용하여 일반 코드를 작성하는 데 뛰어들 것입니다.

우리는 농장을 시뮬레이션하기 위한 코드를 구축하면서 스위프트의 추상화 도구를 파헤칠 것이다.

그래서, 몇 가지 구체적인 유형을 쓰는 것으로 시작합시다.

우리는 "소"라고 불리는 하나의 구조체로 시작할 것이다.

소는 헤이 유형의 매개 변수를 받아들이는 "먹다"라는 방법을 가지고 있다.

건초는 또 다른 구조이다.

그것은 알팔파인 건초를 생산하는 작물을 재배하기 위해 "성장"이라는 정적 방법을 가지고 있다.

알팔파 구조체는 알팔파의 사례에서 건초를 수확하는 방법을 가지고 있다.

마지막으로, 우리는 소에게 먹이를 주는 방법이 있는 "농장"이라는 구조를 추가할 것이다.

사료 방법은 먼저 알팔파를 재배하여 건초를 생산한 다음 건초를 수확하고 마지막으로 소에게 건초를 먹임으로써 구현할 수 있다.

그리고 이제, 나는 내 농장에서 소들에게 먹이를 줄 수 있다.

하지만 나는 더 많은 종류의 동물을 추가하고 싶어.

나는 말과 닭과 같은 다른 동물을 대표하기 위해 더 많은 구조를 추가할 수 있다.

그리고 나는 농장에서 소, 말, 닭에게 먹이를 주고 싶다.

나는 각 유형의 매개 변수를 별도로 받아들이기 위해 피드 방법을 오버로드할 수 있지만, 각 오버로드는 정말 비슷한 구현을 가질 것이다.

이것은 내가 더 많은 종류의 동물을 추가함에 따라 추가 상용구가 될 것이며, 어쨌든 대부분 반복되는 코드이다.

반복적인 구현으로 과부하를 작성하는 자신을 발견한다면, 그것은 일반화하기 위한 신호일 수 있다.

근본적으로, 이러한 구현은 다른 유형의 동물이 기능면에서 비슷하기 때문에 매우 유사하다.

다음 단계는 동물 유형 간의 공통된 능력을 식별하는 것이다.

우리는 모두 어떤 종류의 음식을 먹을 수 있는 동물 유형을 만들었습니다.

각 유형의 동물은 다른 먹는 방식을 가질 것이므로, 먹는 방법의 각 구현에는 행동에 차이가 있을 것이다.

우리가 하고 싶은 것은 추상 코드가 eat 메소드를 호출하고 추상 코드가 작동하는 구체적인 유형에 따라 다르게 작동하도록 하는 것이다.

추상적인 코드가 다른 구체적인 유형에 대해 다르게 행동하는 능력은 "다형성"이라고 불린다.

다형성은 코드가 어떻게 사용되는지에 따라 하나의 코드가 많은 행동을 가질 수 있게 해준다.

적절하게, 다형성 자체는 다른 형태로 나타난다.

첫 번째는 함수 오버로드이며, 동일한 함수 호출은 인수 유형에 따라 다른 것을 의미할 수 있다.

과부하는 실제로 일반적인 해결책이 아니기 때문에 "ad-hoc polymorphism"이라고 불린다.

우리는 방금 과부하가 어떻게 반복적인 코드로 이어질 수 있는지 보았다.

다음은 하위 유형 다형성이며, 슈퍼타입에서 작동하는 코드는 런타임에 코드가 사용하는 특정 하위 유형에 따라 다른 동작을 가질 수 있습니다.

마지막으로, 우리는 제네릭을 사용하여 달성되는 파라메트릭 다형성을 가지고 있다.

일반 코드는 유형 매개 변수를 사용하여 다른 유형으로 작동하는 하나의 코드를 작성할 수 있으며, 구체적인 유형 자체가 인수로 사용됩니다.

우리는 이미 과부하를 배제했으니, 하위 유형 다형성을 사용해 봅시다.

하위 유형 관계를 나타내는 한 가지 방법은 클래스 계층 구조를 사용하는 것이다.

우리는 "동물"이라는 수업을 소개할 수 있다.

다음으로, 우리는 각 동물 유형을 구조체에서 클래스로 바꿀 것이다.

각 특정 동물 클래스는 동물 슈퍼클래스에서 상속되며, 먹는 방법을 무시할 것이다.

이제, 우리는 우리의 모든 특정 동물 유형을 대표할 수 있는 추상적인 기본급 동물을 가지고 있다.

동물 클래스에서 eat를 호출하는 코드는 하위 클래스 구현을 호출하기 위해 하위 유형 다형성을 사용할 것이다.

하지만 우리는 아직 끝나지 않았어.

우리는 여전히 동물의 먹는 방법에 대한 매개 변수 유형을 작성하지 않았고, 이 코드에는 몇 가지 다른 붉은 깃발이 있습니다.

첫째, 클래스를 사용하는 것은 우리가 다른 동물 인스턴스 간에 어떤 상태도 공유될 필요가 없거나 원하지 않더라도 참조 의미론을 강요했다.

이 전략은 또한 기본 클래스의 메소드를 재정의하기 위해 하위 클래스를 요구하지만, 이것을 하는 것을 잊어버리는 것은 런타임까지 잡히지 않을 것이다.

하지만 이 추상화 모델의 더 큰 문제는 각 동물 하위 유형이 다른 유형의 음식을 먹는다는 것이며, 이 의존성은 계급 계층 구조로 표현하기가 정말 어렵다는 것이다.

우리가 취할 수 있는 한 가지 접근 방식은 Any와 같은 덜 구체적인 유형을 받아들이도록 하는 것이다.

하지만 이 전략은 런타임에 올바른 유형이 전달되었는지 확인하기 위해 서브클래스 구현에 의존한다.

그래서, 우리는 각 재정의된 방법에 추가 상용구를 부과했지만, 더 중요한 것은 실수로 잘못된 유형의 음식을 전달할 수 있으며, 런타임에만 잡힐 수 있는 또 다른 버그를 남깁니다.

그래서, 다른 걸 시도해 보자.

우리는 대신 동물 슈퍼클래스에 유형 매개 변수를 도입하여 동물 사료 유형을 유형에 안전한 방식으로 표현할 수 있다.

이 유형 매개 변수는 각 하위 클래스의 특정 피드 유형에 대한 자리 표시자 역할을 합니다.

이 접근 방식을 통해, 식품 유형 매개 변수는 동물 등급의 선언으로 높아져야 한다.

동물이 작동하기 위해 음식이 필요하지만, 음식을 먹는 것은 동물의 핵심 목적이 아니며, 동물과 함께 작동하는 많은 코드는 아마도 음식에 전혀 신경 쓰지 않을 것이기 때문에 이것은 조금 부자연스러워 보인다.

그럼에도 불구하고, 동물 등급에 대한 모든 언급은 음식 유형을 명시해야 한다.

예를 들어, 각 동물 하위 클래스는 상속 절의 괄호 안에 음식 유형을 명시적으로 지정해야 합니다.

동물 클래스의 각 사용 현장의 이 상용구에는 각 동물에 특정한 유형을 더 추가하면 번거로워질 수 있습니다.

그래서, 여기서 우리의 접근 방식 중 어느 것도 좋은 인체 공학이나 올바른 의미를 가지고 있지 않다.

근본적인 문제는 클래스가 데이터 유형이라는 것이며, 우리는 구체적인 유형에 대한 추상적인 아이디어를 나타내기 위해 슈퍼클래스를 복잡하게 만들려고 노력하고 있다.

대신, 우리는 기능이 어떻게 작동하는지에 대한 세부 사항 없이 유형의 기능을 나타내도록 설계된 언어 구성을 원합니다.

동물들은 두 가지 공통된 능력을 가지고 있다.

각 동물은 그 음식의 일부를 섭취하기 위한 수술과 함께 특정 유형의 음식을 가지고 있다.

우리는 그러한 기능을 나타내는 인터페이스를 구축할 수 있다.

스위프트에서, 이것은 프로토콜을 사용하여 이루어진다.

프로토콜은 준수 유형의 기능을 설명하는 추상화 도구이다.

프로토콜을 사용하면 유형이 무엇을 하는지에 대한 아이디어를 구현 세부 사항과 분리할 수 있습니다.

유형이 무엇을 하는지에 대한 아이디어는 인터페이스를 통해 표현된다.

동물의 기능을 프로토콜 인터페이스로 번역해 봅시다.

프로토콜의 이름은 우리가 설명하고 있는 유형의 범주를 나타내기 때문에, 나는 이 프로토콜을 "동물"이라고 불렀다.

각 기능은 프로토콜 요구 사항에 매핑될 것이다.

특정 유형의 음식은 동물 프로토콜의 관련 유형에 매핑될 것이다.

유형 매개 변수와 마찬가지로, 관련 유형은 구체적인 유형의 자리 표시자 역할을 한다.

관련 유형을 특별하게 만드는 것은 그들이 프로토콜을 준수하는 특정 유형에 의존한다는 것이다.

이 관계는 보장되므로, 특정 유형의 동물의 각 사례는 항상 같은 종류의 음식을 가지고 있다.

다음으로, 음식을 소비하는 작업은 방법으로 매핑될 것이다.

이 방법은 "먹기"라고 불리며, 동물의 사료 유형의 매개 변수를 받아들인다.

프로토콜에는 이 방법의 구현이 없으며, 이를 구현하려면 구체적인 동물 유형이 필요합니다.

이제 우리는 동물 프로토콜을 가지고 있으므로, 각 콘크리트 동물 유형을 그것에 맞게 만들 수 있습니다.

선언이나 확장에서 프로토콜 적합성으로 구체적인 유형에 주석을 달 수 있습니다.

프로토콜은 클래스에 국한되지 않으므로 구조체, 열거형 및 행위자와 함께 프로토콜을 사용할 수 있습니다.

이 적합성 주석을 작성하면, 컴파일러는 구체적인 유형이 각 프로토콜 요구 사항을 구현하는지 확인할 것입니다.

각 동물 유형은 먹는 방법을 구현해야 하며, 컴파일러는 매개 변수 목록에서 사용되기 때문에 사료 유형이 무엇인지 추론할 수 있다.

피드 유형은 또한 유형 별칭을 사용하여 명시적으로 작성할 수 있습니다.

우리는 프로토콜 인터페이스를 사용하여 동물의 공통 기능을 성공적으로 식별하고 그 능력을 표현했습니다.

이제, 우리는 일반 코드를 작성하기 시작할 수 있다.

우리는 농장에서 사료 방법을 구현하기 위해 동물 프로토콜을 사용할 수 있다.

우리는 모든 구체적인 동물 유형에 적합한 하나의 구현을 작성하고 싶습니다.

우리는 파라메트릭 다형성을 사용하고 메서드가 호출될 때 구체적인 유형으로 대체될 유형 매개 변수를 도입할 것입니다.

유형 매개 변수는 괄호 안의 함수 이름 뒤에 쓰여진다.

일반 변수와 함수 매개 변수와 마찬가지로, 원하는 대로 유형 매개 변수의 이름을 지정할 수 있습니다.

그리고 다른 유형과 마찬가지로, 이름을 사용하여 함수 서명 전반에 걸쳐 유형 매개 변수를 참조할 수 있습니다.

여기서, 나는 "A"라는 유형 매개 변수를 선언했고, 동물 함수 매개 변수의 유형으로 A를 사용했다.

우리는 항상 구체적인 동물 유형이 동물 프로토콜을 준수하기를 원하므로, 프로토콜 준수로 유형 매개 변수에 주석을 달 수 있습니다.

프로토콜 적합성은 괄호로 작성하거나, 다른 유형 매개 변수 간의 관계를 지정할 수 있는 후행 "어디" 절로 작성할 수 있습니다.

명명된 유형 매개 변수와 후행 "어디" 절은 정교한 요구 사항과 유형 관계를 작성할 수 있기 때문에 정말 강력합니다.

하지만 대부분의 일반적인 기능은 이 일반성을 필요로 하지 않는다.

사료 방법에 집중합시다.

유형 매개 변수 A는 매개 변수 목록에 한 번 나타나며, "어디" 절은 유형 매개 변수에 대한 적합성 요구 사항을 나열합니다.

이 경우, 유형 매개 변수의 이름을 지정하고 "어디" 절을 사용하면 메소드가 실제보다 더 복잡해 보입니다.

이 일반적인 패턴은 정말 흔하기 때문에, 그것을 표현하는 더 간단한 방법이 있다.

유형 매개 변수를 명시적으로 작성하는 대신, 우리는 "일부 동물"을 작성하여 프로토콜 적합성 측면에서 이 추상적인 유형을 표현할 수 있습니다.

이 선언은 이전 선언과 동일하지만, 불필요한 유형 매개 변수 목록과 "어디" 절은 사라졌습니다. 왜냐하면 우리는 그들이 제공하는 표현력이 필요하지 않았기 때문입니다.

"일부 동물"을 쓰는 것은 구문 소음을 줄이고 매개 변수 선언에 동물 매개 변수에 대한 의미 정보를 포함하기 때문에 더 간단합니다.

동물 구문을 분해해 봅시다.

"일부 동물"의 "일부"는 당신이 함께 작업하고 있는 특정 유형이 있음을 나타냅니다.

"일부" 키워드에는 항상 적합성 요구 사항이 뒤따른다.

이 경우, 특정 유형은 동물 프로토콜을 준수해야 하며, 이를 통해 매개 변수 값에 대한 동물 프로토콜의 요구 사항을 사용할 수 있습니다.

"일부" 키워드는 매개 변수와 결과 유형에 사용될 수 있다.

이전에 SwiftUI 코드를 작성한 적이 있다면, 이미 "일부 보기"를 사용하여 결과 위치에 "일부"를 사용했습니다.

"일부 뷰"의 결과 유형은 정확히 같은 개념이다.

SwiftUI 보기에서 본문 속성은 특정 유형의 보기를 반환하지만, 본문 속성을 사용하는 코드는 특정 유형이 무엇인지 알 필요가 없습니다.

특정 추상적인 유형의 개념을 더 잘 이해하기 위해 한 걸음 물러서자.

특정 구체적인 유형의 자리 표시자를 나타내는 추상 유형은 불투명한 유형이라고 불린다.

대체되는 특정 콘크리트 유형은 기본 유형이라고 불린다.

불투명한 유형의 값의 경우, 기본 유형은 값의 범위에 대해 고정됩니다.

이렇게 하면, 값을 사용하는 일반 코드는 값에 액세스할 때마다 동일한 기본 유형을 얻을 수 있습니다.

"일부" 키워드와 괄호 안의 명명된 유형 매개 변수를 사용하는 유형은 모두 불투명한 유형을 선언합니다.

불투명한 유형은 입력과 출력 모두에 사용할 수 있으므로 매개 변수 위치 또는 결과 위치에서 선언할 수 있습니다.

함수 화살표는 이 위치들 사이의 경계선이다.

불투명한 유형의 위치는 프로그램의 어느 부분이 추상적인 유형을 보고 프로그램의 어느 부분이 구체적인 유형을 결정하는지를 결정한다.

명명된 유형 매개 변수는 항상 입력 측에서 선언되므로 호출자는 기본 유형을 결정하고 구현은 추상 유형을 사용합니다.

일반적으로, 불투명한 매개 변수 또는 결과 유형에 대한 값을 제공하는 프로그램의 일부는 기본 유형을 결정하고, 값을 사용하는 프로그램의 부분은 추상 유형을 본다.

매개 변수와 결과 값에 대한 우리의 직관에 따라 이것이 어떻게 작동하는지 살펴봅시다.

기본 유형은 값에서 추론되기 때문에, 기본 유형은 항상 값과 같은 장소에서 온다.

지역 변수의 경우, 기본 유형은 할당의 오른쪽에 있는 값에서 추론된다.

이것은 불투명한 유형의 지역 변수가 항상 초기 값을 가져야 한다는 것을 의미합니다. 그리고 당신이 하나를 제공하지 않으면, 컴파일러는 오류를 보고할 것입니다.

기본 유형은 변수의 범위에 대해 고정되어야 하므로, 기본 유형을 변경하려고 하면 오류가 발생합니다.

불투명한 유형을 가진 매개 변수의 경우, 기본 유형은 호출 사이트의 인수 값에서 추론됩니다.

매개 변수 위치에서 "일부"를 사용하는 것은 스위프트 5.7에서 새로운 것이다.

기본 유형은 매개 변수의 범위에 대해서만 고정되어야 하므로, 각 호출은 다른 인수 유형을 제공할 수 있습니다.

불투명한 결과 유형의 경우, 기본 유형은 구현의 반환 값에서 추론됩니다.

불투명한 결과 유형을 가진 메서드 또는 계산된 속성은 프로그램의 어느 곳에서나 호출될 수 있으므로, 이 명명된 값의 범위는 전역입니다.

이것은 기본 반환 유형이 모든 반환 문에서 동일해야 한다는 것을 의미합니다. 그렇지 않은 경우, 컴파일러는 기본 반환 값이 일치하지 않는 유형이 있다는 오류를 보고할 것입니다.

불투명한 SwiftUI 뷰의 경우, ViewBuilder DSL은 각 브랜치에 대해 동일한 기본 반환 유형을 갖도록 control-flow 문을 변환할 수 있습니다.

그래서 이 경우, 우리는 ViewBuilder DSL을 사용하여 문제를 해결할 수 있습니다.

메소드에 @ViewBuilder 주석을 작성하고 반환 문을 제거하면 ViewBuilder 유형으로 결과를 만들 수 있습니다.

feedAnimal 방법으로 돌아가자.

다른 곳에서는 불투명한 유형을 참조할 필요가 없기 때문에 매개 변수 목록에서 "일부"를 사용할 수 있습니다.

함수 서명에서 불투명한 유형을 여러 번 참조해야 할 때, 이름 유형 매개 변수가 유용할 때 유용합니다.

예를 들어, 우리가 "해비타트"라고 불리는 동물 프로토콜에 또 다른 관련 유형을 추가한다면, 우리는 주어진 동물을 위해 농장에 서식지를 건설할 수 있기를 원할 것이다.

이 경우, 결과 유형은 특정 동물 유형에 따라 다르므로, 매개 변수 유형과 반환 유형에서 유형 매개 변수 A를 사용해야 합니다.

불투명한 유형을 여러 번 참조해야 하는 또 다른 일반적인 장소는 일반 유형입니다.

코드는 종종 일반 유형에 대한 유형 매개 변수를 선언하고, 저장된 속성에 대한 유형 매개 변수를 사용하고, 다시 멤버와이즈 이니셜라이저에서 사용합니다.

다른 맥락에서 일반 유형을 참조하려면 괄호 안에 유형 매개 변수를 명시적으로 지정해야 합니다.

선언의 앵글 괄호는 일반 유형을 사용하는 방법을 명확히 하는 데 도움이 될 수 있으므로, 불투명한 유형은 항상 일반 유형의 이름을 지정해야 합니다.

이제, 피드 방법의 구현을 구축해 봅시다.

우리는 동물 매개 변수의 유형을 사용하여 사료 관련 유형을 통해 성장하기 위해 작물 유형에 접근할 수 있습니다.

우리는 이러한 유형의 피드를 생산하는 작물의 인스턴스를 얻기 위해 Feed.grow()를 호출할 것이다.

다음으로, 우리는 작물에서 농산물을 수확해야 하며, 이는 "수확"이라는 작물 유형에서 제공하는 방법을 호출하여 할 수 있습니다.

그리고 마지막으로, 우리는 이 농산물을 동물에게 먹일 수 있다.

기본 동물 유형이 고정되어 있기 때문에, 컴파일러는 다양한 방법 호출에서 식물 유형, 생산 유형 및 동물 유형 간의 관계를 알고 있다.

이러한 정적인 관계는 우리가 동물에게 잘못된 종류의 음식을 먹이는 실수를 저지르는 것을 방지한다.

만약 우리가 이 동물에게 올바른 음식 유형이 보장되지 않는 유형을 사용하려고 시도한다면, 컴파일러는 우리에게 말할 것이다.

동물 사료 유형과 식물 간의 관계를 표현하기 위해 다른 농장 프로토콜이 어떻게 만들어졌는지 알아보려면, "스위프트의 디자인 프로토콜 인터페이스"를 확인하세요.

마지막으로, 모든 동물에게 먹이를 주는 방법을 추가해 봅시다.

배열을 받아들이는 feedAll이라는 메소드를 추가할 것이다.

요소 유형이 동물 프로토콜을 준수해야 한다는 것을 알고 있지만, 배열이 다른 유형의 동물을 저장할 수 있기를 바랍니다.

어떤 동물이 여기서 우리를 도울 수 있는지 보자.

"일부"에는 변화할 수 없는 특정 기본 유형이 있다.

기본 유형이 고정되어 있기 때문에, 배열의 모든 요소는 동일한 유형을 가져야 한다.

그래서, 일부 동물의 배열은 옳은 것을 표현하지 않는다. 왜냐하면 나는 다른 동물 유형을 수용할 수 있는 배열을 원하기 때문이다.

여기서, 우리는 모든 종류의 동물을 대표할 수 있는 슈퍼타입이 정말 필요하다.

우리는 "모든 동물"이라고 써서 임의의 유형의 동물을 표현할 수 있다.

"Any" 키워드는 이 유형이 임의의 유형의 동물을 저장할 수 있으며, 기본 유형의 동물은 런타임에 따라 달라질 수 있음을 나타냅니다.

"일부" 키워드와 마찬가지로, "any" 키워드에는 항상 적합성 요구 사항이 뒤따른다.

모든 동물은 모든 구체적인 동물 유형을 동적으로 저장할 수 있는 단일 정적 유형으로, 값 유형과 함께 하위 유형 다형성을 사용할 수 있습니다.

이 유연한 저장을 허용하기 위해, 모든 동물 유형은 메모리에 특별한 표현을 가지고 있다.

당신은 이 표현을 상자처럼 생각할 수 있습니다.

때때로, 가치는 상자 안에 직접 들어갈 만큼 충분히 작다.

그리고 다른 값은 상자에 비해 너무 크기 때문에 값은 다른 곳에 할당되어야 하며, 상자는 그 값에 대한 포인터를 저장합니다.

모든 구체적인 동물 유형을 동적으로 저장할 수 있는 정적 유형은 공식적으로 실존적 유형이라고 불린다.

그리고 다른 구체적인 유형에 대해 동일한 표현을 사용하는 전략은 "유형 삭제"라고 불린다.

콘크리트 유형은 컴파일 타임에 지워진다고 하며, 콘크리트 유형은 런타임에만 알려져 있다.

실존적 유형의 이 두 사례는 모든 동물은 같은 정적 유형을 가지고 있지만, 다른 동적 유형을 가지고 있다.

유형 삭제는 다른 동물 값 간의 유형 수준 구별을 제거하여 다른 동적 유형을 가진 값을 동일한 정적 유형으로 상호 교환하여 사용할 수 있습니다.

우리는 유형 삭제를 사용하여 값 유형의 이기종 배열을 작성할 수 있으며, 이는 정확히 우리가 feedAll 메소드에 대해 원하는 것입니다.

그래서 우리는 모든 동물의 배열을 매개 변수 유형으로 사용할 것이다.

관련 유형의 프로토콜에 "any" 키워드를 사용하는 것은 Swift 5.7에서 새로운 것이다.

feedAll 방법을 구현하기 위해, 우리는 먼저 동물의 배열을 반복할 것이다.

각 동물에 대해, 우리는 동물 프로토콜에서 먹는 방법을 부르고 싶다.

이 방법을 호출하려면, 이 반복에서 기본 동물에 대한 특정 사료 유형을 얻어야 합니다.

하지만 우리가 어떤 동물에게 먹으려고 하자마자, 컴파일러 오류가 발생할 것이다.

우리는 특정 동물 유형 간의 유형 수준의 구별을 제거했기 때문에, 관련 유형을 포함하여 특정 동물 유형에 의존하는 모든 유형 관계도 제거했습니다.

그래서, 우리는 이 동물이 어떤 종류의 먹이를 기대하는지 알 수 없다.

유형 관계에 의존하기 위해, 우리는 특정 유형의 동물이 고정된 맥락으로 돌아가야 한다.

어떤 동물에게 직접 먹으라고 부르는 대신, 우리는 어떤 동물을 받아들이는 사료 방법을 불러야 한다.

이제, 모든 동물은 일부 동물과 다른 유형이지만, 컴파일러는 기본 값을 언박싱하고 일부 동물 매개 변수에 직접 전달하여 모든 동물의 인스턴스를 일부 동물로 변환할 수 있습니다.

이 언박싱 인수 기능은 Swift 5.7에서 새로운 것이다.

언박싱은 컴파일러가 상자를 열고 내부에 저장된 값을 꺼내는 것으로 생각할 수 있습니다.

일부 동물 매개 변수의 범위에 대해, 그 값은 고정된 기본 유형을 가지고 있으므로, 우리는 관련 유형에 대한 액세스를 포함하여 기본 유형에 대한 모든 작업에 액세스할 수 있습니다.

이것은 우리가 필요할 때 유연한 스토리지를 선택할 수 있게 해주면서, 기능의 범위에 대한 기본 유형을 수정하여 정적 유형 시스템의 완전한 표현력을 가진 맥락으로 돌아갈 수 있기 때문에 정말 멋지다.

그리고 대부분의 경우, 어떤 동물에서 프로토콜 메소드를 호출하는 것이 실제로 기본 유형의 메소드를 호출하는 것과 유사하게 당신이 기대하는 방식으로 작동하기 때문에 언박싱에 대해 생각할 필요가 없습니다.

그래서, 우리는 각 동물을 각 반복에서 특정 동물에게 먹이를 주기 위해 적절한 작물을 재배하고 수확할 수 있는 사료 방법으로 전달할 수 있다.

이 과정을 통해, 우리는 "일부"와 "모든"가 다른 능력을 가지고 있다는 것을 보았다.

"일부"로, 기본 유형은 고정되어 있다.

이를 통해 일반 코드의 기본 유형에 대한 유형 관계에 의존할 수 있으므로 작업 중인 프로토콜의 API 및 관련 유형에 완전히 액세스할 수 있습니다.

임의의 콘크리트 유형을 저장해야 할 때 "any"를 사용하세요.

"Any"는 이질적인 컬렉션을 나타내고, 기본 유형의 부재를 나타내고, 옵션을 사용하고, 추상화를 구현 세부 사항으로 만들 수 있는 유형 삭제를 제공합니다.

일반적으로, 기본적으로 "some"을 쓰고, 임의의 값을 저장해야 한다는 것을 알 때 "some"을 "any"로 변경하세요.

이 접근 방식을 사용하면, 제공하는 스토리지 유연성이 필요할 때만 유형 삭제 비용과 의미 제한 사항을 지불하게 됩니다.

이 워크플로우는 돌연변이가 필요하다는 것을 알기 전까지는 기본적으로 let-constants를 작성하는 것과 비슷합니다.

이 세션에서, 우리는 코드가 진화하고 더 많은 기능을 확보함에 따라 코드를 일반화하는 워크플로우를 살펴보았다.

우리는 구체적인 유형을 쓰는 것으로 시작했다.

코드가 더 많은 기능을 얻음에 따라, 우리는 다른 구체적인 유형 간의 반복을 발견했다.

거기에서, 우리는 공통의 기능을 확인하고 프로토콜을 사용하여 일반화했다.

마지막으로, 우리는 "some"과 "any"를 사용하여 추상적인 코드를 작성했고, 더 표현적인 코드를 위해 "some"을 선호하는 것에 대해 논의했다.

프로토콜을 만들고 유형 삭제를 이해하는 데 더 깊이 들어가려면, "스위프트에서 프로토콜 인터페이스 설계"를 확인하세요.

저와 함께 해주셔서 감사드리며 멋진 WWDC를 보내세요.

♪