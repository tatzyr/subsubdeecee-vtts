10051

♪ ♪

August Joki: 안녕하세요, 저는 watchOS의 소프트웨어 엔지니어인 August Joki입니다. WidgetKit 합병증으로 더 나아가는 방법을 보여드리기 위해 왔습니다.

멋진 합병증과 위젯을 보셨기를 바랍니다: WidgetKit에서 합병증의 기본 사항을 다루는 Reloaded talk 먼저.

이 강연은 시계 화면의 합병증과 관련하여 다룬 개념을 확장한다.

그리고 내 WWDC 2020 강연: SwiftUI에서 컴플리케이션을 빌드하면 컴플리케이션에서 색조와 SwiftUI 드로잉에 대한 자세한 내용을 다룹니다.

이 강연에서는 watchOS 고유의 WidgetKit 기능과 기존 ClockKit 컴플리케이션을 WidgetKit으로 마이그레이션하는 방법에 대해 논의할 것입니다.

저는 이 강연을 통해 커피 트래커 샘플 앱에서 영감을 받아 예시로 사용했습니다.

이 앱은 하루 종일 마시는 커피, 차, 탄산음료의 수를 기록하고 시간이 지남에 따라 몸에 있는 카페인의 양을 추적합니다.

watchOS만의 독특한 것부터 시작합시다.

iOS 16에서는 휴대폰의 잠금 화면에 컴플리케이션 스타일 위젯을 가져왔고 watchOS 9에서는 시계의 컴플리케이션에 위젯킷을 가져왔습니다.

시계 페이스에는 시계 화면의 모서리를 위한 독특한 컴플리케이션 프레젠테이션이 있습니다.

그리고 그것을 설명하기 위해서는 accessoryCorner라는 독특한 WidgetKit 제품군이 필요합니다.

그 독특한 프레젠테이션의 일부는 SwiftUI 보기에 의해 지정된 보조 콘텐츠이지만, 콘텐츠의 일부로 렌더링되지는 않습니다.

대신, 그것은 시계 화면으로 렌더링된다.

모서리의 원형 부분은 표준 SwiftUI 렌더링이며 보조 콘텐츠는 모서리의 곡선 부분입니다.

또는 인포그래프 얼굴의 다이얼에서.

accessoryInline 제품군은 시계 페이스에서 독특한 동작을 가지고 있다.

그것은 얼굴에 따라 렌더링되는 여러 가지 방법이 있다.

때로는 평평하고, 때로는 다이얼과 일치하도록 구부러졌다.

커피 추적기 앱이 WidgetKit을 사용하도록 업데이트되는 방법을 살펴봐 이러한 독특한 기능을 지원하는 방법에 대해 이야기해 봅시다.

iOS 16의 세 가지 새로운 컴플리케이션 스타일의 위젯 제품군인 AccessoryRectangular, accessoryCircular 및 accessoryInline 외에도 watchOS 9에는 accessoryCorner라는 네 번째 제품군이 있습니다.

액세서리 코너는 하단 모서리에 표시된 지도와 심박수 컴플리케이션과 같은 큰 원형 콘텐츠로 표시되거나, 상단 모서리에 표시된 커피 트래커 및 문페이즈 컴플리케이션과 같은 곡선 라벨이나 게이지가 있는 작은 원형 콘텐츠로 표시될 수 있습니다.

내부 보조 콘텐츠가 표시되는지 여부를 제어하기 위해, watchOS 9는 사용할 수 있는 새로운 보기 수정자를 추가했으며, 지금 보여드리겠습니다.

내 커피 추적기 앱의 코너 컴플리케이션을 만드는 것을 살펴봅시다.

더 큰 원형 콘텐츠 스타일부터 시작하여, 저는 SF 기호와 배경이 있는 ZStack을 가지고 있습니다.

SwiftUI 콘텐츠는 다른 코너 컴플리케이션의 디자인과 일치하도록 자동으로 원으로 잘립니다.

내부 곡선 콘텐츠를 추가하기 위해, 우리는 watchOS 9 위젯 라벨 보기 수정자를 사용합니다.

시계 화면은 수정자의 내용을 추출하여 가족과 시계 화면의 스타일에 적합한 컨트롤을 그립니다.

그리고 원형 콘텐츠는 공간을 만들기 위해 자동으로 축소된다.

accessoryCorner의 경우 위젯의 라벨에서 SwiftUI 텍스트, 게이지 또는 progressView를 지정할 수 있습니다.

AccessoryCorner는 위젯라벨을 지원하는 유일한 가족이 아니다.

그것이 accessoryCircular 제품군에서 어떻게 사용되는지 살펴봅시다.

인포그래프 시계 페이스에는 코너 컴플리케이션 외에도 다이얼 안에 네 개의 원형 컴플리케이션이 있습니다.

중간 상단에 있는 내 커피 트래커 원형 컴플리케이션은 우리가 방금 본 코너 컴플리케이션과 매우 비슷해 보이지만, 다이얼에 텍스트가 있다.

지금 그 문자를 추가하는 방법을 보여줄게.

내 원형 컴플리케이션 디자인을 위해, 나는 내 코너 컴플리케이션의 위젯 라벨에 있는 게이지를 전면과 중앙으로 옮기는 것이 더 적절하다고 생각했다.

인포그래프의 상단 중간 위치를 활용하기 위해, 원형 콘텐츠에 맞지 않는 더 긴 베젤 영역에 추가 텍스트를 표시하기 위해 게이지에 위젯 라벨을 추가합니다.

하지만 이제 나는 메인 뷰와 그 위의 텍스트 사이에 중복 정보가 있다.

나는 내 코너 컴플리케이션에서 원형 내용을 그 잘 생긴 커피 컵 SF 심볼로 전환하여 그것을 정리할 수 있지만, 베젤이 없는 원형 컴플리케이션을 보여주는 얼굴로 전환할 때, 나는 모든 카페인 정보를 잃어버렸다.

운 좋게도, 두 경우 모두 합병증이 작동하도록 추가할 수 있는 API가 있습니다.

내 보기에 showsWidgetLabel이라는 환경 속성을 추가하기 위해 합병증을 업데이트합니다.

이것은 합병증이 위젯 라벨의 내용을 보여주는 시계 화면의 위치에 있을 때마다 사실일 것이다.

그런 다음 showsWidgetLabel의 값에 따라 콘텐츠를 변경할 수 있으므로 각 합병증 지점에서 적절한 수준의 정보를 얻을 수 있습니다.

나는 방금 accessoryCircular 가족이 시계 페이스에 나타날 수 있는 두 가지 다른 방법을 시연했고, 당신이 알아야 할 한 가지 방법이 더 있습니다.

초대형 시계 화면은 오랫동안 사람들이 초대형 형식으로 시간을 볼 수 있는 좋은 방법이었다.

그리고 그것은 하나의 큰 원형 합병증을 지원합니다.

엑스트라 라지 페이스는 accessoryCircular 제품군을 사용하고 얼굴 스타일에 맞게 콘텐츠를 자동으로 확장합니다.

참고: 이 얼굴은 하나의 큰 합병증을 갖도록 설계되었기 때문에, 증가된 캔버스 크기를 합병증을 조밀하게 포장할 수 있는 기회로 사용하지 마십시오.

내용은 일반 원형 가족과 동일해야 하며, 더 커야 한다.

앞서 언급했듯이, 시계 페이스에 사용되는 두 개의 위젯 제품군이 더 있습니다: accessoryRectangular와 accessoryInline.

위젯 라벨을 보여주는 직사각형 합병증이 있는 얼굴은 없습니다.

그리고 accessoryInline 가족은 이미 위젯라벨 역할을 한다.

시계 화면은 인라인 콘텐츠에서 이미지와 텍스트를 추출하여 얼굴 모양과 일치하도록 렌더링합니다.

다음은 이주입니다.

마이그레이션에는 두 부분이 있습니다: WidgetKit에서 기존 ClockKit 컴플리케이션 코드를 다시 작성하는 것; 그리고 사람들이 시계 페이스에 설정한 컴플리케이션을 업그레이드하는 방법을 시스템이 알 수 있도록 매핑을 제공합니다.

WidgetKit을 채택하면 시스템은 ClockKit 데이터 소스에 새로운 콘텐츠를 요청하는 것을 중단하고 얼굴 편집 선택기에 새로운 합병증만 표시합니다.

WidgetKit을 시계에 가져오는 것뿐만 아니라, watchOS 9는 풍부한 합병증을 지원하기 위해 모든 얼굴을 업데이트하여 합병증 가족의 수를 12개에서 4개로 극적으로 줄일 수 있었습니다.

직사각형 및 코너는 액세서리 직사각형 및 액세서리 코너에 직접 매핑됩니다.

세 개의 그래픽 원형 스타일의 ClockKit 제품군은 이제 단일 액세서리Circular WidgetKit 제품군입니다.

그리고 accessoryInline 제품군은 오래된 utilitarianSmallFlat 또는 utilitarianLarge가 있던 곳에서 사용됩니다.

그리고 utilitarian Small이었던 많은 장소들이 accessoryCorner 제품군을 사용하도록 업데이트되었습니다.

WidgetKit을 사용하면 SwiftUI 뷰와 상태 기반 레이아웃이 ClockKit의 템플릿을 대체했습니다.

위젯킷에는 여전히 친숙한 타임라인과 항목이 있습니다.

사실, 그들은 원래 ClockKit 자체에서 영감을 받았는데, 이는 컴플리케이션 데이터 소스가 정적 또는 인텐트 기반 WidgetKit 구성 중 하나로 멋지게 마이그레이션된다는 것을 의미합니다.

WidgetKit이 지원하는 구성 유형과 일반 가족 지원에 대한 자세한 내용은 원래 WidgetKit 토크를 참조하십시오.

우리는 사람의 합병증이 시스템에 의해 자동으로 마이그레이션될 수 있도록 ClockKit에 마지막 API를 추가했습니다.

이를 통해 이미 시계 페이스에 있는 기존 컴플리케이션을 사용자 상호 작용 없이 새로운 WidgetKit 기반 컴플리케이션으로 자동으로 업그레이드할 수 있습니다.

앱이 시계에서 업데이트되면, 워치 페이스는 앱 번들에 위젯이 있는지 확인합니다.

발견되면, ClockKit 컴플리케이션 데이터 소스를 실행하여 기존 컴플리케이션에 대한 마이그레이션을 생성합니다.

이 시점부터, CLKComplicationDataSource는 사람이 ClockKit 합병증이 있는 공유 얼굴을 받을 때만 마이그레이션을 요청하기 위해 실행됩니다.

이 시스템은 새로운 얼굴이 공유될 때마다 마이그레이션을 요청할 것이므로, 일관된 경험을 위해 마이그레이션을 일관되게 유지해야 합니다.

아름다운 WidgetKit 컴플리케이션 생성을 마치면, 새로운 속성인 widgetMigrator를 추가하여 새로운 Migrator 프로토콜을 준수하는 개체를 제공할 수 있습니다.

당신의 컴플리케이션 데이터 소스 자체 또는 당신이 제공하는 다른 유형이든.

CLKComplication WidgetMigrator 프로토콜에는 기존 CLKComplicationDescriptors에서 시계 페이스 위젯 마이그레이션 구성을 제공하는 단일 기능이 있습니다.

새로운 API를 채택하는 가장 간단한 방법은 데이터 소스가 새로운 마이그레이션 프로토콜을 준수하도록 하는 것입니다.

WidgetKit 컴플리케이션이 정적 구성을 사용하는 경우, 정적 마이그레이션 구성을 제공합니다.

그리고 위젯 컴플리케이션에서 인텐트를 사용하면 동등한 마이그레이션 구성이 있습니다.

인텐트 기반 마이그레이션 구성을 제공하는 경우, 워치 앱과 위젯 확장에 인텐트 정의를 포함해야 하므로 두 곳에서 인텐트 개체를 모두 만들 수 있습니다.

WidgetKit은 시계를 복잡하게 만드는 새롭고 창의적인 방법을 가능하게 하며, 경험을 극적으로 단순화합니다.

봐줘서 고마워.