110370

♪ ♪

안녕하세요, 여러분.

제 이름은 아드리안이고, LLDB로 훌륭한 디버깅 경험을 위해 프로젝트를 설정하는 방법에 대해 이야기하겠습니다.

LLDB는 Xcode와 함께 제공되는 기본 디버깅 기술이다.

LLDB를 사용하면 애플리케이션에서 중단점을 설정하고, 실행을 일시 중지하고, 변수와 객체의 상태를 검사하고, 코드를 탐색할 수 있습니다.

LLDB는 코드가 무엇을 하고 있는지 이해하는 데 도움을 줄 수 있으며 코드의 동작이 기대와 다른 지점을 찾을 수 있습니다.

그것은 코드를 이해하고 탐구하기 위한 강력한 도구이다.

LLDB에 대해 더 알고 싶다면, WWDC21의 "중지점 개선 발견"과 같은 이전 비디오를 확인하세요.

오늘 우리는 스위프트 코드 디버깅에 독특한 영향을 미치는 몇 가지 고급 워크플로우를 살펴볼 것입니다.

아마도 당신은 타사 프레임워크를 앱에 통합하고 있을 것입니다.

아마도 당신의 앱과 팀은 대부분의 코드가 지속적인 통합 시스템에 의해 구축되는 지점까지 성장했을 것입니다.

아마도 당신은 회사의 인프라와 통합하기 위해 맞춤형 빌드 시스템을 사용하고 있을 것입니다.

아마도 당신은 다른 소프트웨어 개발자들을 위한 소프트웨어를 만들고 있을 것입니다.

아니면 그냥 LLDB에 대해 더 알고 싶으세요.

내 목표는 LLDB가 어떻게 작동하는지, 그리고 작동하기 위해 빌드 시스템에서 어떤 정보가 필요한지에 대한 더 나은 이해를 제공하는 것이다.

나는 여기에 우리가 실행 예시로 사용할 작은 프로젝트가 있다.

저는 컴파일러 엔지니어이고, 게임을 좋아하기 때문에, 여가 시간에 텍스트 모험을 위한 파서를 작성합니다.

이것은 내가 최근에 순수한 스위프트에서 시작한 것이다.

내가 지금까지 가진 걸 보여줄게.

그 게임은 텍스트 인터페이스를 사용하기 때문에 터미널에서 실행하고 있다.

모든 좋은 모험과 마찬가지로, 우리는 재고를 확인하는 것으로 시작할 것이다.

이 게임은 현대적인 환경에서 일어난다.

내가 아이폰을 가지고 있는 걸 봤어.

다음으로, 우리 주변을 살펴봅시다.

흠, 이 센서는 흥미로워 보여.

센서에서 아이폰을 사용할 수 있을까요?

내가 아이폰을 떨어뜨렸어?

어, 그건 내가 너에게 보여주고 싶었던 게 아니야.

내 생각에 내 게임에 버그가 있는 것 같아.

이게 디버거 토크라는 게 다행이야.

파서에서 중단점을 설정하고 명령을 다시 실행합시다.

우리는 먼저 그 명령이 올바르게 읽혔는지 확인해야 한다.

"단어" 변수에는 토큰화된 명령이 포함되어 있습니다.

아, 이건 예상대로 되지 않았어.

여기서 무슨 일이 일어나고 있는지 모르겠어.

어제 나는 문제 없이 디버거를 사용하고 있었고, 어젯밤에 터미널에서 텍스트를 스타일링하기 위해 이 UI 프레임워크를 통합했다.

그 프레임워크의 개발자들은 프레임워크의 야간 빌드를 만드는 지속적인 통합 시스템을 가지고 있으며, 나는 최신 프레임워크에 대해 직접 연결하고 있다.

이 프레임워크가 내 디버깅 문제와 관련이 있는지 궁금하다.

예를 들어, 나는 디버그 빌드를 명시적으로 다운로드했음에도 불구하고 프레임워크의 소스 코드에 들어갈 수 없다는 것을 이미 알아차렸다.

그거 봐.

분해만 보여.

거기서 무슨 일이 일어났는지 이해하려고 노력하자, 그리고 내가 왜 소스 코드를 볼 수 없었는지 알아내는 것부터 시작하자.

LLDB는 소스 코드를 보여주기 위해 무엇이 필요합니까?

컴파일러가 함수를 컴파일할 때, 기계 코드를 생성합니다.

그리고 그것은 디버거를 위한 빵 부스러기를 남기므로 실행 파일의 주소는 소스 파일과 줄 번호에 매핑될 수 있으며 그 반대의 경우도 마찬가지입니다.

이 빵 부스러기를 디버그 정보라고 부른다.

애플 플랫폼에서 디버그 정보는 객체 파일에 저장됩니다.

보관 및 배포를 위해, 디버그 정보는 .dSYM 번들에 연결될 수 있습니다.

디버그 정보 링커는 dsymutil이라고 불린다.

LLDB는 스포트라이트를 사용하여 .dSYM 번들을 찾기 때문에, 디스크의 위치와 관련하여 매우 유연하다.

이제 디버그 정보가 어떻게 작동하는지 알았으니, 예시로 돌아가 봅시다.

먼저, LLDB가 실제로 프레임워크의 dSYM을 찾았는지 확인해 봅시다.

우리는 이미지 목록 명령으로 이것을 할 수 있다.

UI 프레임워크는 "터미널 인터페이스"라고 불린다.

네, LLDB는 프레임워크에 대한 dSYM을 찾았습니다.

그것은 디버그 정보에 접근할 수 있다는 것을 의미한다.

우리는 현재 주소에 대한 더 많은 정보를 얻기 위해 "이미지 조회"를 사용할 수 있습니다.

그건 그렇고, 다양한 옵션에 대해 더 알고 싶다면, LLDB는 훌륭한 내장 도움말을 가지고 있습니다.

아, 나는 왜 소스 코드가 없는지 알 것 같아: 이 소스 경로는 내 로컬 컴퓨터에 있는 곳이 아니라 소스가 빌드 서버에 있던 곳을 가리키고 있어.

우리는 그걸 고칠 수 있어.

LLDB에는 이러한 경로를 리디렉션하는 데 사용할 수 있는 소스 맵이 내장되어 있습니다.

우리는 지금 당장 명령을 입력할 수 있지만, 나는 차라리 이 변화를 더 영구적으로 만들고 싶다.

제품, 구성표, 구성표 편집으로 이동하거나 재생 버튼을 옵션으로 클릭하여 불러올 수 있는 구성표 편집기에서 프로젝트별 LLDB init 파일을 정의할 수 있습니다.

나는 이미 이 프로젝트를 위해 하나를 추가했다.

이제 LLDB를 설정했으니, 프로젝트를 다시 실행합시다.

그리고 우리는 소스 코드가 있어.

LLDB는 "sets set target.source-map"을 사용하여 소스 경로를 다시 매핑할 수 있습니다.

이 명령을 프로젝트의 .lldbinit 파일에 넣어 자동으로 실행할 수 있습니다.

또는, 각 .dSYM 번들에는 경로 접두사 리매핑 사전을 넣을 수 있는 XML .plist 파일이 포함되어 있습니다.

서버에서 최신 빌드를 가져오는 다운로드 스크립트가 있는 경우, 해당 스크립트를 수정하여 다운로드한 .dSYM에 적절한 리매핑 사전을 자동으로 삽입할 수 있습니다.

LLDB 웹사이트에서 이 과정에 대해 자세히 알아볼 수 있습니다.

소스 경로는 전혀 언어에 국한되지 않으므로, 이 방법은 Swift, C++ 및 Objective-C 프로젝트에서 모두 작동합니다.

Apple 플랫폼의 기호에 대해 자세히 알아보려면 WWDC21의 "Symbolication: Beyond the basics"를 확인하세요.

소스 코드가 빌드 서버 팜에서 컴파일될 때, 소스 파일에 대한 원격 경로는 기계마다 다를 수 있습니다.

기계당 하나의 리맵 접두사를 정의할 필요가 없도록, 컴파일러에게 디버그 정보에 넣기 전에 소스 경로를 정규화하도록 지시할 수 있습니다.

이것은 -debug-prefix-map 옵션을 사용하여 수행됩니다.

이런 식으로 기계별 경로 접두사는 LLDB의 로컬 경로로 다시 매핑할 수 있는 고유한 표준 자리 표시자 이름으로 대체될 수 있습니다.

우리가 소스 탄젠트에 가기 전에, 나는 "단어"의 객체 설명을 인쇄하려고 했다.

그건 효과가 없었어.

사실, "단어"라는 표현을 평가하는 것만으로도 효과가 없었다.

적어도 우리는 변수 보기에서 변수를 볼 수 있다.

Xcode 변수 보기와 동등한 콘솔은 "프레임 변수" 또는 "v" 명령이다.

이 명령들 사이의 뉘앙스에 대해 더 알고 싶다면, WWDC19의 "LLDB: Beyond 'po'"를 확인하세요.

그래서 포는 무엇이고 왜 여전히 작동하지 않나요?

이것이 무엇을 의미하는지 이해하기 위해, 우리는 LLDB에 대해 더 배워야 한다.

상기시켜 드리자면, LLDB는 디버거입니다.

하지만 LLDB는 단순한 디버거가 아니다.

그것도 컴파일러야!

디버거의 기능 외에도, LLDB는 Swift와 Clang 컴파일러의 완전한 기능을 갖춘 복사본을 포함한다.

이 컴파일러는 p와 po 명령 별칭을 통해 알 수 있는 LLDB의 표현식 평가자를 강화합니다.

표현식 평가자를 사용하면 변수를 보는 것 이상으로 계산을 수행하고, 함수를 호출하고, 심지어 프로그램의 상태를 변경할 수 있습니다.

WWDC18의 "Xcode 및 LLDB를 사용한 고급 디버깅"을 확인하여 이러한 명령으로 가능한 것에 대한 아이디어를 얻으십시오.

디버거는 지역 변수를 어떻게 포맷하나요?

컴파일러가 제공하는 디버그 정보는 디버거에게 메모리에 변수가 저장되는 위치를 알려줍니다.

하지만 그 정보만으로, LLDB는 우리에게 임의의 원시 바이트만 보여줄 수 있을 것이다.

그렇다면 LLDB는 어떻게 그것을 멋지게 포맷된 출력으로 바꾸나요?

답은 유형이다.

유형 정보를 통해 LLDB는 소스 변수의 구조와 메모리 레이아웃을 이해할 수 있다.

유형 정보를 통해 LLDB는 집계 유형에 어떤 필드가 있는지 알고 있으며 유형은 LLDB가 적절한 데이터 포맷터를 사용하여 예쁘게 인쇄할 수 있도록 합니다.

이제 유형 정보가 어디에서 오는지 살펴봅시다.

프레임 변수와 v 명령이 있는 디버거 측에서 LLDB는 디버그 정보에서 유형 정보를 가져옵니다.

그리고 LLDB는 또한 스위프트 반사 메타데이터에서 유형을 얻는다.

표현식 평가자와 po가 있는 컴파일러 측에서 LLDB는 모듈에서 유형 정보를 얻는다.

이 깨끗한 분리는 Xcode 14의 새로운 기능이며 표현식 평가자가 아니더라도 변수 보기가 완전히 작동할 수 있는 이유를 설명합니다.

모듈은 컴파일러가 유형 선언을 구성하는 방법이다.

스위프트 컴파일러는 모듈을 가져오는 많은 방법을 알고 있지만, 우리가 그것에 뛰어들기 전에, 나는 당신에게 편리한 새로운 기능을 보여주고 싶다.

컴파일러 측에서 일어나고 있는 문제를 어떻게 진단하기 시작할 수 있을까요?

올해 LLDB는 새로운 "신속한 건강 점검" 명령을 추가했다.

모듈 가져오기가 실패했는지 알아내기 위한 첫 번째 정류장입니다.

이게 어떻게 작동하는지 보여줄게.

문제가 발생한 후 swift-healthcheck를 실행하면 Swift 표현식 평가자 구성의 로그에 액세스할 수 있습니다.

로그의 끝에서 우리는 LLDB가 "TerminalUI" Swift 모듈을 가져오는 데 문제가 있었다는 것을 알 수 있다.

이름을 바탕으로, 나는 이것이 TerminalInterface 프레임워크의 구현 세부 사항이라고 생각한다.

이 누락된 모듈은 self의 유형이 UI 구현에 대해 일반적이며 해당 유형을 포함하는 모듈이 없으면 표현식 평가자가 "self"의 동적 유형을 실현할 수 없기 때문에 문제가 됩니다.

저는 프레임워크 개발자들에게 메시지를 보내고 그들에게 조사를 요청하고 있습니다.

내 경험상, 그들은 항상 매우 반응이 좋았다.

누가 알겠어, 어쩌면 우리는 이 비디오가 끝나기 전에 해결책을 찾을 수 있을지도 몰라.

그 동안, LLDB의 컴파일러가 Swift 모듈을 어떻게 찾는지 살펴봅시다.

내 앱에는 자체 스위프트 모듈이 있다.

재단과 같은 시스템 프레임워크를 가져올 수 있다.

시스템 프레임워크는 SDK에 있는 텍스트로 안정적인 스위프트 인터페이스 파일이다.

모든 Swift 모듈은 모듈 맵 파일의 도움으로 함께 그룹화된 하나 이상의 헤더 파일의 멋진 이름인 Clang 모듈을 가져올 수 있습니다.

클랑 모듈은 다른 클랑 모듈에 의존할 수 있다.

내 앱은 로컬로 구축된 프레임워크에 속하는 스위프트 모듈을 가져올 수도 있다.

또한 SDK의 일부가 아닌 텍스트 스위프트 인터페이스 파일을 가져올 수 있습니다.

방법을 배우고 싶다면, WWDC19의 "바이너리 프레임워크 인 스위프트"를 확인하세요.

내 앱은 또한 스위프트 코드가 포함된 정적 라이브러리에 연결할 수 있으며, 스위프트 모듈도 함께 제공됩니다.

흠, 하지만 우리는 아직 끝나지 않았어.

Clang 모듈을 가져올 수 있는 브리징 헤더도 있다는 것을 언급해야 한다.

마지막으로, LLDB만의 특수 기능으로, 일부 모듈 내용은 디버그 정보만으로 재구성할 수 있습니다.

그건 많은 출처야!

LLDB는 그들 모두를 어떻게 찾나요?

LLDB가 모듈을 찾을 수 있도록 모듈을 패키징하는 것은 빌드 시스템의 일이다.

시스템 프레임워크의 모듈은 SDK에 남아 있다.

LLDB는 프로그램에 첨부할 때 읽을 수 있는 일치하는 SDK를 찾을 것입니다.

객체 파일에서 바로 디버깅할 때, LLDB는 빌드 당시의 모든 비 SDK 모듈을 찾을 것이다.

Dsymutil은 a라고 불리는 디버그 정보 아카이브를 패키징할 수 있다. 모든 동적 라이브러리, 프레임워크 또는 dylib 및 실행 파일을 위한 DSYM 번들.

각 .dSYM 번들은 브리징 헤더, 텍스트 스위프트 인터페이스 파일 및 가장 중요한 디버그 정보를 포함할 수 있는 이진 스위프트 모듈을 포함할 수 있습니다.

그건 모든 걸 커버해.

모든 것?

정적 아카이브에 속하는 스위프트 모듈을 제외한 모든 것.

Dsymutil이 스위프트 모듈을 픽업하려면, 링커에 등록해야 합니다.

동적 라이브러리와 실행 파일의 경우, 빌드 시스템은 당신을 위해 자동으로 이것을 할 것입니다.

하지만 정적 아카이브는 링커에 의해 생성되지 않으며, zip 파일과 같은 개체 파일의 모음일 뿐입니다.

즉, 스위프트 모듈을 링커에 등록하는 책임은 정적 아카이브를 연결하는 모든 실행 파일 또는 동적 라이브러리에 있습니다.

많은 경우에, Xcode의 빌드 시스템은 당신을 위해 이것을 할 것입니다.

하지만 자신만의 사용자 지정 빌드 시스템을 유지하거나 사용자 지정 빌드 규칙을 정의한 경우, 이것은 알아야 할 것입니다.

Apple 링커를 사용할 때, Swift 모듈은 -add-ast-path 옵션으로 등록되어야 합니다.

이것이 사실인지 확인하려면 빌드 로그를 확인하세요.

또한 dsymutil을 사용하여 실행 파일의 심볼 테이블을 덤프하고 "swiftmodule"에 대한 grep을 사용하여 작동하는지 확인할 수 있습니다.

리눅스와 같은 다른 플랫폼에서 스위프트 드라이버는 바이너리 스위프트 모듈 파일을 나머지 디버그 정보와 함께 바이너리에 연결할 수 있는 객체로 변환하는 -modulewrap 동작을 지원합니다.

LLDB가 거기서 찾을 거야.

그 프레임워크의 개발자들은 믿을 수 없을 정도로 반응이 좋았다.

우리가 의심했듯이, 프레임워크의 빌드 시스템의 일부로 정적 아카이브가 사용된다는 것이 밝혀졌다.

그리고 그것은 dSYM 번들에서 누락된 정적 아카이브에 속한 스위프트 모듈이었다.

나는 이제 고정된 버전의 프레임워크를 설치했다.

그것은 누락된 정적 모듈을 링커에 등록했기 때문에 dsymutil은 그것을 수집할 수 있었다.

이제 스스로 해결할 수 있다.

그리고 우리는 "단어"의 객체 설명을 인쇄할 수 있다.

어쨌든 콘솔을 사용하고 있기 때문에, 저는 parseFrom 함수에 들어가기 위해 별칭을 사용하고 있습니다.

그리고 이제 우리는 여기서 복사 및 붙여넣기 오류인 버그를 쉽게 찾을 수 있습니다.

그리고 그것으로, 우리는 누락된 스위프트 모듈의 퍼즐뿐만 아니라 게임의 첫 번째 퍼즐도 풀었다.

우리가 마무리하기 전에, 나는 조심해야 할 세부 사항이 하나 더 있다.

스위프트 컴파일러는 Clang 헤더 검색 경로 및 기타 관련 옵션을 이진 .swiftmodule 파일로 직렬화합니다.

이것은 Clang 모듈 종속성을 가져오는 것이 빌드 중에만 작동하도록 하기 때문에 좋습니다.

하지만 다른 기계에 건물을 지을 때, 이 지역 경로는 해로울 수 있다.

따라서 바이너리 .swiftmodule을 다른 기계로 배송하기 전에, -no-serialize-debugging-options 컴파일러 플래그로 빌드하는 것을 고려해 보세요.

Xcode에서 이것은 SWIFT_SERIALIZE_DEBUGGING_OPTIONS 설정을 통해 제어됩니다.

다음 설정 중 하나로 LLDB에서 이러한 검색 경로를 다시 도입할 수 있습니다.

우리가 배운 것을 요약해 봅시다.

한 컴퓨터에서 다른 컴퓨터로 코드를 보내고 싶다면, 어떤 수준의 디버깅을 할 것으로 예상하는지 스스로에게 물어봐야 합니다.

예를 들어, 바이너리 프레임워크를 다른 개발자에게 배송하고 디버거에서 코드에 들어갈 것으로 예상하지 않는다면, Swift 모듈을 텍스트 .swiftinterface 파일로 배송하는 것이 가장 좋습니다.

하지만 개발자가 다운로드한 빌드 아티팩트를 디버깅할 것으로 예상되는 빌드 서버 또는 지속적인 통합 시스템을 설정하는 경우, 이진 스위프트 모듈을 구축하고 검색 경로 직렬화를 끄는 것을 고려해야 합니다.

-Debug-prefix-map 옵션을 사용하여 디버그 정보에서 서버의 소스 경로를 정규화할 수도 있습니다.

그게 내가 널 위해 가진 전부야.

오늘 우리는 디버거와 컴파일러로서의 LLDB의 이중 특성에 대해 배웠습니다.

디버거는 작동하기 위해 디버그 정보와 반사 메타데이터가 필요하며 Xcode 변수 보기와 v 명령을 제공합니다.

컴파일러는 모듈이 필요하며 검색 경로에 민감하다.

그것은 expr, p, po 명령 뒤에 있다.

컴파일러 진단을 얻는 좋은 방법은 LLDB의 새로운 swift-healthcheck 명령이다.

봐줘서 고마워! ♪ ♪