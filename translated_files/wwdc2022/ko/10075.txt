10075

♪ 기악 힙합 음악 ♪

♪

"AppKit과 함께 SwiftUI 사용"에 오신 것을 환영합니다.

저는 단축키를 작업하는 엔지니어 이안입니다.

macOS Monterey에서 단축키는 macOS에 왔다.

단축키는 Mac에서 SwiftUI를 많이 사용한다.

SwiftUI는 iOS 및 watchOS의 앱과 공통 뷰를 공유하면서 플랫폼의 경험을 사용자 정의하는 데 도움을 줍니다.

이 비디오에서는 단축키의 몇 가지 예를 보고 Mac 앱에서 SwiftUI를 채택하는 방법을 보여드리겠습니다.

먼저, 앱에서 SwiftUI 뷰를 호스팅하는 방법의 예를 보여준 다음, AppKit과 SwiftUI 간에 데이터를 전달하는 방법에 대해 이야기하겠습니다.

또한 컬렉션 또는 테이블 뷰의 셀에서 SwiftUI 뷰 호스팅, AppKit에 포함될 때 SwiftUI 뷰의 레이아웃 및 크기 조정을 처리하는 방법, SwiftUI 뷰가 응답자 체인에 참여하고 집중할 수 있도록 하는 방법, 마지막으로 SwiftUI에서 AppKit 뷰를 호스팅하는 방법을 다룰 것입니다.

좋아요, AppKit에서 SwiftUI를 호스팅하는 방법부터 시작하겠습니다.

단축키에서 메인 창에는 AppKit 분할 보기 컨트롤러가 포함되어 있으며 왼쪽의 사이드바는 SwiftUI를 사용하여 작성됩니다.

사이드바 보기는 SwiftUI 목록으로 구현되며, 목록에는 앱에서 탐색할 수 있는 모든 장소의 행이 있는 섹션이 표시됩니다.

보기는 선택한 항목 바인딩을 통해 선택한 항목을 추적합니다.

선택할 수 있는 가능한 항목은 SidebarItem 유형의 사례로 표시됩니다.

이 경우, 이미 분할 뷰 컨트롤러가 있기 때문에.

이 사이드바 뷰를 호스팅하기 위해, 우리는 NSHostingController라는 SwiftUI의 클래스를 사용합니다.

SwiftUI 사이드바 보기는 해당 호스팅 컨트롤러의 루트 보기로 전달됩니다.

호스팅 컨트롤러는 다른 뷰 컨트롤러와 마찬가지로 사용할 수 있기 때문에, 여기서 우리는 그것을 splitViewItem으로 구성하고 splitViewController에 추가합니다.

이제 사이드바는 분할 보기에서 호스팅되지만, 선택이 변경될 때 작동하려면 분할 보기의 오른쪽에 다른 페이지를 표시해야 합니다.

현재, 선택된 항목 상태는 SwiftUI 내에만 존재합니다.

우리가 해야 할 일은 그것을 분할 보기와 사이드바 사이에서 공유할 수 있는 장소로 옮기는 것이다.

이를 수행하는 좋은 방법은 SwiftUI 외부에 저장하고 공유해야 하는 상태를 포함할 수 있는 모델 객체를 만드는 것입니다.

나는 이 객체를 SelectionModel이라고 부를 것이다.

이제, 사이드바는 여전히 SelectionModel의 상태를 읽고 쓸 수 있습니다.

코드에서, SelectionModel은 ObservableObject를 준수하는 클래스이다.

관찰 가능한 객체이기 때문에 SwiftUI는 모델에 저장된 상태가 변경될 때 뷰를 다시 로드할 수 있습니다.

현재 선택된 사이드바 항목을 저장합니다.

이 속성은 선택한 항목이 변경될 때 SwiftUI 사이드바 보기를 업데이트할 수 있도록 게시됩니다.

누군가가 사이드바에서 선택을 변경할 때마다, 모델은 세부 보기에 새 페이지를 표시할 수 있습니다.

이제 AppKit에서 SwiftUI를 호스팅하는 방법을 다루었으니, 컬렉션과 테이블 셀로 넘어가겠습니다.

다른 플랫폼에서 macOS로 단축키를 가져올 때, 이미 컬렉션 뷰 셀이나 홈 화면 위젯에 단축키를 표시하도록 만들어진 상징적인 SwiftUI 뷰가 있었다.

macOS에서, 이러한 동일한 보기는 NSCollectionView의 셀에 표시됩니다.

많은 항목이 있는 컬렉션이나 테이블 뷰에서, 각 셀 뷰는 스크롤할 때 재활용되어 시간이 지남에 따라 다른 콘텐츠를 보여줍니다.

셀 재사용이 수행되는지 확인하려면, 사용자가 스크롤할 때 셀에서 하위 뷰를 추가하거나 제거하는 것을 피해야 합니다.

각 셀에 SwiftUI 뷰를 표시할 때, 단일 호스팅 뷰를 사용하고 셀의 콘텐츠를 변경해야 할 때 다른 루트 뷰로 업데이트하십시오.

SwiftUI를 호스팅하기 위해 컬렉션 뷰 셀을 만드는 데 필요한 모든 것은 다음과 같습니다.

여기 예시에서, 저는 바로 가기 보기를 표시하는 셀을 만들고 있습니다.

각 셀에는 SwiftUI를 호스팅하기 위한 NSHostingView가 포함되어 있습니다.

셀은 콘텐츠로 구성되기 전에 생성되기 때문에, 이것은 nil로 시작되며, 바로 가기가 처음 표시될 준비가 되면 설정됩니다.

displayShortcut 메서드는 단축키를 표시하도록 셀을 구성할 때 데이터 소스에 의해 호출됩니다.

이 방법은 SwiftUI ShortcutView를 만듭니다.

그런 다음, 이미 hostingView가 있다면, 그 hostingView의 rootView는 새 보기로 설정됩니다.

그렇지 않으면, 처음이라면, newHostingView가 생성되고 셀의 하위 뷰로 추가됩니다.

여기 SwiftUI를 호스팅하는 셀의 수명 주기가 있습니다.

먼저, 셀은 초기화되고 아직 표시할 바로 가기가 없기 때문에 하위 뷰 없이 시작됩니다.

displayShortcut이 처음 호출될 때, hostingView는 표시할 shortcutView로 생성됩니다.

이것은 VStack, 이미지, 스페이서 및 두 개의 텍스트 뷰를 포함하는 SwiftUI 뷰 계층 구조를 만듭니다.

이 셀이 화면에서 스크롤되면, 잠재적으로 시스템에 의해 중단되고 다른 단축키를 표시해야 합니다.

이런 일이 발생하면, 새로운 ShortcutView가 만들어지고 HostingView에 제공됩니다.

HostingView는 이미 다른 바로 가기 보기를 표시하고 있었기 때문에 VStack과 스페이서를 포함한 보기의 전체 구조를 재사용하고 변경된 이미지, 텍스트 및 배경만 업데이트합니다.

좋아, 다음으로, 레이아웃과 크기에 대해 이야기해 보자.

호스팅 컨트롤러와 호스팅 뷰는 SwiftUI 뷰의 이상적인 너비와 높이에 따라 본질적인 크기를 가지고 있습니다.

SwiftUI는 AppKit 레이아웃 시스템이 보기의 크기를 적절하게 조정하는 데 사용하는 자동 레이아웃 제약을 자동으로 만들고 업데이트합니다.

견해는 또한 유연하며, 이는 최소와 최대 사이의 다양한 크기를 지원한다는 것을 의미한다.

SwiftUI는 이것들에 대한 제약도 만든다.

계층 구조에 SwiftUI 호스팅 뷰를 포함할 때, 슈퍼뷰 또는 다른 인접한 뷰에 자체 자동 레이아웃 제약 조건을 적용해야 합니다.

프레임 수정자 또는 기타 SwiftUI 레이아웃을 사용하면 너비를 고정 크기로 재정의하는 것과 같이 생성된 제약 조건이 업데이트됩니다.

윈도우는 사용자가 크기를 조정할 수 있기 때문에, 최소 및 최대 크기를 가지고 있다.

HostingViews가 창의 최상위 contentView로 설정되면, SwiftUI는 표시되는 콘텐츠에 따라 해당 창의 최소 및 최대 크기를 자동으로 업데이트합니다.

그리고 이것은 콘텐츠에 따라 창의 크기를 수직, 수평 또는 둘 다 조정할 수 있게 해준다.

호스팅 컨트롤러에 배치된 SwiftUI 뷰는 모달 방식으로 제시될 때 콘텐츠에 따라 크기가 조정됩니다.

예를 들어, 여기에 표시된 것처럼 NSViewController에서 팝오버 프레젠테이션 API를 사용하여 호스팅 컨트롤러를 제시하여 SwiftUI 뷰를 AppKit 팝오버에 쉽게 배치할 수 있습니다.

presentAsSheet 방법을 사용하여 SwiftUI 뷰를 시트로 표시할 수도 있습니다.

그리고 마지막으로, 모달 창의 경우, presentAsModalWindow 방법을 사용하여 닫힐 때까지 상호 작용을 차단하는 창을 제시할 수 있습니다.

창문은 내용에 맞게 크기가 조정되었다.

macOS Ventura에는 NSHostingView와 NSHostingController에 자동으로 추가되는 제약 조건을 사용자 정의할 수 있는 새로운 API가 있습니다.

기본적으로 호스팅 컨트롤러와 뷰는 최소 크기, 고유 크기 및 최대 크기에 대한 제약을 만듭니다.

보기를 항상 유연하게 조정하거나 AppKit의 주변 보기에 제약이 이미 추가된 경우 성능상의 이유로 이들 중 일부를 비활성화할 수 있습니다.

호스팅 컨트롤러의 경우, 이상적인 보기 크기가 선호하는 콘텐츠 크기를 결정하도록 하려면, preferredContentSize 옵션을 활성화할 수 있습니다.

앱에 SwiftUI 뷰를 추가하기 시작하면, 앱의 다른 뷰와 마찬가지로 응답자 체인과 포커스 시스템에 참여하는 것이 중요합니다.

단축키에서, 우리의 편집기는 SwiftUI 뷰로 구현됩니다.

하지만 편집기는 AppKit에서 구현된 메인 메뉴에 정의된 메뉴 표시줄 명령을 처리해야 합니다.

이러한 명령에는 잘라내기, 복사, 붙여넣기 등이 포함됩니다.

우리는 작업을 위아래로 이동하기 위해 몇 가지 사용자 지정 메뉴 항목도 구현했습니다.

AppKit에서 뷰 계층 구조는 "응답자 체인"이라고 불리는 뷰 체인을 구성합니다.

집중된 응답자는 첫 번째 응답자라고 불린다.

메뉴 항목이 선택되면, 해당 항목의 선택기가 첫 번째 응답자에게 전송됩니다.

하지만 첫 번째 응답자가 그 셀렉터에 응답하지 않으면, 셀렉터는 무언가가 셀렉터를 처리하거나 앱에 도달할 때까지 각 다음 응답자에게 전송됩니다.

SwiftUI의 첫 번째 응답자와 동등한 것은 집중된 관점이다.

집중 가능한 SwiftUI 뷰는 키보드 입력에 응답하고 응답자 체인으로 전송된 핸들 선택기를 처리할 수 있습니다.

텍스트 필드와 같은 일부 보기는 이미 초점을 맞출 수 있지만, 초점을 맞출 수 있는 수정자를 사용하여 다른 보기도 초점을 맞출 수 있습니다.

SwiftUI에는 복사, 잘라내기 및 붙여넣기와 같은 일반적인 명령을 처리하는 몇 가지 수정자가 있습니다.

이것들은 페이스트보드 안팎으로 값을 전달하며, 사람들이 앱 안팎으로 데이터를 전송할 수 있는 쉬운 방법입니다.

단축키 편집기는 onMoveCommand 및 onExit 명령 수정자를 사용하여 화살표 키와 이스케이프 키를 처리합니다.

onCommand 수정자는 AppKit의 일반적인 선택기 또는 앱에 정의된 사용자 지정 선택기를 처리하는 데 사용할 수 있습니다.

여기서, 우리는 AppKit의 selectAll 명령과 단축키 앱에 정의된 moveActionUp 및 moveActionDown 명령을 처리합니다.

앱에서 초점과 키보드 탐색성을 테스트할 때, 키보드 시스템 설정을 열고 전체 키보드 탐색을 켜고 끄고 테스트해야 합니다. 많은 컨트롤이 활성화된 경우에만 초점을 맞출 수 있기 때문입니다.

앱이 키보드로 잘 작동하도록 하기 위해 할 수 있는 일이 훨씬 더 많습니다.

예를 들어, FocusState와 같은 API와 포커스된 뷰를 프로그래밍 방식으로 변경할 수 있는 포커스 수정자가 있습니다.

초점과 키보드에 대해 자세히 알아보려면, "SwiftUI에서 직접 및 초점 반영" 비디오를 시청해야 합니다.

마지막으로, SwiftUI에서 AppKit 뷰를 호스팅하는 것에 대해 이야기해 봅시다.

단축키가 SwiftUI 레이아웃 내에서 AppKit 뷰를 호스팅하는 경우가 있으며, 앱에서 SwiftUI를 채택할 때 AppKit 뷰를 호스팅해야 할 수도 있습니다.

한 가지 예는 SwiftUI 단축키 편집기 내부에 있으며, macOS의 다른 몇 가지 시스템 앱과 공유되는 AppKit 컨트롤인 AppleScript 편집기 보기가 내장되어 있습니다.

SwiftUI는 AppKit 뷰와 뷰 컨트롤러가 SwiftUI 뷰 계층에 포함될 수 있는 두 가지 표현 가능한 프로토콜을 제공합니다.

SwiftUI 뷰와 마찬가지로, representables는 AppKit 뷰를 만들고 업데이트하는 방법에 대한 설명입니다.

AppKit의 많은 클래스에는 대의원, 관찰자 또는 KVO 또는 관찰할 알림에 의존하기 때문에, 프로토콜에는 뷰 또는 뷰 컨트롤러와 함께 구현할 수 있는 선택적 코디네이터 객체도 포함되어 있습니다.

여기 호스팅된 객체와 코디네이터의 수명 주기가 있습니다.

우리는 호스팅된 뷰가 초기화되는 것으로 시작합니다.

이것은 뷰가 처음으로 표시될 때 발생한다.

SwiftUI가 초기화하는 동안 가장 먼저 하는 일은 코디네이터를 만드는 것이다.

이것은 선택 사항이지만, 위임 또는 국가 관리를 위해 필요한 경우 자신만의 유형을 정의하고 makeCoordinator에서 반환할 수 있습니다.

코디네이터의 단일 인스턴스는 뷰의 평생 동안 주변에 머무를 것이다.

둘째, makeNSView 또는 makeNSViewController 메소드가 호출됩니다.

이것은 당신이 SwiftUI에 당신의 뷰의 새로운 인스턴스를 만드는 방법을 설명하는 곳입니다.

문맥에는 방금 만들어진 코디네이터가 포함되어 있으므로, 여기에 코디네이터를 뷰의 대리인 또는 다른 유형의 관찰자로 할당하기에 좋은 장소가 있습니다.

뷰가 생성되면, SwiftUI 상태나 환경이 변경될 때마다 업데이트 뷰 메소드가 호출됩니다.

여기서, AppKit 보기에 저장된 속성이나 상태를 업데이트하여 주변 SwiftUI 상태 및 환경과 동기화하는 것은 귀하의 책임입니다.

업데이트 방법은 자주 호출될 수 있으므로, 보기에 대한 변경 사항은 가능한 한 최소화되어야 합니다.

무엇이 변경되었는지 확인하고 변경될 때만 보기의 영향을 받는 부분을 다시 로드해야 합니다.

SwiftUI가 호스팅된 보기를 표시하면, 해체될 것이다.

호스팅된 뷰와 코디네이터는 둘 다 할당될 것이다.

이것들이 할당되기 전에, 표현 가능한 프로토콜은 필요한 경우 상태를 정리할 수 있는 선택적 구현 방법을 제공합니다.

좋아요, 이제 수명 주기를 알고 있고 표현 가능한 프로토콜에 익숙해졌으니, 단축키가 앱에서 사용자 지정 스크립트 편집기 보기를 호스팅하는 방법을 보여드리겠습니다.

스크립트 편집기는 ScriptEditorView라고 불리는 NSView이다.

편집기에 작성된 코드는 sourceCode 속성을 통해 액세스하고 수정할 수 있으며, 변경되지 않도록 보기를 비활성화할 수 있습니다.

스크립트 편집기에는 또한 누군가가 소스 코드를 수정할 때마다 알림을 받는 대리인이 있다.

AppKit 뷰를 호스팅할 때, 먼저 SwiftUI에서 뷰가 어디에 배치될지, 그리고 어떤 데이터를 전달해야 하는지 생각해 보세요.

단축키에서, 이 보기는 컴파일 버튼 옆에 있는 컨테이너 보기에 배치됩니다.

컴파일 버튼의 핸들러는 뷰에 입력된 소스 코드에 액세스해야 합니다.

소스 코드는 State 속성 래퍼를 사용하여 SwiftUI에 저장됩니다.

대표자는 이 상태를 읽고 써야 할 것이다.

대표성을 구축하려면, NSViewRepresentable을 호스팅하기 때문에 NSViewRepresentable을 준수하는 유형을 만드는 것으로 시작하세요.

SwiftUI에서 구성해야 하는 각 것에 대한 속성을 추가하세요.

소스 코드의 경우 바인딩이 사용되며, 이는 SwiftUI에 저장된 상태를 읽고 쓸 것이다.

구현해야 할 첫 번째 방법은 makeNSView입니다.

다음은 뷰의 새로운 인스턴스를 만드는 방법과 필요한 일회성 설정을 수행해야 하는 곳입니다.

여기서, 대리인은 코디네이터에게 배정되었다.

조금 있다가 코디네이터에 대해 더 얘기할게.

다음으로, updateNSView를 구현하세요.

이것은 소스 코드가 변경되거나 SwiftUI 환경이 변경될 때 호출됩니다.

스크립트 편집기는 소스코드 속성이 설정될 때 많은 작업을 하기 때문에, 우리는 이미 뷰에 있는 값을 비교하고, 불필요한 작업을 피하기 위해 변경되는 경우에만 속성을 설정합니다.

updateNSView에 전달된 컨텍스트에는 SwiftUI 환경이 포함되어 있습니다.

isEnabled 환경 키는 스크립트 편집기의 isEditable 속성으로 전달되므로 나머지 SwiftUI 뷰 계층 구조가 있으면 편집이 비활성화됩니다.

누군가가 뷰에서 소스 코드를 수정할 때마다, 소스 코드 바인딩은 새로운 값을 캡처해야 합니다.

이를 위해, 우리는 ScriptEditorViewDelegate를 준수하는 코디네이터를 만들 것입니다.

코디네이터는 업데이트해야 하는 소스 코드 바인딩이 포함된 표현 가능한 값을 저장할 것이다.

그리고 sourceCodeDidChange 메소드에서 바인딩은 뷰에서 새 문자열 값으로 설정됩니다.

마지막으로, 우리는 SwiftUI에게 코디네이터를 만들고 업데이트하는 방법을 말해야 합니다.

먼저, 새로운 코디네이터를 만들기 위해 makeCoordinator 방법을 구현해야 합니다.

코디네이터는 호스팅된 뷰와 같은 수명을 가지며, 호스팅된 뷰와 마찬가지로 코디네이터에 추가하는 속성은 표현 가능한 변경 사항으로 최신 상태로 유지되어야 합니다.

updateNSView는 표현 가능한 변경에 저장된 값이 있을 때 호출되기 때문에, 여기서 코디네이터의 표현 가능한 속성이 업데이트됩니다.

이제 SwiftUI에 AppKit을 추가하고 AppKit에 SwiftUI를 추가하는 방법을 알았으므로 SwiftUI를 앱에 통합하기 시작해야 합니다.

시작하기에 좋은 곳은 사이드바 또는 테이블 및 컬렉션 보기 셀에 있습니다.

당신의 견해가 정확하게 크기를 조정하고 일반적인 명령과 초점을 다루고 있는지 확인하세요.

시간 내줘서 고마워, 그리고 네가 뭘 만드는지 빨리 보고 싶어 ♪