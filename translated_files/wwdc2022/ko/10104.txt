10104

♪ 기악 힙합 음악 ♪

♪

안녕하세요, 제 이름은 Jaideep Joshi이고, 저는 Apple의 GPU 소프트웨어 엔지니어입니다.

이 세션에서는 게임과 앱의 리소스 로딩을 단순화하고 최적화하는 Metal 3의 새로운 기능을 소개할 것입니다.

빠른 리소스 로딩 기능이 앱의 자산 로딩 파이프라인에 어떻게 들어갈 수 있는지 보여주는 것으로 시작하겠습니다.

그것은 Apple 제품에서 새로운 스토리지 기술을 활용하는 몇 가지 주요 기능을 가지고 있다.

빠른 리소스 로딩에는 애플리케이션이 발생할 수 있는 흥미로운 시나리오를 해결하는 몇 가지 고급 기능이 있습니다.

앱에서 이러한 기능을 효과적으로 사용하는 데 도움이 되는 몇 가지 모범 사례 권장 사항이 있습니다.

앱에 빠른 리소스 로딩을 추가할 때, Metal System Trace 및 GPU 디버거와 같은 도구는 발생할 수 있는 문제를 프로파일링하고 해결하는 데 도움이 될 수 있습니다.

마지막에, 나는 빠른 자원 로딩을 보여주는 예시를 살펴볼 것이다.

메탈 3의 빠른 자원 로딩으로 할 수 있는 일은 다음과 같습니다.

Metal 3의 빠른 리소스 로딩을 통해 게임과 앱은 Apple 실리콘 통합 메모리 아키텍처와 Apple 플랫폼에 포함된 빠른 SSD 스토리지를 활용하여 짧은 대기 시간과 높은 처리량으로 자산을 로드할 수 있습니다.

게임의 자산이 제시간에 준비될 수 있도록 데이터를 스트리밍하고 로드 시간을 줄이는 가장 좋은 방법을 배우게 될 것입니다.

로드 시간을 줄이는 핵심 측면은 가능한 가장 작은 세분으로 필요한 것만 로드하는 것입니다.

Metal 3의 높은 처리량과 낮은 대기 시간을 통해 앱은 텍스처, 오디오 및 지오메트리 데이터를 포함한 고품질 자산을 스트리밍할 수 있습니다.

이제 게임에서 자산 로딩의 예를 안내해 드리겠습니다.

게임은 일반적으로 처음 시작할 때 또는 새로운 레벨의 시작 부분에 로딩 화면을 표시하므로 게임의 자산을 메모리에 로드할 수 있습니다.

플레이어가 레벨을 통과함에 따라, 게임은 장면에 더 많은 자산을 로드한다.

단점은 플레이어가 게임이 자산을 미리 로드하기 위해 스토리지 시스템에 여러 요청을 하는 동안 오랜 시간을 기다려야 한다는 것이다.

게다가, 그 자산들은 큰 메모리 공간을 가질 수 있다.

이 경험을 개선할 수 있는 몇 가지 방법이 있다.

게임은 플레이어가 더 가까워질수록 객체를 동적으로 스트리밍함으로써 이 경험을 향상시킬 수 있다.

이런 식으로, 게임은 처음에 필요한 것만 로드하고 플레이어가 레벨을 이동함에 따라 점차적으로 다른 자원을 스트리밍합니다.

예를 들어, 게임은 처음에 이 칠판을 더 낮은 해상도로 로드하지만, 플레이어가 그것을 향해 걸어갈 때, 게임은 고해상도 버전을 로드합니다.

이 접근 방식은 플레이어가 로딩 화면에서 기다리는 시간을 줄인다.

그러나, 플레이어는 고해상도 버전을 로드하는 데 너무 오래 걸리기 때문에 가까이 있어도 장면에서 저해상도 항목을 볼 수 있습니다.

이것을 다루는 한 가지 방법은 각 자산의 더 작은 부분을 스트리밍하는 것이다.

예를 들어, 게임은 전체 mip 레벨 대신 타일을 스트리밍하는 희박한 텍스처로 장면의 보이는 영역만 로드할 수 있습니다.

이것은 앱이 스트리밍하는 데 필요한 데이터의 양을 크게 줄입니다.

그 접근 방식으로, 로드 요청은 더 작아지고, 더 많은 것이 있다.

하지만 최신 스토리지 하드웨어는 한 번에 여러 로드 요청을 실행할 수 있기 때문에 괜찮습니다.

이것은 게임플레이를 손상시키지 않으면서 장면의 해상도와 규모를 높일 수 있다는 것을 의미합니다.

많은 수의 작은 부하 요청을 발행하는 것과 함께, 우선 순위가 높은 요청이 제 시간에 완료될 수 있도록 부하 요청의 우선 순위를 지정할 수 있습니다.

이제 로드 시간을 줄이면서 게임의 시각적 충실도를 높이는 방법을 다루었으니, 메탈 3의 빠른 리소스 로딩이 어떻게 도움이 되는지 보여드리겠습니다.

빠른 리소스 로딩은 저장소에서 리소스를 로드하는 비동기 API입니다.

기존 로드 API와 달리, 로드를 발행하는 스레드는 로드가 완료될 때까지 기다릴 필요가 없습니다.

로드 작업은 더 빠른 스토리지의 처리량을 더 잘 활용하기 위해 동시에 실행됩니다.

자원 로딩의 오버헤드를 더욱 최소화하기 위해 일괄 로드 작업을 할 수 있습니다.

그리고 마지막으로, Metal 3을 사용하면 더 낮은 대기 시간을 위해 로드 작업의 우선 순위를 지정할 수 있습니다.

이제 자원을 로드하는 단계부터 시작하여 자산 로딩 파이프라인을 구축하는 데 도움이 되는 주요 기능을 보여드리겠습니다.

리소스를 로드하는 데는 세 단계가 있습니다: 파일을 열고, 필요한 로드 명령을 실행한 다음, 이러한 로드 명령을 렌더링 작업과 동기화합니다.

파일을 여는 것부터 시작하는 방법은 다음과 같습니다.

메탈 장치 인스턴스로 파일 핸들을 만들어 기존 파일을 엽니다.

예를 들어, 이 코드는 Metal 장치 인스턴스를 사용하여 파일 경로 URL로 새로운 makeIOHandle 메소드를 호출하여 파일 핸들을 만듭니다.

파일 핸들이 있으면, 그것을 사용하여 로드 명령을 실행할 수 있습니다.

다음은 로드 작업을 수행하고 GPU 작업을 인코딩하는 애플리케이션의 일반적인 시나리오입니다.

기존 로드 API를 사용하면, 앱은 렌더링 작업을 인코딩하기 전에 로딩 작업이 완료될 때까지 기다려야 합니다.

Metal 3를 사용하면 앱이 비동기적으로 로드 명령을 실행할 수 있습니다.

Metal IO 명령 대기열을 만드는 것으로 시작하세요.

그런 다음 그 대기열을 사용하여 IO 명령 버퍼를 만들고 그 버퍼에 로드 명령을 인코딩하세요.

그러나, 명령 버퍼가 명령 대기열에서 비동기적으로 실행되기 때문에, 앱은 로드 작업이 완료될 때까지 기다릴 필요가 없습니다.

사실, IO 명령 버퍼 내의 모든 명령이 동시에 실행될 뿐만 아니라, IO 명령 버퍼 자체는 동시에 실행되고 순서대로 완료됩니다.

이 동시 실행 모델은 처리량을 극대화하여 더 빠른 스토리지 하드웨어를 더 잘 활용합니다.

세 가지 유형의 IO 명령을 명령 버퍼에 인코딩할 수 있습니다: 텍스처 스트리밍을 위해 메탈 텍스처에 로드되는 loadTexture; 장면이나 지오메트리 데이터를 스트리밍하기 위해 메탈 버퍼에 로드되는 loadBuffer; 그리고 CPU 액세스 가능한 메모리에 로드되는 loadBytes.

IO 명령 대기열에서 IO 명령 버퍼를 만듭니다.

대기열을 만들려면, 먼저 IO 명령 대기열 설명자를 만들고 구성하세요.

기본적으로 대기열은 동시이지만, 명령 버퍼를 순차적으로 그리고 완전히 순서대로 실행하도록 설정할 수도 있습니다.

그런 다음 큐 설명자를 Metal 장치 인스턴스의 makeIOCommandQueue 메소드에 전달하십시오.

명령 큐의 makeCommandBuffer 메소드를 호출하여 IO 명령 버퍼를 만드세요.

그런 다음 그 명령 버퍼를 사용하여 텍스처와 버퍼를 로드하는 로드 명령을 인코딩하십시오.

메탈의 검증 계층은 런타임에 인코딩 오류를 포착할 것이다.

로드 명령은 이전에 생성된 fileHandle 인스턴스를 사용하는 것이다.

명령 버퍼에 로드 명령을 추가하면, 명령 버퍼의 커밋 메소드를 호출하여 실행을 위해 대기열에 제출하십시오.

이제 IO 명령 대기열, 명령 버퍼를 만들고, 로드 명령을 발행하고, 대기열에 제출하는 방법을 다루었으므로, 로딩 작업을 다른 GPU 작업과 동기화하는 방법을 보여드리고자 합니다.

앱은 일반적으로 렌더링을 위한 리소스 로딩을 마친 후 렌더링 작업을 시작합니다.

하지만 빠른 리소스 로딩을 사용하는 앱은 IO 명령 큐를 렌더링 명령 큐와 동기화하는 방법이 필요합니다.

이 대기열을 메탈 공유 이벤트와 동기화할 수 있습니다.

Metal hared 이벤트를 사용하면 IO 대기열의 명령 버퍼를 렌더링 대기열의 명령 버퍼와 동기화할 수 있습니다.

waitEvent 명령을 인코딩하여 명령 버퍼에 공유 이벤트를 기다리라고 말할 수 있습니다.

마찬가지로, signalEvent 명령을 인코딩하여 명령 버퍼가 공유 이벤트를 신호하도록 알 수 있습니다.

메탈은 공유 이벤트에 신호를 보내기 전에 명령 버퍼 내의 모든 IO 명령이 완료되도록 합니다.

명령 버퍼 간에 동기화하려면, 먼저 메탈 공유 이벤트가 필요합니다.

waitForEvent 메소드를 호출하여 명령 버퍼에 공유 이벤트를 기다리라고 말할 수 있습니다.

마찬가지로, 명령 버퍼가 signalEvent 메서드를 호출하여 공유 이벤트에 신호를 보내도록 할 수 있습니다.

IO 명령 버퍼가 동일한 공유 이벤트를 신호할 때까지 기다리도록 해당 GPU 명령 버퍼에 유사한 논리를 추가할 수 있습니다.

요약하자면, 다음은 Metal 앱에서 리소스를 로드하는 주요 기능과 API입니다.

금속 파일 핸들을 만들어 파일을 여세요.

IO 명령 큐와 IO 명령 버퍼를 만들어 로드 명령을 발행하세요.

그런 다음, 대기열에서 실행을 위해 명령 버퍼에 로드 명령을 인코딩하세요.

그리고 마지막으로, Metal 공유 이벤트와 함께 대기 및 signalEvent 명령을 사용하여 로딩 및 렌더링을 동기화하십시오.

이제, 당신이 도움이 될 수 있는 몇 가지 고급 기능을 살펴볼 것입니다.

다음은 게임이 전체 지도를 메모리에 맞출 수 없는 전형적인 시나리오이며, 이것이 지도를 지역으로 세분화하는 이유입니다.

플레이어가 지도를 진행함에 따라, 게임은 지도의 영역을 미리 로드하기 시작한다.

플레이어의 방향에 따라, 게임은 미리 로드하기에 가장 좋은 지역이 북서쪽, 서쪽, 남서쪽 지역이라고 결정한다.

그러나, 일단 플레이어가 서부 지역으로 이동하고 남쪽으로 향하기 시작하면, 북서부 지역을 미리 로드하는 것은 더 이상 도움이 되지 않는다.

향후 부하의 대기 시간을 줄이기 위해, Metal 3을 사용하면 부하 작업을 취소할 수 있습니다.

실제로 그것을 어떻게 하는지 봅시다.

플레이어가 중앙 지역에 있을 때, 세 지역에 대한 IO 명령 버퍼를 인코딩하고 커밋하세요.

그런 다음 플레이어가 서부 지역에 있고 남쪽으로 향할 때, tryCancel 방법을 사용하여 북서부 지역의 부하를 취소하십시오.

취소는 명령 버퍼 세분성에 있으므로, 실행 중간에 명령 버퍼를 취소할 수 있습니다.

나중에 지역이 완전히 로드되었는지 알고 싶다면, 명령 버퍼의 상태를 확인할 수 있습니다.

메탈 3은 또한 IO 작업의 우선 순위를 지정할 수 있게 해준다.

플레이어가 장면의 새로운 부분으로 순간이동하고 게임이 많은 양의 그래픽 자산으로 스트리밍되기 시작하는 게임 시나리오를 고려하십시오.

동시에, 그 게임은 순간이동 음향 효과를 재생해야 한다.

빠른 리소스 로딩을 통해 오디오 데이터를 포함한 모든 앱 자산을 로드할 수 있습니다.

오디오를 로드하려면, 앞서 설명한 loadBytes 명령을 사용하여 애플리케이션 할당 메모리에 로드할 수 있습니다.

이 예에서, 텍스처와 오디오 IO 명령 버퍼는 단일 IO 명령 대기열에서 동시에 실행됩니다.

이 단순화된 다이어그램은 저장 계층의 요청을 보여준다.

스토리지 시스템은 오디오와 텍스처 로드 요청을 병렬로 실행할 수 있다.

오디오 지연을 피하려면, 스트리밍 시스템이 텍스처 요청보다 오디오 요청의 우선 순위를 지정할 수 있는 것이 중요합니다.

오디오 요청의 우선 순위를 지정하려면, 별도의 IO 명령 대기열을 만들고 우선 순위를 높게 설정할 수 있습니다.

스토리지 시스템은 우선 순위가 높은 IO 요청이 대기 시간이 낮고 다른 요청보다 우선 순위가 지정되도록 할 것이다.

오디오 자산에 대한 별도의 우선 순위가 높은 대기열을 만든 후, 오디오 로드 요청의 실행 시간은 줄어들었고, 병렬 텍스처 로드 요청의 실행 시간은 커졌다.

우선 순위가 높은 대기열을 만드는 방법은 다음과 같습니다.

명령 큐 설명자의 우선 순위 속성을 높게 설정하기만 하면 됩니다.

우선 순위를 정상 또는 낮음으로 설정한 다음, 평소와 같이 설명자에서 새로운 IO 명령 대기열을 만들 수도 있습니다.

대기열을 만든 후에는 대기열의 우선 순위 수준을 변경할 수 없다는 것을 기억하세요.

앱에 빠른 리소스 로딩을 추가할 때, 명심해야 할 몇 가지 모범 사례가 있습니다.

먼저, 자산을 압축하는 것을 고려해 보세요.

내장 또는 사용자 지정 압축을 사용하여 앱의 디스크 공간을 줄일 수 있습니다.

압축을 사용하면 런타임 성능을 더 작은 디스크 풋프린트와 교환할 수 있습니다.

또한, 스파스 텍스처를 사용할 때 스파스 페이지 크기를 조정하여 스토리지 처리량을 향상시킬 수 있습니다.

나는 압축을 시작으로 이것들 각각을 더 자세히 살펴볼 것이다.

Metals 3의 API를 사용하여 자산 파일을 오프라인으로 압축할 수 있습니다.

먼저, 압축 컨텍스트를 만들고 청크 크기와 압축 방법으로 구성하세요.

그런 다음 자산 파일의 일부를 컨텍스트에 전달하여 모든 파일의 단일 압축 버전을 생성합니다.

압축 컨텍스트는 모든 데이터를 청크하고 선택한 코덱으로 압축하여 팩 파일에 저장합니다.

이 예에서 컨텍스트는 64K 청크로 데이터를 압축하지만, 압축하려는 데이터의 크기와 유형에 따라 적절한 청크 크기를 선택할 수 있습니다.

Metal 3에서 압축 API를 사용하는 방법은 다음과 같습니다.

먼저, 압축 파일, 압축 방법 및 청크 크기를 만들기 위한 경로를 제공하여 압축 컨텍스트를 만드세요.

다음으로, 파일 데이터를 가져와서 컨텍스트에 추가하세요.

여기서, 파일 데이터는 NSData 객체에 있다.

데이터를 추가하기 위해 여러 번 호출하여 다른 파일의 데이터를 추가할 수 있습니다.

데이터 추가가 완료되면, 플러시 및 압축 컨텍스트 함수를 호출하여 압축 파일을 마무리하고 저장하십시오.

파일 핸들을 만들어 압축 파일을 열고 접근할 수 있습니다.

이 파일 핸들은 로드 명령을 실행할 때 사용됩니다.

압축된 파일의 경우, Metal 3는 오프셋을 압축 해제해야 하는 청크 목록으로 변환하여 인라인 압축 해제를 수행하고 리소스에 로드합니다.

금속 장치 인스턴스로 파일 핸들을 만듭니다.

예를 들어, 이 코드는 Metal 장치 인스턴스를 사용하여 이전에 다룬 makeIOHandle 방법에 압축된 파일 경로를 제공하여 파일 핸들을 만듭니다.

압축 파일의 경우, 추가 매개 변수는 압축 방법입니다.

이것은 압축 파일을 만들 때 사용한 것과 동일한 압축 방법입니다.

이제, 지원되는 다양한 압축 방법과 각각의 특성을 살펴보겠습니다. 그래서 당신은 그들 중 하나를 선택하는 방법을 더 잘 이해할 수 있습니다.

압축 해제 속도가 중요하고 앱이 큰 디스크 공간을 확보할 수 있을 때 LZ4를 사용하세요.

코덱 속도와 압축 비율의 균형이 중요하다면, ZLib, LZBitmap 또는 LZFSE를 사용하세요.

균형 잡힌 코덱 중에서, ZLib은 Apple이 아닌 장치에서 더 잘 작동합니다.

LZBitmap은 인코딩과 디코딩이 빠르며, LZFSE는 압축 비율이 높다.

최고의 압축 비율이 필요한 경우, 앱이 자산을 디코딩하는 데 걸리는 추가 시간을 감당할 수 있다면 LZMA 코덱을 사용하는 것을 고려하십시오.

자신만의 압축 체계를 사용하는 것도 가능합니다.

데이터가 사용자 지정 압축 코덱의 혜택을 받는 경우가 있을 수 있습니다.

이 경우, 압축 컨텍스트를 자신의 압축기로 대체하고 오프셋을 변환하고 런타임에 감압을 직접 수행할 수 있습니다.

이제 디스크 공간을 줄이기 위해 압축을 사용하는 방법을 보았으니, 희소 페이지 크기를 조정해 봅시다.

이전 버전의 금속은 16K 입도에서 희박한 질감으로 타일을 적재합니다.

메탈 3을 사용하면 두 개의 새로운 스파스 타일 크기를 지정할 수 있습니다: 64와 256K.

이 새로운 크기를 사용하면 더 큰 세분화로 텍스처를 스트리밍하여 스토리지 하드웨어를 더 잘 활용하고 포화할 수 있습니다.

더 큰 타일 크기를 스트리밍하는 것과 스트리밍하는 데이터의 양 사이에는 절충이 있으므로, 어떤 크기가 앱과 희소한 텍스처와 가장 잘 작동하는지 실험해야 합니다.

다음으로, 금속 개발자 도구 세트를 사용하여 앱에서 빠른 리소스 로딩을 프로파일링하고 디버깅하는 방법을 살펴보겠습니다.

Xcode 14에는 빠른 리소스 로딩을 완벽하게 지원합니다.

Metal System Trace를 사용한 런타임 프로파일링부터 API 검사 및 Metal 디버거를 사용한 고급 종속성 분석까지.

런타임 프로파일링부터 시작합시다.

Xcode 14에서 Instruments는 Metal System Trace 템플릿으로 빠른 리소스 로딩을 프로파일링할 수 있습니다.

Instruments는 Metal 앱에서 최고의 성능을 달성하는 데 도움이 되는 강력한 분석 및 프로파일링 도구입니다.

금속 시스템 추적 템플릿을 사용하면 로드 작업이 인코딩되고 실행될 때 확인할 수 있습니다.

앱이 CPU와 GPU 모두에서 수행하는 활동과 어떤 관련이 있는지 이해할 수 있습니다.

악기로 메탈 앱을 프로파일링하는 방법을 배우려면, 이전 세션인 "GPU 카운터로 메탈 앱과 게임 최적화"와 "애플 GPU를 위한 고급 게임 최적화"를 확인하세요.

이제, 기어를 디버깅으로 바꾸자.

Xcode 14의 Metal 디버거를 사용하면 이제 게임의 새로운 빠른 리소스 로딩 API 사용을 분석할 수 있습니다.

프레임 캡처를 받으면, 모든 빠른 리소스 로딩 API 호출을 검사할 수 있습니다.

생성된 IO 명령 버퍼에서 발행된 로드 작업까지.

이제 새로운 종속성 뷰어로 빠른 리소스 로딩 종속성을 시각적으로 검사할 수 있습니다.

종속성 뷰어는 IO 명령 버퍼와 메탈 패스 간의 리소스 종속성에 대한 자세한 개요를 제공합니다.

여기에서 새로운 동기화 에지 및 그래프 필터링과 같은 새로운 종속성 뷰어의 모든 기능을 사용하여 리소스 로딩 종속성을 깊이 파고들고 최적화할 수 있습니다.

Xcode 14의 새로운 종속성 뷰어에 대해 자세히 알아보려면, 올해의 "Go bindless with Metal 3" 세션을 확인하세요.

이제, 빠른 자원 로딩을 살펴봅시다.

이것은 새로운 빠른 리소스 로딩 API를 사용하여 타일 크기가 16킬로바이트인 희박한 텍스처를 사용하여 텍스처 데이터를 스트리밍하는 테스트 장면입니다.

이 비디오는 M1 Pro 칩이 장착된 MacBook Pro에서 가져온 것입니다.

스트리밍 시스템은 GPU의 스파스 텍스처 액세스 카운터를 쿼리하여 두 가지를 식별합니다: 샘플링했지만 로드되지 않은 타일과 앱이 사용하지 않는 로드된 타일.

이 앱은 이 정보를 사용하여 필요한 타일의 로드 목록과 필요하지 않은 타일의 퇴거 목록을 인코딩합니다.

그런 식으로, 작업 세트에는 앱이 대부분 사용할 가능성이 있는 타일만 포함되어 있습니다.

플레이어가 장면의 다른 부분으로 이동하기로 결정하면, 앱은 완전히 새로운 고해상도 텍스처 세트로 스트리밍해야 합니다.

스트리밍 시스템이 충분히 빠르다면, 플레이어는 이 스트리밍이 일어나는 것을 알아차리지 못할 것이다.

장면을 일시 중지하면 이미지 차이를 더 명확하게 관찰할 수 있습니다.

왼쪽은 pread API를 사용하여 단일 스레드에 스파스 타일을 로딩하고 있다.

오른쪽은 빠른 리소스 로딩 API를 사용하여 스파스 타일을 로딩하고 있다.

플레이어가 장면에 들어갈 때, 대부분의 텍스처가 완전히 로드되지 않았다.

로드가 완료되면, 텍스처의 최종 고해상도 버전을 볼 수 있습니다.

이 장면의 시작으로 돌아가서 속도를 늦추면, 빠른 리소스 로딩이 제공하는 개선 사항을 더 쉽게 알아차릴 수 있습니다.

차이점을 강조하기 위해, 이 렌더링은 앱이 아직 빨간색 색조로 로드되지 않은 타일을 표시합니다.

처음에, 그 장면은 앱이 대부분의 타일을 로드하지 않았다는 것을 보여준다.

그러나, 플레이어가 장면에 들어갈 때, 빠른 리소스 로딩은 고해상도 타일의 로딩을 개선하고 단일 스레드 프리어드 버전에 비해 지연을 최소화합니다.

Metal 3의 빠른 리소스 로딩은 앱이 최신 스토리지 기술을 활용할 수 있는 강력하고 효율적인 자산 스트리밍 시스템을 구축하는 데 도움이 됩니다.

고품질 이미지를 포함하여 제 시간에 자산을 스트리밍하여 로드 시간을 줄이는 데 사용하세요.

GPU가 장면을 렌더링하는 동안 Metal의 공유 이벤트를 사용하여 자산을 비동기적으로 로드하세요.

앱이 급하게 필요로 하는 자산의 경우, 우선 순위가 높은 명령 대기열을 만들어 대기 시간을 최소화하십시오.

그리고 로드 명령을 일찍 보내 스토리지 시스템을 바쁘게 유지하세요.

당신은 언제든지 필요하지 않은 것을 취소할 수 있습니다.

Metal 3의 빠른 리소스 로딩은 높은 처리량 자산 로딩을 위해 최신 스토리지 하드웨어의 힘을 활용하는 새로운 방법을 소개합니다.

앱의 시각적 품질과 반응성을 개선하기 위해 이러한 기능을 어떻게 사용하는지 빨리 보고 싶습니다.

봐줘서 고마워.

♪