10040

♪ ♪

가브리엘 팅: 안녕하세요, "인앱 구매 통합 및 마이그레이션을 살펴보세요" 세션에 오신 것을 환영합니다.

이 세션은 두 부분으로 나뉩니다: 하나는 App Store 서버 API로 마이그레이션하는 데 전념하고, 다른 하나는 App Store 서버 알림 버전 2로 마이그레이션하는 데 전념합니다.

제 이름은 가브리엘이고, 앱 스토어 서버 API로 마이그레이션하는 방법에 대해 논의하고 있습니다.

알렉스 베이커: 제 이름은 알렉스이고, 앱 스토어 서버 알림 버전 2로 마이그레이션하는 과정을 안내해 드리겠습니다.

가브리엘: 먼저 App Store 서버 API와 App Store 서버 알림에 대한 간략한 소개부터 시작하겠습니다.

우리는 작년에 데이터를 얻고 서버에서 작업을 수행할 수 있는 강력하고 안전하며 효율적인 방법으로 App Store Server API를 도입했습니다.

우리는 당신이 받은 데이터가 변조되지 않고, 당신을 위한 것이며, App Store에 의해 서명되었는지 확인할 수 있도록 JSON 웹 서명 또는 JWS 형식으로 서명된 필요한 데이터만 제공하는 것을 목표로 합니다.

예를 들어, App Store Server API 엔드포인트 중 하나인 Get Transaction History 엔드포인트는 새로운 필터 및 정렬 기능과 함께 원래TransactionId만으로 지정한 모든 트랜잭션 세트를 가져올 수 있습니다.

App Store 서버 알림 버전 2의 창에서, 나타낼 수 있는 구독 상태의 수가 증가함에 따라, 알림 버전 2는 구독의 가능한 모든 상태를 실시간으로 업데이트합니다.

우리는 우리에게 정보를 요청할 필요 없이 구독자에게 무슨 일이 일어나고 있는지에 대해 알아야 할 모든 정보를 적극적으로 제공하는 것을 목표로 합니다.

알렉스는 이 세션의 그의 부분에서 당신에게 이것을 더 많이 안내할 것입니다.

이러한 기능을 쉽고 효과적으로 사용하는 것이 흥미로웠다면, 이 세션은 당신을 위한 것입니다.

App Store Server API 및 App Store 서버 알림 버전 2를 사용하는 방법과 몇 가지 마이그레이션 팁 및 모범 사례를 안내해 드리겠습니다.

이들 각각에 대한 추가 정보는 아래에 나열된 추가 세션을 참조하십시오.

그러니 App Store Server API로 마이그레이션하는 것에 대해 논의하기 시작합시다.

먼저, 우리는 App Store Server API를 사용하는 방법에 대해 논의할 것입니다.

둘째, 우리는 JSON 웹 토큰 서명에 대한 몇 가지 세부 사항에 대해 자세히 알아볼 것입니다.

셋째, 우리는 당신이 App Store에서 받은 서명된 거래가 진짜인지 확인하는 방법을 보여줄 것입니다.

마지막으로, 우리는 verifyReceipt에서 App Store Server API로 마이그레이션하는 방법에 대해 논의할 것입니다.

시작하자.

먼저, 다른 버전의 StoreKit에서 App Store Server API를 사용하는 방법에 대해 이야기해 봅시다. 먼저 원래 StoreKit으로, 그 다음에는 StoreKit 2로, StoreKit 2를 지원하는 iOS 버전을 사용하는 두 클라이언트 모두에 대해 동시에 지원하는 방법에 대해 논의해 봅시다.

먼저, App Store Server API에 대한 요청이 어떻게 생겼는지 살펴봅시다.

여기에 나열된 다섯 개의 API가 originalTransactionId를 경로 매개 변수로 사용한다는 것을 알 수 있습니다.

이를 통해 영수증, 서명된 거래, 서명된 갱신 및 알림에서 받은 원본 트랜잭션 ID를 사용하여 이러한 API를 쉽게 호출할 수 있습니다.

다음은 주문 ID 찾기 엔드포인트입니다.

이 엔드포인트는 대신 지원 쿼리를 위해 고객이 제공한 orderId를 사용합니다.

이것은 고객이 각 거래에 대한 고객 영수증에 주문 ID를 제공하지만 원본 TransactionId는 제공되지 않기 때문에 고객의 직접 질문에 더 잘 지원할 수 있도록 하기 위한 것입니다.

이를 통해 고객이 보유하고 있는 데이터로 고객 문의에 직접 응답할 수 있습니다.

여기에 나열된 마지막 엔드포인트는 알렉스가 이 세션의 그의 부분에서 다룰 알림과 관련이 있다.

다음으로, Original StoreKit에서 originalTransactionIds를 어디서 얻을 수 있는지 살펴봅시다.

통합 앱 영수증으로 verifyReceipt를 호출하면, App Store Server API를 호출할 때 사용할 원래TransactionId는 이 사용자가 구매한 각 거래에 대한 영수증과 latest_receipt_info 및 pending_renewal_info의 in_app 필드에 다시 나타납니다.

이제 Original StoreKit 거래에서 originalTransactionId를 얻는 방법을 알았으니, 고객, App Store 서버 및 서버 간의 전체 흐름을 살펴보겠습니다.

먼저, 서버에서 앱 영수증을 받으세요.

다음으로, 앱 영수증을 가지고 서버에서 verifyReceipt에 전화하세요.

이것은 해독된 영수증을 반환할 것이다.

디코딩된 영수증에서, 내가 이전에 보여준 것과 정확히 같은 방식으로 모든 원본 거래 ID를 수집하세요.

다음으로, 수집된 원본 트랜잭션 ID 중 하나로 거래 기록 가져오기 엔드포인트를 호출할 수 있으며, 이는 이 사용자의 거래 내역을 서명된 거래로 반환합니다.

이러한 거래에는 비소모품, 환불된 소모품, 비갱신 구독 및 자동 갱신 구독이 포함됩니다.

그런 다음, 특정 구독에 대한 최신 서명된 거래와 서명된 갱신 정보를 받으려면, 해당 originalTransactionId로 Get All Subscription Statuses 엔드포인트를 호출하십시오.

이것은 주어진 originalTransactionId에 해당하는 구독에 대한 모든 서명된 거래와 갱신을 반환할 것이다.

다음으로, StoreKit 2 거래의 경우 originalTransactionId가 어디에 있는지 살펴봅시다.

이것은 거래에서 원본 TransactionId를 얻기 위한 클라이언트의 코드입니다.

StoreKit 2를 지원하는 장치, 즉 iOS 15 이상에 있는 장치에서는 검증되고 디코딩된 트랜잭션에서 originalID 속성을 얻을 수 있습니다.

이제 서버 측을 살펴보면, 여기에 서명된 JWS 거래의 예가 있습니다. 이는 App Store 서버 API 및 App Store 서버 알림에서 서명된 거래 및 서명된 갱신에서 받는 데이터 유형입니다.

여기서, 우리는 originalTransactionId가 최상위 필드라는 것을 알 수 있다.

다음으로, 고객, App Store 서버 및 StoreKit 2 거래를 위한 서버 간의 전체 흐름을 살펴보겠습니다.

먼저, 장치에서 서명된 거래를 가져가세요.

StoreKit 2를 사용하면 장치에서 이 거래를 확인할 수 있습니다.

온디바이스 상태 리스너, 거래 리스너 또는 마지막 거래를 사용하면 최신 거래, 취소 및 환불에 대한 업데이트를 유지한 다음 기록 보관을 위해 서버로 보낼 수 있습니다.

예를 들어, 이것들은 구독 갱신, 구독 제안 상환, 만료 등에 대해 업데이트됩니다.

당신의 서버로 거래를 보내세요.

알렉스가 다음 섹션에서 더 자세히 살펴볼 App Store 서버 알림과 함께, App Store Server API를 호출하지 않고도 구독의 최신 상태와 상태를 최신 상태로 유지할 수 있습니다.

구독 갱신일 연장과 같은 구독에 대한 작업을 수행해야 할 때, 서명된 거래에서 originalTransactionId를 사용하여 해당 엔드포인트를 호출하고 필요한 데이터를 되돌릴 수 있습니다.

이제 원래 StoreKit 및 StoreKit 2와 함께 App Store Server API를 사용하는 방법을 보았으므로 StoreKit과 StoreKit 2를 모두 지원하는 방법에 대해 이야기해 봅시다.

StoreKit 2를 완전히 채택하지 않고도 App Store Server API를 활용할 수 있습니다.

이전에 표시된 바와 같이, Original StoreKit의 영수증에서 originalTransactionId를 얻을 수 있습니다.

JWS 거래에서 StoreKit 2에서 원본 트랜잭션 ID를 얻을 수도 있습니다.

다른 API와 독립적으로 App Store Server API를 사용할 수도 있습니다.

그것은 다른 API의 특정 버전을 사용하는 것과 관련이 없다.

앱 스토어 서버 알림 측면에서, 버전 1 또는 버전 2 알림과 함께 사용할 수 있습니다.

버전 2를 사용하는 것이 좋습니다. 왜냐하면 구독 변경 사항이 발생할 때 알림을 보내고, 안전한 JWS 형식을 사용하기 때문입니다. 알렉스는 이 세션의 그의 부분에서 더 자세히 알아볼 것입니다.

그러나, 버전 1 알림과 함께 또는 전혀 알림 없이 App Store Server API를 별도로 사용할 수 있습니다.

다음으로, 이전에 진행한 마이그레이션 단계를 완료한 후 새로운 구매를 처리하는 방법에 대해 논의해 봅시다.

원래 StoreKit을 사용하여 장치에서 새로운 구매를 지원하기 위해, 새로운 영수증을 받아 서버로 보내고, 그 과정에서 새로운 데이터를 수집하는 동안 내가 이전에 보여준 것과 정확히 같은 단계를 수행할 수 있습니다. 새로운 영수증으로 verifyReceipt를 호출하고, latest_receipt의 새로운 originalTransactionId로 디코딩된 영수증을 받고, 영수증의 in_app 섹션에서 다른 originalTransactionIds

그런 다음, 새로운 originalTransactionId를 가져와서, 해당 구독의 최신 상태를 얻기 위해 Get All Subscription Statuses 엔드포인트를 호출해야 하는 경우와 같이 필요에 따라 App Store Server API를 호출할 수 있습니다.

이제 Original StoreKit과 StoreKit 2 모두에서 App Store Server API를 사용하는 방법을 다루었으므로, App Store Server API를 호출하기 위한 요구 사항인 JSON 웹 토큰 서명에 대한 몇 가지 세부 사항에 대해 알아보겠습니다.

개발자 계정이 App Store Server API의 호출자임을 인증하기 위해 JWT라고도 하는 JSON 웹 토큰을 사용하여 요청을 인증합니다.

이 토큰은 서버의 호출에서 인증 헤더로 모든 요청에 포함되어야 합니다.

JWT는 헤더, 페이로드 및 서명으로 구성되어 있다.

다음으로, 우리는 당신의 애플리케이션에 특화된 JWT를 구성하는 방법에 대해 알아 보겠습니다.

여기서, 우리는 JSON 웹 토큰이 어떻게 구성되는지, 그리고 헤더와 페이로드의 구조를 볼 수 있습니다.

토큰 자체는 마침표로 구분된 세 부분으로 나눌 수 있습니다: 기본 64로 인코딩된 헤더, 기본 64로 인코딩된 페이로드, 그리고 서명 비밀을 사용하여 서명된 기본 64로 인코딩된 헤더와 페이로드로 구성된 서명.

헤더는 데이터에 서명하는 방법에 대한 메타데이터가 포함된 필드로 구성되어 있습니다.

여기서 중요한 필드 중 하나는 App Store Connect의 개인 키 ID인 키 ID입니다.

이것은 JWT에 서명하는 데 사용하는 키와 일치해야 합니다.

페이로드에는 특정 애플리케이션에 대한 추가 정보가 포함되어 있습니다.

API 키를 얻는 방법에 대한 추가 정보와 지침은 "App Store Server API와 함께 사용할 API 키 만들기" 문서를 참조하십시오.

이러한 각 필드에 대한 자세한 내용은 "API 요청을 위한 토큰 생성" 기사를 참조하십시오.

모든 적절한 정보가 있는 헤더와 페이로드가 있으면, 다음으로 keyId에 해당하는 인증서를 사용하여 JWT에 서명할 것입니다.

여기 언어에 관계없이 사용할 수 있는 핵심 의사 코드가 있습니다.

먼저, 우리가 방금 살펴본 헤더에 제공된 키 ID에 해당하는 개인 키가 있는지 확인하세요.

그런 다음, JWT 라이브러리가 개인 키, 헤더 및 페이로드로 노출하는 서명 함수를 호출하십시오.

헤더에는 서명 알고리즘이 포함되어 있기 때문에, JWT 라이브러리는 제공된 알고리즘에 따라 서명합니다.

마지막으로, 다음은 Get All Subscription Statuses 엔드포인트에 대한 cURL 호출을 인증할 때 이 토큰의 사용 예입니다.

${token}과 ${originalTransactionId}를 각각 생성한 토큰의 값과 원하는 originalTransactionId로 바꾸세요.

다음으로, 당신이 받은 서명된 거래가 당신을 위한 것이고 App Store에서 서명했는지 확인하는 방법에 대해 이야기해 봅시다.

서명된 트랜잭션은 본질적으로 자바스크립트 객체 표기법 또는 암호로 서명된 JSON 객체로, App Store와 서버 사이에서 변조된 경우 이를 감지할 수 있습니다.

서명된 거래는 JSON 웹 서명 또는 JWS 형식으로 서명됩니다.

App Store에서 보내는 서명된 거래는 JWS 형식으로 도착할 것입니다.

당신이 받은 JWS를 확인함으로써, 당신은 데이터가 App Store에서 왔는지, 그리고 콘텐츠가 변조되었는지 확인할 수 있습니다.

이제, 서명된 거래를 확인하는 방법을 살펴봅시다.

먼저, 베이스 64는 헤더를 디코딩한다.

그런 다음, alg 클레임을 통해 어떤 서명 알고리즘을 사용할지 결정할 수 있습니다.

이것은 JWS 확인의 일환으로 사용될 것이다.

X5c 클레임의 인증서 체인은 Apple에서 발행하며, 클레임의 유효성 검사는 데이터가 제대로 서명되고 변조되지 않았음을 나타냅니다.

JWS를 확인하는 방법에 대한 자세한 내용은 App Store 개발자 문서를 참조하십시오.

본질적으로, x5c 체인은 인증서 체인이다.

인증서 체인의 성공적인 검증은 데이터를 신뢰할 수 있고 데이터가 Apple에 의해 서명되었다는 것을 알려줍니다.

인증서 체인에 대한 주문 문제. 먼저 루트 인증서가 나온다.

이 루트 인증서에는 추가 인증서가 뒤따를 수 있으며, 각 인증서는 이전 인증서로 서명됩니다.

나는 체인의 마지막 인증서를 리프 인증서라고 부를 것이다.

첫 번째 인증서는 루트 인증서라고 불리며 자체 서명됩니다.

이 인증서는 Apple의 인증 기관에서 받은 루트 인증서와 일치해야 합니다.

인증서가 일치하지 않으면, 체인을 신뢰해서는 안 됩니다.

체인의 마지막 인증서인 리프 인증서는 JWS에 서명하는 데 사용되는 인증서입니다.

다음은 App Store가 보내는 JWS의 헤더가 어떻게 생겼는지에 대한 예입니다.

첫 번째는 JWS에 서명하는 데 사용되는 알고리즘이다.

다음은 인증서가 순서대로 나열된 x5c 인증서 체인입니다.

이제, 높은 수준의 개요에서 x5c 인증서 체인을 생성하는 것이 어떻게 생겼는지 살펴봅시다.

우리는 Apple 인증 기관의 루트 인증서로 시작합니다.

그런 다음, 루트 인증서는 중간 서명 인증서에 서명하는 데 사용됩니다.

그런 다음 중간 서명 인증서는 잎 인증서에 서명하는 데 사용됩니다.

이제 x5c 인증서 체인을 생성하는 것이 어떻게 생겼는지 다뤘으니, 체인을 확인하는 것이 어떻게 생겼는지 살펴봅시다.

리프 인증서부터 시작하여, 우리는 그것이 중간 서명 인증서에 의해 서명되었는지 확인합니다.

그런 다음 우리는 중간 서명 인증서가 루트 인증서에 의해 서명되었는지 확인합니다.

또한, 루트 인증서는 Apple 인증 기관의 인증서와 일치해야 합니다.

이 모든 단계가 성공하면, 전체 체인이 합법적인 것으로 확인된다.

인증서 체인을 확인하는 방법에 대해 이야기해 봅시다.

다음은 OpenSSL을 사용하여 x5c 인증서 체인을 확인하는 명령입니다.

이것을 조각으로 나누면, 확인 명령은 대체로 검증을 위해 인증서를 전달할 수 있게 해준다.

신뢰할 수 있는 플래그를 사용하면 신뢰할 수 있는 인증서를 제공할 수 있습니다. 즉, 다음 인증서를 확인하는 데 사용되는 인증서입니다.

이 경우, 우리는 당신이 Apple 인증 기관에서 얻은 루트 인증서를 전달하고 있으므로 신뢰할 수 있습니다.

우리는 이것을 사용하여 체인의 다음 인증서인 WWDR 인증서를 확인할 것입니다.

신뢰할 수 없는 플래그를 사용하면 신뢰할 수 있는 인증서를 사용하여 확인하려는 인증서 또는 인증서를 제공할 수 있습니다.

여기서, 우리는 먼저 루트 인증서로 서명된 Apple 인증 기관의 WWDR 인증서를 통과합니다.

이것은 x5c 체인의 두 번째 인증서와 일치해야 한다.

그리고 마지막으로, 여기 리프 인증서는 이전 인증서로 서명된 마지막 인증서입니다.

성공적인 검증의 경우, 성공 코드가 반환됩니다.

그런 다음 디코딩된 정보를 사용할 수 있습니다.

검증에 실패한 경우, 반환된 오류 코드를 기반으로 문제를 결정하십시오.

확인할 수 없다면, 이 데이터는 변조될 수 있으며 사용해서는 안 됩니다.

OpenSSL을 사용하여 x5c 인증서 체인을 확인하는 방법에 대한 전체 지침은 App Store 개발자 문서를 참조하십시오.

여기 서명된 거래를 확인하는 방법에 대한 의사 코드가 있습니다.

먼저, 확인하고 싶은 JWS를 받으세요.

그런 다음, JWS 라이브러리가 검증에 필요한 인증서를 가져가세요.

적절한 인증서를 사용하여 JWS 라이브러리의 확인 기능을 호출하세요.

JWS에 서명하는 인증서는 리프 인증서이지만, 일부 라이브러리는 전체 체인을 통과해야 합니다.

통화가 성공한 경우, 작업을 진행할 수 있습니다.

이것이 App Store Server API에 대한 호출의 결과인 경우, 검증된 데이터를 저장할 수 있습니다.

알림의 경우, 알렉스는 이 세션의 그의 부분에서 이것에 더 많이 들어갈 것이다.

JWS를 검증할 수 없는 경우, JWS를 사용하지 마세요.

이것은 App Store에서 변조되었거나 전송되지 않았다는 것을 의미할 수 있습니다.

알렉스는 알림을 사용할 때 보안을 더 잘 보장하는 방법에 대해 더 자세히 알아볼 것이다.

JWS 확인 및 처리에 대한 전체 지침은 App Store 개발자 문서를 참조하십시오.

이제, verifyReceipt에서 App Store Server API로 마이그레이션하기 위한 몇 가지 사용 사례를 검토해 봅시다.

먼저, 주어진 구독자의 최신 상태를 확인하고 싶은 경우를 살펴봅시다.

이를 통해 개별 구독에 대한 변경 사항을 최신 상태로 유지할 수 있습니다.

이전에는 구독자의 최신 상태를 얻으려면 verifyReceipt를 호출하여 만료 의도, grace_period_expires_date 등과 같은 필드를 기반으로 구독 상태를 결정해야 했습니다.

이제 App Store Server API를 사용하면 모든 구독 상태 가져오기 엔드포인트를 호출하여 현재 상태와 최신 서명된 거래 및 갱신 정보가 포함된 상태 필드와 함께 구독의 최신 상태를 얻을 수 있습니다.

당신이 이것을 어떻게 실행할 수 있는지의 흐름을 살펴봅시다.

먼저, 당신이 가지고 있는 디코딩된 영수증의 경우, 제가 이전에 보여준 방식으로 원본 TransactionIds를 얻을 수 있습니다.

그런 다음, 해당 원본 TransactionId에 대한 모든 구독 상태 가져오기 엔드포인트를 호출할 수 있으며, 이는 해당 거래에 대한 최신 서명된 거래 및 갱신을 반환합니다.

다음으로, 최신 거래를 얻는 경우를 살펴봅시다.

최신 거래를 받으면 사용자가 무엇을 구매했는지, 무엇을 갱신했는지, 사용자의 구독에 변경 사항이 있는지 등을 알 수 있습니다.

이전에는 사용자의 최신 거래를 얻기 위해 verifyReceipt를 호출하고 in_app 배열을 사용하고 사용자의 모든 거래를 포함하는 latest_receipt_info를 검사해야 했습니다.

App Store Server API를 사용하여 최신 거래를 얻기 위해 거래 기록 가져오기 엔드포인트를 사용하면 사용자의 전체 구매 내역을 가져올 수 있습니다.

또한, WWDC22 토크인 "인앱 구매의 새로운 기능"에서 다루는 새로운 필터 및 정렬 기능과 결합된 페이지 매김은 필요한 데이터를 효율적으로 정확하게 가져올 수 있도록 합니다.

이것이 무엇을 수반할 수 있는지의 흐름을 살펴봅시다.

해당 사용자에게 속한 모든 originalTransactionId를 사용하면 Get Transaction History 엔드포인트를 호출할 수 있으며, 이는 이 사용자의 거래 내역을 서명된 거래로 반환하고, 필터링되고, 정렬되고, 사양에 따라 페이지가 매겨집니다.

마지막으로, appAccountToken을 채택한 사례를 살펴봅시다.

appAccountToken 필드를 사용하면 StoreKit 2 트랜잭션을 사용자와 연결하는 UUID를 제공할 수 있습니다.

그런 다음, 서명된 거래, 서명된 갱신 및 해당 거래에 대한 알림에 appAccountToken이 나타납니다.

이전에는 StoreKit2의 새로운 기능이었기 때문에 원래 StoreKit에서 appAccountToken을 지원하지 않았습니다.

이제, 우리는 Original StoreKit 클라이언트와의 호환성을 지원하기 위해 Original StoreKit의 필드 애플리케이션 사용자 이름에 UUID를 제공하는 지원을 추가했습니다.

이 조건 하에서, UUID는 appAccountToken이 하는 모든 기능을 지원할 것이다.

그런 다음 appAccountToken은 Original StoreKit 사용자의 verifyReceipt로 돌아오며, App Store Server API 호출 및 App Store 서버 알림의 알림에서 Original StoreKit 및 StoreKit 2 사용자 모두에게 나타납니다.

그것은 이 세션의 App Store Server API 부분에 대한 것입니다.

다음으로, 앱 스토어 서버 알림 버전 2로 마이그레이션하는 알렉스가 있습니다.

알렉스: 고마워, 가브리엘.

제 이름은 알렉스이고, 오늘 여기에 와서 앱 스토어 서버 알림 버전 2에 대해 논의하게 되어 기쁩니다.

먼저, 우리는 버전 2 알림을 시작하는 방법을 다룰 것입니다.

다음으로, 버전 2 알림이 어떻게 다르고 사용 가능한 다른 모델을 기반으로 구축되는지.

셋째, 우리는 놓친 알림의 경우 회복과 이 작업을 수행하는 데 도움이 되는 새로운 자원 중 일부에 대해 이야기할 것입니다.

마지막으로, 알림이 고객 행동에 대한 통찰력을 제공하고 구독 수명 주기에 대한 정보를 얻을 수 있는 추가 기회를 창출하는 방법.

알림이 무엇이고 누가 그것을 사용할 수 있는지에 대한 간략한 소개를 살펴봅시다.

앱 스토어 서버 알림은 앱 사용자가 특정 조치를 취할 때마다 보내는 메시지입니다.

이러한 알림은 대체로 구독 업데이트와 환불 업데이트의 두 가지 범주로 분류되지만, 우리는 항상 추가 시나리오를 다루기 위해 노력하고 있습니다.

우리는 앱에서 사용할 수 없는 사용자 행동의 격차를 메우기 위해 이러한 알림을 제공합니다.

예를 들어, 우리의 가장 일반적인 사용 사례 중 하나는 구독 갱신이다.

이 거래를 사용할 수 있게 되면 사용자가 앱에 없을 수 있습니다.

App Store 서버 알림은 구독이 갱신될 때 최신 거래 정보를 서버에 직접 전송하여 이 문제를 해결하는 데 도움이 됩니다.

버전 2 알림은 방금 가브리엘에게서 들은 StoreKit 2 모델 및 App Store Server API와 많은 유사점을 공유합니다.

그러나, 그들은 함께 잘 작동하지만, 모두 다른 시간에 채택될 수 있는 독립적인 도구이다.

가장 중요한 것은, 버전 2 서버 알림을 사용하는 동안 StoreKit 2를 사용할 수 없는 iOS-15 이전 클라이언트를 계속 지원할 수 있다는 것입니다.

우리는 버전 2 알림을 전체 구독 수명 주기 동안 사용자에 대한 정보를 제공하기 위한 가장 심층적이고 유연한 도구 중 하나로 만들기 위해 노력했습니다.

우리는 프레젠테이션의 뒷부분에서 이것에 대해 더 자세히 설명할 것이지만, 알림은 앱 외부에서 취한 조치에 대해 캡처하기가 거의 불가능한 정보를 제공합니다.

특히 알림과 버전 2 알림의 개념에 관심이 있기를 바랍니다.

더 나아가기 전에, 이 프레젠테이션은 시작과 알림을 받기 위한 모범 사례를 안내하지만, 전체 이야기를 말해주지는 않습니다.

알림과 다양한 사용 사례를 어떻게 충족시킬 수 있는지에 대한 자세한 내용은 최근 비디오를 참조하십시오.

버전 2 알림을 설정하는 것을 살펴봅시다.

우리는 당신의 첫 번째 알림을 받을 수 있도록 알림을 설정하는 방법을 살펴볼 것입니다.

먼저, App Store Connect에서 앱 페이지로 이동하세요.

아래로 스크롤하면, App Store 서버 알림 섹션을 볼 수 있습니다.

여기서 당신은 생산과 샌드박스 모두에 대한 옵션을 볼 수 있습니다.

각 환경은 별도의 URL과 별도의 알림 버전을 포함할 수 있습니다.

다음은 생산 설정에 대한 옵션 페이지의 예입니다.

샌드박스 설정은 정확히 동일합니다.

특히 버전 1 알림 사용자인 경우, 샌드박스 환경에서 버전 2 알림을 먼저 시도하는 것이 좋습니다.

이곳은 생산 설정에 영향을 미치지 않고 알림에 익숙해질 수 있는 좋은 장소입니다.

샌드박스 설정 버튼을 선택하고, 서버의 URL을 제공하고, 버전 2 알림을 선택하세요.

알림을 트리거하기 전에, 서버 엔드포인트에 유효한 HTTPS 인증서가 있는지 확인하세요.

또한 Apple의 공용 IP가 서버에 액세스할 수 있도록 허용했는지 확인하세요.

알림을 설정할 때 가장 일반적인 실패 중 일부는 방화벽과 인증서와 관련이 있습니다.

이것들은 또한 초기 문제 해결 단계로 갑자기 알림 수신을 중단하는지 확인하는 것이 좋습니다.

이제 첫 번째 알림을 받을 준비가 되었습니다.

샌드박스에서 알림은 인앱 구독 구매와 같은 다양한 행동에 의해 트리거될 수 있습니다.

그러나 테스트하는 동안 쉽게 사용할 수 있도록 App Store Server API의 일부인 새로운 테스트 알림 요청 엔드포인트를 사용하여 알림을 트리거하는 것이 좋습니다.

이 엔드포인트는 알림 테스트 프로세스를 자동화하는 데 도움을 준다.

테스트 알림 요청 엔드포인트를 트리거한 후, 알림이 곧 도착할 것으로 예상됩니다.

알림을 받는 데 문제가 있는 경우, 알림이 전달되지 않은 이유에 대한 간략한 상태를 제공할 수 있는 새로운 Get Test Notification Status 엔드포인트를 참조하십시오.

예를 들어, SSL_ISSUE와 같은 상태는 HTTPS 인증서를 다시 확인하는 단서가 될 것입니다.

구성 변경을 수행할 때마다 테스트 알림을 트리거하는 것이 좋습니다.

이것은 변경 후에도 여전히 알림을 받을 수 있는지 확인하는 좋은 방법입니다.

이제, 당신이 방금 받은 알림을 이해하는 것으로 넘어가겠습니다.

우리가 이전에 가브리엘에게서 본 거래와 마찬가지로, 알림도 JWS 형식이다.

알림 페이로드를 디코딩하고 확인하는 방법을 살펴봅시다.

먼저, 알림을 받을 때, JSON 본문의 서명된 페이로드 필드를 추출하고 싶을 것입니다.

다음으로, 당신은 가브리엘이 서명된 거래를 확인하기 위해 이전에 안내한 것과 정확히 같은 단계를 수행할 것입니다.

서명된 데이터가 알림의 서명된 알림 페이로드인지 아니면 App Store Server API의 서명된 거래인지 확인하기 위해 동일한 단계를 따르게 됩니다.

다음으로, 알림이 어떤 앱을 위한 것인지 확인하는 것이 중요합니다.

동일한 엔드포인트를 공유하는 여러 앱이 있다면, 이것은 대상 앱을 결정하기에 좋은 장소입니다.

알림 대상 앱이 앱이며, 알림이 다른 개발자를 위한 것이 아니라는 것을 확인하는 것도 중요합니다.

마지막으로, 한 가지 더 유용한 확인은 알림 환경이 프로덕션 또는 샌드박스의 예상 환경과 일치하는지 확인하는 것입니다.

App Store Connect는 각 환경에 대해 별도의 URL을 허용하기 때문에, 이 요구 사항을 시행할 수 있으며, URL이 공유되는 경우 환경에 따라 알림을 별도로 저장하고 처리할 수 있습니다.

이 시점에서, JWS는 완전히 검증되었고 추가 처리를 위해 저장될 수 있다.

몇 가지 기본 점검 외에도 서버가 알림을 비동기적으로 처리하는 것이 좋습니다.

알림 처리가 너무 오래 걸리면, 우리 서버는 시간 초과를 기록하고 알림이 성공적으로 전달되지 않았다고 가정합니다.

그러면 우리는 알림을 다시 보낼 것이다.

따라서, 이 기능 외부로 시간 집약적인 처리를 이동하면 App Store 서버가 성공적으로 전송된 알림을 기록하고 재시도 시 서버가 알림을 재처리할 필요가 없도록 하는 데 도움이 됩니다.

이제, 확인 후 알림 본문을 살펴봅시다.

첫 번째 필드는 알림 유형과 선택적 하위 유형입니다.

결합하면, 이것들은 알림이 필요한 시나리오를 알려줍니다.

이 필드들은 또한 마지막 알림 이후 무엇이 바뀌었는지 보여주고 왜 이러한 변화가 발생했는지에 대한 정보를 제공하는 데 도움이 됩니다.

notificationUUID는 알림당 고유 식별자입니다.

서버가 알림을 재시도하면, 재시도된 알림에는 동일한 알림UUID가 포함됩니다.

이것은 서버가 알림을 처리했지만 적시에 성공적인 HTTP 응답 코드로 응답하지 않은 경우를 감지하는 데 도움이 됩니다.

이 필드를 기반으로 재시도로 인해 중복 알림 감지를 추가하는 것이 좋습니다.

signedDate 필드는 알림이 언제 생성되었음을 알려줍니다.

이것은 재시도된 알림을 감지하는 데 특히 유용합니다.

다음으로, appAppleId와 bundleId.

이것들은 목표 애플리케이션을 감지하는 데 중요하다.

앞서 논의했듯이, 이 필드를 확인하고 리플레이 공격을 방지하기 위해 예상 값과 일치하는지 확인하는 것이 중요합니다.

또한, 알림 환경이 예상 환경과 일치하는지 확인하고, 샌드박스 알림이 생산 데이터로 기록되지 않으며, 그 반대의 경우도 마찬가지입니다.

마지막으로, 실제 signedTransactionInfo와 선택적 signedRenewalInfo.

이것들은 서명 시 기본 구매의 최신 상태가 될 것이다.

이 시점에서, 알림을 분석하면, 최신 거래 및 갱신 정보와 상태 변경에 대한 최신 이유가 남게 됩니다.

이제 특정 알림을 설정하고 받는 것을 다뤘으니, 버전 2 알림 모델, 구독 수명 주기를 추적하기 위해 알림이 어떻게 어울릴 수 있는지, 그리고 버전 1 알림과의 비교를 통해 버전 2 알림 뒤에 있는 디자인 결정을 살펴보겠습니다.

버전 2는 구매 상태에 대한 정보를 보낼 때 다른 철학을 채택한다.

모든 최신 기록을 보내는 대신, 버전 2 알림은 최신 정보, 즉 최신 거래 정보, 구독의 경우 보류 중인 갱신 정보만 보내는 데 중점을 둡니다.

알림을 통해, 우리는 구독 수명 주기의 모든 단계에 대한 정보를 제공하기 위해 노력합니다.

따라서, 알림에는 구매 또는 구독에 대한 최신 정보만 포함되어 있습니다.

이러한 알림은 함께 구독 상태의 전체 타임라인을 만듭니다.

전체 거래 내역을 봐야 하고 알림 내역에 액세스할 수 없는 경우, 페이지가 매겨지고 필터링 가능한 컨텍스트에서 사용자의 전체 거래 내역을 쿼리할 수 있는 거래 내역 가져오기 엔드포인트와 잘 어울립니다.

둘째, 버전 1 알림은 고객이 StoreKit 2를 사용할 필요가 없습니다.

그리고 맞아, 버전 2도 마찬가지야.

사실, 클라이언트 측에서 어떤 프레임워크를 사용하든, 오늘부터 버전 2 알림의 혜택을 누릴 수 있습니다.

마지막으로, 버전 2 알림은 제공된 세부 사항의 수준을 향상시키고 추가 유형을 추가하고 새로운 하위 유형 필드를 추가하여 다루는 사례를 확장하기 위해 작동합니다.

이를 통해, 우리는 더 많은 시나리오를 다루고 구독 수명 주기의 모든 단계에서 알림을 제공할 수 있습니다.

우리가 추가한 주목할 만한 시나리오 중 일부는 만료, 자동 갱신 상태 변경과 관련된 더 세분화된 정보, 환불 절차에 대한 더 많은 시나리오를 포함합니다.

이제, 다루는 시나리오의 복잡성을 설명하고 더 구체적인 예를 제공하기 위해, 알림이 구독이 취하는 각 단계를 처음부터 끝까지 어떻게 알려줄 수 있는지 살펴봅시다.

구독하기 전에 사용자를 상상해 봅시다.

구독 시, 사용자는 갱신 구독 상태로 이동하고 SUBSCRIBED with subtype INITIAL_BUY 알림이 전송되거나, 제안이 사용된 경우 SUBtype INITIAL_BUY와 함께 OFFER_REDEEMED가 전송됩니다.

알림에는 첫 번째 서명된 거래와 서명된 갱신 정보가 포함될 것이다.

시간이 흐르고, 구독은 갱신되며, 갱신 상태에 머문다.

갱신할 때마다, 우리는 다음에 서명된 거래 정보와 함께 DID_RENEW 알림을 보냅니다.

사용자가 자동 갱신을 비활성화할 때마다 만료되는 구독 상태로 이동하면 하위 유형 AUTO_RENEW_DISABLED 알림이 있는 DID_CHANGE_RENEWAL_STATUS 알림을 받게 됩니다.

자동 갱신을 다시 활성화하지 않으면, 기간이 끝날 때 만료된 상태로 이동하면, 만료된 하위 유형 VOLUNTARY 알림을 받게 됩니다.

이제, 당신은 궁금할 것입니다, 다른 모든 알림 유형은 어디에 있나요?

알림을 통해 볼 수 있는 구독 수명 주기입니다.

많은 일이 일어나고 있어.

그리고 이 다이어그램은 전체 이야기조차 말해주지 않는다.

예를 들어, 환불/취소 수명 주기는 여기에 포함되지 않습니다.

이 다이어그램은 버전 2 알림이 다루고 구독 수명 주기의 각 단계를 알리기 위해 작동하는 방대한 시나리오를 보여줍니다.

내가 말하고 싶은 또 다른 요점은 우리가 가능한 모든 전환 상태를 다루기 위해 노력하고 있다는 것이다.

이것은 구독 추적을 위한 단일 소스가 되어 알림의 유용성을 높이고 구독자 여정의 모든 단계를 보고 있다는 자신감을 높이는 데 도움이 됩니다.

그러나, 이 모든 데이터가 여기에 있지만, 사용 가능한 모든 유형으로 작업할 필요는 없습니다.

예를 들어, 갱신 선호도 변경과 관련된 알림을 처리하는 것만으로도 가치를 제공할 수 있습니다.

특히 당신이 막 시작했다면, 당신의 상황에 가장 유용한 알림 유형부터 시작하세요.

이제, 서버를 설정한 후 일어나는 일을 다루겠습니다. 모든 것이 원활하게 실행되고 있지만, 아아, 서버가 다운됩니다.

며칠 동안, 몇 분 동안, 아니면 하나만 놓쳤을 수도 있다고 생각하든, 이 문제를 해결하는 데 도움이 되는 몇 가지 단계를 살펴봅시다.

당신의 서버를 상상해 봅시다.

그것은 성공적으로 설정되었고 알림을 받고 있다.

어느 시점에서, 당신의 서버에 문제가 있어서 알림을 받을 수 없습니다.

우리는 여전히 당신의 서버로 메시지를 보내려고 시도하고 있지만, 이제 그 요청들은 실패하기 시작합니다.

이 시나리오를 다루는 방법에는 여러 가지가 있다.

첫 번째는 그냥 기다리는 거야.

서버에서 성공적인 상태 코드를 받지 못하거나 전혀 연결할 수 없는 경우, 문서화된 재시도 정책에 따라 알림을 다시 시도할 것입니다.

버전 2 알림의 경우, 우리는 각 시도 후, 먼저 1시간 지연 후, 12시간 지연, 24시간, 48시간, 그리고 마지막으로 72시간 지연을 다시 시도합니다.

첫 번째 실패 후 한 시간 후에 알림이 다시 시도되기 때문에, 대기는 한 시간 미만의 정전에 적합합니다.

어느 시점에서 서버가 복구되고, 알림을 다시 받기 시작합니다.

먼저, 당신은 놓친 알림과 관련이 없는 새로운 알림을 받습니다.

알림은 지연으로 재시도되므로, 서버가 온라인 상태가 되면, 놓친 모든 알림을 즉시 받지 못할 것입니다.

시간이 흐르고 당신은 새로운 알림이 산재된 놓친 알림을 받기 시작합니다.

이것은 알림이 원본인지 재시도된 알림인지 어떻게 감지할 수 있는지에 대한 질문을 제기합니다.

알림을 검토해 봅시다.

이 알림에서, 우리는 단지 몇 개의 필드를 보여주고 있다.

알림에는 signedDate 필드가 포함되어 있습니다.

이 필드는 서명 날짜와 알림을 받은 시간을 비교하여 재시도를 감지하는 데 유용할 수 있습니다.

알림을 받은 날짜보다 훨씬 일찍 서명 날짜가 있는 알림을 본다면, 이는 정전을 경험했을 수 있음을 나타냅니다.

이 시나리오에서 6과 3으로 표시된 알림이 동일한 구독에 대한 것이라고 상상해 보세요.

이것은 원래의 거래Ids를 비교함으로써 결정될 수 있다.

이 경우, 알림 6 이후에 알림 3을 받았다고 해서 알림 6보다 더 새로운 정보가 포함되어 있다는 것을 의미하지는 않습니다.

다른 경우에는 서버에서 알림을 받았을 수 있지만, 성공적인 HTTP 200 상태 코드로 응답하지 못했습니다.

이로 인해 알림이 서버로 다시 전달될 수 있습니다.

앞서 논의한 바와 같이, 이러한 요청을 중복 제거하려면 notificationUUID 필드를 확인하십시오.

알림을 성공적으로 기록했음에도 불구하고 상당한 수의 재시도된 알림을 볼 수 있습니다.

이 경우, 알림을 받을 때마다 HTTP 200 응답으로 응답하고 있는지 확인하세요.

또한, 타임아웃을 기록하고 알림을 다시 보내는 것을 방지하기 위해 성공적으로 응답하기 전에 광범위한 처리를 하지 않도록 적시에 그렇게 하고 있는지 확인하십시오.

때때로, 특히 더 긴 정전의 경우, 다음 재시도 시간은 몇 시간 또는 며칠 전일 수 있으며, 장기간 정전의 경우 재시도 소진되었을 수 있습니다.

놓친 알림에서 복구하기 위한 다음 옵션은 알림 기록 가져오기 엔드포인트입니다.

우리는 방금 당신의 서버에 보낸 알림의 6개월 기록을 제공하는 새로운 알림 기록 가져오기 엔드포인트를 발표했습니다.

우리가 발표하는 다른 훌륭한 기능과 함께 이 엔드포인트에 대한 개요는 "인앱 구매의 새로운 기능" 비디오를 참조하십시오.

여기서 우리는 이 엔드포인트를 사용할 때 모범 사례와 도움이 될 수 있는 시나리오에 초점을 맞출 것입니다.

정전이 해결된 후, 정전의 시작 및 종료 타임스탬프에 유의하십시오.

알림 기록 가져오기 엔드포인트를 사용하면 특정 기간 동안 쿼리를 수행할 수 있습니다.

정전의 시작 및 종료 시간을 지정함으로써, 전체 기록을 통해 페이징을 요구하는 대신 놓쳤을 가능성이 있는 알림만 처리할 수 있습니다.

이것은 복구 속도를 향상시키고 이미 기록된 알림을 재처리하는 작업을 줄이는 데 도움이 될 것이다.

다음으로, 알림 기록 가져오기 엔드포인트를 사용하면 알림 유형별로 필터링할 수 있습니다.

연장된 정전을 경험하고 상당한 수의 알림을 예상하는 경우, 유형별로 필터링하고 DID_RENEW 및 EXPIRED와 같이 즉각적인 영향을 미칠 수 있는 유형으로 시작하는 것을 고려하십시오.

이것들은 당신이 가장 관련성이 높은 경우에 먼저 조치를 취하는 데 도움이 될 것입니다.

알림 유형을 전달할 때 한 가지 팁, notificationSubtype 필드가 생략되면, 이것은 하위 유형이 없는 알림만 반환합니다.

따라서, DID_RENEW notificationType에 표시된 예제의 경우, 이것은 BILLING_RECOVERY 하위 유형으로 DID_RENEW 알림을 반환하지 않습니다.

마지막으로, Get Notification History 엔드포인트를 사용하면 originalTransactionId를 사용하여 특정 사용자에게 필터링할 수 있습니다.

구독 수명 주기를 생각해보면, 우리는 사용자 여정의 모든 단계가 알림으로 커버되도록 노력했습니다.

따라서, 예를 들어 구독 갱신에서 만료까지 예상치 못한 방식으로 뛰어다니는 경우, 이는 해당 사용자에 대한 알림을 놓쳤다는 것을 나타낼 수 있습니다.

이것은 또한 사용자의 계정이 예상과 다른 상태에 있는 경우 고객 지원 맥락에서 유용할 수 있습니다.

이러한 경우, 해당 사용자의 알림 기록에 대한 쿼리를 보낼 수 있습니다.

알림 기록 가져오기 엔드포인트의 응답을 살펴봅시다.

단순함을 위한 응답에는 특정 값만 표시됩니다.

응답에서 반환된 값은 notificationHistory 배열에 있습니다.

배열의 각 항목은 하나의 알림을 나타낸다.

서명된 페이로드 필드에는 당신에게 전송된 정확한 알림이 포함되어 있습니다.

둘째, 우리는 첫 번째 SendAttemptResult 필드가 있습니다.

이 필드에는 서버에 의해 기록된 초기 알림 시도 결과를 기반으로 한 여러 값 중 하나가 포함되어 있습니다.

성공적인 경우, 이것은 성공의 가치가 될 것이다.

그러나, 우리가 방금 논의했듯이, 때때로 알림이 서버에 도달하지 못합니다.

이 메시지들은 해결 과정을 단순화하기 위해 문제의 방향을 가리키는 데 도움이 되는 일반적인 가이드가 되기 위한 것입니다.

예를 들어, 우리는 여기서 SSL_ISSUE를 본다.

이것은 서버의 SSL 인증서 또는 프로세스에 문제가 있음을 나타냅니다.

이 필드는 알림이 도착하지 않은 것을 보는 것 이상으로 서버 문제 진단에 대한 향상된 가시성을 제공합니다.

우리는 또한 테스트 알림을 사용할 때 이 기능을 제공하기 위해 테스트 알림 상태 엔드포인트에서 동일한 필드를 제공합니다.

이것들은 온보딩이나 문제 해결 중, 또는 정전의 근본 원인을 결정하는 동안 소급적으로 도움이 될 수 있습니다.

알림은 사용자 기록의 모든 경우를 다루지 않을 수 있습니다.

방금 알림을 채택했을 수도 있고 포함되지 않은 역사를 가진 기존 사용자가 있을 수도 있습니다.

또한 알림 기록 가져오기 엔드포인트에서 알림의 보존 기간보다 더 긴 기록을 검사할 수 있습니다.

그것이 Get Transaction History 엔드포인트가 그림으로 들어가는 곳이다.

앞서 가브리엘의 프레젠테이션에서 보았듯이, 이 엔드포인트는 알림을 사용하기 전에 사례를 다루는 고객에게 이들을 제공함으로써 이러한 문제를 해결합니다.

이제, 알림이 구매 내역을 넘어 통찰력과 기회를 제공할 수 있는 방법을 살펴봅시다.

버전 2 알림의 새로운 추가 사항 중 하나는 notificationType 필드에 추가 컨텍스트를 추가하는 하위 유형 필드입니다.

이 필드는 EXPIRED 또는 DID_CHANGE_RENEWAL_STATUS와 같은 특정 시나리오에서 더 많은 세부 사항을 제공하기 위한 것입니다.

예를 들어, EXPIRED로, 당신이 취하는 조치는 일반적으로 동일하며, 구독을 비활성으로 표시하고 제품에 대한 액세스를 취소합니다.

그러나, 사용자가 만료된 이유를 이해하는 것은 종종 유용할 수 있다.

청구 문제, 자발적인 선택, 또는 결코 받아들여지지 않은 가격 인상 때문인가요?

또 다른 알림인 DID_CHANGE_RENEWAL_STATUS는 알림을 사용할 때 추가 정보와 기회를 얻는 좋은 예입니다.

표면적으로, 그것은 우선순위가 낮은 것으로 보인다.

즉시 조치를 취할 필요가 없습니다.

제품에 대한 접근을 취소하기 위한 중요한 알림은 만료된 알림이다.

속지 마. 여기에는 많은 기회가 있다.

하나, 이 알림은 구독이 만료되기 전에 고객을 되찾을 수 있는 좋은 기회입니다.

특히 자동 갱신을 비활성화하는 것은 응용 프로그램 외부에서 발생할 수 있기 때문에, 이것은 만료일 전에 갱신 상태의 변경에 대해 알릴 수 있는 유일한 트리거가 될 수 있습니다.

이 알림은 또한 고객 행동에 대한 통찰력을 제공한다.

이 알림은 갱신 기간 동안 구독자가 언제 취소할지 결정하는 데 사용할 수 있습니다.

갱신 전날인가요?

신규 가입자는 서비스에 가입한 직후 자동 갱신을 비활성화하고 있나요?

이러한 유형의 정보는 취소의 원인을 이해하고 제품을 개선하는 데 중요할 수 있습니다.

마지막으로, 특정 시나리오는 알림 없이 사용자의 기록에 반영되지 않을 수 있습니다.

예를 들어, 사용자는 구독 기간이 만료되기 전에 비활성화한 다음 자동 갱신을 다시 활성화할 수 있습니다.

이 모든 것이 구독 기간 내에 발생하기 때문에, 구독의 장기 상태에는 영향을 미치지 않습니다.

이러한 결정은 고객을 이해하는 데 중요할 수 있으며, 알림은 이러한 유형의 시나리오를 감지하고 기록하기 위한 정보를 제공합니다.

전반적으로, 알림은 그 어느 때보다 더 많은 시나리오를 다루는 고객 여정의 모든 단계에서 정보를 제공함으로써 고객 행동을 이해할 수 있는 기회를 향상시키고 창출하기 위해 작동합니다.

결론적으로, 오늘 우리는 App Store 서버 API와 App Store 서버 알림을 모두 다루었습니다.

이것들은 구매를 관리하고 추적하는 기능을 개선하는 데 사용할 수 있습니다.

그들은 업데이트된 메시지 유형을 사용하고 그 어느 때보다 더 많은 사례를 다룹니다.

이 시스템은 모든 고객이 사용할 수 있으며 Original StoreKit 및 StoreKit 2와 상호 호환되며 구독 수명 주기를 모니터링하는 능력을 향상시킬 수 있습니다.

마지막으로, 이 도구들은 이미 샌드박스와 프로덕션 모두에서 사용할 수 있으며 모든 시스템에 큰 도움이 됩니다.

우리와 함께 해주셔서 감사드리며, 멋진 WWDC를 보내세요.