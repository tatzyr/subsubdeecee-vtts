10054

♪ 기악 힙합 음악 ♪

♪

안녕. 저는 SwiftUI 팀의 엔지니어인 커트입니다.

SwiftUI에는 탐색을 위한 몇 가지 흥미로운 새로운 API가 있습니다.

저는 이 새로운 API로 앱을 만드는 것을 즐겼고 당신과 공유할 수 있게 되어 기쁩니다.

이러한 API는 Apple TV, iPhone 및 Apple Watch와 같은 기본 스택에서 강력한 다중 열 프레젠테이션으로 확장됩니다.

새로운 API는 프로그래밍 방식 탐색과 딥 링크에 대한 강력한 지원을 제공하며, 앱을 위한 완벽한 구조를 구축할 수 있는 조각을 구성할 수 있습니다.

이 강연에서, SwiftUI에서 내비게이션이 있는 앱을 요리하기 위한 몇 가지 간단한 레시피를 드리겠습니다.

그리고 이미 SwiftUI를 사용하고 있다면, 이 새로운 API가 한 단계 끌어올릴 수 있기를 바랍니다.

새로운 데이터 기반 내비게이션 API에 들어가는 재료부터 시작하겠습니다.

그런 다음, 우리는 시음 메뉴로 이동할 것입니다: 내비게이션의 완전한 프로그래밍 제어를 위한 몇 가지 빠르고 쉬운 레시피.

디저트 코스의 경우, 앱에서 탐색 상태를 유지하기 위해 새로운 API를 사용하는 방법에 대한 몇 가지 팁을 공유하겠습니다.

이전에 SwiftUI에서 내비게이션을 사용한 적이 있다면, 새로운 API가 어떻게 다른지 궁금할 것입니다.

그래서 파고들기 전에, 기존 API 중 일부를 검토해 봅시다.

기존 API는 다른 열이나 스택에 표시된 뷰를 보내는 링크를 기반으로 합니다.

예를 들어, 루트 뷰에 내비게이션 링크 목록이 있을 수 있습니다.

내가 이 링크들 중 하나를 탭하면, 링크는 스택에서 보기를 푸시한다.

이것은 기본 내비게이션에 적합하며, 이 패턴을 계속 사용할 수 있습니다.

하지만 루트 뷰로 돌아가자.

기존 내비게이션 API를 사용하여 프로그래밍 방식으로 링크를 제시하기 위해 링크에 바인딩을 추가합니다.

예를 들어, item.showDetail을 true로 설정하여 이 링크의 보기를 제시할 수 있습니다.

하지만 이것은 각 링크에 대해 별도의 바인딩이 필요하다는 것을 의미합니다.

새로운 API를 통해, 우리는 NavigationStack이라고 불리는 전체 컨테이너에 바인딩을 들어 올립니다.

여기 경로는 스택에 푸시된 모든 값을 나타내는 컬렉션입니다.

내비게이션링크는 경로에 값을 추가합니다.

경로를 변경하여 딥 링크하거나, 경로에서 모든 항목을 제거하여 루트 보기로 이동할 수 있습니다.

이 강연에서는 새로운 내비게이션 API가 어떻게 데이터 기반 프로그래밍 방식 탐색을 가능하게 하는지 보여드리겠습니다.

나는 당신이 그것이 강력하고 사용하기 쉽기를 바랍니다.

새로운 내비게이션 API를 사용하기 위한 레시피에 뛰어들기 전에, 나는 메뉴에 있는 것을 공유하는 것이 도움이 될 것이라고 생각했다.

나는 최근에 요리에 정말 빠져들었고 내 레시피를 추적하기 위해 앱을 만들고 있어.

나는 이 정보를 제시하는 다양한 방법에 대해 많은 아이디어를 가지고 있다.

예를 들어, 여기 세 열 접근 방식이 있습니다.

첫 번째 열에서 레시피 카테고리를 선택할 수 있습니다.

카테고리를 선택하면, 두 번째 열에는 내가 수집한 레시피가 나열됩니다.

그리고 내가 레시피를 선택하면, 세부 영역은 그 레시피의 재료를 보여준다.

세부 영역에는 관련 레시피 선택에 대한 링크도 있습니다.

우리 할머니는 항상 "크러스트가 파이를 만든다"고 말씀하셨다.

그래서 그게 우리가 오늘 요리하는 거야.

우리의 재료는 새로운 내비게이션 API이다.

그것들을 파헤친 다음, 그것들을 함께 섞는 몇 가지 특정 내비게이션 레시피를 살펴봅시다.

새로운 내비게이션 API는 손님들이 그 구조를 이동할 수 있도록 도와주는 새로운 NavigationLink와 함께 앱의 구조를 설명하는 데 사용할 수 있는 몇 가지 새로운 컨테이너 유형을 소개합니다.

첫 번째 새로운 컨테이너는 내비게이션스택이다.

NavigationStack은 Apple Watch의 Find My, iPhone의 설정 및 macOS Ventura의 새로운 시스템 설정 앱에서 볼 수 있는 푸시 팝 인터페이스를 나타냅니다.

두 번째 새로운 컨테이너 유형은 NavigationSplitView이다.

NavigationSplitView는 Mac과 iPad의 Mail 또는 Notes와 같은 다중 열 앱에 적합합니다.

그리고 NavigationSplitView는 iPhone, iPad의 Slide Over, 심지어 Apple Watch 및 Apple TV의 단일 열 스택에 자동으로 적응합니다.

NavigationSplitView에는 두 세트의 이니셜라이저가 있습니다.

여기에 표시된 것처럼, 한 세트는 두 열의 경험을 만들어낸다.

다른 이니셜라이저 세트는 세 열의 경험을 만들어낸다.

NavigationSplitView에는 열 너비, 사이드바 프레젠테이션을 사용자 정의하고 프로그래밍 방식으로 열을 표시하고 숨길 수 있는 구성 옵션이 제공됩니다.

저는 이 강연에서 구성 옵션에 뛰어들지 않을 것이지만, 제 동료 Raj의 강연인 "iPad의 SwiftUI: 인터페이스 구성"과 NavigationSplitView를 앱에 맞게 조정하는 방법에 대한 훌륭한 문서를 확인하십시오.

이전에, 내비게이션링크는 항상 제시할 제목과 보기를 포함했다.

새로운 품종은 여전히 제목을 포함하지만, 제시하는 관점 대신 가치를 제시한다.

예를 들어, 이 링크는 사과 파이 레시피를 제시하고 있다.

보시다시피, 내비게이션링크는 똑똑합니다.

링크의 동작은 NavigationStack 또는 나타나는 목록에 따라 다릅니다.

이 맛있는 새로운 API가 어떻게 함께 작동하는지 보려면, 내 요리책 앱과 앱에서 사용하기 위한 몇 가지 구체적인 레시피를 살펴봅시다.

우리의 첫 번째 레시피는 Apple Watch의 나의 찾기 또는 iPhone의 설정에서 찾을 수 있는 것과 같은 기본적인 보기 스택입니다.

나는 각 카테고리에 대한 섹션이 있다.

섹션 내에서, 나는 세부 사항을 보기 위해 레시피를 탭할 수 있다.

모든 레시피 내에서, 관련 레시피 중 하나를 탭하여 스택에 밀어 넣을 수 있습니다.

뒤로 버튼을 사용하여 원래 레시피로 돌아간 다음 카테고리 목록으로 돌아갈 수 있습니다.

이 레시피는 NavigationStack과 새로운 다양한 NavigationLink, 그리고 내비게이션 대상 수정자를 결합합니다.

어떻게 하는지 보자.

나는 기본적인 내비게이션스택으로 시작할 것이다.

내부에는 내 모든 카테고리와 내비게이션 제목을 반복하는 목록이 있다.

목록 안에는 각 카테고리에 대한 섹션이 있습니다.

다음으로, 각 섹션 안에, 카테고리의 각 레시피에 대한 내비게이션 링크를 추가할 것입니다.

지금은, 나는 내 RecipeDetail 보기를 보여주는 링크를 만들 것이다.

이것은 기존 뷰 대상 NavigationLink를 사용하고 있습니다.

그리고 그것은 이 내비게이션 경험을 함께 요리하기에 충분하다.

하지만 프로그래밍 방식 내비게이션은 어때?

프로그래밍 방식의 탐색을 추가하려면, 나는 이 탐색 링크의 두 부분을 분리해야 한다: 그것이 제시하는 값과 그 값과 어울리는 보기.

어떻게 하는지 보자.

먼저, 링크에서 목적지 뷰를 꺼내 새로운 navigationDestination 수정자로 가져올 것입니다.

이 수정자는 그것이 책임지는 제시된 데이터의 유형을 선언합니다; 여기, 그것은 레시피입니다.

수정자는 레시피 값이 제시될 때 스택에 푸시할 뷰를 설명하는 뷰 빌더를 사용합니다.

그런 다음, 새로운 내비게이션 링크 중 하나로 전환하고 레시피 값을 제시하겠습니다.

후드 아래를 들여다보고 NavigationStack이 어떻게 이 일을 하는지 봅시다.

모든 내비게이션 스택은 스택이 보여주는 모든 데이터를 나타내는 경로를 추적합니다.

스택이 여기에 표시된 것처럼 루트 뷰를 보여줄 때, 경로는 비어 있다.

다음으로, 스택은 또한 그 안에 선언된 모든 탐색 목적지 또는 스택에 푸시된 뷰 내부를 추적합니다.

일반적으로, 이것은 세트이지만, 이 예에서는 목적지가 하나밖에 없다.

다이어그램에 푸시된 뷰도 추가합시다.

이제, 경로가 비어 있기 때문에, 푸시된 뷰 목록도 비어 있다.

이제, 우유와 쿠키처럼, 우리가 이것들을 합치면 마법이 일어난다.

값 제시 링크를 탭하면, 그 값을 경로에 추가합니다.

그런 다음, 내비게이션 스택은 경로 값 위에 목적지를 매핑하여 스택에서 어떤 뷰를 푸시할지 결정합니다.

이제, 내 애플 파이 레시피에서, 내가 파이 크러스트를 탭하면, 링크도 경로에 추가된다.

NavigationStack은 마법을 발휘하고 또 다른 RecipeDetail 보기를 스택에 푸시합니다.

내가 경로에 추가하는 모든 값에 대해, NavigationStack은 다른 보기를 푸시한다.

뒤로 버튼을 탭하면, NavigationStack은 경로와 푸시된 보기에서 마지막 항목을 제거합니다.

그리고 내비게이션스택은 한 가지 트릭을 더 제공한다.

바인딩을 사용하여 이 경로에 연결할 수 있습니다.

우리 코드로 돌아가자.

여기가 우리가 있던 곳이야.

경로를 묶기 위해, 먼저 몇 가지 상태를 추가하겠습니다.

이 스택에서 밀려난 모든 가치는 레시피이기 때문에, 나는 다양한 레시피를 내 경로로 사용할 수 있다.

스택에 다양한 데이터를 제시해야 하는 경우, 새로운 유형 지우기 NavigationPath 컬렉션을 확인하십시오.

경로 상태가 되면, NavigationStack에 인수를 추가하고 경로에 바인딩을 전달합니다.

그것을 제자리에 두면, 나는 내 스택을 지글지글하게 만들 수 있다.

예를 들어, 특정 레시피로 점프하는 방법을 추가할 수 있습니다.

또는 내 스택의 어느 곳에서나 경로를 재설정하는 것만으로 루트로 돌아갈 수 있습니다.

그것이 SwiftUI에서 새로운 NavigationStack, 가치 제시 NavigationLinks 및 navigationDestinations를 사용하여 푸시 가능한 스택을 준비하는 방법입니다.

이 레시피는 Mac을 포함한 모든 플랫폼에서 작동하지만, iPhone, Apple TV 및 Apple Watch에서 정말 빛납니다.

NavigationStack이 작동하는 것을 보려면, "Apple Watch용 생산성 앱 구축"을 확인하세요.

우리의 다음 레시피는 Mac과 iPad의 Mail에서 찾을 수 있는 것처럼 스택이 없는 다중 열 프레젠테이션을 위한 것입니다.

iPad에서, 사이드바는 처음에 숨겨져 있다.

나는 그것을 공개하고 카테고리를 선택할 수 있다.

그런 다음, 두 번째 열에서, 나는 레시피를 선택할 수 있다.

세 번째 열은 레시피 세부 사항을 보여준다.

이 레시피는 NavigationSplitView와 새로운 다양한 NavigationLink 및 목록 선택을 결합합니다.

이 레시피는 양식을 피하는 데 도움이 되기 때문에 더 큰 장치에서 좋습니다.

나는 뚫을 필요 없이 내 모든 정보를 볼 수 있다.

어떻게 하는지 보자.

내용과 세부 사항에 대한 자리 표시자 보기가 있는 3열 NavigationSplitView로 시작하겠습니다.

그런 다음, 내 모든 카테고리를 반복하는 사이드바에 목록과 navigationTitle을 추가할 것이다.

목록 안에는 각 카테고리에 대한 내비게이션 링크가 있습니다.

다음으로, 어떤 카테고리가 선택되었는지 추적하기 위해 몇 가지 주를 소개하겠습니다.

선택한 카테고리를 사용하기 위해 사이드바에서 목록을 조정할 것입니다.

우리가 선택에 바인딩을 전달하고 있다는 점에 유의하세요.

이것은 목록과 그 내용이 선택을 조작할 수 있게 해준다.

일치하는 선택 유형이 있는 목록 안에 가치 제시 링크를 넣으면 - 여기에 카테고리 - 링크는 탭하거나 클릭할 때 자동으로 선택을 업데이트합니다.

그래서 이제 사이드바에서 카테고리를 선택하면, SwiftUI는 선택한 카테고리를 업데이트합니다.

선택과 목록에 대한 훌륭한 정보는 앞서 언급한 Raj의 "인터페이스 구성" 강연을 확인하세요.

다음으로, 콘텐츠 열의 자리 표시자를 선택한 카테고리의 레시피 목록으로 바꾸고, 이 열에 대한 navigationTitle도 추가할 것입니다.

선택한 카테고리와 마찬가지로, 콘텐츠 목록에서 선택한 레시피를 추적하기 위해 동일한 기술을 사용할 수 있습니다.

나는 선택된 레시피에 주를 사용하고, 내 콘텐츠 목록이 그 상태를 사용하도록 하고, 각 레시피에 대한 가치 제시 링크를 사용할 것이다.

마지막으로, 선택한 레시피에 대한 세부 사항을 보여주기 위해 세부 사항 열을 업데이트하겠습니다.

이것으로, 나는 다시 내비게이션에 대한 완전한 프로그래밍 제어권을 갖게 되었다.

예를 들어, 오늘의 레시피로 이동하려면, 선택 상태를 업데이트하기만 하면 됩니다.

그것이 새로운 NavigationSplitView, 가치 제시 NavigationLinks 및 SwiftUI에서 선택한 목록을 사용하여 다중 열 탐색 경험을 준비하는 방법입니다.

이와 같이 목록 선택과 NavigationSplitView를 결합하는 것에 대한 한 가지 멋진 점은 SwiftUI가 iPhone의 단일 스택이나 iPad의 Slide Over에 분할 보기를 자동으로 조정할 수 있다는 것입니다.

선택에 대한 변경 사항은 자동으로 iPhone의 적절한 푸시와 팝으로 변환됩니다.

물론, 이 멀티컬럼 프레젠테이션은 Mac에서도 잘 작동한다.

그리고 Apple TV와 Apple Watch는 여러 열을 보여주지 않지만, 그 플랫폼들은 또한 단일 스택으로 자동 번역을 받는다.

SwiftUI의 NavigationSplitView는 모든 플랫폼에서 작동합니다.

다음으로, iPad와 Mac의 사진과 같은 두 열 탐색 경험을 구축하여 이 모든 재료를 어떻게 모을 수 있는지 살펴봅시다.

내가 카테고리를 선택할 때, 세부 영역은 그 카테고리에 있는 내 모든 레시피의 격자를 보여준다.

내가 레시피를 탭하면, 그것은 세부 영역의 스택에 밀려난다.

내가 관련 레시피를 탭할 때, 그것은 또한 스택에 밀려난다.

그리고 나는 레시피 그리드로 돌아갈 수 있다.

이 레시피는 내비게이션 분할 보기, 스택, 링크, 목적지 및 목록을 결합한 우리의 pièce de résistance입니다.

이 모든 재료들이 어떻게 어울리는지 봅시다.

두 열 NavigationSplitView로 시작하겠습니다.

첫 번째 열은 이전 레시피와 정확히 같다.

선택한 범주와 해당 상태에 대한 바인딩과 값 제시 NavigationLink 및 필수 navigationTitle을 사용하는 목록을 추적할 수 있는 상태가 있습니다.

이 레시피의 차이점은 세부 영역에 있다.

새로운 내비게이션 API는 구성을 실제로 활용한다.

NavigationSplitView의 열 안에 목록을 넣을 수 있는 것처럼, 열 안에 NavigationStack을 넣을 수도 있습니다.

이 내비게이션 스택의 루트 뷰는 내 RecipeGrid이다.

RecipeGrid가 NavigationStack 안에 있다는 것을 주목하세요.

그것은 내가 RecipeGrid 안에 스택 관련 수정자를 넣을 수 있다는 것을 의미한다.

RecipeGrid의 본문을 확대하여 그것이 무엇을 의미하는지 봅시다.

RecipeGrid는 뷰이며 카테고리를 매개 변수로 사용합니다.

여기서 카테고리는 선택 사항이기 때문에, if-let으로 시작하겠습니다.

다른 경우는 빈 선택을 처리합니다.

내 안에, 나는 스크롤 뷰와 게으른 그리드를 추가할 것이다.

게으른 그리드 레이아웃은 일련의 뷰를 취한다.

여기, 저는 ForEach를 사용하여 레시피를 반복하고 있습니다.

각 레시피마다, 나는 가치를 제시하는 내비게이션링크를 가지고 있다.

그 링크는 레시피 가치를 제시한다.

이 후행 폐쇄에서 링크의 라벨은 썸네일과 제목이 있는 내 RecipeTile이다.

그래서 이 그리드를 끝내려면 뭐가 남았어?

음, 나는 내비게이션스택에 레시피에서 세부 보기로 매핑하는 방법을 말하지 않았어.

첫 번째 레시피에서 언급했듯이, 새로운 NavigationStack은 navigationDestination 수정자를 사용하여 경로의 값에서 스택에 표시된 뷰로 매핑합니다.

그러니 내비게이션 목적지 수정자를 추가해 봅시다.

하지만 그걸 어디에 붙여야 하나요?

나는 그것을 링크에 직접 첨부하고 싶지만, 이것은 두 가지 이유로 잘못되었다.

List, Table 또는 LazyVGrid와 같은 게으른 컨테이너는 모든 뷰를 즉시 로드하지 않습니다.

여기에 수정자를 넣으면, 목적지가 로드되지 않을 수 있으므로, 주변 NavigationStack이 그것을 보지 못할 수도 있습니다.

둘째, 여기에 수정자를 넣으면, 내 그리드의 모든 항목에 대해 반복될 것이다.

대신, 나는 내 ScrollView에 수정자를 첨부할 것이다.

ScrollView 외부에 수정자를 첨부함으로써, NavigationStack이 스크롤 위치에 관계없이 이 navigationDestination을 볼 수 있도록 합니다.

내가 여기에 수정자를 넣는 것에 대해 좋아하는 또 다른 점은 그것이 여전히 그것을 목표로 하는 링크에 가깝다는 것이다.

내비게이션 목적지는 저나 제 팀이 이해할 수 있는 방식으로 코드를 구성할 수 있는 유연성을 제공합니다.

내 NavigationSplitView로 다시 나타나면, 여기에 완전한 프로그래밍 방식 탐색을 활성화할 수 있는 것이 하나 더 있습니다.

내비게이션 경로를 추가해야 합니다.

나는 경로를 유지하기 위해 상태를 추가하고 상태를 내 NavigationStack에 바인딩할 것이다.

완전한 프로그래밍 방식 탐색을 통해, 나는 이 탐색 경험에서 오늘의 레시피를 보여주는 방법을 쓸 수 있다.

그것이 새로운 NavigationSplitView, NavigationStack, 값 제시 NavigationLinks 및 SwiftUI에서 선택한 목록을 사용하여 스택으로 다중 열 탐색 경험을 준비하는 방법입니다.

이전 레시피와 마찬가지로, 이것은 또한 좁은 프레젠테이션에 자동으로 적응하고 모든 플랫폼에서 작동합니다.

내 앱에서 내비게이션을 구조화하기 위한 이 레시피를 탐색하는 것은 재미있었지만, 우리의 내비게이션 잔치는 디저트 없이는 완성되지 않을 것이다.

그것을 위해, 내비게이션 상태를 유지하는 방법을 살펴봅시다.

내 앱에서 탐색 상태를 유지하려면, 두 가지 재료가 더 필요합니다: Codable과 SceneStorage.

이 레시피에는 세 가지 기본 단계가 있다.

먼저, 내비게이션 상태를 NavigationModel 유형으로 캡슐화하겠습니다.

그것은 내가 그것을 단위로 저장하고 복원할 수 있게 해주기 때문에 항상 일관성이 있다.

그럼, 나는 내 내비게이션 모델을 코딩할 수 있게 만들 거야.

마지막으로, 나는 SceneStorage를 사용하여 내 모델을 저장하고 복원할 것이다.

나는 길을 따라 조심해야 할 것이다 - 나는 내 앱이 떨어진 수플레처럼 충돌하는 것을 원하지 않는다 - 하지만 단계는 간단하다.

1단계를 살펴봅시다.

여기 우리의 마지막 레시피 끝에 있는 코드가 있습니다.

내 탐색 상태는 선택된 범주와 경로 속성에 저장됩니다.

선택된 카테고리는 사이드바에서 선택을 추적합니다.

경로는 세부 영역의 스택으로 밀려난 뷰를 추적한다.

새로운 NavigationModel 클래스를 소개하고 ObservableObject를 준수하도록 하겠습니다.

다음으로, 탐색 상태를 모델 객체로 이동하여 속성 래퍼를 State에서 Published로 변경할 것입니다.

그런 다음, 내 NavigationModel의 인스턴스를 보유하고 새로운 모델 객체를 사용하기 위해 매개 변수를 변경하기 위해 StateObject를 소개하겠습니다.

다음으로, 나는 내 내비게이션 모델을 코딩할 수 있게 만들 것이다.

나는 수업에 Codable 적합성을 추가하는 것으로 시작할 것이다.

많은 경우에, 스위프트는 자동으로 코딩 가능한 적합성을 생성할 수 있지만, 나는 여기서 나만의 적합성을 구현하고 싶다.

주된 이유는 레시피가 모델 가치이기 때문이다.

나는 국가 복원을 위한 전체 모델 값을 저장하고 싶지 않다.

여기에는 두 가지 이유가 있다.

먼저, 내 레시피 데이터베이스에는 이미 레시피에 대한 모든 세부 사항이 포함되어 있다.

저장된 내비게이션 상태에서 그 정보를 반복하는 것은 저장소를 잘 사용하는 것이 아니다.

둘째, 내 레시피 데이터베이스가 내 로컬 내비게이션 상태와 독립적으로 변경될 수 있다면 - 예를 들어, 내가 마침내 동기화를 추가하기 때문에 - 나는 내 로컬 내비게이션 상태가 오래된 데이터를 포함하는 것을 원하지 않는다.

사용자 지정 코딩을 위해, 다음으로 코딩키를 추가하겠습니다.

키 중 하나는 방금 선택된 카테고리입니다.

하지만 제가 다른 "recipePathIds"라고 명명했다는 것을 주목하세요. 저는 경로에 레시피의 식별자를 저장할 계획입니다.

인코딩 방법에서, 코딩 키를 사용하여 키 컨테이너를 만들고 선택한 카테고리를 컨테이너에 추가할 것입니다.

저는 encodeIfPresent를 사용하고 있으므로, 0이 아닌 경우에만 값을 작성합니다.

그런 다음, 레시피 경로 식별자를 추가하겠습니다.

인코딩할 식별자를 얻기 위해 경로를 매핑하고 있다는 점에 유의하십시오.

예를 들어, 내 탐색 상태가 상단의 녹색 상자에 표시된 것처럼 경로에 애플 파이와 파이 크러스트가 있는 선택된 카테고리로 디저트를 포함했다고 가정해 봅시다.

이것은 다른 상자에 표시된 것처럼 JSON으로 인코딩될 수 있습니다.

Codability를 마무리하기 위해, 나는 필요한 이니셜라이저를 추가할 것이다.

흥미로운 부분은 레시피 ID를 디코딩한 다음 공유 데이터 모델을 사용하여 ID를 레시피로 다시 변환하는 곳입니다.

나는 찾을 수 없는 레시피를 버리기 위해 컴팩트맵을 사용하고 있다.

예를 들어, 동기화가 작동한 후 다른 장치에서 레시피를 삭제하면 이런 일이 발생할 수 있습니다. 언젠가는 확실히 할 것입니다.

이것은 복원된 내비게이션 상태가 여전히 의미가 있는지 확인하기 위해 자신의 앱에서 재량권을 사용해야 하는 곳입니다.

마지막으로, 모델을 JSON 데이터로 읽고 쓰기 위한 계산된 속성을 추가할 것입니다.

이제 내비게이션 모델이 있고 인코딩하고 디코딩하는 방법을 알고 있기 때문에, 남은 것은 실제로 저장하고 복원하는 것뿐입니다.

그것을 위해 나는 SceneStorage를 사용할 것이다.

여기가 우리가 주요 견해를 떠난 곳이다.

나는 내 NavigationModel을 유지하기 위해 StateObject를 사용하고 있었다.

이제, 저는 내비게이션 모델을 지속하기 위해 몇 가지 SceneStorage를 소개하겠습니다.

SceneStorage 속성은 관련 값을 자동으로 저장하고 복원합니다.

여기에 있는 내 데이터와 같이 스토리지 유형이 선택 사항일 때, 새 장면이 생성될 때 값은 0입니다.

시스템이 장면을 복원할 때, SwiftUI는 SceneStorage 속성의 값도 복원되도록 합니다.

나는 내 내비게이션 모델을 지속하기 위해 이것을 이용할 것이다.

그렇게 하기 위해, 나는 내 보기에 작업 수정자를 추가할 것이다.

작업 수정자는 폐쇄를 비동기적으로 실행한다.

그것은 보기가 나타날 때 시작되고 보기가 사라지면 취소됩니다.

내 보기가 나타날 때마다, 나는 먼저 앱의 이전 실행에서 기존 데이터가 있는지 확인할 것이다.

그렇다면, 나는 그 데이터로 내비게이션 모델을 업데이트할 것이다.

그런 다음, 내비게이션 모델이 변경될 때마다 반복되는 비동기 루프를 시작할 것입니다.

이 루프의 본문은 각 변경마다 실행되므로, 내비게이션 상태를 장면 저장 데이터에 다시 저장하는 데 사용할 수 있습니다.

그리고 그게 다야!

웹에서 빈티지 줄리아 차일드 요리 쇼를 보러 가기 위해 앱을 떠날 때, 그것은 내가 어디에 있었는지 기억한다.

내가 앱으로 돌아가면, 그것은 내가 중단한 곳으로 돌아간다.

이제, 편리한 주방 팁이 있는 마지막에 이상한 섹션 없이는 어떤 요리책도 완성되지 않을 것이다.

고수에 대한 세 가지 훌륭한 대체품은 없지만, 공유할 수 있는 몇 가지 탐색 팁이 있습니다.

가능한 한 빨리 새로운 NavigationStack과 NavigationSplitView로 전환하세요.

스택 스타일로 NavigationView를 사용하는 경우, NavigationStack으로 전환하세요.

NavigationStack은 또한 Apple TV, Apple Watch 또는 스택 스타일이 항상 기본값이었던 iPad 및 iPhone의 시트에서 좋은 첫 번째 선택입니다.

다중 열 NavigationView를 사용하는 경우, NavigationSplitView로 전환하세요.

그리고 바인딩을 사용하는 링크를 사용하여 프로그래밍 방식 탐색을 이미 채택했다면, 탐색 경로 및 목록 선택과 함께 새로운 가치를 제시하는 NavigationLink로 이동하는 것이 좋습니다.

구식 프로그래밍 링크는 iOS 16과 정렬된 릴리스에서 더 이상 사용되지 않습니다.

새로운 API로의 마이그레이션에 대한 자세한 내용과 예제는 개발자 문서의 "새로운 탐색 유형으로 마이그레이션" 기사를 확인하세요.

다음으로, List와 새로운 NavigationSplitView와 NavigationStack이 함께 혼합되었다는 것을 명심하세요.

손님들이 좋아할 내비게이션 경험을 만들기 위해 그것들을 구성하세요.

내비게이션 스택을 사용할 때, 내비게이션 목적지는 스택이나 하위 뷰 내부의 어느 곳에나 있을 수 있습니다.

유지 보수를 더 쉽게 하기 위해 해당 링크 근처에 목적지를 두는 것을 고려하지만, 게으른 컨테이너 안에 넣지 마세요.

마지막으로, 말이 될 때 NavigationSplitView로 내비게이션 경험을 구축하기 시작하는 것이 좋습니다.

처음에 iPhone용으로 개발하더라도, NavigationSplitView는 더 좁은 장치에 자동으로 적응할 것입니다.

그리고 iPhone Pro Max를 가로로 지원하거나 앱을 iPad 또는 Mac으로 가져올 준비가 되면, NavigationSplitView는 모든 추가 공간을 활용할 것입니다.

새로운 SwiftUI 내비게이션 API를 공유할 수 있는 기회를 주셔서 감사합니다!

앞서 언급한 대화 외에도, 앱에서 새 창과 장면을 여는 것에 대한 좋은 정보를 위해 "SwiftUI 앱에 여러 개의 창을 가져오세요"를 확인하도록 초대합니다.

나는 우리 요리책 앱의 탐색을 위한 이 레시피들이 미각을 즐겁게 해주길 바란다.

저는 당신이 자신의 앱에서 요리한 훌륭한 경험을 보기를 고대하고 있습니다.

맛있게 드세요!

♪