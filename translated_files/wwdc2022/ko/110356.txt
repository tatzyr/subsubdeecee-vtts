110356

♪ 기악 힙합 음악 ♪

♪

안녕! 제 이름은 콘라드이고 스위프트 팀의 엔지니어입니다.

"스위프트에서 분산된 배우들을 만나세요"에 오신 것을 환영합니다.

이 세션에서, 우리는 당신이 Swift 동시성 기반 앱을 단일 프로세스 이상으로 가져갈 수 있는 방법을 배우게 될 것입니다.

스위프트 액터들은 같은 과정에서 낮은 수준의 데이터 경쟁으로부터 당신을 보호하도록 설계되었습니다.

그들은 컴파일 타임 강제 행위자 격리 검사를 통해 이것을 한다.

분산된 액터들은 동일한 개념적 액터 모델을 개선하고 클러스터의 여러 장치나 서버와 같은 여러 프로세스로 확장합니다.

따라서 아직 스위프트 배우에 익숙하지 않은 경우를 대비하여, 먼저 WWDC 2021의 "스위프트 배우와 함께 변경 가능한 상태 보호" 세션을 보는 것이 좋습니다.

이 세션에서 우리가 작업할 앱은 내가 최근에 개발하고 있는 틱택토 스타일의 게임이다: 틱택 피쉬!

여기서 재미있는 아이디어는 게임을 할 때 움직임을 표시하는 데 사용되는 이모티콘에 해당하는 팀을 선택할 수 있다는 것입니다.

그런 다음, 필드에서 움직임을 표시할 때, 팀의 이모티콘은 선수 중 한 명이 이길 때까지 필드에 배치됩니다.

지금은 봇 상대와 플레이할 수 있는 오프라인 모드만 구현했지만, 앱을 다음 단계로 끌어올리기 위해 몇 가지 멀티플레이어 모드를 소개하고 싶습니다.

저는 이미 이 앱에서 배우를 사용하여 동시성을 관리하고 게임에 관련된 플레이어를 모델링하고 있습니다.

그 플레이어 배우들을 다른 프로세스로 마이그레이션하기 위해 무엇이 필요한지, 그리고 분산된 배우들이 내가 이것을 하는 데 어떻게 도울 수 있는지 봅시다.

코드로 넘어가기 전에, 한 걸음 물러서서 왜 배우들이 동시 및 분산 애플리케이션을 구축하는 데 적합한지 시각화해 봅시다.

WWDC 세션 내내, 당신은 우리가 배우에 대해 이야기할 때 "동시성의 바다"라는 용어를 사용하는 것을 들을 수 있습니다.

이것은 그들에 대해 생각하는 훌륭한 정신적 모델이기 때문이다.

각 배우는 동시성의 바다에 있는 자신의 섬이며, 서로의 섬에 직접 접근하는 대신, 그들 사이에 메시지를 교환한다.

스위프트에서, 섬을 가로질러 메시지를 보내는 것은 비동기 메서드 호출과 비동기/대기로 구현된다.

이것은 액터 상태 격리와 함께 컴파일러가 액터 기반 프로그램이 컴파일되면 낮은 수준의 데이터 경쟁에서 자유로울 수 있도록 보장할 수 있다.

이제 이 동일한 개념 모델을 가지고 분산 시스템으로 재창조된 우리 게임에 적용합시다.

우리는 각 장치, 클러스터의 노드 또는 운영 체제의 프로세스를 마치 더 작은 어두운 직사각형으로 표시된 독립적인 동시성의 바다인 것처럼 생각할 수 있습니다.

그 안에서, 우리는 그들이 여전히 같은 메모리 공간을 공유하고 있기 때문에 정보를 쉽게 동기화할 수 있었다.

그리고 메시지 전달의 동일한 개념은 동시성과 배포에 완벽하게 잘 작동하지만, 모든 것이 작동하려면 배포에 몇 가지 제한이 더 필요합니다.

이곳은 분산된 배우들이 그림 속으로 들어오는 곳이다.

분산된 배우를 사용함으로써, 우리는 두 프로세스 사이에 채널을 설정하고 그들 사이에 메시지를 보낼 수 있다.

다시 말해, 스위프트 배우들이 동시성의 바다에 있는 섬이라면, 분산된 배우들은 분산된 시스템의 광대한 바다에서 동일하다.

프로그래밍 모델에서, 별로 변하지 않았다 - 배우들은 여전히 그들의 상태를 고립시키고 여전히 비동기 메시지를 통해서만 통신할 수 있다.

우리는 같은 과정에서 더 많은 분산된 배우를 가질 수 있으며, 모든 의도와 목적을 위해, 그들은 지역 배우만큼 유용하며, 필요할 때마다 원격 상호 작용에 참여할 준비가 되어 있다는 차이점이 있습니다.

우리가 그러한 분산된 행위자와 상호 작용하는 방식을 바꿀 필요 없이 잠재적으로 멀리 떨어져 있는 이 능력은 "위치 투명성"이라고 불린다.

이것은 분산된 배우가 어디에 있든, 우리는 같은 방식으로 상호 작용할 수 있다는 것을 의미한다.

이것은 우리가 지역 행위자에서 동일한 논리를 실행하기 때문에 테스트에 환상적일 뿐만 아니라, 구현을 변경할 필요 없이 행위자를 그들이 있어야 할 곳으로 투명하게 이동할 수 있게 해준다.

좋아, 내 생각에 우리는 코드를 보고 첫 번째 배우를 분산 배우로 전환할 준비가 된 것 같아.

먼저, 일반적인 게임 UI와 그것이 내 플레이어 배우들과 어떻게 상호 작용하는지 간단히 살펴봅시다.

보기는 꽤 표준 SwiftUI 코드이며, 게임 필드를 나타내는 몇 가지 텍스트와 버튼 요소가 있습니다.

사용자가 GameCell을 클릭할 때, 우리는 플레이어 배우에게 움직임을 생성하고 UI를 강화하는 보기 모델을 업데이트하도록 요청합니다.

스위프트 동시성 덕분에, 모든 업데이트는 스레드로부터 안전하고 잘 작동한다.

현재, 사용자 입력을 나타내는 행위자는 오프라인 플레이어로 구현된다.

다음에 한 번 보자.

이 배우는 게임 동작을 생성할 수 있는 상태를 캡슐화한다.

특히, 그것은 이미 얼마나 많은 움직임을 했고 어떤 팀을 위해 뛰고 있는지 추적해야 한다.

각 팀은 각 이동에 대해 선택할 수 있는 많은 이모티콘을 가지고 있기 때문에, 이동 횟수를 사용하여 이모티콘 캐릭터 ID를 선택하십시오.

나는 또한 움직임이 만들어지면 모델을 업데이트해야 한다.

이 모델은 MainActor 격리 클래스이므로, 그것의 돌연변이는 스레드로부터 안전하다.

하지만 나는 userMadeMove 전화를 걸 때 "await"를 사용해야 한다.

마지막으로, 오프라인 플레이어는 또한 상대가 움직일 때마다 호출될 방법을 선언한다.

우리가 여기서 해야 할 유일한 일은 뷰 모델을 업데이트하는 것입니다. 이는 인간 플레이어가 이동을 선택할 수 있도록 게임 필드를 다시 활성화하고, 게임이 끝날 때까지 주기가 계속됩니다.

우리의 봇 플레이어는 또한 배우를 사용하여 대표된다.

그것의 구현은 실제로 뷰 모델 업데이트에 대해 걱정할 필요가 없기 때문에 오프라인 플레이어보다 꽤 간단합니다. 그것은 단지 GameState를 추적하고 게임 동작을 생성합니다.

봇 플레이어가 조금 더 간단하기 때문에, 분산 배우로의 전환을 시작하는 것이 좋다고 생각합니다.

좋아, 내 생각에 우리는 코드를 보고 첫 번째 배우를 분산 배우로 전환할 준비가 된 것 같아.

배포된 Tic Tac Fish 게임을 향한 첫 번째 단계는 BotPlayer 유형을 배포된 배우로 변환하는 것이지만, 여전히 로컬에서만 사용하는 것입니다.

Xcode를 열고 우리가 어떻게 할 수 있는지 봅시다.

분산 액터를 선언하려면, 스위프트 5.7에서 도입한 새로운 분산 모듈을 가져와야 합니다.

이 모듈에는 분산 액터를 선언하고 사용하는 데 필요한 모든 유형이 포함되어 있습니다.

이제 이와 같이 BotPlayer 배우 선언 앞에 분산 키워드를 추가할 수 있습니다.

이로 인해 액터는 DistributedActor 프로토콜을 자동으로 준수하고 많은 추가 컴파일 시간 검사를 가능하게 합니다.

컴파일러가 지금 우리에게 어떤 종류의 오류를 수정하라고 요청할지 봅시다.

컴파일러는 봇플레이어가 함께 사용할 수 있는 액터시스템을 선언하지 않는다는 것을 유용하게 알려준다.

분산 액터가 항상 원격 호출을 수행하는 데 필요한 모든 직렬화와 네트워킹을 처리하는 일부 분산 액터 시스템에 속하기 때문에, 우리는 이 액터가 어떤 유형의 액터 시스템과 함께 사용될 것인지 선언해야 합니다.

현재로서는 봇 플레이어가 원격 호스트에서 실제로 실행하지 않고 모든 분산 격리 검사를 통과하도록 하는 것이 유일한 목표이기 때문에, 분산 모듈과 함께 제공되는 LocalTestingDistributedActor 시스템을 사용할 수 있습니다.

모듈 전체의 DefaultDistributedActorSystem typealias 또는 특정 액터의 본문에 ActorSystem typealias를 선언하여 우리가 사용할 액터 시스템에 대해 컴파일러에게 말할 수 있습니다.

후자의 비트는 좀 더 구체적이니까, 그걸로 가자.

다음 오류는 두 플레이어 배우가 모두 준수해야 하는 식별 가능한 프로토콜을 준수하기 위해 이전에 수동으로 구현한 "id" 속성에 관한 것입니다.

오류는 이제 ID 속성이 분산 액터 합성 속성과 충돌하기 때문에 명시적으로 정의할 수 없다고 말합니다.

신분증은 분산된 배우들의 중요한 부분이다.

그들은 그것이 속한 전체 분산 배우 시스템에서 배우를 고유하게 식별하는 데 사용된다.

그들은 배우가 초기화됨에 따라 분산 배우 시스템에 의해 할당되고, 나중에 그 시스템에 의해 관리된다.

따라서, 우리는 ID 속성을 수동으로 선언하거나 할당할 수 없습니다 - 액터 시스템은 우리를 위해 이것을 할 것입니다.

즉, 나는 단순히 그것을 배우 시스템에 맡기고 수동으로 선언된 ID 속성을 제거할 수 있다.

우리가 여기서 처리해야 할 마지막 오류는 분산된 배우의 이니셜라이저이다.

컴파일러는 actorSystem 속성이 사용하기 전에 초기화되지 않았다고 말한다.

이것은 모든 분산 행위자의 일부인 또 다른 컴파일러 합성 속성이다.

우리가 사용하고자 하는 액터 시스템의 유형을 선언해야 할 뿐만 아니라, 일부 구체적인 액터 시스템으로 합성된 액터 시스템 속성을 초기화해야 합니다.

일반적으로, 여기서 해야 할 옳은 일은 이니셜라이저에서 배우 시스템을 받아들이고, 그것을 재산으로 전달하는 것이다.

이렇게 하면, 쉬운 단위 테스트를 용이하게 하기 위해 테스트에서 다른 액터 시스템 구현을 통과할 수 있습니다.

우리는 또한 새로운 봇 플레이어를 만들 때마다 인스턴스를 전달해야 하므로, 지금 합시다.

멋져! 우리는 모든 선언 측면 오류를 끝냈다.

하지만 여전히 우리가 해결해야 할 몇 가지 콜 사이트 오류가 있다.

잠재적으로 원격으로 분산된 행위자에게는 분산된 방법만 호출될 수 있는 것으로 보인다.

이것은 시스템의 일부 배우만 분산된 배우로 주석을 달는 것과 비슷합니다.

분산 액터의 모든 방법이 반드시 원격으로 호출되도록 설계된 것은 아니다.

그들은 작은 도우미 기능이나 호출자가 이미 인증되었다고 가정하는 기능을 가질 수 있다.

이것이 스위프트가 분산 API 표면에 대해 명시하도록 요청하는 이유이며, 원격 호출자에게 노출하고 싶습니다.

고맙게도, 이것은 또한 그 기능에 분산 키워드를 추가함으로써 쉽게 고칠 수 있다.

makeMove와 opponentMoved 메소드 모두 원격으로 호출될 예정이기 때문에, 둘 다에 분산 키워드를 추가하겠습니다.

알았어! 그것으로, 우리가 처리해야 할 마지막 한 가지가 있다.

분산 메소드 호출이 네트워크 경계를 넘을 수 있기 때문에, 우리는 모든 매개 변수와 반환 값이 액터 시스템의 직렬화 요구 사항을 준수하는지 확인해야 합니다.

우리의 경우, 액터 시스템은 스위프트의 기본 직렬화 메커니즘인 Codable을 사용하고 있다.

특히, 컴파일러는 "결과 유형 GameMove는 직렬화 요구 사항 Codable을 준수하지 않습니다."라고 말합니다.

게임모브 유형을 간단히 살펴보겠습니다.

운 좋게도, 필요한 적합성을 추가하기만 하면 쉽게 코딩할 수 있는 깨끗한 작은 데이터 유형인 것 같습니다.

스위프트 컴파일러는 나를 위해 필요한 코딩 가능한 구현을 합성할 것이다.

그리고 그것으로, 우리는 끝났어!

나는 예상대로 게임이 진행되는지 확인할 수 있다.

좋아, 팀 피쉬를 위한 포인트!

그리고 봇 플레이어는 여전히 같은 로컬 장치에서 실행하지만, 우리는 이미 흥미진진한 다음 단계를 위한 길을 닦았다.

이 단계에서, 우리는 실제로 봇 플레이어의 새로 얻은 위치 투명성의 이점을 얻을 것이다.

나는 이미 우리가 이것을 위해 사용할 수 있는 웹소켓 기반 샘플 액터 시스템을 준비했다.

이 액터 시스템을 사용하면 봇 플레이어를 서버 측 스위프트 애플리케이션으로 옮기고 모바일 게임에서 원격 참조를 해결할 수 있습니다.

배우에 관한 한, 우리는 선언된 ActorSystem을 LocalTesting DistributedActor System에서 샘플 앱을 위해 준비한 SampleWebSocketActorSystem으로 변경하기만 하면 됩니다.

나머지 배우 코드는 동일하게 유지됩니다.

다음으로, 로컬로 만드는 대신 원격 봇 플레이어 참조를 해결해 봅시다.

"로컬"과 "원격"이라는 용어는 분산된 배우와 관련하여 관점의 문제라는 것을 명심할 가치가 있다.

모든 원격 참조에 대해, 분산 액터 시스템의 다른 노드에 해당하는 로컬 인스턴스가 있습니다.

분산 액터의 로컬 인스턴스를 만드는 것은 다른 스위프트 객체와 거의 같은 방식으로 수행됩니다: 이니셜라이저를 호출하여.

그러나 분산된 배우에 대한 원격 참조를 얻는 것은 약간 다른 패턴을 따른다.

배우를 만드는 대신, 우리는 구체적인 배우 시스템을 사용하여 배우 ID를 해결하려고 시도할 것이다.

정적 해결 방법을 사용하면 액터 시스템에 해당 ID를 가진 액터에 대한 기존 액터 인스턴스를 제공하거나 식별된 액터에 대한 원격 참조를 반환하도록 요청할 수 있습니다.

액터 시스템은 식별자를 해결할 때 실제 원격 조회를 수행해서는 안 됩니다. 보시다시피, 해결 방법은 비동기적이지 않으므로 빠르게 반환하고 네트워킹을 수행하거나 작업을 차단하지 않아야 합니다.

신원이 유효해 보이고 유효한 원격 위치를 가리키는 것처럼 보인다면, 시스템은 그러한 행위자가 존재한다고 가정하고 원격 참조를 반환해야 한다.

ID를 해결할 때 원격 시스템의 실제 인스턴스가 아직 존재하지 않을 수도 있다는 것을 명심하세요!

예를 들어, 여기서 우리는 우리와 함께 게임을 하는 데 전념해야 하는 상대 봇 플레이어의 무작위 식별자를 만들고 있습니다.

이 봇은 아직 존재하지 않지만, 이 ID에 지정된 첫 번째 메시지가 수신되면 서버 측 시스템에서 생성됩니다.

이제 서버 측 스위프트 애플리케이션으로 이동합니다.

내가 준비한 샘플 웹소켓 액터 시스템 덕분에, 그것을 구현하는 것은 쉬울 것이다.

먼저, 우리는 서버 모드에서 WebSocket 액터 시스템을 만들어 포트에 연결하기보다는 포트에 바인딩하고 들을 수 있도록 합니다.

그리고 우리는 시스템이 종료될 때까지 앱을 기다리게 한다.

다음으로, 우리는 아직 액터 인스턴스가 할당되지 않은 ID로 전달된 메시지를 받을 때 필요에 따라 액터를 만드는 패턴을 어떻게든 처리해야 할 것이다.

일반적으로, 액터 시스템은 수신 메시지를 수신하고, 로컬 분산 액터 인스턴스를 찾기 위해 수신자 ID를 해결하려고 시도한 다음, 위치한 액터에 대한 원격 호출을 실행합니다.

하지만 우리가 방금 논의했듯이, 우리의 봇 플레이어 ID는 말 그대로 만들어졌기 때문에, 시스템은 그들에 대해 알 수 없으며, 그 자체로 올바른 유형의 배우를 만들 수 없습니다.

고맙게도, 우리의 샘플 배우 시스템 구현은 우리에게 딱 맞는 패턴을 준비했습니다: 주문형 배우 생성.

이것은 단지 패턴일 뿐이며, 분산 액터 모듈에 의해 내장되거나 제공되는 것이 아니라는 점에 유의하십시오.

그러나, 그것은 얼마나 유연하고 강력한 액터 시스템 구현이 될 수 있는지를 보여주는 좋은 예이다.

시스템은 다양한 패턴을 제공하고 복잡한 작업을 간단하게 처리할 수 있다.

이 패턴을 사용하여, 액터 시스템은 평소와 같이 들어오는 모든 ID에 대해 로컬 액터를 해결하려고 시도합니다.

그러나, 기존 액터를 찾지 못하면, CreateOnDemand를 해결하려고 시도한다.

우리는 ID와 서버 코드를 구성하는 클라이언트 코드를 모두 통제하고 있기 때문에, 필요에 따라 필요한 액터를 만들어 액터 시스템을 도울 수 있습니다.

우리가 클라이언트에서 만들어온 봇 식별자는 ActorIdentity에 태그를 추가하거나 인식할 수 있는 이름을 사용하는 것과 같은 인식 가능한 명명 체계를 사용하고 있기 때문에 우리는 그 ID를 감지하고 아직 활성화되지 않은 모든 메시지에 대해 새로운 봇 상대를 만들 수 있습니다.

후속 원격 호출은 단순히 기존 인스턴스를 해결하기 때문에 지정된 첫 번째 메시지에 대해서만 새 봇 플레이어를 만들 것입니다.

그리고 그게 전부야!

서버 구현이 완료되었으며 이제 원격 봇 플레이어로 게임을 할 수 있습니다.

Swift run을 사용하거나 Xcode를 사용하여 서버 구성표를 선택하고 평소와 같이 실행을 클릭하여 명령줄에서 서버를 실행할 수 있습니다.

우리가 첫 번째 움직임을 마쳤을 때, 우리는 봇 플레이어에게 우리가 만든 원격 플레이어 참조에서 makeMove를 호출하여 똑같이 하도록 요청합니다.

이것은 서버 측 시스템에서 해결을 유발한다.

이 ID에 대한 기존 봇을 찾을 수 없으므로, 시도하고 성공하여 주문형 봇을 만듭니다.

봇은 makeMove 전화를 받고, 생성된 GameMove로 응답한다.

그건 이미 꽤 좋았어!

우리는 봇 플레이어를 분산 액터로 변환하기 위해 몇 가지 선행 작업을 해야 했지만, 실제로 원격 시스템으로 옮기는 것은 꽤 간단했다.

그리고 우리는 네트워킹이나 직렬화 구현 세부 사항을 전혀 다룰 필요가 없었습니다!

모든 무거운 일은 분산된 배우 시스템에 의해 우리를 위해 이루어졌다.

그리고 아직 사용 가능한 강화된 기능 완전한 구현은 많지 않지만, 이러한 배포의 용이성은 우리가 이 기능으로 노력하고 있는 것입니다.

다음으로, 우리 게임을 위한 진정한 멀티플레이어 경험을 어떻게 구축할 수 있는지 봅시다.

우리의 이전 예는 클라이언트/서버 시나리오에서 분산된 배우를 사용했는데, 이는 당신이 작업한 다른 앱에서 이미 익숙할 수 있습니다.

그러나, 분산 액터는 전용 서버 구성 요소가 전혀 없는 P2P 시스템에서도 사용될 수 있다.

이것은 내가 우리 게임에 대해 가졌던 또 다른 아이디어와 일치한다.

가끔 여행할 때, 당신은 인터넷이 좋지 않은 이 장소들에 가게 되지만, 지역 Wi-Fi는 잘 작동합니다.

나는 여전히 같은 네트워크에 연결된 친구들과 도전하고 놀 수 있고 싶다. 왜냐하면 나는 그런 상황에 처하게 될 것이다.

이번에는 네트워크 프레임워크에서 제공하는 로컬 네트워킹 기능을 사용하여 또 다른 액터 시스템 구현을 구현했습니다.

이 강연에서 그 배우 시스템의 구현에 뛰어들지는 않지만, WWDC 2019의 "Advances in Networking, Part 2"를 보고 그러한 사용자 지정 프로토콜을 구현하는 방법을 배울 수 있습니다.

또한 로컬 네트워크에 대한 접근이 매우 개인 정보 보호에 민감한 정보를 노출시킬 수 있다는 점을 지적할 가치가 있으므로, 정중하게 사용하세요.

이번에는 다른 장치에서 이미 존재하는 분산 액터를 다룰 것이기 때문에, 우리는 더 이상 이전 예에서 했던 것처럼 ID를 만들 수 없습니다.

우리는 게임을 하고 싶은 다른 장치에서 특정 배우를 발견해야 합니다.

이 문제는 분산된 행위자에게만 국한된 것이 아니며, 일반적으로 서비스 검색 메커니즘을 사용하여 해결됩니다.

그러나 분산 액터의 영역에서는 모든 코드 전반에 걸쳐 강력한 형식의 API를 고수할 수 있는 API 액터 시스템의 일반적인 패턴과 스타일이 있을 것으로 예상됩니다.

우리는 그것을 접수원 패턴이라고 부른다. 왜냐하면 호텔과 비슷하게, 배우들은 다른 사람들이 만날 수 있도록 유명해지고 이용하기 위해 체크인해야 하기 때문이다.

모든 배우 시스템에는 자체 접수원이 있으며 배우 발견을 구현하기 위해 기본 전송 메커니즘에 가장 적합한 모든 수단을 사용할 수 있습니다.

때때로 이것은 기존 서비스 검색 API에 의존할 수 있으며, 그 위에 형식에 안전한 API만 계층화하거나, 가십 기반 메커니즘 또는 완전히 다른 것을 구현할 수 있습니다.

그러나 이것은 배우 시스템의 사용자의 관점에서 구현 세부 사항입니다. 우리가 신경 써야 할 것은 배우를 확인하여 발견할 수 있도록 하고 우리가 그들을 발견해야 할 때 태그나 유형으로 배우를 찾는 것입니다.

SampleLocalNetworkActorSystem을 위해 구현한 간단한 접수원을 살펴봅시다.

그것은 배우가 체크인할 수 있게 해주며, 분산 배우 시스템의 모든 접수원이 그것을 발견할 수 있게 해준다.

그런 다음 해당 시스템에서 사용할 수 있는 특정 유형과 태그의 모든 배우 목록을 얻을 수 있습니다.

이 접수원을 사용하여 우리가 함께 게임을 하고 싶은 구체적인 상대 배우를 발견합시다.

이전에, 우리의 GameView는 뷰 이니셜라이저에서 상대를 직접 만들거나 해결했습니다.

상대가 네트워크에 나타날 때까지 비동기적으로 기다려야 하기 때문에 우리는 더 이상 이것을 할 수 없습니다.

이렇게 하기 위해, 우리가 하나를 발견하려고 하는 동안 "상대방을 찾고..." 메시지를 보여주는 매치메이킹 뷰를 소개하겠습니다.

이 견해가 나타나면, 우리는 중매를 시작할 것이다.

매치메이킹은 새로운 구조화되지 않은 작업에서 이루어질 것이며, 우리는 지역 배우 시스템의 접수원에게 상대 팀의 태그를 사용하여 태그된 모든 배우의 목록을 요청할 것이다.

그래서 만약 우리가 팀 피쉬를 위해 뛰고 있다면, 우리는 팀 설치류의 선수를 찾을 것이고, 그 반대도 마찬가지입니다.

다음으로, 우리는 들어오는 상대 배우들을 기다리기 위해 비동기 루프를 사용할 것이다.

시스템이 우리가 플레이할 수 있는 상대와 함께 근처의 장치를 발견함에 따라, 이 작업 루프는 재개될 것이다.

상대가 항상 게임을 할 준비가 되어 있다고 가정하고 즉시 우리 모델에 저장하고 그들과 함께 게임을 시작합시다.

우리는 도우미 기능을 사용하여 누가 첫 번째 행동을 해야 하는지 결정하고, 마지막으로 상대방에게 우리가 그들과 함께 게임을 시작하고 싶다고 말한다.

매치메이킹 작업을 완료하려면 한 명의 상대만 있으면 되기 때문에, 루프에 대한 비동기에서 벗어나기 위해 여기로 돌아와야 합니다.

이 게임플레이 모드의 경우, OfflinePlayer 구현을 조금 변경해야 합니다.

LocalNetworkPlayer라고 부르면, SampleLocalNetworkActorSystem을 사용할 것입니다.

가장 흥미로운 점은 인간 플레이어를 대표하는 배우의 makeMove 방법이 이제 원격으로 호출될 수 있다는 것입니다!

하지만 움직이는 것은 실제로 인간 플레이어의 책임이다.

이 문제를 해결하기 위해, 우리는 뷰 모델에 humanSelectedField 비동기 함수를 도입합니다.

그것은 인간 사용자가 필드 중 하나를 클릭할 때 트리거되는 @Published 값으로 구동됩니다.

인간 플레이어가 필드를 클릭하면 makeMove 기능이 재개되고, 수행된 GameMove를 원격 발신자에게 반환하여 원격 호출을 완료합니다.

그리고 다시, 그게 전부야!

우리는 진정한 멀티플레이어 게임 모드를 처리하기 위해 액터 구현을 조금 변경해야 했지만, 시스템의 전반적인 디자인에는 변화가 없었다.

그리고 가장 중요한 것은, 우리의 게임 논리 변화의 어떤 것도 우리가 로컬 네트워킹을 사용할 것이라는 사실에 정말 구체되지 않았다는 것이다.

우리는 상대를 발견하고 플레이어 배우에게 분산된 방법을 호출하여 그들과 게임을 한다.

이 게임 모드를 시연하려면, 나는 함께 플레이할 상대가 필요할 것이다.

내 푹신푹신한 조수 Caplin the Capybara에게 물어보자.

그가 그걸 꽤 잘한다고 들었어!

그래, 그는 꽤 똑똑해.

그는 그걸 꽤 잘해.

여기서 해볼게.

오, 그가 날 잡았어!

이번에는 네가 이겼어, 꼬마야, 하지만 우리는 또 다른 세션을 할 거야.

도와줘서 고마워, 캐플린!

마지막으로, 다른 배우 시스템을 결합함으로써 우리가 무엇을 달성할 수 있는지에 대한 아이디어를 드리겠습니다.

예를 들어, 우리는 WebSocket 시스템을 사용하여 장치 호스팅 액터 플레이어 액터를 서버 측 로비 시스템에 등록하여 페어링하고 그들 사이의 분산 호출을 위한 프록시 역할을 할 수 있습니다.

우리는 장치 호스팅 플레이어 배우가 스스로 등록할 수 있는 GameLobby 배우를 구현할 수 있습니다.

장치가 플레이 온라인 모드로 들어가면, 그들은 접수원을 사용하여 GameLobby를 발견하고 가입을 요청할 것이다.

GameLobby는 사용 가능한 플레이어를 추적하고 한 쌍의 플레이어가 확인되면 게임 세션을 시작합니다.

게임 세션은 게임의 드라이버 역할을 하며, 움직임을 폴링하고 게임의 서버에 저장된 표현에 표시합니다.

게임이 완료되면, 우리는 결과를 수집하고 로비에 다시 보고할 수 있다.

하지만 더 흥미롭게도, 우리는 이 디자인을 수평으로 확장할 수 있다.

물론 우리는 단일 서버에서 동시에 더 많은 게임을 제공하기 위해 더 많은 게임 세션 배우를 만들 수 있지만, 분산된 배우 덕분에 클러스터에서 동시 게임 수의 균형을 맞추기 위해 다른 노드에서 게임 세션을 만들 수도 있습니다.

즉, 우리가 클러스터 액터 시스템을 가지고 있다면.

그리고, 사실, 우리는 그래!

우리는 당신이 그러한 시나리오에서 사용할 수 있도록 기능이 풍부한 클러스터 액터 시스템 라이브러리를 오픈 소스로했습니다.

SwiftNIO를 사용하여 구현되었으며, 서버 측 데이터 센터 클러스터링에 특화되어 있습니다.

그것은 실패 감지를 위한 고급 기술을 적용하며, 클러스터 전체 접수원의 자체 구현과 함께 제공됩니다.

액터 시스템의 고급 참조 구현이며 강력한 서버 측 응용 프로그램이기 때문에 살펴보시기 바랍니다.

이 세션에서 우리가 배운 것을 요약해 봅시다.

먼저, 우리는 분산 액터와 추가 컴파일러 지원 액터 격리 및 직렬화 검사를 제공하는 방법에 대해 배웠습니다.

우리는 그들이 어떻게 위치 투명성을 가능하게 하는지, 그리고 우리의 배우들이 발신자와 같은 과정에 위치할 필요성에서 벗어나기 위해 그것을 어떻게 사용할 수 있는지 배웠습니다.

우리는 또한 분산 액터를 사용하여 구축할 수 있는 것에 대해 영감을 얻기 위해 몇 가지 액터 시스템 구현을 보았습니다.

분산된 행위자는 그들이 사용하는 행위자 시스템만큼만 강력하다.

참고로, 여기 우리가 이 세션에서 본 액터 시스템 목록이 있습니다.

기본적으로 Swift와 함께 제공되는 로컬 테스트 시스템과 두 개의 샘플 액터 시스템: 클라이언트/서버 스타일 웹소켓 기반 시스템과 로컬 네트워킹 기반 시스템.

이러한 시스템은 다소 불완전하며, 분산된 배우를 사용하여 구축할 수 있는 것에 대한 영감으로 더 많은 역할을 했다.

이 세션과 관련된 샘플 코드 앱에서 볼 수 있습니다.

그리고 마지막으로, 오픈 소스 완전한 기능을 갖춘 서버 측 클러스터링 구현입니다.

지금 베타 패키지로 사용할 수 있으며, 스위프트 5.7과 함께 성숙해질 것이다.

분산된 배우에 대해 자세히 알아보려면, 다음 리소스를 참조할 수 있습니다: 이 세션과 관련된 샘플 코드는 Tic Tac Fish 게임의 모든 단계를 포함하므로 코드를 직접 자세히 살펴볼 수 있습니다.

분산 배우 언어 기능과 관련된 스위프트 진화 제안은 그들에게 힘을 실어 주는 메커니즘을 매우 자세하게 설명한다.

또한 스위프트 포럼에서 배우 시스템 개발자와 사용자 모두에게 전념하는 분산 배우 카테고리를 찾을 수 있습니다.

들어주셔서 감사합니다, 그리고 저는 당신이 당신의 앱에서 무엇을 위해 배포된 배우를 사용할지 보기를 고대하고 있습니다!

♪