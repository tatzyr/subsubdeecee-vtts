10093

♪ 부드러운 기악 힙합 음악 ♪

♪

데빈 클라리: 안녕. 저는 메시지 팀의 엔지니어인 데빈입니다.

랜스 파커: 그리고 저는 메시지 엔지니어인 랜스입니다.

데빈: "사용자 지정 협업 앱을 메시지와 통합"에 오신 것을 환영합니다.

협업은 대화로 시작되며, iOS 16과 macOS Ventura에서는 앱의 사용자 지정 협업 경험을 대화의 구조로 바로 가져올 수 있습니다.

이 비디오에서, 우리는 협업의 수명 주기를 살펴볼 것이다.

그런 다음, 메시지를 통해 공유할 앱의 협업 콘텐츠를 준비하는 방법을 보여드리겠습니다.

다음으로, 개인 정보를 손상시키지 않으면서 수신자 액세스를 즉시 확인하고 참가자 변경 사항에 응답하는 데 필요한 모든 것을 제공할 것입니다.

마지막으로, 앱이 메시지 대화에 바로 콘텐츠에 대한 공지를 게시할 수 있는 방법을 보여드리겠습니다.

이 비디오는 앱이 기존 협업 인프라를 가지고 있으며 이미 범용 링크를 채택했다고 가정합니다.

우리는 또한 "앱에 당신과 공유 추가"와 "메시지와의 협업 경험 강화"에 도입된 몇 가지 개념을 기반으로 할 것입니다.

먼저, 이 API를 통해 사용자가 그 어느 때보다 빠르게 협업을 시작할 수 있는 방법을 설명하기 위해 사용자 지정 협업 메시지의 수명 주기를 살펴볼 것입니다.

사용자가 메시지를 통해 앱의 협업을 공유하기로 결정하면, 먼저 콘텐츠를 나타내는 메타데이터를 만듭니다.

메타데이터에는 사용자가 메시지를 보내기 전에 구성할 수 있는 공유 옵션과 사용자 정의할 수 있는 다른 많은 속성이 포함되어 있습니다.

다음으로, 메타데이터를 공유 시트에 제공하거나 드래그 앤 드롭하세요.

이것은 메시지 작성 필드에서 콘텐츠의 초안을 준비할 수 있게 해준다.

협력은 보편적인 링크로 대표되어야 한다.

그것은 즉시 만들 수 있지만, 메시지가 전송되기 직전까지 연기하는 것이 가장 좋습니다.

이것은 앱의 링크 생성이 메시지 작성 필드에 구성된 선택된 공유 옵션 또는 수신자에 의존하는 경우에 유용합니다.

사용자는 수신자와 공유 옵션을 선택하고 보내기 버튼을 탭합니다.

메시지가 전송되기 전에, 메시지는 앱에 범용 링크와 콘텐츠에 대한 장치 독립적인 식별자를 요청합니다.

그 식별자를 사용하여, 메시지는 특정 협업 메시지의 수신자를 나타내는 암호화 신원 세트를 제공한다.

당신의 앱은 나중에 이러한 신원을 사용하여 수신자가 모든 장치에서 링크를 즉시 열 수 있도록 합니다.

앱은 이러한 신원을 서버에 저장하고 공유 콘텐츠와 연결합니다.

앱이 이 단계를 마치면, 메시지가 수신자에게 전송됩니다.

이제, 수신 장치에서 일어나는 일은 다음과 같습니다.

목표는 수신자 신원을 서버의 계정과 페어링하여 즉시 액세스를 확인하는 것입니다.

수신자가 링크를 열면, 앱은 다른 링크와 마찬가지로 URL을 열라는 호출을 받습니다.

앱이 사용자 계정이 아직 문서에 액세스할 수 없다는 것을 감지하면, 수신자 장치가 암호화로 서명한 사용자 신원 증명을 위해 시스템에 쿼리합니다.

앱은 검증을 위해 서명된 신원 증명을 서버로 보냅니다.

서명이 유효한 경우, 서버는 증거를 전송 장치에서 이전에 제공한 신원과 비교합니다.

일치하는 것이 있다면, 당신의 서버는 사용자의 계정에 대한 접근 권한을 부여합니다.

그리고 그것으로, 수신자는 계정 정보를 교환하지 않고도 콘텐츠에 즉각적이고 안전하게 접근할 수 있습니다!

그리고 그것이 협업 메시지의 수명 주기입니다!

다음으로, 협업을 시작하기 위한 API를 더 자세히 살펴봅시다.

그 시스템은 협업에 대한 메타데이터가 필요하다.

그리고 이를 위해, 당신은 SWCollaborationMetadata라는 Shared with You 프레임워크의 새로운 클래스를 사용합니다.

이 클래스에는 구성할 수 있는 몇 가지 속성이 있습니다: 콘텐츠의 제목, 공유되기 전에 콘텐츠를 참조하는 로컬 식별자; 사용자가 공유하는 계정에 대한 투명성을 제공하기 위한 이니시에이터 이름과 계정 핸들; 그리고 사용자가 구성할 수 있는 기본 공유 옵션.

메타데이터 객체를 만들고 속성을 구성하는 방법은 다음과 같습니다.

문자열로 초기화된 SWLocalCollaborationIdentifier를 사용하여 로컬 식별자를 만드세요.

문자열은 앱이 장치가 아닌 로컬에서 콘텐츠를 식별하는 데 충분하기만 하면 됩니다.

로컬 식별자를 사용하여 새로운 메타데이터 인스턴스를 초기화하세요.

기초 프레임워크에서 PersonNameComponents를 사용하여 콘텐츠 제목, 개시자의 계정 핸들 및 이름을 설정하십시오.

핸들과 이름은 로컬에만 표시되므로 사용자가 공유하는 계정을 확인할 수 있습니다.

다음으로, defaultShareOptions를 설정하세요.

어떻게 하는지 보여주기 전에, 먼저 옵션이 어떻게 작동하는지 설명하겠습니다.

공유 옵션은 사용자가 메시지 또는 공유 시트의 협업에서 구성하는 설정입니다.

사용자가 선택한 옵션은 메시지가 전송되기 전에 제공됩니다.

공유 옵션에는 누가 협업을 편집할 수 있는지 또는 누가 콘텐츠에 접근할 수 있어야 하는지와 같은 설정이 포함될 수 있습니다.

SWCollaborationOption부터 시작하여 몇 가지 클래스를 사용하여 옵션을 정의합니다.

그룹화 방법에 따라, 옵션은 개별 스위치 또는 설정에 대한 상호 배타적인 값을 나타냅니다.

옵션에는 제목과 식별자가 있으며, 선택되거나 선택되지 않습니다.

옵션 그룹을 나타내는 두 가지 클래스가 있습니다: SWCollaborationOptionsGroup과 SWCollaborationOptions PickerGroup.

SWCollaborationOptionsGroup을 사용하여 스위치 컬렉션을 나타내는 반면, SWCollaborationOptions PickerGroup은 설정에 대해 상호 배타적인 값을 나타냅니다.

마지막으로, SWCollaborationShareOptions는 메타데이터의 defaultShareOptions 속성에 설정될 전체 옵션 그룹 세트를 정의합니다.

옵션을 설명하기 위해 요약 문자열을 제공할 수도 있습니다.

이제 옵션 클래스를 설명했으므로, 여기에 그것들을 사용하는 방법을 보여주는 예가 있습니다.

이 코드는 두 개의 옵션 그룹을 정의한다.

첫 번째 그룹은 식별자와 두 가지 가능한 옵션으로 초기화됩니다.

식별자는 나중에 사용자가 선택한 옵션을 식별하는 데 사용하는 임의의 문자열입니다.

이것은 피커 그룹이기 때문에, 옵션은 상호 배타적이다.

이 그룹은 콘텐츠에 대한 권한 설정을 나타냅니다: 읽기 쓰기 또는 읽기 전용.

그런 다음, 그 그룹의 첫 번째 옵션은 기본적으로 선택된다.

그리고 제목은 이 그룹을 설명하는 문자열로 설정되어 있다.

두 번째 옵션 그룹은 같은 방식으로 초기화되며, 두 가지 옵션도 포함되어 있습니다.

하지만 이것은 일반적인 옵션 그룹이기 때문에, 사용자는 멘션과 댓글을 독립적으로 허용할지 여부를 구성할 수 있습니다.

마지막으로, 두 옵션 그룹은 메타데이터에 설정된 SWCollaborationShareOptions의 인스턴스를 초기화하는 데 사용됩니다.

다음으로, 메타데이터는 사용자가 콘텐츠를 공유하기로 결정한 방법에 따라 공유 시트 또는 드래그 앤 드롭에 제공됩니다.

앱이 SwiftUI를 사용하는 경우, SWCollaborationMetadata는 새로운 ShareLink API와 호환됩니다.

Transferable 및 ShareLink에 대해 자세히 알아보려면 "Meet Transferable"과 "SwiftUI의 새로운 기능"을 시청하세요.

SwiftUI에서 프록시 표현에 대한 협업을 지원하는 것이 얼마나 쉬운지는 다음과 같습니다!

전송 가능한 모델 객체 내에서 협업 메타데이터 인스턴스를 반환하기 위해 ProxyRepresentation을 설정하십시오.

그런 다음, 보기에서, 그 모델 객체로 ShareLink를 초기화하세요.

UIKit 및 AppKit 앱의 경우, NSItemProvider를 사용하여 공유를 지원합니다.

그리고 SWCollaborationMetadata는 NSItemProviderReading and writing을 준수합니다.

따라서 협업을 지원하기 위해 항목 공급자에게 메타데이터 인스턴스를 등록하기만 하면 됩니다.

가능한 한 많은 채널을 통해 공유를 지원하기 위해 콘텐츠의 여러 표현을 등록하는 것도 좋습니다.

예를 들어, 메시지는 파일 표현을 제공하는 경우 콘텐츠를 복사본으로 보낼 수 있는 옵션을 자동으로 제공합니다.

iOS 및 iPadOS의 UIActivityViewController 및 UIDragItem 및 macOS의 NSSharingServicePicker와 함께 NSItemProvider API를 사용할 수 있습니다.

iOS의 공유 시트로 설정하는 방법은 다음과 같습니다.

NSItemProvider 인스턴스를 만드세요.

시스템의 모든 프로세스에 대한 가시성을 설정하여 이전 예제에서 생성된 협업 메타데이터를 등록하십시오.

항목 제공자로 UIActivityItemsConfiguration을 초기화한 다음, 해당 구성으로 UIActivityViewController를 초기화하십시오.

그리고 마지막으로, 뷰 컨트롤러를 제시하세요.

드래그 앤 드롭을 지원하는 것은 쉽다.

NSItemProvider를 초기화하고 같은 방식으로 메타데이터를 등록한 다음, 드래그 앤 드롭 API와 함께 사용할 항목 공급자와 함께 UIDragItem을 만드세요.

API는 공유 팝오버를 위해 macOS에서 유사하다.

다시, 아이템 제공자를 설정하세요.

그리고 이번에는 NSSharingServicePicker를 초기화하는 데 사용하세요.

그런 다음 대상 보기와 관련된 피커를 보여주세요.

macOS에서 드래그 앤 드롭은 NSItemProvider가 아닌 NSPasteboardItem을 사용합니다.

이를 지원하기 위해, SharedWithYou는 NSPasteboardItem 확장을 내보냅니다.

이 확장 프로그램을 사용하여 드래그 앤 드롭을 지원하기 위해 새로운 NSPasteboardItem 인스턴스에서 직접 협업 메타데이터를 설정하십시오.

그리고 그것이 당신의 협업 콘텐츠 초안이 메시지에 상연되는 데 필요한 전부입니다!

다음으로, 사용자가 보내기 버튼을 탭하면, 시스템은 앱과 조정하여 공유를 설정합니다.

그것은 SWCollaborationCoordinator라고 불리는 새로운 수업을 통해 이것을 한다.

SWCollaborationCoordinator는 싱글톤이며, 이는 글로벌 공유 인스턴스가 있다는 것을 의미한다.

그 공유 인스턴스는 actionHandler라고 불리는 당신이 정의한 대리인을 통해 협업을 조정합니다.

앱이 항상 협업을 조정할 수 있도록, 필요할 때 백그라운드에서 실행됩니다.

따라서 출시 직후에 대리인을 등록하고 시간 초과를 피하기 위해 즉시 조치를 처리해야 합니다.

앱 실행이 끝난 후 협업 코디네이터를 설정하는 방법은 다음과 같습니다.

공유 자산을 통해 싱글톤 코디네이터 인스턴스에 액세스하세요.

그런 다음, 앱 대리인의 didFinishLaunchingWithOptions 메소드에서 actionHandler 속성을 SWCollaborationActionHandler 프로토콜을 준수하는 객체로 설정하십시오.

액션 핸들러 프로토콜은 SWAction이라는 새로운 클래스를 사용한다.

SWActions는 앱이 수행할 것으로 예상되는 작업을 나타냅니다.

당신은 그것들을 완료로 표시하기 위한 행동을 이행하고, 그렇지 않으면 실패합니다.

앱이 처리해야 할 첫 번째 작업은 협업 작업을 시작하는 것입니다.

SWStartCollaborationAction에는 사용자가 선택한 공유 옵션으로 업데이트된 이전에 설정한 협업 메타데이터가 포함되어 있습니다.

필요한 설정을 수행하면, 범용 링크와 협업을 위한 장치 독립적인 식별자로 시작 작업을 수행합니다.

시작 작업에 명시적으로 실패하면, 메시지는 취소됩니다.

다음은 예제 서버 요청을 사용하여 시작 작업을 처리하는 구현입니다.

먼저, 작업의 메타데이터 속성에서 로컬 식별자와 사용자가 선택한 공유 옵션을 검색하십시오.

식별자와 옵션을 사용하여 협업을 준비하기 위해 서버 요청을 설정하세요.

그런 다음, 서버에 요청을 보내세요.

이 예시는 비동기 대기를 사용한다.

마지막으로, 응답에서 범용 링크와 장치 독립적인 식별자로 작업을 수행하십시오.

또는, 오류가 있다면, 메시지를 취소하는 작업에 실패하세요.

시작 작업이 성공하면, 시스템은 협업 참가자를 업데이트하기 위해 앱에 두 번째 작업을 보냅니다.

SWUpdateCollaboration ParticipantsAction에는 참가자의 암호화 신원이 포함되어 있습니다.

신원은 이전 단계의 시작 작업에 의해 충족된 협업 식별자에서 파생됩니다.

콘텐츠와 관련된 서버에 신원을 저장하세요.

수신자 장치에 대한 액세스를 확인하기 위해 이 데이터를 사용할 것입니다.

마지막으로, 이 행동을 이행하면 메시지의 보편적인 링크를 보낼 것이다.

이 예제는 업데이트 참가자 작업을 처리하는 방법을 보여줍니다.

작업의 메타데이터에서 협업 식별자를 검색하세요.

이것은 시작 작업을 처리하는 동안 당신이 이행한 식별자입니다.

다음으로, 작업의 addedIdentities 속성을 사용하여 서버에 저장할 참가자 데이터를 검색하십시오.

각 신원에는 루트 해시라고 불리는 데이터 속성이 있다.

이것은 나중에 사용하기 위해 서버에 저장해야 하는 데이터입니다.

Lance는 Verifying Access 섹션에서 이 속성에 대한 자세한 내용을 검토할 것이다.

이번에는 대상 식별자와의 협업에 참가자를 추가하기 위해 다른 서버 요청을 설정하십시오.

그리고 이전과 마찬가지로, 서버에 요청을 보내고, 작업을 이행하거나 실패하세요.

이번에는, 이행 방법은 어떤 매개 변수도 취하지 않는다.

이제 협업을 설정했으므로, 앱은 메시지 수신자에게 즉각적인 액세스 권한을 부여하는 데 필요한 모든 것을 갖추고 있습니다.

내가 그걸 랜스에게 넘겨서 어떻게 하는지 보여줄게!

랜스: 고마워, 데빈. 이 섹션에서는 이전 단계에서 서버에 저장한 신원 데이터를 사용하여 수신자에게 즉각적인 액세스를 제공하는 방법을 보여 드리겠습니다.

SWPersonIdentity의 rootHash 속성은 이 검증을 수행하는 데 사용됩니다.

루트해시는 장치에서 참가자를 고유하게 식별하는 데 사용되는 안전한 값이다.

검증을 수행하려면, 루트 해시를 계산하는 방법을 이해해야 합니다.

내가 지금 그걸 통해 너를 데려갈게.

협업 메시지가 전송되면, 실제로 각 사람의 장치에 개별적으로 전송됩니다.

메시지는 암호화 공개 키를 사용하여 각 장치를 식별합니다.

목표는 이 장치 세트에서만 액세스를 허용하는 것이기 때문에, 루트 해시는 각 수신자에게 등록된 공개 키 세트에서 파생됩니다.

루트 해시는 머클 트리라고 불리는 데이터 구조의 루트 노드이다.

머클 트리는 일련의 해싱 작업을 수행하여 만들어진 이진 트리이다.

공개 키를 기반으로 사용자의 신원을 도출하기 위해, 키는 이 트리의 잎으로 사용됩니다.

머클 트리에 사용되는 해싱 알고리즘은 루트 노드가 해당 키 세트에서만 계산될 수 있도록 합니다.

이 예에서, 이 사용자는 세 개의 장치와 세 개의 공개 키를 가지고 있다.

키는 키 다양화라는 프로세스를 사용하여 앱에서 제공하는 각 협업 식별자에 대해 고유합니다.

사용자에게 등록된 장치의 수를 추적하는 것을 방지하기 위해, 세트는 고정된 크기까지 임의의 키로 채워집니다.

트리의 리프 노드는 패딩된 다양한 키 세트를 해싱하여 생성됩니다.

SHA256 알고리즘은 이 트리의 해싱 작업에 사용됩니다.

그런 다음, 각 리프 노드 쌍은 연결된 다음 상위 노드를 도출하기 위해 해시됩니다.

이 과정은 부모 노드와 함께 반복되고 단일 루트 노드가 남을 때까지 다시 반복됩니다.

이것은 장치에서 이 수신자의 신원을 고유하게 나타내는 데 사용되는 루트 해시입니다.

완전한 머클 트리에서 노드의 하위 집합을 사용하여 루트 해시를 생성할 수 있습니다.

이 트리의 루트 해시는 다양한 공개 키 P3와 함께 해시 H4, 7, 11만 사용하여 재현할 수 있습니다.

먼저, 누락된 리프 노드 H3를 얻기 위해 공개 키를 해시하세요.

H3와 H4를 사용하여 H8을 생성하세요.

H8과 함께 주어진 H7 노드를 사용하여 H10을 생성하세요.

그리고 마지막으로, H10과 H11은 루트 해시를 생성한다.

전체 트리를 재구성할 필요 없이 공개 키 P3가 주어진 루트 해시를 생성하는 데 사용되었다는 것을 증명할 수 있다는 점에 유의하는 것이 중요합니다.

이것을 하는 데 필요한 노드의 하위 집합은 포함 증명이라고 불린다.

앱에서 범용 링크가 열리면 확인이 시작됩니다.

이렇게 하려면, 먼저 링크가 협업인지 확인해야 합니다.

SWCollaborationHighlight는 협업 링크를 나타내며 SWHighlightCenter에서 검색됩니다.

그 협업 하이라이트를 사용하여 포용의 증거를 생성하세요.

포함 증명을 나타내려면, SWPersonIdentityProof라는 클래스를 사용하세요.

검증을 수행하려면, 먼저 서버로 보낼 암호화 서명과 함께 이 개체를 생성해야 합니다.

SWHighlightCenter에서 getSignedIdentityProof 방법을 사용하여 증거를 검색하십시오.

SWCollaborationHighlight와 일부 임의의 데이터가 장치에 의해 서명되어야 합니다.

당신의 협업에 접근하기 위해 나쁜 행위자가 요청을 재생할 수 없도록 서명을 사용하세요.

데이터는 서버에서 요청한 도전이거나 장치에서 생성된 nonce일 수 있습니다.

이 예시는 도전적인 접근 방식을 사용한다.

URL은 앱의 UIApplicationDelegate에서 이 방법으로 전달됩니다.

이 URL은 협업과 관련된 범용 링크입니다.

URL은 SWHighlightCenter에서 관련 SWCollaborationHighlight를 가져오는 데 사용됩니다.

다음으로, 서버에서 챌린지를 요청하고, 하이라이트와 함께 SWHighlightCenter의 getSignedIdentityProof 방법으로 다시 가져온 데이터를 전달할 것입니다.

이 방법은 서명된 신원 증명을 반환합니다.

나중에 이 데이터를 검증하기 위해 당신의 서버가 무엇을 해야 하는지 논의하겠습니다.

이제 확인을 위해 서명된 증거를 서버에 보낼 수 있습니다.

마지막으로, 나는 결과로 사용자 인터페이스를 업데이트한다.

앱은 공개 키와 서명된 데이터와 함께 증거를 서버로 보냅니다.

데이터는 SHA256을 해시 함수로 사용하여 P-256 타원 곡선을 통해 타원 곡선 디지털 서명 알고리즘을 사용하여 서명됩니다.

신원 증명의 공개 키를 사용하여 데이터의 서명을 확인하세요.

가장 일반적으로 사용되는 암호화 라이브러리로 이것을 할 수 있습니다.

서명을 확인하면, 신원 증명이 해당 공개 키와 관련된 장치에서 전송되었다는 것을 신뢰할 수 있습니다.

다음으로, 신원 증명을 사용하여 루트 해시를 다시 계산합니다.

다음은 우리가 전에 살펴본 예제 트리를 사용하여 SWPersonIdentityProof가 무엇을 포함할 것인지에 대한 예입니다.

머클 트리의 루트 해시를 재구성하는 데 사용하세요.

공개 키는 P3이다.

포함 해시는 H4, 7, 11이다.

2의 로컬 키 인덱스는 트리에서 공개 키의 위치를 나타냅니다.

다음은 증명의 속성에서 루트 해시를 재구성하는 구현의 예입니다.

재귀 알고리즘은 트리 데이터 구조로 작업할 때 잘 작동하므로, 그것이 제가 여기서 한 일입니다.

초기 호출에서, 공개 키의 해시, 포함 해시 세트 및 공개 키 인덱스를 전달하십시오.

다음으로, 첫 번째 포함 해시를 꺼냈다.

공개 키 인덱스는 키가 형제의 왼쪽이나 오른쪽에 있는지 확인하기 위해 확인됩니다.

선택된 해시는 올바른 순서로 연결된 다음 해시됩니다.

다음으로, inclusionHashes 배열에서 소비된 노드가 제거되고, 나머지는 동일한 함수에 대한 재귀 호출로 전달됩니다.

공개 키 인덱스도 트리의 다음 노드를 위해 준비되도록 업데이트됩니다.

이 간단한 함수를 사용하면 신원 증명이 주어진 루트 해시를 빠르게 계산할 수 있습니다.

서버는 이제 생성된 루트 해쉬가 전송 중에 업로드된 문서의 소유자인 루트 해시 목록에 있는지 확인할 수 있습니다.

해시는 알려진 해시 목록에 있으므로, 서버는 문서에 대한 액세스 권한을 부여할 수 있습니다.

이제 당신은 자신 있게 문서에 대한 접근 권한을 부여할 수 있습니다!

신원을 확인하기 위해 따라야 할 단계를 요약하려면: 먼저, 유니버설 링크를 처리하는 동안 콘텐츠의 협업 하이라이트를 찾아보세요.

다음으로, 데이터에 서명하고 포함 증명을 검색하세요.

서명된 데이터와 증거를 서버로 보내세요.

데이터의 서명을 확인하세요.

포함 증명을 사용하여 루트 해시를 생성하세요.

마지막으로, 루트 해시를 해당 콘텐츠와 관련된 알려진 신원 목록과 비교하세요.

이제 협업 링크에 대한 액세스 확인에 대한 모든 것을 알았으니, 메시지로 참가자 변경 사항을 조정하는 방법에 대해 이야기하겠습니다.

메시지 그룹의 참가자가 변경되고 해당 그룹이 함께 협업할 때, 사용자는 메시지 스레드의 배너에서 바로 해당 변경 사항을 앱에 전파하도록 선택할 수 있습니다.

이 시나리오에서, 당신의 앱은 추가 및 제거된 신원을 포함하는 또 다른 SWUpdateCollaboration ParticipantsAction을 받습니다.

협업을 설정할 때 이 작업을 처리하기 위해 작성한 것과 동일한 코드를 사용하지만, 제거된 참가자도 처리해야 합니다.

제거하려면, 제거된 신원과 관련된 계정을 찾아 액세스를 취소하기만 하면 됩니다.

아직 연결된 계정이 없다면, 데이터베이스에서 루트 해시를 삭제하기만 하면 됩니다.

여기 데빈이 이전에 검토한 업데이트 참가자 행동에 대한 구현이 있습니다.

이 예제는 작업에서 제거된 ID 속성을 사용하고 유사한 제거 API 요청에 전달합니다.

이 코드는 제거된 ID 처리만 보여주지만, 완전한 구현은 추가 및 제거된 ID를 모두 처리해야 합니다.

그리고 그것이 당신이 참가자 변화를 처리하는 데 필요한 전부입니다!

마지막으로, 협업이 변경되면, 앱은 메시지에 직접 표시될 변경 사항에 대한 공지를 게시합니다.

이 섹션에서 검토할 몇 가지 유형의 지원되는 공지가 있습니다.

알림은 링크가 공유된 대화에서 바로 배너로 표시됩니다.

배너에는 무엇이 바뀌었는지, 그리고 누가 변경했는지에 대한 설명이 포함되어 있다.

이 대화에서, 찰리는 베이킹 레시피 문서를 편집했다.

쇼 버튼을 탭하면 콘텐츠에 바로 다시 연결됩니다.

공지를 나타내기 위해, SharedWithYou 프레임워크에는 SWHighlightEvent라는 프로토콜이 있습니다.

하이라이트 이벤트는 SWHighlightCenter API에서 검색된 SWHighlights로 초기화됩니다.

메시지는 여러 범주의 이벤트를 지원합니다.

콘텐츠 업데이트 또는 댓글에 대한 변경 이벤트, 참가자가 가입하거나 떠날 때 멤버십 이벤트, 사용자가 협업에서 언급될 때 언급 이벤트, 콘텐츠가 이동되거나 삭제될 때의 지속성 이벤트.

다음은 협업 편집을 위해 변경 이벤트를 게시하는 방법을 보여주는 예입니다.

하이라이트 센터 API를 사용하여 대상 식별자에 대한 협업 하이라이트를 검색하십시오.

기억하세요, 이 식별자는 협업 시작 중에 정의한 것이므로, 앱은 콘텐츠가 변경될 때 사용할 수 있어야 합니다.

다음으로, 하이라이트 변경 이벤트 인스턴스를 만드세요.

이니셜라이저는 하이라이트와 트리거 열거형 값을 취합니다. 이 경우 편집 유형으로 설정하십시오.

마지막으로, 다시 하이라이트 센터를 사용하여, 그 행사에 대한 공지를 게시하세요.

마찬가지로, 멤버십 변경의 경우, 멤버십 이벤트를 게시하고, 이번에는 추가된 공동 작업자 또는 제거된 공동 작업자 트리거 유형을 통과합니다.

다음으로, 앱이 사용자 멘션을 지원하는 경우, 멘션 이벤트를 게시할 수 있습니다.

언급된 사용자의 루트 해시로 사람 신원을 초기화하세요.

액세스를 확인하는 동안 앱의 사용자 계정과 개인 신원을 연결했다는 것을 기억하세요.

그런 다음, 같은 방식으로 멘션 이벤트를 게시하고, 이번에는 언급된 신원을 매개 변수로 전달합니다.

이 통지는 언급된 사용자에게 보내는 메시지에만 표시됩니다.

마지막으로, 콘텐츠가 이동, 이름 변경 또는 삭제될 때 지속성 이벤트 유형을 사용하세요.

여기서, 이름이 바뀐 트리거 유형은 사용자가 콘텐츠의 이름을 변경했다는 것을 나타내기 위해 사용됩니다.

그리고 그것이 당신의 앱이 공동 작업자에게 알릴 수 있는 방법이며, 그들은 메시지에서 바로 업데이트를 받을 것입니다.

데빈: 그리고 그것으로, 당신은 몇 가지 단계를 따라 앱의 협업 경험을 메시지와 통합할 준비가 되었습니다.

콘텐츠를 공동으로 공유하도록 설정하고, 참가자 액세스를 암호화하여 확인하고, 참가자 변경 사항을 추적하고, 메시지에 공지를 게시하여 사용자를 콘텐츠에 바로 연결하세요.

"메시지와 협업 경험 향상" 비디오를 확인하여 협업을 위해 표시할 수 있는 새로운 UI 요소에 대해 자세히 알아보세요.

랜스: 우리는 당신의 앱과 협력하기를 기다릴 수 없습니다!

데빈과 랜스는 암호로 서명했다.

데빈: 봐줘서 고마워!

♪