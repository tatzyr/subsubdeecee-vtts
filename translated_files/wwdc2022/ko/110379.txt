110379

♪ ♪

제레미: 안녕. 저는 제레미이고, AVFoundation을 사용하여 더 반응이 빠른 미디어 앱을 만드는 방법을 보여주기 위해 왔습니다.

앱에서 미디어 자산을 사용할 때, 단순히 재생하는 것 이상을 하고 싶을 수도 있습니다.

썸네일을 보여주거나, 미디어를 새로운 구성으로 결합하거나, 자산에 대한 정보를 얻고 싶을 수도 있습니다.

이러한 작업은 데이터를 로드해야 하며, 비디오와 같은 큰 파일을 사용하면 완료하는 데 시간이 좀 걸릴 수 있습니다.

불행히도, 이 작업이 메인 스레드에서 동기적으로 수행되면 앱에 대기 시간 문제를 쉽게 도입할 수 있습니다.

앱의 반응성을 유지하는 가장 좋은 방법은 데이터를 비동기적으로 로드하고 완료되면 UI를 업데이트하는 것입니다.

AVFoundation에는 이것을 쉽게 만들 수 있는 도구가 있다.

그래서 여기 우리가 오늘 얘기할 게 있어.

먼저, AVFoundation의 새로운 비동기 API를 소개해 드리겠습니다.

그런 다음, 작년에 도입한 비동기 로드(_:) 방법을 사용하여 자산 검사에 대한 업데이트를 드리겠습니다.

그리고 AVAssetResourceLoader를 사용하여 로컬 및 캐시된 미디어에 대한 사용자 지정 데이터 로딩을 최적화하는 방법을 보여드리겠습니다.

하지만 먼저, 새로운 비동기 API로 넘어가자.

AVAssetImageGenerator로 비디오에서 스틸 이미지를 잡는 것은 썸네일을 만드는 좋은 방법입니다.

하지만 이미지 생성은 즉각적이지 않다.

이미지를 생성하려면, 이미지 생성기는 비디오 파일에서 프레임 데이터를 로드해야 합니다.

그리고 원격 서버나 인터넷에 저장된 미디어의 경우, 로딩이 훨씬 느려질 것이다.

그것이 당신이 이미지를 생성하는 방법이 중요한 이유입니다.

copyCGImage와 같이 메인 스레드에서 데이터를 동기적으로 로드하는 방법을 사용하면 비디오가 로드되기를 기다리는 동안 UI가 멈출 수 있습니다.

올해, 우리는 이미지 생성기가 데이터를 로드하는 동안 호출 스레드를 확보하기 위해 async/await를 사용하는 이미지(at: time) 비동기 메서드를 추가했습니다.

이미지 생성기는 이미지와 자산의 실제 시간이 있는 튜플을 반환합니다.

실제 시간이 요청한 시간과 다를 수 있는 몇 가지 이유가 있지만, 이미지만 원한다면 .image 속성으로 직접 액세스할 수 있습니다.

압축된 비디오의 일부 프레임은 다른 프레임보다 로드하기 쉽다.

iFrames는 독립적으로 디코딩할 수 있는 반면, 다른 프레임은 디코딩하기 위해 근처의 프레임에 의존한다.

요청한 시간 동안, 이미지 생성기는 기본적으로 가장 가까운 iFrame을 사용하여 이미지를 생성합니다.

요청한 시간에 대한 정확한 프레임을 얻기 위해 허용 오차를 0으로 설정하는 것이 유혹적일 수 있습니다.

하지만 그 프레임은 이미지 생성기가 로드해야 할 다른 근처의 프레임에 의존할 가능성이 높다는 것을 명심하세요.

대신, 당신이 찾고 있는 결과를 여전히 제공할 수 있는 넓은 허용 오차를 설정하는 것을 고려해 보세요.

넓은 허용 오차는 이미지 생성기가 선택할 수 있는 더 많은 프레임을 제공하여 데이터 로딩을 최소화하는 데 도움을 준다.

로드해야 하는 프레임이 적을수록, 이미지를 더 빨리 반환할 수 있다.

자산에서 여러 번 일련의 이미지를 얻기 위해, 이미지 생성기는 generateCGImagesAsynchronously(forTimes:)를 가지고 있다.

그러나 스위프트에는 그것을 사용하기 위해 주의해야 할 뉘앙스가 있다.

올해 우리는 이미지(for: times) 방법을 추가했습니다.

이제 CMTimes 배열이 필요하므로, 먼저 NSValues에 매핑할 필요가 없습니다.

그것은 또한 비동기 시퀀스를 사용하여 결과를 제공한다.

스위프트에서 시퀀스를 사용하면 for in 루프를 사용하여 항목을 반복할 수 있습니다.

한 번에 모두 준비되지 않은 항목 시퀀스의 경우, 비동기 시퀀스를 사용하면 각 반복 후 다음 요소를 기다릴 수 있습니다.

성공적으로 생성된 각 이미지에 대해, 결과는 원래 요청된 시간과 이미지와 함께 실제 시간을 포함합니다.

만약 그것이 실패한다면, 그 결과는 그 이유를 설명하는 오류가 있다.

그리고 이미지에만 관심이 있다면, 결과는 값에 직접 액세스할 수 있는 속성을 가지고 있으며, 생성이 실패하면 오류가 발생할 수도 있습니다.

비동기 시퀀스에 대해 자세히 알아보려면, "동기 시퀀스 만나기" 세션을 확인하는 것이 좋습니다.

이미지 생성과 같은 작업의 경우, 데이터를 로드하는 방법을 보는 것이 조금 더 쉽습니다.

하지만 문제 지점으로 선택하기 어려운 AVFoundation의 다른 동기 영역이 있다.

AVMutableComposition은 이러한 영역 중 하나이다.

구성에 참조를 추가하기 위해 자산의 트랙에 대한 정보가 필요한 자산에 대한 시간 범위를 삽입하십시오.

트랙을 동시에 검사하므로, 트랙이 아직 로드되지 않은 경우, 새로운 컴포지션 트랙을 만들기 위해 동기적으로 로드됩니다.

이전에, 해결책은 구성에 삽입하기 전에 자산의 트랙을 로딩하기를 기다리는 것이었을 것이다.

그러나, 올해, 우리는 필요에 따라 트랙을 비동기적으로 로드할 insertTimeRange의 비동기 버전을 소개합니다.

비디오 구성과 변경 가능한 비디오 구성에는 자산의 속성을 로드해야 하는 추가 방법도 있습니다.

올해 새로운 "propertiesOf asset" 생성자와 isValid(for:timeRange:) 메서드도 이제 비동기 대응을 가지고 있습니다.

이 새로운 방법은 자산의 트랙과 기간을 비동기적으로 로드하므로, 미리 로드할 필요도 없습니다.

이러한 새로운 비동기 방법은 비동기적으로 필요한 속성을 로드하여 자산과 더 쉽게 상호 작용할 수 있게 해준다.

하지만 자산의 속성을 직접 로드해야 할 때, 비동기 자산 검사를 재교육해 봅시다.

당신은 자산의 재산을 검사하는 두 가지 방법이 있다는 것을 알아챘을 것입니다.

AVFoundation이 도입되었을 때, 속성을 검사하는 가장 좋은 방법은 비동기 키 값을 로드하는 것이었다.

작년에, 우리는 비동기 로드(_:)를 도입했다.

그것은 형식 안전 키를 사용하여 로드할 속성을 식별하며, 오래된 비동기 키 값 로딩 기술은 하드 코딩된 문자열을 키로 사용합니다.

이 문자열 키의 오타는 잡기 어렵다.

키를 잘못 입력하면 비동기적으로 로드되는 것을 방지하고, 나중에 속성이 사용될 때 로드되는 동안 차단됩니다.

또한 로드할 키에 새로운 속성을 추가하는 것을 잊어버리거나 비동기 로드를 완전히 잊어버리는 것은 매우 쉽습니다.

이러한 이유로, 올해, 우리는 비동기 로드를 위해 스위프트의 비동기 키 값 로딩과 동기 속성을 더 이상 사용하지 않습니다.

비동기 로드는 오타를 방지하기 위해 유형 안전 식별자를 사용합니다.

언로드된 속성에 접근하지 않도록 요청된 대로 속성 값을 직접 반환합니다.

그리고 이 모든 것이 컴파일 시간에 확인되기 때문에, 새로운 IO 바운드 성능 문제를 도입하는 것을 방지할 수 있습니다.

비동기 로드는 이제 AVAsset, AVAssetTrack, AVMetadataItem 및 하위 클래스의 속성을 비동기적으로 검사하는 유일한 권장 방법입니다.

그러나, 이 수업들 중 소수는 여전히 동기식 재산 검사를 제공할 것이다.

그것은 그들의 속성에 대한 데이터가 이미 메모리에서 사용할 수 있기 때문이다.

이유를 알아보기 위해 변경 가능한 구성을 다시 한 번 살펴봅시다.

우리는 두 개의 기존 비디오 트랙의 세그먼트를 결합하기 위해 가변 구성을 사용할 것입니다.

우리는 빈 컴포지션을 만들고 빈 비디오 트랙을 추가하는 것으로 시작할 것입니다.

그런 다음, 우리는 첫 번째 비디오 트랙의 일부를 컴포지션 트랙에 동시에 삽입할 수 있습니다.

무대 뒤에서, 이 단계는 어떤 데이터도 로드하지 않는다.

대신, 그것은 원하는 트랙을 가리키는 새로운 트랙 세그먼트를 추가합니다.

그러면 우리는 같은 방식으로 두 번째 트랙의 일부를 추가할 수 있다.

컴포지션 자체는 파일이 아닌 메모리 구조에 의해 뒷받침되기 때문에, 먼저 로드할 필요 없이 속성을 동기적으로 안전하게 검사할 수 있습니다.

다시 말하지만, 이러한 이유로, 동기식 속성 검사는 이러한 클래스에서 계속 사용할 수 있으며 모든 클래스는 비동기식 검사를 위해 비동기 부하를 사용할 것이다.

AVFoundation의 이러한 모든 새로운 비동기 방법을 사용하면 미디어 데이터를 로드하는 동안 차단을 더 쉽게 방지할 수 있습니다.

하지만, 처음으로 앱에 동시성을 도입하는 것은 까다로울 수 있습니다.

Swift 동시성을 시작하고 앱에서 AVFoundation의 비동기 부하로 마이그레이션하는 데 도움이 필요하면 WWDC 21의 이 세션을 확인하세요.

마지막 주제를 위해, 자산에 대한 사용자 지정 데이터 로딩을 최적화하는 것에 대해 이야기해 봅시다.

시작하려면, AVAsset이 기본적으로 데이터를 어떻게 로드하는지 살펴봅시다.

URL로 AVAsset을 만들 때, 미디어는 네트워크에 있거나 장치에 로컬로 저장할 수 있습니다.

네트워크에 있다면, AVAsset은 원활한 재생을 보장하기 위해 일정량의 데이터를 동적으로 캐시할 것이다.

미디어가 로컬인 경우, AVAsset은 캐시를 우회하고 재생에 필요한 데이터를 로드할 수 있습니다.

어떤 경우에는 AVAsset에게 미디어에 대한 직접 포인터를 제공하지 못할 수도 있습니다.

사용자 지정 프로젝트 파일 안에 mp4의 원시 바이트를 저장할 수도 있습니다.

이와 같은 상황에서, AVAsset은 AVAssetResourceLoader를 사용할 수 있습니다.

리소스 로더는 특별한 방법으로 로드할 수 있는 미디어에서 임의의 바이트를 요청할 수 있는 방법을 자산에 제공합니다.

하지만 자산이 더 이상 데이터 읽기를 처리하지 않기 때문에, 각 청크를 로드하는 데 얼마나 걸릴지 예측할 수 없습니다.

따라서 미디어에 액세스하는 것은 네트워크 통신을 포함한다고 가정하고, 재생할 준비가 되기 전에 데이터를 캐시할 때까지 기다린다.

올해, 미디어를 로컬에서 사용할 수 있다면, 리소스 로더에 대해 entireLengthAvailableOnDemand를 활성화할 수 있습니다.

이 플래그를 설정하면 요청된 대로 데이터를 받을 것으로 예상할 수 있으므로 캐싱을 건너뛸 수 있습니다.

로컬 미디어의 경우, 전체LengthAvailableOnDemand는 추가 데이터를 캐시할 필요가 없기 때문에 재생 중 앱의 메모리 사용량을 줄이는 데 도움이 될 수 있습니다.

또한 자산이 캐시가 먼저 채워지기를 기다릴 필요가 없기 때문에 재생을 시작하는 데 걸리는 시간을 줄일 수 있습니다.

하지만, 이 깃발을 활성화할 때 주의하세요.

로딩에 네트워크 파일 저장을 포함한 네트워크 작업이 필요한 경우, 재생이 신뢰할 수 없을 가능성이 높습니다.

그것이 리소스 로더의 새로운 개선 사항이다.

이제 앱의 몇 가지 다음 단계로 마무리합시다.

미디어로 작업할 때, async/await를 사용하여 백그라운드에서 로드되는 동안 앱이 반응하는 상태로 유지하십시오.

더 빠른 결과를 위해 이미지 생성기를 사용할 때 허용 오차를 늘리는 것을 고려하십시오.

그리고 로컬에서 사용 가능한 미디어에 리소스 로더를 사용하는 경우, 필요에 따라 전체 길이를 활성화하여 성능을 높일 수 있습니다.

그게 내가 오늘 가진 전부야.

시청해 주셔서 감사합니다, 그리고 WWDC 22를 즐기세요.