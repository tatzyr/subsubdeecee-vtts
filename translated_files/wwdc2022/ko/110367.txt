110367

♪ ♪

알렉스: 안녕하세요, 제 이름은 알렉스이고, 저는 개발자 도구에서 일하고 있습니다.

오늘 저는 Xcode 14에서 지원되는 새로운 C++ 20 기능에 대해 이야기하고 싶습니다.

나는 특히 C++ 20 개념이 일반 C++ 코드의 유형 안전성을 단순화하고 개선하는 방법에 초점을 맞출 것이다.

나는 개념을 사용하는 방법을 보여줄 것이고 당신만의 개념을 만드는 방법도 설명할 것이다.

Xcode에서 지원되는 몇 가지 다른 새로운 C++20 기능을 나열하여 이야기를 끝내고, 컴파일 시간 코드 평가의 힘을 통해 C++ 프로젝트의 성능을 향상시키는 데 그 중 일부를 어떻게 사용할 수 있는지에 대해 다룰 것입니다.

C++ 개념에 뛰어들기 전에, 먼저 C++로 일반 코드를 작성하는 방법에 대한 간략한 개요를 살펴봅시다.

숫자가 홀수인지 확인하는 함수를 쓰고 싶다고 가정해 봅시다.

'Int' 매개 변수를 사용하는 함수를 작성할 수 있으며, 'int' 유형으로 나타낼 수 있는 모든 값으로 작동합니다.

64비트 부호 없는 정수 값을 전달하면 어떻게 될까요?

이와 같은 구체적인 함수는 'int' 유형에 맞도록 잘려질 때 64비트 값으로 올바르게 작동하지 않습니다.

이 문제를 해결하기 위해, 나는 'isOdd'를 함수 템플릿으로 만들 수 있다.

이제 함수 템플릿이 있으므로, 64비트 부호 없는 정수 값을 전달할 수 있습니다.

컴파일러는 이제 'uint64_t' 유형과 올바르게 작동하는 'isOdd'의 전문화를 자동으로 생성합니다.

이것은 내가 두 가지 다른 유형에서 작동하는 'isOdd'의 두 버전을 작성할 필요가 없다는 것을 의미하기 때문에 정말 유용하다.

C++ 템플릿을 사용하여 'isOdd'와 같은 일반 함수와 일반 컨테이너 클래스도 작성할 수 있습니다.

'isOdd'를 어떻게 사용할 수 있는지 살펴봅시다.

이 기능은 테스트 파일에 추가한 몇 가지 테스트 사례로 테스트됩니다.

불행히도, 나는 내 시험 중 하나에서 실수를 했다.

컴파일러는 실수를 잡았지만, 내가 실수를 한 곳을 가리키는 대신, 컴파일러는 'isOdd' 템플릿 안에 오류를 보여준다.

내가 오타를 만들고 시험에서 '11' 대신 '1.1'을 쓴 것 같아.

그 때문에, 컴파일러는 '더블' 유형을 취하는 'isOdd'의 전문화를 생성한다.

불행히도, Xcode가 'isOdd'가 잘못된 유형으로 호출된 특정 위치를 가리키지 않았기 때문에 이 오타를 찾는 데 시간이 좀 걸렸습니다.

언어와 컴파일러가 이런 실수를 더 빨리 찾는 데 도움이 될 수 있나요?

음, 현재 예에서, 'isOdd'에 허용되는 유형에 대한 요구 사항은 명시적으로 명시되지 않았습니다.

정수 유형을 사용하여 isOdd를 호출해야 한다는 문서 주석만 있습니다.

C++20 이전에, C++ 프로그래머는 일반 C++ 코드를 작성할 때 템플릿 요구 사항을 지정할 수 있는 좋은 방법이 없었다.

그들은 종종 템플릿 요구 사항을 지정할 때 문서 주석, 특정 매개 변수 이름 또는 복잡한 enable_if 확인에 의존해야 했다.

음, 들어보셨겠지만, C++ 20은 개념이라는 새로운 C++ 기능을 소개합니다.

개념을 사용하여 일반 C++ 코드에서 템플릿 요구 사항을 검증할 수 있습니다.

개념이 'isOdd'로 전달될 수 있는 유형을 검증하는 데 어떻게 도움이 될 수 있는지 살펴봅시다.

먼저, 'isOdd' 선언으로 돌아가자.

현재, 저는 '클래스' 키워드를 사용하여 이 템플릿에서 사용되는 'T' 유형이 모든 유형이 될 수 있음을 지정합니다.

C++ 20을 사용하면 '클래스' 키워드 대신 개념을 사용하여 이 템플릿을 사용할 수 있는 유형 세트를 제한할 수 있습니다.

표준 라이브러리에서 제공하는 '통합' 개념을 사용하여 이 'isOdd' 함수 템플릿을 내장된 정수 유형으로만 제한할 수 있습니다.

컴파일러는 T가 이 개념을 만족시키지 못할 때 이 함수 템플릿을 전문화하려고 시도조차 하지 않을 것이다.

통합 개념은 C++ 표준 라이브러리에 선언되어 있다.

그래서 나는 그것을 내 코드에 사용하기 위해 개념 헤더를 포함시켜야 한다.

이제 'isOdd' 함수 템플릿의 _T_ 유형에 '통합' 요구 사항을 추가했으므로, 컴파일러는 내가 테스트에서 실수를 한 곳을 직접 가리키는 훨씬 더 명확한 진단을 제공할 수 있다.

알고 보니, '1.1'은 이중이며, 따라서 '통합' 개념을 만족시키지 못한다.

컴파일러는 이전보다 훨씬 더 빨리 이 오타를 찾고 고치는 데 도움이 되는 명확한 오류 메시지로 이것을 설명할 수 있다.

버그를 수정하는 데 도움을 주는 것 외에도, 'isOdd'로 전달된 유형을 제한하는 것은 내가 가지고 있는 모든 테스트 케이스가 정수 유형에서만 작동하는 'isOdd'이며, 실제로 알고리즘의 의도된 동작을 테스트하고 있다는 것을 안심하게 해준다.

개념을 사용하여 템플릿을 사용할 수 있는 유형에 대한 의도를 선언할 수 있습니다.

그런 다음 컴파일러는 템플릿이 전문화되기 전에 형식 요구 사항을 검증할 것입니다.

개념을 어떻게 사용할 수 있는지, 그리고 C++ 표준 라이브러리에서 어떤 핵심 개념을 제공하는지 자세히 살펴봅시다.

C++ 표준 라이브러리는 개념 라이브러리를 제공한다.

유형의 핵심 동작을 검증하는 데 사용할 수 있는 일련의 핵심 언어 개념을 구현합니다.

코드에 개념 헤더를 포함하여 이 라이브러리에 액세스할 수 있습니다.

나는 이미 이전 예시에서 '통합' 개념을 어떻게 사용할 수 있는지 보여주었다.

이제, 이 도서관에서 제공하는 다른 개념들을 살펴봅시다.

이 라이브러리는 유형이 내장 유형 중 하나인지 테스트하는 개념과 같은 많은 유용한 핵심 언어 개념을 제공합니다.

예를 들어, 'floating_point' 개념은 'float'와 'double'과 같은 내장 유형으로 만족됩니다.

여기에 표시된 'static_assert'는 이것이 실제로 사실임을 증명한다.

또한 유형이 구성 가능한지, 파괴 가능한지, 전환 가능한지, 아니면 다른 유형과 동일한지 확인하는 다른 많은 유용한 핵심 개념을 제공합니다.

예를 들어, 'convertible_to' 개념은 유형을 다른 유형으로 변환할 수 있는지 테스트합니다.

그리고 'move_constructible' 개념은 같은 유형의 다른 값에서 직접 구성할 수 있는 유형으로 만족됩니다.

이 라이브러리는 또한 유형을 다른 유형과 비교할 수 있는지 테스트하는 몇 가지 비교 개념을 제공합니다.

예를 들어, 'equality_comparable' 개념은 동일한 유형의 값으로 작동하는 유효한 '==' 연산자를 가진 유형에 의해 충족된다.

이 슬라이드에 언급된 개념 외에도, 이 도서관은 수많은 다른 핵심 언어 개념을 제공한다.

그것은 또한 유형을 이동하거나 복사할 수 있는지 테스트하는 개념을 제공한다.

그 외에도, 그것은 또한 유형이 호출 가능한 객체인지 확인하는 개념을 제공한다.

이제 C++ 표준 라이브러리에서 제공한 개념을 살펴보았으니, 개념을 사용하여 템플릿을 제한하는 방법을 살펴봅시다.

앞서 보여준 것처럼, 템플릿에서 클래스 키워드 대신 개념을 사용하여 이 템플릿에 허용되는 유형을 제한할 수 있습니다.

그 외에도, 유형을 여러 개념으로 제한해야 하는 경우 템플릿 선언에서 '필수' 절을 사용할 수 있습니다.

어떻게 할 수 있는지 보기 위해 약간 다른 예를 살펴봅시다.

여기 'isDefaultValue' 함수 템플릿이 있습니다.

주어진 값이 그 유형의 기본값과 같으면 true를 반환합니다.

이 템플릿이 전문화되기 전에 이 유형이 이러한 작업을 지원하는지 테스트하기 위해 표준 라이브러리의 두 가지 개념을 사용할 수 있습니다.

이 함수 템플릿에 허용되는 유형 집합을 제한하기 위해 '필수' 절을 추가할 것입니다.

개념 라이브러리의 어떤 개념이 여기서 유형을 검증하는 데 도움이 될 수 있는지 봅시다.

먼저, 'equality_comparable' 개념은 _T_를 같은 유형의 다른 값과 비교할 수 있는지 테스트합니다.

그런 다음, 'default_constructible' 개념은 _T_가 기본 생성자가 있는 유형인지 테스트합니다.

그들 사이의 논리와 연산자는 컴파일러에게 두 개념을 모두 검증하도록 지시한다.

이것은 이 기능 템플릿이 지원되는 유형으로만 전문화되도록 보장합니다.

우리가 지금까지 개념에 대해 배운 것을 살펴봅시다.

템플릿에서 사용할 수 있는 유형을 제한하려면 개념을 사용해야 합니다.

그러면 컴파일러는 유형 불일치가 발생하면 템플릿을 전문화할 필요가 없기 때문에 더 명확한 진단을 보여줄 수 있을 것이다.

유형의 핵심 동작을 검증해야 하는 경우 개념 라이브러리의 개념을 재사용해야 합니다.

유형이 여러 요구 사항을 준수하는지 테스트해야 할 때 템플릿에 '요구' 절을 추가해야 합니다.

우리는 이제 C++ 프로그램에서 개념을 사용하는 방법을 보았다.

C++를 사용하면 유형의 특정 동작을 검증하는 사용자 지정 개념을 선언할 수 있습니다.

특정 유형의 행동을 검증하는 우리만의 개념을 만드는 방법을 살펴봅시다.

하지만 그렇게 하기 전에, 우리는 우리가 선언하고 싶은 개념에 의해 검증되어야 하는 행동 요구 사항을 식별하는 방법을 살펴볼 필요가 있다.

개념을 사용하여 특정 유형의 행동을 검증하는 방법을 설명하기 위해 새로운 예를 사용할 것입니다.

다양한 2차원 모양을 이미지로 렌더링할 수 있는 C++ 라이브러리를 만들고 있다고 가정해 봅시다.

저는 제 도서관에서 다양한 모양을 지원하고 싶습니다.

렌더링하는 것이 가장 간단하기 때문에, 나는 원 모양으로 시작하고 있다.

나는 위치와 반경과 같은 속성을 저장하기 위해 C++ 클래스를 사용할 것이다.

원을 렌더링하기 위해, 나는 렌더링된 이미지의 각 픽셀에서 실행되는 거리 함수 기반 렌더링 알고리즘을 사용할 것이다.

이 알고리즘은 렌더링하기 위해 도형 표면까지의 거리를 계산해야 한다.

서클 클래스의 'getDistanceFrom' 메소드는 그것을 계산한다.

그것은 원 내부의 음의 거리와 원 외부의 양의 거리를 반환한다.

원 외에도, 나는 다른 모양을 렌더링하고 싶다.

예를 들어, 다른 원 모양에서 한 원 모양을 기하학적으로 빼면 초승달 모양도 렌더링할 수 있다.

나는 클래스를 사용하여 렌더링하고 싶은 크레센트와 같은 모양을 대표할 것이다.

각각의 새로운 모양 클래스에는 'getDistanceFrom' 메소드가 포함되어 있습니다.

여러 모양 클래스를 만든 후, 이제 구현을 확인하기 위해 이러한 모양을 렌더링해 보고 싶습니다.

어떤 모양에서도 작동하는 렌더링 기능을 만드는 방법에 대한 몇 가지 옵션이 있습니다.

도형에 대한 클래스 계층 구조를 만들고, 가상 방법을 사용하여 도형 표면까지의 거리를 계산할 수 있습니다.

그러나, 이 함수는 렌더링 중에 수백만 번 호출될 것이기 때문에 가상 호출 오버헤드를 피하고 싶기 때문에 성능상의 이유로 대신 함수 템플릿을 사용할 것입니다.

이것이 내가 이 렌더링 함수 템플릿을 만든 이유이다.

computePixelColor 함수는 모양 값을 취하고, 주어진 픽셀이 모양 안에 있는지 확인합니다.

만약 그것이 안에 있다면, 그것은 평범한 흰색을 반환한다.

이것은 이제 내가 모양을 올바르게 채울 수 있는지 확인할 수 있게 해준다.

이 기능은 원형, 초승달 또는 기타 일치하는 유형 등 모든 모양 유형에서 작동하도록 하는 템플릿입니다.

템플릿이 여기서 잘 작동하지만, 이 함수에 전달될 수 있는 유형을 제한하기 위해 개념을 사용하고 싶습니다.

이 함수에 전달된 유형을 제한하면 컴파일러가 유형 불일치가 발생할 때 더 명확한 진단을 생성할 수 있습니다.

그 외에도, 이 함수에 전달된 유형을 제한하면 이 함수의 추가 과부하를 추가할 수 있습니다.

유형을 제한하기 위해, 나는 모양 개념을 만들 것이다.

이 개념은 유형의 동작을 검증하고, 원, 초승달 및 미래에 추가하고 싶은 다른 모양 클래스와 같은 클래스를 받아들일 것이다.

'모양'과 같은 개념을 만들기 위해, 나는 먼저 이 개념에 의해 검증되어야 하는 요구 사항을 식별해야 한다.

이걸 어떻게 할 수 있는지 보자.

이 함수 템플릿은 'T' 유형을 일반 유형으로 사용합니다.

그런 다음 'T' 유형의 'shape'라는 인수가 이 함수에 전달됩니다.

그런 다음 'shape' 인수는 'getDistanceFrom' 메서드를 호출할 때 함수 내에서 사용됩니다.

보시다시피, 이 기능에서 다른 작업이 수행되지 않기 때문에, 이것은 제 개념에서 검증하고 싶은 유일한 요구 사항입니다.

'필수' 표현식을 사용하여 유형이 특정 방식으로 작동하는지 테스트할 수 있습니다.

Shape 개념을 만들기 위해 '필수'를 어떻게 사용할 수 있는지 살펴봅시다.

나는 '요구' 내부의 유형의 동작을 테스트하는 일련의 표현을 제공해야 한다.

나는 이미 'getDistanceFrom'에 대한 호출을 테스트해야 할 단일 요구 사항으로 확인했기 때문에, 이제 'Shape' 개념을 만들 수 있습니다.

나는 '개념' 키워드를 사용하여 모양 개념을 선언했다.

그런 다음 유형을 검증하기 위해 이 개념에 '필수' 표현을 추가했습니다.

나는 '필수' 표현에 인수 목록을 추가했다.

이 인수 목록을 사용하면 '요구 사항' 내에서 테스트할 'T' 유형의 '모양' 값을 선언할 수 있습니다.

모든 유형의 값을 선언하기 위해 필요 표현식의 인수 목록을 사용할 수 있습니다.

그러면 요구 사항에 이러한 값을 사용할 수 있습니다.

'필수' 표현의 본문에는 이 개념이 충족되기 위해 통과해야 하는 일련의 요구 사항이 포함되어 있습니다.

'Shape' 개념은 'getDistanceFrom'에 대한 메서드 호출이 유효한지 확인하는 하나의 간단한 표현 요구 사항을 가지고 있습니다.

이 표현은 실제로 프로그램에서 실행되지 않을 것이다.

유형의 동작을 검증하기 위해 컴파일 시간에만 필요하며, 검증 후에 폐기됩니다.

표현식 요구 사항을 사용하여 특정 표현식이 컴파일되는지 여부를 테스트하여 유형의 동작을 검증할 수 있습니다.

'getDistanceFrom' 메소드 호출에 대한 인수를 놓치고 있기 때문에 이 특정 표현은 아직 완성되지 않았습니다.

나는 이 방법이 'float' 유형의 두 값을 취하기를 원한다는 것을 알고 있으므로, 두 개의 부동 소수점 리터럴을 사용하여 이 표현식을 완성할 수 있다.

나는 'getDistanceFrom' 메소드가 플로트 값을 반환한다는 것을 테스트하기 위해 추가 검사를 추가할 것이다. 왜냐하면 그것이 내 일반 코드에서 가정하는 것이기 때문이다.

저는 현재 유형에 'getDistanceFrom' 메서드가 있는지 테스트하기 위해 간단한 표현식 요구 사항을 사용하고 있습니다.

그러나, 나는 그것이 float 값을 반환한다는 것을 테스트하기 위해 표현식 요구 사항 대신 복합 요구 사항을 사용할 수 있다.

화살표 연산자는 복합 요구 사항을 따를 수 있다.

화살표 연산자는 오른쪽에 제약을 예상하므로 'same_as'와 같은 표준 라이브러리 개념을 사용하여 'getDistanceFrom' 메서드에 대한 호출이 float 값을 반환하는지 확인할 수 있습니다.

이제 이 개념은 나에게 준비된 것처럼 보인다.

'computePixelColor' 함수에 전달될 수 있는 유형을 제한하기 위해 그것을 사용할 수 있습니다.

이제 내 일반적인 'computePixelColor' 기능은 '모양' 개념을 충족하는 유형에서만 작동합니다.

이것은 이 두 유형 모두 '모양' 개념을 만족하기 때문에 Circle과 Crescent와 같은 클래스가 이 특정 일반 'computePixelColor' 함수를 사용하여 렌더링된다는 것을 의미합니다.

렌더링된 평범한 모양을 본 후, 저는 제 모양 중 일부에 색상을 추가하는 'computePixelColor'의 다른 버전을 만들고 싶습니다.

내 셰이프 라이브러리에 다채로운 GradientCircle 클래스를 추가하고 싶다고 가정해 봅시다.

이제 이미지의 픽셀 색상을 계산하기 위한 새로운 기능이 필요합니다.

C++20을 사용하면 'computePixelColor' 함수 템플릿의 여러 변형을 만들 수 있습니다.

각 변형은 다른 개념을 사용하여 제한되어야 한다.

나는 GradientCircle과 같은 수업에서 만족할 새로운 GradientShape 개념을 만들 것이다.

이 개념은 그라디언트가 있는 모양에서만 작동하는 'computePixelColor'의 새로운 변형을 제한할 것이다.

이 개념은 셰이프 개념과 마찬가지로 '필수' 표현을 사용하여 구현된다.

그러나, 나는 GradientShape가 원래의 Shape 개념도 만족시키기를 원하기 때문에, 나는 그것을 새로운 개념의 첫 번째 요구 사항으로 포함시킨다.

이것은 GradientShape 개념을 만족시키는 클래스가 Shape 개념을 만족시키도록 보장하며, 이는 내가 여전히 그러한 클래스의 값에 대해 'getDistanceFrom' 메소드를 호출할 수 있다는 것을 의미한다.

그런 다음 논리 및 연산자와 '필요' 표현식을 사용하여 GradientShape 개념이 'getGradientColor' 메서드가 있는 클래스에서만 충족될 수 있도록 합니다.

이제 GradientShape 개념을 만들었으니, 'computePixelColor'의 새로운 변형을 만들 수 있습니다.

이 함수 템플릿은 GradientShape 개념에 의해 제한되기 때문에 GradientCircle 클래스와 같은 그라디언트가 있는 모양 클래스에서만 작동합니다.

이제 모든 조각이 제자리에 있으므로, 그라디언트로 원을 렌더링해 볼 수 있습니다.

여기서 나는 GradientCircle을 렌더링하고 있어.

컴파일러가 '렌더' 함수 내에서 선택할 'computePixelColor'의 오버로드를 봅시다.

GradientCircle은 computePixelColor의 두 변형 모두에서 안전하게 사용할 수 있지만, 컴파일러는 첫 번째 과부하보다 더 구체적이기 때문에 GradientShape 개념으로 제한되는 과부하를 선택합니다.

컴파일러가 'computePixelColor'의 가장 일치하는 오버로드를 선택하기 때문에, 라이브러리를 테스트할 때 렌더링된 이 아름다운 그라디언트 원을 볼 수 있습니다.

굉장해!

이제 우리가 개념을 만드는 것에 대해 배운 것을 살펴봅시다.

기존 일반 코드에서 행동 요구 사항을 식별하여 개념을 만들 수 있습니다.

유형의 행동을 검증하기 위한 개념을 만들기 위해 요구 표현식을 사용해야 합니다.

또한 개념을 사용하여 일반 함수와 클래스의 더 구체적인 변형을 만들 수 있습니다.

우리는 이제 개념으로 일반적인 C++ 코드를 향상시키는 방법을 보았습니다.

개념을 지원하는 것 외에도, Xcode 14는 다른 C++20 기능에 대한 지원도 개선했다.

보다 구체적으로, 저는 Xcode 14에서 컴파일 타임 C++ 코드 평가에 대한 향상된 지원을 강조하고 싶습니다.

컴파일 시간 코드 평가는 C++ 코드의 변수 초기화 비용을 줄일 수 있기 때문에 유용합니다.

앱에 복잡한 초기화 시퀀스에 의존하는 많은 C++ 코드가 있는 경우 앱 실행 시간을 줄이는 데 도움이 될 수 있습니다.

그 외에도, 컴파일 타임 코드 평가는 컴파일 타임에 검증이 필요한 상수를 검증하는 데 도움이 될 수 있습니다.

이것은 코드가 실행되기 전에 버그를 잡는 데 도움이 될 수 있습니다.

C++에서 컴파일 타임 코드 평가를 어떻게 사용할 수 있는지 예를 들어 봅시다.

여기 제 모양 렌더링 라이브러리에서 색상 팔레트를 초기화하는 코드 스니펫이 있습니다.

그런 다음 이 라이브러리는 모양을 디스플레이로 렌더링하는 iOS 앱에서 사용됩니다.

팔레트의 각 색상은 색상의 HTML 16진수 코드로 문자열 리터럴을 구문 분석하여 초기화됩니다.

현재, 'fromHexCode' 함수는 배열을 초기화하는 동안 세 개의 문자열 리터럴을 구문 분석해야 합니다.

이와 같은 복잡한 지속적인 초기화 작업은 내가 많이 가지고 있다면 내 앱의 출시 시간에 측정 가능한 영향을 미칠 수 있다.

컴파일 타임 코드 평가를 사용하여 이 배열이 대신 일정한 색상 값으로 초기화되도록 할 수 있습니다.

이게 할 수 있다는 걸 보여줄게.

'Constexpr' 키워드는 C++에서 컴파일 타임 코드 평가를 가능하게 한다.

팔레트가 일정한 색상 배열인지 확인하기 위해 내 예제의 여러 곳에 추가해야 합니다.

먼저, 'fromHexCode' 함수에 'constexpr' 키워드를 추가해야 합니다.

컴파일러는 이제 컴파일 시간 초기화 시퀀스에서 사용될 때 컴파일 시간에 이 함수의 코드를 실행할 수 있습니다.

컴파일 타임에 평가 가능하기를 원할 때 C++ 함수를 'constexpr'로 만들어야 합니다.

컴파일러는 'constexpr' 초기화 시퀀스에서 사용할 때 오류를 표시하여 컴파일 시간에 해당 함수의 코드를 평가할 수 없는 경우 알려드릴 것입니다.

그러나, 컴파일 타임에 평가할 수 있는지 확인하기 위해 'constexpr'을 추가하기 전에 함수를 검사할 수도 있습니다.

fromHexCode를 살펴보고 이와 같은 함수가 컴파일 시간 코드 평가에 좋은 후보가 될 수 있는지 확인하는 방법을 알아봅시다.

이 함수는 if 문과 같은 많은 언어 구조와 비교 연산자 및 산술 연산자와 같은 원시 연산을 사용합니다.

이 모든 작업은 컴파일 타임에 평가될 수 있다.

또한, 이 함수는 다른 함수를 여러 번 호출한다; hexToInt.

나는 이미 hexToInt 함수에 'constexpr'에 주석을 달렸기 때문에, 이 함수에 대한 호출은 컴파일 타임에 평가할 수 있다.

전반적으로, fromHexCode에는 컴파일러가 컴파일 시간에 평가할 수 있어야 하는 코드가 포함되어 있는 것 같기 때문에, 컴파일 시간 초기화 순서로 진행하고 사용하는 것이 안전하다고 생각합니다.

fromHexCode가 컴파일 타임에 평가될 수 있는지 확인한 후, 'constexpr' 키워드를 'colorPalette' 변수 선언에 추가해야 합니다.

컴파일러는 이제 컴파일 시간에 이 배열의 전체 초기화 시퀀스를 평가할 것이라고 보장합니다.

더 구체적으로, 컴파일러는 fromHexCode 함수에 대한 각 호출을 평가할 것이다.

평가는 팔레트 이니셜라이저의 함수에 대한 원래 호출을 대체할 일정한 색상 값을 생성할 것이다.

fromHexCode에 대한 모든 호출이 이제 일정한 색상 값으로 대체되기 때문에, 'colorPalette' 변수는 이제 일정한 색상 값을 포함하는 배열 리터럴로 초기화되도록 보장됩니다.

이것은 이제 내 앱이 이 팔레트가 초기화될 때 색상 값을 구문 분석하는 데 추가 비용을 지불할 필요가 없다는 것을 의미합니다.

이것은 앱 내부의 C++ 라이브러리가 시작 시 해야 하는 작업의 양을 줄이기 때문에 내 앱의 출시 시간에 좋습니다.

C++ 변수가 상수 값으로 초기화되도록 하려면 C++ 변수를 'constexpr'로 만들어야 합니다.

Xcode 14는 실제로 컴파일 시간 평가를 위한 표준 라이브러리 지원을 크게 개선했다.

올해 우리는 컴파일 타임 코드 평가 중에 사용할 수 있는 여러 가지 표준 라이브러리 유형과 알고리즘에 'constexpr' 지원을 추가했습니다.

그 외에도, Xcode 14는 C++20 표준 지원을 크게 개선했다.

여기에 표시된 모든 기능은 이제 C++ 20 모드에서 사용할 수 있습니다.

아직 하지 않았다면 오늘 C++ 20 모드로 전환해야 합니다.

Xcode 프로젝트의 "C++ 언어 방언" 설정을 사용하여 C++ 20으로 업그레이드할 수 있습니다.

C++20으로 전환하면 코드에서 개념과 같은 기능을 사용할 수 있습니다.

C++20은 최소 배포 대상이 필요하지 않으므로, 현재 목표로 하고 있는 것과 동일한 OS 버전에 대한 코드를 배송할 수 있습니다.

오늘 C++20을 사용해 보세요.

고마워!

나머지 개발자 회의를 즐기세요.