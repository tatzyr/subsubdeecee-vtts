110404

♪ 기악 힙합 음악 ♪

안녕하세요, 저는 App Store의 상업 기술 옹호자인 David Wendland입니다.

오늘, 고객이 어떠한 조치도 취하지 않고 고객의 신규, 현재 및 과거 구매를 사전에 식별하여 앱이 어떻게 일류 경험을 제공할 수 있는지 보여드리겠습니다.

StoreKit 2와 원래 StoreKit으로 이 작업을 수행하는 방법을 다루므로 모든 고객을 위해 앱의 온보딩 경험을 최적화할 수 있습니다.

사전 예방적 인앱 구매 복원을 정의하는 것으로 시작하겠습니다.

즉, 고객이 앱을 실행하면 장치에서 쉽게 사용할 수 있는 데이터를 사용하여 신규 또는 기존 고객인지 확인하고 고객 조치를 요구하지 않고 "구매 복원" 버튼을 누르거나 비밀번호를 입력하지 않고 거래를 사전에 확인합니다.

이를 통해 앱 경험을 고객의 구매 내역과 상태에 맞게 조정할 수 있으므로 앱이 현재 고객을 위한 제품이나 서비스를 잠금 해제하거나, 앱이 새로운 고객에게 제공하는 최신 제품 상품 또는 이전 구독자를 위해 구독 제안을 제시하여 다시 받을 수 있습니다.

이것이 StoreKit을 사용하여 모든 장치에서 신규, 기존 및 과거 고객에 대한 앱의 경험을 자동으로 최적화하는 사전 복원에 관한 것입니다.

이 예시를 살펴봅시다.

여기 오션 저널 앱이 있습니다.

이것은 고객이 선택할 수 있는 몇 가지 다른 행동 촉구가 있는 일반적인 머천다이징 경험이다.

인앱 구매를 시도하고 FaceID와 같은 생체 인식으로 인증하거나, 앱 계정을 만든 경우 로그인하여 키체인을 사용하여 비밀번호를 입력하거나, 활성 구독자라고 생각되면 "구매 복원" 버튼을 사용할 수 있습니다.

새로운 장치의 활성 구독자의 경우, 어떤 옵션을 선택할지 아는 것이 항상 명확하지는 않습니다.

그리고 앱에서 쉽게 사용할 수 있는 데이터로, 이 경험은 사전 예방적인 인앱 구매 복원 모범 사례로 간소화될 수 있습니다.

그래서, 내가 새 장치에서 이 앱을 실행했지만 이미 활성 구독자였다면, 실행 시, 앱은 내 조치 없이 자동으로 내 서비스를 능동적으로 복원할 것이다.

그래서 여기서 앱은 내 프로 구독을 인식하고 내가 가장 좋아하는 해변을 로드했고, 서핑 조건을 완료하고 라이브 캠 기능을 활성화했다.

이 경험은 당신의 앱을 다른 앱과 차별화하며 iOS 15 및 이후 버전의 StoreKit 2로 이 작업을 수행하는 방법을 다룰 것입니다.

또한, 앱이 이전 버전의 iOS를 지원하는 경우, 원래 StoreKit과 verifyReceipt 엔드포인트로 동일한 훌륭한 경험을 만드는 방법을 다룰 것입니다.

그 배경으로, 여기 내가 다룰 것이 있다.

먼저, 앱이 StoreKit을 사용한 고객의 인앱 구매를 기반으로 개인화된 경험을 생성하는 데 사용하는 핵심 고객 제품 상태를 자세히 설명하겠습니다.

그런 다음 SK 데모 앱을 사용하여 샘플 코드로 완성된 StoreKit 2를 사용하여 구현하는 단계를 검토하겠습니다.

각 인앱 구매 유형, 핵심 고객 제품 상태를 살펴보고, 개인화된 온보딩 경험의 몇 가지 예를 검토해 봅시다.

우선, 사전 예방적 복원에 적용되는 인앱 구매 유형은 비소모품, 비갱신 구독 및 자동 갱신 구독으로, 모두 고객의 거래 내역에 지속되며 StoreKit에서 항상 사용할 수 있기 때문입니다.

따라서 앱은 고객별로 각 제품 또는 구독 그룹에 대한 구매 상태를 식별할 수 있습니다.

비갱신 및 자동 갱신 구독의 경우, 고객 제품 상태를 검토할 때 "구독"이라는 용어를 사용하여 둘 다 참조할 것입니다.

다음은 앱이 개인화할 수 있는 세 가지 핵심 상태입니다.

심층적인 신규 고객을 검토해 봅시다.

이 상태는 현재 또는 과거의 인앱 구매 거래가 없는 로그인된 App Store Apple ID를 나타냅니다.

이 상태는 일반적으로 앱의 기본 머천다이징 경험으로 사용됩니다.

우리의 오션 저널 앱은 한 달 무료 평가판으로 월간 및 연간 구독을 상품화하고 있습니다.

우리의 두 번째 핵심 상태를 살펴보면, 우리는 구매 및 활성 구독자를 확보했습니다.

이 상태에서, 고객은 활성 거래를 가지고 있으며 당신의 앱은 고객에게 구매한 제품이나 서비스에 대한 접근 권한을 부여할 의무가 있습니다.

여기서, 우리의 오션 저널 앱은 프리미엄 라이브 비치 캠으로 고객이 선호하는 해변을 즉시 제공합니다.

서비스가 사전에 복원되었기 때문에 구매 버튼이 보이지 않습니다.

구매한 각 제품 또는 활성 구독에 대해, 거래에는 고객의 Apple ID와 매장에 대해 지속되는 정적이고 고유한 원래 거래 ID가 있습니다.

고객의 거래 상태를 유지하려면, 원래 거래 ID를 시스템의 계정과 연결하세요.

익명의 계정이거나 사용자가 시스템으로 만든 계정일 수 있습니다.

원래 거래 ID를 아는 것은 App Store 서버 알림의 힘을 활용할 때 매우 중요하므로 서버가 거래 상태를 최신 상태로 유지할 수 있습니다.

강조해야 할 한 가지 시나리오는 고객의 구독이 자동 갱신에 실패했을 때이며, 따라서 청구 재시도 상태라고 부르는 것으로, 최대 60일 동안 구독을 복구하려고 시도합니다.

App Store Connect에서 청구 유예 기간 기능을 선택한 경우, 유예 기간으로 청구 재시도하는 구독자는 구독을 복구하려고 시도하는 동안 구독 서비스에 계속 액세스할 수 있습니다.

그리고 그들이 여전히 당신의 서비스에 접근할 수 있는 동안, 지불 문제를 해결하기 위한 간단한 행동 촉구를 제시해야 합니다.

청구 재시도 및 청구 유예 기간에 대해 자세히 알아보려면, 비자발적 구독자 손실 감소에 대한 세션 링크와 리소스를 확인하세요.

최종 핵심 상태는 비활성 구매 또는 비활성 구독자입니다.

이 상태는 이전에 인앱 구매를 했지만 만료 또는 취소로 인해 더 이상 해당 제품이나 서비스를 받을 자격이 없는 고객을 나타냅니다.

이러한 거래는 지속적이며 장치와 플랫폼에서 상태를 유지할 수 있는 원본 거래 ID가 포함되어 있습니다.

구독의 경우, 비활성은 만료일에 따라 결정됩니다.

그리고 모든 인앱 구매 유형의 경우, 해지 날짜가 있으면 비활성 상태일 수 있습니다.

이것은 거래가 환불되었거나 가족 공유를 통해 부여된 접근이 취소되었을 때 발생합니다.

만료 또는 취소로 인해 비활성 구독자의 경우, 그들을 되찾기 위해 구독 제안을 제시하는 것을 고려하십시오.

그리고 청구 재시도 상태에 있는 사람들을 위해, 지불 세부 사항을 해결하기 위해 동일한 행동 촉구를 제시하는 것을 잊지 마세요.

검토에서, 다음은 앱이 앱 내 구매를 사전에 복원하고 고객에게 앱의 경험을 맞춤화하는 데 사용할 세 가지 핵심 고객 제품 상태입니다.

이러한 경험이 오션 저널 앱과 나란히 어떻게 보이는지 봅시다.

새로운 고객들은 당신의 최신 제품 제안과 소개 제안을 보게 될 것입니다.

앱이 모든 장치에서 제품과 서비스에 대한 액세스를 간소화했기 때문에 현재 활성 고객은 작동한다고 느낄 것입니다.

그리고 비활성 구독자의 경우, 제안 코드 또는 프로모션 제안을 사용하여 최신 윈백 제안을 제시할 수 있습니다.

좋아요, 우리는 세 가지 핵심 고객 제품 상태를 다루었고, 이러한 주들만 지원하는 것이 고객에게 큰 승리가 되는 방법을 다루었습니다.

하지만 물론, 그 경험을 더 발전시킬 기회가 있다.

앱은 제품 제공, 비즈니스 모델, 정책 및 우선 순위에 맞게 고객 경험을 확장하거나 개선할 수 있습니다.

하지만 앱에 사전 복원을 구현할 준비를 할 때 고려해야 할 몇 가지 사항이 있습니다.

여러 제품이나 구독 그룹을 지원하는 경우, 고객의 상태는 각 제품과 각 구독 그룹에 대해 결정됩니다.

따라서, 하이브리드 주 또는 기타 종속성을 설명해야 할 수도 있습니다.

오프 플랫폼 활동과 그것이 고객의 제품 상태에 어떻게 영향을 미치는지 고려하십시오.

그리고 모든 인앱 구매 유형에 대해 서버 대 서버 상태를 유지하는 데 중요하기 때문에 App Store 서버 알림을 확인하십시오.

그리고 버전 2에서는 새로운 알림 유형과 하위 유형이 거의 실시간으로 서버로 안전하게 전송되는 28개의 고유한 이벤트를 지원합니다.

세션에서 버전 2로 통합 또는 마이그레이션에 대해 자세히 알아보세요, "인앱 구매 통합 및 마이그레이션을 살펴보세요."

알렉스와 가브리엘은 또한 StoreKit 2와 원래 StoreKit 프레임워크와의 호환성과 모범 사례를 다룹니다.

우리는 고객 제품 상태를 통해 지원하고 그 경험이 당신의 고객에게 무엇이 될 수 있는지에 대해 이야기했습니다.

이제 구현 세부 사항을 살펴봅시다.

StoreKit 2를 사용하여 사전 복원으로 업데이트한 SK 데모 앱을 사용할 것입니다.

이 세션에서 SK 데모 앱을 다운로드할 수 있습니다.

활성 인앱 구매가 없는 신규 고객을 위한 SK 데모의 기본 경험을 검토해 봅시다.

제품을 보려면, "쇼핑" 버튼을 탭하세요. 위에는 비소모성 인앱 구매로 사용 가능한 자동차 재고가 있습니다.

그리고 나서 우리는 고객이 선택할 수 있는 세 가지 수준의 서비스를 제공하는 월간 자동 갱신 구독으로 내비게이션 서비스를 제공합니다.

그리고 아래에는 일회성 액세스를 제공하는 비갱신 구독 옵션이 있습니다.

이것은 제품을 구매하지 않았을 때 우리 앱의 새로운 고객 경험을 다룹니다.

이제 우리 앱이 고객이 현재 또는 과거 구매를 했는지 어떻게 결정할 수 있는지 살펴봅시다.

앱이 실행되는 즉시 세 단계를 실행해야 합니다.

가장 중요한 것은 "구매" 버튼이 고객에게 판매되기 전에 이러한 단계가 완료된다는 것입니다.

첫 번째 단계는 앱이 App Store에서 거래를 듣기 시작해야 한다는 것입니다.

이것은 가족 공유 구매 요청, 코드 상환, 구독 자동 갱신 또는 구매가 중단될 때와 같은 기능에서 언제든지 거래가 나타날 수 있기 때문에 App Store의 모범 사례입니다.

또한, 앱은 환불로 인해 액세스가 손실되거나 가족 공유를 통해 더 이상 공유되지 않는 취소된 거래를 받을 수 있습니다.

이것은 액세스가 이미 허용되고 상태가 활성에서 비활성으로 이동할 때 후속 앱 출시에 더 많이 적용될 것이다.

거래가 발견되면, 그것들은 미완성 거래로 간주되며, 검증되고, 고객에게 전달되고, 완료된 것으로 표시되어야 합니다.

이것은 당신의 앱이 어떤 거래도 놓치지 않고 훌륭한 고객 경험을 제공할 수 있도록 보장합니다.

이제 SK 데모 앱이 StoreKit 2에서 거래를 어떻게 듣는지 살펴봅시다.

여기서 저는 listenForTransactions 기능을 사용하고 있습니다.

그것은 로그인한 App Store 고객을 위한 거래에 대한 미완성 거래 또는 업데이트를 반환할 것이다.

발견된 모든 거래의 경우, 여기에서 StoreKit 2는 이러한 거래의 진위를 확인할 것입니다.

그리고 나서, 내 앱이 콘텐츠를 전달하거나, 액세스 권한을 부여하거나, 고객 제품 상태를 업데이트한 후, 구매가 전달되었음을 App Store에 표시하기 위해 거래를 완료할 것입니다.

거래가 완료되면, 더 이상 StoreKit을 통해 모든 장치에서 앱으로 반환되지 않습니다.

그 첫 번째 단계는 모든 앱에 중요하며 앞으로 모든 앱 출시에서 발생할 것이다.

2단계는 고객 제품 상태를 결정하는 것이며, 이는 currentEntitlements를 사용하여 고객의 활성 거래를 사전에 요청함으로써 이루어집니다.

그리고 특히 자동 갱신 구독의 경우, 취소, 청구 재시도 또는 보류 중인 다운그레이드와 같은 고객의 갱신 상태를 설명하기 위해 Product.SubscriptionInfo.RenewalState를 추가로 사용해야 합니다.

SK 데모 앱을 살펴보고 우리가 이것을 어떻게 달성하는지 봅시다.

이것은 각 지속적인 인앱 구매 유형에 대한 고객의 제품 상태를 추적하는 updateCustomerProductStatus 기능으로 시작합니다.

그런 다음 StoreKit 2의 현재 자격 방법을 사용하여 각 구매 유형을 반복합니다.

이것은 고객이 받을 수 있는 제품에 대한 거래를 반환합니다.

그리고 우리는 제품 유형별로 이러한 거래를 기록합니다.

여기, 우리의 비소모품 제품을 위해, 그리고 여기 우리의 비갱신 구독 제품을 위해.

그들이 활성 구독자인지 비활성 구독자인지 결정하기 위해, 비갱신 구독의 만료일을 계산하기 위해 추가 로직을 추가했습니다.

그리고 마지막으로, 나는 활성 자동 갱신 구독을 확인하고, 그 상태를 구독 그룹에 적용할 것이다.

청구 재시도, 만료 및 취소와 같은 비활성 상태를 설명하기 위해 가변 구독 그룹 상태는 Product.SubscriptionInfo.RenewalState를 사용합니다. 이제 사용자의 거래를 검색하고 각 제품 또는 구독 그룹의 고객 상태를 결정했기 때문에, 우리 앱은 다양한 사용 사례에 대한 앱 경험을 개인화할 수 있는 논리를 가지고 있습니다.

SK 데모 앱 소스 코드를 살펴봅시다.

세 가지 인앱 구매 제품 유형 모두에 대해 활성 거래가 결정되지 않으면, 고객은 이전에 검토한 기본 새로운 고객 경험을 보게 될 것이며, 여기서 그들은 우리의 "쇼핑" 페이지에 대한 간단한 행동 촉구를 갖게 될 것입니다.

고객이 활성 구매를 한 경우, 앱 실행 시 구매를 확인하고 그에 따라 모든 제품에서 "구매" 버튼을 업데이트할 것입니다.

그래서 여기서 비소모품의 경우, 우리는 그들이 구매한 것을 제시하고 앱은 구매한 비소모품을 보여주거나, 앱은 고객이 상점 경험을 방문할 수 있도록 행동 촉구를 제공합니다.

활성 제품의 경우, 고객이 비갱신 구독 및 자동 갱신 구독을 위한 내비게이션 서비스의 활성 구독자인 경우 여기서 처리합니다.

그리고 마지막 부분에서, 우리는 비활성 구독자를 설명한다.

구독이 만료되었거나, 취소되었거나, 청구 재시도 상태에 있는 사람들.

좋아, 이제 SK 데모 앱으로 가자.

우리는 비소모성 및 자동 갱신 구독 모두에 대해 활성 고객을 시뮬레이션하고 싶습니다.

따라서 경주용 자동차를 구입하고 프로 내비게이션을 구독하면, 데모 앱은 앱이 해당 구매가 성공적이고, 확인되었으며, 활성화되었음을 나타내기 위해 녹색 체크 표시를 적용할 것입니다.

이러한 구매로, 비소모품에 대한 내 고객 제품 상태가 구매된다.

그리고 우리의 구독을 위해, 저는 활성 구독자입니다.

이제, 새 장치에 앱을 설치하면, SK 데모 앱을 처음 시작할 때, 1, 2, 3단계를 능동적으로 수행할 것입니다.

여기서 당신은 우리의 데모 앱이 내 두 구매에 대한 액세스를 능동적으로 복원한 것을 볼 수 있습니다.

이것은 데모 앱이기 때문에, 그것이 배달되는 제품의 범위이다.

하지만 앱에서, 이 과정은 이러한 활성 고객이 이미 소유하고 있는 제품을 구매할 수 있도록 보장하지 않으며, 해당 제품과 서비스가 자동으로 활성화되도록 할 것입니다.

당신의 현재 고객들에게, 이것은 훌륭합니다.

고객이 로그인하거나 "구매 복원"을 탭할 필요가 없습니다.

그건 그냥 작동했어.

당신의 앱은 API와 데이터를 쉽게 사용할 수 있습니다.

그래서 우리는 StoreKit 2로 이것을 하기 위한 세 단계를 다루었습니다.

이제 StoreKit 2의 힘을 활용할 수 없는 이전 버전의 iOS에서 고객에게 동일한 경험을 구현하는 방법에 대해 논의하고 싶습니다.

원래 StoreKit을 사용하면 StoreKit 2와 동일한 단계를 수행하여 iOS 7 이상에서 인앱 구매를 사전에 복원하여 고객 제품 상태를 결정합니다.

이렇게 하려면 서버가 verifyReceipt 엔드포인트를 사용하여 고객의 제품 상태를 결정하기 위해 최신 거래를 검증하고 검색해야 합니다.

앱 영수증은 App Store에서 앱을 설치할 때 장치에 표시됩니다.

하지만 샌드박스나 TestFlight로 테스트할 때, 앱 영수증은 인앱 구매가 완료되거나 복원된 후에만 존재한다는 것을 명심하세요.

앱이 앱 영수증을 찾지 못하면, 이것은 샌드박스에서만 발생해야 하며 앱은 이 시나리오를 인앱 구매가 없는 새로운 고객과 동일하게 고려할 수 있습니다.

과거에 생성된 앱 영수증은 App Store에서 최신 거래를 검색하기에 충분합니다.

따라서, "복원 구매" 또는 영수증 새로 고침과 같은 고객 조치는 필요하지 않습니다.

비소모품, 비갱신 구독 및 자동 갱신 구독에 대한 거래를 받으려면 영수증 확인 요청에 공유 비밀을 포함하십시오.

우리가 이전에 검토한 세 가지 실행 단계를 되돌아봅시다.

차이점은 고객의 제품 상태를 식별하는 2단계에 있습니다.

고객 제품 상태를 결정하는 방법은 장치의 앱 영수증으로 시작되며, 차례로 서버는 App Store verifyReceipt 엔드포인트로 검증됩니다.

이 과정을 살펴봅시다.

먼저, 앱 영수증을 검색해야 하며, 개발자 문서의 이 샘플에서 볼 수 있듯이 appStoreReceiptURL 속성을 사용하고 있는지 확인해야 합니다.

앱 영수증과 함께, 이것이 장치에서 서버와 App Store로 어떻게 전송되는지 봅시다.

장치의 앱은 여기 왼쪽에 있습니다.

먼저 앱 영수증을 검색하여 서버로 보낸 다음 App Store verifyReceipt 엔드포인트로 유효성을 검사합니다.

그 응답에서, 당신은 고객 제품 상태를 결정하고, 그 상태를 당신의 앱으로 보낼 것입니다.

고객 제품 상태를 결정하기 위해, 우리는 WWDC2020의 자격 엔진을 사용했습니다.

비소모품 및 비갱신 구독을 지원하도록 업데이트되었으며, 이제 인앱 구매가 없을 때 새로운 고객 상태를 처리합니다.

자격 엔진 사용에 대해 자세히 알아보려면, "구독을 위한 건축" 세션을 확인하고 샘플 프로젝트를 다운로드하는 것이 좋습니다.

이 비디오의 리소스를 통해 이 세션에 대한 링크와 더 많은 것을 찾을 수 있습니다.

그것은 앱이 서버에서 고객 제품 상태를 받는 2단계를 완료합니다.

이제 앱은 StoreKit 2와 원래 StoreKit 프레임워크를 사용하여 출시 즉시 앱 경험을 개인화할 것입니다.

나는 몇 가지 최종 모범 사례를 공유하고 싶다.

먼저, 앱 내에서 "구매 복원" 버튼을 계속 제공하세요.

자주 사용되지는 않지만, 고객에게 문제가 발생하거나 고객이 다른 Apple ID를 사용하는 경우 앱이 Apple ID의 거래를 복원하도록 강제할 수 있는 기회를 제공합니다.

앱이 먼저 장치에서 고객의 인앱 구매를 사전에 복원할 때, 고객 제품 상태를 결정하는 데 도움이 되도록 앱을 최적화하고 데이터를 안전하게 저장하는 것이 좋습니다.

CloudKit은 유연성, 보안 및 고객의 장치에서 동기화할 수 있는 기능으로 고려해야 할 기능입니다.

StoreKit을 사용할 때 구현을 테스트하는 것이 중요합니다.

그리고 StoreKit 2를 사용하면 샌드박스, TestFlight 및 Xcode StoreKit 테스트를 통해 사전 복원 구현을 테스트할 수 있습니다.

그리고 원래 StoreKit을 사용하는 경우, 앱이 App Store에서 설치될 때 항상 존재하는 동안 Sandbox와 TestFlight에서 테스트할 때 앱 영수증이 없을 수 있다는 것을 기억하는 것이 중요합니다.

앱 영수증이 없는 경우, 앱이 기본 새로운 고객 경험을 사용하고 구매 복원 버튼을 쉽게 사용할 수 있도록 하는 것이 좋습니다.

결론적으로, 고객 조치, 탭 또는 인증 없이 구매를 사전에 확인하도록 앱을 업데이트하십시오.

앱이 신규, 활성 및 비활성 고객의 제품 상태에 맞게 출시 즉시 고객의 경험을 조정할 수 있도록 하십시오.

App Store 서버 알림 버전 2를 구현하여 모든 인앱 구매 유형에 대해 모든 고객의 거래, 서버 대 서버의 상태를 유지하십시오.

이를 통해 백엔드는 환불 또는 취소된 거래 또는 구독 갱신, 청구 재시도 및 만료와 같은 거래에서 발생한 모든 변경 사항을 거의 실시간으로 알 수 있습니다.

시청해 주셔서 감사드리며, Dani와 Ian이 StoreKit, 서버 API 및 서버 알림 버전 2에 대한 모든 훌륭한 업데이트에 대해 알려줄 이 추가 세션인 "인앱 구매의 새로운 기능"을 확인하십시오.

고마워. 몸조심해.

♪ ♪