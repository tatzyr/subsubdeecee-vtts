10059

샘 라자루스: 안녕하세요, 제 이름은 샘이고, 저는 SwiftUI 팀의 엔지니어입니다.

SwiftUI를 설계할 때, 우리는 항상 명확하게 정의된 원칙에 따라 결정을 내리기 위해 노력해 왔으며, 오늘 우리는 그 중 하나를 강조할 것입니다: 점진적인 공개.

SwiftUI 팀에서, 우리는 새로운 API에 대해 생각하고 구축하는 데 많은 시간을 할애하지만, 당신이 깨닫지 못한 것은 재사용 가능한 구성 요소나 추상화를 구축하는 순간, 당신도 API 디자이너라는 것입니다.

이 강연에서, 우리는 디자인 프로세스의 커튼을 벗겨내고 점진적인 공개에 대해 배운 것을 공유하고 싶었기 때문에, 다음에 재사용 가능한 구성 요소 또는 추상화를 만들 때 도구 벨트에 새로운 도구가 있습니다.

점진적인 공개가 실제로 무엇을 의미하는지 이야기하는 것으로 시작합시다.

알고 보니, 그것은 API의 디자인에만 있는 것이 아니다!

사실, 가장 일반적인 macOS UI 중 하나인 저장 대화 상자에서 작동하는 것을 볼 수 있습니다.

저장 대화상자가 처음 표시되면, 기본 위치가 이미 채워져 있습니다.

또한, 대화상자에는 몇 가지 일반적인 위치가 있는 드롭다운이 표시되므로, 선택할 수 있는 위치에 쉽게 접근할 수 있습니다.

그리고 마지막으로, 올바른 경로를 찾기 위해 파일 시스템을 탐색해야 하는 경우, 대화상자를 확장하여 더 복잡하지만 더 강력한 UI를 표시할 수 있습니다.

여기에는 필요할 때 드러날 수 있는 다양한 복잡성 층이 있다.

이것은 우리가 API로 제공하고자 하는 것과 같은 경험이다.

멋진 UI 경험을 제공하는 것과 동등한 코드는 API를 사용하기 좋게 만들고 있습니다.

개발자로서, 우리는 우리가 그것을 쓰는 곳의 관점에서 코드를 보는 데 익숙하다: 선언 사이트.

하지만 코드를 사용하기 좋게 만들기 위해, 우리는 그것을 다른 관점에서 봐야 합니다: 코드가 실제로 사용되는 곳, 또는 우리가 콜 사이트라고 부르는 것.

그렇다면 점진적인 공개는 호출 사이트의 복잡성이 사용 사례의 복잡성에 따라 커지도록 API를 설계하고 있다.

이상적인 API는 간단하고 접근하기 쉽지만 강력한 사용 사례를 수용할 수 있다.

이것은 개발자들에게 실질적인 이점이 있다.

첫째, 첫 번째 빌드 및 실행 시간을 최소화하여 API를 빠르게 사용할 수 있습니다.

또한 코드의 학습 곡선을 낮추어 모든 사용 사례와 관련이 없는 개념에 의해 API가 수렁에 빠지는 것을 방지합니다.

마지막으로, 그것은 빡빡한 피드백 루프를 만든다.

점진적인 공개를 수용하는 API를 사용하면 각 단계에서 만든 것을 볼 수 있습니다.

이 모든 것들이 함께 앱을 구축하는 것은 하나의 대규모 선행 투자가 아닌 빠른 개선의 주기를 만든다.

그래서 점진적인 공개는 유용한 지침이지만, 그들이 그 원칙을 받아들일 수 있도록 특정 API를 어떻게 설계할 수 있을까요?

SwiftUI 팀에서, 우리는 일반적인 사용 사례를 고려하는 것으로 시작합니다.

점진적으로 기능을 공개하기 위해, 우리는 간단한 사례가 무엇인지 식별해야 한다.

우리는 또한 지능형 디폴트를 제공하기 위해 노력하므로, 일반적인 사례는 필요한 것만 지정할 수 있습니다.

다음으로, 우리는 통화 사이트를 최적화하여 통화 사이트의 모든 캐릭터가 목적을 갖도록 하는 것을 목표로 합니다.

그리고 마지막으로, 우리는 가능성을 열거하기보다는 조각을 구성하도록 API를 설계합니다.

일반적인 사용 사례를 고려하는 방법부터 시작하여 SwiftUI의 몇 가지 예를 살펴보겠습니다.

SwiftUI가 이것을 특히 잘 하는 곳 중 하나는 라벨이다.

예를 들어, 버튼을 만들 때, 버튼에 대한 라벨을 제공해야 합니다.

대부분의 경우, 그 라벨은 버튼의 목적을 설명하는 텍스트일 뿐이며, SwiftUI는 그것을 철자하는 간결한 방법을 제공합니다.

하지만 버튼을 더 사용자 정의하고 싶다면, SwiftUI는 또 다른 과부하를 제공합니다.

라벨로 임의적인 견해를 취하는 것.

이를 통해 이 간단한 제어에서 복잡한 기능을 구축할 수 있습니다.

하지만 이 API는 99%의 일반적인 사용 사례를 신중하게 고려하기 때문에, 간단한 버전만 있으면 됩니다.

이 라벨 패턴은 SwiftUI의 모든 곳에 나타난다.

그리고 내가 모든 곳에서 말할 때, 나는 정말 진심이야.

그래서 일반적인 사용 사례를 고려하는 것은 우리가 전체 프레임워크에서 하는 일이다.

다음으로, 지능형 기본값을 제공하는 것을 살펴봅시다.

일반적인 사용 사례를 간소화하기 위해, 우리는 명시적으로 지정하지 않은 모든 것에 대해 지능형 기본값을 제공해야 합니다.

그리고 모든 SwiftUI: Text에서 가장 일반적으로 사용되는 API 중 하나보다 더 좋은 예는 없습니다.

텍스트는 지능적인 기본값의 좋은 예이기 때문에 아마도 지정할 필요가 없는 모든 것에 대해 생각하지 않고 이와 같은 코드를 수백 번 작성했을 것입니다.

이 코드만으로 SwiftUI는 환경 로케일로 앱 번들에서 현지화된 문자열을 찾아 텍스트를 현지화합니다.

그것은 상자에서 꺼내자마자 어두운 모드를 지원하는 현재 색 구성표에 자동으로 적응할 것이다.

그리고 현재 접근성 동적 유형 크기에 따라 텍스트를 자동으로 확대 또는 축소합니다.

우리는 전에 이러한 행동에 대해 이야기했지만, 텍스트는 그보다 무대 뒤에서 훨씬 더 많은 일을 하고 있다.

예를 들어, 두 개의 텍스트를 서로 옆에 있는 스택에 넣을 때, 텍스트 사이의 공간은 현재 컨텍스트에서 텍스트의 올바른 줄 간격으로 자동으로 조정됩니다.

그 모든 동작은 수동으로 지정할 수 있지만, SwiftUI의 지능형 기본값은 사용 사례와 관련이 없을 때 통화 사이트에 나타나지 않는다는 것을 의미합니다.

텍스트는 가장 간단한 경우가 매우 적은 API의 예이지만, 지능형 기본값은 모든 종류의 통화 사이트에 적용됩니다.

예를 들어, 도구 모음을 가져가세요.

여기, 우리는 많은 버튼이 있는 도구 모음이 있습니다.

위치를 명시적으로 지정할 필요 없이, 도구 모음 버튼은 플랫폼 규칙에 따라 배치됩니다.

macOS에서는 도구 모음의 앞쪽 가장자리에 나타나지만, iOS에서는 뒤쪽 가장자리에서 시작하여 탐색 모음에 나타납니다.

그리고 마지막으로, watchOS에서는 내비게이션 바 아래에 고정된 첫 번째 항목만 나타납니다.

이것은 대부분의 경우에 잘 작동하지만, 더 많은 제어가 필요한 경우, 항목의 배치를 명시적으로 지정하기 위해 추가 API를 제공합니다.

다시 말하지만, 필요한 경우 사용자 정의가 있지만, 지능형 기본값은 대부분의 경우를 처리합니다.

일반적인 사용 사례를 고려하고 지능형 기본값을 제공하는 것은 정말 훌륭한 경험을 창출하지만, 이러한 API를 사용하는 것이 투박하거나 정제되지 않은 것처럼 느껴지면 전체 효과를 망칠 수 있습니다.

그것은 우리를 우리의 마지막 전략으로 이끈다: 통화 사이트를 최적화한다.

그리고 그것을 위해, 다른 API를 살펴봅시다: 테이블.

다중 열 테이블은 매우 기능이 풍부한 컨트롤이다.

구성해야 할 것이 많고 기능이 많다.

하지만 대다수의 테이블은 훨씬 간단하고 그 모든 기능이 필요하지 않습니다.

우리는 테이블이 더 복잡한 행동을 할 수 있기를 원하며, 가장 장황한 형식으로 그것을 가지고 있다.

그것은 정렬, 풍부한 셀 콘텐츠가 있는 여러 열, 분할된 행 등을 지원합니다.

하지만 우리는 또한 더 일반적인 경우에 훌륭한 경험을 제공하고 싶기 때문에, 이 간단한 테이블에 대해 완전히 지정된 코드를 살펴보고 호출 사이트를 어떻게 최적화할 수 있는지 봅시다.

먼저, 이 예시를 분해해 봅시다.

테이블은 각 행에 대한 데이터를 생성하는 방법을 지정하는 것으로 시작합니다.

여기, 나는 우리가 현재 읽고 있는 각 책을 반복하고 그 책들 각각에 대한 테이블 행을 만들고 있다.

다음으로, 각 행의 데이터에서 열을 채우는 방법을 지정합니다.

여기서, 저는 제목 열과 저자 열을 만듭니다.

또한 사용자가 테이블 열 헤더를 클릭할 때 테이블이 정렬을 변경할 수 있도록 정렬 순서에 바인딩이 필요합니다.

마지막으로, 정렬 순서가 바뀔 때마다 테이블의 데이터를 다시 정렬하는 코드를 추가했습니다.

그것은 많은 정보이므로, 점진적인 공개를 수용하기 위해 이 통화 사이트를 최적화하는 방법을 살펴봅시다.

즉시 눈에 띄는 일반적인 사용 사례 중 하나는 행과 관련이 있다.

대부분의 경우, 행 필드는 이 예에서와 똑같이 보일 것이다: 컬렉션 위에 ForEach, 각 항목에 대한 테이블 행을 제공한다.

개발자는 이 모든 것을 스스로 반복할 필요가 없으므로, SwiftUI는 후드 아래에서 이를 처리하는 편리함을 제공합니다.

컬렉션을 테이블에 직접 전달함으로써, ForEach 동작은 무대 뒤에서 제공될 수 있으며, 우리의 통화 사이트를 대폭 단순화할 수 있지만, 이것은 여전히 더 단순화될 수 있다.

다른 일반적인 사용 사례는 무엇인가요?

음, 대부분의 경우, 표에 표시하고 싶은 값 중 하나가 문자열일 때, 텍스트를 사용하여 열에 표시할 것입니다.

우리는 이 경우에도 통화 사이트를 최적화합니다.

값 키 경로가 문자열을 가리킬 때마다, 우리는 TableColumn과 관련된 뷰를 생략할 수 있습니다.

그것은 또 다른 중요한 단순화이지만, 여전히 최적화해야 할 것이 더 있습니다!

콜 사이트에는 모든 테이블이 걱정할 필요가 없는 정보가 있습니다: 정렬 순서.

테이블의 가장 간단한 사용 사례는 정렬에 전혀 신경 쓰지 않습니다!

그래서 우리는 정렬과 관련이 없는 테이블 버전을 제공합니다.

그리고 이것은 우리를 마지막 반복으로 이끈다. 훨씬 더 간단해!

이 콜 사이트의 모든 캐릭터는 명확한 목적을 가지고 있으며, 우리는 매 단계마다 두 가지 주요 질문을 함으로써 여기에 왔습니다: "우리가 편의를 구축해야 하는 가장 일반적인 사용 사례는 무엇입니까?"

그리고 "항상 요구되어야 하는 필수 정보는 무엇인가요?"

이러한 안내 질문은 통화 사이트를 최적화하는 데 도움이 되지만, 신중하게 적용해야 합니다.

API에 대한 그들의 영향을 생각하지 않는다면, 그들은 당신을 잘못된 길로 이끌 수 있습니다.

그것은 우리를 최종 전략으로 이끈다: 작성, 열거하지 마세요.

그리고 이것을 설명하기 위해, SwiftUI의 레이아웃 시스템의 일부인 스택, 특히 HStack의 디자인에 대해 이야기해 봅시다.

먼저, HStack에 필수적인 정보가 무엇인지 생각해 봅시다.

음, 어떤 콘텐츠가 스택에 있어야 하는지 그리고 그 콘텐츠가 스택 내에서 어떻게 배열되어야 하는지 알아야 합니다.

우리는 이미 HStack의 내용을 지정할 뷰 빌더가 있으므로, 배열에 집중합시다.

우리가 강조한 안내 질문으로 돌아가서, Hstack에서 요소를 배열할 때 가장 일반적인 사용 사례는 무엇입니까?

음, 가끔 나는 앞쪽에서 시작하여 상자를 차례로 보여주는 이와 같은 스택을 보여주고 싶다.

또 다른 일반적인 경우는 요소를 중심에 두고 싶다는 것이다.

그리고 마지막으로, 나는 요소를 후행 가장자리에 맞추고 싶을 수도 있다.

VStack은 이미 이와 유사한 경우인 정렬을 가진 API를 가지고 있으므로 스택 내의 요소 배열에 대해 유사한 열거형을 만드는 것이 유혹적으로 보일 수 있습니다.

이것은 우리가 언급한 모든 사례를 지원합니다!

HStack의 배열을 지정함으로써, 나는 내가 원하는 것에 따라 선행, 후행 또는 중심 배열을 선택할 수 있었다.

하지만 이제 요소를 고르게 간격을 두거나 요소 사이에만 간격을 두거나 마지막 요소 앞에만 공간을 두려면 어떻게 해야 하나요?

이건 정말 지저분해지고 있어!

하지만 더 중요한 것은, 그것은 지속 불가능하다는 것이다.

나는 우리가 원하는 모든 행동에 대해 열거형 사례를 추가해야 하며, 우리는 모든 유용한 사례를 생각하지 못할 수도 있다!

편의를 제공하기보다는 일반적인 사례를 열거하는 자신을 발견했을 때, API를 솔루션을 구축할 수 있는 컴포저블 조각으로 분해해 보세요: 작성, 열거하지 마세요.

스택의 경우, SwiftUI는 스페이서를 제공하고 스택의 요소로 구성하여 우리가 열거한 모든 간격 체계를 구축할 수 있으며, 이것이 오늘날 우리가 가지고 있는 API에 도달한 방법입니다.

여기서 점진적인 공개를 위한 최고의 경험을 설계하는 것은 단지 통화 사이트를 최소화하는 것이 아니라, 그 통화 사이트가 모든 경우를 처리하기 위해 어떻게 확장되어야 하는지에 대한 신중한 생각을 포함했다: 이 경우, 구성을 통해.

코드를 직접 작성할 때, 당신이 만드는 구성 요소에 대해 같은 종류의 신중한 고려 사항을 적용하는 것이 매우 도움이 될 수 있습니다.

그리고 요약하자면, 그것은 일반적인 사용 사례를 고려하는 것으로 시작한다.

점진적 공개를 적용함으로써, 당신이 작성하는 코드는 가장 일반적인 사용 사례에서 시간을 절약할 수 있습니다.

지능형 기본값은 일반적인 경우의 세부 사항에 대해 생각할 필요가 없다는 것을 의미합니다.

구축한 통화 사이트를 최적화하기 위해 작업하면 빠르게 반복할 수 있습니다.

그리고 마지막으로, 구성을 활용하면 모든 사용 사례를 수용할 수 있을 만큼 유연한 API를 구축할 수 있습니다.

그리고 당신은 API 디자이너이기 때문에, 다른 사람을 위해 설계되었든, 아니면 그냥 사용하기 위해 설계되었든, 매일 작성하는 코드에 이러한 교훈을 적용할 수 있습니다.

봐줘서 고마워.

.