10046

♪ 기악 힙합 음악 ♪

♪

"선언적 장치 관리 채택" 세션에 오신 것을 환영합니다.

제 이름은 사이러스 다부이고, 저는 장치 관리 팀의 엔지니어입니다.

선언적 장치 관리의 흥미진진한 새로운 기능에 대해 말씀드리기 위해 왔습니다.

WWDC21에서 제 동료 멜리사는 Apple 장치를 관리하기 위한 새로운 패러다임인 선언적 장치 관리를 도입하여 MDM 프로토콜 자체를 재구성했습니다.

우리가 그 세션에서 배웠듯이, 선언적 장치 관리는 장치가 자율적이고 능동적일 수 있기 때문에 강력하다.

이 장치는 자체 상태 변화에 반응한 다음 서버에서 프롬프트하지 않고 관리 로직을 자체적으로 적용하기 때문에 자율적이다.

이 장치는 능동적이며, 중요한 상태 변경이 발생할 때 상태 채널이 서버에 비동기적으로 보고하여 서버가 장치를 폴링할 필요가 없습니다.

선언적 장치 관리 데이터 모델에는 두 가지 핵심 요소가 있다: 선언과 상태.

선언은 활성화와 술어, 구성, 자산 및 관리 유형을 포함한다.

그리고 상태는 상태 항목과 상태 보고를 다룹니다.

이것이 왜 중요한지, 그것이 당신에게 무엇을 의미하는지, 그리고 당신의 제품을 사용하는 조직에 대해 잠시 이야기해 봅시다.

우리는 새로운 복잡한 관리 전략을 지원하고, 관리되는 장치의 전반적인 사용자 경험을 향상시키고, IT 관리자의 반복적이고 지루한 작업을 완화하고, 장치가 자체 관리 상태에서 운전자가 될 수 있도록 권한을 부여하기 위해 이 기술을 만들었습니다.

장치 관리 솔루션의 개발자로서, 선언적 접근 방식을 통해 서버가 가볍고 반응적일 수 있습니다.

그리고 선언적 데이터 모델이 조직이 어떻게 구조화되는지에 더 밀접하게 매핑함으로써, 그것은 장치에 대한 변화가 더 직관적이 된다는 것을 의미한다.

상태 보고서는 풍부한 피드백 채널을 제공하여 서버가 장치를 더 면밀히 모니터링하고, 폴링을 구현하는 데 사용되는 복잡한 전략 없이 보다 시기적절하고 신뢰할 수 있는 방식으로 관련 정보를 제공할 수 있습니다.

이 모든 것은 더 간단한 개발 노력을 의미하며, 가장 중요한 곳에 가치를 더하는 장치 관리 기능에 집중하고 고객이 좋아할 솔루션을 만들 수 있습니다.

IT 관리자의 경우, 선언적 접근 방식은 장치가 예상 상태에 있다는 자신감을 더 불러일으킨다.

그리고 그렇지 않은 상황에서는, 서버에 대한 연결이 끊어지더라도 민감한 조직 데이터를 보호하는 안전한 상태에 있습니다.

상태 보고서를 통해 장치의 중요한 피드백을 제공하며, 네트워크 대역폭과 같은 리소스 활용을 줄이면서 관리자의 효율성을 향상시킵니다.

조직의 사용자를 위해, 장치 관리는 더 빠른 온보딩, 더 빠른 복구 시간 및 조직의 더 나은 지원으로 더 빠르고 신뢰할 수 있는 경험이 됩니다.

이러한 모든 이점을 염두에 두고, 미래 프로토콜 기능의 초점은 선언적 장치 관리가 될 것이며, 오늘날 제품에 선언적 장치 관리를 채택하는 것이 훨씬 더 중요하다는 것을 알고 있습니다.

선언적 장치 관리와 이를 채택하는 데 필요한 단계에 대한 심층적인 소개를 위해, WWDC21 세션 비디오를 시청하세요.

이 릴리스에는 세 가지 초점 영역이 있습니다: 선언적 장치 관리의 범위 확장, 상태 보고서 강화, 술어 강화.

선언적 장치 관리의 범위를 확장하는 것부터 시작합시다.

선언적 장치 관리가 도입되었을 때, 그것은 사용자 등록이 있는 iOS에서만 지원되었다.

이제 선언적 장치 관리는 MDM이 지원하는 모든 등록 유형에 사용할 수 있습니다: 감독되는 장치를 포함하는 자동 장치 등록, 프로필 기반 등록, 프로필 및 계정 기반 사용자 등록.

선언적 장치 관리는 이제 공유 iPad에서도 사용할 수 있습니다.

iOS 16에서 사용자는 이제 설정 앱의 MDM 프로필 세부 정보 보기에서 구성을 찾을 수 있습니다.

구성 행을 탭하면 활성 구성에 대한 세부 사항이 표시됩니다.

그리고 저는 또한 선언적 장치 관리가 MDM이 지원하는 모든 플랫폼에서 가능하다는 것을 발표하게 되어 기쁩니다.

macOS Ventura는 이제 macOS에서 지원되는 모든 MDM 등록 유형에 대해 선언적 장치 관리를 지원합니다.

tvOS 16은 이제 MDM 장치 등록 유형에 대한 선언적 장치 관리를 지원합니다.

OS가 지원하는 경우, iOS에서 사용할 수 있는 동일한 선언과 상태 세트는 macOS와 tvOS에서도 사용할 수 있습니다.

macOS에서는 MDM 프로필 세부 정보 보기에 구성 섹션이 있어 활성 구성을 보여줍니다.

MDM 프로필 세부 정보 보기에 구성 섹션이 있는 tvOS도 마찬가지입니다.

마지막으로 주목해야 할 사항: macOS와 공유 iPad 장치에는 각각 두 개의 MDM 채널이 있습니다.

이것들은 장치와 사용자 채널이다.

장치 채널은 장치 수준 상태를 관리할 수 있는 반면, 사용자 채널은 특정 사용자의 관리 상태를 목표로 한다.

모든 채널에서 선언적 장치 관리를 사용하려면, 해당 채널에 대해 별도로 활성화해야 합니다.

그것은 해당 채널에서 DeclarativeManagement 명령을 보내는 것을 의미합니다.

또한, 선언적 장치 관리 상태 보고서는 각 채널에 대해 별도로 생성되므로 별도로 모니터링해야 합니다.

이제 우리의 두 번째 초점 영역으로 가십시오: 상태 보고서.

상태 보고서를 빠르게 검토해 봅시다.

장치는 구독 상태 항목에 대해 서버에 상태를 점진적으로 보고할 수 있습니다.

이 장치는 상태 업데이트가 신뢰할 수 있고 네트워킹이나 다른 유형의 문제가 발생할 경우 놓치지 않도록 서버의 성공적인 응답을 추적합니다.

상태 보고는 장치를 사전 예방적으로 만든다.

서버가 상태 변화를 감시하기 위해 장치를 지속적으로 폴링할 필요가 없습니다.

iOS 15에서, 우리는 모델 유형과 운영 체제 버전과 같은 장치 속성에 대한 일련의 상태 항목을 도입했습니다.

이 릴리스를 위해 우리는 세 가지 영역에서 상태를 확장하고 있습니다: 암호 상태, 구성에 의해 설치된 계정, 그리고 MDM이 설치된 앱.

암호 상태부터 시작합시다.

iOS 15에서, 우리는 암호 정책 구성을 도입했다.

MDM 암호 정책 프로필과 마찬가지로 적용되는 정책과 사용자가 변경할 때 암호가 준수되는 것 사이에 약간의 지연이 있을 수 있습니다.

따라서, MDM 서버는 암호가 언제 준수되는지 결정하기 위해 장치를 폴링해야 합니다.

하지만 새로운 선언적 장치 관리 암호 상태 항목으로, 그렇게 할 필요가 없습니다.

우리는 두 가지 상태 항목을 추가했습니다: Passcode.is-compliant와 passcode.is-present.

규정 준수는 암호가 MDM 프로필이나 구성을 통해 적용된 모든 암호 정책을 준수하는지 여부를 나타냅니다.

이러한 상태 항목에는 MDM 쿼리를 통해 검색할 수 있는 동등한 속성을 미러링하는 부울 값이 있습니다.

전형적인 서버 동작을 살펴봅시다.

종종, 조직은 장치에 적용할 보안에 민감한 상태를 가지고 있다.

예를 들어, 보호된 네트워크에 대한 액세스를 허용하는 VPN 또는 Wi-Fi 프로필.

그 상태는 강력한 암호 정책이 존재하고 암호가 해당 정책을 준수하는 경우에만 장치에서 활성화되어야 합니다.

전통적인 MDM의 경우, 서버는 암호 정책 프로필을 보낸 다음 장치를 폴링하여 사용자가 변경할 때 암호가 준수될 때까지 기다려야 합니다.

처음에는 암호가 호환되지 않을 수 있으므로 Wi-Fi 프로필을 보낼 수 없습니다.

결국, 사용자는 규정을 준수하기 위해 암호를 변경한다.

서버의 다음 설문 조사에서 변경된 준수 상태를 감지하고 Wi-Fi 프로필을 보내도 괜찮다고 판단하여 장치에 설치됩니다.

선언적 장치 관리는 암호 준수 상태에 의해 트리거되는 활성화 조건자를 사용하여 서버가 폴링할 필요성을 제거합니다.

서버는 암호 정책과 Wi-Fi 프로필을 모두 구성으로 전송하며, Wi-Fi 구성은 암호 준수에 따라 활성화와 연결됩니다.

암호 구성은 즉시 활성화되고 강력한 암호 정책을 적용합니다.

처음에는 암호가 호환되지 않을 가능성이 높기 때문에 활성화 조건자는 거짓으로 평가되며 Wi-Fi 구성은 활성화되지 않습니다.

어느 시점에서, 사용자는 준수하도록 암호를 업데이트한다.

이것은 활성화의 재평가를 트리거하고 술어는 이제 true로 평가되어 Wi-Fi 구성이 활성화됩니다.

이 모든 것은 서버의 개입 없이 발생하며, 실제로 서버에 대한 연결 없이도 발생할 수 있다.

서버는 구성이 활성화될 때 장치에서 상태 보고서를 자동으로 받기 때문에 변경이 언제 일어나는지 알 수 있습니다.

이것은 폴링할 필요성을 피하고 더 반응적이고 신뢰할 수 있는 장치 동작을 얻기 위해 비즈니스 로직을 서버에서 장치로 성공적으로 이동한 방법을 보여줍니다.

이제, 계정 상태로 돌아가자.

iOS 15에서는 장치에 다양한 유형의 계정을 설치하기 위해 계정 구성을 도입했습니다.

이것들은 일반적으로 조직 계정으로, 사용자가 조직 데이터에 접근할 수 있게 해준다.

관리자가 문제가 있을 수 있는 사용자를 지원하기 위해 계정이 언제 성공적으로 설치되었는지, 어떤 상태에 있는지 아는 것이 유용합니다.

이 릴리스는 메일, 캘린더 및 기타 계정 유형에 대한 8개의 계정 상태 항목을 추가합니다.

참고로, 그 상태는 구성에 의해 설치된 계정에 대해서만 보고되며 수동으로 생성되거나 MDM 프로필을 통해 설치된 계정은 포함되지 않습니다.

각각의 새로운 상태 항목은 계정 구성 유형에 해당하며, 수신 및 발신 메일 계정의 상태는 별도로 보고됩니다.

새로운 상태 항목은 각각 다른 유형의 JSON 객체를 사용하여 해당 계정 유형의 상태를 나타냅니다.

다음은 수신 메일 상태 항목과 구독한 일정 상태 항목의 예입니다.

식별자 키의 값은 상태 항목 객체 배열 내의 객체에 대한 고유 식별자입니다.

선언 식별자 키의 값은 계정을 설치한 구성의 식별자 속성 값과 일치하여 상태 항목 개체와 관련 구성을 쉽게 상호 참조할 수 있습니다.

이 두 키는 항상 모든 유형의 계정 상태 항목 객체에 존재합니다.

다른 키는 계정 유형에 따라 다릅니다.

예를 들어, 메일 서버의 호스트 이름과 포트, 또는 구독된 캘린더의 캘린더 URL.

이 릴리스는 동일한 유형의 하나 이상의 계정에 대한 보고를 지원하기 위해 값이 배열인 상태 항목을 소개합니다.

그러한 배열 값은 특별한 행동을 가지고 있다.

배열의 각 항목은 단일 배열의 모든 객체에 사용되는 동일한 스키마를 가진 JSON 객체입니다.

각 객체 유형에는 항상 식별자 키가 있으며, 배열 내에서 객체를 찾기 위한 기본 키 역할을 합니다.

다른 키들은 존재하며 보고되는 기본 유형의 상태와 연결되어 있다.

향후 OS 릴리스에 추가된 키와의 호환성을 보장하기 위해, 서버는 배열 객체에서 알 수 없는 키를 받아들여야 합니다.

배열 값의 변경 사항은 성능상의 이유로 항상 객체별로 서버에 점진적으로 보고됩니다.

이 새로운 기능이 어떻게 작동하는지 보여주는 예시를 살펴봅시다.

이 예에서, 서버는 두 개의 메일 계정 구성을 장치로 보냅니다.

둘 다 활성화되어 장치에 두 개의 메일 계정이 있습니다.

서버는 이제 메일 계정 상태 항목에 대한 상태 구독을 보냅니다.

구독이 활성화되면, 계정의 상태가 수집되고, 장치는 서버로 상태 보고서를 보냅니다.

상태 보고서는 상태 배열에 두 개의 계정 상태 객체를 포함하며, 서버에 현재 장치에 존재하는 것에 대한 완전한 그림을 제공합니다.

각 배열 객체는 다른 식별자를 가지고 있다.

이 보고서를 처리한 후, 서버는 장치에 있는 것과 일치하는 두 개의 메일 계정의 상태를 가지고 있습니다.

서버가 새 구성을 보내 장치에 메일 계정을 추가하면, 장치의 상태 항목에 새 개체가 배열 값에 추가되고 다른 상태 보고서가 서버로 전송됩니다.

새로운 항목만 보고됩니다.

식별자 키의 값은 서버가 이미 가지고 있는 것과 일치하지 않으므로, 서버는 이것이 새 계정에 해당한다고 추론할 수 있다.

이 보고서를 처리한 후, 서버는 세 개의 메일 계정, 두 개의 초기 계정과 새 계정의 상태를 가지고 있으며, 다시 장치에 있는 것과 정확히 일치합니다.

사용자가 메일이나 메모가 활성화된 상태를 토글할 때와 같이 계정 상태가 변경되면, 장치의 상태 항목은 배열 값에 업데이트된 개체를 갖게 되며, 다시 상태 보고서가 서버로 전송됩니다.

변경된 항목만 보고됩니다.

이 경우, 사용자는 계정의 메모 기능을 끁니다.

식별자 키의 값은 서버가 이미 가지고 있는 것과 일치하므로, 서버는 이것이 기존 계정에 대한 업데이트라고 추론할 수 있습니다.

결과적으로, 그것은 기존 상태 항목 배열 객체를 새 객체로 대체한다.

이 보고서를 처리한 후, 서버는 세 개의 메일 계정에 대한 상태를 가지고 있지만, 하나는 변경되었습니다.

계정 구성이 장치에서 제거되면, 장치의 상태 항목에는 제거를 위해 표시된 해당 개체가 있으며, 다른 상태 보고서가 서버로 전송됩니다.

제거된 항목만 보고됩니다.

제거를 나타내기 위해, 배열 항목 객체에는 두 개의 키만 포함되어 있습니다: 서버가 이미 가지고 있는 것과 일치하는 식별자 키와 true 값으로 설정된 제거된 키.

이를 통해 서버는 기존 항목을 제거하여 장치 상태의 표현을 업데이트할 수 있습니다.

이 보고서를 처리한 후, 서버는 장치의 상태와 정확하게 일치하는 두 개의 메일 계정에 대해서만 상태를 가지고 있습니다.

상태 보고서에 대한 마지막 요점.

이 장치는 성능 문제를 피하기 위해 상태 보고서가 전송되는 속도를 제한할 것이다.

이 장치는 상태 보고서를 서버에 보내기 전에 최대 1분의 가변 간격으로 상태 항목에 대한 변경 사항을 집계합니다.

이것은 상태가 빠르게 보고된다는 것을 의미하지만, 즉각적이지는 않다.

다음으로, 다년생 MDM 병목 현상 문제를 해결하는 데 관심을 돌입시다: 애플리케이션 설치 상태 모니터링.

MDM 서버는 종종 사용자가 업무나 교육에 필요한 도구에 액세스할 수 있도록 장치에 앱을 설치합니다.

서버 측 논리는 종종 앱이 성공적으로 설치되었는지 여부에 따라 결정됩니다.

따라서 MDM 서버는 앱 설치 진행 상황을 모니터링하고 사용자가 장치에서 관리되는 앱을 제거할 가능성을 지켜봐야 합니다.

현재 MDM 서버는 InstalledApplicationList 또는 ManagedApplicationList 명령을 사용하여 장치를 폴링하여 앱 설치 진행 상황을 관찰할 수 있습니다.

장치가 앱 설치 진행 상황을 서버에 능동적으로 보내도록 함으로써 폴링을 피할 수 있습니다.

그리고 그것을 하는 도구는 선언적 장치 관리 상태 보고서이다.

이 릴리스는 mdm.app 상태 항목을 추가합니다.

그 값은 각각 MDM 서버에 의해 설치된 앱을 나타내는 객체의 배열이다.

이 값은 배열이기 때문에, 앞서 설명한 절차를 사용하여 점진적으로 보고됩니다.

MDM에 의해 설치된 앱만 여기에 보고되며, 심지어 감독된 장치에서도 보고됩니다.

이 상태 보고서에는 설치가 완료된 앱의 상태 항목이 포함되어 있습니다.

식별자 키는 배열 항목 객체의 고유 식별자이며, 이 경우 앱의 번들 식별자입니다.

이름 키는 앱의 이름을 나타낸다.

세 가지 버전 키는 일반, 짧은 및 외부 버전 식별자를 제공합니다.

그리고 상태 키는 앱의 현재 설치 단계를 나타내는 열거형이다.

이 키의 값은 MDM ManagedApplicationList 명령 응답의 동등한 항목에 해당합니다.

이 모든 정보로, 서버는 보고되는 앱과 그 상태를 즉시 식별할 수 있다.

앱 설치 시 데이터 흐름의 예를 살펴봅시다.

오른쪽에는 MDM 서버에서 관리하는 iOS 16 장치가 있습니다.

서버는 이미 선언적 장치 관리를 활성화하고 MDM이 설치한 앱 상태 항목에 대한 상태 구독을 보냈습니다.

서버의 다음 단계는 MDM InstallApplication 명령을 사용하여 앱을 설치하는 것입니다.

이것은 사용자 등록이기 때문에, 앱을 설치하려면 사용자 승인이 필요하므로, 장치가 앱 설치 명령을 처리할 때 프롬프트가 나타납니다.

이 시점에서, 설치 진행은 사용자 입력을 기다리며 일시 중지됩니다.

장치는 서버로 상태 보고서를 보낼 것이며, 여기에는 앱의 번들 ID와 상태가 프롬프트로 설정된 단일 MDM 설치 앱 상태 개체가 포함됩니다.

어느 시점에서, 사용자가 설치 버튼을 탭하면, 앱 설치가 장치에서 시작됩니다.

설치가 진행됨에 따라, 이번에는 앱 상태가 설치로 설정된 또 다른 상태 보고서가 전송됩니다. 앱이 다운로드되고 설치되고 있음을 나타냅니다.

결국, 앱은 설치를 완료하고 사용할 준비가 되었습니다.

그 시점에서, 앱 상태가 관리로 설정된 또 다른 상태 보고서가 전송되며, 이는 앱이 제대로 설치되고 관리되고 있음을 나타냅니다.

이제, 사용자가 장치에서 앱을 수동으로 삭제한다고 가정해 봅시다.

다시 말하지만, 이번에는 앱 상태가 관리되지만 제거된 상태로 상태 보고서가 전송됩니다.

이것은 앱이 더 이상 설치되지 않았지만, 관리 상태가 여전히 장치에서 추적되고 있음을 나타냅니다.

서버가 앱 관리 상태를 제거하고 싶어한다고 가정해 봅시다.

그것은 장치에 RemoveApplication 명령을 보내서 그렇게 한다.

그것은 내부적으로 유지되는 관리 상태를 제거하고, 앱이 여전히 존재한다면, 그것도 제거될 것이다.

또 다른 상태 보고서는 앱 상태 배열에서 제거된 것으로 표시된 앱 객체와 함께 전송됩니다.

이것은 앱 설치의 반응성과 신뢰성을 향상시키는 데 도움이 되는 새로운 MDM 상태 항목의 힘을 보여주며, 구현하는 데 몇 단계만 거치면 됩니다.

이제, 우리의 세 번째 초점 영역을 살펴봅시다: 술어.

활성화 술어들을 빠르게 검토해 봅시다.

활성화에는 활성화에서 참조된 구성이 장치에 적용될지 여부를 결정하는 선택적 조건자가 포함될 수 있습니다.

조건자는 상태 항목을 참조하여 해당 상태 항목의 값을 테스트할 수 있습니다.

조건자에서 참조된 상태 항목이 변경되면, 장치는 모든 활성화를 재처리하여 조건자를 재평가합니다.

술어들은 Apple Developer 사이트에 문서화된 NSPredicate 구문을 사용하여 문자열로 지정됩니다.

더 복잡한 술어 표현식을 지원하기 위해, 우리는 표현식에서 상태 항목을 더 쉽게 감지할 수 있도록 술어 구문을 확장했습니다.

새로운 구문은 조건자 문자열의 @status 용어 안에 상태 항목 이름을 배치합니다.

이 예에서, 일련 번호 상태 항목은 새로운 구문을 사용하여 술어 표현식에 나타납니다.

이전 구문은 이전 버전과의 호환성을 위해 계속 작동할 것이지만, 지금은 더 이상 사용되지 않으므로 새 것으로 전환하십시오.

조건자를 상태 항목 배열 값과 함께 어떻게 사용할 수 있는지 살펴봅시다.

방금 설명했듯이, 이제 계정과 MDM이 설치한 앱 상태 항목의 배열인 상태 항목 값이 있습니다.

배열의 항목에 대한 활성화를 전제할 수 있는 것은 유용하다.

예를 들어, 특정 번들 식별자가 있는 앱이 장치에 설치되고 관리될 때 활성화가 트리거되기를 원할 수 있습니다.

NSPredicate에는 배열에서 작동하는 데 사용할 수 있는 SUBQUERY 용어가 있습니다.

이 NSPredicate 표현식은 MDM이 설치한 앱 상태 항목을 대상으로 하는 하위 쿼리를 사용합니다.

상태 항목은 SUBQUERY의 첫 번째 인수로 사용됩니다.

두 번째 인수는 배열의 각 요소를 참조할 변수를 정의한다.

세 번째 인수는 그 변수에 의해 식별된 각 요소를 테스트하는 술어 표현이다.

SUBQUERY 표현식은 세 번째 인수의 술어와 일치하는 요소 배열을 반환합니다.

그런 다음 @count 연산자는 해당 배열의 길이를 반환하고, 결과 일치가 하나 있는지 결정하기 위해 길이가 확인됩니다.

지정된 앱이 설치되고 관리되면, 이 SUBQUERY 표현식은 단일 요소가 있는 배열을 반환하고, 술어는 true로 평가됩니다.

앱이 설치되지 않으면, SUBQUERY 표현식은 빈 배열을 반환하고, 술어는 false로 평가됩니다.

상태 항목 배열 객체의 키를 참조하려면 키 경로가 제대로 처리되도록 @key 확장어를 사용해야 합니다.

새로운 술어 구문은 확장할 수 있으며, 이제 새로운 유형의 데이터에 대한 술어 용어를 추가하는 데 어떻게 사용할 수 있는지 논의할 것입니다.

서버는 복잡한 서버 측 논리가 이러한 변경을 트리거하기 위해 대규모 구성 세트를 동기화할 필요 없이 장치에서 간단한 상태 변경으로 변환될 수 있도록 술어의 평가를 더 직접적으로 제어할 수 있어야 합니다.

이것의 예는 여러 역할을 가진 사용자가 있고 사용자에게 배포될 때 효율적이고 적시적인 장치 할당을 원하는 조직 또는 교체 장치를 신속하게 배포하거나 조직 데이터를 보호하기 위해 장치를 안전 모드로 빠르게 전환해야 하는 조직일 수 있습니다.

이를 지원하기 위해, 서버가 활성화 술어에 직접 사용할 수 있는 장치에 임의의 속성을 설정할 수 있도록 새로운 선언을 추가하고 있다고 말하게 되어 기쁩니다.

이것은 새로운 관리 자산 선언이다.

선언은 키 이름이 서버에 의해 정의된 JSON 객체로 구성되어 있다.

JSON 객체 값은 배열이나 객체를 포함한 모든 JSON 값 유형일 수 있습니다.

여기에 있는 관리 속성 선언은 세 가지 속성을 포함합니다: 문자열과 정수 값이 있는 이름과 나이 속성, 그리고 문자열 배열인 역할 속성.

이것은 일부 관리 속성을 참조하는 술어의 활성화이다.

먼저, 정수 값이 18보다 크거나 같은지 결정하기 위해 연령 속성을 테스트한 다음, 문자열 Grade12가 속성 배열 값에 있는지 결정하기 위해 역할 속성을 테스트합니다.

각 속성은 용어 내부의 속성 키 이름과 함께 @property 확장 용어를 사용하여 참조됩니다.

여러 관리 속성 선언을 장치로 보낼 수 있지만, 키는 모두 고유해야 합니다.

중복 키가 있는 경우, 속성이 술어에서 참조될 때 값 중 하나가 임의로 선택되어 예측할 수 없는 결과로 이어집니다.

그러니 중복된 키 이름을 사용하지 마세요.

예시 사용 사례를 살펴봅시다.

이 예는 학교를 포함한다.

그리고 물론, 그 학교에는 일련의 선생님들이 있다.

그 학교에는 두 개의 부서가 있다: 상부와 하부.

각 부서는 자체 Wi-Fi 네트워크를 갖춘 자체 캠퍼스를 가지고 있다.

일부 교사들은 IT 관리자 역할을 하며 공유 메일 계정에 대한 접근이 필요합니다.

일부 교사들은 또한 스포츠 코치 역할을 하며 모든 팀 경기 일정에 대한 구독 달력이 있어야 한다.

따라서 교사가 가질 수 있는 네 가지 역할이 있으며, 때로는 여러 역할을 한다.

각 역할에는 장치에 할당된 교사의 역할에 따라 장치에 적용해야 하는 일련의 구성이 있습니다.

우리의 예에서 두 명의 선생님을 생각해 봅시다.

선생님은 중학교에서 가르치고 스포츠 코치이기도 하다.

두 선생님은 고등학교에서 가르치고 IT 관리자이기도 하다.

그러한 사용 사례는 전통적인 MDM 서버에서 어떻게 처리될 수 있을까요?

일반적으로, 서버는 장치를 완전히 구성하기 전에 장치가 교사에게 할당될 때까지 기다려야 한다.

서버는 선생님이 어떤 역할을 하는지 결정해야 한다.

그런 다음 각 역할에 연결된 프로필을 결정합니다.

그런 다음 장치에 각 프로필을 한 번에 하나씩 설치해야 합니다.

교사가 역할을 변경하면, 서버는 새로운 역할과 일치하도록 프로필을 추가하거나 제거해야 합니다.

이것은 시간이 많이 걸리고 특히 피크 타임에 장치 관리 시스템에 상당한 병목 현상을 일으킬 수 있으며, 우리의 경우에는 과제가 끝날 때 학교 첫날이 될 것이다.

새로운 관리 자산 선언과 함께, 우리는 이것에 대한 더 효율적인 대안을 가지고 있다.

이것은 미리 장치에 전체 선언 세트를 미리 로드하는 것을 포함한다.

구성은 관리 속성을 통해 다른 역할에 대해 트리거되는 술어와 함께 활성화에 할당됩니다.

장치가 교사에게 할당되면, 서버는 교사의 역할이 있는 관리 속성 선언만 보내며, 이는 해당 역할에 대한 구성의 활성화를 트리거합니다.

이 방법은 전체 서버와 네트워크 트래픽을 최소화하고 장치 상태를 빠르게 변경하는 복잡성을 줄입니다.

우리 학교 예시로 돌아가자.

서버는 다음 선언 세트를 미리 로드합니다: 각 부서에 대한 Wi-Fi 네트워크를 설정하는 두 개의 활성화/구성 쌍.

그런 다음, 우리는 메일 계정을 설치하는 IT 관리자 역할을 위한 활성화/구성 쌍이 있습니다.

마지막으로, 우리는 구독한 달력을 설치하는 활성화와 구성을 가지고 있습니다.

각 활성화에는 역할 관리 속성을 사용하여 분할 또는 함수의 이름을 테스트하는 술어가 있습니다.

할당되지 않은 장치에 처음 로드될 때, 모든 술어는 false로 평가되므로 아무것도 적용되지 않습니다.

이제, 과제 당일에 무슨 일이 일어나는지 살펴봅시다.

서버가 해야 할 일은 각 교사에게 맞춤화된 관리 속성 선언을 만드는 것이다.

선생님은 낮은 것과 스포츠를 나열하는 역할 속성을 가지고 있다.

두 번째 선생님은 상위와 IT 관리자를 나열하는 역할 속성을 가지고 있다.

이러한 선언이 할당된 각 장치로 별도로 전송되면, 사전 로드된 활성화는 모두 재평가될 것이다.

그래서 교사의 장치는 낮은 역할과 스포츠 역할에 대한 구성을 활성화했다.

그리고 교사 2의 장치에는 상위 및 IT 관리자 역할에 대한 구성이 활성화되어 있습니다.

많은 구성의 적용을 트리거하려면 하나의 선언만 필요합니다.

마지막으로, 교사가 역할을 바꿀 때 어떤 일이 일어나는지 살펴봅시다.

이 경우, 두 번째 선생님은 기존 역할 외에도 스포츠 코치가 되었다.

교사의 할당된 장치에 대한 관리 속성 선언은 이제 추가 역할 이름을 포함하도록 업데이트되었습니다.

그 선언이 장치에서 업데이트되면, 모든 활성화가 재평가된다.

이 경우, 새로운 스포츠 역할에 대한 구독된 달력 구성이 적용될 것이다.

다시 말하지만, 단 하나의 선언 변경만 트리거로 필요합니다.

이것은 관리 속성 선언이 어떻게 장치의 구성 세트 사이를 빠르고 쉽게 전환할 수 있는 강력한 방법을 제공하여 복잡한 서버 측 논리가 장치의 간단한 상태 변경으로 변환될 수 있는지 보여줍니다.

이제, 마무리하자.

우리는 iOS 16, tvOS 16 및 macOS Ventura에서 선언적 장치 관리 범위를 확장했으며, 공유 iPad를 포함한 모든 적용 가능한 유형의 MDM 등록에 사용할 수 있도록 했습니다.

이것은 MDM을 지원하는 모든 Apple 장치에서 선언적 장치 관리를 완벽하게 지원합니다.

암호, 계정 및 MDM 설치 앱에 대한 새로운 상태 항목을 추가했습니다.

MDM이 설치한 앱 상태는 MDM의 주요 병목 현상 중 하나에 대한 훌륭한 솔루션을 제공합니다.

마지막으로, 우리는 더 확장 가능하고 사용하기 쉽도록 술어 구문을 강화했으며, 서버가 복잡한 비즈니스 로직을 장치로 이동할 수 있는 더 많은 기회를 제공하는 새로운 관리 속성 선언을 추가했습니다.

이제 당신의 제품에 선언적 장치 관리를 추가할 때입니다.

그리고 우리는 당신이 선언적 장치 관리를 사용하여 장치 관리 솔루션을 다시 상상하기 위해 무엇을 할 것인지 알게 되어 기쁩니다!

언제나처럼, 당신의 피드백에 대단히 감사드립니다.

감사합니다 그리고 나머지 WWDC를 즐기세요.

♪ ♪