110350

♪ ♪

스위프트 동시성 시각화 및 최적화에 오신 것을 환영합니다.

제 이름은 마이크이고, 저는 스위프트 런타임 라이브러리에서 일하고 있습니다.

안녕하세요, 저는 Harjas이고, 악기 작업을 하고 있습니다.

함께, 우리는 Instruments 14에서 사용할 수 있는 새로운 시각화 도구를 포함하여 Swift Concurrency 코드를 더 잘 이해하고 더 빠르게 만드는 방법에 대해 논의할 것입니다.

당신이 속도를 낼 수 있도록 Swift Concurrency의 다양한 부분과 그들이 어떻게 함께 작동하는지에 대한 정말 빠른 요약으로 시작합시다.

그 후, 우리는 새로운 동시성 도구를 시연할 것이다.

Swift Concurrency를 사용하는 앱으로 실제 성능 문제를 해결하기 위해 어떻게 사용하는지 보여드리겠습니다.

마지막으로, 우리는 스레드 풀 고갈과 지속적인 오용의 잠재적인 문제와 이를 피하는 방법에 대해 논의할 것입니다.

작년에, 우리는 Swift Concurrency를 도입했다.

이것은 비동기/대기, 구조화된 동시성 및 배우를 포함하는 새로운 언어 기능이었다.

우리는 그 이후로 Apple 내부와 외부 모두에서 이러한 기능을 많이 채택한 것을 보게 되어 기뻤습니다.

스위프트 동시성은 동시 프로그래밍을 더 쉽고 안전하게 만들기 위해 함께 작동하는 몇 가지 새로운 기능을 언어에 추가합니다.

Async/await는 동시 코드의 기본 구문 빌딩 블록이다.

실행 중에 작업을 중단한 다음 실행 스레드를 차단하지 않고 나중에 작업을 재개할 수 있는 함수를 만들고 호출할 수 있습니다.

작업은 동시 코드의 기본 작업 단위이다.

작업은 동시 코드를 실행하고 상태 및 관련 데이터를 관리합니다.

그들은 지역 변수를 포함하고, 취소를 처리하며, 비동기 코드의 실행을 시작하고 일시 중지합니다.

구조화된 동시성은 자식 작업을 쉽게 생성하여 병렬로 실행하고 완료될 때까지 기다릴 수 있게 해준다.

이 언어는 작업을 함께 그룹화하고 사용하지 않으면 작업을 기다리거나 자동으로 취소되도록 하는 구문을 제공합니다.

배우들은 공유 데이터에 접근해야 하는 여러 작업을 조정한다.

그들은 외부에서 데이터를 분리하고, 한 번에 하나의 작업만 내부 상태를 조작할 수 있도록 허용하여 동시 돌연변이로 인한 데이터 경쟁을 피한다.

Instruments 14의 새로운 기능, 우리는 앱에서 이 모든 활동을 캡처하고 시각화할 수 있는 도구 세트를 도입하여 앱이 무엇을 하고 있는지 이해하고, 문제를 찾고, 성능을 향상시킬 수 있도록 도와줍니다.

Swift Concurrency의 기본에 대한 보다 심층적인 논의를 위해, 관련 비디오 섹션에 링크된 이러한 기능에 대한 몇 가지 비디오가 있습니다.

Swift Concurrency 코드를 사용하여 앱을 최적화하는 방법을 살펴봅시다.

스위프트 동시성은 올바른 동시 및 병렬 코드를 쉽게 작성할 수 있게 해준다.

그러나, 동시성 구조를 오용하는 코드를 작성하는 것은 여전히 가능하다.

그것들을 올바르게 사용하는 것도 가능하지만 당신이 목표로 했던 성능 이점을 얻지 못하는 방식으로.

성능 저하나 버그를 일으킬 수 있는 스위프트 동시성을 사용하여 코드를 작성할 때 발생할 수 있는 몇 가지 일반적인 문제가 있습니다.

주요 배우 차단으로 인해 앱이 중단될 수 있습니다.

배우 경합과 스레드 풀 고갈은 병렬 실행을 줄임으로써 성능을 손상시킨다.

지속적인 오용은 누출이나 충돌을 일으킨다.

새로운 스위프트 동시성 도구는 이러한 문제를 발견하고 해결하는 데 도움이 될 수 있습니다.

주요 배우 차단부터 시작하여 이들 각각을 살펴봅시다.

메인 액터 차단은 장기 실행 작업이 메인 액터에서 실행될 때 발생한다.

주요 배우는 메인 스레드에서 모든 작업을 수행하는 특별한 배우이다.

UI 작업은 메인 스레드에서 수행되어야 하며, 메인 액터를 사용하면 UI 코드를 Swift Concurrency에 통합할 수 있습니다.

그러나, 메인 스레드는 UI에 매우 중요하기 때문에, 사용할 수 있어야 하며 장기간 실행되는 작업 단위가 차지할 수 없습니다.

이런 일이 발생하면, 앱이 잠기고 반응하지 않는 것처럼 보입니다.

메인 액터에서 실행되는 코드는 빠르게 완료되어야 하며, 작업을 완료하거나 메인 액터에서 백그라운드로 계산을 이동해야 합니다.

작업은 일반 배우나 분리된 작업에 넣어 배경으로 이동할 수 있습니다.

UI를 업데이트하거나 메인 스레드에서 수행해야 하는 다른 작업을 수행하기 위해 메인 액터에서 작은 작업을 실행할 수 있습니다.

이것의 데모가 실행 중인 것을 봅시다.

고마워, 마이크.

여기 파일 스퀴저 애플리케이션이 있습니다.

우리는 폴더의 모든 파일을 빠르게 압축할 수 있도록 이 응용 프로그램을 만들었습니다.

작은 파일에서 잘 작동하는 것 같다.

그러나, 더 큰 파일을 사용할 때, 예상보다 훨씬 오래 걸리고 UI는 완전히 멈춘 상태이며 어떤 상호 작용에도 반응하지 않습니다.

이 행동은 사용자에게 매우 불쾌하며 애플리케이션이 충돌했거나 결코 끝나지 않을 것이라고 생각하게 만들 수 있다.

우리는 UI가 항상 최고의 사용자 경험을 위해 반응할 수 있도록 노력해야 합니다.

이 성능 문제를 조사하기 위해, 우리는 Instruments에서 새로운 Swift Concurrency 템플릿을 사용할 수 있습니다.

Swift Tasks와 Swift Actors 악기는 동시성 코드를 시각화하고 최적화하는 데 도움이 되는 전체 도구 모음을 제공합니다.

성능 문제를 조사하기 시작할 때 먼저 Swift Tasks 도구에서 제공하는 최상위 통계를 살펴봐야 합니다.

이 중 첫 번째는 얼마나 많은 작업이 동시에 실행되고 있는지 보여주는 실행 작업입니다.

다음으로, 주어진 시점에 얼마나 많은 작업이 존재하는지 보여주는 Alive Tasks가 있습니다.

그리고 마지막으로, 총 작업; 그 시점까지 생성된 총 작업 수를 그래프로 표시하세요.

애플리케이션 메모리 공간을 줄이려고 할 때, Alive 및 Total Tasks 통계를 자세히 살펴봐야 합니다.

이 모든 통계의 조합은 코드가 얼마나 잘 병렬화되고 얼마나 많은 자원을 소비하고 있는지에 대한 좋은 그림을 제공합니다.

이 도구의 많은 세부 보기 중 하나는 작업 포리스트입니다. 이 창의 아래쪽 절반에 표시된 이 도구는 구조화된 동시성 코드에서 작업 간의 부모-자식 관계의 그래픽 표현을 제공합니다.

다음으로, 우리는 작업 요약 보기를 가지고 있다.

이것은 각 작업이 다른 주에서 얼마나 많은 시간을 소비하는지 보여준다.

선택한 작업에 대한 모든 정보가 포함된 트랙을 타임라인에 고정할 수 있도록 작업을 마우스 오른쪽 버튼으로 클릭하여 보기를 강화했습니다.

이를 통해 매우 오랫동안 실행되거나 배우에 접근하기 위해 기다릴 수 있는 관심 있는 작업에 대해 빠르게 찾고 배울 수 있습니다.

스위프트 작업을 타임라인에 고정하면, 네 가지 주요 기능을 얻을 수 있습니다.

첫째, 당신의 스위프트 작업이 어떤 상태에 있는지 보여주는 트랙입니다.

둘째, 확장된 세부 사항 보기의 작업 생성 역추적이다.

셋째, 스위프트 태스크가 있는 상태에 대한 더 많은 맥락을 제공하는 내러티브 뷰이다.

예를 들어, 작업을 기다리고 있다면, 어떤 작업을 기다리고 있는지 알려줄 것입니다.

마지막으로, 당신은 요약 보기에서 했던 것처럼 내러티브 보기에서 동일한 핀 동작에 접근할 수 있습니다.

따라서, 자식 작업, 스레드 또는 스위프트 액터도 타임라인에 고정할 수 있습니다.

이 내러티브 뷰는 스위프트 태스크가 다른 동시성 프리미티브와 CPU와 어떻게 관련되어 있는지 찾는 데 도움이 될 것입니다.

이제 새로운 기기의 일부 기능에 대한 간략한 개요를 보았으니, 애플리케이션을 프로파일링하고 코드를 최적화해 봅시다.

우리는 Xcode에서 프로젝트를 가져오고 Command-I를 눌러 이것을 할 수 있습니다.

이것은 우리의 애플리케이션을 컴파일하고, 도구를 열고, 파일 스퀴저 애플리케이션에 대한 대상을 미리 선택할 것이다.

여기에서 템플릿 선택기에서 Swift Concurrency 옵션을 선택하고 녹음을 시작할 수 있습니다.

다시 한 번, 나는 큰 파일을 앱에 놓을 것이다.

다시 말하지만, 우리는 앱이 회전하기 시작하고 UI가 반응하지 않는 것을 본다.

우리는 악기가 우리의 응용 프로그램에 대한 모든 정보를 캡처할 수 있도록 이것을 몇 초 더 실행하도록 할 것이다.

이제 흔적이 있으니, 우리는 조사를 시작할 수 있다.

나는 모든 정보를 더 잘 보기 위해 이 흔적을 전체 화면으로 볼 것이다.

우리는 옵션 드래그를 사용하여 관심 영역을 확대할 수 있습니다.

프로세스 트랙에서, 인스트루먼트는 이 UI 행이 어디에서 발생했는지 정확히 보여준다.

이것은 중단이 언제 발생했는지 또는 얼마나 오래 지속되었는지 명확하지 않은 경우에 유용할 수 있다.

앞서 언급했듯이, 시작하기에 좋은 곳은 최상위 스위프트 작업 통계입니다.

바로 내 눈을 사로잡는 것은 실행 작업 수이다.

대부분의 경우, 오직 하나의 작업만 실행되고 있다.

이것은 우리에게 문제의 일부는 우리의 모든 작업이 연재되어야 한다는 것이다.

작업 상태 요약을 사용하여 가장 오래 실행되는 작업을 찾고 핀 동작을 사용하여 타임라인에 고정할 수 있습니다.

이 작업에 대한 내러티브 뷰는 짧은 시간 동안 배경 스레드에서 실행된 다음 메인 스레드에서 오랫동안 실행되었다는 것을 알려줍니다.

더 조사하기 위해, 우리는 메인 스레드를 타임라인에 고정할 수 있다.

메인 스레드는 여러 장기 실행 작업에 의해 차단되고 있다.

이것은 마이크가 말한 주요 배우 차단 문제를 보여준다.

그래서 우리가 스스로에게 물어봐야 할 질문은 "이 작업은 무엇을 하고 있나요?"이다. 그리고 "이 작업은 어디에서 왔나요?"

우리는 이 두 가지 질문에 답하기 위해 내러티브 관점으로 돌아갈 수 있다.

확장된 세부 정보 보기의 생성 역추적은 작업이 compressAllFiles 함수에서 생성되었음을 보여줍니다.

그 이야기는 작업이 compressAllFiles에서 1번 클로저를 실행하고 있다는 것을 보여준다.

이 기호를 마우스 오른쪽 버튼으로 클릭하면 소스 뷰어에서 열 수 있습니다.

이 기능 내부의 첫 번째 폐쇄는 우리의 압축 작업을 호출하고 있다.

이제 이 작업이 어디에서 생성되었고 무엇을 하고 있는지 알았으므로, Xcode에서 코드를 열고 메인 스레드에서 이러한 무거운 계산을 실행하지 않도록 조정할 수 있습니다.

압축 파일 기능은 CompressionState 클래스 내에 있습니다.

전체 CompressionState 클래스는 @MainActor에서 실행되도록 주석이 달린다.

이것은 왜 작업이 메인 스레드에서도 실행되었는지 설명한다.

우리는 이 전체 클래스가 MainActor에 있어야 합니다. 왜냐하면 여기 @Published 속성은 메인 스레드에서만 업데이트되어야 하기 때문입니다. 그렇지 않으면 런타임 문제가 발생할 수 있습니다.

그래서, 대신에 우리는 이 수업을 자체 배우로 전환하려고 시도할 수 있다.

그러나, 컴파일러는 본질적으로 이 공유 가변 상태가 두 명의 다른 배우에 의해 보호되어야 한다고 말할 것이기 때문에 우리가 이것을 할 수 없다고 말할 것이다.

하지만 그것은 우리에게 진정한 해결책이 무엇인지에 대한 힌트를 준다.

우리는 이 수업 내에서 두 개의 다른 변할 수 있는 상태를 가지고 있다.

하나의 상태인 '파일' 속성은 SwiftUI에 의해 관찰되기 때문에 MainActor로 격리되어야 한다.

하지만 다른 상태인 로그에 대한 액세스는 동시 액세스로부터 보호되어야 하지만, 주어진 시점에서 로그에 액세스하는 스레드는 중요하지 않습니다.

따라서, 그것은 실제로 주연 배우에 있을 필요가 없다.

하지만 우리는 여전히 그것을 동시 접근으로부터 보호하고 싶기 때문에, 우리는 그것을 자체 액터로 포장한다.

우리가 지금 필요한 것은 필요에 따라 작업이 둘 사이를 이동할 수 있는 방법을 추가하는 것이다.

우리는 새로운 배우를 만들고 그것을 ParallelCompressor라고 부를 수 있다.

그런 다음 로그 상태를 새 배우에 복사하고 추가 설정 코드를 추가할 수 있습니다.

여기서부터, 우리는 이 배우들이 서로 소통하도록 해야 한다.

먼저, CompressionState 클래스에서 로그 변수를 참조하는 코드를 제거하고 ParallelCompressor Actor에 추가합시다.

그런 다음 마지막으로, ParallelCompressor에서 compressFile을 호출하기 위해 CompressionState를 업데이트해야 합니다.

이러한 변화로, 우리의 응용 프로그램을 다시 테스트해 봅시다.

다시 한 번, 나는 큰 파일을 우리 애플리케이션에 놓을 것이다.

UI는 더 이상 중단되지 않으며, 이는 큰 개선이지만, 우리는 우리가 기대하는 속도를 얻지 못하고 있다.

우리는 가능한 한 빨리 이 작업을 하기 위해 기계의 모든 코어를 최대한 활용하고 싶습니다.

마이크, 우리가 뭘 더 지켜봐야 해?

마이크: 우리는 주연 배우의 일을 옮겨서 우리의 문제를 해결했지만, 여전히 우리가 원하는 공연을 얻지 못하고 있다.

이유를 알기 위해, 우리는 배우들을 자세히 살펴볼 필요가 있다.

배우들은 공유 상태를 조작하기 위해 여러 작업을 안전하게 만든다.

그러나, 그들은 공유 상태에 대한 접근을 직렬화함으로써 이것을 한다.

한 번에 하나의 작업만 배우를 차지할 수 있으며, 그 배우를 사용해야 하는 다른 작업은 기다릴 것이다.

스위프트 동시성은 구조화되지 않은 작업, 작업 그룹 및 비동기 렛을 사용하여 병렬 계산을 허용합니다.

이상적으로, 이러한 구조는 많은 CPU 코어를 동시에 사용할 수 있다.

그러한 코드에서 배우를 사용할 때, 이러한 작업들 사이에서 공유되는 배우에 대해 많은 양의 작업을 수행하는 것을 조심하십시오.

여러 작업이 동일한 배우를 동시에 사용하려고 할 때, 배우는 해당 작업의 실행을 직렬화합니다.

이 때문에, 우리는 병렬 계산의 성능 이점을 잃는다.

이것은 각 작업이 배우가 가능해질 때까지 기다려야 하기 때문이다.

이 문제를 해결하기 위해, 우리는 액터의 데이터에 대한 독점적인 접근이 필요할 때만 액터에서 작업이 실행되도록 해야 합니다.

다른 모든 것은 배우로부터 도망쳐야 한다.

우리는 그 일을 덩어리로 나눕니다.

어떤 덩어리는 배우에게 달려야 하고, 다른 덩어리는 그렇지 않다.

배우가 아닌 격리된 덩어리는 병렬로 실행될 수 있으며, 이는 컴퓨터가 작업을 훨씬 더 빨리 끝낼 수 있다는 것을 의미합니다.

이것의 데모가 실행 중인 것을 봅시다.

하자스: 고마워, 마이크.

업데이트된 "파일 압착기" 응용 프로그램의 흔적을 살펴보고 마이크가 방금 우리에게 가르쳐준 것을 명심합시다.

작업 요약 보기는 우리의 동시성 코드가 Enqueued 상태에서 놀라운 시간을 보내고 있다는 것을 보여준다.

이것은 우리가 배우에 독점적으로 접근하기 위해 기다리는 많은 작업이 있다는 것을 의미한다.

그 이유를 알아보기 위해 이 작업들 중 하나를 고정해 봅시다.

이 작업은 압축 작업을 실행하기 전에 ParallelCompressor Actor에 들어가기 위해 꽤 많은 시간을 보낸다.

가서 배우를 우리 타임라인에 고정하자.

여기 ParallelCompressor Actor에 대한 최상위 데이터가 있습니다.

이 배우 대기열은 오래 지속되는 작업에 의해 차단되는 것 같다.

작업은 정말로 필요한 만큼 배우에게만 남아 있어야 한다.

작업 이야기로 돌아가자.

ParallelCompressor의 enqueue 후, 작업은 compressAllFiles의 1번 클로저에서 실행됩니다.

그러니 거기서 조사를 시작합시다.

소스 코드는 이 폐쇄가 주로 압축 작업을 실행하고 있다는 것을 보여준다.

compressFile 함수는 ParallelCompressor Actor의 일부이기 때문에, 이 함수의 전체 실행은 Actor에서 발생하며, 다른 모든 압축 작업을 차단합니다.

이 문제를 해결하기 위해, 우리는 compressFile 기능을 액터 격리에서 분리된 작업으로 가져와야 합니다.

이렇게 함으로써, 우리는 관련 가변 상태를 업데이트하는 데 필요한 한 액터에서만 분리된 작업을 할 수 있습니다.

따라서 이제 압축 기능은 액터 보호 상태에 액세스해야 할 때까지 스레드 풀의 모든 스레드에서 자유롭게 실행할 수 있습니다.

예를 들어, '파일' 속성에 액세스해야 할 때, 그것은 메인 액터로 이동할 것이다.

하지만 거기서 끝나자마자, ParallelCompressor Actor로 이동하는 로그 속성에 액세스해야 할 때까지 다시 "동시성의 바다"로 이동합니다.

하지만 다시 말하지만, 그것이 거기서 끝나자마자, 그것은 배우가 다시 스레드 풀에서 실행되도록 떠난다.

하지만 물론, 우리는 압축 작업을 하는 단 하나의 작업이 아니다; 우리는 많은 것을 가지고 있다.

그리고 배우에게 제약을 받지 않음으로써, 그들은 모두 동시에 실행될 수 있으며, 스레드 수에 의해서만 제한됩니다.

물론, 각 배우는 한 번에 하나의 작업만 실행할 수 있지만, 대부분의 경우, 우리의 작업은 배우에 있을 필요가 없습니다.

마이크가 설명했듯이, 이것은 우리의 압축 작업이 병렬로 실행되고 사용 가능한 모든 CPU 코어를 활용할 수 있게 해준다.

그러니 지금 이 변화를 만들자.

우리는 compressFile 기능을 격리되지 않은 것으로 표시할 수 있습니다.

이것은 몇 가지 컴파일러 오류를 초래한다.

그것을 비고립으로 표시함으로써, 우리는 스위프트 컴파일러에게 이 액터의 공유 상태에 접근할 필요가 없다고 말했다.

하지만 그건 완전히 사실이 아니야.

이 로그 기능은 액터 격리되어 있으며 공유 가변 상태에 액세스해야 합니다.

이 문제를 해결하기 위해, 우리는 이 함수를 비동기화한 다음 모든 로그 호출을 await 키워드로 표시해야 합니다.

이제 우리는 분리된 작업을 만들기 위해 작업 생성을 업데이트해야 합니다.

우리는 작업이 만들어진 액터 컨텍스트를 상속받지 않도록 하기 위해 이것을 한다.

분리된 작업의 경우, 우리는 명시적으로 자신을 포착해야 한다.

우리의 응용 프로그램을 다시 테스트해 봅시다.

이 앱은 모든 파일을 동시에 압축할 수 있으며 UI는 반응형으로 유지됩니다.

우리의 개선 사항을 확인하기 위해, 우리는 Swift Actors 악기를 확인할 수 있습니다.

ParallelCompressor Actor를 보면, Actor에서 실행되는 대부분의 작업은 짧은 시간 동안만 진행되며 대기열 크기는 절대 손에서 벗어나지 않습니다.

요약하자면, 우리는 악기를 사용하여 UI 중단의 원인을 분리하고, 더 나은 병렬 처리를 위해 동시성 코드를 재구성했으며, 데이터를 사용하여 성능 개선을 확인했습니다.

이제 마이크는 우리에게 다른 잠재적인 성과 문제에 대해 말할 것이다.

마이크: 우리가 데모에서 본 것 이상으로 다루고 싶은 두 가지 일반적인 문제가 있습니다.

먼저, 스레드 풀 고갈에 대해 이야기해 봅시다.

스레드 풀 고갈은 성능을 해치거나 심지어 애플리케이션의 교착 상태에 있을 수 있다.

스위프트 동시성은 실행 중일 때 작업을 진행해야 한다.

작업이 무언가를 기다릴 때, 그것은 보통 일시 중지함으로써 그렇게 한다.

그러나 작업 내의 코드는 일시 중지하지 않고 파일이나 네트워크 IO를 차단하거나 잠금을 획득하는 것과 같은 차단 호출을 수행할 수 있습니다.

이것은 앞으로 나아가기 위한 작업에 대한 요구 사항을 깨뜨린다.

이런 일이 발생하면, 작업은 실행 중인 스레드를 계속 차지하지만, 실제로는 CPU 코어를 사용하지 않는다.

스레드 풀이 제한되어 있고 일부는 차단되어 있기 때문에, 동시성 런타임은 모든 CPU 코어를 완전히 사용할 수 없습니다.

이것은 수행할 수 있는 병렬 계산의 양과 앱의 최대 성능을 줄입니다.

극단적인 경우, 전체 스레드 풀이 차단된 작업에 의해 점유되고, 스레드 풀에서 실행하기 위해 새로운 작업이 필요한 것을 기다리고 있을 때, 동시성 런타임은 교착 상태가 될 수 있습니다.

작업에서 통화를 차단하는 것을 피하세요.

파일과 네트워크 IO는 비동기 API를 사용하여 수행되어야 합니다.

조건 변수나 세마포를 기다리지 마세요.

세밀하고 짧게 고정된 자물쇠는 필요한 경우 허용되지만, 논쟁이 많거나 오랜 기간 동안 유지되는 자물쇠는 피하십시오.

이러한 작업을 수행하는 데 필요한 코드가 있다면, 예를 들어 디스패치 큐에서 실행하여 동시성 스레드 풀 외부로 코드를 이동하고 연속을 사용하여 동시성 세계로 연결하십시오.

가능할 때마다, 시스템을 원활하게 운영하기 위해 작업을 차단하기 위해 비동기 API를 사용하세요.

연속을 사용할 때, 올바르게 사용하도록 주의해야 합니다.

연속성은 스위프트 동시성과 다른 형태의 비동기 코드 사이의 다리이다.

연속은 현재 작업을 일시 중지하고 호출될 때 작업을 재개하는 콜백을 제공합니다.

그런 다음 콜백 기반 비동기 API와 함께 사용할 수 있습니다.

스위프트 동시성의 관점에서, 작업은 일시 중지되고, 계속이 재개되면 재개된다.

콜백 기반 비동기 API의 관점에서, 작업이 시작되고, 작업이 완료되면 콜백이 호출됩니다.

스위프트 동시성 도구는 연속에 대해 알고 있으며 그에 따라 시간 간격을 표시하여 작업이 계속 호출되기를 기다리고 있음을 보여줍니다.

연속 콜백에는 특별한 요구 사항이 있습니다: 그들은 정확히 한 번, 그 이상, 그 이하로 호출되어야 합니다.

이것은 콜백 기반 API의 일반적인 요구 사항이지만, 비공식적인 경향이 있으며 언어에 의해 시행되지 않으며, 감독이 일반적이다.

신속한 동시성은 이것을 어려운 요구 사항으로 만든다.

콜백이 두 번 호출되면, 프로그램이 충돌하거나 오작동할 것이다.

콜백이 호출되지 않으면, 작업이 유출될 것이다.

이 코드 스니펫에서 우리는 계속을 얻기 위해 withCheckedContinuation을 사용합니다.

그런 다음 콜백 기반 API를 호출합니다.

콜백에서, 우리는 계속을 재개한다.

이것은 정확히 한 번 호출하는 요구 사항을 충족한다.

코드가 더 복잡할 때 조심하는 것이 중요하다.

왼쪽에서, 우리는 성공에 대한 연속을 재개하기 위해 콜백을 수정했습니다.

이건 벌레야.

실패하면, 계속은 재개되지 않을 것이며, 작업은 영원히 중단될 것이다.

오른쪽에서, 우리는 계속을 두 번 재개하고 있다.

이것은 또한 버그이며, 앱은 오작용하거나 충돌할 것이다.

이 두 스니펫 모두 정확히 한 번 계속을 재개해야 한다는 요구 사항을 위반한다.

두 종류의 연속을 사용할 수 있다: 확인되고 안전하지 않다.

성능이 절대적으로 중요하지 않는 한 항상 withCheckedContinuation API를 계속 사용하세요.

확인된 연속은 자동으로 오용을 감지하고 오류를 표시합니다.

체크된 연속이 두 번 호출되면, 연속 함정이 된다.

연속이 전혀 호출되지 않을 때, 연속이 파괴되면 연속이 유출되었다고 경고하는 메시지가 콘솔에 인쇄됩니다.

스위프트 동시성 도구는 연속 상태에서 무기한 갇힌 해당 작업을 보여줄 것이다.

인스트루먼트의 새로운 스위프트 동시성 템플릿에 대해 살펴봐야 할 것이 훨씬 더 많다.

구조화된 동시성의 그래픽 시각화를 얻고, 작업 생성 콜트리를 보고, 정확한 조립 지침을 검사하여 Swift Concurrency 런타임의 전체 그림을 얻을 수 있습니다.

Swift Concurrency가 어떻게 작동하는지에 대해 자세히 알아보려면, 작년 "Swift Concurrency: Behind the Scenes" 세션을 시청하세요.

그리고 데이터 경쟁에 대해 더 알아보려면, "스위프트 동시성을 사용하여 데이터 경쟁을 제거하세요"를 보세요.

봐줘서 고마워!

그리고 동시성 코드를 디버깅하는 것을 즐기세요.