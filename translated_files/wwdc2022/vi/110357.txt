110357

- Xin chào, tôi là Michael Ilseman và tôi là một kỹ sư trong nhóm thư viện tiêu chuẩn Swift.

Tham gia cùng tôi khi chúng ta gặp nhau và làm quen với Regex trong Swift.

Swift Regex có rất nhiều thứ, và chúng tôi sẽ chỉ nếm trải mọi thứ mà nó cung cấp.

Giả sử chúng tôi là các nhà phát triển cộng tác với một số nhà điều tra tài chính trên một công cụ để phân tích các giao dịch về những bất thường.

Bây giờ, bạn sẽ nghĩ rằng đối với một nhiệm vụ quan trọng này, chúng tôi sẽ xử lý dữ liệu có cấu trúc tốt.

Nhưng thay vào đó, chúng tôi có một loạt các chuỗi.

Ở đây trường đầu tiên có loại giao dịch, trường thứ hai là ngày giao dịch, trường thứ ba là cá nhân hoặc tổ chức, trường thứ tư và trường cuối cùng là số tiền bằng đô la Mỹ.

Các trường được phân tách bằng khoảng trắng từ 2 trở lên hoặc tab vì một lý do kỹ thuật rất quan trọng mà không ai liên quan có thể nhớ được.

Và, vâng, trường ngày đó hoàn toàn mơ hồ.

Chúng tôi sẽ chỉ hy vọng rằng đó là tháng/ngày/năm và xem điều gì sẽ xảy ra.

Xử lý các giao dịch này liên quan đến việc xử lý chuỗi và chuỗi là một tập hợp, có nghĩa là chúng tôi có quyền truy cập vào các thuật toán thu thập chung.

Các thuật toán này về cơ bản có hai loại, những thuật toán hoạt động trên các phần tử và những thuật toán hoạt động trên các chỉ số.

Chúng ta có thể thử sử dụng các thuật toán dựa trên phần tử bằng cách tách các trường giao dịch, nhưng dấu phân cách trường là tab hoặc khoảng trắng 2 hoặc nhiều hơn khiến điều này trở nên khó khăn.

Chỉ riêng việc tách trên khoảng trắng không cắt được nó.

Một cách tiếp cận khác là thả xuống mã thao tác chỉ mục cấp thấp.

Nhưng thật khó để làm đúng, và ngay cả khi bạn biết mình đang làm gì, nó vẫn cần rất nhiều mã.

Hãy quay lại để chia tay.

Lý do cách tiếp cận này không hoạt động là vì nó dựa trên phần tử trong khi dấu phân cách trường là một mẫu phức tạp hơn.

Một giải pháp được tìm thấy trong nhiều ngôn ngữ khác nhau là viết một biểu thức chính quy.

Các biểu thức chính quy xuất hiện từ lý thuyết ngôn ngữ chính thức, nơi chúng định nghĩa một ngôn ngữ chính quy.

Họ đã nhập ứng dụng thực tế để tìm kiếm trong các trình soạn thảo và các công cụ dòng lệnh cũng như phân tích từ vựng trong trình biên dịch.

Các ứng dụng này đưa các biểu thức chính quy vượt ra ngoài nguồn gốc lý thuyết của chúng, vì chúng cần trích xuất các phần của đầu vào, kiểm soát và thực thi trực tiếp, và thêm sức mạnh biểu cảm.

Và Swift đang đưa họ đi xa hơn.

Chúng tôi gọi đây là dẫn xuất Regex.

Regex là một cấu trúc chung trên Đầu ra của nó, đó là kết quả của việc áp dụng nó, bao gồm cả việc chụp.

Bạn có thể tạo một cái bằng cách sử dụng một nghĩa đen chứa cú pháp regex ở giữa các dấu phân cách dấu gạch chéo.

Cú pháp regex của Swift tương thích với Perl, Python, Ruby, Java, NSRegularExpression và nhiều, rất nhiều thứ khác.

Regex này khớp với một hoặc nhiều chữ số.

Trình biên dịch biết cú pháp regex, vì vậy bạn sẽ nhận được tô sáng cú pháp, lỗi thời gian biên dịch và thậm chí là chụp được nhập mạnh, mà chúng ta sẽ gặp sau.

Một regex có thể được tạo trong thời gian chạy từ một chuỗi chứa cùng một cú pháp regex.

Điều này hữu ích cho các trường tìm kiếm trong trình soạn thảo hoặc công cụ dòng lệnh.

Điều này sẽ gây ra lỗi trong thời gian chạy nếu đầu vào chứa cú pháp không hợp lệ.

Loại đầu ra là một AnyRegexOutput hiện hữu, bởi vì các loại và số lần chụp sẽ không được biết cho đến thời gian chạy.

Và cùng một regex có thể được viết bằng cách sử dụng trình tạo regex khai báo và có cấu trúc tốt, mặc dù dài dòng hơn.

Hãy điều chỉnh cách tiếp cận phân tách của chúng ta từ trước đó để sử dụng nghĩa đen regex.

Phần đầu tiên khớp với 2 hoặc nhiều lần xuất hiện của bất kỳ ký tự khoảng trắng nào.

Phần thứ hai khớp với một tab nằm ngang duy nhất.

Và ký tự đường ống biểu thị sự lựa chọn giữa các lựa chọn thay thế, cung cấp cho chúng ta một dấu phân cách trường gồm 2 hoặc nhiều khoảng trắng hoặc một tab duy nhất.

Bây giờ các trường của chúng ta đã được phân chia, hãy đóng góp cho chính nền văn minh và bình thường hóa dấu phân cách trường đó thành một tab duy nhất và hoàn thành nó.

Chúng ta có thể gọi 'tham gia' trên kết quả sau khi tách, nhưng có một thuật toán tốt hơn cho điều đó: 'thay thế' cho phép chúng ta thay thế tất cả các dấu phân cách trường bằng một tab duy nhất.

Vì vậy, chúng tôi đi ra ngoài và truyền giáo cách tiếp cận vượt trội rõ ràng của chúng tôi với bất kỳ ai sẽ lắng nghe.

Việc nhận con nuôi là...chậm nhưng đầy hứa hẹn.

Nếu bạn quen thuộc với các biểu thức chính quy, bạn cũng có thể biết về danh tiếng hỗn hợp của chúng.

Như câu nói cũ, "Tôi đã gặp vấn đề, vì vậy tôi đã viết một biểu thức chính quy.

Bây giờ tôi có hai vấn đề."

Nhưng Swift regex thì khác.

Swift thúc đẩy nghệ thuật trong bốn lĩnh vực chính.

Cú pháp Regex ngắn gọn và biểu cảm, nhưng nó có thể trở nên ngắn gọn và khó đọc.

Và các tính năng mới hơn phải sử dụng cú pháp ngày càng khó hiểu.

Swift regexes có thể được cấu trúc và tổ chức theo cách chúng tôi cấu trúc và tổ chức mã nguồn thông qua các trình tạo Regex.

Chữ viết ngắn gọn, các nhà xây dựng đưa ra cấu trúc và các nghĩa đen có thể được sử dụng trong các nhà xây dựng để tìm ra sự cân bằng hoàn hảo đó.

Các biểu diễn văn bản cho dữ liệu đã trở nên phức tạp hơn rất nhiều và việc xử lý chúng một cách chính xác đòi hỏi một trình phân tích cú pháp phù hợp với tiêu chuẩn.

Swift regex cho phép bạn đan xen các trình phân tích cú pháp sức mạnh công nghiệp như các thành phần riêng lẻ của regex.

Điều này được thực hiện theo kiểu mở rộng thư viện, có nghĩa là bất kỳ trình phân tích cú pháp nào cũng có thể tham gia.

Phần lớn lịch sử của các biểu thức chính quy được áp dụng diễn ra trong một thế giới mà toàn bộ hệ thống máy tính chỉ hỗ trợ một ngôn ngữ và mã hóa duy nhất, đáng chú ý nhất là ASCII.

Nhưng thế giới hiện đại là Unicode.

Swift regex thực hiện Unicode mà không ảnh hưởng đến tính biểu cảm.

Và cuối cùng, sức mạnh của các biểu thức chính quy có thể mở ra một không gian tìm kiếm rộng lớn phải được khám phá một cách thấu đáo.

Điều này làm cho việc thực hiện của họ khó lý luận.

Một số ngôn ngữ hỗ trợ điều khiển, nhưng vì chúng nằm sau cú pháp khó hiểu, chúng có xu hướng bị che khuất.

Swift regex cung cấp khả năng thực thi có thể dự đoán được và kiểm soát bề mặt một cách nổi bật.

Hãy quay lại báo cáo tài chính mà chúng tôi đang làm việc và phân tích cú pháp hoàn toàn từng giao dịch bằng cách sử dụng trình tạo Regex, một cách tiếp cận khai báo để xử lý chuỗi trong Swift.

Chúng tôi sẽ nhập mô-đun RegexBuilder để bắt đầu.

Chúng ta có thể sử dụng lại dấu phân cách trường regex mà chúng ta vừa xác định.

Trường đầu tiên rất đơn giản; đó là TÍN DỤNG hoặc NỢ.

Chúng ta có thể sử dụng cú pháp theo nghĩa đen regex mà chúng ta đã thấy để viết nó.

Sau đó là một dấu phân cách trường, và sau đó là ngày tháng.

Phân tích cú pháp ngày tháng bằng tay là một ý tưởng tồi.

Foundation có trình phân tích cú pháp thực sự tốt cho các loại như ngày tháng, số và URL và chúng ta có thể sử dụng chúng trực tiếp trong Trình tạo Regex.

Chúng tôi cung cấp một ngôn ngữ rõ ràng, đó là dự đoán tốt nhất của chúng tôi về ý định của tác giả.

Chúng tôi làm điều này thay vì ngầm sử dụng ngôn ngữ hiện tại của hệ thống.

Chúng tôi luôn có thể thay đổi nó sau này, và điều đó thật dễ dàng để thực hiện bởi vì chúng tôi đã đưa ra các giả định của mình _rõ ràng_ trong mã.

Trường thứ ba có thể là "bất cứ thứ gì", vì vậy thật hấp dẫn khi chỉ viết "một hoặc nhiều thứ."

Và mặc dù điều đó sẽ cho chúng ta câu trả lời đúng, nhưng nó thực hiện rất nhiều công việc không cần thiết trước tiên, bởi vì nó bắt đầu bằng cách kết hợp bất kỳ thứ gì khác xảy ra sau nó.

Regex sẽ sao lưu từng ký tự một và thử phần còn lại của mẫu.

Chúng tôi muốn yêu cầu regex dừng lại khi nó nhìn thấy dấu phân cách trường kết thúc.

Có khá nhiều cách để chúng ta có thể hoàn thành việc này.

Một cách hay để làm điều này là sử dụng NegativeLookahead để xem qua phần tiếp theo của đầu vào mà không thực sự tiêu thụ nó.

Ở đây chúng tôi xem qua đầu vào để đảm bảo dấu phân cách trường không xuất hiện trước khi khớp với bất kỳ ký tự nào.

NegativeLookahead là một trong những công cụ cho phép bạn kiểm soát chính xác cách Regex khớp với các thành phần của nó.

Cuối cùng, chúng tôi khớp số tiền, một lần nữa sử dụng một trong những trình phân tích cú pháp của Foundation, lần này là tiền tệ.

Chúng tôi đã giả định rằng dấu phẩy là dấu phân cách hàng nghìn trong khi dấu chấm là dấu phân cách thập phân và chúng tôi đưa ra giả định này rõ ràng.

Chúng tôi đã xây dựng một regex cho phép chúng tôi phân tích cú pháp một dòng từ sổ cái giao dịch.

Chúng tôi không chỉ muốn nhận ra các dòng. Chúng tôi muốn trích xuất một số dữ liệu này.

Để làm điều này, chúng tôi sử dụng captures, trích xuất các phần đầu vào của chúng tôi để xử lý sau này.

Theo quy ước, chụp 'thứ 0' là một phần của đầu vào mà toàn bộ regex khớp và mỗi lần chụp rõ ràng theo sau.

Loại giao dịch của chúng tôi được ghi lại dưới dạng Chuỗi con là một phần đầu vào của chúng tôi.

Đối với ngày tháng, chúng tôi thực sự nắm bắt được giá trị được nhập mạnh đã được phân tích cú pháp mà không cần phải xử lý hậu kỳ văn bản.

Cá nhân hoặc tổ chức một lần nữa được nắm bắt như một phần đầu vào của chúng tôi và việc nắm bắt thập phân là một giá trị được nhập mạnh khác.

Để sử dụng nó, chúng tôi trích xuất các giá trị ngày và thập phân từ kết quả khớp và các nhà điều tra lấy nó từ đây.

Tại thời điểm này, chúng tôi khuyên họ nên đổ dữ liệu vào cơ sở dữ liệu thực để có những lợi ích rõ ràng như truy vấn có cấu trúc.

Họ có một... ý kiến khác nhau.

Họ muốn giữ mọi thứ như những sợi dây.

Đó là tin tốt cho cuộc nói chuyện này bởi vì chúng ta có thể thấy nhiều hơn về Swift Regex.

Mọi thứ đang diễn ra tốt đẹp cho đến khi đột nhiên nó không diễn ra.

Chúng tôi vừa biết rằng thứ tự ngày trong văn bản giao dịch, mà chúng tôi đã nói với mọi người là hoàn toàn mơ hồ, trên thực tế là không rõ ràng.

Nó không phải lúc nào cũng giống nhau, và lý thuyết hàng đầu là nó phụ thuộc vào loại tiền tệ được sử dụng trong giao dịch.

Bởi vì tất nhiên là có.

Điều này có nghĩa là đô la Mỹ là tháng/ngày/năm và bảng Anh là ngày/tháng/năm.

Vì vậy, hãy viết một kịch bản giống như sed để định rõ điều này.

Đối với regex của chúng tôi, chúng tôi sẽ sử dụng một dấu phân cách mở rộng.

Điều này cho phép chúng ta có những dấu gạch chéo bên trong mà không cần phải thoát khỏi chúng.

Điều này cũng cho phép chúng tôi truy cập vào chế độ cú pháp mở rộng trong đó khoảng trắng bị bỏ qua, có nghĩa là chúng tôi có thể sử dụng khoảng trắng để dễ đọc, giống như trong mã thông thường.

Chúng tôi đã sử dụng các ảnh chụp có tên, hiển thị trong đầu ra của Regex dưới dạng nhãn bộ.

Và chúng tôi sử dụng Thuộc tính Unicode để nhận dạng các ký hiệu tiền tệ.

Điều này làm cho regex của chúng tôi dễ thích nghi hơn; chúng tôi sẽ xử lý các ký hiệu cụ thể trong logic ứng dụng.

Thay vì cố gắng cắt và ghép văn bản theo cách thủ công, chúng tôi sẽ lại sử dụng trình phân tích cú pháp ngày của Foundation.

pickStrategy nhận biểu tượng tiền tệ và sẽ xác định chiến lược phân tích cú pháp dựa trên nó.

Tất cả các giả định của chúng tôi đều rõ ràng trong mã, điều này giúp dễ dàng thích nghi và phát triển hơn, điều mà cuối cùng chúng tôi gần như chắc chắn sẽ cần.

Hãy sử dụng chức năng regex và helper của chúng tôi với thuật toán tìm và thay thế bằng cách cung cấp đóng sử dụng kết quả khớp, bao gồm cả chụp, để xây dựng chuỗi thay thế.

Chúng tôi chọn một chiến lược dựa trên đồng tiền bị bắt và phân tích ngày bị bắt.

Chúng ta có thể truy cập các bức ảnh chụp theo tên, thay vì chỉ theo vị trí.

Đối với đầu ra của chúng tôi, chúng tôi sẽ định dạng ngày mới bằng cách sử dụng ISO-8601, một tiêu chuẩn công nghiệp rõ ràng.

Công cụ của chúng tôi biến sổ cái này thành một cái rõ ràng.

Bởi vì chúng tôi đang sử dụng trình phân tích cú pháp và định dạng ngày thực, chúng tôi thích nghi hơn nhiều với các yêu cầu thay đổi.

Và sử dụng thuộc tính Unicode để nhận dạng các ký hiệu tiền tệ giúp chúng ta phát triển nhanh hơn nhiều.

Một regex khai báo một thuật toán trên một số mô hình của Chuỗi.

Swift's String trình bày nhiều mô hình để làm việc với Unicode.

Chuỗi này, đại diện cho một câu chuyện tình yêu cho các lứa tuổi, chứa 3 nhân vật.

Những ký tự này là những thực thể phức tạp chính thức được gọi là cụm đồ thị mở rộng Unicode.

Một ký tự duy nhất bao gồm một hoặc nhiều giá trị vô hướng Unicode.

Chuỗi cung cấp UnicodeScalarView để truy cập biểu diễn cấp thấp hơn này của nội dung của nó.

Điều này cho phép sử dụng nâng cao cũng như khả năng tương thích với các hệ thống khác.

Nhân vật đầu tiên của chúng ta, nhân vật chính trong câu chuyện của chúng ta, bao gồm 4 vô hướng Unicode: ZOMBIE, Zero Width Joiner, FEMALE SIGN, và uh...

VARIATION SELECTOR-16, trong bối cảnh này báo hiệu một sở thích được hiển thị dưới dạng biểu tượng cảm xúc.

Tất nhiên rồi!

Những vô hướng này tạo ra biểu tượng cảm xúc duy nhất mà chúng ta nhìn thấy trực quan.

Khi các chuỗi được lưu trữ trong bộ nhớ, chúng được mã hóa dưới dạng UTF-8 byte.

Chúng ta có thể xem các byte này bằng chế độ xem UTF-8.

UTF-8 là một mã hóa có chiều rộng thay đổi, có nghĩa là nhiều byte có thể cần thiết cho một vô hướng duy nhất và như chúng ta đã thấy, có thể cần nhiều vô hướng cho một ký tự duy nhất.

Nhân vật chính của câu chuyện của chúng tôi, được đại diện bởi 4 vô hướng Unicode, được mã hóa bằng 13 UTF-8 byte.

Ngoài việc bao gồm nhiều vô hướng, cùng một ký tự chính xác đôi khi có thể được biểu diễn bằng các bộ vô hướng khác nhau.

Điều này xuất hiện rất nhiều khi xử lý các ngôn ngữ khác ngoài tiếng Anh.

Trong ví dụ này, chữ 'e' với trọng âm cấp tính có thể được biểu diễn dưới dạng một vô hướng duy nhất, được tạo sẵn 'e' với trọng âm cấp tính hoặc dưới dạng ASCII 'e' theo sau là giọng cấp tính kết hợp.

Đây là những ký tự giống nhau, vì vậy so sánh Chuỗi sẽ trả về true.

Điều này là do String tuân theo cái được gọi chính thức là Unicode Canonical Equivalence.

Từ góc nhìn của UnicodeScalarView, hoặc chế độ xem UTF-8, nội dung khác nhau và chúng tôi thấy sự khác biệt này khi chúng tôi so sánh trong các chế độ xem cấp thấp hơn này.

Cũng giống như String, Swift regex bị ám ảnh bởi Unicode chính xác theo mặc định.

Nhưng nó làm điều này mà không ảnh hưởng đến tính biểu cảm.

Hãy chuyển qua một cặp dây.

Đối với chuỗi đầu tiên, chúng ta sẽ khớp với Unicode Scalar SPARKLING HEART có tên được bao quanh bởi bất kỳ ký tự nào được ký hiệu bằng dấu chấm (.).

Bất kỳ lớp ký tự nào cũng sẽ khớp với bất kỳ ký tự Swift nào; nghĩa là, bất kỳ cụm đồ thị mở rộng Unicode nào.

Đối với chuỗi thứ hai, các ký tự bằng nhau so sánh bằng nhau...

Và chúng ta có thể bỏ qua trường hợp.

Và bây giờ câu chuyện tình yêu đơn giản của chúng ta đã trở nên phức tạp hơn rất nhiều.

Đôi khi cuộc sống, hoặc trong trường hợp này là cuộc sống, có những phức tạp mà chúng ta cần xử lý.

Cũng giống như String, nếu bạn cần tự xử lý các giá trị vô hướng Unicode, để tương thích hoặc độ chính xác của cụm đồ thị phụ, bạn có thể bằng cách khớp với ngữ nghĩa 'unicodeScalar'.

Khi chúng ta khớp ở cấp độ Vô hướng Unicode, dấu chấm khớp với một giá trị Vô hướng Unicode duy nhất thay vì một Ký tự Swift đầy đủ.

Điều đó có nghĩa là chúng ta có thể gặp lại bạn của mình: VARIATION-SELECTOR 16.

Bộ chọn nhỏ thân thiện này được khớp bởi dấu chấm và bạn không thể nhìn thấy nó bởi vì khi tất cả chỉ có một mình, nó hiển thị dưới dạng khoảng trắng trống.

Rất hữu ích.

Bây giờ chúng ta đã làm việc với độ chính xác và chính xác, hãy làm điều gì đó khác biệt một chút và quay trở lại với tài chính.

Các nhà điều tra đã quay trở lại, và lần này họ có một yêu cầu thú vị.

Họ đã sửa đổi công cụ khớp giao dịch của chúng tôi để đánh hơi các giao dịch trực tiếp thay vì xử lý sổ cái sau khi thực tế.

Nhìn vào mã của họ, họ thực sự đã làm một công việc khá tốt, nhưng họ đang phải đối mặt với các vấn đề về quy mô và cần sự giúp đỡ của chúng tôi.

Các giao dịch mà họ đang xử lý rất giống nhau, nhưng có những khác biệt nhỏ.

Thay vì một ngày tháng, thay vào đó họ có một dấu thời gian chính xác.

Điều này được thể hiện ở một định dạng rõ ràng, rõ ràng và độc quyền gây sốc.

Họ có một cách diễn đạt chính quy được viết trong một thế kỷ trước phù hợp với điều này.

Không sao đâu.

Tiếp theo họ có một trường chi tiết bao gồm các cá nhân và mã nhận dạng.

Họ lọc các giao dịch dựa trên trường này bằng cách sử dụng regex biên dịch thời gian chạy có nguồn gốc từ đầu vào.

Bởi vì điều này đang hoạt động, và có nhiều lĩnh vực hơn sau này, họ muốn bảo lãnh sớm cho bất kỳ giao dịch không thú vị nào.

Sau đó là một số tiền và các trường khác như tổng kiểm tra, mà họ tự xử lý tốt.

Và tất nhiên, các trường vẫn cách nhau 2 hoặc nhiều khoảng trắng hoặc một tab.

Người đối sánh giao dịch của họ trông rất giống của chúng tôi.

Họ có regex riêng cho dấu thời gian, regex chi tiết của họ được biên dịch từ đầu vào và họ xử lý các trường còn lại.

Họ đã làm một công việc khá tốt. Mọi thứ đều hoạt động về mặt kỹ thuật.

Nó chỉ không mở rộng quy mô tốt.

Họ nhận thấy rằng dấu thời gian và các regexe chi tiết của họ thường khớp với nhiều đầu vào hơn các trường của họ.

Lý tưởng nhất, các regexes này sẽ bị hạn chế chỉ chạy trên một trường duy nhất.

Chúng tôi đã xử lý một vấn đề tương tự trong dự án của mình bằng cách sử dụng cái nhìn tiêu cực về phía trước, vì vậy hãy kéo regex đó vào.

'Trường' sẽ khớp hiệu quả với bất kỳ ký tự nào cho đến khi nó gặp dấu phân cách trường và chúng tôi muốn sử dụng nó để chứa các regexes của chúng.

Chúng tôi có thể làm điều này như một bước xử lý hậu kỳ, nhưng vì điều này đang chạy trực tiếp, chúng tôi muốn bảo lãnh sớm nếu các regexes này không khớp với trường của chúng.

Chúng ta có thể làm điều này bằng cách sử dụng TryCapture.

TryCapture vượt qua trường phù hợp để đóng cửa của chúng tôi, nơi chúng tôi kiểm tra theo dấu thời gian của điều tra viên và các quy định chi tiết.

Nếu chúng khớp, chúng tôi trả về giá trị của trường, có nghĩa là khớp đã thành công và trường được ghi lại.

Nếu không, chúng tôi trả về số không, báo hiệu rằng việc khớp không thành công.

Việc đóng cửa của TryCapture tích cực tham gia vào việc kết hợp, đó chính xác là những gì chúng tôi cần.

Và với điều này, chúng tôi đã giải quyết được một vấn đề mở rộng quy mô lớn.

Nhưng vẫn còn một vấn đề nữa: khi một cái gì đó sau này trong trình đối sánh giao dịch không thành công, có thể mất nhiều thời gian để thoát.

FieldSeparator regex của chúng tôi mà chúng tôi đã xác định ngay từ đầu khớp với 2 hoặc nhiều khoảng trắng hoặc một tab, đó là những gì chúng tôi muốn.

Nếu có 8 ký tự khoảng trắng, nó sẽ khớp với tất cả chúng trước khi thử phần còn lại của regex.

Nhưng nếu regex sau đó thất bại, nó sẽ sao lưu và chỉ khớp với 7 ký tự khoảng trắng trước khi thử lại.

Và nếu điều đó không thành công, nó sẽ chỉ khớp với 6 ký tự khoảng trắng, v.v.

Chỉ sau khi thử tất cả các lựa chọn thay thế thì việc kết hợp mới thất bại.

Việc sao lưu này để thử các lựa chọn thay thế được gọi là quay lại toàn cầu hoặc, theo logic chính thức, đóng Kleene.

Đó là những gì mang lại cho các biểu thức chính quy sức mạnh đặc trưng của chúng.

Nhưng nó mở ra một không gian tìm kiếm rộng lớn để khám phá, và ở đây chúng tôi muốn một không gian tìm kiếm tuyến tính hơn.

Chúng tôi muốn khớp tất cả các khoảng trắng và không bao giờ từ bỏ bất kỳ khoảng trắng nào.

Có một vài công cụ mà chúng ta có thể sử dụng; công cụ tổng quát hơn là đặt fieldSeparator trong phạm vi quay lại cục bộ thay vì phạm vi toàn cầu.

Trình tạo cục bộ tạo ra một phạm vi trong đó, nếu regex chứa khớp thành công, mọi lựa chọn thay thế chưa được thử sẽ bị loại bỏ.

Ngay cả khi trình đối sánh giao dịch của chúng tôi thất bại sau này, chúng tôi không quay lại để cố gắng tiêu thụ ít không gian hơn.

Quay lại toàn cầu, mặc định cho regex, rất tốt cho tìm kiếm và kết hợp mờ.

Local rất hữu ích để khớp các mã thông báo được chỉ định chính xác.

Dấu phân cách trường, dù nó có thể gây khó chịu, là chính xác.

Địa phương được biết đến ở những nơi khác như một nhóm không bắt giữ nguyên tử, có thể là một... cái tên đáng sợ.

Làm cho nó có vẻ như regex của bạn có thể nổ tung.

Nhưng nó thực sự làm ngược lại-- nó chứa không gian tìm kiếm.

Và với điều này, chúng tôi đã giúp họ giải quyết các vấn đề mở rộng quy mô của họ.

Hôm nay chúng tôi phải gặp Swift Regex, nhưng còn rất nhiều thứ nữa mà chúng tôi không thể đề cập đến.

Hãy chắc chắn kiểm tra Swift Regex: Beyond the Basics của đồng nghiệp Richard của tôi.

Trước khi chúng ta rời đi, tôi muốn nhấn mạnh một vài điểm.

Các nhà xây dựng Regex đưa ra cấu trúc. Các ký tự Regex ngắn gọn.

Sự lựa chọn giữa thời điểm sử dụng cái này và cái kia cuối cùng sẽ mang tính chủ quan.

Đảm bảo sử dụng trình phân tích cú pháp thực bất cứ khi nào có thể.

Điều này sẽ giúp bạn tiết kiệm rất nhiều thời gian và tránh đau đầu.

Chỉ bằng cách sử dụng mặc định của Swift, bạn sẽ nhận được nhiều sự hỗ trợ và tốt đẹp của Unicode hơn bất kỳ nơi nào khác.

Tìm cách sử dụng những thứ như thuộc tính ký tự một cách hiệu quả, chẳng hạn như khi chúng tôi khớp các ký hiệu tiền tệ.

Và cuối cùng, đơn giản hóa các thuật toán tìm kiếm và xử lý của bạn bằng cách sử dụng các điều khiển như phạm vi tìm kiếm và quay lại cục bộ.

Cảm ơn bạn đã xem.