10108

♪ ♪

Felix Acero: Xin chào, tên tôi là Felix Acero, và tôi là Kỹ sư phần mềm của nhóm Kiến trúc và Kỹ thuật Bảo mật.

Trong video này, tôi sẽ chỉ cho bạn cách bạn có thể sử dụng khung LocalAuthentication để cải thiện quy trình xác thực và ủy quyền cho ứng dụng của bạn.

Chúng tôi sẽ bắt đầu bằng cách xem xét các khái niệm chung về xác thực và ủy quyền và cách chúng áp dụng cho ứng dụng của bạn.

Sau đó, chúng tôi sẽ xem xét cách API LocalAuthentication hiện có, và đặc biệt là LAContext, có thể giúp bạn thực hiện một loạt các sơ đồ ủy quyền.

Và cuối cùng chúng ta sẽ xem các API mới mà chúng ta đang thêm vào LocalAuthentication năm nay có thể giúp bạn hợp lý hóa hơn nữa mã ủy quyền của mình như thế nào.

Vì vậy, hãy bắt đầu bằng cách nói về xác thực và ủy quyền.

Xác thực và ủy quyền là những khái niệm bảo mật khác biệt nhưng có liên quan chặt chẽ.

Một mặt, xác thực là hành động xác minh danh tính của người dùng.

Mặt khác, ủy quyền là hành động xác minh xem một người dùng nhất định có được phép thực hiện một hoạt động cụ thể trên một tài nguyên cụ thể hay không.

Tổng hợp lại, chúng ta có thể thấy rằng, vì trước tiên chúng ta cần xác minh rằng người dùng là người mà họ tuyên bố trước khi chúng ta có thể đánh giá những tài nguyên và hoạt động nào có sẵn cho họ, chúng ta có thể nói rằng xác thực trên thực tế cho phép ủy quyền.

Để giúp minh họa các khái niệm này, hãy xem xét một ví dụ cụ thể liên quan đến tài nguyên bảo mật chung được quản lý bởi các ứng dụng của bạn, chẳng hạn như các khóa Secure Enclave.

Các khóa Secure Enclave là các loại khóa bất đối xứng đặc biệt được liên kết với một thiết bị cụ thể và được bảo vệ bởi trình quản lý khóa dựa trên phần cứng được cách ly với bộ xử lý chính.

Điều làm cho các khóa này trở nên đặc biệt là khi bạn lưu trữ khóa riêng tư trong Secure Enclave, bạn không bao giờ thực sự xử lý khóa mà thay vào đó hướng dẫn Secure Enclave thực hiện các thao tác với nó.

Các khóa Secure Enclave có thể được liên kết với danh sách kiểm soát truy cập hoặc viết tắt là ACL.

Danh sách kiểm soát truy cập chỉ định các yêu cầu cần được thỏa mãn để thực hiện các thao tác cụ thể như ký hoặc giải mã một đốm màu.

Họ có thể chỉ định khi nào một mục nhất định có sẵn, ví dụ như sau khi mở khóa thiết bị, cũng như các yêu cầu xác thực cần thiết để cho phép thực hiện một số thao tác nhất định.

Đối với ví dụ này, giả sử rằng ứng dụng của bạn muốn bảo vệ các hoạt động ký hiệu và giải mã của khóa bằng xác thực sinh trắc học, đồng thời đảm bảo rằng khóa chỉ khả dụng sau khi thiết bị đã được mở khóa.

Bây giờ hãy xem quy trình ủy quyền sẽ trông như thế nào đối với một hoạt động ký hiệu liên quan đến khóa này.

Đầu tiên, ứng dụng của bạn đưa ra yêu cầu ký một đốm màu bằng khóa riêng tư.

Sau đó, sau khi xác minh rằng ứng dụng của bạn có thể truy cập khóa, hệ thống tiến hành xác định các yêu cầu ủy quyền cho hoạt động ký hiệu.

Trong trường hợp này, thao tác ký hiệu yêu cầu xác thực sinh trắc học thành công từ bất kỳ người dùng nào hiện đang đăng ký.

Hệ thống sau đó sẽ hướng dẫn người dùng qua quy trình xác thực sinh trắc học thông qua giao diện người dùng tiêu chuẩn.

Sau khi xác thực thành công, hệ thống xác minh rằng tất cả các yêu cầu ủy quyền còn lại đã được thỏa mãn trước khi cuối cùng thực hiện thao tác ký hiệu và trả lại một đốm màu đã ký cho ứng dụng của bạn.

Hãy chia nhỏ các thành phần chính liên quan đến luồng này để xem chúng phù hợp với định nghĩa ban đầu của chúng ta như thế nào.

Đầu tiên, chúng tôi có một tài nguyên: khóa Secure Enclave.

Thứ hai, chúng tôi có một thao tác có thể được thực hiện bằng chìa khóa.

Và thứ ba, chúng tôi có một bộ yêu cầu, trong số những thứ khác, chỉ định ai được phép thực hiện thao tác cũng như các phương tiện xác thực nên được sử dụng để xác minh danh tính của họ.

Cắm các thông số của ví dụ này vào định nghĩa của chúng tôi, chúng tôi có thể thấy rằng để xác thực, câu hỏi liệu đây có phải là người dùng phù hợp hay không được trả lời bằng phương tiện xác thực sinh trắc học; trong khi để ủy quyền, câu hỏi liệu người dùng có được phép thực hiện thao tác chữ ký bằng khóa riêng hay không được trả lời bằng cách

Bây giờ chúng ta đã thấy cách điều này hoạt động ở cấp độ cao, chúng ta có thể xem cách một luồng như thế này có thể được thực hiện bằng cách sử dụng API hiện tại của LocalAuthentication.

Hãy bắt đầu bằng cách nhanh chóng xem xét các tính năng được cung cấp bởi LAContext, đây là một trong những thành phần cốt lõi của khuôn khổ.

Một LAContext có thể được sử dụng để đánh giá danh tính của người dùng.

Nó xử lý sự tương tác của người dùng khi yêu cầu xác thực sinh trắc học hoặc mật mã.

Và nó cũng giao tiếp với Secure Enclave để cho phép quản lý an toàn dữ liệu sinh trắc học.

Từ quan điểm này, LAContext có thể được sử dụng để hỗ trợ các trường hợp sử dụng xác thực của bạn.

LAContext cũng có thể được sử dụng kết hợp với các khuôn khổ khác để hỗ trợ các luồng ủy quyền.

Ví dụ, bạn có thể sử dụng nó để đánh giá danh sách kiểm soát truy cập giống như danh sách chúng ta đã thấy trong ví dụ trước.

Chúng ta hãy xem xét kỹ hơn.

Điều đầu tiên chúng ta cần làm là truy cập ACL được liên kết với khóa riêng tư của chúng ta.

Chúng tôi có thể làm điều này với sự trợ giúp của SecItemCopyMatching API được cung cấp bởi khung Bảo mật, đảm bảo rằng chúng tôi cung cấp khóa thuộc tính trả về bên trong truy vấn của mình.

Khi chúng tôi có quyền truy cập vào danh sách kiểm soát truy cập, chúng tôi có thể đánh giá nó trực tiếp bằng cách sử dụng LAContext và evaluateAccessControl API.

Lợi thế lớn nhất mà cách tiếp cận này mang lại cho bạn là nó cho phép bạn quyết định đúng thời điểm và đúng vị trí trong ứng dụng của mình để nhắc người dùng ủy quyền này.

Trong trường hợp này, vì danh sách kiểm soát truy cập yêu cầu xác thực sinh trắc học cho hoạt động chữ ký, LAContext sẽ trình bày Face ID hoặc Touch ID UI quen thuộc.

Khi ACL đã được ủy quyền bên trong LAContext của chúng tôi, chúng tôi sẽ có thể sử dụng nó như một phần của truy vấn để có được tham chiếu đến khóa của chúng tôi.

Chúng tôi làm điều này bằng cách thêm LAContext vào truy vấn SecItem của chúng tôi dưới khóa use-authentication-context.

Bằng cách liên kết LAContext với tham chiếu khóa riêng của chúng tôi, chúng tôi đảm bảo rằng việc thực hiện thao tác chữ ký sẽ không kích hoạt xác thực khác, đồng thời cho phép thao tác tiếp tục mà không có lời nhắc không cần thiết.

Những ràng buộc này cũng có nghĩa là sẽ không cần tương tác người dùng bổ sung cho các chữ ký trong tương lai cho đến khi LAContext bị vô hiệu.

LAContext cung cấp rất nhiều tính linh hoạt và nó cho phép bạn kiểm soát từng bước và thông số liên quan đến quy trình ủy quyền của bạn.

Nó có thể được sử dụng kết hợp với các khung khác như khung Bảo mật, từ đó mở ra một loạt các trường hợp sử dụng.

Tuy nhiên, tính linh hoạt này phải trả giá bằng độ phức tạp mã cao hơn, đòi hỏi bạn phải điều phối cẩn thận các API được cung cấp bởi một số khuôn khổ.

Tùy thuộc vào trường hợp sử dụng của bạn, LAContext có thể là công cụ phù hợp với bạn, đặc biệt nếu đề xuất giá trị chính của ứng dụng của bạn yêu cầu quyền truy cập cấp thấp vào các khóa, bí mật, ngữ cảnh và danh sách kiểm soát truy cập.

Tuy nhiên, nếu tất cả những gì bạn cần cho ứng dụng của mình là một cách cho phép truy cập vào nội dung hoặc tài nguyên nhạy cảm, thì bạn có thể muốn đánh đổi một số tính linh hoạt này để lấy một API đơn giản hơn.

Điều này đưa chúng ta đến chủ đề cuối cùng của chúng ta, hợp lý hóa ứng dụng của bạn.

Mới sử dụng iOS 16 và macOS 13, LocalAuthentication đang giới thiệu API tập trung vào ủy quyền, cấp độ cao hơn.

API mới được xây dựng dựa trên các khái niệm hiện có trong LocalAuthentication như LAContext và hướng tới việc đơn giản hóa việc triển khai các luồng ủy quyền chung, cho phép bạn tập trung tất cả năng lượng của mình vào đề xuất giá trị cốt lõi của các ứng dụng.

Sự trừu tượng quan trọng nhất được giới thiệu bởi API mới là LARight.

Trường hợp sử dụng đơn giản nhất mà bạn có thể cung cấp LARight là giúp bạn ủy quyền các hoạt động trên các tài nguyên được xác định bởi ứng dụng.

Ví dụ: bạn có thể sử dụng quyền để giúp bạn truy cập vào phần hồ sơ người dùng của ứng dụng bằng cách trước tiên yêu cầu xác thực sinh trắc học thành công từ người dùng của bạn.

Theo mặc định, các quyền được bảo vệ bởi một tập hợp các yêu cầu xác thực cho phép người dùng của bạn xác thực bằng Touch ID, Face ID, Apple Watch hoặc mật mã thiết bị của họ tùy thuộc vào thiết bị họ đang sử dụng.

Bạn cũng có thể chọn liên kết các quyền của mình với các yêu cầu chi tiết hơn, điều này cho phép bạn hạn chế hơn nữa các phương tiện xác thực.

Hãy xem cách chúng ta có thể sử dụng LARights trong mã.

Điều đầu tiên chúng ta cần làm là khởi tạo quyền của mình.

Chúng tôi làm điều này bằng cách xác định các yêu cầu của nó.

Trong trường hợp này, quyền đăng nhập của chúng tôi sẽ yêu cầu người dùng xác thực bằng phép đo sinh học hoặc cung cấp mật mã thiết bị.

Sau đó chúng tôi tiến hành xác minh rằng người dùng hiện tại có thể có quyền đăng nhập.

Chúng tôi sử dụng thông tin này để xác định xem chúng tôi có thể tiếp tục với hoạt động đăng nhập hay thay vào đó chúng tôi cần chuyển hướng người dùng đến phần công khai của ứng dụng của chúng tôi.

Cuối cùng, chúng ta có thể tiến hành hoạt động ủy quyền thực tế cung cấp một lý do cục bộ sẽ hiển thị cho người dùng trong giao diện người dùng ủy quyền.

Khi ủy quyền quyền theo cách này, một giao diện người dùng hoàn toàn mới, dựa trên hệ thống sẽ được trình bày.

Giao diện người dùng được hiển thị bên trong cửa sổ ứng dụng của bạn và cung cấp cho người dùng thông tin liên quan để giúp họ hiểu nguồn gốc và mục đích của hoạt động.

Chúng tôi tin rằng giao diện mới sẽ cho phép bạn tạo ra các luồng ủy quyền tích hợp liền mạch hơn với ứng dụng của bạn và cung cấp nhiều ngữ cảnh và thông tin hơn cho người dùng của bạn.

Bây giờ chúng ta đã thấy cách tạo và ủy quyền quyền, chúng ta hãy xem xét kỹ hơn vòng đời của nó.

Quyền bắt đầu vòng đời của chúng ở một trạng thái không xác định.

Ngay sau khi đơn đăng ký của bạn đưa ra yêu cầu ủy quyền, trạng thái của quyền sẽ thay đổi thành ủy quyền.

Tại thời điểm này, người dùng sẽ được trình bày với giao diện người dùng ủy quyền mà chúng ta đã thấy trong trang chiếu trước.

Tùy thuộc vào sự thành công hay thất bại của hoạt động, quyền có thể chuyển sang trạng thái được ủy quyền hoặc không được ủy quyền.

Đây là quá trình chuyển đổi trạng thái quan trọng nhất cho đơn đăng ký của bạn.

Cuối cùng, quyền cũng có thể chuyển từ trạng thái được ủy quyền sang trạng thái không được ủy quyền.

Điều này xảy ra khi ứng dụng của bạn đưa ra yêu cầu hủy ủy quyền một cách rõ ràng ở bên phải hoặc khi trường hợp phù hợp được phân bổ.

Hãy chắc chắn giữ một tham chiếu mạnh mẽ đến quyền của bạn để duy trì trạng thái được ủy quyền của nó.

Sau khi quyền đã bị hủy cấp phép, ứng dụng của bạn có thể tiếp tục đưa ra các yêu cầu ủy quyền để khởi động lại chu kỳ.

Tất cả các chuyển đổi trạng thái trước đó có thể được truy vấn và quan sát.

Nếu bạn có quyền truy cập vào phiên bản LARight, bạn có thể truy vấn trực tiếp thuộc tính trạng thái của nó.

Bạn cũng có thể quan sát tất cả các chuyển đổi trạng thái bằng cách sử dụng KVO hoặc Combine.

Ngoài ra, nếu ứng dụng của bạn xử lý một số quyền, bạn có thể quan sát trạng thái của tất cả chúng từ một nơi duy nhất bằng cách nghe thông báo didBecomeAuthorized và didBecomeUnauthorized, được xuất bản lên Trung tâm thông báo mặc định sau khi phát hiện thay đổi trạng thái ủy quyền.

Trước khi chúng ta tiếp tục, hãy quay lại ví dụ của chúng ta và thêm thao tác đăng xuất để hủy ủy quyền đăng nhập của chúng ta.

Bằng cách này, chúng tôi đảm bảo rằng một ủy quyền mới sẽ được yêu cầu vào lần đăng nhập tiếp theo khi người dùng muốn đăng nhập.

Cho đến nay, chúng tôi đã thấy cách sử dụng các trường hợp phù hợp để ủy quyền các hoạt động trên các tài nguyên do ứng dụng xác định.

Chúng tôi cũng đã thấy vòng đời và trạng thái của các quyền này cuối cùng gắn liền với thời gian chạy như thế nào, điều đó có nghĩa là trên mỗi phiên của ứng dụng của bạn, bạn cần khởi tạo và định cấu hình các quyền này một cách chính xác.

Vì vậy, chúng ta hãy xem cách các quyền có thể được duy trì và loại khả năng nào mà điều này cho phép cho ứng dụng của bạn.

LARights có thể được duy trì với sự trợ giúp của đúng cửa hàng.

Khi vẫn tồn tại, các quyền được hỗ trợ bởi khóa Secure Enclave duy nhất được bảo vệ bằng danh sách kiểm soát truy cập hoặc ACL phù hợp với các yêu cầu ủy quyền của quyền.

Cách tiếp cận này giúp chúng tôi đảm bảo rằng các yêu cầu ủy quyền sẽ vẫn bất biến sau khi quyền đã được duy trì.

Bạn cũng có thể truy cập khóa riêng tư hỗ trợ quyền của mình và sử dụng nó để thực hiện các hoạt động mật mã được bảo vệ như giải mã, chữ ký và trao đổi khóa.

Khóa công khai tương ứng cũng có thể truy cập được và có thể được sử dụng để thực hiện các hoạt động như mã hóa và xác minh chữ ký.

Bởi vì đây là khóa công khai, bạn cũng có thể xuất các byte được liên kết với nó.

Các hoạt động khóa riêng tư chỉ được phép sau khi quyền đã được ủy quyền thành công.

Ngược lại, các hoạt động khóa công khai luôn được cho phép.

Khi duy trì quyền của mình, bạn cũng có cơ hội lưu trữ một bí mật bất biến duy nhất cùng với nó.

Bí mật cũng được liên kết với một danh sách kiểm soát truy cập phù hợp với các yêu cầu ủy quyền của quyền của bạn và nó chỉ có thể truy cập được sau khi quyền đã được ủy quyền.

Tóm lại, LAPersistedRights được tạo ra với sự trợ giúp của đúng cửa hàng.

Chúng chỉ được cấu hình một lần và các yêu cầu ủy quyền của chúng là bất biến.

Bởi vì chúng được lưu trữ, chúng có thể được sử dụng trong các phiên khác nhau trong ứng dụng của bạn.

Bên trong, chúng được liên kết với một thiết bị cụ thể và được hỗ trợ bởi một khóa Secure Enclave duy nhất có thể được sử dụng để thực hiện các hoạt động mật mã khác nhau, tùy thuộc vào trạng thái ủy quyền của quyền.

Cuối cùng, chúng có thể được sử dụng để bảo vệ một bí mật bất biến duy nhất mà chỉ có sẵn sau khi quyền đã được cho phép.

Bây giờ chúng tôi đã hiểu một số tính năng được cung cấp bởi các quyền tồn tại, hãy xem chúng có thể giúp chúng tôi thực hiện kịch bản mà chúng tôi đã thảo luận ở đầu bài thuyết trình như thế nào, nơi chúng tôi muốn cho phép hoạt động chữ ký.

Chúng tôi bắt đầu bằng cách khởi tạo một quyền thông thường chỉ định các yêu cầu ủy quyền của nó.

Trong trường hợp này, chúng tôi muốn đảm bảo rằng quyền sẽ chỉ được cấp cho những người dùng có đăng ký sinh trắc học trong thiết bị tại thời điểm tạo quyền của chúng tôi.

Do đó, chúng tôi sử dụng yêu cầu BiometryCurrentSet.

Sau đó, chúng tôi có thể duy trì quyền với sự trợ giúp của cửa hàng phù hợp, cung cấp một mã định danh duy nhất.

Mã định danh này sẽ hữu ích vào lần tới khi chúng tôi cần tìm nạp quyền trong các phiên ứng dụng trong tương lai của mình.

Khi quyền được duy trì, chúng tôi có quyền truy cập ngay vào khóa công khai của nó và có thể bắt đầu thực hiện các hoạt động không được bảo vệ với nó mà không cần ủy quyền rõ ràng.

Trong ví dụ này, chúng tôi chỉ đơn giản là xuất các byte công khai của nó.

Sau đó, khi đến lúc thực hiện thao tác chữ ký, chúng tôi có thể truy xuất quyền của mình từ cửa hàng bằng cách sử dụng mã định danh duy nhất mà chúng tôi đã cung cấp trong quá trình tạo.

Sau đó, chúng tôi có thể tiến hành ủy quyền cho người dùng hiện tại thông qua hoạt động ủy quyền ở bên phải của chúng tôi.

Tại thời điểm này, hệ thống sẽ hướng dẫn người dùng qua quy trình xác thực và sẽ xác minh rằng tất cả các yêu cầu ủy quyền đều được thỏa mãn.

Sau khi quyền đã được ủy quyền, chúng ta có thể sử dụng khóa riêng của nó để thực hiện các hoạt động mật mã được bảo vệ.

Trong trường hợp này, chúng tôi đang sử dụng khóa riêng để ký một thử thách do máy chủ phụ trợ của ứng dụng của chúng tôi ban hành.

Để kết thúc, chúng tôi đã nói về mối quan hệ tồn tại giữa các khái niệm chung về xác thực và ủy quyền, và đặc biệt là cách xác thực cho phép ủy quyền.

Chúng tôi đã xem xét một số tính năng được cung cấp bởi LAContext và cách nó có thể được kết hợp với các khuôn khổ như Bảo mật để mở khóa các luồng ủy quyền rất mạnh mẽ và có thể mở rộng.

Và cuối cùng, chúng tôi đã xem xét cách LARight mới được thêm vào có thể giúp bạn hợp lý hóa mã để thực hiện các trường hợp sử dụng ủy quyền nhất định.

Chúng tôi mời bạn xem xét các cách sử dụng LocalAuthentication hiện có trong ứng dụng của bạn và xem xét liệu một số tính năng mà chúng tôi đã thảo luận hôm nay có thể giúp bạn đơn giản hóa mã của mình trong khi vẫn bảo vệ quyền riêng tư và bảo mật của người dùng hay không.

Cảm ơn.