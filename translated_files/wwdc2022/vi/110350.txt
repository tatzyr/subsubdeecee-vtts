110350

♪ ♪

Chào mừng bạn đến với Hình dung và Tối ưu hóa Đồng thời Nhanh chóng.

Tên tôi là Mike, và tôi làm việc trên thư viện thời gian chạy Swift.

Xin chào, tôi là Harjas, và tôi làm việc trên Instruments.

Cùng nhau, chúng ta sẽ thảo luận về các cách để hiểu rõ hơn về mã Swift Concurrency của bạn và làm cho nó hoạt động nhanh hơn, bao gồm một công cụ trực quan hóa mới có sẵn trong Công cụ 14.

Hãy bắt đầu với bản tóm tắt thực sự nhanh về các phần khác nhau của Swift Concurrency và cách chúng hoạt động cùng nhau, để đảm bảo bạn bắt kịp tốc độ.

Sau đó, chúng tôi sẽ giới thiệu công cụ đồng thời mới.

Chúng tôi sẽ chỉ cho bạn cách chúng tôi sử dụng nó để giải quyết một số vấn đề hiệu suất thực tế với một ứng dụng sử dụng Swift Concurrency.

Cuối cùng, chúng ta sẽ thảo luận về các vấn đề tiềm ẩn của việc cạn kiệt nhóm chủ đề và tiếp tục lạm dụng và cách tránh chúng.

Năm ngoái, chúng tôi đã giới thiệu Swift Concurrency.

Đây là một tính năng ngôn ngữ mới bao gồm async/await, cấu trúc đồng thời và Actors.

Chúng tôi rất vui khi thấy rất nhiều việc áp dụng các tính năng này kể từ đó, cả bên trong và bên ngoài Apple.

Swift concurrency bổ sung một số tính năng mới vào ngôn ngữ hoạt động cùng nhau để giúp lập trình đồng thời dễ dàng và an toàn hơn.

Async/await là các khối xây dựng cú pháp cơ bản cho mã đồng thời.

Chúng cho phép bạn tạo và gọi các hàm có thể tạm dừng công việc của chúng ở giữa quá trình thực thi, sau đó tiếp tục công việc đó sau, mà không chặn chuỗi thực thi.

Nhiệm vụ là đơn vị công việc cơ bản trong mã đồng thời.

Các tác vụ thực thi mã đồng thời và quản lý trạng thái và dữ liệu liên quan của nó.

Chúng chứa các biến cục bộ, xử lý việc hủy bỏ, và bắt đầu và tạm dừng việc thực thi mã không đồng bộ.

Đồng thời có cấu trúc giúp dễ dàng tạo ra các tác vụ con để chạy song song và chờ chúng hoàn thành.

Ngôn ngữ cung cấp cú pháp giữ cho công việc được nhóm lại với nhau và đảm bảo rằng các nhiệm vụ được chờ đợi hoặc tự động hủy nếu không được sử dụng.

Các diễn viên phối hợp nhiều nhiệm vụ cần truy cập dữ liệu được chia sẻ.

Chúng cô lập dữ liệu từ bên ngoài và chỉ cho phép một tác vụ tại một thời điểm thao tác trạng thái bên trong của chúng, tránh các cuộc đua dữ liệu từ đột biến đồng thời.

Tính năng mới trong Công cụ 14, chúng tôi đang giới thiệu một bộ công cụ có thể nắm bắt và trực quan hóa tất cả hoạt động này trong ứng dụng của bạn, giúp bạn hiểu ứng dụng của mình đang làm gì, xác định vị trí sự cố và cải thiện hiệu suất.

Để thảo luận chuyên sâu hơn về các nguyên tắc cơ bản của Swift Concurrency, chúng tôi có một số video về các tính năng này được liên kết trong phần Video liên quan.

Hãy cùng xem xét việc tối ưu hóa một ứng dụng bằng cách sử dụng mã Swift Concurrency.

Đồng thời nhanh giúp dễ dàng viết đúng mã đồng thời và song song.

Tuy nhiên, vẫn có thể viết mã lạm dụng các cấu trúc đồng thời.

Cũng có thể sử dụng chúng một cách chính xác nhưng theo cách không mang lại lợi ích hiệu suất mà bạn đang hướng tới.

Có một vài vấn đề phổ biến có thể phát sinh khi viết mã bằng Swift đồng thời có thể gây ra hiệu suất kém hoặc lỗi.

Chặn diễn viên chính có thể khiến ứng dụng của bạn bị treo.

Tranh chấp diễn viên và kiệt sức của nhóm chủ đề làm tổn thương hiệu suất bằng cách giảm thực hiện song song.

Việc lạm dụng liên tục gây ra rò rỉ hoặc sự cố.

Công cụ Swift Concurrency mới có thể giúp bạn khám phá và khắc phục những vấn đề này.

Chúng ta hãy xem xét từng thứ này, bắt đầu với việc chặn Diễn viên chính.

Chặn Diễn viên chính xảy ra khi một tác vụ chạy lâu dài trên Diễn viên chính.

Diễn viên chính là một Diễn viên đặc biệt thực hiện tất cả công việc của mình trên chủ đề chính.

Công việc giao diện người dùng phải được thực hiện trên luồng chính và Diễn viên chính cho phép bạn tích hợp mã giao diện người dùng vào Swift Concurrency.

Tuy nhiên, vì chủ đề chính rất quan trọng đối với giao diện người dùng, nó cần phải có sẵn và không thể bị chiếm bởi một đơn vị công việc lâu dài.

Khi điều này xảy ra, ứng dụng của bạn dường như bị khóa và không phản hồi.

Mã chạy trên Diễn viên chính phải hoàn thành nhanh chóng và hoàn thành công việc của nó hoặc di chuyển tính toán ra khỏi Diễn viên chính và vào nền.

Công việc có thể được chuyển sang nền bằng cách đặt nó vào một Diễn viên bình thường hoặc trong một nhiệm vụ tách biệt.

Các đơn vị công việc nhỏ có thể được thực hiện trên Actor chính để cập nhật giao diện người dùng hoặc thực hiện các tác vụ khác phải được thực hiện trên luồng chính.

Hãy xem bản demo của điều này đang hoạt động.

Cảm ơn, Mike.

Ở đây chúng tôi có ứng dụng File Squeezer của chúng tôi.

Chúng tôi đã xây dựng ứng dụng này để có thể nhanh chóng nén tất cả các tệp trong một thư mục.

Nó có vẻ hoạt động tốt cho các tệp nhỏ.

Tuy nhiên, khi tôi sử dụng các tệp lớn hơn, mất nhiều thời gian hơn dự kiến và giao diện người dùng bị đóng băng hoàn toàn và không phản hồi với bất kỳ tương tác nào.

Hành vi này rất khó chịu đối với người dùng và có thể khiến họ nghĩ rằng ứng dụng đã gặp sự cố hoặc sẽ không bao giờ kết thúc.

Chúng ta nên cố gắng đảm bảo rằng giao diện người dùng của chúng ta luôn đáp ứng để có trải nghiệm người dùng tốt nhất.

Để điều tra vấn đề hiệu suất này, chúng ta có thể sử dụng mẫu Swift Concurrency mới trong Instruments.

Các công cụ Swift Tasks và Swift Actors cung cấp một bộ công cụ đầy đủ để giúp bạn hình dung và tối ưu hóa mã đồng thời của mình.

Khi bạn mới bắt đầu điều tra một vấn đề về hiệu suất, trước tiên bạn nên xem số liệu thống kê cấp cao nhất do công cụ Swift Tasks cung cấp cho bạn.

Đầu tiên trong số này là Chạy Nhiệm vụ, cho bạn biết có bao nhiêu nhiệm vụ đang thực hiện đồng thời.

Tiếp theo, chúng ta có Nhiệm vụ Sống, cho thấy có bao nhiêu nhiệm vụ hiện diện tại một thời điểm nhất định.

Và cuối cùng, Tổng nhiệm vụ; vẽ biểu đồ tổng số nhiệm vụ đã được tạo cho đến thời điểm đó.

Khi bạn đang cố gắng giảm dấu chân bộ nhớ ứng dụng của mình, bạn nên xem kỹ số liệu thống kê Alive và Total Tasks.

Sự kết hợp của tất cả các số liệu thống kê này cung cấp cho bạn một bức tranh tốt về việc mã của bạn song song tốt như thế nào và bạn đang tiêu thụ bao nhiêu tài nguyên.

Một trong nhiều chế độ xem chi tiết cho công cụ này là Task Forest; được hiển thị ở nửa dưới của cửa sổ này, nó cung cấp một biểu diễn đồ họa về mối quan hệ cha-con giữa các Nhiệm vụ trong mã đồng thời có cấu trúc.

Tiếp theo, chúng tôi có chế độ xem Tóm tắt Nhiệm vụ của mình.

Điều này cho thấy mỗi Nhiệm vụ dành bao nhiêu thời gian ở các trạng thái khác nhau.

Chúng tôi đã tăng cường chế độ xem bằng cách cho phép bạn nhấp chuột phải vào Nhiệm vụ để có thể ghim Bản nhạc chứa tất cả thông tin về Nhiệm vụ đã chọn vào dòng thời gian.

Điều này cho phép bạn nhanh chóng tìm và tìm hiểu về các Nhiệm vụ quan tâm có thể đang chạy trong một thời gian rất dài hoặc bị mắc kẹt chờ đợi để có quyền truy cập vào một Diễn viên.

Khi bạn ghim một Nhiệm vụ Swift vào dòng thời gian, bạn sẽ nhận được bốn tính năng chính.

Đầu tiên, là bản nhạc cho bạn thấy Nhiệm vụ Swift của bạn đang ở trạng thái nào.

Thứ hai, là dấu vết ngược tạo Nhiệm vụ trong chế độ xem chi tiết mở rộng.

Thứ ba, là quan điểm tường thuật cung cấp thêm bối cảnh về trạng thái của Nhiệm vụ Nhanh.

Chẳng hạn như, nếu nó đang chờ một Nhiệm vụ, nó sẽ cho bạn biết bạn đang chờ Nhiệm vụ nào.

Cuối cùng, bạn có quyền truy cập vào cùng một hành động ghim trong chế độ xem tường thuật như bạn đã làm trong chế độ xem tóm tắt.

Vì vậy, bạn có thể ghim một Nhiệm vụ con, một chủ đề hoặc thậm chí là một Diễn viên Swift vào dòng thời gian.

Chế độ xem tường thuật này sẽ là công cụ để tìm ra cách một Nhiệm vụ Swift có liên quan đến các nguyên thủy đồng thời khác của bạn và CPU.

Bây giờ chúng ta đã thấy tổng quan ngắn gọn về một số tính năng trong công cụ mới, hãy lập hồ sơ ứng dụng của chúng tôi và tối ưu hóa mã của chúng tôi.

Chúng ta có thể làm điều này bằng cách kéo dự án của mình lên Xcode và nhấn Command-I.

Điều này sẽ biên dịch ứng dụng của chúng tôi, mở các công cụ và chọn trước mục tiêu cho ứng dụng File Squeezer.

Từ đây bạn có thể chọn tùy chọn Swift Concurrency trong trình chọn mẫu và bắt đầu ghi âm.

Một lần nữa, tôi sẽ thả các tệp lớn vào ứng dụng.

Một lần nữa, chúng tôi thấy rằng ứng dụng bắt đầu quay và giao diện người dùng không phản hồi.

Chúng tôi sẽ để điều này chạy thêm vài giây nữa để Công cụ có thể nắm bắt tất cả thông tin về ứng dụng của chúng tôi.

Bây giờ chúng ta đã có dấu vết, chúng ta có thể bắt đầu điều tra.

Tôi sẽ toàn màn hình dấu vết này để xem rõ hơn tất cả thông tin.

Chúng ta có thể sử dụng tùy chọn kéo để phóng to khu vực chúng ta quan tâm.

Trong quá trình theo dõi, Instruments cho chúng ta thấy chính xác nơi treo giao diện người dùng này đã xảy ra.

Điều này có thể hữu ích cho các trường hợp không rõ khi nào treo xảy ra hoặc kéo dài bao lâu.

Như tôi đã đề cập trước đó, một nơi tốt để bắt đầu là thống kê Nhiệm vụ Nhanh cấp cao nhất.

Điều thu hút sự chú ý của tôi ngay lập tức là số lượng Nhiệm vụ Chạy.

Trong hầu hết thời gian, chỉ có một Nhiệm vụ đang chạy.

Điều này cho chúng ta biết một phần của vấn đề là tất cả công việc của chúng ta đang bị buộc phải đăng nhiều kỳ.

Chúng ta có thể sử dụng bản tóm tắt Trạng thái Nhiệm vụ để tìm Nhiệm vụ chạy lâu nhất của mình và sử dụng hành động ghim để ghim nó vào dòng thời gian.

Chế độ xem tường thuật cho Nhiệm vụ này cho chúng ta biết rằng nó đã chạy trên một luồng nền trong một khoảng thời gian ngắn và sau đó chạy trên Luồng chính trong một thời gian dài.

Để điều tra thêm, chúng ta có thể ghim Chủ đề chính vào dòng thời gian.

Chủ đề chính đang bị chặn bởi một số Nhiệm vụ chạy dài.

Điều này thể hiện vấn đề chặn Diễn viên chính mà Mike đã nói đến.

Vì vậy, những câu hỏi mà chúng ta phải tự hỏi mình là, "Nhiệm vụ này đang làm gì vậy?" Và "Nhiệm vụ này đến từ đâu?"

Chúng ta có thể chuyển trở lại chế độ xem tường thuật để trả lời cả hai câu hỏi này.

Dấu vết ngược tạo trong chế độ xem chi tiết mở rộng cho thấy rằng nhiệm vụ đã được tạo trong chức năng compressAllFiles.

Câu chuyện cho thấy Nhiệm vụ đang thực hiện đóng cửa số một trong compressAllFiles.

Bằng cách nhấp chuột phải vào biểu tượng này, chúng ta có thể mở biểu tượng này trong trình xem nguồn.

Đóng cửa số một bên trong chức năng này đang gọi công việc nén của chúng tôi.

Bây giờ chúng ta đã biết Nhiệm vụ này được tạo ở đâu và nó đang làm gì, chúng ta có thể mở mã của mình trong Xcode và điều chỉnh nó để chúng ta không chạy các tính toán nặng nề này trên Luồng chính.

Chức năng nén tệp nằm trong lớp CompressionState.

Toàn bộ lớp CompressionState được chú thích để chạy trên @MainActor.

Điều này giải thích tại sao Nhiệm vụ cũng chạy trên Chủ đề Chính.

Chúng tôi cần toàn bộ lớp này nằm trên MainActor vì thuộc tính @Published ở đây chỉ phải được cập nhật từ Chủ đề chính, nếu không, chúng tôi có thể gặp sự cố về thời gian chạy.

Vì vậy, thay vào đó chúng ta có thể cố gắng chuyển đổi lớp này thành Diễn viên của riêng nó.

Tuy nhiên, trình biên dịch sẽ cho chúng tôi biết rằng chúng tôi không thể làm điều này bởi vì về cơ bản chúng tôi sẽ nói rằng trạng thái có thể thay đổi được chia sẻ này cần được bảo vệ bởi hai Diễn viên khác nhau.

Nhưng điều đó cho chúng ta một gợi ý về giải pháp thực sự là gì.

Chúng tôi có hai phần khác nhau của trạng thái có thể thay đổi ở đây trong lớp này.

Một phần của trạng thái, thuộc tính 'tệp', cần được cách ly với MainActor vì nó được SwiftUI quan sát.

Nhưng quyền truy cập vào phần khác của trạng thái, nhật ký, cần được bảo vệ khỏi sự truy cập đồng thời, nhưng luồng nào truy cập nhật ký tại bất kỳ điểm nhất định nào không quan trọng.

Do đó, nó không thực sự cần phải có trên Diễn viên chính.

Tuy nhiên, chúng tôi vẫn muốn bảo vệ nó khỏi sự truy cập đồng thời, vì vậy chúng tôi gói nó trong Diễn viên của chính nó.

Tất cả những gì chúng ta cần bây giờ là thêm một cách để Nhiệm vụ nhảy giữa hai khi cần thiết.

Chúng ta có thể tạo một Diễn viên mới và gọi nó là ParallelCompressor.

Sau đó, chúng ta có thể sao chép trạng thái nhật ký vào Diễn viên mới và thêm một số mã thiết lập bổ sung.

Từ đây, chúng ta cần làm cho những Diễn viên này giao tiếp với nhau.

Đầu tiên, hãy xóa mã đề cập đến biến nhật ký khỏi lớp CompressionState và thêm nó vào ParallelCompressor Actor của chúng tôi.

Sau đó, cuối cùng, chúng ta cần cập nhật CompressionState để gọi compressFile trên ParallelCompressor.

Với những thay đổi này, hãy kiểm tra lại ứng dụng của chúng tôi.

Một lần nữa, tôi sẽ thả các tệp lớn vào ứng dụng của chúng tôi.

Giao diện người dùng không còn bị treo nữa, đó là một cải tiến tuyệt vời, nhưng chúng tôi không đạt được tốc độ mà chúng tôi mong đợi.

Chúng tôi thực sự muốn tận dụng tối đa tất cả các lõi trong máy để thực hiện công việc này càng nhanh càng tốt.

Mike, chúng ta nên đề phòng điều gì khác?

Mike: Chúng tôi đã giải quyết vấn đề của mình bằng cách chuyển công việc ra khỏi Diễn viên chính, nhưng chúng tôi vẫn không đạt được hiệu suất mà chúng tôi muốn.

Để hiểu tại sao, chúng ta cần xem xét kỹ hơn các Diễn viên.

Các diễn viên làm cho nó an toàn cho nhiều nhiệm vụ để thao tác trạng thái được chia sẻ.

Tuy nhiên, họ làm điều này bằng cách tuần tự hóa quyền truy cập vào trạng thái được chia sẻ đó.

Chỉ một nhiệm vụ tại một thời điểm được phép chiếm giữ Diễn viên và các nhiệm vụ khác cần sử dụng Diễn viên đó sẽ đợi.

Đồng thời Swift cho phép tính toán song song bằng cách sử dụng các nhiệm vụ phi cấu trúc, nhóm tác vụ và let không đồng bộ.

Lý tưởng nhất, các cấu trúc này có thể sử dụng nhiều lõi CPU cùng một lúc.

Khi sử dụng Actors từ mã đó, hãy cẩn thận thực hiện một lượng lớn công việc trên một Actor được chia sẻ giữa các nhiệm vụ này.

Khi nhiều tác vụ cố gắng sử dụng cùng một Diễn viên cùng một lúc, Diễn viên sẽ tuần tự hóa việc thực hiện các tác vụ đó.

Bởi vì điều này, chúng ta mất đi lợi ích hiệu suất của tính toán song song.

Điều này là do mỗi nhiệm vụ phải đợi Diễn viên có sẵn.

Để khắc phục điều này, chúng tôi cần đảm bảo rằng các tác vụ chỉ chạy trên Diễn viên khi chúng thực sự cần quyền truy cập độc quyền vào dữ liệu của Diễn viên.

Mọi thứ khác nên chạy trốn khỏi Diễn viên.

Chúng tôi chia nhiệm vụ thành nhiều phần.

Một số phần phải chạy trên Diễn viên, và những phần khác thì không.

Các đoạn bị cô lập không phải của Diễn viên có thể được thực hiện song song, có nghĩa là máy tính có thể hoàn thành công việc nhanh hơn nhiều.

Hãy xem bản demo của điều này đang hoạt động.

Harjas: Cảm ơn, Mike.

Hãy cùng xem dấu vết của ứng dụng "File Squeezer" được cập nhật của chúng tôi và ghi nhớ những gì Mike vừa dạy chúng tôi.

Chế độ xem Tóm tắt Nhiệm vụ cho chúng ta thấy rằng mã đồng thời của chúng ta đang dành một khoảng thời gian đáng báo động ở trạng thái Enqueued.

Điều này có nghĩa là chúng tôi có rất nhiều Nhiệm vụ đang chờ để có quyền truy cập độc quyền vào một Diễn viên.

Hãy ghim một trong những Nhiệm vụ này để tìm hiểu lý do tại sao.

Nhiệm vụ này dành khá nhiều thời gian để truy cập vào ParallelCompressor Actor trước khi nó chạy công việc nén.

Hãy tiếp tục và ghim Diễn viên vào dòng thời gian của chúng ta.

Ở đây chúng tôi có một số dữ liệu cấp cao nhất cho ParallelCompressor Actor.

Hàng đợi diễn viên này dường như đang bị chặn bởi một số Nhiệm vụ kéo dài.

Nhiệm vụ thực sự chỉ nên ở trên một Diễn viên miễn là cần thiết.

Hãy quay lại câu chuyện Nhiệm vụ.

Sau khi xếp hàng trên ParallelCompressor, Task chạy ở mức đóng số một trong compressAllFiles.

Vậy hãy bắt đầu cuộc điều tra của chúng ta ở đó.

Mã nguồn cho chúng ta thấy rằng việc đóng cửa này chủ yếu đang chạy công việc nén của chúng ta.

Vì hàm compressFile là một phần của ParallelCompressor Actor, toàn bộ việc thực thi hàm này xảy ra trên Actor; chặn tất cả các công việc nén khác.

Để giải quyết vấn đề này, chúng ta cần kéo hàm compressFile ra khỏi Actor-isolation và vào một nhiệm vụ tách rời.

Bằng cách này, chúng ta chỉ có thể có nhiệm vụ tách rời trên một Diễn viên miễn là cần thiết để cập nhật trạng thái có thể thay đổi có liên quan.

Vì vậy, bây giờ chức năng nén có thể được thực thi tự do, trên bất kỳ luồng nào trong nhóm luồng, cho đến khi nó cần truy cập trạng thái được bảo vệ bởi Actor.

Ví dụ, khi nó cần truy cập thuộc tính 'tệp', nó sẽ chuyển sang Diễn viên chính.

Nhưng ngay sau khi hoàn thành ở đó, nó sẽ di chuyển vào "biển đồng thời" một lần nữa, cho đến khi nó cần truy cập thuộc tính nhật ký, mà nó chuyển sang ParallelCompressor Actor.

Nhưng một lần nữa, ngay sau khi nó được hoàn thành ở đó, nó để Diễn viên một lần nữa được thực thi trên nhóm chủ đề.

Nhưng tất nhiên, chúng tôi không chỉ có một nhiệm vụ thực hiện công việc nén; chúng tôi có rất nhiều.

Và bằng cách không bị ràng buộc đối với một Diễn viên, tất cả chúng có thể được thực thi đồng thời, chỉ bị giới hạn bởi số lượng luồng.

Tất nhiên, mỗi Diễn viên chỉ có thể thực hiện một nhiệm vụ tại một thời điểm, nhưng hầu hết thời gian, Nhiệm vụ của chúng ta không cần phải ở trên một Diễn viên.

Vì vậy, như Mike đã giải thích, điều này cho phép các tác vụ nén của chúng tôi được thực hiện song song và sử dụng tất cả các lõi CPU có sẵn.

Vậy hãy thay đổi điều này ngay bây giờ.

Chúng ta có thể đánh dấu hàm compressFile là không cô lập.

Điều này dẫn đến một vài lỗi trình biên dịch.

Bằng cách đánh dấu nó là không cô lập, chúng tôi đã nói với trình biên dịch Swift rằng chúng tôi không cần truy cập vào trạng thái được chia sẻ của Diễn viên này.

Nhưng điều đó không hoàn toàn đúng.

Chức năng nhật ký này bị cô lập bởi Actor và nó cần quyền truy cập vào trạng thái có thể thay đổi được chia sẻ.

Để khắc phục điều này, chúng ta cần làm cho hàm này không đồng bộ và sau đó đánh dấu tất cả các lệnh gọi nhật ký của chúng ta bằng từ khóa await.

Bây giờ chúng ta cần cập nhật việc tạo nhiệm vụ của mình để tạo một nhiệm vụ tách rời.

Chúng tôi làm điều này để đảm bảo Nhiệm vụ không kế thừa bối cảnh Diễn viên mà nó được tạo ra.

Đối với các nhiệm vụ tách rời, chúng ta cần nắm bắt bản thân một cách rõ ràng.

Hãy kiểm tra lại đơn đăng ký của chúng tôi.

Ứng dụng có thể nén tất cả các tệp cùng một lúc và giao diện người dùng vẫn đáp ứng.

Để xác minh những cải tiến của chúng tôi, chúng tôi có thể kiểm tra nhạc cụ Swift Actors.

Nhìn vào Diễn viên ParallelCompressor, hầu hết các tác phẩm được thực hiện trên Diễn viên chỉ trong một khoảng thời gian ngắn và kích thước hàng đợi không bao giờ vượt quá tầm kiểm soát.

Tóm lại, chúng tôi đã sử dụng Công cụ để cô lập nguyên nhân của giao diện người dùng bị treo, chúng tôi đã cấu trúc lại mã đồng thời của mình để song song tốt hơn và xác minh các cải tiến hiệu suất bằng cách sử dụng dữ liệu.

Bây giờ Mike sẽ cho chúng tôi biết về một số vấn đề hiệu suất tiềm ẩn khác.

Mike: Có hai vấn đề phổ biến mà tôi muốn đề cập ngoài những gì chúng ta đã thấy trong bản demo.

Đầu tiên, hãy nói về sự kiệt sức của bể bơi.

Sự cạn kiệt của bể bơi có thể làm tổn thương hiệu suất hoặc thậm chí bế tắc một ứng dụng.

Đồng thời nhanh chóng yêu cầu các tác vụ để tiến hành trước khi chúng đang chạy.

Khi một nhiệm vụ chờ đợi điều gì đó, nó thường làm như vậy bằng cách tạm dừng.

Tuy nhiên, mã trong một tác vụ có thể thực hiện cuộc gọi chặn, chẳng hạn như chặn tệp hoặc IO mạng hoặc lấy khóa mà không bị đình chỉ.

Điều này phá vỡ yêu cầu đối với các nhiệm vụ để tiến bộ.

Khi điều này xảy ra, nhiệm vụ tiếp tục chiếm chủ đề nơi nó đang thực thi, nhưng nó không thực sự sử dụng lõi CPU.

Bởi vì nhóm luồng bị giới hạn và một số trong số chúng bị chặn, thời gian chạy đồng thời không thể sử dụng đầy đủ tất cả các lõi CPU.

Điều này làm giảm số lượng tính toán song song có thể được thực hiện và hiệu suất tối đa của ứng dụng của bạn.

Trong trường hợp cực đoan, khi toàn bộ nhóm luồng bị chiếm bởi các tác vụ bị chặn và họ đang chờ đợi thứ gì đó yêu cầu một tác vụ mới để chạy trên nhóm luồng, thời gian chạy đồng thời có thể bị bế tắc.

Đảm bảo tránh chặn các cuộc gọi trong các nhiệm vụ.

Tệp và mạng IO phải được thực hiện bằng cách sử dụng API không đồng bộ.

Tránh chờ đợi các biến điều kiện hoặc semaphores.

Các khóa hạt mịn, được giữ ngắn gọn có thể chấp nhận được nếu cần thiết, nhưng tránh các khóa có nhiều tranh chấp hoặc được giữ trong thời gian dài.

Nếu bạn có mã cần thực hiện những việc này, hãy di chuyển mã đó ra ngoài nhóm luồng đồng thời - ví dụ: bằng cách chạy nó trên hàng đợi Dispatch - và kết nối nó với thế giới đồng thời bằng cách sử dụng tiếp tục.

Bất cứ khi nào có thể, hãy sử dụng API không đồng bộ để chặn các hoạt động để giữ cho hệ thống hoạt động trơn tru.

Khi bạn đang sử dụng tiếp tục, bạn phải cẩn thận để sử dụng chúng một cách chính xác.

Tiếp tục là cầu nối giữa đồng thời Swift và các dạng mã không đồng bộ khác.

Việc tiếp tục đình chỉ nhiệm vụ hiện tại và cung cấp một cuộc gọi lại để tiếp tục nhiệm vụ khi được gọi.

Điều này sau đó có thể được sử dụng với các API không đồng bộ dựa trên gọi lại.

Từ quan điểm của Swift đồng thời, nhiệm vụ bị đình chỉ, và sau đó nó tiếp tục khi việc tiếp tục được nối lại.

Từ quan điểm của API không đồng bộ dựa trên gọi lại, công việc bắt đầu và sau đó gọi lại được gọi khi công việc hoàn thành.

Công cụ Swift Concurrency biết về các lần tiếp tục và sẽ đánh dấu khoảng thời gian cho phù hợp, cho bạn thấy rằng nhiệm vụ đang chờ tiếp tục được gọi.

Các cuộc gọi lại liên tục có một yêu cầu đặc biệt: chúng phải được gọi chính xác một lần, không hơn không kém.

Đây là một yêu cầu phổ biến trong các API dựa trên gọi lại, nhưng nó có xu hướng là một yêu cầu không chính thức và không được thực thi bởi ngôn ngữ và các giám sát là phổ biến.

Đồng thời nhanh chóng làm cho điều này trở thành một yêu cầu khó khăn.

Nếu cuộc gọi lại được gọi hai lần, chương trình sẽ gặp sự cố hoặc hoạt động sai.

Nếu cuộc gọi lại không bao giờ được gọi, nhiệm vụ sẽ bị rò rỉ.

Trong đoạn mã này, chúng tôi sử dụng withCheckedContinuation để tiếp tục.

Sau đó chúng tôi gọi một API dựa trên gọi lại.

Trong cuộc gọi lại, chúng tôi tiếp tục tiếp tục.

Điều này đáp ứng yêu cầu gọi nó chính xác một lần.

Điều quan trọng là phải cẩn thận khi mã phức tạp hơn.

Ở bên trái, chúng tôi đã sửa đổi cuộc gọi lại để chỉ tiếp tục tiếp tục thành công.

Đây là một lỗi.

Khi thất bại, việc tiếp tục sẽ không được tiếp tục và nhiệm vụ sẽ bị đình chỉ mãi mãi.

Ở bên phải, chúng tôi đang tiếp tục tiếp tục hai lần.

Đây cũng là một lỗi, và ứng dụng sẽ hoạt động sai hoặc gặp sự cố.

Cả hai đoạn mã này đều vi phạm yêu cầu tiếp tục tiếp tục chính xác một lần.

Hai loại tiếp tục có sẵn: đã kiểm tra và không an toàn.

Luôn sử dụng withCheckedContinuation API để tiếp tục trừ khi hiệu suất hoàn toàn quan trọng.

Các tiếp tục được kiểm tra tự động phát hiện việc lạm dụng và gắn cờ lỗi.

Khi một lần tiếp tục được kiểm tra được gọi hai lần, sự tiếp tục sẽ bẫy.

Khi phần tiếp tục hoàn toàn không bao giờ được gọi, một thông báo sẽ được in lên bảng điều khiển khi phần tiếp tục bị phá hủy cảnh báo bạn rằng phần tiếp tục bị rò rỉ.

Công cụ Swift Concurrency sẽ hiển thị nhiệm vụ tương ứng bị mắc kẹt vô thời hạn ở trạng thái tiếp tục.

Có nhiều thứ hơn để xem xét cho mẫu Swift Concurrency mới trong Instruments.

Bạn có thể nhận trực quan hóa đồ họa của đồng thời có cấu trúc, xem các calltrees tạo tác vụ và kiểm tra các hướng dẫn lắp ráp chính xác để có được bức tranh đầy đủ về thời gian chạy Swift Concurrency.

Để tìm hiểu thêm về cách Swift Concurrency hoạt động dưới mui xe, hãy xem phiên năm ngoái trên "Swift Concurrency: Hậu trường."

Và để tìm hiểu thêm về các cuộc đua dữ liệu, hãy xem "Loại bỏ các cuộc đua dữ liệu bằng Swift Concurrency."

Cảm ơn vì đã xem!

Và vui vẻ gỡ lỗi mã đồng thời của bạn.