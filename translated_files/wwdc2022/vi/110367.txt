110367

♪ ♪

Alex: Xin chào, tên tôi là Alex, và tôi làm việc trên Developer Tools.

Hôm nay tôi muốn nói chuyện với bạn về các tính năng C++ 20 mới được hỗ trợ trong Xcode 14.

Tôi sẽ đặc biệt tập trung vào cách các khái niệm C++ 20 đơn giản hóa và cải thiện loại an toàn của mã C++ chung.

Tôi sẽ trình bày cách sử dụng các khái niệm và cũng sẽ giải thích cách tạo ra các khái niệm của riêng bạn.

Tôi sẽ kết thúc cuộc nói chuyện bằng cách liệt kê một số tính năng C++20 mới khác được hỗ trợ trong Xcode và sẽ đề cập đến cách một số trong số chúng có thể được sử dụng để cải thiện hiệu suất của các dự án C++ của bạn thông qua sức mạnh của việc biên dịch đánh giá mã thời gian.

Trước khi đi sâu vào các khái niệm C++, trước tiên chúng ta hãy xem qua tổng quan nhanh về cách viết mã chung trong C++.

Giả sử tôi muốn viết một hàm kiểm tra xem một số có lẻ hay không.

Tôi có thể viết một hàm nhận tham số 'int' và nó sẽ hoạt động với bất kỳ giá trị nào có thể được biểu diễn bằng loại 'int'.

Điều gì sẽ xảy ra nếu tôi chuyển một giá trị nguyên không dấu 64 bit cho nó?

Một hàm cụ thể như thế này không hoạt động chính xác với các giá trị 64 bit, vì chúng bị cắt ngắn để phù hợp với loại 'int'.

Để khắc phục điều này, tôi có thể biến 'isOdd' thành một mẫu hàm.

Bây giờ tôi đã có một mẫu hàm, tôi có thể chuyển giá trị số nguyên không dấu 64 bit cho nó.

Trình biên dịch bây giờ sẽ tự động tạo ra một chuyên ngành 'isOdd' hoạt động chính xác với loại 'uint64_t'.

Điều này thực sự hữu ích vì nó có nghĩa là tôi không phải viết hai phiên bản 'isOdd' hoạt động trên hai loại khác nhau.

Bạn có thể sử dụng các mẫu C++ để viết các hàm chung như 'isOdd' và các lớp vùng chứa chung.

Hãy cùng xem 'isOdd' có thể được sử dụng như thế nào.

Chức năng này được kiểm tra với một số trường hợp kiểm tra mà tôi đã thêm vào tệp kiểm tra của mình.

Thật không may, tôi đã mắc lỗi trong một trong những bài kiểm tra của mình.

Trình biên dịch đã mắc lỗi, nhưng thay vì chỉ vào nơi tôi đã mắc lỗi, trình biên dịch hiển thị lỗi bên trong mẫu 'isOdd'.

Có vẻ như tôi đã mắc lỗi đánh máy và viết ra '1.1' trong bài kiểm tra của mình thay vì '11'.

Do đó, trình biên dịch tạo ra một chuyên ngành 'isOdd' có kiểu 'double'.

Thật không may, tôi đã mất một thời gian để tìm ra lỗi đánh máy này vì Xcode đã không chỉ cho tôi vị trí cụ thể nơi 'isOdd' được gọi với loại không chính xác.

Ngôn ngữ và trình biên dịch có thể giúp tôi tìm ra những lỗi như thế này nhanh hơn không?

Chà, trong ví dụ hiện tại, các yêu cầu đối với loại nào được phép vào 'isOdd' không được chỉ định rõ ràng.

Chỉ có một nhận xét tài liệu nói rằng tôi phải gọi isOdd bằng cách sử dụng các kiểu số nguyên.

Trước C++20, các lập trình viên C++ không có cách tốt để chỉ định các yêu cầu mẫu khi viết mã C++ chung.

Họ thường phải dùng đến nhận xét tài liệu, tên tham số cụ thể hoặc kiểm tra enable_if phức tạp khi chỉ định các yêu cầu mẫu.

Chà, như bạn có thể đã nghe, C++ 20 giới thiệu một tính năng C++ mới được gọi là các khái niệm.

Bạn có thể sử dụng các khái niệm để xác thực các yêu cầu mẫu trong mã C++ chung của mình.

Chúng ta hãy xem các khái niệm có thể giúp tôi xác thực các loại có thể được chuyển thành 'isOdd' như thế nào.

Đầu tiên, chúng ta hãy quay lại tuyên bố 'isOdd'.

Hiện tại, tôi sử dụng từ khóa 'lớp' để chỉ định rằng loại 'T' được sử dụng bởi mẫu này có thể là bất kỳ loại nào.

C++ 20 cho phép tôi sử dụng một khái niệm thay vì từ khóa 'lớp' để hạn chế tập hợp các loại mà mẫu này có thể được sử dụng.

Tôi có thể sử dụng khái niệm 'không thể thiếu' do thư viện tiêu chuẩn cung cấp để hạn chế mẫu hàm 'isOdd' này chỉ đối với các loại số nguyên tích hợp sẵn.

Trình biên dịch thậm chí sẽ không cố gắng chuyên môn hóa mẫu hàm này khi T không thỏa mãn khái niệm này.

Khái niệm tích phân được khai báo trong thư viện chuẩn C++.

Vì vậy, tôi cần bao gồm tiêu đề khái niệm để sử dụng nó trong mã của mình.

Bây giờ tôi đã thêm một yêu cầu 'không thể thiếu' vào loại _T_ trong mẫu hàm 'isOdd', trình biên dịch có thể cung cấp chẩn đoán rõ ràng hơn nhiều chỉ trực tiếp vào nơi tôi đã mắc lỗi trong các bài kiểm tra của mình.

Hóa ra, '1.1' là một cú đúp, và do đó, nó không thỏa mãn khái niệm 'không thể thiếu'.

Trình biên dịch có thể giải thích điều này cho tôi với một thông báo lỗi rõ ràng giúp tôi tìm và sửa lỗi đánh máy này nhanh hơn nhiều so với trước đây.

Ngoài việc giúp tôi sửa lỗi, việc hạn chế loại được chuyển thành 'isOdd' giúp tôi yên tâm rằng tất cả các trường hợp kiểm tra mà tôi có là 'isOdd' chỉ hoạt động với các loại số nguyên và chúng thực sự đang kiểm tra hành vi dự định của thuật toán.

Bạn có thể sử dụng các khái niệm để khai báo mục đích sử dụng các loại mẫu của bạn.

Trình biên dịch sau đó sẽ xác thực các yêu cầu về loại trước khi các mẫu của bạn được chuyên biệt hóa.

Chúng ta hãy xem xét kỹ hơn cách các khái niệm có thể được sử dụng và những khái niệm cốt lõi nào được cung cấp bởi thư viện tiêu chuẩn C++.

Thư viện tiêu chuẩn C++ cung cấp một thư viện khái niệm.

Nó thực hiện một tập hợp các khái niệm ngôn ngữ cốt lõi mà bạn có thể sử dụng để xác thực hành vi cốt lõi của một loại.

Bạn có thể truy cập thư viện này bằng cách bao gồm tiêu đề khái niệm trong mã của bạn.

Tôi đã chỉ ra cách tôi có thể sử dụng khái niệm 'không thể thiếu' trong ví dụ trước đó của mình.

Bây giờ, chúng ta hãy xem xét các khái niệm khác được cung cấp bởi thư viện này.

Thư viện này cung cấp một số khái niệm ngôn ngữ cốt lõi hữu ích, như các khái niệm kiểm tra xem một loại có phải là một trong những loại tích hợp sẵn hay không.

Ví dụ, khái niệm 'floating_point' được thỏa mãn bởi các loại tích hợp sẵn như 'float' và 'double'.

'Static_assert' được hiển thị ở đây xác nhận rằng đây thực sự là trường hợp.

Nó cũng cung cấp rất nhiều khái niệm cốt lõi hữu ích khác để kiểm tra xem các loại có thể xây dựng, có thể phá hủy, có thể chuyển đổi hay chúng giống với một loại khác.

Ví dụ, khái niệm 'convertible_to' kiểm tra xem một loại có thể được chuyển đổi sang loại khác hay không.

Và khái niệm 'move_constructible' được thỏa mãn bởi các loại có thể được xây dựng trực tiếp từ một giá trị khác cùng loại.

Thư viện này cũng cung cấp một số khái niệm so sánh để kiểm tra xem các loại có thể được so sánh với các loại khác hay không.

Ví dụ, khái niệm 'equality_comparable' được thỏa mãn bởi các loại có toán tử '==' hợp lệ hoạt động với giá trị cùng loại.

Ngoài các khái niệm được đề cập trên trang trình bày này, thư viện này cung cấp nhiều khái niệm ngôn ngữ cốt lõi khác.

Nó cũng cung cấp các khái niệm kiểm tra xem một loại có thể được di chuyển hoặc sao chép hay không.

Thêm vào đó, nó cũng cung cấp các khái niệm kiểm tra xem một loại có phải là một đối tượng có thể gọi được hay không.

Bây giờ chúng ta đã xem qua các khái niệm được cung cấp cho chúng ta bởi thư viện tiêu chuẩn C++, chúng ta hãy xem xét cách các khái niệm có thể được sử dụng để hạn chế các mẫu.

Như tôi đã trình bày trước đó, bạn có thể sử dụng một khái niệm thay vì từ khóa lớp trong mẫu để hạn chế loại nào được phép cho mẫu này.

Thêm vào đó, bạn có thể sử dụng mệnh đề 'yêu cầu' trong khai báo mẫu nếu bạn cần hạn chế một loại cho nhiều khái niệm.

Chúng ta hãy xem xét một ví dụ hơi khác để xem nó có thể được thực hiện như thế nào.

Ở đây tôi có mẫu hàm 'isDefaultValue'.

Nó trả về true nếu giá trị đã cho bằng với giá trị mặc định của loại của nó.

Tôi có thể sử dụng hai khái niệm từ thư viện tiêu chuẩn để kiểm tra xem loại này có hỗ trợ các hoạt động này hay không trước khi mẫu này được chuyên biệt hóa.

Tôi sẽ thêm mệnh đề 'yêu cầu' để hạn chế tập hợp các loại được phép cho mẫu hàm này.

Hãy xem những khái niệm nào từ thư viện khái niệm có thể giúp tôi xác thực loại ở đây.

Đầu tiên, khái niệm 'bình đẳng_có thể so sánh' kiểm tra nếu _T_ có thể được so sánh với một giá trị khác cùng loại.

Sau đó, khái niệm 'mặc định_có thể xây dựng' kiểm tra nếu _T_ là một loại có hàm tạo mặc định.

Logic và toán tử giữa chúng hướng dẫn trình biên dịch xác thực cả hai khái niệm.

Điều này đảm bảo rằng mẫu chức năng này sẽ chỉ chuyên biệt với các loại được hỗ trợ.

Hãy xem lại những gì chúng ta đã học được cho đến nay về các khái niệm.

Bạn nên sử dụng các khái niệm để hạn chế các loại được phép sử dụng trong các mẫu của mình.

Trình biên dịch sau đó sẽ có thể hiển thị chẩn đoán rõ ràng hơn vì mẫu sẽ không phải chuyên biệt hóa nếu xảy ra lỗi loại.

Bạn nên sử dụng lại các khái niệm từ thư viện khái niệm nếu bạn cần xác thực một số hành vi cốt lõi của một loại.

Bạn nên thêm mệnh đề 'yêu cầu' vào các mẫu của mình khi bạn cần kiểm tra xem các loại có phù hợp với nhiều yêu cầu hay không.

Bây giờ chúng ta đã thấy cách sử dụng các khái niệm trong các chương trình C++.

C++ cho phép chúng tôi khai báo các khái niệm tùy chỉnh xác thực hành vi cụ thể của một loại.

Chúng ta hãy xem cách tạo ra các khái niệm của riêng chúng ta để xác nhận hành vi loại cụ thể.

Tuy nhiên, trước khi chúng ta làm điều đó, chúng ta cần xem xét cách xác định các yêu cầu hành vi phải được xác nhận bởi khái niệm mà chúng ta muốn khai báo.

Tôi sẽ sử dụng một ví dụ mới để minh họa cách xác thực hành vi loại cụ thể bằng cách sử dụng các khái niệm.

Giả sử tôi đang xây dựng một thư viện C++ có thể hiển thị các hình dạng hai chiều khác nhau cho một hình ảnh.

Tôi muốn hỗ trợ các hình dạng khác nhau trong thư viện của mình.

Tôi đang bắt đầu với một hình tròn, vì nó đơn giản nhất để kết xuất.

Tôi sẽ sử dụng một lớp C++ để lưu trữ các thuộc tính của nó, như vị trí và bán kính.

Để hiển thị vòng tròn, tôi sẽ sử dụng thuật toán kết xuất dựa trên hàm khoảng cách chạy trên mỗi pixel trong hình ảnh được hiển thị.

Thuật toán này cần tính toán khoảng cách đến bề mặt của hình dạng để hiển thị nó.

Phương thức 'getDistanceFrom' trong lớp Circle tính toán nó.

Nó trả về một khoảng cách âm bên trong vòng tròn, và một khoảng cách dương bên ngoài vòng tròn.

Ngoài vòng tròn, tôi muốn hiển thị các hình dạng khác.

Ví dụ, bằng cách trừ đi hình học một hình tròn từ một hình tròn khác, tôi cũng có thể hiển thị một hình lưỡi liềm.

Tôi sẽ đại diện cho các hình dạng như Crescent mà tôi cũng muốn kết xuất bằng cách sử dụng các lớp học.

Mỗi lớp hình dạng mới bao gồm phương thức 'getDistanceFrom'.

Sau khi tạo một số lớp hình dạng, bây giờ tôi muốn thử kết xuất các hình dạng này để xác minh việc thực hiện chúng.

Tôi có một vài lựa chọn về cách tôi có thể tạo hàm kết xuất hoạt động với bất kỳ hình dạng nào.

Tôi có thể tạo một hệ thống phân cấp lớp cho các hình dạng và sử dụng một phương pháp ảo để tính toán khoảng cách đến bề mặt của hình dạng.

Tuy nhiên, tôi sẽ sử dụng mẫu hàm thay vì lý do hiệu suất, vì tôi muốn tránh chi phí cuộc gọi ảo vì hàm này sẽ được gọi hàng triệu lần trong quá trình kết xuất.

Đây là lý do tại sao tôi tạo ra mẫu chức năng kết xuất này.

Hàm computePixelColor nhận một giá trị hình dạng và kiểm tra xem điểm ảnh đã cho có nằm trong hình dạng hay không.

Nếu nó ở bên trong, nó sẽ trả về một màu trắng trơn.

Điều này bây giờ cho phép tôi xác minh rằng các hình dạng có thể được điền chính xác.

Hàm này là một mẫu, làm cho nó hoạt động với bất kỳ loại hình dạng nào, có thể là hình tròn, hình lưỡi liềm hoặc bất kỳ loại phù hợp nào khác.

Mặc dù một mẫu hoạt động tốt ở đây, tôi muốn sử dụng các khái niệm để hạn chế loại có thể được chuyển cho hàm này.

Hạn chế loại được chuyển đến hàm này sẽ cho phép trình biên dịch tạo ra chẩn đoán rõ ràng hơn khi xảy ra sự không khớp kiểu.

Thêm vào đó, việc hạn chế loại được truyền cho hàm này cũng sẽ cho phép tôi thêm các quá tải bổ sung của hàm này.

Để hạn chế kiểu chữ, tôi sẽ tạo ra một khái niệm Hình dạng.

Khái niệm này sẽ xác nhận hành vi của loại và sẽ chấp nhận các lớp như hình tròn, hình lưỡi liềm và bất kỳ lớp hình dạng nào khác mà tôi có thể muốn thêm vào trong tương lai.

Để tạo ra một khái niệm như 'Hình dạng', trước tiên tôi cần xác định các yêu cầu phải được xác nhận bởi khái niệm này.

Hãy xem điều này có thể được thực hiện như thế nào.

Mẫu chức năng này sử dụng kiểu 'T' làm kiểu chung.

Một đối số có tên 'hình dạng' của loại 'T' sau đó được chuyển đến hàm này.

Đối số 'shape' sau đó được sử dụng bên trong hàm, khi tôi gọi phương thức 'getDistanceFrom' trên đó.

Như bạn có thể thấy, đây là yêu cầu duy nhất tôi muốn xác thực trong khái niệm của mình, vì không có thao tác nào khác được thực hiện trên hình dạng trong chức năng này.

Bạn có thể sử dụng biểu thức 'yêu cầu' để kiểm tra xem một loại có hoạt động theo một cách cụ thể hay không.

Hãy xem cách tôi có thể sử dụng 'yêu cầu' để tạo ra khái niệm Hình dạng.

Tôi cần cung cấp một tập hợp các biểu thức kiểm tra hành vi của một loại bên trong 'yêu cầu'.

Tôi đã xác định cuộc gọi đến 'getDistanceFrom' là một yêu cầu duy nhất mà tôi cần kiểm tra, vì vậy bây giờ tôi có thể tiếp tục và tạo ra khái niệm 'Hình dạng'.

Tôi đã tuyên bố khái niệm hình dạng bằng cách sử dụng từ khóa 'khái niệm'.

Sau đó tôi đã thêm biểu thức 'yêu cầu' vào khái niệm này để xác thực loại.

Tôi đã thêm một danh sách đối số vào biểu thức 'yêu cầu'.

Danh sách đối số này cho phép tôi khai báo một giá trị 'hình dạng' của loại 'T' mà sau đó tôi sẽ kiểm tra bên trong 'yêu cầu'.

Bạn có thể sử dụng danh sách đối số trong biểu thức yêu cầu để khai báo các giá trị thuộc bất kỳ loại nào.

Sau đó bạn sẽ có thể sử dụng các giá trị này bên trong yêu cầu.

Phần thân của biểu thức 'yêu cầu' chứa một tập hợp các yêu cầu phải được thông qua để khái niệm này được thỏa mãn.

Khái niệm 'shape' chỉ có một yêu cầu biểu thức đơn giản để kiểm tra xem một cuộc gọi phương thức đến 'getDistanceFrom' có hợp lệ hay không.

Biểu thức này sẽ không thực sự được thực thi trong chương trình.

Nó chỉ cần thiết tại thời điểm biên dịch để xác thực hành vi của loại và nó sẽ bị loại bỏ sau khi xác thực.

Bạn có thể sử dụng các yêu cầu biểu thức để xác thực hành vi của loại bằng cách kiểm tra xem một biểu thức cụ thể có được biên dịch hay không.

Tuy nhiên, biểu thức cụ thể này vẫn chưa hoàn chỉnh, vì chúng tôi đang thiếu các đối số cho cuộc gọi phương thức 'getDistanceFrom'.

Tôi biết rằng tôi muốn phương pháp này lấy hai giá trị của loại 'float', vì vậy tôi có thể sử dụng hai ký tự dấu phẩy động để hoàn thành biểu thức này.

Tôi sẽ thêm một kiểm tra bổ sung để kiểm tra rằng phương thức 'getDistanceFrom' trả về một giá trị float, vì đó là những gì đang được giả định bởi mã chung của tôi.

Tôi hiện đang sử dụng một yêu cầu biểu thức đơn giản để kiểm tra xem loại đó có phương thức 'getDistanceFrom' hay không.

Tuy nhiên, tôi có thể sử dụng yêu cầu ghép thay vì yêu cầu biểu thức để kiểm tra xem nó có trả về giá trị float hay không.

Toán tử mũi tên có thể tuân theo yêu cầu ghép.

Toán tử mũi tên mong đợi một ràng buộc ở phía bên tay phải của nó, vì vậy đây là nơi tôi có thể sử dụng khái niệm thư viện tiêu chuẩn như 'giống_as' để xác thực rằng lệnh gọi phương thức 'getDistanceFrom' trả về giá trị float.

Bây giờ khái niệm này có vẻ đã sẵn sàng đối với tôi.

Tôi có thể tiếp tục và sử dụng nó để hạn chế các loại có thể được chuyển đến chức năng 'computePixelColor' của tôi.

Bây giờ chức năng 'computePixelColor' chung của tôi sẽ chỉ hoạt động với các loại đáp ứng khái niệm 'Hình dạng'.

Điều này có nghĩa là các lớp như Circle và Crescent sẽ được hiển thị bằng cách sử dụng chức năng 'computePixelColor' chung cụ thể này, vì cả hai loại này đều đáp ứng khái niệm 'Shape'.

Sau khi nhìn thấy các hình dạng đơn giản được hiển thị, tôi muốn tạo một phiên bản khác của 'computePixelColor' để thêm màu sắc cho một số hình dạng của tôi.

Giả sử tôi muốn thêm một lớp GradientCircle đầy màu sắc vào thư viện hình dạng của mình.

Bây giờ tôi cần một chức năng mới để tính toán màu điểm ảnh trong hình ảnh.

C++20 cho phép tôi tạo ra nhiều biến thể của mẫu hàm 'computePixelColor'.

Mỗi biến thể phải được hạn chế bằng cách sử dụng các khái niệm khác nhau.

Tôi sẽ tạo ra một khái niệm GradientShape mới sẽ được thỏa mãn bởi các lớp học như GradientCircle.

Khái niệm này sau đó sẽ hạn chế một biến thể mới của 'computePixelColor' chỉ hoạt động với các hình dạng có độ dốc.

Khái niệm này được thực hiện bằng cách sử dụng biểu thức 'yêu cầu', giống như khái niệm Hình dạng.

Tuy nhiên, vì tôi muốn GradientShape cũng đáp ứng khái niệm Hình dạng ban đầu, tôi đưa nó vào yêu cầu đầu tiên trong khái niệm mới.

Điều này đảm bảo rằng một lớp thỏa mãn khái niệm GradientShape cũng thỏa mãn khái niệm Shape, có nghĩa là tôi vẫn có thể gọi phương thức 'getDistanceFrom' cho các giá trị của lớp đó.

Sau đó, tôi sử dụng logic và toán tử và biểu thức 'yêu cầu' để đảm bảo rằng khái niệm GradientShape chỉ có thể được thỏa mãn bởi các lớp có phương thức 'getGradientColor'.

Bây giờ tôi đã tạo ra khái niệm GradientShape, tôi có thể tiếp tục và tạo ra một biến thể mới của 'computePixelColor'.

Mẫu hàm này chỉ hoạt động với các lớp hình dạng có độ dốc, như lớp GradientCircle, vì nó bị hạn chế bởi khái niệm GradientShape.

Bây giờ tôi đã có tất cả các mảnh tại chỗ, tôi có thể tiếp tục và thử kết xuất một vòng tròn với độ dốc.

Ở đây tôi đang kết xuất một GradientCircle.

Hãy xem trình biên dịch sẽ chọn quá tải nào của 'computePixelColor' bên trong hàm 'kết xuất'.

Mặc dù GradientCircle có thể được sử dụng một cách an toàn với cả hai biến thể của computePixelColor, trình biên dịch chọn quá tải bị hạn chế với khái niệm GradientShape vì nó cụ thể hơn so với quá tải đầu tiên.

Bởi vì trình biên dịch chọn quá tải phù hợp nhất của 'computePixelColor', tôi có thể thấy vòng tròn gradient tuyệt đẹp này được hiển thị khi tôi kiểm tra thư viện của mình.

Thật tuyệt vời!

Bây giờ chúng ta hãy xem qua những gì chúng ta đã học được về việc tạo ra các khái niệm.

Bạn có thể tạo các khái niệm bằng cách xác định các yêu cầu hành vi trong mã chung hiện có của bạn.

Bạn nên sử dụng biểu thức yêu cầu để tạo ra các khái niệm để xác thực hành vi của các loại.

Bạn cũng có thể sử dụng các khái niệm để tạo ra các biến thể cụ thể hơn của các hàm và lớp chung.

Bây giờ chúng tôi đã thấy cách nâng cao mã C++ chung của bạn với các khái niệm.

Ngoài các khái niệm hỗ trợ, Xcode 14 cũng đã cải thiện hỗ trợ cho các tính năng C++20 khác.

Cụ thể hơn, tôi muốn nhấn mạnh sự hỗ trợ được cải thiện cho việc đánh giá mã C++ thời gian biên dịch trong Xcode 14.

Đánh giá mã thời gian biên dịch rất hữu ích vì nó có thể giảm chi phí khởi tạo cho các biến trong mã C++ của bạn.

Điều này có thể giúp giảm thời gian khởi chạy ứng dụng của bạn nếu ứng dụng của bạn có nhiều mã C++ phụ thuộc vào chuỗi khởi tạo phức tạp.

Thêm vào đó, đánh giá mã thời gian biên dịch có thể giúp bạn xác thực các hằng số yêu cầu xác thực tại thời điểm biên dịch.

Điều này có thể giúp bạn phát hiện lỗi trước khi mã của bạn chạy.

Hãy xem một ví dụ để xem cách tôi có thể sử dụng đánh giá mã thời gian biên dịch trong C++.

Ở đây tôi có một đoạn mã khởi tạo bảng màu trong thư viện kết xuất hình dạng của tôi.

Thư viện này sau đó được sử dụng trong một ứng dụng iOS hiển thị các hình dạng cho màn hình.

Mỗi màu trong bảng màu được khởi tạo bằng cách phân tích cú pháp một chuỗi theo nghĩa đen với mã hex HTML của màu.

Hiện tại, hàm 'fromHexCode' cần phân tích cú pháp ba ký tự chuỗi trong quá trình khởi tạo mảng.

Các hoạt động khởi tạo liên tục phức tạp như thế này có thể có tác động có thể đo lường được đến thời gian khởi chạy ứng dụng của tôi nếu tôi có nhiều trong số chúng.

Thay vào đó, tôi có thể sử dụng đánh giá mã thời gian biên dịch để đảm bảo rằng mảng này được khởi tạo với các giá trị màu không đổi.

Hãy để tôi chỉ cho bạn điều này có thể được thực hiện.

Từ khóa 'constexpr' cho phép đánh giá mã thời gian biên dịch trong C++.

Tôi phải thêm nó ở một vài nơi trong ví dụ của mình để đảm bảo rằng bảng màu là một mảng màu không đổi.

Đầu tiên, tôi cần thêm từ khóa 'constexpr' vào hàm 'fromHexCode'.

Trình biên dịch bây giờ sẽ có thể thực thi mã trong hàm này tại thời điểm biên dịch khi nó được sử dụng trong chuỗi khởi tạo thời gian biên dịch.

Bạn nên làm cho các hàm C++ của mình 'constexpr' khi bạn muốn chúng có thể đánh giá được tại thời điểm biên dịch.

Trình biên dịch sẽ cho bạn biết nếu mã trong hàm như vậy không thể được đánh giá tại thời điểm biên dịch bằng cách hiển thị lỗi khi bạn sử dụng nó trong chuỗi khởi tạo 'constexpr'.

Tuy nhiên, bạn cũng có thể kiểm tra một hàm trước khi thêm 'constexpr' để xem liệu nó có thể được đánh giá tại thời điểm biên dịch hay không.

Chúng ta hãy xem qua fromHexCode để xem cách kiểm tra xem một hàm như thế này có thể là ứng cử viên tốt để biên dịch đánh giá mã thời gian hay không.

Hàm này sử dụng một số cấu trúc ngôn ngữ như câu lệnh if và các phép toán nguyên thủy như toán tử so sánh và toán tử số học.

Tất cả các hoạt động này có thể được đánh giá tại thời điểm biên dịch.

Ngoài ra, hàm này thực hiện một số lệnh gọi đến một hàm khác; hexToInt.

Tôi đã chú thích hàm hexToInt với 'constexpr', vì vậy các cuộc gọi đến hàm này có thể được đánh giá tại thời điểm biên dịch.

Nhìn chung, có vẻ như fromHexCode chứa mã mà trình biên dịch có thể đánh giá tại thời điểm biên dịch, vì vậy tôi nghĩ sẽ an toàn để tiến hành và sử dụng nó trong trình tự khởi tạo thời gian biên dịch.

Sau khi đảm bảo rằng fromHexCode có thể được đánh giá tại thời điểm biên dịch, sau đó tôi cần thêm từ khóa 'constexpr' vào khai báo biến 'colorPalette'.

Trình biên dịch hiện đảm bảo rằng nó sẽ đánh giá toàn bộ chuỗi khởi tạo cho mảng này tại thời điểm biên dịch.

Cụ thể hơn, trình biên dịch sẽ đánh giá từng cuộc gọi đến hàm fromHexCode.

Đánh giá sẽ tạo ra một giá trị màu không đổi sẽ thay thế cuộc gọi ban đầu đến hàm trong trình khởi tạo bảng màu.

Vì tất cả các cuộc gọi đến fromHexCode hiện được thay thế bằng các giá trị màu không đổi, biến 'colorPalette' hiện được đảm bảo được khởi tạo bởi một mảng theo nghĩa đen chứa các giá trị màu không đổi.

Điều này có nghĩa là bây giờ ứng dụng của tôi không phải trả thêm chi phí cho việc phân tích các giá trị màu khi bảng màu này được khởi tạo.

Điều này rất tốt cho thời gian khởi chạy ứng dụng của tôi, vì nó làm giảm khối lượng công việc mà thư viện C++ bên trong ứng dụng này phải làm khi khởi động.

Bạn nên làm cho các biến C++ của mình 'constexpr' khi bạn muốn đảm bảo rằng chúng được khởi tạo với các giá trị không đổi.

Xcode 14 đã thực sự cải thiện đáng kể hỗ trợ thư viện tiêu chuẩn của nó để đánh giá thời gian biên dịch.

Năm nay chúng tôi đã thêm hỗ trợ 'constexpr' vào một số loại thư viện và thuật toán tiêu chuẩn khác nhau, hiện có thể được sử dụng trong quá trình đánh giá mã thời gian biên dịch.

Thêm vào đó, Xcode 14 đã cải thiện đáng kể hỗ trợ tiêu chuẩn C++20 của nó.

Tất cả các tính năng được hiển thị ở đây hiện có thể được sử dụng ở chế độ C++ 20.

Bạn nên chuyển sang chế độ C++ 20 ngay hôm nay nếu bạn chưa làm như vậy.

Bạn có thể sử dụng cài đặt "Phương ngữ ngôn ngữ C++" trong dự án Xcode của mình để nâng cấp lên C++ 20.

Chuyển sang C++20 sẽ cho phép bạn sử dụng các tính năng như khái niệm trong mã của mình.

C++20 không yêu cầu mục tiêu triển khai tối thiểu, vì vậy bạn vẫn có thể gửi mã của mình cho cùng một phiên bản hệ điều hành mà bạn hiện đang nhắm mục tiêu.

Dùng thử C++20 ngay hôm nay.

Cảm ơn bạn!

Tận hưởng phần còn lại của hội nghị nhà phát triển.