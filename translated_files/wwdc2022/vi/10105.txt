10105

♪ ♪

Xin chào, tên tôi là Yi.

Xin chào, tên tôi là Dominik.

Và chúng tôi là kỹ sư phần mềm GPU.

Hôm nay, Dominik và tôi sẽ nói về các cải tiến và tính năng hiệu suất mà chúng tôi đã thêm vào API dò tia kim loại trong năm nay để giúp bạn tối đa hóa hiệu suất của các ứng dụng dò tia của mình.

Các ứng dụng dò tia mô phỏng các tia sáng riêng lẻ nảy xung quanh một cảnh.

Điều này được sử dụng trong các trò chơi và kết xuất ngoại tuyến để tạo ra phản xạ chân thực, bóng tối, chiếu sáng toàn cầu và hơn thế nữa.

Điều này đòi hỏi phải mô phỏng rất nhiều tia, vì vậy hiệu suất là rất quan trọng đối với các ứng dụng này.

May mắn thay, Metal đã tích hợp hỗ trợ theo dõi tia được tối ưu hóa cho tất cả các thiết bị của Apple.

Hãy xem xét ngắn gọn cách hoạt động của dò tia trong Metal.

API dò tia kim loại có sẵn từ bên trong các hàm đổ bóng như chức năng tính toán hoặc phân đoạn.

Chúng tôi bắt đầu bằng cách tạo ra một số tia được phát ra hiện trường.

Tiếp theo, chúng tôi tạo ra một đối tượng liên ngành và sử dụng nó để kiểm tra giao điểm giữa các tia của chúng ta và hình học trong cảnh.

Một lát sau, tôi sẽ mô tả một số tính năng mới mà chúng tôi đã thêm vào trong năm nay để tăng tốc độ tìm kiếm giao lộ.

Quá trình này phụ thuộc vào một cấu trúc dữ liệu đặc biệt được gọi là cấu trúc gia tốc, cũng đại diện cho hình học trong cảnh.

Tôi cũng sẽ nói về một số tính năng mới và cải tiến hiệu suất tập trung vào cấu trúc tăng tốc ngày hôm nay.

Liên ngành trả về một đối tượng kết quả giao nhau mô tả nguyên thủy mỗi tia bắn trúng.

Kết quả giao nhau được sử dụng để tạo ra một màu để ghi vào hình ảnh đầu ra.

Nó cũng có thể được sử dụng để tạo ra các tia bổ sung trải qua quá trình một lần nữa.

Chúng ta có thể lặp lại quá trình này bao nhiêu lần tùy thích để mô phỏng ánh sáng nảy xung quanh cảnh.

Nếu bạn muốn tìm hiểu thêm về những điều cơ bản của API dò tia kim loại, tôi khuyên bạn nên xem lại các phiên WWDC trước đây của chúng tôi.

Lần đầu tiên chúng tôi giới thiệu API dò tia kim loại tại WWDC20 và năm ngoái, chúng tôi đã giới thiệu các tính năng mới bao gồm hỗ trợ làm mờ chuyển động.

Hôm nay, tôi sẽ nói về ba điều.

Đầu tiên, tôi sẽ cho bạn biết về các tính năng mới cho phép bạn cải thiện hiệu suất dò tia trong các ứng dụng của mình.

Tiếp theo, tôi sẽ nói về những cải tiến và tính năng mà chúng tôi đã thêm vào API cấu trúc tăng tốc.

Cuối cùng, Dominik sẽ cho bạn biết về những cải tiến đối với các công cụ GPU của chúng tôi để dò tia.

Năm nay, chúng tôi đã thêm ba tính năng mới nhằm cải thiện hiệu suất dò tia hoặc đơn giản hóa mã của bạn.

Chúng là dữ liệu trên mỗi nguyên thủy, khả năng truy xuất bộ đệm từ các bảng hàm giao điểm và hỗ trợ truy tìm tia từ bộ đệm lệnh gián tiếp.

Hãy bắt đầu với dữ liệu mỗi nguyên thủy.

Các ứng dụng thường có dữ liệu được liên kết với nguyên thủy trong cảnh của chúng như màu đỉnh, chuẩn và tọa độ kết cấu.

Năm nay, chúng tôi đã thêm khả năng lưu trữ một lượng nhỏ dữ liệu cho mỗi nguyên thủy trực tiếp trong cấu trúc gia tốc.

Dữ liệu này có thể được truy cập với ít gián tiếp bộ nhớ hơn và lỗi bộ nhớ cache, cải thiện hiệu suất.

Điều này cũng làm giảm nhu cầu lưu trữ cấu trúc dữ liệu phụ trợ phức tạp thường được yêu cầu để tra cứu dữ liệu liên quan đến nguyên thủy của bạn.

Hãy xem xét một ví dụ.

Kiểm tra alpha là một kỹ thuật được sử dụng để thêm độ phức tạp cho hình học trong suốt mà không làm tăng số lượng tam giác.

Trong kỹ thuật này, kênh alpha của kết cấu được ánh xạ lên hình tam giác được sử dụng để xác định xem tia sẽ chạm vào tam giác hay tiếp tục xa hơn.

Để đạt được điều này, bạn cần cấu hình liên ngành để gọi hàm giao nhau tùy chỉnh của mình khi một tam giác bị tia va vào.

Mục tiêu cuối cùng là lấy mẫu từ kết cấu liên quan đến tam giác và kiểm tra xem giá trị alpha có cho phép tia tiếp tục đi qua nguyên thủy hay không.

Để đến đó, bạn cần hai thông tin: đối tượng kết cấu và tọa độ UV.

Trong một triển khai điển hình của thử nghiệm alpha, bạn sẽ cần truy cập một số bộ đệm trung gian trong bộ nhớ thiết bị Metal để có được thông tin này.

Đầu tiên, bạn sẽ lưu trữ kết cấu liên quan đến nguyên thủy trong một số loại cấu trúc vật liệu.

Một số vật liệu sẽ được đóng gói vào bộ đệm.

Sẽ không thực tế khi lưu trữ cấu trúc vật liệu cho mọi nguyên thủy, vì chúng có thể khá lớn và có thể có rất nhiều nguyên thủy.

Thay vào đó, bạn sẽ chỉ muốn lưu trữ ID vật liệu cho mỗi nguyên thủy trong bộ đệm và sử dụng chúng để tra cứu tài liệu.

Tiếp theo, để tính toán tia cực tím, bạn cần tải tia cực tím cho mỗi đỉnh từ một bộ đệm khác và nội suy chúng.

Cuối cùng, giả sử bạn đang sử dụng hình học ví dụ.

Bạn có thể muốn mỗi trường hợp có vật liệu và ánh xạ tia cực tím riêng.

Để hỗ trợ điều đó, bạn sẽ lưu trữ các con trỏ đến bộ đệm UV và Material ID trong bộ đệm Dữ liệu Phiên bản, thêm một cấp độ gián tiếp khác vào chức năng của bạn.

Cách tiếp cận này yêu cầu bạn duy trì một thiết lập bộ đệm khá phức tạp và liên quan đến nhiều lớp gián tiếp để có được dữ liệu mà bạn cần.

Điều này cũng có thể dẫn đến việc bỏ lỡ bộ nhớ cache sẽ ảnh hưởng tiêu cực đến hiệu suất.

Hãy xem mã cần thiết để thực hiện sơ đồ này.

Sau đó, tôi sẽ chỉ cho bạn cách bạn có thể đơn giản hóa nó từng bước bằng cách sử dụng dữ liệu mỗi nguyên thủy.

Đây là triển khai ban đầu của hàm giao điểm kiểm tra alpha.

Hàm này được gọi khi tia chạm vào một tam giác được kiểm tra alpha.

Chức năng bắt đầu bằng cách tải dữ liệu phiên bản từ bộ nhớ.

Đây là bộ đệm chứa các con trỏ đến tia cực tím và bộ đệm vật liệu được sử dụng bởi ví dụ.

Tiếp theo, chức năng tải tọa độ UV từ bộ đệm UV và nội suy chúng.

Đây là một lần tải bộ nhớ khác.

Sau đó, hàm tải chỉ mục vật liệu từ một bộ đệm khác.

Và cuối cùng, chức năng tải vật liệu và lấy mẫu kết cấu tương ứng.

Tại thời điểm này, hàm có giá trị alpha cần thiết và có thể so sánh nó với ngưỡng.

Bây giờ, tôi sẽ chỉ cho bạn cách bạn có thể đơn giản hóa mã này và cải thiện hiệu suất của nó bằng cách sử dụng dữ liệu per-primitive.

Thay vì sử dụng thiết lập bộ đệm phức tạp với nhiều lớp gián tiếp, bạn chỉ có thể lưu trữ dữ liệu mà hàm giao điểm sẽ cần cho mỗi nguyên thủy trực tiếp trong cấu trúc gia tốc.

Trong ví dụ này, bạn có thể tạo một cấu trúc chứa kết cấu và tọa độ UV cho mỗi nguyên thủy.

Bạn cung cấp dữ liệu này khi xây dựng cấu trúc gia tốc và hàm giao điểm chỉ đơn giản là nhận một con trỏ đến dữ liệu đó khi một tia chạm vào nguyên thủy.

Bạn có thể lưu trữ bất cứ thứ gì bạn thích trong dữ liệu mỗi nguyên thủy, nhưng giữ kích thước nhỏ sẽ giúp đạt được hiệu suất tốt nhất.

Tôi sẽ bắt đầu với các đầu vào cho chức năng giao nhau.

Có quyền truy cập vào tất cả chúng mang lại cho bạn rất nhiều sự linh hoạt khi triển khai, nhưng nó cũng có thể tăng mức sử dụng đăng ký trên GPU.

Với dữ liệu mỗi nguyên thủy, thay vì tất cả các bộ đệm, bạn chỉ cần truy cập con trỏ dữ liệu nguyên thủy.

Đây là dữ liệu bạn lưu trữ trực tiếp trong cấu trúc gia tốc.

Trong trường hợp này, mỗi nguyên thủy có đối tượng kết cấu riêng và tia cực tím cho tất cả các đỉnh của nó.

Tiếp theo là tải từ bộ đệm vật liệu toàn cầu và bộ đệm dữ liệu phiên bản.

Bạn sẽ không cần một trong hai cái.

Thay vào đó, bạn có thể thực hiện một lần tải từ con trỏ dữ liệu mỗi nguyên thủy.

Đây là quyền truy cập bộ nhớ thiết bị duy nhất cần thiết trong chức năng này.

Tiếp theo là tia cực tím.

Thay vì hủy tham chiếu một con trỏ được truy xuất từ dữ liệu phiên bản, bạn chỉ cần truy cập dữ liệu được nhúng trong cấu trúc dữ liệu per-primitive.

Sự thay đổi trong mã rất tinh tế, nhưng rất quan trọng đối với hiệu suất, vì không có tải bộ nhớ bổ sung nào liên quan.

Cuối cùng, có những tính chất vật chất.

Vì phần duy nhất của vật liệu cần thiết là kết cấu, bạn có thể mã hóa kết cấu nguyên thủy trực tiếp trong cấu trúc dữ liệu per-primitive.

Điều này có nghĩa là bạn không cần truy cập bộ đệm chỉ mục vật liệu và vật liệu nữa.

Bạn có thể chỉ cần sử dụng kết cấu trực tiếp mà không phải trả chi phí cho việc hủy tham chiếu bộ nhớ bổ sung.

Đây là cách mã giao nhau của bạn có thể đơn giản hơn bao nhiêu khi sử dụng dữ liệu per-primitive.

Tất cả các truy cập bộ nhớ tốn kém được thay thế chỉ bằng một lần tải từ con trỏ dữ liệu nguyên thủy.

Trên hết, mã đơn giản và dễ theo dõi hơn nhiều.

Tiếp theo, tôi sẽ chỉ cho bạn cách lưu trữ dữ liệu nguyên thủy trong cấu trúc gia tốc.

Bạn sẽ cần phải làm điều này trước khi bạn có thể truy cập nó từ một chức năng giao lộ.

Bạn sẽ cần thiết lập một vài trường trong mô tả hình học cấu trúc gia tốc.

Đầu tiên, đặt bộ đệm Metal nơi lưu trữ tất cả dữ liệu.

Tiếp theo, chỉ định kích thước của dữ liệu sẽ được lưu trữ cho mỗi nguyên thủy.

Nếu dữ liệu của bạn không được đóng gói chặt chẽ trong bộ đệm hoặc không bắt đầu ở đầu bộ đệm, bạn cũng có thể chỉ định sải chân và độ lệch.

Nếu không, các giá trị này mặc định là 0 nên bạn không cần phải đặt chúng.

Bạn đã thấy cách bạn có thể sử dụng dữ liệu per-primitive trong một hàm giao nhau.

Nó chỉ đơn giản được chuyển vào hàm như một con trỏ.

Nhưng đó không phải là tất cả - bạn có quyền truy cập vào dữ liệu này bất cứ nơi nào bạn cần.

Điều đó bao gồm kết quả giao nhau cuối cùng được trả về bởi liên ngành.

Và nếu bạn đang sử dụng truy vấn giao điểm, dữ liệu nguyên thủy cũng có sẵn cho cả giao điểm ứng cử viên và giao điểm đã cam kết.

Điều này có nghĩa là bạn có thể sử dụng dữ liệu per-primitive để đổ bóng ngoài việc kiểm tra giao lộ.

Dữ liệu mỗi nguyên thủy có thể cải thiện hiệu suất của cả mã giao điểm và mã đổ bóng của bạn bằng cách giảm số lần truy cập và gián tiếp bộ nhớ.

Trên thực tế, chúng tôi đã tìm thấy trong một trong những ứng dụng thử nghiệm của riêng mình rằng việc sử dụng dữ liệu mỗi nguyên thủy dẫn đến cải thiện hiệu suất từ 10% đến 16%.

Chúng tôi không thể chờ đợi bạn dùng thử và xem bạn có thể nhận được những loại cải tiến nào về hiệu suất và chất lượng mã.

Năm nay, chúng tôi cũng đã thêm một tính năng tiện lợi khác vào ngôn ngữ đổ bóng kim loại để giúp bạn đơn giản hóa hạt nhân dò tia của mình.

Các ứng dụng thường truyền cùng một tập hợp các ràng buộc cho cả chức năng giao nhau và hạt nhân dò tia chính của chúng.

Ví dụ, mã mẫu dò tia của chúng tôi sử dụng hàm giao nhau để hiển thị các quả cầu.

Hàm giao điểm này truy cập vào bộ đệm tài nguyên chứa thông tin về từng quả cầu.

Để chuyển bộ đệm này vào hàm giao điểm, ứng dụng liên kết bộ đệm với bảng hàm giao nhau.

Tuy nhiên, hạt nhân dò tia chính cũng cần quyền truy cập vào bộ đệm tài nguyên, vì vậy ứng dụng cũng liên kết bộ đệm ở đó.

Năm nay, ngôn ngữ đổ bóng kim loại cho phép bạn truy cập các bộ đệm bị ràng buộc với các bảng chức năng giao nhau.

Với tính năng mới này, bạn có thể tiết kiệm công sức liên kết bộ đệm cho hạt nhân và thay vào đó truy cập nó trực tiếp từ bảng hàm giao điểm.

Bạn có thể làm điều này bằng cách gọi phương thức get_buffer trên bảng hàm giao điểm, cung cấp loại con trỏ của nó.

Bạn cũng có thể truy cập các bảng chức năng hiển thị theo loại chức năng của chúng.

Bộ đệm lệnh gián tiếp cho phép bạn mã hóa GPU hoạt động độc lập trên GPU và đại diện cho một yếu tố cơ bản của các đường ống điều khiển GPU.

Để tìm hiểu thêm về bộ đệm lệnh gián tiếp và kết xuất dựa trên GPU, chúng tôi khuyên bạn nên xem lại phiên "Kết xuất hiện đại với Kim loại" từ WWDC 2019.

Cho phép hỗ trợ dò tia trong bộ đệm lệnh gián tiếp rất dễ dàng.

Tất cả những gì bạn phải làm là đặt cờ supportRayTracing trên bộ mô tả.

Bộ đệm lệnh gián tiếp gửi đồ họa và các chức năng tính toán, vì vậy bạn có thể chỉ cần sử dụng dò tia từ các chức năng đó như bình thường.

Đó là tóm tắt tất cả các tính năng mới mà chúng tôi đã thêm vào trong năm nay để giúp bạn cải thiện hiệu suất dò tia trong các ứng dụng của mình.

Tiếp theo, hãy nói về cấu trúc gia tốc.

Chúng tôi đã triển khai một số cải tiến hiệu suất và các tính năng bổ sung tập trung vào việc xây dựng các cấu trúc gia tốc.

Hãy tóm tắt lại những gì chúng được sử dụng để làm.

Cấu trúc gia tốc là cấu trúc dữ liệu giúp đẩy nhanh quá trình dò tia.

Họ làm điều này bằng cách phân chia không gian đệ quy để chúng ta có thể nhanh chóng tìm thấy hình tam giác nào có khả năng giao với một tia.

Để hỗ trợ xây dựng các cảnh phức tạp, Metal hỗ trợ hai loại cấu trúc gia tốc: cấu trúc gia tốc nguyên thủy và cấu trúc gia tốc ví dụ.

Các mảnh hình học riêng lẻ được thể hiện bằng cách sử dụng các cấu trúc gia tốc nguyên thủy.

Chúng có thể là một cái gì đó đơn giản như một mặt phẳng hoặc một khối lập phương, hoặc một cái gì đó phức tạp hơn như một hình cầu hoặc một lưới tam giác.

Bạn có thể tạo các cảnh phức tạp hơn bằng cách sử dụng cấu trúc tăng tốc phiên bản.

Các cấu trúc gia tốc phiên bản tạo ra các bản sao của các cấu trúc gia tốc nguyên thủy.

Đầu tiên, xác định ma trận biến đổi cho từng đối tượng trong cảnh của bạn.

Sau đó, sử dụng mảng ma trận biến đổi và cấu trúc gia tốc nguyên thủy để xây dựng cấu trúc gia tốc thể hiện.

Đó là cách bạn có thể xây dựng một cảnh tĩnh bằng cách sử dụng các cấu trúc gia tốc.

Tiếp theo, hãy xem các ứng dụng động như trò chơi sẽ sử dụng cấu trúc tăng tốc như thế nào.

Hãy bắt đầu từ đầu: có một số nhiệm vụ bạn cần làm khi lần đầu tiên khởi chạy trò chơi hoặc tải một cấp độ mới.

Điều này bao gồm các tác vụ thông thường như tải mô hình và kết cấu.

Với dò tia, bạn cũng cần xây dựng các cấu trúc gia tốc nguyên thủy cho tất cả các mô hình sẽ được sử dụng.

Chúng tôi khuyên bạn nên xây dựng càng nhiều cấu trúc gia tốc nguyên thủy của mình càng tốt tại thời điểm tải để tiết kiệm thời gian trong vòng lặp kết xuất chính của bạn.

Bạn có thể sử dụng cấu trúc tăng tốc phiên bản để thêm hoặc xóa các đối tượng này khỏi cảnh nếu cần.

Khi ứng dụng của bạn tải xong, nó sẽ đi vào vòng lặp chính.

Mỗi khung hình, nó hiển thị cảnh bằng cách sử dụng kết hợp rasterization, dò tia và xử lý hậu kỳ.

Tuy nhiên, vì các trò chơi rất năng động, bạn có thể sẽ cần cập nhật một số cấu trúc tăng tốc.

Điều này thường bao gồm việc trang bị lại một số mô hình biến dạng hoặc hoạt hình như các nhân vật lột da.

Việc trang bị lại cấu trúc tăng tốc hiện có nhanh hơn nhiều so với việc xây dựng lại toàn bộ, vì vậy chúng tôi khuyên bạn nên sử dụng nó cho những trường hợp như thế này.

Bạn cũng nên xây dựng lại toàn bộ cấu trúc tăng tốc phiên bản.

Điều này là cần thiết vì các đối tượng có thể đã được thêm hoặc xóa khỏi cảnh kể từ khung hình cuối cùng hoặc chúng có thể đã di chuyển đáng kể.

Việc xây dựng lại toàn bộ là tốt trong trường hợp này vì chỉ có một cấu trúc gia tốc phiên bản và nó thường chỉ chứa tối đa vài nghìn đối tượng.

Năm nay, chúng tôi đã cải thiện hiệu suất cho tất cả các trường hợp này.

Đầu tiên, các bản dựng cấu trúc tăng tốc hiện nhanh hơn tới 2,3 lần trên Apple Silicon.

Thứ hai, việc tái trang bị cũng nhanh hơn tới 38%.

Điều này có nghĩa là cả thời gian tải và chi phí trên mỗi khung đều giảm.

Nhưng nó thậm chí còn tốt hơn.

Một số ứng dụng xây dựng hàng trăm hoặc thậm chí hàng nghìn cấu trúc gia tốc nguyên thủy nhỏ.

Những bản dựng nhỏ này không thực hiện đủ công việc riêng lẻ để lấp đầy GPU, dẫn đến thời gian dài sử dụng GPU thấp.

Do đó, nhiều bản dựng hiện được tự động thực hiện song song bất cứ khi nào có thể trên Apple Silicon.

Điều này dẫn đến việc xây dựng nhanh hơn tới 2,8 lần khi chúng chạy song song.

Điều này tiếp tục giảm thời gian tải.

Và điều này không chỉ áp dụng cho các bản dựng: nó áp dụng cho tất cả các hoạt động cấu trúc gia tốc bao gồm nén chặt và trang bị lại, vì vậy chi phí trên mỗi khung hình của bạn cũng được giảm bớt.

Có một vài hướng dẫn bạn sẽ cần tuân theo để đảm bảo rằng bạn có thể hưởng lợi từ việc tối ưu hóa này.

Đây là một ví dụ xây dựng một loạt các cấu trúc gia tốc.

Để xây dựng chúng song song, bạn sẽ cần đảm bảo rằng bạn sử dụng cùng một bộ mã hóa lệnh cấu trúc tăng tốc cho nhiều bản dựng.

Ngoài ra, các bản dựng sử dụng cùng một bộ đệm đầu không thể chạy song song.

Do đó, bạn sẽ muốn đảm bảo rằng bạn đang lặp qua một nhóm nhỏ các bộ đệm đầu thay vì sử dụng cùng một bộ đệm đầu cho mỗi bản dựng.

Đó là tất cả những cải tiến hiệu suất mà chúng tôi đã thực hiện để xây dựng các cấu trúc gia tốc.

Chúng tôi cũng đã thêm ba tính năng mới để giúp xây dựng các cấu trúc gia tốc dễ dàng và hiệu quả hơn.

Chúng hỗ trợ cho các định dạng đỉnh bổ sung, ma trận biến đổi và phân bổ cấu trúc gia tốc từ đống.

Hãy bắt đầu với các định dạng đỉnh.

Tối ưu hóa hiệu suất phổ biến là sử dụng các định dạng định dạng định lượng tử hóa hoặc giảm độ chính xác cho dữ liệu đỉnh, dẫn đến việc sử dụng bộ nhớ thấp hơn.

Năm nay, bạn có thể xây dựng các cấu trúc gia tốc từ một loạt các định dạng đỉnh.

Điều này bao gồm một nửa định dạng dấu phẩy động chính xác, hai định dạng đỉnh thành phần cho hình học phẳng và tất cả các định dạng số nguyên chuẩn hóa thông thường.

Trước đây, các cấu trúc gia tốc đã yêu cầu ba thành phần, dữ liệu đỉnh dấu phẩy động có độ chính xác đầy đủ.

Trong ví dụ này, ứng dụng có dữ liệu đỉnh ở định dạng đỉnh chính xác một nửa.

Dữ liệu này cần được giải nén và sao chép vào bộ đệm tạm thời chỉ để xây dựng cấu trúc gia tốc.

Với tính năng định dạng đỉnh mới, các bản dựng cấu trúc gia tốc hiện có thể tiêu thụ dữ liệu đỉnh ở bất kỳ định dạng nào được hỗ trợ, loại bỏ nhu cầu tạo bản sao tạm thời.

Cài đặt định dạng đỉnh không thể đơn giản hơn.

Tất cả những gì bạn cần làm là đặt thuộc tính trên bộ mô tả hình học của bạn.

Tiếp theo, hãy nói về ma trận biến đổi.

Tính năng này bổ sung cho các định dạng đỉnh mới, để bạn có thể chuyển đổi trước dữ liệu đỉnh của mình trước khi xây dựng cấu trúc tăng tốc.

Ví dụ, bạn có thể muốn sử dụng chúng để giải nén các mắt lưới phức tạp được lưu trữ ở định dạng chuẩn hóa.

Hãy xem xét mô hình Gấu trúc đỏ trong cảnh này.

Để bình thường hóa hình học để sử dụng một trong các định dạng nén của chúng tôi, bạn lấy lưới, tính toán giới hạn của nó và sau đó chia tỷ lệ chúng thành phạm vi từ 0 đến một.

Sau đó, bạn có thể sử dụng một trong các định dạng đỉnh số nguyên được chuẩn hóa để lưu trữ lưới, giảm dung lượng mà nó chiếm trên đĩa và trong bộ nhớ.

Trong thời gian chạy, bạn cung cấp một ma trận sẽ chia tỷ lệ và bù đắp từng đỉnh đến vị trí cuối cùng.

Áp dụng ma trận đó sẽ truy xuất mô hình ban đầu.

Bây giờ chúng ta hãy đi qua cách thiết lập cấu trúc gia tốc truyền một ma trận biến đổi.

Bạn bắt đầu bằng cách tạo bộ đệm biến đổi.

Một cách để làm điều này là tạo ra một đối tượng MTLPackedFloat4x3 chứa ma trận chuyển đổi tỷ lệ và bù đắp.

Sau đó, tạo một Bộ đệm kim loại đủ lớn để giữ ma trận.

Và cuối cùng, sao chép ma trận vào Bộ đệm.

Tiếp theo, thiết lập cấu trúc gia tốc.

Đầu tiên, tạo một mô tả hình học tam giác.

Sau đó, chỉ định Bộ đệm Ma trận biến đổi.

Và cuối cùng là Bù đắp bộ đệm.

Đó là tất cả những gì bạn cần làm để thiết lập ma trận chuyển đổi.

Những ma trận này cũng có thể được sử dụng để kết hợp các cấu trúc gia tốc đơn giản để cải thiện hiệu suất dò tia.

Hãy xem một cảnh ví dụ.

Ở đây, các hộp và quả cầu đều là những mắt lưới tương đối đơn giản.

Điều này thể hiện một cơ hội để tối ưu hóa cấu trúc gia tốc cho nhóm này ở phía trước của cảnh.

Tập trung vào cấu trúc gia tốc của phiên bản, có một chi phí cho mỗi trường hợp mà tia của bạn chiếu vào.

Có một chi phí cho việc chuyển đổi tia và sau đó chuyển từ phiên bản sang cấu trúc gia tốc nguyên thủy.

Điều này xảy ra thường xuyên hơn với các trường hợp chồng chéo.

Để giảm số lượng phiên bản, bạn có thể tạo một cấu trúc gia tốc nguyên thủy duy nhất chứa cả hộp và hình cầu.

Để làm điều này, bạn có thể tạo một bộ mô tả hình học cho mỗi đối tượng, mỗi đối tượng có ma trận biến đổi riêng.

Cấu trúc gia tốc nguyên thủy kết quả là một thể hiện duy nhất trong cấu trúc gia tốc thể hiện và chứa các hộp và hình cầu.

Điều này sẽ dẫn đến một cấu trúc gia tốc hoạt động tốt hơn.

Hãy xem cách thiết lập cái này trong mã.

Bạn bắt đầu với bộ mô tả xác định hình học hình cầu.

Tiếp theo, đặt bộ đệm đỉnh, bộ đệm chỉ mục và các thuộc tính khác như bình thường cho cấu trúc gia tốc nguyên thủy.

Sự khác biệt là, bạn cũng chỉ định bộ đệm biến đổi có chứa ma trận biến đổi được sử dụng cho bản sao của hình cầu.

Đối với các hộp, bạn có nhiều mô tả hình học chia sẻ bộ đệm đỉnh và chỉ mục.

Bạn chỉ cần chỉ định các bộ đệm biến đổi khác nhau cho mỗi bản sao.

Cuối cùng, khi tạo bộ mô tả cho cấu trúc gia tốc nguyên thủy, hãy thêm tất cả các bộ mô tả hình học.

Điều này sẽ dẫn đến một cấu trúc gia tốc nguyên thủy mà bạn có thể đưa vào cảnh với một biến đổi danh tính.

Cấu trúc gia tốc nguyên thủy này sẽ mất ít thời gian hơn để xây dựng so với các cấu trúc gia tốc riêng biệt và sẽ giao nhau nhanh hơn.

Cuối cùng, việc phân bổ đống các cấu trúc gia tốc là một trong những tính năng được yêu cầu nhiều nhất của chúng tôi.

Với tính năng này, giờ đây bạn có nhiều quyền kiểm soát hơn đối với việc phân bổ cấu trúc gia tốc.

Nó cũng cho phép bạn sử dụng lại bộ nhớ đống giữa các lần phân bổ, tránh phân bổ bộ đệm tốn kém.

Heaps cũng có thể giúp cải thiện hiệu suất bằng cách giảm các cuộc gọi đến phương thức useResource: khi sử dụng các cấu trúc tăng tốc phiên bản.

Quay trở lại cảnh ví dụ, cấu trúc gia tốc phiên bản tham chiếu các cấu trúc gia tốc nguyên thủy một cách gián tiếp.

Điều này có nghĩa là mỗi lần bạn muốn sử dụng cấu trúc tăng tốc phiên bản với bộ mã hóa lệnh, bạn cần gọi phương thức useResource: cho mỗi cấu trúc tăng tốc nguyên thủy.

Đối với các cảnh lớn, điều này có thể yêu cầu hàng nghìn cuộc gọi để sử dụng Tài nguyên: mỗi lần bạn sử dụng cấu trúc tăng tốc phiên bản.

Biết rằng bạn có rất nhiều lệnh gọi useResource:, bạn có thể gọi useResources: để giảm số lượng lệnh gọi API, nhưng bạn vẫn cần duy trì một mảng các cấu trúc gia tốc của mình và Metal vẫn cần lặp qua mảng.

Thay vào đó, bạn có thể phân bổ tất cả các cấu trúc gia tốc nguyên thủy này từ cùng một đống.

Khi bạn muốn sử dụng cấu trúc tăng tốc thể hiện, bạn chỉ cần thực hiện một cuộc gọi duy nhất đến phương thức useHeap: để tham chiếu tất cả các cấu trúc tăng tốc nguyên thủy.

Chúng tôi đã thấy một sự cải thiện hiệu suất nhỏ trong một ứng dụng đơn giản bằng cách thay thế các cuộc gọi đến useResource: bằng một cuộc gọi duy nhất để useHeap:.

Hãy xem cách bạn có thể phân bổ cấu trúc gia tốc từ một đống.

Bạn có thể trực tiếp phân bổ cấu trúc gia tốc bằng cách gọi một phương thức trên đống lấy mô tả cấu trúc gia tốc làm đầu vào.

Nếu bạn không phân bổ bằng cách sử dụng bộ mô tả, thiết bị Metal sẽ xác định kích thước và yêu cầu căn chỉnh để phân bổ cấu trúc gia tốc từ một đống.

Bạn có thể lấy thông tin này từ thiết bị Metal bằng cách cung cấp mô tả hoặc kích thước cấu trúc gia tốc.

Khi kích thước cuối cùng được xác định, bạn có thể phân bổ cấu trúc gia tốc từ đống.

Có một vài điều cần nhớ khi sử dụng đống.

Đầu tiên, hãy nhớ gọi useHeap: để làm cho tất cả các cấu trúc gia tốc trong đống cư trú trong suốt thời gian dò tia vượt qua.

Thứ hai, theo mặc định, Metal không theo dõi tài nguyên bạn phân bổ từ một đống.

Bạn có thể chọn tham gia theo dõi rủi ro tài nguyên hoặc bạn có thể quản lý đồng bộ hóa của riêng mình theo cách thủ công.

Bạn có thể sử dụng MTLFences để đồng bộ hóa giữa các bộ mã hóa lệnh và MTLEvents để đồng bộ hóa trên các bộ đệm lệnh.

Đó là những tính năng mới và cải tiến hiệu suất trong API dò tia kim loại trong năm nay.

Tiếp theo, Dominik sẽ nói về những cải tiến đối với các công cụ Metal của Xcode sẽ tăng năng suất của bạn khi phát triển các ứng dụng dò tia.

Dominik: Cảm ơn, Yi.

Có rất nhiều cải tiến đối với các công cụ Metal trong Xcode 14, nhưng ở đây, tôi muốn nhấn mạnh chỉ một số cải tiến đặc biệt hữu ích khi phát triển các ứng dụng dò tia Bắt đầu với trình gỡ lỗi Metal, tôi sẽ nói về những cải tiến đối với Trình xem cấu trúc tăng tốc, Shader Profiler và Trình gỡ lỗi Shader.

Sau đó, tôi sẽ làm tròn nó với Xác thực Shader thời gian chạy.

Đầu tiên, chúng ta hãy xem Trình xem Cấu trúc Tăng tốc.

Trình xem cấu trúc gia tốc trong Trình gỡ lỗi kim loại cho phép bạn kiểm tra, rất chi tiết, tất cả các hình học và trường hợp của tất cả các mắt lưới tạo nên cấu trúc gia tốc của bạn.

Xcode 14 hiện hỗ trợ gỡ lỗi các cấu trúc gia tốc với chuyển động nguyên thủy hoặc phiên bản và chế độ nổi bật mới để trực quan hóa các nguyên thủy với trình kiểm tra dữ liệu mỗi nguyên thủy.

Hãy xem chúng hoạt động.

Nếu bạn đang sử dụng các cấu trúc gia tốc với chuyển động, bây giờ bạn có một máy chà sàn ở thanh dưới cùng để xem cấu trúc gia tốc của bạn tại các thời điểm khác nhau.

Ở bên phải của máy chà sàn là một nút "phát".

Bạn có thể sử dụng nó để phát hoạt ảnh qua lại trong một vòng lặp.

Bây giờ hãy để tôi chỉ cho bạn cách kiểm tra các nguyên thủy riêng lẻ trong cấu trúc gia tốc của bạn.

Điều này đặc biệt hữu ích nếu bạn đang sử dụng API dữ liệu mỗi nguyên thủy mới.

Và vì vậy có một chế độ nổi bật mới chỉ dành cho việc này.

Chế độ tô sáng nguyên thủy cho phép bạn truy cập vào tất cả dữ liệu nguyên thủy...

Và cho phép bạn chọn các nguyên thủy cụ thể để kiểm tra chi tiết.

Trong thanh bên trái, bạn có thể tìm thấy các mũi tên bên cạnh các hàng dữ liệu.

Nhấp vào một mũi tên sẽ hiển thị một cửa sổ bật lên hiển thị dữ liệu tương ứng cho nguyên thủy.

Những bổ sung này cho trình xem cấu trúc tăng tốc đảm bảo bạn có toàn quyền truy cập, xuống từng nguyên thủy, vào tất cả các thành phần tạo nên cấu trúc tăng tốc của bạn.

Tiếp theo, hãy nói về những cải tiến cho Shader Profiler.

Shader Profiler cung cấp cho bạn thông tin chi tiết về hiệu suất của shader của bạn, cung cấp chi phí thời gian thực thi trên mỗi đường ống và trên GPU của Apple, nó cung cấp độ chi tiết hơn ở cấp nguồn, hiển thị chi phí thực thi trên mỗi dòng được phân phối trên các danh mục hướng dẫn.

Trong Xcode 14, các bản ghi GPU hồ sơ đã được cập nhật để hỗ trợ các chức năng giao nhau, các chức năng hiển thị và các thư viện động.

Ở đây chúng ta có một hạt nhân dò tia sử dụng chức năng giao nhau.

Bây giờ bạn có thể xem kết quả lập hồ sơ trên mỗi dòng bên trong hàm giao lộ.

Điều này bao gồm phân tích các danh mục hướng dẫn đóng góp vào chi phí.

Lập hồ sơ các chức năng hiển thị hoạt động theo cùng một cách.

Và tương tự, thông tin hồ sơ chi tiết hiện có sẵn cho mã đổ bóng từ các thư viện động được liên kết.

Với những bổ sung này, giờ đây bạn đã có bảng phân tích đầy đủ về hiệu suất của đường ống của mình, xuống từng dòng mã.

Chuyển sang Trình gỡ lỗi Shader.

Trình gỡ lỗi Shader cung cấp một quy trình làm việc độc đáo và cực kỳ hiệu quả để gỡ lỗi tính chính xác của mã đổ bóng của bạn.

Cũng giống như với Shader Profiler, chúng tôi cũng đã mở rộng hỗ trợ để cho phép gỡ lỗi các chức năng được liên kết và thư viện động.

Ở đây chúng ta có một hạt nhân dò tia gọi ra một hàm hiển thị được liên kết được truyền qua một bảng hàm hiển thị.

Bây giờ bạn có thể theo dõi việc thực thi hạt nhân vào mã hàm hiển thị của mình để xác minh rằng mã hoạt động như bạn mong đợi.

Một lần nữa, điều tương tự cũng áp dụng cho việc gỡ lỗi các thư viện động.

Bạn cũng có thể nhảy vào và ra khỏi bất kỳ thư viện động nào được thực thi được liên kết với đường ống của bạn.

Với những bổ sung này, giờ đây bạn đã có một bức tranh hoàn chỉnh về việc thực thi đổ bóng của mình trên các chức năng và thư viện được liên kết trong đường ống của bạn.

Bây giờ, trước khi bạn chụp và nhảy vào Trình gỡ lỗi Shader, bạn nên bật Xác thực Shader trong thời gian chạy.

Xác thực Shader là một cách tuyệt vời để chẩn đoán lỗi thời gian chạy trên GPU, phát hiện các vấn đề như truy cập bộ nhớ ngoài giới hạn, đọc kết cấu null và hơn thế nữa.

Để bật Xác thực Shader trong Xcode, tất cả những gì bạn cần làm là vào hộp thoại "Chỉnh sửa sơ đồ", chọn hành động "Chạy" và trong tab "chẩn đoán" đánh dấu vào hộp kiểm "Xác thực Shade".

Và bạn đã sẵn sàng để đi.

Trong Metal 3, chúng tôi đã thêm tính năng phát hiện Stack Overflow sẽ giúp bạn nhanh chóng tìm ra các vấn đề mà nếu không sẽ dẫn đến hành vi không xác định.

Tôi sẽ nhanh chóng giải thích chi tiết về ngăn xếp chức năng trong Bộ đổ bóng kim loại và vấn đề của Stack Overflow.

Ngăn xếp cuộc gọi là một vùng trong bộ nhớ thiết bị nơi Metal lưu trữ các giá trị của dữ liệu cục bộ được sử dụng trong các hàm đổ bóng của bạn.

Nếu hàm được gọi không được biết tại thời điểm biên dịch, Metal cần sự trợ giúp của bạn trong việc ước tính dung lượng bộ nhớ cần thiết cho ngăn xếp.

Một ví dụ về việc gọi một hàm không xác định tại thời điểm biên dịch có thể là một hàm giao điểm dò tia.

Nếu bạn đang sử dụng các hàm giao nhau tùy chỉnh, độ sâu ngăn xếp cuộc gọi tối đa nên được đặt thành 1, để phân bổ không gian cho nó.

Đây là giá trị mặc định, vì vậy bạn không cần phải làm gì hơn.

Tuy nhiên, nếu bạn đang sử dụng Bảng hàm để gọi vào hàm Visible, đây là một ví dụ khác về lệnh gọi hàm không xác định tại thời điểm biên dịch.

Nếu bạn thực hiện một cuộc gọi như vậy từ một hàm giao nhau, như trong ví dụ này, ngăn xếp cuộc gọi của bạn sẽ sâu hai cấp độ.

Một ví dụ khác là gọi đến các thư viện động và gọi một hàm cục bộ bằng cách sử dụng con trỏ hàm.

Trong ví dụ này, ngăn xếp cuộc gọi của chúng tôi có bốn cấp độ với các cuộc gọi lồng nhau đến các loại chức năng khác nhau không thể giải quyết được khi đổ bóng được biên dịch.

Để cấu hình Metal đúng cách để phân bổ dung lượng bộ nhớ phù hợp, bạn cần tự chỉ định độ sâu ngăn xếp cuộc gọi tối đa là 4.

Điều quan trọng cần nhớ là khi giá trị của Độ sâu ngăn xếp cuộc gọi tối đa được đặt quá thấp cho chương trình của bạn, Stack Overflow có thể xảy ra, dẫn đến hành vi không xác định.

Nhưng nếu bạn đang chạy với tính năng Xác thực Shader được bật, những tình huống như vậy sẽ được phát hiện sớm và bạn sẽ thấy thông tin trong Xcode về nơi xảy ra Tràn ngăn xếp.

Sau đó, bạn có thể sửa mã đổ bóng của mình hoặc điều chỉnh độ sâu ngăn xếp cuộc gọi tối đa của mình trong bộ mô tả đường ống.

Tất cả những cải tiến mới này đối với các công cụ Metal trong Xcode 14 đảm bảo bạn có một bức tranh hoàn chỉnh hơn và cái nhìn sâu sắc hơn về hiệu suất và tính chính xác của các ứng dụng dò tia của bạn.

Để biết thêm về cách tận dụng tối đa các công cụ Metal để gỡ lỗi và lập hồ sơ, hãy xem các phiên khác này Tất cả về việc tối đa hóa hiệu suất dò tia Metal cho các ứng dụng của bạn.

Chúng tôi đã nói về cách bạn có thể tăng hiệu suất và đơn giản hóa mã của mình bằng cách sử dụng các tính năng mới như dữ liệu nguyên thủy.

Chúng tôi cũng đã mô tả các kỹ thuật và tính năng tối ưu hóa giúp xây dựng các cấu trúc gia tốc nhanh hơn và thuận tiện hơn bao giờ hết.

Cuối cùng, chúng tôi đã đề cập đến tất cả các cải tiến mới cho các công cụ Metal trong Xcode 14 sẽ cung cấp cho bạn cái nhìn sâu sắc hơn trong quá trình phát triển của bạn.

Cảm ơn vì đã xem.