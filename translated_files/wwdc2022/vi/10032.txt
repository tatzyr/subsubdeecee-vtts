10032

♪ Nhạc hip-hop nhạc cụ êm dịu ♪

♪

Xin chào các bạn. Tên tôi là Michael Gorbach từ Shortcuts Engineering.

Cảm ơn vì đã điều chỉnh để đi sâu vào App Intents, khuôn khổ mới của chúng tôi để hiển thị chức năng ứng dụng của bạn cho hệ thống.

Đây là kế hoạch cho chuyến lặn của chúng tôi.

Sau phần giới thiệu nhanh, tôi sẽ nói về ý định và các thông số của chúng, và cách xác định các thực thể.

Tôi sẽ xem xét một số tính năng tìm kiếm và lọc mạnh mẽ mà bạn có thể xây dựng và cách ý định của bạn có thể tương tác với người dùng.

Cuối cùng, tôi sẽ đề cập đến kiến trúc và vòng đời của App Intents.

Hãy bắt đầu từ đầu.

Trong iOS 10, chúng tôi đã giới thiệu khung SiriKit Intents, cho phép bạn kết nối chức năng ứng dụng của mình với các miền Siri như nhắn tin, tập luyện và thanh toán.

Bây giờ chúng tôi đang giới thiệu một khuôn khổ mới được gọi là App Intents.

Nó có ba thành phần chính.

Ý định là các hành động được tích hợp trong ứng dụng của bạn có thể được sử dụng trên toàn hệ thống.

Ý định sử dụng các thực thể để thể hiện các khái niệm ứng dụng của bạn.

Phím tắt ứng dụng bao bọc ý định của bạn để làm cho chúng tự động và có thể phát hiện được.

Hãy nói về một vài cách mà App Intents có thể làm cho chức năng ứng dụng của bạn có sẵn ở nhiều nơi hơn và mang lại lợi ích cho khách hàng của bạn.

Với Phím tắt ứng dụng, mọi người đều có thể sử dụng các tính năng của ứng dụng bằng giọng nói của họ thông qua Siri mà không cần thiết lập bất cứ điều gì trước.

Việc áp dụng tương tự cũng làm cho ý định của bạn xuất hiện trong Spotlight khi mọi người tìm kiếm ứng dụng của bạn và khi ứng dụng của bạn được đề xuất.

Điều này sẽ đặt công việc của bạn ở phía trước và trung tâm.

Sử dụng App Intents, bạn cũng có thể xây dựng Focus Filters, cho phép khách hàng tùy chỉnh ứng dụng của bạn cho một Focus cụ thể.

Ví dụ, họ có thể thiết lập ứng dụng Lịch của mình để chỉ hiển thị lịch làm việc của họ trong khi họ thực sự đang làm việc.

Kiểm tra phiên này để tìm hiểu thêm về cách áp dụng Bộ lọc Tiêu điểm.

Với Phím tắt Ứng dụng, ý định của bạn sẽ tự động hiển thị trong ứng dụng Phím tắt mà không cần thêm thủ công.

Tích hợp các hành động của bạn vào Phím tắt cực kỳ có giá trị đối với khách hàng vì họ có thể chạy các phím tắt và tận dụng các tính năng của ứng dụng của bạn, từ rất nhiều nơi trên toàn hệ thống.

Họ có thể chạy các phím tắt chỉ bằng một lần nhấn vào Màn hình chính, từ thanh menu trên macOS và theo nhiều cách khác.

Họ thậm chí có thể thiết lập các phím tắt để chạy tự động với tự động hóa.

Các phím tắt hỗ trợ nhân lên sức mạnh và khả năng của ứng dụng của bạn bằng cách kết nối nó với toàn bộ hệ sinh thái Phím tắt, khai thác sức mạnh của một loạt các ứng dụng từ Apple và các nhà phát triển khác.

Đó là bởi vì một phím tắt có thể kết hợp các hành động từ nhiều ứng dụng, cho phép người dùng phát minh ra các tính năng và khả năng hoàn toàn mới mà bạn không cần phải thực hiện bất kỳ công việc nào.

Nếu bạn muốn học cách làm cho hành động của mình hoạt động tốt với những người khác và phù hợp liền mạch với hệ sinh thái này, hãy xem buổi nói chuyện về thiết kế của chúng tôi.

Mục tiêu của chúng tôi trong việc xây dựng App Intents là làm cho nó trở thành một niềm vui để phát triển.

Ý định ứng dụng ngắn gọn.

Viết một ý định đơn giản chỉ có thể mất một vài dòng mã, nhưng API cũng mở rộng quy mô thành các hành động sâu hơn và có thể tùy chỉnh hơn.

App Intents là hiện đại.

Chúng tôi đã tập trung tất cả vào Swift, tận dụng các trình xây dựng kết quả, trình bao bọc tài sản, lập trình định hướng giao thức và chung chung.

Những API này không thể tồn tại nếu không có các tính năng ngôn ngữ tiên tiến.

Việc áp dụng Ý định ứng dụng cũng dễ dàng, bởi vì nó không yêu cầu kiến trúc lại các sản phẩm và mục tiêu của bạn hoặc tạo ra một khuôn khổ.

Nó không yêu cầu tiện ích mở rộng và có thể được áp dụng ngay trong ứng dụng của bạn.

Và mã App Intents có thể duy trì được.

Giống như SwiftUI, App Intents sử dụng mã của bạn làm nguồn cơ bản của sự thật, tránh sự cần thiết của các trình chỉnh sửa hoặc tệp định nghĩa riêng biệt.

Điều này cho phép bạn nhanh chóng xây dựng và lặp lại việc áp dụng của mình và đơn giản hóa việc bảo trì vì mọi thứ đều tồn tại ở một nơi.

Như đã nói, hãy khám phá các API mới này, bắt đầu với mục đích, khối xây dựng trung tâm của khuôn khổ mới của chúng tôi.

Ý định của ứng dụng - hay viết tắt là "ý định" - là một đơn vị chức năng duy nhất, riêng biệt mà ứng dụng của bạn hiển thị cho hệ thống.

Ví dụ, một ý định có thể tạo một sự kiện lịch mới, mở một màn hình cụ thể hoặc đặt hàng.

Một ý định có thể được thực hiện bởi người dùng theo yêu cầu - như bằng cách chạy phím tắt hoặc hỏi Siri - hoặc tự động - như sử dụng bộ lọc Focus hoặc tự động hóa Phím tắt.

Khi một ý định được chạy, nó sẽ trả về kết quả hoặc gây ra lỗi.

Một ý định bao gồm ba phần chính: siêu dữ liệu hoặc thông tin về ý định, bao gồm tiêu đề được bản địa hóa; các tham số, là đầu vào mà ý định có thể sử dụng khi nó được chạy; và một phương thức thực hiện, thực hiện công việc thực tế khi ý định được thực hiện.

Điểm khởi đầu của chúng tôi hôm nay là ứng dụng Thư viện này.

Vì tôi là một con mọt sách khổng lồ, đó là tất cả về việc theo dõi những cuốn sách tôi đã đọc, muốn đọc hoặc hiện đang đọc.

Mỗi danh mục được hiển thị trong tab riêng biệt của ứng dụng mà tôi gọi là Kệ.

Người dùng của tôi truy cập kệ Đang đọc mọi lúc, vì vậy tôi sẽ hiển thị một ứng dụng có ý định giúp mở nó nhanh hơn và thuận tiện hơn.

Tôi sẽ tạo một ý định OpenCurrentlyReading ở đây bằng cách xác định một cấu trúc Swift phù hợp với giao thức AppIntent.

Tôi chỉ cần thực hiện một phương pháp, được gọi là thực hiện.

Trong ứng dụng của tôi, tôi đã có một trình điều hướng có thể mở các tab, vì vậy việc thực hiện ý định cho tôi chỉ là một vài dòng mã.

Tôi sẽ chú thích phương thức thực hiện với @MainActor, vì Navigator của tôi mong đợi luồng chính.

Ý định của tôi cũng cần một tiêu đề.

Giống như tất cả các chuỗi khác mà tôi sẽ chỉ cho bạn hôm nay, điều này sẽ được bản địa hóa tự động nếu tôi thêm khóa vào các tệp chuỗi của mình.

Đây là tất cả những gì tôi cần làm để có được một ý định ứng dụng cơ bản hoạt động.

Bây giờ nó đã được xác định trong mã của tôi, nó sẽ tự động xuất hiện trong trình chỉnh sửa Phím tắt, nơi người dùng của tôi có thể thêm nó vào một phím tắt.

Chỉ cần phơi bày ý định này cung cấp đòn bẩy rất lớn, bởi vì một khi khách hàng biến ý định này thành một lối tắt, nó có thể được sử dụng từ rất nhiều nơi trong hệ thống, bao gồm tất cả những thứ này.

Để làm cho ý định mới của tôi dễ sử dụng và khám phá, tôi cũng sẽ thêm hỗ trợ cho Phím tắt ứng dụng.

Với một chút mã, tôi có thể làm cho ý định của mình tự động hiển thị trong Spotlight và ứng dụng Phím tắt, và tôi có thể xác định một cụm từ mà mọi người có thể nói với Siri để sử dụng ý định này bằng giọng nói của họ.

Kiểm tra phiên "Các phím tắt ứng dụng triển khai với ý định ứng dụng" để có được tất cả các chi tiết.

Cho đến nay, tôi đã tiết lộ ý định mở kệ Đang đọc.

Tiếp theo, hãy khái quát hóa nó, thêm một tham số để nó có thể mở bất kỳ kệ nào.

Tôi có một enum đại diện cho các kệ.

Để nó được sử dụng như một tham số ý định, tôi cần phải phù hợp với giao thức AppEnum.

AppEnum yêu cầu một giá trị thô Chuỗi, vì vậy tôi sẽ thêm nó trước.

Nó cũng yêu cầu tôi cung cấp các tiêu đề có thể định vị, có thể đọc được của con người cho mỗi trường hợp liệt kê của tôi.

Chúng phải được cung cấp dưới dạng từ điển theo nghĩa đen, vì trình biên dịch sẽ đọc mã này tại thời điểm xây dựng.

Cuối cùng, tôi sẽ thêm một typeDisplayName: một tên hiển thị cho người dùng, có thể định vị cho toàn bộ loại enum này.

Tôi sẽ sử dụng "Kệ."

Trong một ý định, mỗi tham số được khai báo bằng cách sử dụng trình bao bọc thuộc tính @Parameter, được khởi tạo với thông tin về tham số, như tiêu đề.

Ở đây, tôi xác định một tham số kệ mới, mà tôi đã đọc trong phương pháp thực hiện của mình.

Các thông số hỗ trợ tất cả các loại này, bao gồm số, chuỗi, tệp và hơn thế nữa, cũng như các thực thể và liệt kê từ ứng dụng của bạn.

Đây là ý định này trông như thế nào trong trình chỉnh sửa Phím tắt.

Lưu ý rằng tham số kệ xuất hiện trong một hàng bảng.

Tôi có thể làm cho giao diện người dùng được sắp xếp hợp lý hơn và làm cho nó phù hợp hơn với Phím tắt, bằng cách sử dụng ParameterSummary API.

Tóm tắt tham số là một câu đại diện cho ý định của bạn và các tham số của nó trong trình chỉnh sửa, như "Mở".

Để có kết quả tốt nhất trong Phím tắt, bạn nên luôn cung cấp Tóm tắt Tham số cho mọi ý định bạn tạo.

Bạn cũng có thể xác định thông số nào hiển thị bên dưới nếp gấp và thông số nào bị ẩn.

Các API này có thể thực hiện một số thứ khá thú vị, như thay đổi bản tóm tắt dựa trên các giá trị thực tế của bất kỳ tham số nào trong ý định của bạn, sử dụng API Khi nào và Khác, hoặc API Chuyển đổi, Trường hợp và Mặc định.

Để thêm một bản tóm tắt tham số, tôi triển khai thuộc tính tĩnh này.

Ở đây tôi sẽ trả về chuỗi "Mở", và nội suy tham số kệ.

Điều cuối cùng tôi cần làm để Open Shelf hoạt động là đảm bảo rằng mục đích mở ứng dụng Thư viện khi nó chạy, như thế này.

Việc mở ứng dụng được điều khiển bởi thuộc tính tĩnh, openAppWhenRun.

Nó mặc định là sai, điều này rất tốt cho hầu hết các ý định.

Nhưng đối với ý định mở một cái gì đó trong giao diện người dùng như thế này, tôi sẽ cần đặt nó thành sự thật.

Tôi vừa tạo ra một ý định mở kệ.

Điều này cực kỳ đơn giản vì bộ kệ đã được cố định.

Nhưng điều gì sẽ xảy ra nếu tôi muốn xây dựng một ý định mở Sách, tập hợp chúng là động, không cố định?

Đối với điều đó, tôi sẽ cần các thực thể.

Một thực thể là một khái niệm mà ứng dụng của bạn hiển thị cho App Intents.

Bạn nên sử dụng một thực thể thay vì một enum khi các giá trị là động, hoặc do người dùng xác định, như một ghi chú trong Ghi chú hoặc một bức ảnh hoặc album trong Ảnh.

Để cung cấp các trường hợp của các thực thể, ứng dụng của bạn có thể thực hiện các truy vấn và trả về các thực thể dưới dạng kết quả từ ý định.

Tôi sẽ bắt đầu bằng cách đưa ra ý định mở một cuốn sách trong ứng dụng.

Trong trình chỉnh sửa Phím tắt, nó sẽ trông như thế này.

Khi mọi người nhấn vào tham số Sách, họ sẽ nhận được một bộ chọn để chọn một cuốn sách, bao gồm một tập hợp các thực thể được đề xuất mà ứng dụng của tôi đã cung cấp.

Họ cũng có thể tìm thấy bất kỳ cuốn sách nào trong thư viện của họ với trường tìm kiếm này ở đầu bộ chọn.

Trước khi tôi tự xây dựng ý định, tôi sẽ cần tạo một thực thể sách và truy vấn tương ứng.

Một thực thể chứa ít nhất ba thứ: một mã định danh, một biểu diễn hiển thị và một tên loại thực thể.

Để thêm một thực thể, hãy bắt đầu bằng cách tuân thủ một cấu trúc với giao thức AppEntity.

Ở đây, tôi sẽ xác định một cấu trúc mới cho BookEntity, nhưng tôi cũng có thể phù hợp với một loại hiện có từ mô hình của mình.

Bạn cung cấp một mã định danh bằng cách tuân thủ thực thể của bạn với giao thức Nhận dạng.

App Intents sử dụng mã định danh này để tham chiếu đến thực thể của bạn khi nó được truyền giữa ứng dụng của bạn và các phần khác của hệ thống.

Mã định danh phải ổn định và liên tục, vì nó có thể được lưu trong một phím tắt do khách hàng của bạn tạo ra.

Biểu diễn hiển thị được sử dụng để hiển thị thực thể này cho người dùng.

Điều này có thể đơn giản như một chuỗi văn bản, giống như tiêu đề cuốn sách.

Bạn cũng có thể cung cấp phụ đề và hình ảnh.

typeDisplayName là một chuỗi có thể đọc được của con người đại diện cho loại của một thực thể.

Trong ví dụ này, đó là "Sách".

Bây giờ, để làm tròn thực thể sách, tôi cần thêm một truy vấn.

Một truy vấn cung cấp cho hệ thống một giao diện để truy xuất các thực thể từ ứng dụng của bạn.

Các truy vấn có thể tra cứu các thực thể theo một vài cách.

Tất cả các truy vấn cần có khả năng tra cứu các thực thể dựa trên số nhận dạng.

Truy vấn chuỗi hỗ trợ tìm kiếm.

Và sau đó, bạn sẽ gặp phải các truy vấn về tài sản, linh hoạt hơn.

Tất cả các truy vấn cũng có thể cung cấp các thực thể được đề xuất, cho phép người dùng chọn từ một danh sách.

Mỗi thực thể nên được liên kết với một truy vấn để hệ thống có thể tra cứu các trường hợp của thực thể đó.

Bạn cung cấp một truy vấn bằng cách tạo một cấu trúc Swift phù hợp với giao thức EntityQuery.

Truy vấn cơ bản chỉ có một phương thức bắt buộc, mà bạn thực hiện để giải quyết các thực thể được cung cấp một mảng các số nhận dạng.

Tôi đã triển khai điều này bằng cách truy cập cơ sở dữ liệu mô hình của mình và tìm bất kỳ cuốn sách nào khớp với các số nhận dạng đó.

Bây giờ, tôi cần kết nối truy vấn với thực thể.

Tôi làm điều này bằng cách triển khai thuộc tính tĩnh defaultQuery trên loại BookEntity và trả về một phiên bản của BookQuery của tôi.

Khi người dùng chọn một cuốn sách, số nhận dạng của nó sẽ được lưu vào phím tắt.

Khi phím tắt được chạy, App Intents sẽ chuyển mã định danh cho truy vấn của tôi để truy xuất phiên bản BookEntity.

Bây giờ loại BookEntity phù hợp với giao thức AppEntity, tôi có thể sử dụng nó như một tham số trong ý định OpenBook của mình.

Phương pháp thực hiện sử dụng Điều hướng của tôi để điều hướng đến cuốn sách.

Để hỗ trợ người chọn sách, truy vấn của tôi cũng cần cung cấp các kết quả được đề xuất.

Để làm điều đó, tôi cần triển khai thêm một phương pháp truy vấn, trả lại tất cả các sách đã thêm vào ứng dụng Thư viện của tôi.

Các phím tắt sẽ lấp đầy bộ chọn với những kết quả này.

Lưu ý rằng giao diện người dùng Phím tắt có một trường tìm kiếm ở trên cùng.

Ứng dụng của tôi có thể có rất nhiều thực thể sách, vì vậy tôi thực sự nên chạy tìm kiếm trong quy trình ứng dụng của mình, trực tiếp với cơ sở dữ liệu của mình.

StringQuery API cho phép tôi làm điều đó.

Việc áp dụng giao thức con StringQuery cho tôi thêm một phương thức để triển khai, được gọi là các thực thể (chuỗi khớp:), để trả về kết quả đã cho một chuỗi.

Ở đây, tôi đã triển khai nó như một kết hợp không phân biệt chữ hoa chữ thường với tiêu đề của cuốn sách, nhưng tôi có thể đã làm những thứ kỳ lạ hơn như tìm kiếm thông qua tác giả hoặc tên sê-ri chẳng hạn.

Nếu tôi có một danh sách sách lớn và một danh sách yêu thích nhỏ hơn, tôi có thể chỉ trả lại các mục yêu thích trong Thực thể được đề xuất và dựa vào các thực thể (chuỗi khớp:) để cho phép người dùng của tôi tìm kiếm trong danh sách dài hơn.

Bây giờ tôi đã giới thiệu một cách để mở sách trong ứng dụng của mình và xây dựng một thực thể sách và truy vấn sách trong quá trình này.

Tôi có thể sử dụng cùng một thực thể và truy vấn để tạo thêm ý định.

Nhiệm vụ tiếp theo của tôi là xây dựng ý định thêm sách vào thư viện.

Khách hàng có thể nhanh chóng thêm sách trong khi duyệt trực tuyến bằng cách sử dụng phím tắt chia sẻ hoặc họ có thể yêu cầu Siri trên HomePod thêm sách mà không cần nhìn vào màn hình.

Xây dựng ý định như thế này thao túng mô hình của bạn trực tiếp mà không hiển thị giao diện người dùng của bạn thực sự có thể trao quyền cho người dùng của bạn.

Đây là việc thực hiện ý định AddBook của tôi, lấy tiêu đề của cuốn sách làm tham số và tên tùy chọn của tác giả.

Nó cũng bao gồm một ghi chú tùy chọn để ghi lại người bạn nào đã giới thiệu cuốn sách.

Phương thức thực hiện sẽ thêm cuốn sách vào thư viện bằng cách tra cứu nó bằng lệnh gọi API bằng cách sử dụng async/await.

Nó sẽ gây ra lỗi nếu không thể tìm thấy kết quả phù hợp.

Để bản địa hóa lỗi này, tôi tuân thủ loại lỗi của mình với giao thức CustomLocalizedString ResourceConvertible.

Tôi sẽ trả về một khóa chuỗi được bản địa hóa từ thuộc tính này và thêm khóa vào các tệp chuỗi của tôi.

Mục đích Thêm Sách này cực kỳ hữu ích, với Siri, các tiện ích và hơn thế nữa.

Nhưng nó thậm chí còn linh hoạt hơn nếu nó có thể được kết hợp với các ý định khác.

Với một chút công việc, tôi có thể cho phép kết hợp ý định Thêm Sách của mình với ý định Mở Sách mà tôi đã xây dựng trước đó, chuyển kết quả từ cái này sang cái kia.

Để làm như vậy, tôi sẽ có ý định Thêm Sách trả về một giá trị như một phần của kết quả của nó.

Lưu ý rằng kiểu trả về của phương thức thực hiện của tôi đã chọn một giao thức mới để biểu diễn giá trị tôi đang trả về.

Giờ đây, người dùng có thể kết nối giá trị kết quả của ý định này với các ý định khác lấy một thực thể sách làm tham số.

Ý định Thêm Sách và ý định Mở Sách kết hợp khá tự nhiên với nhau, vì vậy bạn có thể tạo một phím tắt thêm một cuốn sách và sau đó ngay lập tức mở nó trong thư viện.

Đó là một mô hình phổ biến để trả về kết quả từ một ý định và mở nó trong ứng dụng.

Ý định của ứng dụng có một cách tích hợp để thể hiện điều này được gọi là openIntent.

Nếu tôi thêm một openIntent, khách hàng sẽ nhận được một công tắc mới trong Phím tắt được gọi là "Open When Run".

Nếu họ tắt công tắc, họ sẽ có thể sử dụng ý định này như một phần của phím tắt trong nền mà không bị gián đoạn.

Nếu họ để công tắc bật, cuốn sách mới được thêm vào sẽ được mở ngay lập tức trong ứng dụng Thư viện của tôi.

Áp dụng openIntent dễ dàng như tạo một ví dụ về ý định Open Book và trả lại nó như một phần của kết quả.

Khi ý định này được chạy, nếu công tắc Mở Khi Chạy được bật, ý định Mở Sách sẽ tự động được thực hiện sau khi ý định Thêm Sách kết thúc.

Bạn có thể làm nhiều việc hơn với các thực thể và truy vấn.

Với bộ API tiếp theo, AppIntents mở ra một số khả năng mạnh mẽ mà bạn chưa từng có trước đây với khung SiriKit Intents.

Hãy xem cách bạn có thể tiết lộ thêm thông tin từ các thực thể của mình và cho phép khách hàng tìm và lọc dựa trên điều đó.

Cho đến nay, tôi đã thêm tất cả các yêu cầu cơ bản vào thực thể sách của mình.

Nhưng để mọi người tích hợp sách sâu hơn vào các phím tắt của họ, tôi sẽ cần tiết lộ thêm một chút về sách của mình.

Các thực thể hỗ trợ các thuộc tính, chứa thông tin bổ sung về thực thể mà bạn muốn hiển thị cho người dùng.

Trong trường hợp này, tôi sẽ thêm tác giả của cuốn sách, ngày xuất bản, ngày đọc và ai đã đề xuất nó, để mọi người có thể sử dụng các thuộc tính đó trong các phím tắt của họ.

Tôi thêm các thuộc tính vào BookEntity của mình bằng cách sử dụng trình bao bọc thuộc tính có tên @Property.

Các thuộc tính hỗ trợ tất cả các loại giống như các tham số và mỗi loại có một tiêu đề được bản địa hóa.

Với các thuộc tính mới này, khách hàng của tôi giờ đây có thể sử dụng các biến ma thuật trong Phím tắt để lấy ra từng phần thông tin mới khi làm việc với một thực thể sách Khi sử dụng ý định Thêm Sách trước đó, họ có thể sử dụng tác giả hoặc ngày xuất bản của một cuốn sách mới được thêm vào trong các phím tắt của họ.

Khi bạn kết hợp các thuộc tính với các truy vấn, ứng dụng của bạn sẽ tự động nhận được các hành động Tìm và Lọc cực kỳ mạnh mẽ này trong Phím tắt, với giao diện người dùng chỉnh sửa vị ngữ linh hoạt này.

Bây giờ, khách hàng của tôi sẽ có thể tìm và lọc sách dựa trên ngày đọc, tiêu đề, tác giả và hơn thế nữa.

Ví dụ, đó là một miếng bánh để tìm tất cả những cuốn sách của Delia Owens.

Sử dụng các tùy chọn Sắp xếp theo và Giới hạn, bạn có thể hỗ trợ các truy vấn nâng cao hơn nữa, như tìm ba cuốn sách được xuất bản gần đây nhất của Delia Owens.

Một khách hàng có thể sử dụng các khối xây dựng này để làm một số việc khá thú vị, như tìm ba tác giả phổ biến nhất trong bộ sưu tập của họ.

Để kích hoạt tất cả điều này, tôi sẽ cần áp dụng một loại truy vấn khác được gọi là truy vấn thuộc tính.

Truy vấn thuộc tính tìm thấy các thực thể không dựa trên chuỗi hoặc mã định danh, mà dựa trên các thuộc tính trong thực thể.

Có ba bước để thực hiện các truy vấn tài sản.

Đầu tiên, bạn khai báo các thuộc tính truy vấn, chỉ định cách thực thể của bạn có thể được tìm kiếm bằng cách sử dụng các thuộc tính của nó.

Sau đó, bạn thêm các tùy chọn sắp xếp, xác định cách sắp xếp kết quả truy vấn.

Và cuối cùng, bạn triển khai các thực thể (phù hợp:) để chạy tìm kiếm.

Các thuộc tính truy vấn khai báo mọi cách AppIntents có thể tìm kiếm trên thực thể được liên kết với truy vấn này.

Mỗi người liệt kê một thuộc tính của thực thể của tôi và các toán tử so sánh - như chứa, bằng hoặc nhỏ hơn - có sẵn cho nó.

Ở đây, tôi liệt kê các bộ so sánh "ít hơn" và "lớn hơn" cho các thuộc tính ngày của tôi, và "chứa" và "bằng" cho tài sản tiêu đề của tôi.

Các thuộc tính truy vấn ánh xạ từng tổ hợp thuộc tính và bộ so sánh thành một loại bạn chọn, được gọi là loại ánh xạ bộ so sánh.

Ở đây, tôi đang sử dụng CoreData, vì vậy tôi sẽ sử dụng NSPredicate.

Nếu tôi đang sử dụng cơ sở dữ liệu tùy chỉnh hoặc REST API, tôi có thể thiết kế loại bộ so sánh của riêng mình và sử dụng nó thay thế.

Đây là mã để thiết lập các thuộc tính truy vấn cho sách của tôi.

Tôi tuân thủ BooksQuery với giao thức EntityPropertyQuery.

Sau đó, tôi triển khai các thuộc tính var tĩnh bằng cách sử dụng trình tạo kết quả QueryProperties.

Mỗi mục nhập chỉ định một keyPath của một Thuộc tính có thể được truy vấn và bên trong nó, mỗi bộ so sánh có thể áp dụng cho thuộc tính đó.

Đối với mỗi bộ so sánh, tôi cung cấp một NSPredicate, bởi vì tôi đã chọn NSPredicate làm loại ánh xạ bộ so sánh của mình.

Khi hệ thống yêu cầu ứng dụng của tôi trả về kết quả cho truy vấn, nó sẽ cung cấp lại NSPredicates mà tôi đang xây dựng ở đây.

Có một định nghĩa tương tự để phân loại.

Đây là danh sách tất cả các thuộc tính mà mô hình của tôi có thể sắp xếp sách theo.

Trong trường hợp này, tôi cho phép sắp xếp theo tiêu đề, ngày đọc và ngày xuất bản.

Cuối cùng, tôi triển khai các thực thể (phù hợp:), truy vấn cơ sở dữ liệu của tôi và trả về các thực thể phù hợp.

Phương pháp này lấy một mảng của loại ánh xạ so sánh mà tôi đã sử dụng trong các tham số truy vấn được xác định trước đó - trong trường hợp này là NSPredicate.

Những vị ngữ này đang mô tả tiêu chí nào về các thuộc tính của thực thể mà tôi muốn truy vấn.

Nó cũng có một chế độ, cho biết nên kết hợp các vị ngữ với "và" hay với "hoặc", các đường dẫn chính để sắp xếp và giới hạn tùy chọn cho số lượng kết quả.

Việc triển khai của tôi sử dụng các tham số này để thực hiện truy vấn đối với cơ sở dữ liệu CoreData của tôi.

Khách hàng có thể làm gì với truy vấn tài sản này?

Họ có thể chọn một cuốn sách ngẫu nhiên từ thư viện của họ để đọc.

Họ có thể tìm thấy tất cả những cuốn sách của họ được xuất bản vào đầu thế kỷ XX.

Họ có thể tận dụng hệ sinh thái Phím tắt và làm cho ứng dụng của tôi hữu ích hơn bằng cách kết nối nó với những người khác.

Ví dụ, họ có thể sử dụng ứng dụng bảng tính để xuất tất cả những cuốn sách họ đã đọc trong năm nay sang tệp CSV.

Hoặc, họ có thể sử dụng một ứng dụng vẽ đồ thị để tạo biểu đồ về số lượng sách họ đã đọc mỗi năm trong 10 cuốn sách qua.

Và đó mới chỉ là sự khởi đầu.

Loại áp dụng Ý định ứng dụng sâu sắc này thực sự cho phép khách hàng sử dụng ứng dụng của bạn để làm những gì họ cần, khiến nó trở thành một phần quan trọng trong quy trình làm việc của họ.

Mỗi tích hợp này - ví dụ như tạo biểu đồ - là một tính năng bạn không cần phải xây dựng.

Khi ý định của bạn được thực hiện, ứng dụng của bạn có thể cần tương tác với người dùng để hiển thị hoặc nói kết quả hoặc để giải quyết sự mơ hồ, cho dù đó là yêu cầu Siri hay phím tắt.

App Intents hỗ trợ một số tương tác này: hộp thoại để đưa ra phản hồi bằng văn bản và giọng nói cho người dùng của bạn khi ý định đã hoàn thành và các đoạn để đưa ra phản hồi trực quan.

Yêu cầu giá trị và định hướng để yêu cầu người dùng làm rõ các giá trị cho các tham số ý định và xác nhận để xác minh các giá trị tham số hoặc kiểm tra với người dùng về các ý định mang tính giao dịch hoặc phá hoại.

Hộp thoại cung cấp phản hồi bằng lời nói hoặc văn bản cho người đang thực hiện một ý định.

Điều thực sự quan trọng là cung cấp hộp thoại cho ý định hoạt động tốt trong trải nghiệm giọng nói.

Trong ý định Thêm Sách của tôi từ trước đó, tôi sẽ thêm needsValueDialog được nói khi yêu cầu tiêu đề sách và hộp thoại kết quả được trả về từ phương thức thực hiện của tôi.

Những thứ này sẽ được đọc hoặc hiển thị bởi Phím tắt hoặc Siri trên nhiều nền tảng của chúng tôi.

Bạn có thể nghĩ các đoạn trích là hình ảnh tương đương với hộp thoại, cho phép bạn thêm một biểu diễn trực quan vào kết quả ý định của mình.

Để sử dụng một đoạn mã, chỉ cần thêm chế độ xem SwiftUI mà bạn chọn làm phần đóng cuối vào kết quả ý định của bạn.

Giống như với một tiện ích, chế độ xem SwiftUI của bạn sẽ được lưu trữ và gửi đến Phím tắt hoặc Siri.

App Intents cũng hỗ trợ yêu cầu người dùng cung cấp giá trị bằng cách ném requestValue.

Ví dụ, điều này có ích khi bạn cần một giá trị cho một tham số đôi khi là tùy chọn.

Ở đây, requestValue giúp tôi khi tìm kiếm chuỗi của tôi trả về nhiều hơn một cuốn sách.

Trong trường hợp này, tôi nhắc nhở và yêu cầu một tác giả thu hẹp phạm vi tìm kiếm sách.

requestValue cho tôi một lỗi mà tôi có thể ném, lỗi này sẽ nhắc người dùng và chạy lại hành động với tên tác giả được cập nhật.

Trong khi đó, định hướng rất tuyệt khi bạn cần người dùng chọn giữa một tập hợp các giá trị cho một tham số.

Điều này cho tôi một cách thậm chí còn tốt hơn để xử lý nhiều kết quả có thể có trong hành động Thêm Sách của tôi.

Ở đây, tôi nhận được một danh sách tên tác giả từ những cuốn sách được tạo ra và yêu cầu định hướng với những giá trị có thể có đó.

Người dùng sẽ được yêu cầu chọn giữa chúng, và tôi sẽ lấy lại kết quả.

Cuối cùng, App Intents hỗ trợ hai loại xác nhận khác nhau.

Loại đầu tiên là xác nhận một giá trị tham số.

Bạn có thể sử dụng cái này khi bạn đoán được giá trị đó nên là bao nhiêu nhưng bạn muốn xác nhận, chỉ để chắc chắn.

Khi thêm một cuốn sách, đôi khi dịch vụ web tôi gọi để tra cứu sách theo tiêu đề trả về một vài kết quả phù hợp, nhưng một trong số đó cho đến nay là phổ biến hơn.

Trong những trường hợp này, tôi sẽ giả định rằng người dùng muốn thêm cuốn sách phổ biến đó, nhưng tôi sẽ thêm xác nhận để đảm bảo rằng tôi đã làm đúng.

Để làm điều đó, tôi sẽ gọi requestConfirmation trên tham số tiêu đề.

Loại thứ hai là xác nhận kết quả của một ý định.

Ví dụ, điều này rất tốt cho việc đặt hàng.

Nếu tôi muốn kiếm tiền từ ứng dụng Thư viện của mình và thêm đơn đặt hàng thông qua hiệu sách, tôi muốn đảm bảo rằng tôi đã đặt hàng đúng.

Để làm điều này, tôi có thể gọi requestConfirmation về ý định của mình, chuyển theo thứ tự được đặt.

Tôi cũng sẽ chỉ định một đoạn mã ở đây, hiển thị bản xem trước của đơn đặt hàng.

Tôi đặt tiền tố cuộc gọi bằng "thử" vì requestConfirmation sẽ gây ra lỗi nếu người dùng hủy thay vì xác nhận.

Trước khi tôi rời khỏi bạn, có một vài khía cạnh của kiến trúc App Intents mà tôi muốn đề cập đến, mà bạn nên biết khi áp dụng khuôn khổ.

Thực tế có hai cách để xây dựng Ý định ứng dụng của bạn: trong ứng dụng của bạn hoặc trong một tiện ích mở rộng riêng biệt.

Trong số này, việc triển khai ý định trực tiếp trong ứng dụng của bạn là đơn giản nhất.

Điều này thật tuyệt vì bạn không cần một khuôn khổ hoặc sao chép mã của mình và bạn không cần phối hợp giữa các quy trình.

Sử dụng ứng dụng của bạn cũng cung cấp một số giới hạn bộ nhớ cao hơn và nó cung cấp cho bạn khả năng thực hiện một số loại công việc khó hơn từ tiện ích mở rộng, như phát âm thanh.

Ứng dụng của bạn có thể được chạy ở phía trước nếu bạn triển khai openAppWhenRun với ý định trả về true.

Nếu không, nó sẽ được chạy trong nền.

Khi chạy ở chế độ nền, ứng dụng của bạn sẽ khởi chạy ở chế độ đặc biệt mà không có cảnh nào được đưa lên để tối đa hóa hiệu suất.

Trên thực tế, nếu bạn triển khai ý định ứng dụng nền trong ứng dụng của mình, chúng tôi đặc biệt khuyến khích bạn cũng triển khai hỗ trợ cảnh.

Hoặc, bạn có thể xây dựng ý định ứng dụng của mình trong một tiện ích mở rộng.

Điều này có một vài lợi thế.

Nó nhẹ hơn, bởi vì quá trình mở rộng chỉ xử lý ý định của ứng dụng và không yêu cầu quay ứng dụng của bạn.

Nếu bạn đang xử lý ý định của Focus, sử dụng tiện ích mở rộng cũng có nghĩa là bạn sẽ ngay lập tức nhận được ý định được thực hiện trên tiện ích mở rộng của mình khi Focus thay đổi, mà không yêu cầu ứng dụng của bạn đang chạy ở phía trước.

Tiện ích mở rộng có nhiều công sức hơn một chút, vì bạn sẽ cần thêm mục tiêu mới, di chuyển một số mã vào khuôn khổ và xử lý sự phối hợp giữa ứng dụng của bạn và tiện ích mở rộng.

Để tạo phần mở rộng App Intents, hãy vào File > New Target trong Xcode và chọn App Intents Extension.

Với App Intents, mã của bạn là nguồn duy nhất của sự thật.

App Intents đạt được trải nghiệm nhà phát triển thanh lịch này bằng cách trích xuất tĩnh thông tin về ý định, thực thể, truy vấn và tham số của bạn tại thời điểm xây dựng.

Xcode sẽ tạo một tệp siêu dữ liệu bên trong ứng dụng hoặc gói tiện ích mở rộng của bạn trong quá trình xây dựng, chứa thông tin nhận được từ trình biên dịch Swift khi nó chạy trên mã của bạn.

Để đảm bảo tất cả những điều này hoạt động, hãy giữ các loại Ý định ứng dụng của bạn trực tiếp trong mục tiêu hoặc tiện ích mở rộng, không phải trong một khuôn khổ.

Tương tự, các chuỗi được bản địa hóa của bạn nên được tìm thấy trong một tệp chuỗi trong cùng một gói nơi các loại Ý định Ứng dụng của bạn tồn tại.

Đối với những người bạn có các ứng dụng hiện có với Ý định SiriKit mà bạn muốn nâng cấp, nếu bạn áp dụng ý định tích hợp với các tiện ích hoặc miền như nhắn tin hoặc phương tiện, bạn nên tiếp tục sử dụng khung Ý định SiriKit.

Nhưng nếu bạn thêm ý định tùy chỉnh cho Siri và Phím tắt, bạn nên tiếp tục và nâng cấp lên App Intents.

Bạn có thể bắt đầu quá trình nâng cấp bằng cách nhấp vào nút Chuyển đổi thành Ý định ứng dụng trong tệp định nghĩa Ý định SiriKit của bạn.

Tích hợp ứng dụng của bạn vào Phím tắt với Ý định ứng dụng là một cách tuyệt vời để tối đa hóa đòn bẩy của bạn với tư cách là một nhà phát triển, bởi vì bằng cách thực hiện một lượng nhỏ công việc để áp dụng Ý định ứng dụng, bạn tạo ra một lượng lớn giá trị cho khách hàng.

Cảm ơn bạn đã tham gia!

Tôi thực sự hy vọng rằng bạn sẽ dùng thử App Intents hôm nay và cho chúng tôi phản hồi của bạn.

Tôi rất hào hứng về cách khuôn khổ mới này có thể giúp bạn gây bất ngờ, thích thú và trao quyền cho mọi người sử dụng ứng dụng của bạn!

Chúc bạn đọc vui vẻ và hy vọng WWDC của bạn thật hoành tráng!

♪