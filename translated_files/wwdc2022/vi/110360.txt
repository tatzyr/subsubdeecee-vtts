110360

♪ ♪

Xin chào! Tên tôi là Tom, và tôi là một phần của nhóm Swift tại Apple.

Hôm nay tôi muốn chia sẻ những gì cần thiết để mở rộng ứng dụng iOS lên đám mây.

Nhiều ứng dụng của chúng tôi bắt đầu tập trung vào một thiết bị duy nhất, thường là iPhone.

Khi việc sử dụng tăng lên, chúng tôi thấy mình muốn đưa nó đến các thiết bị bổ sung như Mac, đồng hồ hoặc các nền tảng và thiết bị khác của Apple.

Xcode giúp chúng tôi tổ chức và xây dựng ứng dụng của mình cho các nền tảng này.

Chúng tôi có thể chia sẻ mã bằng cách sử dụng các gói trong khi nắm bắt các khía cạnh độc đáo của từng thiết bị trong mã ứng dụng cụ thể của nền tảng.

Khi các hệ thống tiếp tục phát triển và phát triển, các ứng dụng thường cần bổ sung cho ứng dụng khách hàng bằng một thành phần máy chủ.

Các thành phần máy chủ này cho phép ứng dụng khách mở rộng chức năng của chúng lên đám mây.

Ví dụ, các tác vụ giảm tải có thể được thực hiện trong nền, các tác vụ giảm tải nặng về tính toán hoặc các tác vụ yêu cầu quyền truy cập vào dữ liệu không có sẵn trên thiết bị.

Thông thường, các thành phần máy chủ cần được xây dựng bằng cách sử dụng các công cụ và phương pháp khác nhau từ các đối tác máy khách của chúng, tạo ra sự trùng lặp về nỗ lực và các thách thức tích hợp.

Sử dụng Swift để xây dựng các thành phần máy chủ giúp thu hẹp khoảng cách công nghệ này, cung cấp một môi trường quen thuộc trên toàn bộ ngăn xếp.

Hãy xem việc xây dựng một ứng dụng máy chủ trong Swift trông như thế nào.

Các ứng dụng máy chủ được mô hình hóa như các gói Swift.

Gói xác định một mục tiêu thực thi ánh xạ điểm vào ứng dụng.

Để biến ứng dụng thành ứng dụng web, chúng tôi có thể thêm sự phụ thuộc vào khung web giúp chúng tôi cấu trúc mã của mình và cung cấp các tiện ích cơ bản như định tuyến.

Trong ví dụ này, chúng tôi sử dụng khung web Vapor, một dự án cộng đồng mã nguồn mở phổ biến để xây dựng các dịch vụ web.

Cũng như các tệp thực thi dựa trên Swift khác, điểm vào của chương trình được mô hình hóa tốt nhất bằng cách sử dụng chú thích @main.

Để tích hợp khung web, chúng tôi thêm mã bootstrap có liên quan vào chức năng chính.

Loại ứng dụng được sử dụng trong ví dụ này được cung cấp bởi khung web Vapor.

Với việc khởi động cơ bản tại chỗ, chúng tôi có thể làm cho ứng dụng của mình làm điều gì đó hữu ích.

Ví dụ, hãy thêm mã để chào đón người dùng đưa ra yêu cầu đến máy chủ.

Chúng tôi sử dụng khung web để xác định điểm cuối HTTP và trỏ nó đến một phương thức cung cấp lời chào.

Tiến thêm một bước nữa, chúng tôi thêm điểm cuối HTTP thứ hai, điểm này xử lý yêu cầu bài đăng HTTP và lặp lại nội dung của nội dung yêu cầu trở lại người gọi.

Hãy xem điều này đang hoạt động.

Ở đây chúng tôi có ứng dụng máy chủ của chúng tôi trong Xcode.

Vì chúng tôi chỉ mới bắt đầu, chúng tôi có thể chạy máy chủ cục bộ trên máy của riêng mình để kiểm tra mọi thứ.

Để chạy nó cục bộ, chúng tôi chọn sơ đồ "MyServer" được tạo cho chúng tôi bởi Xcode, sử dụng "My Mac" làm đích đến và nhấn "run".

Khi ứng dụng đã khởi chạy, chúng ta có thể sử dụng bảng điều khiển Xcode để kiểm tra các thông báo nhật ký do máy chủ phát ra.

Trong trường hợp này, chúng ta có thể thấy rằng máy chủ đã khởi động và lắng nghe trên địa chỉ localhost (127.0.0.1) cổng 8080.

Chúng tôi có thể sử dụng thông tin này để kiểm tra máy chủ của mình.

Hãy chuyển sang thiết bị đầu cuối và đưa ra yêu cầu đến địa chỉ máy chủ được quảng cáo.

Chúng tôi sử dụng một tiện ích gọi là "curl" để đưa ra yêu cầu.

Sử dụng điểm cuối đầu tiên của chúng tôi.

Và cái thứ hai của chúng tôi.

Chuyển một số dữ liệu để lặp lại.

Tuyệt vời!

Sử dụng thiết bị đầu cuối chắc chắn rất thú vị, nhưng điều chúng tôi thực sự muốn biết là cách gọi máy chủ của chúng tôi từ ứng dụng iOS.

Hãy cùng tìm hiểu điều đó.

Đây là một ví dụ về cấu trúc dữ liệu Swift mà chúng ta có thể sử dụng để trừu tượng hóa sự tương tác với máy chủ.

Chúng tôi mô hình hóa các API máy chủ như các phương thức không đồng bộ trên sự trừu tượng của chúng tôi, bởi vì mạng vốn không đồng bộ.

Chúng tôi sử dụng URLSession để thực hiện một yêu cầu không đồng bộ sau đó phân tích cú pháp phản hồi của máy chủ và cuối cùng trả lại cho người gọi.

Trong trường hợp này, phản hồi của máy chủ là một chuỗi đơn giản, nhưng trên thực tế, nó có thể phức tạp hơn.

Ví dụ, phản hồi có thể được mã hóa trong JSON, trong trường hợp đó chúng ta có thể giải mã nó bằng hệ thống Codable của Swift.

Hãy kết hợp tất cả những điều này lại với nhau trong Xcode.

Chúng tôi đang sử dụng không gian làm việc Xcode để xây dựng và kiểm tra các ứng dụng iOS và máy chủ cạnh nhau.

Chúng tôi đã có sẵn bản tóm tắt máy chủ ứng dụng iOS.

Hãy thay đổi SwiftUI ContentView mặc định để tìm nạp lời chào của máy chủ bằng cách sử dụng mã mà chúng tôi đã đặt cùng nhau.

Đầu tiên chúng tôi tạo ra một biến trạng thái được gọi là serverGreeting.

Tiếp theo, chúng tôi liên kết máy chủGreeting với màn hình Văn bản.

Cuối cùng, chúng tôi thêm một nhiệm vụ để gọi API máy chủ và đặt trạng thái.

Khi mã đã sẵn sàng, chúng ta có thể chạy ứng dụng trong trình giả lập.

Chúng tôi chọn sơ đồ "MyApp", một trình giả lập và nhấn "chạy".

Ồ, không! Chúng tôi gặp lỗi!

Hmm, đây có vẻ là một số loại lỗi kết nối.

Địa chỉ có vẻ đúng, vì vậy chắc hẳn chúng ta đã quên khởi động máy chủ cục bộ.

Hãy chuyển trở lại Xcode, chọn sơ đồ máy chủ và chạy máy chủ.

Bây giờ, hãy khởi động lại ứng dụng của chúng ta, bắt chéo ngón tay của chúng ta...

Và whoo-hoo! Nó đã hoạt động!

Để hoàn thành phần này của bản demo, hãy triển khai ứng dụng của chúng tôi lên đám mây.

Có rất nhiều nhà cung cấp đám mây để lựa chọn, bao gồm AWS, Google Cloud, Azure, Heroku và nhiều nhà cung cấp khác.

Trong ví dụ này, chúng tôi sẽ sử dụng Heroku.

Heroku có một git đẩy thuận tiện để triển khai hệ thống cho các dự án nhỏ như ứng dụng demo này.

Hãy chuyển sang thiết bị đầu cuối để bắt đầu triển khai.

Sau khi thiết lập tài khoản của chúng tôi và định cấu hình ứng dụng của chúng tôi với dịch vụ Heroku, chúng tôi có thể đẩy mã của mình đến điều khiển từ xa Heroku.

Và tắt nó đi!

Heroku sử dụng một công nghệ gọi là buildpacks để biên dịch ứng dụng từ xa, sau đó triển khai các tạo tác nhị phân đến một máy chủ tạm thời.

Gói xây dựng Heroku swift được xây dựng bởi các thành viên của cộng đồng mã nguồn mở Swift và nó có sẵn cho tất cả người dùng Swift trên Máy chủ.

Với ứng dụng của chúng tôi được triển khai, chúng tôi có thể kiểm tra nó bằng cách sử dụng curl, như chúng tôi đã làm với máy chủ cục bộ của mình.

Hãy kiểm tra điểm cuối đầu tiên.

Sao chép địa chỉ ở đây.

Và cái thứ hai của chúng tôi.

Lần này, chúng tôi sẽ gửi một tải trọng khác.

Ngọt ngào, ứng dụng của chúng tôi đã được triển khai thành công!

Trước khi chúng ta tiếp tục, hãy tạm dừng ở đây và xem lại những điều rút ra chính từ phần này của cuộc nói chuyện.

Nếu bạn đã sử dụng Swift để xây dựng Ứng dụng iOS hoặc macOS, bạn cũng có thể sử dụng nó để phát triển phía máy chủ của hệ thống.

Xcode giúp chúng tôi phát triển và gỡ lỗi các thành phần khác nhau của hệ thống, cả máy khách và máy chủ, tất cả trong một Không gian làm việc.

Và cuối cùng, bạn có thể lựa chọn các nhà cung cấp đám mây để triển khai các ứng dụng máy chủ dựa trên Swift.

Thông tin bổ sung về việc triển khai cho các nền tảng đám mây này có thể được tìm thấy trên tài liệu Máy chủ Swift tại swift.org.

Bây giờ chúng ta đã thấy một thiết lập cơ bản, hãy xem xét một ví dụ thực tế hơn - Xe tải thực phẩm!

Bạn có thể đã thấy ứng dụng này được sử dụng trong nhiều phiên của chúng tôi.

Hãy nhìn trộm dưới mui xe và xem dữ liệu được quản lý như thế nào.

Hmm, có vẻ như danh sách bánh rán được mã hóa cứng.

Điều này có nghĩa là người dùng ứng dụng có thể thấy một menu bánh rán khác với những gì thực sự có sẵn.

Mặc dù điều này có thể hữu ích cho một hoạt động Xe tải Thực phẩm nhỏ, một hoạt động có thể làm bất kỳ loại bánh rán nào ngay tại chỗ, chúng tôi muốn xây dựng một đế chế bánh rán nơi thực đơn được tập trung và các xe tải đều hướng đến dịch vụ khách hàng.

Hãy thiết kế hệ thống Xe tải Thực phẩm tập trung của chúng ta có thể trông như thế nào.

Chúng tôi đang bắt đầu với ứng dụng iOS của mình, với bộ nhớ trong bộ nhớ.

Để tập trung menu, chúng ta có thể trích xuất bộ nhớ từ ứng dụng iOS và di chuyển nó đến máy chủ.

Điều này sẽ cho phép tất cả người dùng ứng dụng chia sẻ cùng một bộ nhớ, và do đó, cùng một menu bánh rán.

Tương tự như ví dụ trong phần đầu tiên của cuộc nói chuyện, máy chủ của chúng tôi sẽ hiển thị API dựa trên HTTP.

Ứng dụng iOS sẽ sử dụng một sự trừu tượng để làm việc với các API này, sau đó liên kết chúng lại với nhau với tầng trình bày, trong ví dụ này là SwiftUI.

Thiết kế của chúng tôi đã hoàn thành.

Thời gian để viết một số mã ngọt ngào.

Bạn có thể theo dõi bằng cách tải xuống ứng dụng mẫu Xe tải Thực phẩm từ bộ tài nguyên dành cho nhà phát triển.

Chúng tôi bắt đầu xây dựng Máy chủ của mình với một khung ứng dụng, sau đó xác định điểm cuối HTTP cho API web "donuts" và trỏ nó đến phương thức "listDonuts" trên máy chủ trừu tượng của chúng tôi.

Bạn có thể nhận thấy rằng API trả về một Phản hồi thuộc loại Donuts và Phản hồi đó.Donuts phù hợp với một giao thức được gọi là Nội dung.

Giao thức Nội dung được xác định bởi khung web và giúp chúng tôi mã hóa phản hồi dưới dạng JSON trên dây.

Bạn cũng có thể nhận thấy rằng API bao gồm một mảng của một Model.Donut bí ẩn, mà chúng tôi vẫn chưa xác định Vì vậy, đây là mô hình dữ liệu của chúng tôi trong tất cả vinh quang của nó: Donut, Dough, Glaze và Topping.

Một điểm thú vị cần thực hiện ở đây là chúng tôi đã sao chép định nghĩa của mô hình này từ ứng dụng Food Truck iOS của mình, vì chúng tôi cần các mô hình dữ liệu của máy chủ và máy khách để căn chỉnh gần đúng.

Một điểm thú vị khác là sự phù hợp với giao thức Encodable.

Điều này là bắt buộc để máy chủ của chúng tôi có thể mã hóa các đối tượng mô hình dưới dạng JSON qua dây.

Với mô hình dữ liệu và các API cơ bản tại chỗ, chúng ta có thể mở rộng logic của mình để bao gồm sự trừu tượng hóa lưu trữ.

Việc lưu trữ sẽ cung cấp cho Ứng dụng danh sách các loại bánh rán có sẵn.

Tại thời điểm này, chúng ta nên có một máy chủ đầy đủ chức năng.

Nhưng chờ đã! Thực đơn bánh rán của chúng tôi trống rỗng!

Chúng ta nên lấy thực đơn tập trung từ đâu?

Lưu trữ luôn là một chủ đề thú vị khi thiết kế các ứng dụng phía máy chủ.

Có một số chiến lược để lựa chọn, tùy thuộc vào trường hợp sử dụng.

Nếu dữ liệu ứng dụng tĩnh hoặc thay đổi rất chậm và thủ công, các tệp trên đĩa có thể cung cấp một giải pháp đủ tốt.

Đối với dữ liệu lấy người dùng làm trung tâm hoặc bộ dữ liệu toàn cầu, iCloud cung cấp một bộ API mà bạn có thể sử dụng trực tiếp từ ứng dụng iOS mà không cần triển khai máy chủ chuyên dụng.

Khi xử lý dữ liệu động hoặc giao dịch, cơ sở dữ liệu cung cấp một giải pháp tuyệt vời.

Có rất nhiều công nghệ cơ sở dữ liệu có sẵn cho các ứng dụng phía máy chủ.

Mỗi công nghệ được thiết kế cho hiệu suất cụ thể, tính nhất quán của dữ liệu và nhu cầu mô hình hóa dữ liệu.

Trong những năm qua, cộng đồng nguồn mở Swift đã phát triển các trình điều khiển cơ sở dữ liệu giúp tương tác nguyên bản với hầu hết các công nghệ cơ sở dữ liệu.

Danh sách một phần bao gồm Postgres, MySQL, MongoDB, Redis, DynamoDB, và nhiều danh sách khác.

Với mục đích đơn giản hóa bản demo này, chúng tôi sẽ chỉ trình diễn chiến lược lưu trữ tệp tĩnh, nhưng bạn có thể tìm hiểu thêm về cách sử dụng cơ sở dữ liệu trên tài liệu Máy chủ Swift tại swift.org.

Vì chúng tôi đang sử dụng chiến lược lưu trữ tệp tĩnh, chúng tôi bắt đầu bằng cách tạo tệp JSON ghi lại menu bánh rán.

Sau khi tạo tệp này, chúng tôi có thể làm cho nó có thể truy cập được vào ứng dụng bằng cách sử dụng hỗ trợ tài nguyên của SwiftPM.

Với điều đó tại chỗ, đã đến lúc làm cho sự trừu tượng lưu trữ của chúng ta trở nên tinh vi hơn.

Cụ thể, chúng tôi thêm một phương thức "tải".

Phương pháp này tìm đường dẫn tệp tài nguyên bằng trình truy cập tài nguyên được tạo của SwiftPM, sau đó sử dụng API FileManager để tải nội dung của tệp vào bộ nhớ.

Cuối cùng, chúng tôi sử dụng JSONDecoder để giải mã nội dung JSON thành mô hình dữ liệu ứng dụng máy chủ.

Một thay đổi thú vị là Lưu trữ hiện được định nghĩa là một diễn viên.

Chúng tôi đã chọn sử dụng một diễn viên vì Storage hiện có biến "donuts" có thể thay đổi và các phương thức "load" và "listDonuts" có thể truy cập đồng thời.

Các diễn viên, lần đầu tiên được giới thiệu trong Swift 5.5, giúp chúng tôi tránh các cuộc đua dữ liệu và xử lý trạng thái có thể thay đổi được chia sẻ một cách an toàn nhưng dễ dàng.

Trước khi giới thiệu các tác nhân, chúng ta cần phải nhớ và thêm các khối đồng bộ hóa khi truy cập trạng thái có thể thay đổi bằng API như Khóa hoặc Hàng đợi.

Với các bản cập nhật lưu trữ đã hoàn tất, chúng ta có thể kết hợp tất cả lại với nhau.

Chúng tôi thêm một phương thức "bootstrap" vào sự trừu tượng hóa máy chủ của chúng tôi và tải bộ nhớ từ đó.

Sau đó, chúng tôi nối dây bootstrap đến điểm vào thực thi.

Lưu ý rằng vì lưu trữ bây giờ là một diễn viên, chúng tôi truy cập nó trong một ngữ cảnh không đồng bộ.

Máy chủ của chúng tôi đã sẵn sàng.

Hãy chuyển sang phía khách hàng.

Chúng tôi bắt đầu bằng cách thêm một bản tóm tắt Máy chủ sẽ giúp chúng tôi gói gọn các API của máy chủ.

Chúng tôi sử dụng URLSession để thực hiện yêu cầu HTTP và JSONDecoder để giải mã phản hồi của máy chủ và chuyển đổi nó từ JSON thành mô hình ứng dụng iOS của chúng tôi.

Tại thời điểm này, chúng ta có thể xóa menu được mã hóa cứng và thay thế nó bằng một tìm nạp không đồng bộ từ máy chủ.

Cuối cùng, chúng tôi thực hiện cuộc gọi đến máy chủ từ tác vụ tải ContentView.

Đến lúc kiểm tra rồi!

Lần này, đừng quên khởi động máy chủ.

Chúng tôi sẽ chọn sơ đồ "FoodTruckServer" ở đây.

Nhấn chạy.

Và với ứng dụng đang chạy, hãy nhảy vào thiết bị đầu cuối và xem rằng chúng ta có thể truy cập các API.

Sao chép lại địa chỉ.

Lần này, chúng ta sẽ sử dụng một tiện ích gọi là jq để in đầu ra JSON đẹp hơn.

Cái này trông khá ổn.

Được rồi, đã đến lúc kiểm tra với Ứng dụng của chúng tôi.

Chuyển sang Xcode.

Chọn chương trình Xe tải Thực phẩm ở đây.

Trình mô phỏng.

Và chạy nó.

Và ở đó chúng tôi có nó, ba chiếc bánh rán từ thực đơn tập trung của chúng tôi.

Chúng ta có thể tham chiếu chéo điều đó với những gì chúng ta thấy từ máy chủ.

Hãy quay trở lại thiết bị đầu cuối.

Để so sánh dễ dàng, chúng tôi sẽ sử dụng jq để truy vấn chỉ tên của bánh rán.

Không gian sâu, Sô cô la 2, Cà phê Caramel - chính xác như những gì chúng tôi mong đợi.

Điều đó thật tuyệt vời!

Nhưng chúng ta có thể làm tốt hơn nữa.

Như hiện tại, các ứng dụng máy chủ và máy khách của chúng tôi đều có các bản sao giống hệt nhau của mã mô hình dữ liệu.

Chúng ta có thể tránh lặp lại và làm cho việc tuần tự hóa an toàn hơn, bằng cách chia sẻ mô hình trên các ứng dụng iOS và máy chủ.

Hãy xem lại cách thiết lập điều này ở mức cao.

Đầu tiên, chúng tôi tạo một gói khác cho thư viện có tên "Chia sẻ" và thêm nó vào không gian làm việc Xcode.

Sau đó, chúng ta có thể di chuyển mã mô hình dữ liệu sang gói Chia sẻ, thêm Chia sẻ dưới dạng phụ thuộc của ứng dụng máy chủ và dưới dạng phụ thuộc của ứng dụng iOS, sử dụng cài đặt Khung mục tiêu và Thư viện.

Tại thời điểm đó, chúng tôi có thể tái cấu trúc mã máy khách của mình để sử dụng mô hình được chia sẻ và làm tương tự với mã máy chủ.

Bây giờ mọi thứ trông đẹp hơn nhiều.

Trước khi chúng tôi kết thúc, đây là một số ý tưởng về nơi chúng tôi có thể nhận đơn đăng ký tiếp theo.

Để tận dụng tối đa thực tế là chúng tôi có một máy chủ tập trung, chúng tôi có thể muốn và xác định các API để thêm, chỉnh sửa hoặc xóa bánh rán khỏi menu.

Điều này sẽ yêu cầu chúng tôi chuyển bộ nhớ của mình từ tệp tĩnh sang cơ sở dữ liệu.

Với một cơ sở dữ liệu tại chỗ, chúng tôi cũng có thể thực hiện các API mua và đặt hàng.

Những API như vậy có thể giúp chúng tôi kiếm tiền từ việc kinh doanh bánh rán của mình.

Họ cũng cung cấp một tín hiệu, mà chúng ta có thể sử dụng để thực hiện định giá động, như bán hàng và giảm giá cho những chiếc bánh rán ít phổ biến hơn.

Cơ hội là vô tận.

Để kết thúc, trong phiên này, chúng tôi đã thấy rằng Swift là một ngôn ngữ có mục đích chung, hữu ích cho cả ứng dụng máy khách và máy chủ, chia sẻ mã giữa máy chủ và ứng dụng khách có thể làm giảm bản mẫu và làm cho việc tuần tự hóa hệ thống của chúng tôi an toàn hơn, URLSession là một công cụ chính để tương tác với

Cảm ơn bạn rất nhiều vì đã xem, và tận hưởng phần còn lại của hội nghị.