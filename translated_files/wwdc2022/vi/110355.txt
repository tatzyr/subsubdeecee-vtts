110355

♪ nhạc cụ hip hop ♪

Xin chào, tên tôi là Philippe.

Swift có một danh mục ngày càng tăng các gói mã nguồn mở.

Tôi vui mừng giới thiệu với bạn một trong những bổ sung mới nhất: Thuật toán Swift Async.

Gói này nằm cùng với các gói khác, như Bộ sưu tập Swift và Thuật toán Swift.

Gói Swift Async Algorithms là một tập hợp các thuật toán đặc biệt tập trung vào việc xử lý các giá trị theo thời gian bằng cách sử dụng AsyncSequence.

Nhưng trước khi chúng ta đi sâu vào nó, chúng ta hãy dành một chút thời gian ngắn để tóm tắt lại AsyncSequence.

AsyncSequence là một giao thức cho phép bạn mô tả các giá trị được tạo ra không đồng bộ.

Về cơ bản, nó giống như Sequence, nhưng có hai điểm khác biệt chính.

Hàm tiếp theo từ trình lặp của nó là không đồng bộ, là nó có thể cung cấp các giá trị bằng cách sử dụng đồng thời Swift.

Nó cũng cho phép bạn xử lý bất kỳ thất bại tiềm ẩn nào bằng cách sử dụng hiệu ứng ném của Swift.

Và giống như trình tự, bạn có thể lặp lại nó, sử dụng cú pháp for-await-in.

Tóm lại, nếu bạn biết cách sử dụng Sequence, bạn đã biết cách sử dụng AsyncSequence.

Bây giờ, khi AsyncSequence được giới thiệu, chúng tôi đã thêm vào hầu hết các công cụ mà bạn mong đợi tìm thấy với Sequence ngay tại đó với các phiên bản không đồng bộ.

Bạn có các thuật toán như bản đồ, bộ lọc, giảm và hơn thế nữa.

Gói Swift Async Algorithms tiến thêm một bước nữa bằng cách kết hợp các thuật toán nâng cao hơn, cũng như tương tác với đồng hồ để cung cấp cho bạn một số thứ thực sự mạnh mẽ.

Đây là một gói mã nguồn mở của các thuật toán AsyncSequence giúp tăng tính đồng thời của Swift.

Năm ngoái chúng tôi đã giới thiệu gói Swift Algorithms.

Để chứng minh việc sử dụng các thuật toán đó, chúng tôi đã tạo một ứng dụng nhắn tin.

Đây là một ví dụ tuyệt vời về một số thứ phong phú và mạnh mẽ mà bạn có thể làm với gói đó.

Chúng tôi quyết định có một số cơ hội thực sự tốt để tận dụng lợi thế của việc di chuyển ứng dụng để sử dụng Swift đồng thời.

Để làm nổi bật chỉ một vài thuật toán không đồng bộ, tôi sẽ đưa bạn qua một số thứ mà chúng tôi đã sử dụng và cách chúng hoạt động.

Trước hết, chúng tôi có một họ các thuật toán để làm việc với nhiều AsyncSequences đầu vào.

Đây là những thuật toán tập trung vào việc kết hợp AsyncSequences với nhau theo những cách khác nhau.

Nhưng tất cả chúng đều có chung một đặc điểm: Chúng lấy nhiều AsyncSequences đầu vào và tạo ra một AsyncSequence đầu ra.

Một thứ mà bạn có thể đã quen thuộc là Zip.

Thuật toán Zip lấy nhiều đầu vào và lặp lại chúng sao cho nó tạo ra một bộ kết quả từ mỗi cơ sở.

Mỗi đầu vào cho Zip là các cơ sở mà Zip được xây dựng từ đó.

Thuật toán Zip không đồng bộ hoạt động giống như thuật toán Zip trong thư viện tiêu chuẩn, nhưng nó lặp lại đồng thời từng cơ sở và ném lại lỗi nếu xảy ra lỗi khi lặp lại bất kỳ cơ sở nào trong số chúng.

Bây giờ, việc hoàn thành lần lặp lại đồng thời đó với lỗi ném lại có thể khá liên quan.

Nhưng gói Swift Async Algorithms đã xử lý tất cả những điều đó cho chúng tôi trong ứng dụng nhắn tin của chúng tôi.

Trước đây chúng tôi đã có rất nhiều mã điều phối việc tạo ra các bản xem trước không đồng bộ các bản ghi video và chuyển mã video thành nhiều kích cỡ để lưu trữ và truyền tải hiệu quả.

Bằng cách sử dụng Zip, chúng tôi có thể đảm bảo rằng video được chuyển mã sẽ được xem trước khi chúng tôi gửi nó đến máy chủ.

Vì Zip là đồng thời, cả chuyển mã hoặc xem trước sẽ không trì hoãn lẫn nhau.

Nhưng điều này còn đi xa hơn một chút.

Bản thân Zip không có ưu tiên về mặt nào tạo ra giá trị đầu tiên hay không, vì vậy một video có thể được sản xuất trước hoặc xem trước, và bất kể đó là bên nào, nó sẽ chờ bên kia gửi một bộ hoàn chỉnh.

Chúng ta có thể chờ các cặp sao cho chúng có thể được tải lên cùng nhau vì Zip đang chờ mỗi bên đồng thời để xây dựng một bộ giá trị.

Chúng tôi đã đi đến kết luận rằng việc mô hình hóa các tin nhắn đến của chúng tôi như một AsyncSequence có rất nhiều ý nghĩa.

Vì vậy, chúng tôi quyết định sử dụng AsyncStream để xử lý những tin nhắn đó vì nó giữ nguyên thứ tự và biến các cuộc gọi lại của chúng tôi thành AsyncSequence của các tin nhắn.

Một trong những tính năng được yêu cầu mà chúng tôi cần giải quyết là chúng tôi muốn hỗ trợ nhiều tài khoản.

Vì vậy, mỗi tài khoản tạo ra một AsyncStream của các tin nhắn đến, nhưng khi triển khai điều này, chúng ta cần xử lý tất cả chúng cùng nhau như một AsyncSequence đơn lẻ.

Điều này có nghĩa là chúng tôi cần một thuật toán để hợp nhất các AsyncSequences đó lại với nhau.

Rất may, gói Swift Async Algorithms có một thuật toán cho chính xác điều đó, được đặt tên một cách khéo léo là "Hợp nhất".

Nó hoạt động tương tự như Zip ở chỗ nó đồng thời lặp lại nhiều AsyncSequences. Nhưng thay vì tạo các bộ được ghép nối, nó yêu cầu các cơ sở chia sẻ cùng một loại phần tử và hợp nhất AsyncSequences cơ sở thành một AsyncSequence số ít của các phần tử đó.

Hợp nhất các tác phẩm bằng cách lấy phần tử đầu tiên được tạo ra bởi bất kỳ bên nào khi lặp lại.

Nó tiếp tục lặp lại cho đến khi không còn giá trị nào có thể được tạo ra, đặc biệt là khi tất cả các AsyncSequences cơ sở trả về số không từ trình lặp của chúng.

Nếu bất kỳ cơ sở nào tạo ra lỗi, các lần lặp lại khác sẽ bị hủy bỏ.

Điều này cho phép chúng tôi lấy AsyncSequences của các tin nhắn và hợp nhất chúng.

Các thuật toán kết hợp này hoạt động đồng thời khi các giá trị được tạo ra, nhưng đôi khi rất hữu ích khi thực sự tương tác với chính thời gian.

Gói Swift Async Algorithms mang đến một nhóm các thuật toán để làm việc theo thời gian bằng cách tận dụng Clock API mới trong Swift.

Bản thân thời gian có thể là một chủ đề thực sự phức tạp và tính mới trong Swift (5.7) là một tập hợp các API để làm cho nó an toàn và nhất quán: Đồng hồ, Tức thì và Thời lượng.

Giao thức Đồng hồ xác định hai nguyên thủy, một cách để thức dậy sau một khoảnh khắc nhất định và một cách để tạo ra một khái niệm về hiện tại.

Có một vài chiếc đồng hồ tích hợp sẵn.

Hai trong số những cái phổ biến hơn là ContinuousClock và SuspendingClock.

Bạn có thể sử dụng ContinuousClock để đo thời gian giống như đồng hồ bấm giờ, nơi thời gian trôi qua bất kể trạng thái của vật đang được đo.

Mặt khác, SuspendingClock thực hiện những gì tên gọi của nó ngụ ý; nó tạm dừng khi máy được đưa vào chế tạo trạng thái ngủ.

Chúng tôi đã sử dụng API đồng hồ mới trong ứng dụng của mình để di chuyển từ các sự kiện gọi lại hiện có sang chức năng ngủ đồng hồ để xử lý việc loại bỏ các cảnh báo sau một thời hạn.

Chúng tôi đã có thể tạo thời hạn bằng cách thêm giá trị thời lượng chỉ ra cụ thể số giây chúng tôi muốn trì hoãn.

Đồng hồ cũng có một số phương pháp tiện dụng để đo thời gian thực hiện công việc đã trôi qua.

Ở đây chúng ta có hai đồng hồ phổ biến mà tôi đã đề cập trước đó, SuspendingClock và ContinuousClock.

Dưới đây là các màn hình hiển thị thời gian làm việc tiềm năng đã trôi qua đang được đo lường.

Sự khác biệt chính giữa hai đồng hồ này đến từ hành vi của nó khi máy đang ngủ.

Đối với công việc kéo dài như thế này, công việc có thể bị tạm dừng, giống như chúng tôi đã làm ở đây, nhưng khi chúng tôi tiếp tục thực thi, ContinuousClock đã tiến triển trong khi máy đang ngủ, nhưng SuspendingClock thì không.

Thông thường, sự khác biệt này có thể là chi tiết chính để đảm bảo những thứ như hoạt ảnh hoạt động như mong đợi bằng cách tạm dừng thời gian thực hiện.

Nếu bạn cần tương tác với thời gian liên quan đến máy, như đối với hoạt ảnh, hãy sử dụng SuspendingClock.

Đo lường các nhiệm vụ liên quan đến con người phía trước thiết bị phù hợp hơn với Đồng hồ liên tục.

Vì vậy, nếu bạn cần trì hoãn một khoảng thời gian tuyệt đối, một cái gì đó liên quan đến con người, hãy sử dụng ContinuousClock.

Gói Swift Async Algorithms sử dụng các loại Clock, Instant và Duration mới này để xây dựng các thuật toán chung để xử lý nhiều khái niệm về cách các sự kiện được xử lý liên quan đến thời gian.

Trong ứng dụng nhắn tin của chúng tôi, chúng tôi thấy những thứ này thực sự hữu ích để cung cấp quyền kiểm soát chính xác các sự kiện.

Nó cho phép chúng tôi đánh giá giới hạn các tương tác và các tin nhắn đệm hiệu quả.

Có lẽ lĩnh vực nổi bật nhất mà chúng tôi sử dụng thời gian là tìm kiếm tin nhắn.

Chúng tôi đã tạo ra một bộ điều khiển quản lý một kênh kết quả.

Kênh sắp xếp kết quả tìm kiếm từ nhiệm vụ tìm kiếm trở lại giao diện người dùng của chúng tôi.

Bản thân nhiệm vụ tìm kiếm cần phải có một số đặc điểm cụ thể liên quan đến thời gian.

Chúng tôi muốn đảm bảo giới hạn tốc độ tìm kiếm các tin nhắn đã gửi trên máy chủ.

Thuật toán Debounce đang chờ đợi một khoảng thời gian tĩnh lặng trước khi nó phát ra các giá trị tiếp theo khi lặp lại.

Điều đó có nghĩa là các sự kiện có thể đến nhanh chóng, nhưng chúng tôi muốn đảm bảo chờ đợi một khoảng thời gian yên tĩnh trước khi xử lý các giá trị.

Khi đầu vào của người dùng từ trường tìm kiếm được thay đổi nhanh chóng, chúng tôi không muốn bộ điều khiển tìm kiếm kích hoạt yêu cầu tìm kiếm cho mỗi thay đổi.

Thay vào đó, chúng tôi muốn đảm bảo đợi một khoảng thời gian yên tĩnh khi chúng tôi chắc chắn rằng việc đánh máy có thể sẽ được thực hiện.

Theo mặc định, thuật toán Debounce sẽ sử dụng ContinuousClock.

Trong trường hợp này, chúng ta có thể gỡ bỏ đầu vào sao cho nó chờ một khoảng thời gian xác định trong khi không có gì xảy ra.

Đồng hồ và thời lượng không chỉ được sử dụng để tháo rời mà còn được sử dụng cho các thuật toán khác.

Một lĩnh vực mà chúng tôi thấy thực sự hữu ích là gửi hàng loạt tin nhắn đến máy chủ.

Trong gói thuật toán Swift, có một tập hợp các thuật toán cho các giá trị khối.

Gói Swift Async Algorithms cung cấp những thứ đó, nhưng cũng thêm một tập hợp các phiên bản tương tác với đồng hồ và thời lượng.

Họ các thuật toán phân đoạn cho phép kiểm soát các khối theo số lượng, theo thời gian hoặc theo nội dung.

Nếu một lỗi xảy ra trong bất kỳ lỗi nào trong số này, lỗi đó sẽ được ném lại, vì vậy mã của chúng tôi an toàn khi xảy ra lỗi.

Chúng tôi đã sử dụng API "chunked(by:)" để đảm bảo rằng các đoạn tin nhắn được tuần tự hóa và gửi đi trong một khoảng thời gian nhất định đã trôi qua.

Bằng cách đó, máy chủ của chúng tôi nhận được các gói hiệu quả được gửi từ khách hàng.

Chúng tôi đã có thể sử dụng API này để xây dựng các lô tin nhắn cứ sau 500 mili giây.

Bằng cách đó, nếu ai đó thực sự hào hứng và gõ rất nhanh, các yêu cầu được gửi đến máy chủ sẽ được nhóm lại.

Khi làm việc với các bộ sưu tập và trình tự, nó thường hữu ích và hiệu quả để xử lý các yếu tố lười biếng.

AsyncSequence hoạt động giống như cách các thuật toán lười hoạt động trong thư viện tiêu chuẩn Swift.

Nhưng cũng giống như những thuật toán lười biếng đó, thường có những lúc bạn cần quay trở lại thế giới của các bộ sưu tập.

Gói Swift Async Algorithms cung cấp một tập hợp các trình khởi tạo để xây dựng các bộ sưu tập bằng AsyncSequence.

Những thứ này cho phép bạn xây dựng từ điển, tập hợp hoặc mảng với AsyncSequences đầu vào được biết là hữu hạn.

Các trình khởi tạo bộ sưu tập cho phép chúng tôi xây dựng các chuyển đổi ngay trong quá trình khởi tạo tin nhắn và giữ các loại dữ liệu của chúng tôi dưới dạng Mảng.

Điều này thực sự hữu ích vì chúng tôi có nhiều tính năng thực sự có thể sử dụng một số cập nhật để sử dụng Swift đồng thời.

Và bằng cách giữ các cấu trúc dữ liệu hiện có của chúng tôi, chúng tôi có thể di chuyển các phần của ứng dụng của mình từng bước và nơi nó có ý nghĩa.

Cho đến nay, chúng tôi chỉ xem qua một số điểm nổi bật của gói Swift Async Algorithms.

Có rất nhiều thứ hơn những gì chúng ta đã đề cập ngày hôm nay.

Chúng tôi có các thuật toán khác nhau, từ việc kết hợp nhiều AsyncSequences, giới hạn tốc độ theo thời gian, chia mọi thứ thành nhiều phần, nhưng đó chỉ là những điểm nổi bật mà cuối cùng chúng tôi đã sử dụng rộng rãi trong ứng dụng của mình.

Gói này có nhiều thứ hơn là chỉ những thứ đó.

Nó bao gồm từ đệm, giảm, nối, đến tiêm các giá trị không liên tục và hơn thế nữa.

Gói Swift Async Algorithms lấy tập hợp các thuật toán để xử lý mọi thứ theo thời gian và mở rộng nó thành một loạt các chức năng nâng cao có thể giúp bạn trong các ứng dụng của mình.

Hãy thử nó.

Chúng tôi thực sự hào hứng khi khám phá những gì bạn xây dựng với những thứ này và sự phấn khích đó được chia sẻ.

Gói này đang được phát triển công khai với bạn.

Cảm ơn vì đã xem, và tận hưởng phần còn lại của hội nghị.

♪ nhạc cụ hip hop ♪