10104

♪ nhạc cụ hip hop ♪

♪

Xin chào, tên tôi là Jaideep Joshi, và tôi là kỹ sư phần mềm GPU tại Apple.

Trong phiên này, tôi sẽ giới thiệu một tính năng mới trong Metal 3 sẽ đơn giản hóa và tối ưu hóa việc tải tài nguyên cho các trò chơi và ứng dụng của bạn.

Tôi sẽ bắt đầu bằng cách chỉ cho bạn cách tính năng tải tài nguyên nhanh có thể phù hợp với quy trình tải tài sản của ứng dụng của bạn.

Nó có một số tính năng chính khai thác các công nghệ lưu trữ mới trên các sản phẩm của Apple.

Tải tài nguyên nhanh có một số tính năng nâng cao giải quyết các tình huống thú vị mà ứng dụng của bạn có thể gặp phải.

Có một vài đề xuất thực hành tốt nhất mà bạn nên biết sẽ giúp bạn sử dụng hiệu quả các tính năng này trong ứng dụng của mình.

Khi bạn thêm tải tài nguyên nhanh vào ứng dụng của mình, các công cụ như Metal System Trace và trình gỡ lỗi GPU có thể giúp lập hồ sơ và khắc phục các sự cố mà bạn có thể gặp phải.

Cuối cùng, tôi sẽ xem qua một ví dụ cho thấy việc tải tài nguyên nhanh đang hoạt động.

Vì vậy, đây là những gì bạn có thể làm với việc tải tài nguyên nhanh của Metal 3.

Với khả năng tải tài nguyên nhanh của Metal 3, các trò chơi và ứng dụng của bạn có thể tải tài sản với độ trễ thấp và thông lượng cao bằng cách tận dụng kiến trúc bộ nhớ hợp nhất silicon của Apple và bộ nhớ SSD nhanh đi kèm với nền tảng của Apple.

Bạn sẽ học được những cách tốt nhất để truyền dữ liệu và giảm thời gian tải để đảm bảo rằng nội dung trò chơi của bạn đã sẵn sàng đúng hạn.

Một khía cạnh quan trọng của việc giảm thời gian tải là chỉ tải những gì bạn cần ở độ chi tiết nhỏ nhất có thể.

Thông lượng cao và độ trễ thấp trong Metal 3 cho phép các ứng dụng của bạn phát trực tuyến các nội dung chất lượng cao hơn, bao gồm kết cấu, âm thanh và dữ liệu hình học.

Bây giờ tôi sẽ hướng dẫn bạn một ví dụ về tải tài sản trong một trò chơi.

Các trò chơi thường hiển thị màn hình tải khi chúng khởi động lần đầu tiên hoặc khi bắt đầu một cấp độ mới, vì vậy chúng có thể tải nội dung của trò chơi vào bộ nhớ.

Khi người chơi di chuyển qua cấp độ, trò chơi sẽ tải thêm tài sản cho cảnh.

Nhược điểm là người chơi phải đợi một thời gian dài trong khi trò chơi thực hiện nhiều yêu cầu đến hệ thống lưu trữ để tải tài sản trước.

Thêm vào đó, những tài sản đó có thể có một dấu chân bộ nhớ lớn.

Có một vài cách để cải thiện trải nghiệm này.

Các trò chơi có thể cải thiện trải nghiệm này bằng cách tự động phát trực tuyến các đối tượng khi người chơi đến gần chúng hơn.

Bằng cách này, trò chơi chỉ tải những gì nó cần lúc đầu và dần dần phát trực tuyến các tài nguyên khác khi người chơi di chuyển qua cấp độ.

Ví dụ, trò chơi ban đầu tải bảng đen này ở độ phân giải thấp hơn, nhưng khi người chơi đi về phía nó, trò chơi sẽ tải phiên bản có độ phân giải cao hơn.

Cách tiếp cận này làm giảm thời gian người chơi chờ đợi ở màn hình tải.

Tuy nhiên, người chơi vẫn có thể nhìn thấy các vật phẩm có độ phân giải thấp hơn trong cảnh ngay cả khi chúng ở gần, vì mất quá nhiều thời gian để tải các phiên bản có độ phân giải cao hơn.

Một cách để giải quyết vấn đề này là phát trực tuyến các phần nhỏ hơn của mỗi tài sản.

Ví dụ, trò chơi của bạn chỉ có thể tải các vùng có thể nhìn thấy của cảnh với kết cấu thưa thớt truyền các ô thay vì toàn bộ cấp độ mip.

Điều này làm giảm đáng kể lượng dữ liệu mà ứng dụng của bạn cần phát trực tuyến.

Với cách tiếp cận đó, các yêu cầu tải trở nên nhỏ hơn và có nhiều yêu cầu hơn.

Nhưng không sao, bởi vì phần cứng lưu trữ hiện đại có thể chạy nhiều yêu cầu tải cùng một lúc.

Điều này có nghĩa là bạn có thể tăng độ phân giải và quy mô cảnh của mình mà không ảnh hưởng đến lối chơi.

Cùng với việc đưa ra một số lượng lớn các yêu cầu tải nhỏ, bạn cũng có khả năng ưu tiên các yêu cầu tải của mình, để đảm bảo rằng các yêu cầu ưu tiên cao kết thúc kịp thời.

Bây giờ tôi đã đề cập đến các cách để tăng độ trung thực trực quan của trò chơi trong khi giảm thời gian tải, tôi sẽ chỉ cho bạn cách tải tài nguyên nhanh của Metal 3 giúp bạn làm điều này.

Tải tài nguyên nhanh là một API không đồng bộ tải tài nguyên từ bộ nhớ.

Không giống như các API tải hiện có, luồng phát hành tải không cần phải đợi tải kết thúc.

Các hoạt động tải thực hiện đồng thời để sử dụng tốt hơn thông lượng lưu trữ nhanh hơn.

Bạn có thể tải hàng loạt các hoạt động để giảm thiểu hơn nữa chi phí tải tài nguyên.

Và cuối cùng, với Metal 3, bạn có thể ưu tiên các hoạt động tải để có độ trễ thấp hơn.

Bây giờ tôi sẽ chỉ cho bạn các tính năng chính sẽ giúp bạn xây dựng quy trình tải tài sản của mình, bắt đầu với các bước để tải tài nguyên.

Có ba bước để tải tài nguyên: mở tệp, đưa ra các lệnh tải cần thiết và sau đó đồng bộ hóa các lệnh tải này với công việc kết xuất.

Đây là cách bạn làm điều đó, bắt đầu bằng việc mở một tệp.

Bạn mở một tệp hiện có bằng cách tạo một trình xử lý tệp với phiên bản thiết bị Metal.

Ví dụ, mã này sử dụng phiên bản thiết bị Metal để tạo trình xử lý tệp bằng cách gọi phương thức makeIOHandle mới của nó với URL đường dẫn tệp.

Khi bạn có một trình xử lý tệp, bạn có thể sử dụng nó để đưa ra các lệnh tải.

Đây là một kịch bản điển hình trong một ứng dụng, nơi nó thực hiện các hoạt động tải và mã hóa công việc GPU.

Với các API tải hiện có, ứng dụng phải đợi công việc tải kết thúc trước khi nó có thể mã hóa công việc kết xuất.

Metal 3 cho phép ứng dụng của bạn thực hiện không đồng bộ các lệnh tải.

Bắt đầu bằng cách tạo một hàng đợi lệnh Metal IO.

Sau đó sử dụng hàng đợi đó để tạo bộ đệm lệnh IO và mã hóa các lệnh tải cho các bộ đệm đó.

Tuy nhiên, vì bộ đệm lệnh thực thi không đồng bộ trên hàng đợi lệnh, ứng dụng của bạn không cần phải đợi các thao tác tải kết thúc.

Trên thực tế, không chỉ tất cả các lệnh trong bộ đệm lệnh IO thực hiện đồng thời, các bộ đệm lệnh IO tự thực thi đồng thời và hoàn thành không theo thứ tự.

Mô hình thực thi đồng thời này sử dụng tốt hơn phần cứng lưu trữ nhanh hơn bằng cách tối đa hóa thông lượng.

Bạn có thể mã hóa ba loại lệnh IO thành bộ đệm lệnh: loadTexture, tải vào kết cấu Metal để phát trực tuyến kết cấu; loadBuffer, tải vào bộ đệm Metal để phát trực tuyến cảnh hoặc dữ liệu hình học; và loadBytes, tải vào bộ nhớ có thể truy cập CPU.

Bạn tạo bộ đệm lệnh IO từ hàng đợi lệnh IO.

Để tạo một hàng đợi, trước tiên hãy tạo và định cấu hình một bộ mô tả hàng đợi lệnh IO.

Theo mặc định, các hàng đợi là đồng thời, nhưng bạn cũng có thể đặt chúng để chạy bộ đệm lệnh tuần tự và hoàn toàn theo thứ tự.

Sau đó chuyển bộ mô tả hàng đợi cho phương thức makeIOCommandQueue của phiên bản thiết bị Metal.

Tạo bộ đệm lệnh IO bằng cách gọi phương thức makeCommandBuffer của hàng đợi lệnh.

Sau đó sử dụng bộ đệm lệnh đó để mã hóa các lệnh tải tải kết cấu và bộ đệm.

Lớp xác thực của Metal sẽ bắt lỗi mã hóa trong thời gian chạy.

Các lệnh tải là những gì sử dụng phiên bản fileHandle được tạo trước đó.

Khi bạn hoàn tất việc thêm các lệnh tải vào bộ đệm lệnh, hãy gửi nó vào hàng đợi để thực thi bằng cách gọi phương thức cam kết của bộ đệm lệnh.

Bây giờ tôi đã đề cập đến cách tạo hàng đợi lệnh IO, bộ đệm lệnh, phát hành lệnh tải và gửi chúng vào hàng đợi, tôi muốn chỉ cho bạn cách bạn có thể đồng bộ hóa công việc tải với công việc GPU khác.

Một ứng dụng thường bắt đầu công việc kết xuất sau khi hoàn thành việc tải tài nguyên cho kết xuất đó.

Nhưng một ứng dụng sử dụng tải tài nguyên nhanh cần một cách để đồng bộ hóa hàng đợi lệnh IO với hàng đợi lệnh kết xuất.

Bạn có thể đồng bộ hóa các hàng đợi này với một sự kiện được chia sẻ Metal.

Các sự kiện hared kim loại cho phép bạn đồng bộ đệm lệnh từ hàng đợi IO của mình với bộ đệm lệnh từ hàng đợi kết xuất của bạn.

Bạn có thể yêu cầu bộ đệm lệnh chờ sự kiện được chia sẻ bằng cách mã hóa lệnh waitEvent.

Tương tự, bạn có thể yêu cầu bộ đệm lệnh đó báo hiệu một sự kiện được chia sẻ bằng cách mã hóa lệnh signalEvent.

Metal đảm bảo rằng tất cả các lệnh IO trong bộ đệm lệnh đã hoàn tất trước khi nó báo hiệu sự kiện được chia sẻ.

Để đồng bộ hóa giữa các bộ đệm lệnh, trước tiên bạn cần một sự kiện được chia sẻ Metal.

Bạn có thể yêu cầu bộ đệm lệnh chờ một sự kiện được chia sẻ bằng cách gọi phương thức waitForEvent của nó.

Tương tự, bạn có thể yêu cầu bộ đệm lệnh báo hiệu một sự kiện được chia sẻ bằng cách gọi phương thức signalEvent của nó.

Bạn có thể thêm logic tương tự vào bộ đệm lệnh GPU tương ứng để nó chờ bộ đệm lệnh IO báo hiệu cùng một sự kiện được chia sẻ.

Tóm lại, đây là các tính năng chính và API tải tài nguyên trong các ứng dụng Metal của bạn.

Mở một tệp bằng cách tạo một tay cầm tệp Metal.

Phát hành các lệnh tải bằng cách tạo hàng đợi lệnh IO và bộ đệm lệnh IO.

Sau đó, mã hóa các lệnh tải thành bộ đệm lệnh để thực thi trên hàng đợi.

Và cuối cùng, sử dụng các lệnh wait và signalEvent với các sự kiện được chia sẻ Metal để đồng bộ hóa việc tải và kết xuất.

Bây giờ, tôi sẽ xem xét một vài tính năng nâng cao mà bạn có thể thấy hữu ích.

Đây là một kịch bản điển hình mà một trò chơi không thể đặt toàn bộ bản đồ của nó vào bộ nhớ, đó là lý do tại sao nó chia nhỏ bản đồ thành các khu vực.

Khi người chơi tiến bộ qua bản đồ, trò chơi bắt đầu tải trước các khu vực của bản đồ.

Dựa trên hướng của người chơi, trò chơi xác định rằng các khu vực tốt nhất để tải trước là các khu vực tây bắc, tây và tây nam.

Tuy nhiên, một khi người chơi di chuyển đến khu vực phía tây và bắt đầu đi về phía nam, việc tải trước khu vực phía tây bắc không còn có lợi nữa.

Để giảm độ trễ của tải trong tương lai, Metal 3 cho phép bạn cố gắng hủy hoạt động tải.

Hãy xem làm thế nào để làm điều đó trong thực tế.

Khi người chơi ở khu vực trung tâm, hãy mã hóa và cam kết bộ đệm lệnh IO cho ba khu vực.

Sau đó, khi người chơi ở khu vực phía tây và đi về phía nam, hãy sử dụng phương pháp tryCancel để hủy tải cho khu vực phía tây bắc.

Việc hủy bỏ ở độ chi tiết bộ đệm lệnh, vì vậy bạn có thể hủy bộ đệm lệnh giữa quá trình thực thi.

Nếu tại một thời điểm nào đó sau đó, bạn muốn biết liệu khu vực đã được tải đầy đủ hay chưa, bạn có thể kiểm tra trạng thái của bộ đệm lệnh.

Metal 3 cũng cho phép bạn ưu tiên công việc IO của mình.

Hãy xem xét một kịch bản trò chơi trong đó người chơi dịch chuyển tức thời đến một phần mới của cảnh và trò chơi của bạn bắt đầu phát trực tuyến với số lượng lớn tài sản đồ họa.

Đồng thời, trò chơi cần chơi hiệu ứng âm thanh dịch chuyển tức thời.

Tải tài nguyên nhanh cho phép bạn tải tất cả tài sản của ứng dụng, bao gồm cả dữ liệu âm thanh.

Để tải âm thanh, bạn có thể sử dụng lệnh loadBytes đã thảo luận trước đó để tải vào bộ nhớ được phân bổ cho ứng dụng.

Trong ví dụ này, bộ đệm lệnh IO kết cấu và âm thanh được thực thi đồng thời trên một hàng đợi lệnh IO duy nhất.

Sơ đồ đơn giản này cho thấy các yêu cầu ở lớp lưu trữ.

Hệ thống lưu trữ có thể thực hiện song song cả yêu cầu tải âm thanh và kết cấu.

Để tránh âm thanh bị trì hoãn, điều quan trọng là hệ thống phát trực tuyến có thể ưu tiên các yêu cầu âm thanh hơn các yêu cầu kết cấu.

Để ưu tiên các yêu cầu âm thanh, bạn có thể tạo một hàng đợi lệnh IO riêng biệt và đặt mức độ ưu tiên của nó ở mức cao.

Hệ thống lưu trữ sẽ đảm bảo rằng các yêu cầu IO ưu tiên cao có độ trễ thấp hơn và được ưu tiên hơn các yêu cầu khác.

Sau khi tạo một hàng đợi ưu tiên cao riêng biệt cho các tài sản âm thanh, thời gian thực hiện các yêu cầu tải âm thanh đã nhỏ hơn, trong khi thời gian thực hiện các yêu cầu tải kết cấu song song ngày càng lớn hơn.

Đây là cách bạn tạo một hàng đợi ưu tiên cao.

Chỉ cần đặt thuộc tính ưu tiên của bộ mô tả hàng đợi lệnh ở mức cao.

Bạn cũng có thể đặt mức độ ưu tiên thành bình thường hoặc thấp, sau đó tạo một hàng đợi lệnh IO mới từ bộ mô tả như bình thường.

Chỉ cần nhớ rằng bạn không thể thay đổi mức độ ưu tiên của hàng đợi sau khi bạn tạo nó.

Khi bạn thêm tải tài nguyên nhanh vào ứng dụng của mình, đây là một số phương pháp hay nhất cần ghi nhớ.

Đầu tiên, hãy cân nhắc việc nén tài sản của bạn.

Bạn có thể giảm dung lượng đĩa của ứng dụng bằng cách sử dụng tính năng nén tích hợp hoặc tùy chỉnh.

Nén cho phép bạn đánh đổi hiệu suất thời gian chạy lấy dấu chân đĩa nhỏ hơn.

Ngoài ra, bạn có thể cải thiện thông lượng lưu trữ bằng cách điều chỉnh kích thước trang thưa thớt khi sử dụng kết cấu thưa thớt.

Tôi sẽ xem xét từng thứ này chi tiết hơn, bắt đầu bằng việc nén.

Bạn có thể sử dụng API của Metals 3 để nén các tệp tài sản của mình ngoại tuyến.

Đầu tiên, tạo một ngữ cảnh nén và cấu hình nó với kích thước đoạn và phương pháp nén.

Sau đó chuyển các phần của tệp nội dung của bạn vào ngữ cảnh để tạo ra một phiên bản nén duy nhất của tất cả các tệp của bạn.

Bối cảnh nén hoạt động bằng cách phân đoạn tất cả dữ liệu và nén nó bằng codec bạn chọn và lưu trữ nó vào một tệp gói.

Trong ví dụ này, ngữ cảnh nén dữ liệu thành các đoạn 64K, nhưng bạn có thể chọn kích thước đoạn phù hợp dựa trên kích thước và loại dữ liệu bạn muốn nén.

Đây là cách bạn sử dụng API nén trong Metal 3.

Đầu tiên, tạo một ngữ cảnh nén bằng cách cung cấp một đường dẫn để tạo tệp nén, một phương pháp nén và kích thước đoạn.

Tiếp theo, lấy dữ liệu tệp và thêm nó vào ngữ cảnh.

Ở đây, dữ liệu tệp nằm trong một đối tượng NSData.

Bạn có thể nối thêm dữ liệu từ các tệp khác nhau bằng cách thực hiện nhiều cuộc gọi để nối thêm dữ liệu.

Khi bạn thêm dữ liệu xong, hãy hoàn thiện và lưu tệp nén bằng cách gọi chức năng ngữ cảnh nén tuôn ra và phá hủy.

Bạn có thể mở và truy cập tệp nén bằng cách tạo một trình xử lý tệp.

Trình xử lý tệp này được sử dụng khi đưa ra các lệnh tải.

Đối với các tệp nén, Metal 3 thực hiện giải nén nội tuyến, bằng cách dịch các phần bù thành danh sách các khối cần giải nén và tải chúng vào tài nguyên của bạn.

Bạn tạo một trình xử lý tệp với một phiên bản thiết bị Metal.

Ví dụ, mã này sử dụng phiên bản thiết bị Metal để tạo trình xử lý tệp bằng cách cung cấp đường dẫn tệp nén cho phương thức makeIOHandle mà tôi đã đề cập trước đó.

Đối với các tệp nén, một tham số bổ sung là phương pháp nén.

Đây là cùng một phương pháp nén mà bạn đã sử dụng tại thời điểm tạo tệp nén.

Bây giờ, tôi sẽ xem xét các phương pháp nén khác nhau được hỗ trợ và các đặc điểm của từng phương pháp, vì vậy bạn có thể hiểu rõ hơn về cách chọn giữa chúng.

Sử dụng LZ4 khi tốc độ giải nén là rất quan trọng và ứng dụng của bạn có thể đủ dung lượng đĩa lớn.

Nếu sự cân bằng giữa tốc độ codec và tỷ lệ nén quan trọng đối với bạn, hãy sử dụng ZLib, LZBitmap hoặc LZFSE.

Trong số các codec cân bằng, ZLib hoạt động tốt hơn với các thiết bị không phải của Apple.

LZBitmap mã hóa và giải mã nhanh, và LZFSE có tỷ lệ nén cao.

Nếu bạn cần tỷ lệ nén tốt nhất, hãy cân nhắc sử dụng codec LZMA, nếu ứng dụng của bạn có thể đủ khả năng thêm thời gian để giải mã tài sản.

Cũng có thể sử dụng sơ đồ nén của riêng bạn.

Bạn có thể có những trường hợp mà dữ liệu của bạn được hưởng lợi từ một codec nén tùy chỉnh.

Trong trường hợp đó, bạn có thể thay thế ngữ cảnh nén bằng máy nén của riêng mình và dịch các phần bù và tự mình thực hiện giải nén trong thời gian chạy.

Bây giờ bạn đã thấy cách sử dụng nén để giảm dấu chân đĩa, hãy xem xét điều chỉnh kích thước trang thưa thớt.

Các phiên bản trước của Metal hỗ trợ tải gạch đến kết cấu thưa thớt ở độ chi tiết 16K.

Với Metal 3, bạn có thể chỉ định hai kích thước gạch thưa thớt mới: 64 và 256K.

Những kích thước mới này cho phép bạn truyền phát kết cấu ở độ chi tiết lớn hơn để sử dụng tốt hơn và bão hòa phần cứng lưu trữ.

Lưu ý rằng có sự cân bằng giữa việc phát trực tuyến các kích thước ô lớn hơn và lượng dữ liệu bạn phát trực tuyến, vì vậy bạn sẽ phải thử nghiệm để xem kích thước nào hoạt động tốt nhất với ứng dụng của mình và kết cấu thưa thớt của nó.

Tiếp theo, hãy xem cách bạn có thể sử dụng bộ Công cụ Nhà phát triển Kim loại để lập hồ sơ và gỡ lỗi tải tài nguyên nhanh trong ứng dụng của mình.

Xcode 14 bao gồm hỗ trợ đầy đủ cho việc tải tài nguyên nhanh chóng.

Từ hồ sơ thời gian chạy với Metal System Trace đến kiểm tra API và phân tích phụ thuộc nâng cao với trình gỡ lỗi Metal.

Hãy bắt đầu với hồ sơ thời gian chạy.

Trong Xcode 14, Instruments có thể lập hồ sơ tải tài nguyên nhanh chóng với mẫu Metal System Trace.

Instruments là một công cụ phân tích và lập hồ sơ mạnh mẽ sẽ giúp bạn đạt được hiệu suất tốt nhất trong ứng dụng Metal của mình.

Mẫu Metal System Trace cho phép bạn kiểm tra khi nào các hoạt động tải được mã hóa và thực thi.

Bạn sẽ có thể hiểu cách chúng tương quan với hoạt động mà ứng dụng của bạn đang thực hiện trên cả CPU và GPU.

Để tìm hiểu cách lập hồ sơ ứng dụng Metal của bạn với Instruments, vui lòng xem các phiên trước, "Tối ưu hóa ứng dụng và trò chơi Metal với bộ đếm GPU" và "Tối ưu hóa các trò chơi cao cấp cho GPU của Apple."

Bây giờ, hãy chuyển bánh răng sang gỡ lỗi.

Với trình gỡ lỗi Metal trong Xcode 14, giờ đây bạn có thể phân tích việc sử dụng API tải tài nguyên nhanh mới trong trò chơi của mình.

Khi bạn chụp khung hình, bạn sẽ có thể kiểm tra tất cả các lệnh gọi API tải tài nguyên nhanh.

Từ bộ đệm lệnh IO được tạo đến các hoạt động tải đã được phát hành.

Bây giờ bạn có thể kiểm tra trực quan các phụ thuộc tải tài nguyên nhanh với trình xem Phụ thuộc mới.

Trình xem Phụ thuộc cung cấp tổng quan chi tiết về sự phụ thuộc tài nguyên giữa bộ đệm lệnh IO và thẻ Metal.

Từ đây, bạn có thể sử dụng tất cả các tính năng trong trình xem Phụ thuộc mới, chẳng hạn như các cạnh đồng bộ hóa mới và lọc đồ thị, để tìm hiểu sâu và tối ưu hóa các phụ thuộc tải tài nguyên của bạn.

Để tìm hiểu thêm về trình xem Dependency mới trong Xcode 14, vui lòng xem phiên "Go bindless with Metal 3" năm nay.

Bây giờ, hãy xem xét việc tải tài nguyên nhanh đang hoạt động.

Đây là một cảnh thử nghiệm sử dụng các API tải tài nguyên nhanh mới để truyền dữ liệu kết cấu bằng cách sử dụng các kết cấu thưa thớt với kích thước ô 16 kilobyte.

Video này là từ MacBook Pro với chip M1 Pro.

Hệ thống phát trực tuyến truy vấn các bộ đếm truy cập kết cấu thưa thớt của GPU để xác định hai thứ: các ô mà nó đã lấy mẫu nhưng không tải và các ô đã tải mà ứng dụng không sử dụng.

Ứng dụng sử dụng thông tin này để mã hóa danh sách tải cho các ô mà nó cần và danh sách các lần trục xuất cho các ô mà nó không cần.

Bằng cách đó, bộ làm việc chỉ chứa các ô mà ứng dụng hầu như có khả năng sử dụng.

Nếu người chơi quyết định di chuyển đến một phần khác của cảnh, ứng dụng cần phát trực tuyến trong một bộ kết cấu độ phân giải cao hoàn toàn mới.

Nếu hệ thống phát trực tuyến đủ nhanh, người chơi sẽ không nhận thấy việc phát trực tuyến này xảy ra.

Nếu tôi tạm dừng cảnh, bạn có thể quan sát sự khác biệt của hình ảnh rõ ràng hơn.

Phía bên trái đang tải các ô thưa thớt trên một luồng duy nhất bằng API pread.

Phía bên phải đang tải các ô thưa thớt bằng cách sử dụng API tải tài nguyên nhanh.

Khi người chơi bước vào cảnh, hầu hết các kết cấu chưa được tải đầy đủ.

Sau khi tải xong, phiên bản có độ phân giải cao cuối cùng của kết cấu sẽ hiển thị.

Nếu tôi quay lại phần đầu của cảnh này và làm chậm nó, sẽ dễ dàng nhận thấy những cải tiến mà việc tải tài nguyên nhanh cung cấp.

Để làm nổi bật sự khác biệt, kết xuất này đánh dấu các ô mà ứng dụng chưa tải với tông màu đỏ.

Lúc đầu, cảnh cho thấy ứng dụng chưa tải hầu hết các ô.

Tuy nhiên, khi người chơi bước vào cảnh, tải tài nguyên nhanh sẽ cải thiện việc tải các ô có độ phân giải cao và giảm thiểu độ trễ so với phiên bản pread đơn luồng.

Tải tài nguyên nhanh của Metal 3 giúp bạn xây dựng một hệ thống phân luồng tài sản mạnh mẽ và hiệu quả cho phép ứng dụng của bạn tận dụng các công nghệ lưu trữ mới nhất.

Sử dụng nó để giảm thời gian tải bằng cách phát trực tuyến nội dung kịp thời, bao gồm cả hình ảnh chất lượng cao hơn.

Sử dụng các sự kiện được chia sẻ của Metal để tải tài sản không đồng bộ trong khi GPU hiển thị cảnh.

Đối với các tài sản mà ứng dụng của bạn cần vội vàng, hãy giảm thiểu độ trễ bằng cách tạo hàng đợi lệnh với mức độ ưu tiên cao hơn.

Và hãy nhớ rằng, giữ cho hệ thống lưu trữ bận rộn bằng cách gửi lệnh tải sớm.

Bạn luôn có thể hủy những thứ bạn không cần.

Tải tài nguyên nhanh trong Metal 3 giới thiệu những cách mới để khai thác sức mạnh của phần cứng lưu trữ hiện đại để tải tài sản thông lượng cao.

Tôi nóng lòng muốn xem cách bạn sử dụng các tính năng này để cải thiện chất lượng hình ảnh và khả năng phản hồi của ứng dụng.

Cảm ơn vì đã xem.

♪