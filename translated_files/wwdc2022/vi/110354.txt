110354

♪ Nhạc hip-hop nhạc cụ êm dịu ♪

♪

Xin chào, tôi là Angela.

Và tôi là Becca.

Chào mừng đến với những gì mới trong Swift!

Chúng tôi thực sự vui mừng được nói chuyện với bạn hôm nay về tất cả các tính năng mới tuyệt vời trong Swift 5.7.

Nhiều điều chúng ta sẽ nói hôm nay chứng minh mục tiêu của Swift là giúp cuộc sống của bạn với tư cách là một nhà phát triển dễ dàng hơn.

Chúng tôi sẽ xem xét công cụ mới để giúp bạn tùy chỉnh quy trình làm việc của mình và một số cải tiến tuyệt vời dưới mui xe.

Sau đó, chúng ta sẽ nói về mô hình đồng thời mới nhất của Swift và con đường đến Swift 6, bao gồm cả sự an toàn toàn luồng.

Sau đó, tôi sẽ kết thúc bằng cách đưa bạn qua một số cải tiến ngôn ngữ giúp Swift dễ đọc và viết hơn, bao gồm các loại thuốc generic sạch hơn, đơn giản hơn và các phương tiện xử lý chuỗi mới mạnh mẽ.

Nhưng trước tiên, hãy bắt đầu bằng cách nói về một trong những điều khiến Swift trở nên đặc biệt - tất cả các bạn.

Đầu vào và đóng góp của bạn là những gì đã cho phép Swift mở rộng nhanh chóng.

Sự tham gia của cộng đồng là cốt lõi của Swift.

Năm nay, nhiều dự án Swift đã có sẵn cho cộng đồng khi docC - công cụ tạo tài liệu được công bố vào năm ngoái - và trang web Swift.org có nguồn mở.

Nguồn mở hoạt động tốt nhất khi bạn có một cộng đồng tích cực hướng dẫn nó.

Chúng tôi đã sử dụng mô hình nhóm làm việc cho Swift trên Máy chủ và Đa dạng trong Swift để cung cấp sự quản lý và hỗ trợ cho các thành viên cộng đồng quan tâm đến các lĩnh vực cụ thể.

Điều này đã hoạt động rất tốt nên chúng tôi đã bắt đầu hai nhóm làm việc mới.

Một cho việc lặp lại trên trang web Swift và làm cho nó trở thành tài nguyên cộng đồng nhiều hơn, và một cho khả năng tương tác C++, để định hình thiết kế của mô hình giữa C++ và Swift.

Khi chúng tôi mạo hiểm vào các lĩnh vực mới, tất cả chúng tôi đều cần sự hỗ trợ từ các thành viên trong cộng đồng.

Là một phần của điều đó, nhóm làm việc Đa dạng trong Swift đã giới thiệu Chương trình Cố vấn Swift vào năm ngoái.

Chương trình cung cấp các lộ trình để đóng góp cho tất cả các lĩnh vực nhóm làm việc cho những người không biết cách bắt đầu hoặc đang tìm cách đào sâu chuyên môn của họ trong một lĩnh vực cụ thể.

Chương trình năm ngoái là một thành công lớn.

Có rất nhiều người được cố vấn quan tâm; và cùng với điều đó, chúng tôi đã có thể tạo ra 41 cặp cố vấn.

Thành công này là lý do tại sao chương trình được đưa trở lại trong năm thứ hai.

Chương trình rất muốn bao gồm tất cả những người quan tâm; nhưng để làm điều đó, chúng tôi cần bạn - những nhà phát triển hào hứng và có kinh nghiệm đang lắng nghe, những người sẵn sàng chia sẻ bề rộng kiến thức của họ và tạo ra các kết nối mới.

Bởi vì chương trình cố vấn không chỉ là về quy tắc mà còn về việc xây dựng các mối quan hệ trong cộng đồng.

Và một chút hướng dẫn có thể có tác dụng lâu dài.

Đừng chỉ tin lời tôi.

Năm ngoái, Amrit đã tham gia vào chương trình cố vấn và tập trung vào trình biên dịch và thiết kế ngôn ngữ.

Những gì bắt đầu như một âm mưu cho Amrit đã biến thành những đóng góp hữu hình.

Đi sâu vào một miền mới không hề dễ dàng.

Mặc dù vậy, cô ấy đã bỏ đi để tìm kiếm thành công và cảm thấy được truyền cảm hứng để đóng góp nhiều hơn.

Giống như nhiều người khác, trải nghiệm này đã mở ra cánh cửa cho Amrit.

Ngoài trình biên dịch và thiết kế ngôn ngữ, năm ngoái có một loạt các lĩnh vực trọng tâm có sẵn, từ viết và thử nghiệm kỹ thuật đến đóng góp cho các gói Swift.

Năm nay, chúng tôi đang bổ sung nhiều hơn nữa và luôn có cơ hội cho các chủ đề mới.

Nếu bạn không thấy điều gì đó trong danh sách này mà bạn quan tâm, bạn vẫn có thể đề cập đến nó trong đơn đăng ký của mình.

Một bổ sung khác là chương trình năm nay sẽ cung cấp tư vấn quanh năm cho các đóng góp lỗi khởi đầu để giúp phù hợp với bất kỳ ai có thể có năng lực tham gia thấp hơn nhưng vẫn hào hứng tham gia.

Nếu bạn quan tâm đến việc đăng ký hoặc chỉ muốn nghe thêm, hãy xem bài đăng trên blog Swift gần đây nhất.

Ở đó, bạn có thể tìm thấy các liên kết đến các phản ánh chi tiết từ những người được cố vấn được đánh dấu.

Chương trình cố vấn chỉ là một sáng kiến dưới sự đa dạng trong sự bảo trợ của Swift.

Để tìm hiểu thêm về chương trình cố vấn và các nỗ lực Đa dạng trong Swift khác, bạn có thể truy cập Swift.org/diversity.

Để mở cánh cửa xa hơn nữa, chúng tôi muốn làm cho việc sử dụng Swift với các tài nguyên bạn có trở nên dễ dàng nhất có thể!

Chúng tôi đã sắp xếp hợp lý quy trình phân phối chuỗi công cụ Swift cho nền tảng Linux bằng cách thêm hỗ trợ cho các định dạng gói Linux.

Với trình cài đặt chuỗi công cụ gốc mới, giờ đây bạn có thể tải xuống RPM cho Amazon Linux 2 và CentOS 7 trực tiếp từ Swift.org.

Các chuỗi công cụ này là thử nghiệm, vì vậy hãy chắc chắn chia sẻ phản hồi trên diễn đàn Swift.org.

Swift chủ yếu được sử dụng để xây dựng ứng dụng.

Tuy nhiên, tầm nhìn luôn là Swift có thể mở rộng - được sử dụng từ mọi thứ từ các tập lệnh cấp cao đến môi trường kim loại trần.

Để khuyến khích Swift được sử dụng ở nơi nó chưa từng được sử dụng trước đây, Swift đã trải qua một số thay đổi lớn trong năm nay.

Để làm cho thư viện tiêu chuẩn nhỏ hơn cho các tệp nhị phân độc lập, được liên kết tĩnh, chúng tôi đã bỏ sự phụ thuộc vào thư viện hỗ trợ Unicode bên ngoài, thay thế nó bằng triển khai gốc nhanh hơn.

Các tệp nhị phân nhỏ hơn, nhanh hơn là một lợi ích to lớn khi chạy trên các giải pháp máy chủ theo sự kiện.

Bạn nhận được liên kết tĩnh trên Linux theo mặc định để hỗ trợ tốt hơn việc triển khai containerized cho máy chủ.

Việc giảm kích thước này làm cho Swift phù hợp với cả những môi trường bị hạn chế, điều này cho phép chúng tôi sử dụng nó trong Bộ xử lý Secure Enclave của Apple.

Swift rất hữu ích từ các ứng dụng đến máy chủ cho đến các bộ xử lý bị hạn chế; gắn tất cả lại với nhau là hệ sinh thái gói.

Các tính năng mới của năm nay trong các gói Swift sẽ giúp cuộc sống của bạn tốt hơn.

Để bắt đầu, Swift Package Manager đã giới thiệu TOFU.

Không, không phải món ăn nhẹ ngon miệng.

TOFU là từ viết tắt của Trust On First Use.

Đó là một giao thức bảo mật mới, nơi dấu vân tay của gói hiện đang được ghi lại khi gói được tải xuống lần đầu tiên.

Các lần tải xuống tiếp theo sẽ xác thực dấu vân tay này và báo cáo lỗi nếu dấu vân tay khác nhau.

Đây chỉ là một ví dụ về cách niềm tin và bảo mật được tích hợp vào cốt lõi của hệ sinh thái gói để giúp bạn cảm thấy tự tin khi sử dụng nó.

Trình cắm lệnh là một cách tuyệt vời để cải thiện quy trình làm việc cho các nhà phát triển Swift.

Chúng là bước đầu tiên trong việc cung cấp các công cụ xây dựng có thể mở rộng và an toàn hơn.

Các trình cắm lệnh có thể được sử dụng để tạo tài liệu, định dạng lại mã nguồn và hơn thế nữa.

Thay vì viết tự động hóa của bạn trong một tập lệnh shell và phải duy trì quy trình làm việc riêng biệt, bạn có thể sử dụng Swift!

Hãy nghĩ đến các nhà định dạng mã nguồn mở và linters.

Bây giờ, tất cả các công cụ mã nguồn mở đó đều có sẵn trong Xcode và Swift Package Manager.

Các trình cắm lệnh là chất kết dính giữa các công cụ nguồn mở và Trình quản lý gói Swift.

Dự án Swift đang áp dụng các công cụ dành cho nhà phát triển trong cộng đồng nguồn mở để cung cấp sự tích hợp liền mạch với quy trình làm việc tự động của bạn.

docC là công cụ tuyệt vời để tích hợp tài liệu vào mã nguồn của bạn.

Năm nay, nó thậm chí còn tốt hơn với sự hỗ trợ của Objective-C và C.

Chúng ta hãy xem những gì cần thiết để tạo một plug-in với docC.

Các trình cắm chỉ là mã Swift đơn giản.

Bạn có thể xác định một plug-in bằng cách tạo một cấu trúc phù hợp với giao thức CommandPlugin.

Và sau đó bạn chỉ cần thêm một chức năng cho trình cắm của bạn biết bạn muốn gọi công cụ nào.

Trong hàm này là nơi chúng tôi muốn gọi docC.

Khi bạn đã xác định trình cắm của mình, nó sẽ có sẵn thông qua giao diện dòng lệnh Swift PM và Xcode dưới dạng mục nhập menu.

Bây giờ, chúng tôi có thể yêu cầu Swift PM tạo tài liệu và nó biết chuyển hành động này đến tệp thực thi docC.

Nó không dừng lại ở đó.

Có một trình cắm thứ hai được gọi là trình cắm công cụ xây dựng.

Các trình cắm này là các gói cho phép bạn tiêm các bước bổ sung trong quá trình xây dựng.

Khi bạn triển khai một trình cắm công cụ xây dựng, điều đó sẽ tạo ra một lệnh cho hệ thống xây dựng để thực thi trong một hộp cát.

Chúng khác với các trình cắm lệnh mà bạn thực thi trực tiếp bất cứ lúc nào và có thể được cấp quyền rõ ràng để thay đổi các tệp trong gói của bạn.

Các trình cắm công cụ xây dựng có thể được sử dụng để tạo mã nguồn hoặc xử lý tùy chỉnh cho các loại tệp đặc biệt.

Với các trình cắm công cụ xây dựng, đây sẽ là bố cục gói.

Trong ví dụ này, plugin.Swift là tập lệnh Swift triển khai mục tiêu trình cắm gói.

Trình cắm được coi là một tệp thực thi Swift.

Và bạn viết trình cắm giống như cách bạn viết bất kỳ tệp thực thi Swift nào.

Bạn có thể triển khai trình cắm của mình bằng cách xác định một tập hợp các lệnh xây dựng cho hệ thống xây dựng biết lệnh thực thi nào sẽ chạy và kết quả là kết quả là đầu ra nào.

Các trình cắm gói là các giải pháp an toàn cung cấp khả năng mở rộng trong các gói của bạn.

Bạn có thể tìm hiểu thêm về cách các trình cắm hoạt động và cách triển khai trình cắm của riêng bạn, trong hai phiên, "Gặp gỡ các plugin Gói Swift" và "Tạo các plugin Gói Swift".

Khi bạn mở rộng việc sử dụng các gói của mình, bạn có thể đã gặp phải va chạm mô-đun.

Đó là khi hai gói riêng biệt xác định một mô-đun có cùng tên.

Để giải quyết tình huống này, Swift 5.7 giới thiệu định hướng mô-đun.

Định hướng mô-đun là một tính năng cho phép bạn đổi tên các mô-đun từ bên ngoài các gói xác định chúng.

Ở đây trong ứng dụng Stunning của chúng tôi, chúng tôi đang đưa vào hai gói xác định mô-đun Ghi nhật ký, vì vậy chúng xung đột.

Để khắc phục điều này cho ứng dụng Stunning của chúng tôi, bạn chỉ cần thêm từ khóa moduleAliases vào phần phụ thuộc trong bản kê khai gói của bạn.

Bằng cách đó bạn có thể sử dụng hai tên khác nhau để phân biệt giữa các mô-đun trước đây có cùng tên.

Swift 5.7 mang đến một số cải tiến hiệu suất tuyệt vời.

Hãy bắt đầu bằng cách xem xét thời gian xây dựng.

Năm ngoái, chúng tôi đã nói với bạn về cách chúng tôi đã viết lại Trình điều khiển Swift - chương trình điều phối việc biên dịch mã nguồn Swift trong Swift.

Kiến trúc lại năm ngoái đã mở ra một số thay đổi thực sự quan trọng giúp tăng tốc độ xây dựng đáng kể.

Trình điều khiển bây giờ có thể được sử dụng như một khuôn khổ trực tiếp bên trong hệ thống xây dựng Xcode thay vì như một tệp thực thi riêng biệt.

Điều này cho phép nó phối hợp các bản dựng chặt chẽ hơn với hệ thống xây dựng để cho phép những thứ như song song hóa.

Nếu bạn là người yêu thích âm thanh của các bản dựng nhanh, bạn có thể biết thêm chi tiết trong phiên "Demystify song song hóa trong các bản dựng Xcode".

Để cho bạn thấy các bản dựng nhanh hơn bao nhiêu, hãy xem một số ví dụ về việc mất bao lâu để xây dựng một số công cụ chúng tôi thường sử dụng được viết bằng Swift.

Trên iMac 10 lõi, những cải tiến đã dao động từ 5 phần trăm cho đến 25 phần trăm.

Tiếp theo, có những cải tiến về tốc độ kiểm tra kiểu.

Năm nay, chúng tôi đã cải thiện hiệu suất kiểm tra kiểu bằng cách triển khai lại một phần quan trọng của hệ thống generics - phần tính toán chữ ký hàm từ những thứ như giao thức và mệnh đề "ở đâu".

Trong triển khai cũ, việc sử dụng thời gian và bộ nhớ có thể mở rộng theo cấp số nhân khi có nhiều giao thức tham gia hơn.

Ví dụ, ở đây, chúng tôi có một tập hợp các giao thức phức tạp xác định một hệ tọa độ, với rất nhiều yêu cầu chung trên nhiều loại liên quan.

Trước đây, việc này sẽ mất 17 giây để nhập mã này.

Nhưng bây giờ, trong Swift 5.7, ví dụ này có thể kiểm tra kiểu nhanh hơn đáng kể, trong vòng chưa đầy một giây.

Chúng tôi cũng có một số cải tiến thời gian chạy ấn tượng không kém.

Trước Swift 5.7, chúng tôi đã thấy việc kiểm tra giao thức khi khởi động ứng dụng mất đến bốn giây trên iOS.

Các giao thức cần được tính toán mỗi khi chúng tôi khởi chạy ứng dụng, dẫn đến thời gian khởi chạy càng dài hơn khi bạn thêm nhiều giao thức.

Bây giờ, chúng đã được lưu vào bộ nhớ cache.

Tùy thuộc vào cách một ứng dụng được viết và số lượng giao thức được sử dụng, điều này có thể có nghĩa là thời gian khởi chạy bị cắt giảm một nửa trong một số ứng dụng khi chạy trên iOS 16.

Phiên "Cải thiện kích thước ứng dụng và hiệu suất thời gian chạy" sẽ đi sâu hơn vào cách bạn có thể tận dụng những cải tiến này trong ứng dụng của riêng mình.

Bây giờ, đã đến lúc cho một cái gì đó mà tôi chắc chắn rằng rất nhiều bạn đã háo hức muốn nghe về nó.

Năm ngoái, chúng tôi đã giới thiệu mô hình đồng thời mới, tập hợp các diễn viên và không đồng bộ/chờ đợi.

Điều này có tác động biến đổi đối với kiến trúc đồng thời của các ứng dụng của bạn.

Async/await và actors an toàn và dễ dàng hơn so với gọi lại và quản lý hàng đợi thủ công.

Năm nay, chúng tôi tiếp tục bổ sung mô hình với dữ liệu an toàn cuộc đua đi đầu.

Bởi vì đồng thời là một cải tiến cơ bản và quan trọng đối với cơ sở mã ứng dụng của bạn, chúng tôi đã có thể triển khai lại những thay đổi này cho đến iOS 13 và macOS Catalina.

Để triển khai cho các hệ điều hành cũ hơn, ứng dụng của bạn gói một bản sao của thời gian chạy đồng thời Swift 5.5 cho các hệ điều hành cũ hơn.

Điều này tương tự như triển khai lại Swift cho các hệ điều hành trước sự ổn định của ABI.

Tiếp theo, chúng tôi đã đưa mô hình này theo những hướng mới.

Chúng tôi đã giới thiệu các tính năng ngôn ngữ và các gói hỗ trợ.

Đầu tiên, hãy nói về việc tránh chủng tộc dữ liệu.

Trước khi tôi nhảy vào đó, có lẽ tôi nên lùi lại một bước và nói rằng một trong những tính năng thực sự quan trọng của Swift, là an toàn bộ nhớ theo mặc định.

Người dùng Swift không thể làm mọi thứ với hành vi không thể đoán trước, như đọc một giá trị trong khi bạn đang sửa đổi nó.

Trong ví dụ này, chúng tôi đang loại bỏ tất cả các số trong một mảng khớp với số lượng của cùng một mảng.

Ban đầu, số lượng của mảng là 3, vì vậy chúng tôi sẽ xóa số 3 khỏi mảng.

Nhưng một khi chúng ta đã làm điều đó, số lượng sẽ là 2.

Chúng ta loại bỏ số 3 và số 2 khỏi mảng, hay chỉ số 3?

Câu trả lời là không.

Swift sẽ ngăn bạn làm điều này vì không an toàn để truy cập số lượng của mảng trong khi bạn đang sửa đổi nó.

Mục tiêu của chúng tôi là làm điều gì đó tương tự để đảm bảo an toàn cho sợi chỉ.

Chúng tôi hình dung ra một ngôn ngữ loại bỏ các cuộc đua dữ liệu cấp thấp theo mặc định.

Nói cách khác, chúng tôi muốn ngăn chặn các lỗi đồng thời có thể gây ra hành vi không thể đoán trước.

Đây là một ví dụ khác.

Sử dụng mảng của cùng một số, chúng tôi tạo một tác vụ nền nối thêm 0 vào mảng và sau đó chúng tôi xóa phần tử cuối cùng của mảng.

Nhưng chờ đã, việc xóa phần tử cuối cùng xảy ra trước hay sau khi chúng ta nối thêm 0?

Câu trả lời, một lần nữa, là không.

Swift sẽ chặn bạn làm điều này vì không an toàn khi sửa đổi mảng từ tác vụ nền mà không đồng bộ hóa quyền truy cập với một cái gì đó giống như một diễn viên.

Các diễn viên là bước quan trọng đầu tiên hướng tới việc loại bỏ các cuộc đua dữ liệu.

Năm nay chúng tôi đã tinh chỉnh mô hình đồng thời để thúc đẩy chúng tôi tiến xa hơn nữa đến mục tiêu cuối cùng.

Bạn có thể nghĩ về mỗi diễn viên như hòn đảo riêng của nó, bị cô lập với mọi thứ khác trong biển đồng thời.

Nhưng điều gì sẽ xảy ra khi các chủ đề khác nhau muốn truy vấn thông tin được lưu trữ bởi mỗi tác nhân bị cô lập?

Phép ẩn dụ này sẽ được khám phá sâu trong phiên "Loại bỏ các cuộc đua dữ liệu bằng cách sử dụng Swift Concurrency."

Từ an toàn bộ nhớ đến an toàn luồng theo mặc định; đó là mục tiêu của Swift 6.

Để đưa chúng tôi đến đó, lần đầu tiên chúng tôi đã cải thiện mô hình đồng thời của năm ngoái với các tính năng ngôn ngữ mới mà tôi vừa đề cập.

Điều thứ hai tôi chưa đề cập đến là các kiểm tra an toàn chọn tham gia mới để xác định các cuộc đua dữ liệu tiềm năng.

Bạn có thể thử nghiệm kiểm tra đồng thời chặt chẽ hơn bằng cách bật nó trong cài đặt xây dựng của bạn.

Hãy cùng xem lại các diễn viên.

Chúng ta có thể đưa khái niệm về sự cô lập diễn viên này và tiến xa hơn với các diễn viên phân tán.

Các tác nhân phân tán đặt những hòn đảo đó trên các máy khác nhau với một mạng lưới giữa chúng.

Tính năng ngôn ngữ mới này giúp việc phát triển các hệ thống phân tán đơn giản hơn nhiều.

Giả sử bạn muốn tạo một ứng dụng trò chơi; bây giờ bạn có thể dễ dàng viết phần cuối bằng Swift.

Ở đây, diễn viên phân tán giống như một diễn viên nhưng nó có thể ở trên một cỗ máy khác.

Trong ví dụ này, chúng tôi đang xem xét trình phát máy tính sẽ duy trì trạng thái trong trò chơi với người dùng.

Từ khóa phân tán cũng có thể được thêm vào một hàm mà chúng tôi mong đợi sẽ cần được gọi trên một diễn viên có thể ở trên máy từ xa.

Hãy thêm một hàm khác gọi là endOfRound.

Nó sẽ lặp qua những người chơi và gọi makeMove trên mỗi người.

Một số người chơi này có thể là người địa phương hoặc từ xa, nhưng chúng tôi có lợi ích là không cần phải quan tâm đến cái nào.

Sự khác biệt duy nhất so với cuộc gọi diễn viên thông thường là cuộc gọi diễn viên phân tán có khả năng thất bại do lỗi mạng.

Trong trường hợp mạng bị lỗi, phương thức diễn viên sẽ gây ra lỗi.

Vì vậy, bạn cần thêm từ khóa try cũng như từ khóa await thông thường cần thiết khi bạn gọi một hàm bên ngoài diễn viên.

Dựa trên các nguyên thủy ngôn ngữ cốt lõi này, chúng tôi cũng đã xây dựng một gói Diễn viên phân tán mã nguồn mở tập trung vào việc xây dựng các hệ thống phân tán nhóm, phía máy chủ trong Swift.

Gói này bao gồm một lớp mạng tích hợp sử dụng SwiftNIO và triển khai giao thức đồng thuận SWIM để quản lý trạng thái trên toàn cụm.

Phiên "Gặp gỡ các diễn viên phân tán trong Swift" sẽ đi vào chi tiết hơn về cách xây dựng các hệ thống phân tán với các tính năng mới này.

Chúng tôi cũng đã ra mắt một bộ thuật toán nguồn mở mới để cung cấp các giải pháp dễ dàng cho các hoạt động phổ biến khi xử lý AsyncSequence, được phát hành với Swift 5.5.

Việc phát hành các API này dưới dạng một gói mang lại cho các nhà phát triển sự linh hoạt trong việc triển khai trên các nền tảng và phiên bản hệ điều hành.

Có một số cách để kết hợp nhiều chuỗi không đồng bộ và nhóm các giá trị thành các bộ sưu tập.

Đây chỉ là một số thuật toán được bao gồm trong gói.

Kiểm tra cuộc nói chuyện "Gặp gỡ các thuật toán không đồng bộ Swift" để xem cách bạn có thể sử dụng API mạnh mẽ mới này.

Nhưng có một khía cạnh khác của đồng thời, đó là hiệu suất.

Năm nay, với việc ưu tiên diễn viên, các diễn viên hiện thực hiện công việc ưu tiên cao nhất trước tiên.

Và tiếp tục tích hợp sâu của chúng tôi với bộ lập lịch hệ điều hành, mô hình có tích hợp ngăn chặn đảo ngược ưu tiên, vì vậy công việc ít quan trọng hơn không thể chặn công việc ưu tiên cao hơn.

Trong lịch sử, thật khó để hình dung tác động hiệu suất của sự đồng thời trong ứng dụng của bạn.

Nhưng bây giờ, chúng tôi có một công cụ mới tuyệt vời để làm chính xác điều đó.

Chế độ xem Swift Concurrency mới trong Instruments có thể giúp bạn điều tra các vấn đề về hiệu suất.

Các công cụ Swift Tasks và Swift Actors cung cấp một bộ công cụ đầy đủ để giúp bạn hình dung và tối ưu hóa mã đồng thời của mình.

Ở cấp độ cao nhất, Swift Tasks Instrument cung cấp số liệu thống kê hữu ích, bao gồm số lượng nhiệm vụ chạy đồng thời và tổng số nhiệm vụ đã được tạo cho đến thời điểm đó.

Ở nửa dưới của cửa sổ này, bạn có thể thấy cái được gọi là Rừng Nhiệm vụ.

Nó cung cấp một biểu diễn đồ họa về mối quan hệ cha-con giữa các tác vụ trong mã đồng thời có cấu trúc.

Đây chỉ là một trong những góc nhìn chi tiết cho Swift Actor Instrument.

Để tìm hiểu cách sử dụng công cụ mới thú vị này, bạn sẽ muốn chuyển sang bài nói chuyện "Trực quan hóa và tối ưu hóa đồng thời Swift."

Và đừng quên thử những gói hàng mới đó.

Đừng ngại cho chúng tôi biết nó đang diễn ra như thế nào trên các diễn đàn.

Bây giờ, tôi sẽ giao nó cho Becca để nói về nhiều cải tiến đối với khả năng sử dụng ngôn ngữ Swift.

Ngôn ngữ là công cụ, và có một điều buồn cười về các công cụ - chúng thực sự có thể ảnh hưởng đến những thứ bạn xây dựng với chúng.

Khi tất cả những gì bạn có là một cái búa, bạn sẽ xây dựng mọi thứ bằng đinh thay vì ốc vít.

Và ngay cả khi bạn có một bộ công cụ đầy đủ, nếu búa của bạn có tay cầm lớn, chắc chắn trong khi tuốc nơ vít của bạn dẻo và khó cầm, bạn vẫn có thể nghiêng về phía đinh.

Một ngôn ngữ cũng giống như vậy.

Nếu Swift có một công cụ tốt để thể hiện điều gì đó, mọi người sẽ sử dụng nó thường xuyên hơn.

Và năm nay, các công cụ của Swift để thể hiện những gì bạn muốn mã của mình làm đã được cải thiện theo nhiều cách.

Một số thay đổi này là những tiện ích đơn giản cho những việc bạn thường làm.

Ví dụ, nó thực sự phổ biến trong Swift để sử dụng nếu let có cùng tên ở cả hai bên của dấu bằng nhau.

Rốt cuộc, có lẽ không có cái tên nào tốt hơn cho giá trị chưa được gói so với cái tên bạn đã đặt cho cái tùy chọn.

Nhưng khi cái tên thực sự dài, sự lặp lại đó bắt đầu trở nên cồng kềnh.

Bạn có thể bị cám dỗ để viết tắt tên, nhưng sau đó mã của bạn trở nên khó hiểu.

Và nếu sau này bạn đổi tên biến tùy chọn, chữ viết tắt có thể không đồng bộ.

Swift 5.7 giới thiệu một cách viết tắt mới cho mô hình phổ biến này.

Nếu bạn đang mở gói một tùy chọn và muốn giá trị chưa gói có cùng tên, chỉ cần thả phía bên tay phải.

Swift sẽ cho rằng nó giống nhau.

Và tất nhiên, điều này cũng hoạt động với người bảo vệ, và thậm chí trong khi, cho vấn đề đó.

Chúng tôi cũng đã xem xét những nơi mà một tính năng đột nhiên ngừng hoạt động khi bạn thực hiện một thay đổi nhỏ.

Ví dụ, Swift luôn có thể tìm ra loại cuộc gọi nào sẽ quay trở lại dựa trên mã được viết bên trong đóng một câu lệnh.

Trong cuộc gọi compactMap này, việc đóng trả về giá trị của parseLine và hàm parseLine trả về MailmapEntry, vì vậy Swift có thể tìm ra rằng các mục nhập phải là một mảng của MailmapEntry.

Điều này hiện hoạt động cho các đóng cửa phức tạp hơn có nhiều câu lệnh hoặc tính năng luồng điều khiển.

Vì vậy, bạn có thể sử dụng do-catch, hoặc if...else, hoặc chỉ cần thêm một cuộc gọi in, mà không cần phải chỉ định thủ công loại kết quả của việc đóng cửa.

Một điều khác mà chúng tôi đã xem xét là những lá cờ nguy hiểm không thực sự gắn cờ bất kỳ mối nguy hiểm thực sự nào.

Swift rất quan tâm đến sự an toàn về loại và bộ nhớ.

Để giữ cho bạn không mắc lỗi, nó không bao giờ tự động chuyển đổi giữa các con trỏ với các loại con trỏ khác nhau, cũng như giữa con trỏ thô và con trỏ đã nhập.

Điều này rất khác với C, cho phép chuyển đổi nhất định.

Ví dụ: bạn có thể thay đổi độ ký của con trỏ hoặc truyền bất kỳ con trỏ nào sang ngôi sao ký tự để truy cập nó dưới dạng byte, mà không vi phạm bất kỳ quy tắc con trỏ nào của C.

Nhưng đôi khi những khác biệt trong hành vi con trỏ này sẽ gây ra vấn đề khi API C được nhập vào Swift.

Nhà phát triển ban đầu có thể đã thiết kế các API của họ với sự không phù hợp nhỏ được xử lý bởi các chuyển đổi tự động trong C nhưng là các lỗi trong Swift.

Trong Swift, việc truy cập một con trỏ thuộc một loại như thể nó là một loại khác là rất nguy hiểm, vì vậy bạn phải mô tả những gì bạn đang làm rất rõ ràng.

Nhưng tất cả đều vô nghĩa nếu chúng ta chuyển con trỏ trực tiếp đến C, bởi vì trong C, sự không khớp của con trỏ đó là hoàn toàn hợp pháp!

Vì vậy, trong trường hợp này, chúng tôi đã đối xử với một cái gì đó thực sự đơn giản như thể nó nguy hiểm.

Điều này quan trọng bởi vì, nhiều như Swift coi trọng loại an toàn, nó cũng coi trọng việc dễ dàng truy cập vào mã C-family.

Đó là lý do tại sao C và Objective-C interop rất phong phú và liền mạch, và đó là lý do tại sao dự án Swift thành lập nhóm làm việc C++ mà Angela đã đề cập trước đó để bắt đầu xây dựng C++ interop có khả năng tương đương.

Chúng tôi không muốn việc sử dụng các hàm C như thế này gây đau đớn một cách không cần thiết.

Vì vậy, Swift hiện có một bộ quy tắc riêng biệt cho các cuộc gọi đến các hàm và phương thức đã nhập.

Nó cho phép chuyển đổi con trỏ sẽ hợp pháp trong C mặc dù chúng thường không có trong Swift.

Bằng cách đó, mã Swift của bạn có thể sử dụng các API này một cách liền mạch.

Cho đến nay chúng ta đã nói về những cải tiến nhỏ đối với các công cụ bạn đã có.

Nhưng năm nay, Swift cũng có một công cụ hoàn toàn mới để trích xuất thông tin từ các chuỗi.

Đây là một hàm phân tích cú pháp một số thông tin ra khỏi một chuỗi.

Loại nhiệm vụ này luôn là một chút thách thức trong Swift.

Cuối cùng bạn sẽ tìm kiếm, tách và cắt đi cắt lại cho đến khi bạn có được thứ bạn muốn.

Khi mọi người nhận thấy điều này, họ có xu hướng tập trung vào những điều nhỏ nhặt, chẳng hạn như việc thao tác các chỉ mục chuỗi có thể dài dòng như thế nào, nhưng tôi nghĩ điều đó hơi thiếu bức tranh lớn hơn.

Bởi vì ngay cả khi chúng tôi thay đổi cú pháp này, nó không giúp bạn trả lời câu hỏi cơ bản mà bạn đang hỏi khi bạn nhìn vào mã này - biến dòng được truyền vào nó thực sự trông như thế nào?

Nó đang cố gắng tháo rời loại dây nào?

Nếu bạn nhìn chằm chằm vào nó đủ lâu, bạn có thể nhận ra rằng nó đang phân tích cú pháp một phiên bản đơn giản của bản đồ thư - một tệp bạn đặt trong kho lưu trữ git để sửa tên nhà phát triển trong các cam kết cũ.

Nhưng việc trích xuất thông tin đó bằng cách tìm kiếm và cắt lát có liên quan đến mức khó có thể tìm ra điều đó.

Bạn bị lạc trong cách cắt chuỗi đến nỗi bạn mất dấu chuỗi đó là gì.

Vấn đề không phải là hai biểu thức này; vấn đề là toàn bộ sự việc.

Chúng ta cần xé bỏ tất cả những thứ này và thay thế nó bằng thứ gì đó tốt hơn.

Chúng tôi cần một cách tiếp cận khác; một cách mà loại mã của bạn vẽ một bức tranh về chuỗi bạn muốn khớp và ngôn ngữ tìm ra cách thực hiện.

Một cách tiếp cận khai báo, không phải là một cách bắt buộc.

Trong Swift 5.7, bây giờ bạn có thể làm điều đó bằng cách viết một regex.

Regex là một cách để mô tả một mẫu trong một chuỗi.

Trong hơn 50 năm, các ngôn ngữ và công cụ đã cho phép các nhà phát triển viết regexes theo cú pháp dày đặc, chứa nhiều thông tin.

Một số bạn đã sử dụng chúng trong thanh tìm Xcode, trong các công cụ dòng lệnh như grep, trong lớp NSRegularExpression của Foundation hoặc trong các ngôn ngữ lập trình khác.

Cú pháp đó hiện được hỗ trợ bởi các ký tự regex của Swift và nó hoạt động giống như trong bất kỳ công cụ nhà phát triển nào khác.

Nhưng một số bạn chưa từng sử dụng regexes trước đây và có lẽ bạn sẽ nói, "Đó là mã thật hay một con mèo đã đi ngang qua bàn phím của cô ấy?"

Và tôi không trách bạn.

Các ký tự Regex được viết bằng các ký hiệu và ghi nhớ mà bạn phải ghi nhớ để đọc chúng.

Đối với một người biết ngôn ngữ, ngay cả những phần khó hiểu nhất của regex này, như phần phù hợp với tên của nhà phát triển chỉ là sự kết hợp của một số quy tắc kết hợp đơn giản.

Nhưng đó là rất nhiều hành vi để nhồi nhét thành 11 ký tự.

Các ký tự Regex nhỏ gọn đến mức ngay cả các nhà phát triển có kinh nghiệm đôi khi cũng cần một phút để hiểu một ký tự phức tạp.

Nhưng điều gì sẽ xảy ra nếu bạn có thể viết cùng một loại quy tắc phù hợp, chỉ bằng từ ngữ thay vì ký hiệu?

Điều đó có vẻ như nó sẽ dễ hiểu hơn.

Trên thực tế, hãy kết hợp tất cả lại với nhau và bạn sẽ nhận được thứ gì đó trông rất giống SwiftUI.

Đó sẽ là một sự thay thế tuyệt vời cho một regex theo nghĩa đen, phải không?

Vì vậy, đó là một điều tốt Swift ủng hộ điều đó!

Thư viện RegexBuilder cung cấp một ngôn ngữ kiểu SwiftUI hoàn toàn mới cho các regexes dễ sử dụng hơn và dễ đọc hơn cú pháp truyền thống.

Nó có thể làm những điều tương tự mà một nghĩa đen regex có thể, nhưng nó mô tả hành vi của nó bằng những từ mà bạn có thể hiểu hoặc tra cứu, thay vì các ký hiệu và chữ viết tắt bạn phải ghi nhớ.

Trình tạo Regex rất tuyệt vời cho người mới bắt đầu, nhưng đây không phải là tính năng chỉ dành cho người mới bắt đầu.

Nó có những khả năng mạnh mẽ vượt xa những gì một regex literal có thể làm.

Để bắt đầu, bạn có thể biến regex thành thành phần regex có thể tái sử dụng, giống như bạn có thể biến hệ thống phân cấp chế độ xem SwiftUI thành chế độ xem.

Bạn có thể sử dụng các thành phần này từ các regexe khác được tạo bằng cú pháp trình tạo và thậm chí bạn có thể làm cho chúng đệ quy.

Các nhà xây dựng Regex cũng hỗ trợ thả một số loại Swift trực tiếp vào regex.

Ví dụ, các ký tự chuỗi chỉ khớp với văn bản chính xác bên trong chúng - không cần thoát đặc biệt.

Bạn cũng có thể sử dụng các ký tự regex ở giữa trình tạo regex.

Vì vậy, bạn có thể đạt được sự cân bằng giữa sự rõ ràng của trình tạo regex và sự đồng nhất của một regex theo nghĩa đen.

Và các loại khác - như kiểu định dạng ngày Foundation này - có thể tích hợp logic phân tích cú pháp tùy chỉnh với các trình tạo regex và thậm chí chuyển đổi dữ liệu sang loại phong phú hơn trước khi chụp nó.

Cuối cùng, bất kể bạn sử dụng cú pháp nào, regexes hỗ trợ một loạt các phương pháp kết hợp hữu ích và chụp được nhập mạnh dễ sử dụng.

Giờ đây, đối với những người mọt sách regex đang vặn vẹo chỗ ngồi của họ, Swift Regex sử dụng công cụ kết hợp mã nguồn mở hoàn toàn mới, với bộ tính năng có thể so sánh với các triển khai regex tiên tiến nhất.

Cú pháp theo nghĩa đen tương thích với tiêu chuẩn Unicode regex và nó có mức độ chính xác Unicode không phổ biến.

Ví dụ, dấu chấm khớp với toàn bộ ký tự theo mặc định, không phải Unicode.Scalar hoặc UTF-8 byte.

Để sử dụng Swift Regex, ứng dụng của bạn sẽ cần phải chạy trên một hệ điều hành với công cụ Swift Regex được tích hợp trong đó, như macOS 13 hoặc iOS 16.

Swift Regex là toàn bộ ngôn ngữ - tốt, thực sự là hai ngôn ngữ - vì vậy có nhiều điều để nói về nó.

Hai phiên này - "Gặp gỡ Swift Regex" và "Swift Regex: Beyond The Basics" - sẽ cung cấp cho bạn nhiều chi tiết hơn về việc sử dụng nó.

Cuối cùng, có một nơi mà chúng tôi đã xem xét toàn diện các công cụ mà chúng tôi có và thực hiện một loạt các thay đổi để cải thiện chúng.

Đó là trong generics và giao thức.

Để cho bạn thấy những công cụ này đã được cải thiện như thế nào, tôi sẽ cần một giao thức ví dụ.

Giả sử bạn đang viết một ứng dụng khách git và bạn phải thể hiện bản đồ thư theo hai cách khác nhau.

Khi bạn đang hiển thị các cam kết, bạn sử dụng một loại có từ điển để nhanh chóng tra cứu tên.

Nhưng khi bạn cho phép người dùng chỉnh sửa bản đồ thư, bạn sử dụng một loại có mảng để giữ các mục nhập theo thứ tự ban đầu của chúng.

Và bạn có một giao thức gọi là Mailmap mà cả hai đều tuân thủ, vì vậy trình phân tích cú pháp mailmap của bạn có thể thêm các mục nhập vào một trong hai loại.

Nhưng có hai cách mà trình phân tích cú pháp có thể sử dụng giao thức Mailmap.

Tôi đã viết hai phiên bản khác nhau của hàm addEntries này để minh họa chúng, nhưng thực sự rất khó để giải thích chúng khác nhau như thế nào, bởi vì Swift đang sử dụng cùng một cú pháp cho hai thứ khác nhau.

Hóa ra từ "Mailmap" có nghĩa là một điều ở đây nhưng nó có nghĩa là một cái gì đó khác biệt tinh tế ở đây.

Khi bạn đặt tên cho một giao thức trong danh sách kế thừa, danh sách tham số chung, ràng buộc tuân thủ chung hoặc loại kết quả không rõ ràng, nó có nghĩa là "một trường hợp phù hợp với giao thức này."

Nhưng trong một loại biến, một đối số chung, một ràng buộc cùng loại chung, hoặc một tham số hàm hoặc loại kết quả, nó thực sự có nghĩa là "một hộp chứa một thể hiện phù hợp với giao thức này."

Sự khác biệt này rất quan trọng vì hộp thường sử dụng nhiều không gian hơn, mất nhiều thời gian hơn để hoạt động và không có tất cả các khả năng của phiên bản bên trong nó.

Nhưng những nơi bạn đang sử dụng hộp trông giống như những nơi bạn không sử dụng, vì vậy thật khó để tìm hiểu xem bạn có đang sử dụng hộp hay không.

Swift 5.7 khắc phục sự giám sát này.

Khi bạn đang sử dụng một trong những hộp này có chứa một loại phù hợp, Swift bây giờ sẽ mong đợi bạn viết bất kỳ từ khóa nào.

Điều này không bắt buộc trong mã hợp lệ trước Swift 5.7, nhưng nó được khuyến khích và bạn sẽ thấy nó trong các giao diện được tạo và thông báo lỗi, ngay cả khi bạn không viết nó ra một cách rõ ràng.

Vì vậy, cách ưa thích để viết tất cả những điều đó ở cột bên phải là với bất kỳ từ khóa nào.

Nếu bạn làm điều đó, bạn sẽ có thể biết khi nào bạn đang sử dụng một trong những hộp này.

Bây giờ bất kỳ từ khóa nào đánh dấu một trong những tham số trong ví dụ này, việc giải thích sự khác biệt giữa hai hàm này sẽ dễ dàng hơn rất nhiều.

addEntries1 lấy Mailmap làm loại chung; addEntries2 lấy nó làm bất kỳ loại nào.

Và nó cũng dễ dàng hơn cho các thông báo lỗi để giải thích những gì đang xảy ra khi bạn gặp một trong những giới hạn của bất kỳ loại nào.

Ví dụ, hàm mergeMailmaps này cố gắng chuyển bất kỳ Mailmap nào sang tham số Mailmap chung.

Điều này được sử dụng để tạo ra một lỗi nói rằng Mailmap không thể phù hợp với chính nó, điều này luôn có vẻ nghịch lý.

Nhưng bây giờ chúng ta đã có khái niệm về bất kỳ loại nào, chúng ta có thể giải thích những gì đang xảy ra rõ ràng hơn.

Vấn đề là bất kỳ Mailmap nào - hộp chứa mailmap - không phù hợp với giao thức Mailmap.

Nhưng cái hộp là thứ bạn đang cố gắng vượt qua, và nó không phù hợp với tham số chung.

Nếu bạn muốn chuyển phiên bản bên trong hộp ở đây, bạn phải bằng cách nào đó mở hộp, lấy bản đồ thư bên trong nó ra và thay vào đó chuyển nó.

Nhưng thực ra, trong những trường hợp đơn giản như thế này, Swift bây giờ sẽ chỉ làm điều đó cho bạn.

Mở hộp, lấy ví dụ bên trong nó ra và chuyển nó đến tham số chung.

Vì vậy, bạn sẽ không thấy thông báo lỗi này nhiều nữa.

Nhưng có một sự cải tiến thậm chí còn thú vị hơn bất kỳ loại nào so với loại đó.

Trước đây, một giao thức không thể được sử dụng như một loại nào nếu nó sử dụng loại tự hoặc có các loại liên quan, hoặc thậm chí chỉ phù hợp với một giao thức đã làm, như Equatable.

Nhưng trong Swift 5.7, lỗi này chỉ - poof - đã biến mất.

Rất nhiều nhà phát triển đã phải vật lộn với cái này, vì vậy chúng tôi rất vui khi đã sửa nó tại nguồn.

Bây giờ, điều đó đủ thú vị chỉ cho các giao thức như Mailmap, nhưng điều này thậm chí còn đi xa hơn.

Bởi vì ngay cả các giao thức rất phức tạp, như Bộ sưu tập, cũng có thể được sử dụng như bất kỳ loại nào.

Bạn thậm chí có thể chỉ định loại phần tử, nhờ vào một tính năng mới được gọi là "các loại liên kết chính".

Rất nhiều loại liên quan về cơ bản chỉ là chi tiết triển khai.

Bạn thường không quan tâm bộ sưu tập sử dụng loại nào cho chỉ mục, trình lặp hoặc trình tự con của nó; bạn chỉ cần sử dụng loại mà nó hỗ trợ.

Nhưng Yếu tố của nó là một câu chuyện khác.

Bạn có thể không phải lúc nào cũng quan tâm chính xác loại Element mà một bộ sưu tập sử dụng, nhưng có lẽ bạn sẽ làm gì đó với các yếu tố, vì vậy bạn sẽ cần hạn chế chúng hoặc trả lại chúng hoặc một cái gì đó.

Khi bạn có một loại liên kết như Element mà gần như mọi người dùng giao thức sẽ quan tâm, bạn có thể đặt tên của nó sau tên của giao thức trong dấu ngoặc nhọn để biến nó thành loại liên kết chính.

Một khi bạn làm điều đó, bạn có thể hạn chế các loại liên quan chính của giao thức với cú pháp dấu ngoặc nhọn khá nhiều ở bất cứ đâu bạn có thể viết tên của giao thức, bao gồm cả trong bất kỳ Bộ sưu tập nào.

Bây giờ, một số bạn có thể đang nhìn vào loại này và nói, "Chờ một chút.

Không phải đã có thứ gọi là AnyCollection, chỉ cần chạy cùng nhau và viết hoa 'bất kỳ' sao? ”

Và bạn nói đúng, có!

AnyCollection cũ là một trình bao bọc xóa kiểu - một cấu trúc viết tay phục vụ cùng mục đích với bất kỳ loại nào.

Sự khác biệt là cấu trúc AnyCollection chỉ là dòng này đến dòng khác của mã mẫu nhàm chán nhất mà bạn từng thấy trong đời; trong khi bất kỳ loại nào cũng là một tính năng ngôn ngữ tích hợp về cơ bản thực hiện điều tương tự - miễn phí!

Bây giờ, cấu trúc AnyCollection sẽ tồn tại để tương thích ngược và bởi vì nó có một vài tính năng mà bất kỳ loại nào cũng chưa thể sánh được.

Nhưng nếu bạn có trình bao bọc xóa kiểu của riêng mình trong mã của mình, bạn có thể muốn xem liệu bạn có thể triển khai lại chúng bằng cách sử dụng bất kỳ loại tích hợp nào thay vì các lớp hộp hoặc đóng hay không.

Hoặc thậm chí có thể chỉ cần thay thế chúng bằng bí danh kiểu.

Vì vậy Swift đã cải thiện đáng kể bất kỳ loại nào.

Nó được giới thiệu bất kỳ từ khóa nào để bạn có thể thấy nơi bạn đang sử dụng chúng.

Nó cho phép bạn chuyển chúng cho các đối số chung chung.

Nó đã bị bãi bỏ hạn chế khiến nhiều giao thức không được sử dụng với chúng.

Và nó thậm chí còn cho phép bạn hạn chế các loại liên quan chính của bất kỳ loại nào.

Nhưng ngay cả với tất cả những cải tiến đó, bất kỳ loại nào vẫn có những hạn chế.

Ví dụ: mặc dù bây giờ bạn có thể sử dụng bất kỳ Mailmaps nào khi Mailmap phù hợp với Equatable, bạn vẫn không thể sử dụng toán tử equals với chúng, bởi vì toán tử equals yêu cầu cả hai mailmaps phải có cùng một loại cụ thể, nhưng điều đó không được đảm bảo khi bạn đang sử dụng hai Mailmaps bất kỳ

Vì vậy, mặc dù Swift đã cải thiện bất kỳ loại nào rất nhiều, chúng vẫn có những hạn chế quan trọng, cả về khả năng và hiệu suất.

Và đó là lý do tại sao rất nhiều lần, bạn không nên sử dụng chúng - thay vào đó bạn nên sử dụng thuốc generic.

Vì vậy, hãy quay lại hai phiên bản của addEntries và áp dụng sự khôn ngoan đó.

Cả hai phiên bản đều làm chính xác điều tương tự, nhưng phiên bản ở trên cùng sử dụng các loại chung chung và phiên bản ở dưới cùng sử dụng bất kỳ loại nào.

Phiên bản chung có thể sẽ hiệu quả hơn và có khả năng hơn, vì vậy bạn nên sử dụng phiên bản đó.

Tuy nhiên, có lẽ bạn bị cám dỗ để sử dụng bất kỳ loại nào, bởi vì chúng dễ đọc và viết hơn rất nhiều.

Để viết phiên bản chung, bạn cần khai báo hai tên loại chung, hạn chế cả hai và cuối cùng, sử dụng các tên loại chung đó làm loại tham số.

Điều đó thật mệt mỏi so với việc viết "bất kỳ Bộ sưu tập nào" và "bất kỳ Bản đồ thư nào".

Vì vậy, bạn sẽ bị cám dỗ để sử dụng bất kỳ loại nào bất chấp những hạn chế của chúng.

Nhưng đó là điều tương tự mà tôi đã nói trước đó - sử dụng búa của bạn thay vì tuốc nơ vít của bạn vì búa có tay cầm lớn, chắc chắn.

Bạn không cần phải đưa ra lựa chọn đó.

Vì vậy, Swift đang tạo ra các loại thuốc generic dễ sử dụng như bất kỳ loại nào.

Nếu một tham số chung chỉ được sử dụng ở một nơi, bây giờ bạn có thể viết nó với một số từ khóa dưới dạng tốc ký.

Và nó thậm chí còn hỗ trợ các loại liên quan chính, vì vậy bạn có thể chấp nhận tất cả các bộ sưu tập các mục nhập bản đồ thư với mã dễ hiểu hơn rất nhiều.

Với điều đó trong hộp công cụ của bạn, không có lý do gì để tránh thuốc generic nữa.

Nếu bạn có sự lựa chọn giữa thuốc generic và bất kỳ loại nào, thuốc generic sẽ dễ sử dụng - chỉ cần viết "một số" thay vì "bất kỳ".

Vì vậy, bạn cũng có thể sử dụng công cụ tốt nhất cho công việc.

Tôi chỉ làm xước bề mặt của những thay đổi này đối với các giao thức và thuốc generic.

Để có cái nhìn sâu sắc, cũng như đánh giá tuyệt vời về tất cả các tính năng chung của Swift, chúng tôi có thêm hai cuộc nói chuyện cho bạn trong năm nay: "Nắm bắt chung Swift" và "Thiết kế giao diện giao thức trong Swift".

Bây giờ, Angela và tôi đã nói về gần hai chục thay đổi đối với Swift, nhưng có rất nhiều điều khác mà chúng tôi không thể phù hợp với phiên này.

Mọi thay đổi này đều được đưa ra, đề xuất, xem xét và chấp nhận công khai trong bảng Evolution trên Diễn đàn Swift.

Và tất cả chúng đều được định hình và hiện thực hóa với sự giúp đỡ của các thành viên cộng đồng từ bên ngoài Apple.

Nếu bạn là một trong những người đó, cảm ơn bạn đã biến Swift 5.7 thành bản phát hành tuyệt vời.

Và nếu bạn muốn giúp quyết định điều gì sẽ xảy ra tiếp theo, hãy truy cập Swift.org/contributing để tìm hiểu cách tham gia.

Cảm ơn bạn đã dành thời gian.

Và mã hóa vui vẻ.

♪