10106

♪ ♪

Chào mừng bạn đến với Hồ sơ và Tối ưu hóa Bộ nhớ Trò chơi của Bạn.

Tôi là Jack Xu (许) từ nhóm Phần mềm GPU tại Apple.

Chúng tôi có sự tham gia của đồng nghiệp Seth Lù (陆) của tôi.

Trong vài năm qua, các nhóm của chúng tôi đã làm việc với các nhà phát triển trò chơi như bạn để cùng nhau hiểu và cải thiện trí nhớ trò chơi.

Hôm nay, chúng tôi muốn chia sẻ những bài học của chúng tôi, vì vậy bạn cũng có thể bắt đầu thuận lợi khi gỡ lỗi bộ nhớ trò chơi của mình và tạo ra những trò chơi tuyệt vời với trải nghiệm người chơi tốt nhất.

Chúng tôi sẽ chia nhỏ việc sử dụng bộ nhớ trong trò chơi của bạn, từ cả đối tượng CPU và GPU.

Thêm vào đó, phân tích phân bổ trong trò chơi của bạn, sử dụng thực tế trên bộ nhớ vật lý và tham chiếu giữa các đối tượng.

Bởi vì có nhiều khía cạnh của bộ nhớ, các công cụ dành cho nhà phát triển của chúng tôi cũng tiết lộ những bí ẩn về trí nhớ từ các góc độ khác nhau.

Chúng tôi sẽ tham gia một chuyến tham quan có hướng dẫn và trải nghiệm cách chúng tôi sử dụng tất cả chúng, bao gồm Xcode, Instruments và các công cụ dòng lệnh trong Terminal.

Trong chuyến tham quan có hướng dẫn hôm nay, chúng ta sẽ bắt đầu với khúc dạo đầu để hiểu bộ nhớ trò chơi.

Và bắt đầu lập hồ sơ bộ nhớ và sự phát triển trí nhớ, nơi Seth sẽ cho chúng ta biết về Dụng cụ.

Sau khi thực hiện cách tiếp cận tạm thời với Instruments, chúng tôi sẽ tiếp tục hành trình của mình và phân tích biểu đồ bộ nhớ của trò chơi của bạn bằng cách sử dụng các công cụ trong Xcode và Terminal.

Các quy trình làm việc này tập trung vào trạng thái sử dụng bộ nhớ hiện tại và phân tích tổng bộ nhớ trò chơi.

Cuối cùng, Seth sẽ chia sẻ cách bạn có thể sử dụng Metal Debugger để tối ưu hóa tài nguyên Metal, đây là một lĩnh vực hơi độc lập nhưng cốt lõi trong bộ nhớ trò chơi.

Bây giờ, hãy bắt đầu với việc hiểu bộ nhớ trò chơi.

Khi bạn khởi chạy trò chơi của mình từ Xcode, chẳng hạn như Kết xuất hiện đại với mã mẫu Kim loại, bạn có thể mở Báo cáo bộ nhớ này trong trình duyệt gỡ lỗi của Xcode.

Đây là cái nhìn đầu tiên của bạn về việc sử dụng bộ nhớ hiện tại và gần đây của trò chơi, và mức độ tác động của nó đối với hệ thống.

Con số trên thước đo cho bạn thấy việc sử dụng bộ nhớ hiện tại của trò chơi.

Bước đầu tiên quan trọng trong việc gỡ lỗi bộ nhớ là hiểu con số này có nghĩa là gì.

Để đặt nó vào một dòng, việc sử dụng bộ nhớ thực tế trong trò chơi của bạn không giống như phân bổ.

Việc sử dụng bộ nhớ thực tế là trên bộ nhớ vật lý.

Trong khi phân bổ là bộ nhớ được yêu cầu bởi trò chơi, trên không gian địa chỉ bộ nhớ ảo.

Và các loại phân bổ khác nhau được tính toán riêng một cách tự nhiên.

Khi trò chơi của bạn phân bổ bộ nhớ, những phân bổ mới đó không ngay lập tức cũng như không trực tiếp chiếm dung lượng trên bộ nhớ vật lý.

Ngược lại, họ sẽ dành một số không gian trên không gian địa chỉ bộ nhớ ảo, mà hệ thống cung cấp cho mỗi quy trình.

Và khi chương trình thực sự sử dụng phân bổ này sau này, hệ thống sẽ chuẩn bị không gian trên bộ nhớ vật lý.

Các phân bổ cùng loại được nhóm thành các danh mục và chiếm không gian địa chỉ ảo một cách thưa thớt.

Các danh mục này có thể bao gồm: nhị phân thực thi của chương trình; tất cả các thư viện và khuôn khổ; ngăn xếp, cung cấp lưu trữ cho các biến cục bộ và tạm thời cũng như một số đối số hàm; các vùng bộ nhớ động còn được gọi là đống; bao gồm lưu trữ phiên bản lớp và bộ nhớ mà chương trình phân bổ thủ công; các vùng

Và những danh mục này được tạo thành từ các khu vực.

Dưới mui xe, các hoạt động bộ nhớ hoạt động ở mức độ chi tiết của các trang bộ nhớ, mỗi trang có 16 kibibyte trên các thiết bị Apple hiện đại.

Điều này có nghĩa là mỗi khu vực chiếm một hoặc nhiều trang và lớn ít nhất 16 kibibyte.

Khi trò chơi tiếp tục, trạng thái bộ nhớ của nó tiếp tục phát triển; các đối tượng mới được phân bổ, các vật phẩm cũ bị phá hủy, các khu vực liên tục thay đổi.

Nhưng chỉ các trang được sử dụng trên các khu vực nằm trên bộ nhớ vật lý, mà hệ thống siêng năng tính phí cho trò chơi của bạn, cũng như với bất kỳ ứng dụng nào khác.

Các trang bộ nhớ trong trò chơi của bạn có thể là một trong ba loại: bẩn, nén và sạch.

Hãy kiểm tra xem chúng là gì.

Các trang bộ nhớ bẩn bao gồm bộ nhớ mà trò chơi của bạn đã ghi vào.

Điều này bao gồm phân bổ bộ nhớ trong đống và khuôn khổ, một khi trò chơi của bạn sửa đổi các biến hoặc biểu tượng đó.

Trên các thiết bị có Apple silicon, các tài nguyên Metal được truy cập cũng thuộc danh mục này, điều này là do CPU và GPU chia sẻ cùng một nhóm bộ nhớ thống nhất nhanh.

Tuy nhiên, nếu một số trang bẩn không được sử dụng trong một thời gian dài, hệ thống có thể giảm sự hiện diện của chúng trên bộ nhớ vật lý bằng cách nén các trang này hoặc lưu trữ chúng trên flash hoặc đĩa, mà chúng tôi gọi là hoán đổi.

Điều này sẽ cho phép thiết bị chạy nhiều ứng dụng và dịch vụ hơn.

Sau đó, khi trò chơi của bạn yêu cầu các trang này một lần nữa, hệ thống sẽ giải nén hoặc trang trong đó từ đĩa.

Lưu ý, trò chơi của bạn vẫn sẽ bị tính phí cho kích thước không nén của chúng.

Đối với các trang bộ nhớ sạch, chúng bao gồm các tệp chỉ đọc được ánh xạ từ đĩa, chẳng hạn như tài sản kết cấu hoặc âm thanh và các khung được tải vào quy trình.

Hệ thống có thể làm trống hoặc tải lại chúng từ đĩa bất cứ lúc nào, vì vậy chúng không được tính vào dấu chân bộ nhớ trò chơi của bạn.

Tuy nhiên, chúng có thể nằm trong bộ nhớ và việc sử dụng quá mức sẽ làm chậm hệ thống và trò chơi của bạn.

Nó thường thú vị nhất khi nhìn vào hai phần đầu tiên, kết hợp lại, chúng ta gọi là dấu chân bộ nhớ.

Và hệ thống sử dụng cái này để thực thi giới hạn bộ nhớ.

Trong một số thuật ngữ, mọi người nói "trí nhớ bẩn" khi chúng có nghĩa là dấu chân bộ nhớ, vì bẩn trái ngược với sạch sẽ.

Nhưng đừng lo lắng, khi mọi thứ trở nên mờ nhạt, chúng tôi sẽ gọi ra ý chúng tôi là cái nào.

Vì vậy, bây giờ bạn đã biết bộ nhớ hoạt động như thế nào và cách hệ thống sạc nó vào trò chơi.

Bên cạnh máy đo bộ nhớ Xcode này, bạn có thể tìm thấy dấu chân bộ nhớ ở nhiều nơi trên hệ thống, bao gồm cả ứng dụng Giám sát Hoạt động trên Mac.

Và một số nền tảng của Apple sử dụng nó cho giới hạn bộ nhớ ứng dụng.

Trò chơi của bạn cũng có thể sử dụng số liệu này để hướng dẫn việc sử dụng bộ nhớ của nó.

Có các API hữu ích để truy vấn dấu chân hiện tại và bộ nhớ khả dụng.

Đây là một cái nhìn nhanh.

Để có sẵn bộ nhớ hệ thống cho trò chơi iOS, iPadOS hoặc tvOS của bạn, hãy gọi os_proc_available_memory, nằm trong tệp tiêu đề os/proc.h.

Và đối với dấu chân bộ nhớ trên bất kỳ nền tảng Apple nào, bạn có thể lấy nó thông qua proc_pid_rusage, với ID quy trình từ "get pid", "rusage_info_current", hiện tại là phiên bản 6 và kho dữ liệu.

Và lấy lại dấu chân vật lý hoặc thuộc tính dấu chân vật lý tối đa suốt đời của nó.

Tóm lại, trong phần đầu tiên này, chúng tôi đã xem xét một số khái niệm về trí nhớ.

Việc phân bổ trong trò chơi của bạn xảy ra trên không gian địa chỉ bộ nhớ ảo và chúng sẽ chiếm không gian bộ nhớ vật lý dưới dạng 16 trang kibibyte, một khi chúng được trò chơi của bạn truy cập.

Dấu chân bộ nhớ là thước đo chính và phổ quát trên nền tảng Apple để xác định việc sử dụng bộ nhớ thực tế trong trò chơi của bạn.

Dấu chân bộ nhớ chứa các trang bẩn, được nén và hoán đổi.

Nó bao gồm cả đối tượng CPU và GPU trên Apple silicon.

Và nó được sử dụng để thực thi giới hạn bộ nhớ.

Trò chơi của bạn có thể gọi các API hệ thống để lấy dấu chân và bộ nhớ khả dụng.

Bây giờ bạn đã biết bộ nhớ hoạt động như thế nào đằng sau hậu trường, hãy cùng tìm hiểu xem nó trông như thế nào trong trò chơi của bạn.

Hãy để tôi giao cho Seth, để nói cho bạn biết thêm.

Seth Lù: Cảm ơn, Jack.

Bây giờ, hãy bắt đầu với việc nắm bắt sự phát triển trí nhớ cho một trò chơi.

Và tôi sẽ tiếp tục sử dụng dự án mẫu Modern Renderer.

Khi bạn chạy một trò chơi từ Xcode, Máy đo bộ nhớ sẽ hiển thị cho bạn dấu chân bộ nhớ theo thời gian.

Tuy nhiên, bạn có thể có cái nhìn chi tiết hơn nhiều về việc sử dụng bộ nhớ bằng cách lập hồ sơ trò chơi trong Instruments.

Bởi vì đôi khi một trò chơi có thể phân bổ rất nhiều bộ nhớ tại thời điểm ra mắt, bạn có thể muốn bắt đầu lập hồ sơ từ một lần ra mắt trò chơi mới thay vì gắn vào một lần chạy hiện có.

Từ Xcode, để nhanh chóng bắt đầu lập hồ sơ trò chơi của bạn, hãy nhấn và giữ nút chạy, sau đó chọn "Hồ sơ".

Điều này sẽ tự động đưa bạn đến với Instruments.

Ứng dụng Instruments bao gồm một bộ sưu tập các công cụ lập hồ sơ ghi lại các khía cạnh khác nhau của hệ thống và trực quan hóa dữ liệu được ghi lại trên dòng thời gian.

Mới trong năm nay là mẫu Game Memory có thể giúp bạn hiểu rõ hơn về sự phát triển bộ nhớ trong trò chơi Metal của mình.

Mẫu này đi kèm với các công cụ Phân bổ và Sự kiện Tài nguyên Kim loại để ghi lại phân bổ bộ nhớ với lịch sử, Trình theo dõi VM để ghi lại dấu chân bộ nhớ, Dấu vết bộ nhớ ảo để ghi lại hoạt động bộ nhớ ảo và Ứng dụng Kim loại và GPU để ghi lại các sự kiện liên quan đến Kim loại.

Và trong bản demo này, tôi sẽ làm nổi bật ba công cụ đầu tiên: Phân bổ, Sự kiện Tài nguyên Kim loại và Trình theo dõi VM.

Nhưng trước tiên, hãy ghi lại dấu vết cho trò chơi.

Bạn có thể nhấn nút ghi âm ở đây để bắt đầu ghi âm.

Và sau đó, để dừng ghi âm, bạn có thể nhấn cùng một nút hoặc đơn giản là thoát khỏi trò chơi.

Trong khi Instruments đang ghi lại Modern Renderer, hãy để tôi chỉ cho bạn một cách khác để ghi lại dấu vết.

Lệnh xctrace cho phép bạn thực hiện các bản ghi theo chương trình, điều này có thể hữu ích trong quy trình làm việc tự động hóa.

Ngoài ra, bạn có thể chỉ định tên thiết bị để chọn iPhone, iPad hoặc Apple TV làm mục tiêu.

Bây giờ tôi đã nắm bắt được dấu vết của Công cụ, trước tiên chúng ta hãy xem Phân bổ.

Công cụ Phân bổ cung cấp cho bạn cái nhìn chi tiết về phân bổ bộ nhớ, kích thước của chúng và số lượng tham chiếu đối tượng.

Tuy nhiên, nó không bao gồm các tài nguyên Metal tư nhân.

Chế độ xem Thống kê hiển thị tất cả các phân bổ đống và máy ảo ẩn danh.

All Heap Allocations bao gồm các bộ đệm malloc'ed có thể chứa các đối tượng và All Anonymous VM bao gồm các vùng VM thú vị có thể bị bẩn.

Và chúng ta sẽ thấy trong giây lát rằng một số tài nguyên Kim loại thuộc danh mục này.

Bây giờ, chúng ta hãy xem bên trong All Heap Allocations.

Thông thường, các phân bổ lớn hơn sẽ thú vị hơn để tối ưu hóa.

Để tìm phân bổ lớn nhất, bạn có thể nhấp vào cột Bảng Kích thước để sắp xếp phân bổ theo kích thước.

Để phân bổ, bạn có thể nhấp vào mũi tên này để xem các thay đổi số lượng tham chiếu cho các đối tượng Swift và Objective-C.

Và với phân bổ lớn này được chọn trong danh sách, có dấu vết ngăn xếp của lịch sử phân bổ trong trình kiểm tra.

Nhấp vào nút cho phép ẩn các thư viện hoặc khuôn khổ hệ thống.

Và ở đây, theo dấu vết ngăn xếp, việc phân bổ đã xảy ra khi Trình kết xuất hiện đại tải tài sản.

Nhấp đúp vào khung cũng có thể đưa bạn đến mã nguồn.

Bây giờ, chúng ta hãy quay lại và xem bên trong danh mục "All Anonymous VM".

Trong các trò chơi Metal, bạn có thể tìm thấy rất nhiều phân bổ trong danh mục IOAccelerator và IOSurface.

Phân bổ trong IOAccelerator tương ứng với tài nguyên kim loại.

Từ dấu vết ngăn xếp, bạn có thể thấy sự phân bổ này đã xảy ra trong khi tải tài sản.

Phân bổ trong IOSurface tương ứng với các bản vẽ.

Và ở đây, dấu vết ngăn xếp cho thấy chế độ xem MetalKit yêu cầu có thể vẽ được.

Công cụ Phân bổ, theo mặc định, trực quan hóa kích thước phân bổ.

Tuy nhiên, nó cũng đi kèm với vẻ ngoài thay thế.

Bạn có thể trên nút mũi tên trong bản nhạc Phân bổ để tùy chỉnh chế độ hiển thị để trực quan hóa Mật độ Phân bổ.

Điều này sẽ cập nhật biểu đồ để hiển thị cho bạn số lượng phân bổ được thực hiện theo thời gian và tiết lộ mức tăng đột biến cho phân bổ bộ nhớ.

Những đột biến này có thể là nguồn tăng trưởng trí nhớ.

Vì vậy, dữ liệu được hiển thị trong Phân bổ ở mức khá thấp.

Để hiểu rõ hơn về các tài nguyên Kim loại được phân bổ, hãy chuyển sang Sự kiện Tài nguyên Kim loại.

Công cụ Sự kiện Tài nguyên Kim loại được thiết kế xoay quanh Tài nguyên Kim loại.

Trong chế độ xem Sự kiện Tài nguyên, bạn có thể tìm thấy lịch sử phân bổ tài nguyên Kim loại và phân bổ giao dịch.

Tại đây, bạn cũng có thể xác định tài nguyên Metal bằng nhãn của chúng mà bạn có thể chỉ định theo chương trình thông qua Metal API.

Và tương tự như công cụ Phân bổ, bạn có thể tìm thấy dấu vết ngăn xếp cho lịch sử phân bổ trong trình kiểm tra.

Công cụ này cũng thêm phân bổ và theo dõi Deallocations dưới thiết bị Metal.

Chúng giúp hình dung mật độ của các sự kiện.

Cho đến nay, Phân bổ và Sự kiện Tài nguyên Kim loại có thể giúp hiểu được phân bổ bộ nhớ.

Tuy nhiên, việc phân bổ không phải lúc nào cũng chuyển thành dấu chân bộ nhớ.

Vì vậy, hãy chuyển sang VM Tracker để điều tra việc sử dụng bộ nhớ thực tế.

Thiết bị VM Tracker hiển thị bộ nhớ bẩn và nén hoặc hoán đổi không nén.

Kích thước bẩn đại diện cho bộ nhớ bẩn không nén.

Và Kích thước Hoán đổi đại diện cho bộ nhớ nén hoặc hoán đổi.

Trong bản ghi âm này, không có việc sử dụng bộ nhớ nén hoặc hoán đổi từ Trình kết xuất hiện đại.

Chế độ xem Tóm tắt chi tiết cho thấy các khu vực VM.

Và trong khu vực "tệp ánh xạ", bạn có thể tìm thấy một số tài nguyên ánh xạ bộ nhớ như nội dung trò chơi của mình.

Ở đây, Modern Renderer ánh xạ tệp nội dung quán rượu vào bộ nhớ.

Vì vậy, đó là tổng quan ngắn gọn về Phân bổ, Sự kiện Tài nguyên Kim loại và Trình theo dõi VM trong Công cụ.

Để nhanh chóng tóm tắt lại cách bạn có thể lập hồ sơ tăng trưởng bộ nhớ: Đầu tiên, chọn mẫu Bộ nhớ trò chơi, sau đó, ghi lại và phân tích dấu vết.

Đôi khi, bạn có thể lặp lại quá trình này một vài lần khi tái tạo hoặc xác minh các mẫu tăng trưởng bộ nhớ.

Chúng tôi hy vọng mẫu Bộ nhớ trò chơi mới có thể giúp bạn hiểu rõ hơn về việc phân bổ bộ nhớ hoặc tăng trưởng dấu chân trong trò chơi của mình.

Và vui lòng xem các video khác này để tìm hiểu thêm về cách sử dụng Dụng cụ.

Bây giờ, quay lại với Jack.

Mẫu bộ nhớ trò chơi trông rất tuyệt và nó sẽ rất hữu ích để giúp hiểu những thay đổi trong việc sử dụng bộ nhớ theo thời gian.

Ngoài ra, bạn cũng có thể muốn nắm bắt trạng thái bộ nhớ của trò chơi tại một thời điểm nhất định, vì vậy bạn có thể tìm hiểu sâu hơn về trạng thái bộ nhớ đó và kiểm tra nó thông qua các lăng kính khác nhau.

Và vì điều đó, chúng tôi có biểu đồ bộ nhớ và một bộ công cụ.

Biểu đồ bộ nhớ là một tệp để lưu trữ hiệu quả ảnh chụp nhanh hoàn chỉnh trạng thái bộ nhớ của trò chơi của bạn, bao gồm lịch sử tạo đối tượng, tài liệu tham khảo và bất kỳ nén hoặc hoán đổi nào.

Bạn có thể chụp nhanh bất cứ lúc nào bạn muốn, chẳng hạn như khi một vấn đề xảy ra, hoặc một cặp trong số đó, trước và sau khi một vấn đề xảy ra để so sánh.

Để thêm gia vị cho mọi thứ, hãy sử dụng một cuốn sách dạy nấu ăn tương tự về cách phân tích trí nhớ bằng biểu đồ bộ nhớ.

Nó bao gồm một thành phần và một phần chuẩn bị.

Đối với Thành phần, bạn sẽ cần trò chơi của mình; một thứ gọi là Ghi nhật ký ngăn xếp Malloc; và, một biểu đồ bộ nhớ được ghi lại.

Thật nhanh chóng để cấu hình Malloc Stack Logging và chụp biểu đồ bộ nhớ.

Malloc Stack Logging ghi lại thông tin phân bổ trong quá trình trò chơi.

Bạn có thể tìm thấy nó trong cài đặt Sơ đồ.

Chọn hành động Chạy, đi tới Chẩn đoán và đánh dấu vào hộp kiểm Ghi nhật ký ngăn xếp Malloc.

Trong trường hợp bạn tự hỏi hai tùy chọn là gì; Tất cả Phân bổ và Lịch sử Miễn phí theo dõi tất cả các đối tượng ngay cả sau khi chúng được phân bổ.

Dữ liệu ghi nhật ký có thể chiếm nhiều bộ nhớ hơn, nhưng nó hữu ích cho các vấn đề gỡ lỗi như phân mảnh.

Mặt khác, Phân bổ Trực tiếp Chỉ loại bỏ các đối tượng được phân bổ khỏi lịch sử của nó, vì vậy nó nhẹ hơn.

Trong trường hợp này, tôi chỉ đang điều tra các tài liệu tham khảo, trên các đối tượng trực tiếp, vì vậy tôi có thể chọn tùy chọn này.

Trên thực tế, hầu hết thời gian, Chỉ phân bổ trực tiếp sẽ là lựa chọn được đề xuất của bạn.

Ngoài ra, bạn có thể đặt biến môi trường nếu không khởi chạy từ Xcode.

Kiểm tra trang hướng dẫn sử dụng malloc để biết một số chế độ ghi âm bổ sung.

Sau đó, cũng chuẩn bị một biểu đồ bộ nhớ.

Chỉ cần nhấp vào nút biểu đồ bộ nhớ gỡ lỗi trong khu vực gỡ lỗi.

Xcode sẽ chụp nhanh bộ nhớ, xử lý nó và nhập trình gỡ lỗi bộ nhớ.

Xcode Memory Debugger cung cấp các quan điểm trực quan về việc sử dụng bộ nhớ của trò chơi.

Hãy dành một phút để khám phá khung cảnh.

Ở phía bên trái, Debug Navigator cung cấp cho bạn một danh sách phân cấp các trường hợp đối tượng.

Ở bên phải, Trình kiểm tra tệp cung cấp thông tin hữu ích như dấu chân bộ nhớ, thời gian hoạt động và ngày chụp.

Ở khu vực giữa chiếu sáng chế độ xem biểu đồ bộ nhớ nơi bạn có đối tượng đã chọn từ bên trái và cách các tham chiếu kết nối với đối tượng này.

Tôi sẽ quay lại biểu đồ này một chút.

Và menu Tệp cung cấp cho bạn tùy chọn lưu biểu đồ bộ nhớ này để phân tích trong tương lai hoặc dễ dàng chia sẻ với nhóm của bạn.

Đối với một trò chơi Mac, bạn cũng có thể chụp biểu đồ bộ nhớ với chương trình dòng lệnh rò rỉ, sử dụng ID quy trình hoặc tên.

Điều này có nghĩa là bạn có thể làm điều đó từ xa trong một trình bao an toàn, vì vậy con trỏ vẫn ở trong trò chơi, trong trường hợp trò chơi của bạn đang chạy toàn màn hình và cần tập trung.

Vì vậy, đó là những gì bạn sẽ cần để bắt đầu phân tích biểu đồ bộ nhớ.

Bây giờ là lúc để kiểm tra biểu đồ bộ nhớ này bằng cách sử dụng Trình gỡ lỗi bộ nhớ Xcode, cộng với một số công cụ dòng lệnh linh hoạt trong Terminal, để tìm ra phân bổ, dấu chân và hơn thế nữa.

Bước đầu tiên tốt là chia nhỏ việc sử dụng bộ nhớ theo danh mục.

Chương trình dấu chân thực hiện điều đó.

Dấu chân sử dụng thông tin trong biểu đồ bộ nhớ để tạo lại bản tóm tắt cấp cao này.

Thông thường, trước tiên bạn sẽ muốn tập trung vào các danh mục lớn hơn.

Đối với các biểu đồ bộ nhớ trò chơi như thế này từ mã mẫu Kết xuất Hiện đại, IOAccelerator thường là biểu đồ lớn nhất.

Như Seth đã nói, nó bao gồm tài nguyên Kim loại.

Ở đây, phân bổ đống đi đến một số danh mục MALLOC_(tiền tố), vì hệ thống nhóm phân bổ đống vào các nhóm kích thước để cải thiện hiệu suất.

Những đối tượng này có thể đến từ nhiều nơi, chẳng hạn như plugin của bên thứ ba hoặc thư viện, nơi trò chơi của bạn thực hiện hiệu ứng âm thanh hoặc mô phỏng vật lý.

Đây là biểu đồ bộ nhớ từ một trò chơi Apple Arcade tuyệt vời, Manifold Garden, được tạo ra bởi William "Cheer" Studio.

Tôi rất vui vì họ cho phép tôi cho bạn thấy việc sử dụng bộ nhớ của trò chơi.

Nếu trò chơi của bạn sử dụng công cụ trò chơi, như Manifold Garden sử dụng Unity hoặc bộ phân bổ tùy chỉnh trên bản đồ bộ nhớ, bộ nhớ đó sẽ được hiển thị dưới dạng VM_ALLOCATE không được gắn thẻ như thế này.

Đây là một mẹo chuyên nghiệp: trên nền tảng Apple, trò chơi của bạn có thể sử dụng tối đa 16 thẻ dành riêng cho ứng dụng, vì vậy bạn có thể rõ ràng hơn khi sử dụng bộ nhớ.

Nó dễ dàng như một sự thay đổi một dòng.

Đầu tiên, tạo thẻ từ một trong 16 tùy chọn.

Sau đó thay thế dấu trừ bằng thẻ mới này làm "mô tả tệp", khi gọi "em map".

Kiểm tra trang hướng dẫn sử dụng "bản đồ chúng" để tìm hiểu cách xác định các thẻ và danh mục.

Nếu bạn sử dụng "mach VM phân bổ", hãy bao gồm cùng một cờ trong đối số cờ khi phân bổ.

Trong chương trình thế giới dấu chân, kích thước bẩn cũng bao gồm hoán đổi và nén, vì vậy hãy nghĩ về nó như tổng phí cho mỗi danh mục.

Đó là một ý tưởng ngắn gọn về thành phần của việc sử dụng bộ nhớ hiện tại và cách nó tạo nên dấu chân.

Một số bộ nhớ này ít được sử dụng hơn và bị nén hoặc hoán đổi.

Chúng có thể là nguồn tiết kiệm bộ nhớ.

Bước tiếp theo là tìm hiểu xem trò chơi sử dụng bao nhiêu bộ nhớ nén hoặc hoán đổi và tối ưu hóa.

Đối với điều này, bạn có thể chạy biểu đồ bộ nhớ với vmmap.

Nó cung cấp cho bạn kích thước bẩn và hoán đổi, thay vì hai kích thước kết hợp.

Cột bẩn này bao gồm bộ nhớ bẩn thông thường hiện không được hoán đổi hoặc nén, trong khi cột được hoán đổi bao gồm kích thước ban đầu của bộ nhớ nén hoặc hoán đổi.

Hệ thống thêm hai cột này lại với nhau để xác định dấu chân.

Nhưng vì nội dung trong cột kích thước hoán đổi không được sử dụng thường xuyên, nó là một chỉ báo tốt cho những gì cần tìm để tối ưu hóa bộ nhớ trò chơi của bạn.

Ồ, nhân tiện, đây là kích thước phân bổ, với cột kích thước ảo.

Và kích thước cư trú bao gồm các trang sạch như tệp thực thi và tệp được ánh xạ bộ nhớ.

Thuận tiện, vmmap hiển thị phân bổ đống với một bảng riêng biệt.

Ở dưới cùng của đầu ra, vmmap nhóm bộ nhớ đống theo vùng.

Các khu vực này phản ánh việc sử dụng hoặc vòng đời của chúng trong trò chơi của bạn.

Bởi vì tôi đã bật MallocStackLogging, phân bổ trên đống nằm trong khu vực của công cụ.

Nếu không, chúng sẽ nằm trong hai vùng mặc định: MallocHelperZone và DefaultMallocZone, dựa trên kích thước phân bổ.

Và thông thường bạn có thể bỏ qua các khu vực tiện ích hệ thống nhỏ hơn như vùng QuartzCore.

Ngoài ra, nếu bạn nghi ngờ sự phân mảnh, được biểu thị bằng kích thước hoặc tỷ lệ phần trăm phân mảnh cao, như hàng chục hoặc hàng trăm megabyte, phiên WWDC 2021 bao gồm nhiều hơn về các vấn đề phân mảnh.

Và chạy vmmap mà không có tóm tắt dấu gạch ngang dấu gạch ngang hoặc để sử dụng vmmap ở chế độ tiêu chuẩn, hiển thị từng vùng vm trong các danh mục đó từng dòng một.

Giống như không gian địa chỉ ảo trông như thế nào, như chúng ta đã thảo luận trước đó.

Vì vậy, với vmmap, bạn có thể chắt lọc bộ nhớ bẩn ít được sử dụng hơn từ những bộ nhớ được sử dụng tích cực.

Và thông thường, cũng có một lượng lớn phân bổ động với nhiều kích cỡ khác nhau, hoặc sử dụng bộ nhớ đống trong trò chơi.

Họ cần một cái nhìn đặc biệt.

Công cụ đống nhóm các tài nguyên được phân loại theo các lớp của chúng và sắp xếp chúng theo số lượng phiên bản.

Các lớp này được xác định trong C++ với VTable, Objective-C hoặc Swift.

Chúng tôi đang sử dụng đối số —quiet để bỏ qua tiêu đề về một số siêu dữ liệu.

Mới trong năm nay, đống thông minh hơn trong việc xác định các loại đối tượng.

Nó sử dụng thông tin được ghi lại bởi Malloc Stack Logging để trình bày người gọi hoặc thư viện có trách nhiệm, vì vậy một đối tượng phi lớn đã là quá khứ.

Và đây là biểu đồ bộ nhớ từ Manifold Garden một lần nữa.

Trong ví dụ này, lần đầu tiên nó được tiết lộ mức độ sử dụng đống được sử dụng bởi các plugin như FMOD Studio và các thành phần trò chơi như GameAssembly.dylib.

Vì vậy, bây giờ bạn có thể được thông báo nhiều hơn về cách bộ nhớ được trải ra.

Và nó cũng gợi ý hướng đi để có thêm thông tin về các đối tượng này.

Trong ví dụ này, nhà phát triển có thể mở FMOD Studio để tinh chỉnh nhạc nền và hiệu ứng âm thanh trong trò chơi hoặc truy cập Unity để tìm kiếm tối ưu hóa mã trò chơi, v.v.

Đôi khi, việc sắp xếp theo tổng kích thước lớp thay vì số lượng phiên bản lớp sẽ hữu ích hơn.

Trong biểu đồ bộ nhớ của dự án mẫu Kết xuất Hiện đại, người đóng góp hàng đầu là một lớp sử dụng hơn 258 triệu byte.

Để tiếp tục tìm kiếm các đối tượng lớn hơn trong mẫu Kết xuất Hiện đại, hãy sử dụng heap để sắp xếp các đối tượng theo tổng kích thước lớp với —sortBySize và liệt kê tất cả các đối tượng với —showSizes, thay vì tóm tắt của từng lớp.

Và, có một đối tượng của NSConcreteMutableData trong Bytes Storage với kích thước 255 triệu byte: trông giống như một đối tượng đáng xem.

Tiếp theo, tôi muốn tìm hiểu nó là gì.

Và tôi muốn biết địa chỉ của nó để bắt đầu.

Tôi thêm —địa chỉ và nhập mẫu NSConcreteMutableData theo sau là ký tự đại diện- ngôi sao dấu chấm và bộ lọc kích thước trong ngoặc để chỉ liệt kê các đối tượng lớn từ 10 megabyte trở lên.

Và đây là địa chỉ của đối tượng.

Tôi sẽ sử dụng nó trong các bước sau để phân tích chuyên sâu hơn.

Vì vậy, đó là công cụ đống, với nhận dạng đối tượng được cải thiện cho các trường hợp.

Cho đến nay, bạn đã thấy ba công cụ để hiểu những đối tượng nào đang sử dụng bộ nhớ trong trò chơi và tất cả chúng đều cung cấp các chế độ xem khác nhau.

Những gì tôi cho thấy chỉ là một quy trình làm việc.

Tùy thuộc vào các mẫu bộ nhớ cụ thể hoặc công nghệ được sử dụng trong trò chơi của bạn, bạn có thể sử dụng chúng theo bất kỳ cách nào phù hợp với nhu cầu của mình.

Với những khám phá cho các đối tượng mà chúng ta không hoàn toàn chắc chắn về sự tồn tại của chúng, bước tiếp theo là lấy nguồn gốc của nó, đó là ngăn xếp cuộc gọi phân bổ của nó.

Trong trường hợp đối tượng 200 triệu byte trong Kết xuất hiện đại, tôi sử dụng chế độ —callTree và chuyển địa chỉ của nó đến malloc_history.

Cùng với đối số đảo ngược bổ sung, tôi có thể tập trung vào các chức năng gần nhất với phân bổ.

Và thì đấy.

Đây là dấu vết phía sau của việc phân bổ.

Tương tự, Xcode Memory Debugger cũng hiển thị lịch sử phân bổ của một đối tượng trong trình kiểm tra.

Chỉ cần chọn một đối tượng, nhấp vào Trình kiểm tra bộ nhớ và nó đây rồi.

Một ví dụ khác, chuyển VM_ALLOCATE làm mẫu lớp thay vì địa chỉ, để kiểm tra việc sử dụng VM ẩn danh trong trò chơi hoặc plugin của bạn, chẳng hạn như gỡ lỗi bộ phân bổ tùy chỉnh.

Cho dù sử dụng Xcode hay malloc_history, bạn có thể biết dấu vết phân bổ trở lại và quyết định xem bạn có muốn đào sâu hơn hay không, bao gồm cả việc đặt điểm dừng ở dòng, để bắt đầu.

Và cuối cùng nhưng không kém phần quan trọng, việc điều tra các tham chiếu đối tượng cũng rất hữu ích.

Biểu đồ bộ nhớ luôn ghi lại các tham chiếu đối tượng, ngay cả khi MallocStackLogging không được bật vì nhiều lý do.

Chúng tôi đã sử dụng rò rỉ trước đây để chụp biểu đồ bộ nhớ bên ngoài Xcode.

Rò rỉ làm được nhiều hơn thế.

Nó kiểm tra tất cả các tham chiếu trong biểu đồ bộ nhớ, và đó là lý do tại sao nó biết về rò rỉ và giữ lại các chu kỳ.

Leaks lấy cây tham chiếu này đến đối tượng bằng cách sử dụng đối số cây theo dõi và địa chỉ đối tượng từ đống.

Tuy nhiên, vì đây là một cái cây khá lớn trong ví dụ này, nên có một cách tốt hơn để xem nó hơn là trong Terminal.

Với Xcode 14, chúng tôi đã thiết kế lại chế độ xem biểu đồ bộ nhớ để hiển thị cả cạnh đi và đi của đối tượng đã chọn.

Nó thậm chí còn có một cửa sổ bật lên lựa chọn hàng xóm mới, để chọn các cạnh bạn muốn Xcode vẽ.

Điều này sẽ cải thiện đáng kể năng suất khi cố gắng hiểu các tham chiếu đối tượng trong các trạng thái trò chơi phức tạp.

Sau khi khám phá xung quanh một chút, tôi khá chắc chắn rằng trình quản lý kết cấu là thứ đang truy cập vào đối tượng này.

Đối với trò chơi của bạn, hãy cân nhắc sử dụng công cụ rò rỉ và chế độ xem biểu đồ bộ nhớ để tìm các mối quan hệ tham chiếu đối tượng quan trọng, để tìm hiểu cách các đối tượng này được truy cập trong trò chơi.

Vì vậy, làm thế nào để xem và tìm ra các tham chiếu quan trọng của một đối tượng bằng cách sử dụng rò rỉ hoặc Xcode.

Vui lòng xem trang hướng dẫn sử dụng của rò rỉ và trợ giúp Xcode để sử dụng nhiều hơn các công cụ này.

Trong sách dạy nấu ăn phân tích biểu đồ bộ nhớ này, mỗi bước sử dụng một số công cụ cụ thể.

Tất cả chúng làm việc cùng nhau để hoàn thành phân tích trên biểu đồ bộ nhớ.

Tóm lại, điều đầu tiên là bật MallocStackLogging khi bạn mong đợi chụp và phân tích bộ nhớ bằng biểu đồ bộ nhớ.

Sau đó chụp biểu đồ bộ nhớ bằng Xcode cho trò chơi của bạn hoặc sử dụng công cụ rò rỉ cho trò chơi Mac của bạn.

Tiếp theo, tìm những đồ vật lớn và rắc rối.

Dấu chân, vmmap và các công cụ đống cung cấp sự cố bộ nhớ, cả ở mức độ cao và chi tiết.

Với malloc_history, bạn có thể tìm ra nơi các đối tượng được phân bổ và rò rỉ có thể phân tích việc sử dụng hoặc tham chiếu đối tượng.

Các phiên trước đây bao gồm các hướng dẫn chuyên sâu cũng như các bản trình diễn về việc sử dụng nhiều hơn các công cụ này.

Cho đến bây giờ, chúng tôi đã hoãn việc thăm dò tài nguyên Kim loại.

Chà, bây giờ là lúc.

Để nói với bạn nhiều hơn, đây là Seth.

Xin chào lần nữa!

Trong các trò chơi, tài nguyên Metal có thể sử dụng một phần lớn bộ nhớ.

Nhưng có nhiều cách để tối ưu hóa việc sử dụng bộ nhớ của họ.

Ở đây tôi đã tóm tắt danh sách tiết kiệm bộ nhớ mà bạn có thể sử dụng khi tối ưu hóa tài nguyên Metal trong trò chơi của mình.

Chúng tôi sẽ xem xét cách Metal Debugger có thể giúp bạn kiểm tra tài nguyên và tìm hiểu một số kỹ thuật nâng cao để giảm hơn nữa bộ nhớ trò chơi của bạn.

Metal Debugger là cửa hàng một cửa để gỡ lỗi các trò chơi Metal của bạn.

Sau khi chụp khung GPU, bạn có thể tìm thấy một trang tóm tắt.

Điều này cung cấp cho bạn một số số liệu thống kê chung về khối lượng công việc đã nắm bắt.

Ở nửa dưới của trang, có một danh sách các thông tin chi tiết được chia thành bốn loại.

Thông tin chi tiết trong danh mục "Bộ nhớ" đề xuất tiết kiệm bộ nhớ cho trò chơi của bạn.

Không có nhiều thông tin chi tiết về bộ nhớ cụ thể cho dấu vết này; chúng ta có thể tiết kiệm chỉ một vài megabyte bộ nhớ sau khi giải quyết những thông tin chi tiết này.

Tuy nhiên, có thể tiết kiệm nhiều bộ nhớ hơn dành riêng cho trò chơi của bạn.

Để có được bức tranh hoàn chỉnh hơn về bộ nhớ được sử dụng bởi Metal resources, bạn có thể sử dụng Trình xem bộ nhớ bằng cách nhấp vào nút Hiển thị bộ nhớ.

Trình xem bộ nhớ cung cấp cho bạn danh sách đầy đủ các tài nguyên được thu thập từ trò chơi.

Nửa trên hiển thị các danh mục khác nhau để lọc.

Bạn có thể nhanh chóng sử dụng cái này để tra cứu tài nguyên, chẳng hạn như kết cấu.

Và ở nửa dưới, bảng chỉ hiển thị các kết cấu.

Hãy lấy bộ lọc ra ngay bây giờ.

Bảng tài nguyên có một bộ sưu tập các cột để giúp bạn tối ưu hóa trò chơi của mình.

Và tôi muốn làm nổi bật một vài cột có thể giúp bạn nhanh chóng xác định một số tài nguyên thú vị.

Cột Insights tương tự như những gì chúng ta vừa thấy trên trang tóm tắt.

Bạn có thể nhanh chóng xem tất cả các tài nguyên với thông tin chi tiết khi sắp xếp bảng theo cột này.

Và nhấp vào biểu tượng thông tin chi tiết sẽ hiển thị một cửa sổ bật lên giải thích việc tìm kiếm và cung cấp một số hành động có thể xảy ra.

Ngay bên cạnh cột này là Kích thước được phân bổ.

Bạn có thể sắp xếp theo cột này để xem các tài nguyên lớn nhất.

Có thể hữu ích khi kiểm tra xem một số tài nguyên có thực sự sử dụng tốt kích thước bộ nhớ của chúng hay không.

Ví dụ, một số kết cấu có thể được thay đổi kích thước thành độ phân giải nhỏ hơn và một số mô hình được tải trong bộ đệm có thể sử dụng số lượng poly thấp hơn, vì làm như vậy sẽ không ảnh hưởng đến chất lượng hình ảnh của trò chơi.

Có một số cách thay thế để tiết kiệm bộ nhớ kết cấu mà tôi sẽ đề cập trong một phút.

Một chuyên mục thú vị khác ở đây là Time Since Last Bound.

Bạn có thể sắp xếp các tài nguyên theo cột này để tìm tài nguyên chưa được sử dụng gần đây.

Nếu một tài nguyên không bao giờ được sử dụng, bạn nên kiểm tra kỹ xem nó có đáng để tải tài sản hay không.

Đối với một tài nguyên đã không bị ràng buộc trong một thời gian, bạn có thể cân nhắc phát hành nó nếu nó không được sử dụng lại trong tương lai.

Ngoài ra, bạn có thể đặt trạng thái có thể thanh lọc của nó thành dễ bay hơi.

Tài nguyên kim loại có thể ở một trong ba trạng thái có thể thanh lọc được: không bay hơi, dễ bay hơi và trống rỗng.

Theo mặc định, tài nguyên không bay hơi.

Bằng cách đặt trạng thái có thể thanh lọc thành dễ bay hơi, Metal có thể trục xuất tài nguyên khỏi bộ nhớ trong trường hợp áp suất bộ nhớ cao trong hệ thống.

Khi tài nguyên trống, hệ thống sẽ không còn sạc nó về phía dấu chân của trò chơi nữa.

Khi trò chơi của bạn cần tài nguyên một lần nữa, hãy kiểm tra xem nội dung có còn ở đó không và tải lại nếu cần.

Cân nhắc chỉ sử dụng dễ bay hơi cho các tài nguyên được sử dụng không thường xuyên, vì vậy trạng thái có thể thanh lọc không chống lại bạn.

Vì vậy, đó là một số ghi chú chung cho tất cả các tài nguyên.

Và bây giờ, chúng ta hãy xem xét kỹ hơn về kết cấu.

Không phải tất cả các cột đều được hiển thị theo mặc định trong Trình xem bộ nhớ.

Nhấp chuột phải vào tiêu đề bảng sẽ cho phép hiển thị và ẩn các cột như Định dạng Pixel của kết cấu.

Bạn có thể nhận được số tiền tiết kiệm khác nhau bằng cách tối ưu hóa định dạng pixel cho một kết cấu.

Nhiều kết cấu trong một trò chơi có thể sử dụng định dạng pixel chính xác một nửa bit để giảm việc sử dụng bộ nhớ và băng thông.

Trong trường hợp bạn cần một kết cấu với một thành phần alpha duy nhất, bạn có thể tránh nhiều kênh màu.

Và cuối cùng, một số kết cấu chỉ đọc có thể được hưởng lợi từ việc nén khối để sử dụng bộ nhớ thấp hơn.

Đối với các định dạng pixel nén khối, có các tùy chọn như ASTC và BC.

Ngoài ra, kể từ A15 Bionic, bạn có thể sử dụng nén mất dữ liệu cho kết cấu và hiển thị các mục tiêu để tiết kiệm bộ nhớ trong khi vẫn giữ được chất lượng bất cứ khi nào có thể.

Vui lòng xem các video trước đó để biết thêm chi tiết.

Và đó là một số tiết kiệm bộ nhớ mà bạn có thể nhanh chóng khám phá bằng cách sử dụng Trình xem bộ nhớ.

Nhưng có một vài kỹ thuật bổ sung bạn có thể thực hiện để tối ưu hóa hơn nữa trò chơi của mình.

Nếu một kết cấu chỉ được sử dụng bằng một lần, bạn có thể đặt chế độ lưu trữ của nó thành không bộ nhớ để tiết kiệm bộ nhớ và băng thông.

Các kết cấu không có bộ nhớ hoạt động tốt cho các mục tiêu kết xuất tạm thời, như chiều sâu, khuôn tô hoặc kết cấu đa mẫu.

Mặt khác, nếu kết cấu chỉ được sử dụng bởi GPU, bạn có thể đặt chế độ lưu trữ của nó thành riêng tư hoặc được chia sẻ hoặc quản lý.

Xin nhắc lại, chế độ quản lý không cần thiết trên Apple silicon Macs, giống như trên iPhone và iPad.

Đây là một ví dụ điển hình.

Trò chơi có kết cấu Depth32Float_Stencil8.

Kết cấu chiều sâu được sử dụng trên các đường chuyền, nhưng nội dung của kết cấu stprint bị loại bỏ và sẽ không được sử dụng sau này trong khung.

Vì vậy, thay vào đó, trò chơi có thể sử dụng hai kết cấu và làm cho kết cấu stprint không có bộ nhớ, để tiết kiệm bộ nhớ và băng thông.

Cuối cùng, tôi muốn đề cập đến một kỹ thuật khác có thể thú vị với bạn để tận dụng tối đa ký ức trong trò chơi của bạn.

Bạn có thể sử dụng các tài nguyên bí danh từ một đống nếu trò chơi của bạn không sử dụng chúng cùng một lúc.

Họ có thể chia sẻ bộ nhớ được hỗ trợ bởi cùng một phân bổ.

Nhưng hãy hết sức cẩn thận khi đồng bộ hóa quyền truy cập vào các tài nguyên đó.

Bạn có thể xem bài nói chuyện "Go bindless with Metal 3" để tìm hiểu thêm về cách sử dụng các tài nguyên được phân bổ từ một đống.

Vì vậy, điều đó kết thúc danh sách kiểm tra tiết kiệm bộ nhớ của chúng tôi.

Và tôi hy vọng danh sách kiểm tra này sẽ giúp bạn kiểm tra tài nguyên Metal trong trò chơi của mình.

Để tìm hiểu thêm về cách sử dụng Metal Debugger để tối ưu hóa bộ nhớ trò chơi của bạn, vui lòng xem các cuộc nói chuyện WWDC khác này.

Và trở lại với bạn, Jack.

Cảm ơn bạn, Seth.

Hôm nay, chúng tôi đã thực hiện một chuyến tham quan có hướng dẫn và khám phá nhiều điều thú vị mà bạn có thể làm để hiểu và cải thiện việc sử dụng bộ nhớ trong trò chơi của mình.

Đầu tiên, dấu chân bộ nhớ là thước đo chính để hiểu việc sử dụng bộ nhớ trong trò chơi của bạn và nó bao gồm bộ nhớ bẩn cộng với bộ nhớ nén và hoán đổi.

Sau đó, chúng tôi đã trải nghiệm các công cụ gỡ lỗi bộ nhớ mạnh mẽ.

Seth đã chỉ cho chúng ta cách Instruments trao quyền lập hồ sơ bộ nhớ với các bản nhạc đo từ xa hữu ích.

Mẫu Game Memory mới được thiết kế chính xác cho công việc này.

Sau đó, tôi đã trình bày biểu đồ bộ nhớ để lưu trữ ảnh chụp nhanh trạng thái bộ nhớ trò chơi.

Có các chương trình dòng lệnh linh hoạt và mạnh mẽ để phân tích biểu đồ bộ nhớ cho các đối tượng, tài liệu tham khảo và lịch sử phân bổ.

Những cải tiến trong công cụ đống và Trình gỡ lỗi bộ nhớ Xcode được thiết kế lại sẽ tăng cường phân tích bộ nhớ trò chơi.

Cuối cùng, Seth đã chia sẻ danh sách kiểm tra tiết kiệm bộ nhớ cho tài nguyên Metal và cách Metal Debugger có thể giúp trả lời các câu hỏi về việc sử dụng tài nguyên Metal trong trò chơi của bạn.

Bạn cũng có thể tìm hiểu thêm từ các phiên WWDC khác, tài liệu và các trang hướng dẫn sử dụng.

Chúng tôi không ngừng phát triển các công cụ tốt nhất và linh hoạt nhất cho bạn.

Vậy tại sao không thử chúng?

Chúng có thể chỉ là những gì bạn đang tìm kiếm.

Và đừng ngần ngại chia sẻ với chúng tôi bất kỳ phản hồi nào bạn có thể có, thông qua bất kỳ kênh nào như Trợ lý phản hồi.

Hãy vui vẻ trong hành trình ký ức của bạn, và cảm ơn vì đã xem. ♪ ♪