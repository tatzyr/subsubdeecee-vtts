10116

- Xin chào! Tôi là Kent và tôi là một kỹ sư trong nhóm CloudKit.

Tôi rất vui được giới thiệu một thư viện mới mà bạn có thể sử dụng để truy cập CloudKit.

Đầu tiên, tôi sẽ đề cập đến cách cấu hình thư viện mới này.

Và sau đó bạn sẽ học cách quản lý lược đồ của mình, cũng như cách truy cập dữ liệu người dùng với CKTool JS.

Hãy bắt đầu nào!

CloudKit là một công nghệ bền bỉ cho phép bạn lưu trữ dữ liệu ứng dụng của mình trong iCloud trong các vùng chứa.

Bằng cách sử dụng CloudKit trong ứng dụng của bạn, bạn cũng có thể cập nhật dữ liệu của mình trên các thiết bị và trên web.

Để xây dựng ứng dụng của bạn, bạn có thể truy cập bộ nhớ iCloud bằng cách sử dụng khung CloudKit trên nền tảng Apple hoặc CloudKit JS trên web.

Để triển khai tự động hóa và công cụ, Xcode cung cấp cktool để sử dụng trên macOS.

Và bây giờ bạn có một cách mới để tự động hóa các thay đổi và tương tác với iCloud, sử dụng CKTool JS.

CKTool JS cho phép bạn thực hiện các thao tác tương tự như tiện ích dòng lệnh cktool được giới thiệu trong Xcode 13 và hỗ trợ các trường hợp sử dụng tương tự.

Trên thực tế, CKTool JS được sử dụng để triển khai các tính năng trong Bảng điều khiển CloudKit như thêm các loại bản ghi và truy vấn bản ghi.

Với CKTool JS, bạn có thể quản lý các vùng chứa ứng dụng của mình và thực hiện các thao tác lược đồ, chẳng hạn như đặt lại và áp dụng các bản cập nhật cho lược đồ của mình.

Đây là điều mà bạn không thể làm từ JavaScript trước đây.

CKTool JS cho phép bạn tìm nạp các bản ghi hiện có bằng cách sử dụng mã định danh duy nhất của chúng hoặc thông qua các truy vấn phức tạp.

Và nó cho phép bạn tạo các bản ghi mới và cập nhật chúng.

CKTool JS đi kèm với các định nghĩa kiểu nghiêm ngặt cho TypeScript.

Các định nghĩa loại này cho phép kiểm tra thời gian biên dịch có gắn cờ sử dụng thư viện máy khách không chính xác và nó cho phép hoàn thành mã trong các IDE được hỗ trợ.

Bạn sẽ thấy việc chỉnh sửa mã CKTool JS dễ dàng hơn vì điều này.

Ngoài ra, thư viện mới này đi kèm với sự hỗ trợ cho cả Node.js và trình duyệt ngay lập tức.

CKTool JS được phân phối dưới dạng một tập hợp các gói npm, cho phép bạn tích hợp nó như một phần của quy trình xây dựng JavaScript của mình.

Làm như vậy cho phép các tính năng như rung cây và bó.

Bạn cũng có thể theo dõi các bản cập nhật cho các gói này vì lịch sử phát hành của chúng có sẵn một cách minh bạch từ npm.

Các gói sau đây là một phần của bản phân phối CKTool JS.

Lưu ý rằng các gói này nằm trong phạm vi @apple và tuân theo quy ước sử dụng cktool. ở đầu tên.

Gói chính mà bạn sẽ sử dụng là cktool.database.

Để cho phép giao tiếp với iCloud, bạn cũng sẽ cần sử dụng một gói khác cho nền tảng mục tiêu của mình, cktool.target.nodejs cho Node.js hoặc cktool.target.browser cho trình duyệt web.

Cktool.database tự động kéo thêm ba gói nữa-- cktool.core, cktool.api.base, và cktool.api.database.

Vì CKTool JS giao tiếp trực tiếp với iCloud, trước tiên nó phải được ủy quyền.

Tùy thuộc vào hoạt động mà bạn muốn gọi, bạn sẽ cần mã thông báo quản lý hoặc mã thông báo người dùng.

Cả hai loại mã thông báo đều có thể nhận được từ Bảng điều khiển CloudKit.

Mã thông báo quản lý được sử dụng để truy cập các hoạt động quản lý và được định phạm vi cho một nhóm và người dùng.

Các hoạt động như vậy bao gồm cho phép nhập và xuất lược đồ, xác thực lược đồ và đặt lại vùng chứa vào sản xuất.

Mã thông báo người dùng được định phạm vi cho các nhóm và vùng chứa và cho phép truy cập vào dữ liệu người dùng riêng tư trong các vùng chứa đó.

Để tìm hiểu cách lấy các mã thông báo ủy quyền này cũng như tích hợp liên tục với CloudKit, hãy xem "Tự động hóa các bài kiểm tra CloudKit với cktool và lược đồ khai báo" từ WWDC21.

Bất cứ khi nào bạn muốn sử dụng CKTool JS trong tập lệnh của mình, trước tiên bạn sẽ cần cấu hình nó để sử dụng.

Nhưng trước khi tôi đi sâu vào cấu hình CKTool JS, tôi sẽ xem xét nhanh những gì tạo nên lược đồ CloudKit.

Trong CloudKit, dữ liệu được lưu trữ theo cách có cấu trúc.

Dữ liệu có cùng loại giá trị được lưu trữ cùng nhau dưới dạng bản ghi.

Các bản ghi là các trường hợp của các loại bản ghi và các thuộc tính của bản ghi mà loại bản ghi mô tả được gọi là các trường.

Ngoài các trường do người dùng xác định của bạn, CloudKit thêm các trường hệ thống như recordName, là ID của bản ghi.

Tôi sẽ sử dụng các ví dụ từ một ứng dụng thu thập tiền xu mà tôi đang làm việc.

Tôi muốn lưu trữ một bộ sưu tập các quốc gia, vì vậy tôi có một loại hồ sơ để mô tả loại tài sản tôi cần lưu trữ cho họ.

Tôi đang lưu trữ tên và mã ISO, và tôi đang đặt tên cho loại bản ghi, "Các quốc gia".

Mã ISO xác định duy nhất một quốc gia, vì vậy điều quan trọng là phải đưa chúng vào loại hồ sơ của tôi.

Tôi tạo một số hồ sơ thuộc loại Quốc gia để lưu trữ thông tin này cùng với tên của họ.

Tôi cũng có một loại kỷ lục cho tiền xu của các quốc gia cụ thể và tôi muốn liên hệ chúng với nhau.

Loại bản ghi Coins lưu trữ mối quan hệ từ một đồng xu với quốc gia của nó.

Các loại bản ghi và mối quan hệ kết hợp để tạo thành một lược đồ.

Tôi có thể coi trạng thái hiện tại của các yếu tố này là phiên bản hiện tại của lược đồ của tôi.

Khi bạn phát triển các ứng dụng của mình, bạn sẽ phát triển lược đồ của mình và trong suốt vòng đời của ứng dụng, bạn có thể sẽ có một số phiên bản của nó.

Trong khi lược đồ ứng dụng của tôi mô tả cấu trúc của dữ liệu tôi muốn lưu trữ trong iCloud, vùng chứa ứng dụng của tôi là nơi dữ liệu đó được lưu trữ.

Một vùng chứa có một mã định danh duy nhất và được liên kết với một nhóm nhà phát triển.

Có hai môi trường cần ghi nhớ khi làm việc với CloudKit.

Môi trường phát triển là một nơi an toàn để thực hiện các thay đổi mà không làm gián đoạn người dùng.

Đây là nơi bạn nên kiểm tra và phát triển các thay đổi đối với lược đồ của mình.

Khi người dùng tương tác với ứng dụng của bạn, họ sẽ tương tác với môi trường sản xuất.

Môi trường sản xuất chứa dữ liệu trực tiếp cho ứng dụng của bạn.

Bây giờ tôi đã xem xét cách CloudKit lưu trữ dữ liệu, tôi sẽ đề cập đến cách định cấu hình CKTool JS.

Bởi vì CKTool JS nói chuyện với iCloud, bạn sẽ cần thu thập một vài thông tin để nó biết cách làm việc với vùng chứa phù hợp và tập lệnh của bạn được phép làm như vậy.

Bạn sẽ cần ID nhóm của mình và ID vùng chứa cho vùng chứa mà bạn muốn làm việc cùng.

Bạn sẽ cần một mã thông báo quản lý để làm việc với các lược đồ và nếu tập lệnh của bạn sẽ truy cập dữ liệu, bạn cũng sẽ cần một mã thông báo người dùng.

Tất cả các giá trị này có thể được lấy từ Bảng điều khiển CloudKit.

Bạn cũng sẽ cần chỉ định môi trường, sự phát triển hoặc sản xuất nào, tập lệnh của bạn sẽ chạy.

Tôi sẽ lấy sự phát triển làm ví dụ trong tương lai.

Bất cứ khi nào bạn định cấu hình CKTool JS để sử dụng, bạn sẽ cần những giá trị này.

Đối với các ví dụ của tôi, tôi đang viết kịch bản cho Node.js.

Bạn nhập các đối tượng và chức năng từ CKTool JS để sử dụng chúng.

Trong trường hợp này, bạn có thể nhập các ký hiệu này bằng cách sử dụng các câu lệnh yêu cầu CommonJS.

Khi bạn đã thu thập thông tin cấu hình của mình, bạn sẽ tạo các đối tượng để giữ thông tin đó.

Để lưu trữ mã thông báo xác thực của bạn, bạn tạo một đối tượng để giữ mã thông báo quản lý của mình và, nếu bạn có, mã thông báo người dùng của bạn.

Vì teamId, containerId và environment là những giá trị chung được chuyển đến CKTool JS, bạn có thể tạo một đối tượng để giữ các giá trị này.

Bạn khởi tạo một đối tượng Cấu hình cho CKTool JS biết cách nói chuyện với iCloud bằng cách sử dụng chức năng nhà máy createConfiguration.

createConfiguration dành riêng cho nền tảng.

Trong trường hợp này, nó sẽ trả về một cấu hình thích hợp cho Node.js, vì đó là chức năng đã được nhập từ gói đích.

Sau đó, bạn chuyển đối tượng cấu hình và đối tượng bảo mật được khai báo trước đó để khởi tạo đối tượng API.

Các đối tượng API chứa các phương thức không đồng bộ cho phép bạn nói chuyện với iCloud.

Bây giờ bạn đã hoàn thành các bước để sử dụng CKTool JS trong tập lệnh của mình.

Hãy cùng tìm hiểu về cách bạn có thể sử dụng CKTool JS để quản lý lược đồ vùng chứa của mình.

Trong ứng dụng của tôi, tôi muốn lưu trữ thông tin như một đồng xu Mỹ được phát hành vào năm 2007.

Đồng xu này bao gồm đồng và niken và giá trị được đóng dấu trên đó là 1/10 đô la Mỹ.

Sau khi suy nghĩ về cách lưu trữ dữ liệu này, tôi quyết định lưu trữ thông tin về thành phần của đồng xu dưới dạng hồ sơ tách biệt với các chi tiết khác về đồng xu.

Vì vậy, tôi lưu trữ tỷ lệ phần trăm đồng cho đồng xu và tỷ lệ phần trăm niken của nó trong các hồ sơ riêng biệt.

Tôi đã xác định được hai loại bản ghi mà tôi muốn trong lược đồ vùng chứa của mình.

Tiền xu, lưu trữ tham chiếu quốc gia, năm phát hành và giá trị danh nghĩa.

Và một loại bản ghi Thành phần lưu trữ tham chiếu đến một đồng xu mà nó mô tả và vật liệu và tỷ lệ phần trăm của nó trong đồng xu.

Bây giờ tôi đã xác định lược đồ cho ứng dụng của mình, tôi có thể tạo một tệp văn bản trong Ngôn ngữ lược đồ CloudKit để mô tả nó.

Quy ước là sử dụng phần mở rộng .ckdb cho tệp lược đồ của bạn.

Để biết thêm thông tin về Ngôn ngữ lược đồ CloudKit, hãy tham khảo bài viết tài liệu "Tích hợp lược đồ dựa trên văn bản vào quy trình làm việc của bạn".

Tệp lược đồ bạn tạo cho vùng chứa của mình có thể được áp dụng bằng CKTool JS.

Trước khi bạn áp dụng một lược đồ mới, bạn thường sẽ đặt lại lược đồ phát triển của vùng chứa để khớp với lược đồ đang sản xuất.

Bạn có thể làm điều này với phương pháp resetToProduction.

Bạn gọi phương thức này bằng cách chuyển đối tượng defaultArgs mà bạn đã khai báo trước đó.

Nếu lược đồ của bạn không được sản xuất, tất cả các loại bản ghi sẽ bị xóa.

Nếu không, điều này sẽ hoàn nguyên sơ đồ phát triển về trạng thái của môi trường sản xuất.

Lưu ý rằng đây là một cuộc gọi không đồng bộ, vì vậy phương thức này trả về một đối tượng hứa hẹn.

CKTool JS có các phương thức cho phép bạn xuất và nhập lược đồ vùng chứa của mình.

Các phương pháp exportSchema và importSchema cho phép bạn làm điều này và được đặt tên từ góc nhìn của vùng chứa.

Vì vậy, bạn tải xuống một lược đồ được xuất từ vùng chứa bằng exportSchema và bạn tải lên một lược đồ được nhập vào vùng chứa bằng importSchema.

Cùng với nhau, những thứ này cho phép bạn quản lý sự tiến hóa của lược đồ của mình.

Bạn có thể tạo một hàm trợ giúp để áp dụng lược đồ vào vùng chứa.

Đầu tiên, nhập đối tượng Tệp từ CKTool JS, sau đó nhập các mô-đun fs và đường dẫn từ Node.js.

Bây giờ xác định một hàm không đồng bộ sẽ thực hiện như sau: Nó đọc nội dung của tệp lược đồ vào bộ đệm Node.js.

Nó tạo ra một phiên bản Tệp CKTool JS để tải lên.

Cuối cùng, nó tải nội dung của tệp lên máy chủ bằng importSchema.

Lưu ý rằng đối tượng defaultArgs đã được khai báo trước đó được chuyển đến importSchema.

Bây giờ bạn có thể ghép nó lại với nhau.

Bởi vì resetToProduction và hàm trợ giúp được sử dụng để nhập lược đồ là không đồng bộ, bạn cần đảm bảo rằng chúng chạy theo đúng thứ tự.

Để làm điều đó bạn xâu chuỗi những lời hứa.

Nếu xảy ra lỗi, lời hứa sẽ từ chối.

Ngoài khả năng quản lý mà CKTool JS có, nó cũng cho phép bạn làm việc với việc đọc và ghi dữ liệu.

Các giá trị trường được sử dụng trong các bản ghi CKTool JS được kiểm tra loại và phạm vi ở phía máy khách trước khi chúng được gửi đến máy chủ.

Nếu giá trị được truyền vào không phải là loại giá trị phù hợp hoặc nằm ngoài phạm vi cho phép của giá trị, một ngoại lệ sẽ được ném ra.

Đối với những con số lớn không thể được biểu diễn nguyên bản trong JavaScript, có những loại CKTool JS được sử dụng thay thế.

Ví dụ, để ép một số với CKTool JS Int64, bạn sử dụng hàm toInt64.

Để ép một số thành giá trị dấu phẩy động Double, bạn sử dụng hàm toDouble.

Nếu bạn đang viết TypeScript, trình biên dịch sẽ gắn cờ cách sử dụng loại giá trị không chính xác nếu các hàm ép buộc này không được sử dụng.

Các giá trị trường trong các bản ghi CKTool JS được tạo bằng cách sử dụng các hàm nhà máy giá trị trường.

Đối với một đồng tiền được phát hành vào năm 2007, tôi sẽ chuyển giá trị đó cho hàm nhà máy makeRecordFieldValue.int64 để tạo giá trị trường bản ghi có chứa Int64.

Nói chung, nếu một hàm nhà máy không thể tạo giá trị trường bản ghi từ giá trị được truyền vào, nó sẽ ném một ngoại lệ.

Ở đây, tôi đã tạo một đối tượng để giữ các giá trị chung mà tôi gửi đến các phương thức hoạt động với các bản ghi.

Vì containerId, môi trường, loại cơ sở dữ liệu và tên vùng thường được yêu cầu, tôi bao gồm những thứ đó trong đối tượng databaseArgs này.

Để truy vấn các bản ghi, tôi sử dụng phương thức queryRecords.

Để làm điều này dễ dàng hơn, tôi tạo một hàm trợ giúp để tìm một quốc gia phù hợp với mã ISO 3 ký tự duy nhất của nó.

Trong trường hợp này, tôi chuyển nội dung của đối tượng databaseArgs, ngoài nội dung chứa truy vấn.

Đối với đối tượng truy vấn, tôi đang chỉ định giá trị recordType cũng như một đối tượng bộ lọc duy nhất.

Đối tượng bộ lọc mô tả một truy vấn trong đó isoCode3 của quốc gia bằng với truy vấn mà hàm này đang tìm kiếm.

Nếu thành công, việc thu thập các bản ghi được tìm thấy sẽ nằm trong thuộc tính response.result.records.

Tôi trả lại đối tượng đầu tiên từ bộ sưu tập này.

Để chuyển đổi các giá trị thô thành các giá trị trường mà createRecord có thể sử dụng, tôi có một hàm trợ giúp được gọi là makeCoinFieldValues để thực hiện việc này.

Đối với mỗi thuộc tính thô cho đồng tiền của tôi mà tôi muốn chuyển đổi thành các giá trị trường, tôi gọi hàm nhà máy RecordFieldValue thích hợp.

Tuy nhiên, đối với lĩnh vực quốc gia, tôi cần tạo một tài liệu tham khảo.

Tôi sử dụng tên bản ghi quốc gia được thông qua để tham chiếu từ bản ghi đồng xu này đến bản ghi quốc gia tương ứng.

Ở đây, tôi tạo một hàm trợ giúp nhận các giá trị trường bản ghi đồng xu và gửi yêu cầu createRecord đến máy chủ.

Trong chức năng này, tôi đang chuyển nội dung của databaseArgs được khai báo trước đó và một nội dung.

Từ điển nội dung chứa các giá trị recordType và trường.

Nếu thành công, response.result.record sẽ được trả về.

Trước khi gọi hàm trợ giúp, tôi cần tìm nạp bản ghi quốc gia chính xác sẽ được tham chiếu từ đồng tiền này.

Tôi sử dụng hàm truy vấn quốc gia được xác định trước đó.

Sau đó tôi gọi coinCreateRecord bằng cách chuyển cho nó một từ điển giá trị trường được tạo bằng hàm trợ giúp makeCoinFieldValues mà tôi đã viết trước đó.

Các giá trị đồng xu thô được chuyển đến hàm trợ giúp đó.

Điều này sẽ tạo bản ghi không đồng bộ và trả về bản ghi mới.

Để cập nhật bản ghi, hãy sử dụng phương pháp updateRecord.

Tôi tạo một chức năng trợ giúp cập nhật một đồng xu khớp với tên bản ghi với các trường được chuyển cho trình trợ giúp này.

Sau đó tôi gọi updateRecord với nội dung của đối tượng databaseArgs, recordName và nội dung chứa loại bản ghi và các giá trị trường của bản ghi mới.

Nếu thành công, bản ghi được cập nhật sẽ nằm trong thuộc tính response.result.record, mà tôi trả về từ hàm trợ giúp.

Để cập nhật bản ghi đồng xu mà tôi đã tạo trước đó, tôi gọi hàm trợ giúp này chuyển tên bản ghi và giá trị trường của nó để cập nhật.

Các giá trị trường được tạo bằng makeCoinFieldValues.

Để xóa một bản ghi, tôi gọi phương thức deleteRecord không đồng bộ trên đối tượng API.

Tôi chuyển nội dung của đối tượng databaseArgs cũng như recordName của bản ghi để xóa.

Tôi hy vọng bạn thích làm quen với CKTool JS.

Hãy tự mình dùng thử: Định cấu hình CKTool JS cho mục đích tự động hóa và công cụ của bạn.

Đặt lại và nhập lược đồ của bạn cũng như đọc và ghi dữ liệu của bạn bằng JavaScript.

Để sử dụng CKTool JS trong các tình huống tích hợp liên tục, hãy xem repo mẫu CloudKit trên GitHub.

Và để có tài liệu chi tiết hơn, hãy xem CKTool JS trên developer.apple.com.

Cảm ơn vì đã tham gia cùng tôi hôm nay, và tận hưởng phần còn lại của WWDC22.