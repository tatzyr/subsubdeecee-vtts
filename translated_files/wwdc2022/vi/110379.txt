110379

♪ ♪

Jeremy: Xin chào. Tôi là Jeremy, và tôi ở đây để chỉ cho bạn cách tạo một ứng dụng đa phương tiện nhạy hơn bằng AVFoundation.

Khi sử dụng nội dung đa phương tiện trong ứng dụng của bạn, bạn có thể muốn làm nhiều hơn là chỉ chơi chúng.

Bạn có thể muốn hiển thị hình thu nhỏ, kết hợp phương tiện thành các tác phẩm mới hoặc nhận thông tin về tài sản của mình.

Những nhiệm vụ này yêu cầu tải dữ liệu và với các tệp lớn như video, có thể mất một thời gian để hoàn thành.

Thật không may, có thể dễ dàng giới thiệu các vấn đề về độ trễ trong ứng dụng của bạn nếu công việc này được thực hiện đồng bộ trên luồng chính.

Một cách tuyệt vời để giữ cho ứng dụng của bạn đáp ứng là tải dữ liệu không đồng bộ và cập nhật giao diện người dùng của bạn khi hoàn tất.

AVFoundation có các công cụ để làm điều này trở nên dễ dàng.

Vì vậy đây là những gì chúng ta sẽ nói về ngày hôm nay.

Đầu tiên, tôi sẽ giới thiệu cho bạn một số API không đồng bộ mới trong AVFoundation.

Sau đó, tôi sẽ cung cấp cho bạn thông tin cập nhật về việc kiểm tra tài sản bằng cách sử dụng phương pháp tải không đồng bộ (_:) mà chúng tôi đã giới thiệu vào năm ngoái.

Và tôi sẽ chỉ cho bạn cách tối ưu hóa việc tải dữ liệu tùy chỉnh cho phương tiện cục bộ và được lưu trong bộ nhớ cache bằng AVAssetResourceLoader.

Nhưng trước tiên, hãy nhảy vào API không đồng bộ mới.

Lấy hình ảnh tĩnh từ video với AVAssetImageGenerator là một cách tuyệt vời để tạo hình thu nhỏ.

Nhưng việc tạo ra hình ảnh không phải là tức thời.

Để tạo ra một hình ảnh, trình tạo hình ảnh cần tải dữ liệu khung hình từ tệp video của bạn.

Và đối với phương tiện được lưu trữ trên máy chủ từ xa hoặc trên internet, việc tải đó sẽ chậm hơn nhiều.

Đó là lý do tại sao điều quan trọng là cách bạn tạo ra hình ảnh của mình.

Sử dụng phương pháp tải dữ liệu đồng bộ, như copyCGImage, trên luồng chính có thể khiến giao diện người dùng của bạn bị đóng băng khi chờ video được tải.

Năm nay, chúng tôi đã thêm phương thức không đồng bộ hình ảnh (tại: thời điểm) sử dụng async/await để giải phóng chuỗi gọi trong khi trình tạo hình ảnh tải dữ liệu.

Trình tạo hình ảnh trả về một bộ với hình ảnh và thời gian thực tế của nó trong tài sản.

Có một vài lý do khiến thời gian thực tế có thể thay đổi so với thời gian bạn yêu cầu, nhưng nếu bạn chỉ muốn hình ảnh, bạn có thể truy cập trực tiếp vào nó bằng thuộc tính .image.

Một số khung hình trong video nén dễ tải hơn những khung hình khác.

iFrames có thể được giải mã độc lập, trong khi các khung khác dựa vào các khung gần đó để giải mã.

Trong thời gian bạn yêu cầu, trình tạo hình ảnh theo mặc định sẽ sử dụng iFrame gần nhất để tạo hình ảnh của bạn.

Có thể rất hấp dẫn khi đặt dung sai về 0 để có được khung chính xác cho thời gian bạn yêu cầu.

Nhưng hãy nhớ rằng khung hình đó có thể sẽ phụ thuộc vào các khung hình khác gần đó mà trình tạo hình ảnh cũng sẽ cần tải.

Thay vào đó, hãy cân nhắc thiết lập dung sai rộng mà vẫn sẽ mang lại cho bạn kết quả mà bạn đang tìm kiếm.

Dung sai rộng giúp trình tạo hình ảnh giảm thiểu tải dữ liệu bằng cách cung cấp cho nó nhiều khung hình hơn để chọn.

Càng ít khung hình cần tải, nó càng có thể trả lại hình ảnh nhanh hơn.

Để có được một loạt hình ảnh nhiều lần trong một tài sản, trình tạo hình ảnh đã tạo raCGImagesAsynchronously(forTimes:).

Tuy nhiên trong Swift, có một số sắc thái cần chú ý khi sử dụng nó.

Mới trong năm nay chúng tôi đã thêm phương pháp hình ảnh (cho: thời gian).

Bây giờ phải mất một mảng CMTimes, vì vậy bạn không cần phải ánh xạ chúng đến NSValues trước.

Nó cũng cung cấp kết quả của nó bằng cách sử dụng Trình tự không đồng bộ.

Trong Swift, các chuỗi cho phép bạn lặp lại các mục của chúng bằng cách sử dụng vòng lặp for in.

Đối với một chuỗi các mục chưa sẵn sàng cùng một lúc, một chuỗi không đồng bộ cho phép bạn chờ đợi phần tử tiếp theo sau mỗi lần lặp.

Đối với mỗi hình ảnh được tạo thành công, kết quả bao gồm thời gian được yêu cầu ban đầu và thời gian thực tế cùng với hình ảnh.

Nếu nó thất bại, kết quả có lỗi để giải thích tại sao.

Và nếu bạn chỉ quan tâm đến hình ảnh, kết quả có các thuộc tính để truy cập trực tiếp vào các giá trị của nó, điều này cũng có thể gây ra lỗi nếu việc tạo không thành công.

Để tìm hiểu thêm về các chuỗi không đồng bộ, tôi khuyên bạn nên kiểm tra phiên "gặp gỡ chuỗi không đồng bộ".

Đối với một nhiệm vụ như tạo hình ảnh, sẽ dễ dàng hơn một chút để xem nó liên quan đến việc tải dữ liệu như thế nào.

Nhưng có một số lĩnh vực đồng bộ khác của AVFoundation khó chọn ra làm điểm có vấn đề hơn.

AVMutableComposition là một trong những lĩnh vực này.

Chèn phạm vi thời gian cho thông tin nhu cầu tài sản về các bản nhạc của tài sản để thêm tham chiếu đến chúng trong bố cục.

Nó kiểm tra đồng bộ các bản nhạc, vì vậy nếu các bản nhạc chưa được tải, chúng sẽ được tải đồng bộ để tạo ra các bản nhạc sáng tác mới.

Trước đây, giải pháp sẽ là chờ tải các bản nhạc của tài sản trước khi chèn chúng vào bố cục.

Tuy nhiên, năm nay, chúng tôi sẽ giới thiệu một phiên bản không đồng bộ của insertTimeRange, phiên bản này sẽ tải không đồng bộ các bản nhạc cho bạn, nếu cần.

Thành phần video và thành phần video có thể thay đổi cũng có các phương pháp bổ sung yêu cầu tải các thuộc tính của tài sản.

Mới trong năm nay, hàm tạo "propertiesOf asset" và phương thức isValid(for:timeRange:) hiện cũng có các đối tác không đồng bộ.

Những phương pháp mới này sẽ tải không đồng bộ các bản nhạc và thời lượng của tài sản, vì vậy bạn cũng không cần tải trước chúng.

Các phương pháp không đồng bộ mới này giúp tương tác với tài sản dễ dàng hơn bằng cách tải các thuộc tính mà chúng cần không đồng bộ.

Nhưng khi bạn cần tự tải các thuộc tính của một tài sản, hãy làm mới việc kiểm tra tài sản không đồng bộ.

Bạn có thể nhận thấy có hai cách để kiểm tra tài sản của tài sản.

Khi AVFoundation được giới thiệu, cách tốt nhất để kiểm tra các thuộc tính là tải giá trị khóa không đồng bộ.

Năm ngoái, chúng tôi đã giới thiệu async load(_:).

Nó sử dụng các khóa an toàn kiểu để xác định các thuộc tính cần tải, trong đó kỹ thuật tải giá trị khóa không đồng bộ cũ sử dụng các chuỗi được mã hóa cứng làm khóa.

Lỗi chính tả trong các phím chuỗi này rất khó nắm bắt.

Lỗi chính tả một khóa ngăn không cho nó được tải không đồng bộ và khi thuộc tính được sử dụng sau đó, nó sẽ chặn trong khi tải.

Cũng rất dễ quên thêm các thuộc tính mới vào các phím để tải hoặc quên tải chúng hoàn toàn không đồng bộ.

Vì những lý do này, năm nay, chúng tôi đang phản đối việc tải giá trị khóa không đồng bộ và các thuộc tính đồng bộ trong Swift, ủng hộ tải không đồng bộ.

Tải không đồng bộ sử dụng các định danh an toàn loại để ngăn chặn lỗi chính tả.

Nó trực tiếp trả về các giá trị thuộc tính theo yêu cầu để tránh truy cập các thuộc tính chưa tải.

Và vì tất cả những điều này được kiểm tra tại thời điểm biên dịch, bạn sẽ ngăn chặn việc giới thiệu bất kỳ vấn đề hiệu suất ràng buộc IO mới nào.

Tải không đồng bộ hiện là cách duy nhất được đề xuất để kiểm tra không đồng bộ các thuộc tính trên AVAsset, AVAssetTrack, AVMetadataItem và các lớp con của chúng.

Tuy nhiên, một số ít các lớp này vẫn sẽ cung cấp kiểm tra tài sản đồng bộ.

Đó là bởi vì dữ liệu cho các thuộc tính của họ đã có sẵn trong bộ nhớ.

Chúng ta hãy xem lại thành phần có thể thay đổi để xem tại sao.

Chúng tôi sẽ sử dụng một bố cục có thể thay đổi để ghép các phân đoạn của hai bản nhạc video hiện có lại với nhau.

Chúng ta sẽ bắt đầu bằng cách tạo một bố cục trống và thêm một đoạn video trống.

Sau đó, chúng ta có thể chèn đồng bộ một phần của đoạn video đầu tiên vào bản nhạc sáng tác.

Đằng sau hậu trường, bước này không tải bất kỳ dữ liệu nào.

Thay vào đó, nó thêm một phân đoạn bản nhạc mới trỏ đến bản nhạc mong muốn.

Sau đó, chúng ta có thể nối thêm một phần của bản nhạc thứ hai theo cùng một cách.

Vì bản thân thành phần được hỗ trợ bởi cấu trúc bộ nhớ chứ không phải tệp, chúng tôi có thể kiểm tra các thuộc tính của nó một cách an toàn đồng bộ mà không cần tải chúng trước.

Một lần nữa, vì lý do này, kiểm tra tài sản đồng bộ sẽ vẫn có sẵn trên các lớp này và tất cả các lớp sẽ sử dụng tải không đồng bộ để kiểm tra không đồng bộ.

Tất cả các phương pháp không đồng bộ mới này trong AVFoundation sẽ giúp ngăn chặn chặn dễ dàng hơn trong khi tải dữ liệu phương tiện.

Tuy nhiên, lần đầu tiên giới thiệu đồng thời vào ứng dụng của bạn có thể khó khăn.

Kiểm tra các phiên này từ WWDC 21 để được trợ giúp bắt đầu với Swift đồng thời và để chuyển sang tải không đồng bộ của AVFoundation trong ứng dụng của bạn.

Đối với chủ đề cuối cùng của chúng tôi, hãy nói về việc tối ưu hóa việc tải dữ liệu tùy chỉnh cho tài sản của bạn.

Để bắt đầu, hãy xem cách AVAsset tải dữ liệu theo mặc định.

Khi bạn tạo một AVAsset với một URL, phương tiện có thể ở trên mạng hoặc được lưu trữ cục bộ trên thiết bị.

Nếu nó ở trên mạng, AVAsset sẽ tự động lưu trữ một lượng dữ liệu nhất định để đảm bảo phát lại mượt mà.

Nếu phương tiện là cục bộ, AVAsset có thể bỏ qua bộ nhớ cache và tải dữ liệu khi cần thiết để phát.

Trong một số trường hợp, bạn có thể không cung cấp cho AVAsset một con trỏ trực tiếp đến phương tiện của bạn.

Có thể bạn lưu trữ các byte thô của mp4 bên trong tệp dự án tùy chỉnh.

Đối với những tình huống như thế này, AVAsset có thể sử dụng AVAssetResourceLoader.

Trình tải tài nguyên cung cấp cho tài sản một cách để yêu cầu các byte tùy ý từ phương tiện của bạn mà bạn có một cách đặc biệt để tải.

Nhưng vì tài sản không còn xử lý việc đọc dữ liệu, nên nó không thể dự đoán mỗi đoạn sẽ mất bao lâu để tải.

Vì vậy, nó giả định rằng việc truy cập phương tiện liên quan đến giao tiếp mạng và đợi cho đến khi nó lưu trữ dữ liệu trước khi nó sẵn sàng phát.

Năm nay, nếu phương tiện của bạn có sẵn cục bộ, bạn có thể bật wholeLengthAvailableOnDemand cho trình tải tài nguyên của mình.

Đặt cờ này cho nội dung biết rằng nó có thể mong đợi nhận được dữ liệu theo yêu cầu, vì vậy nó có thể bỏ qua bộ nhớ đệm.

Đối với phương tiện truyền thông địa phương, wholeLengthAvailableOnDemand có thể giúp giảm mức sử dụng bộ nhớ của ứng dụng của bạn trong quá trình phát lại, vì nó sẽ không cần lưu trữ thêm dữ liệu.

Nó cũng có thể giảm thời gian cần thiết để bắt đầu phát lại, vì nội dung sẽ không phải đợi bộ nhớ cache lấp đầy trước.

Tuy nhiên, hãy thận trọng khi bật cờ này.

Nếu việc tải yêu cầu bất kỳ hoạt động mạng nào, bao gồm lưu trữ tệp mạng, có khả năng phát lại sẽ không đáng tin cậy.

Đó là cải tiến mới cho trình tải tài nguyên.

Bây giờ hãy kết thúc mọi thứ với một số bước tiếp theo cho ứng dụng của bạn.

Khi làm việc với phương tiện truyền thông, hãy sử dụng async/await để giữ cho ứng dụng của bạn phản hồi trong khi nó tải ở chế độ nền.

Cân nhắc tăng dung sai khi sử dụng trình tạo hình ảnh để có kết quả nhanh hơn.

Và nếu bạn đang sử dụng trình tải tài nguyên cho phương tiện có sẵn cục bộ, hãy bật toàn bộ chiều dài có sẵn theo yêu cầu để giúp tăng hiệu suất.

Đó là tất cả những gì tôi có cho ngày hôm nay.

Cảm ơn vì đã xem, và tận hưởng WWDC 22.