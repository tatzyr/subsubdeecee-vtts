10090

- Xin chào, và chào mừng đến với Có gì mới trong TextKit và chế độ xem văn bản!

Tôi là Donna Tom, và tôi là một kỹ sư TextKit.

Trong iOS 15 và macOS Monterey, chúng tôi đã giới thiệu TextKit 2, một công cụ văn bản mới mạnh mẽ với hiệu suất, độ chính xác và độ an toàn được cải thiện.

Kiến trúc bố cục dựa trên khung nhìn của TextKit 2 cung cấp bố cục văn bản hiệu suất cao, đặc biệt là đối với các tài liệu có nội dung lớn.

TextKit 2 cung cấp trải nghiệm văn bản tốt hơn cho khán giả quốc tế bằng cách loại bỏ sự phức tạp không cần thiết khi làm việc với glyphs và nó hỗ trợ đầy đủ cho các công nghệ phông chữ hiện đại như OpenType và Variable Fonts.

Và TextKit 2 tập trung vào việc với các đối tượng cấp cao hơn để kiểm soát bố cục văn bản giúp bạn dễ dàng tùy chỉnh bố cục văn bản của mình hơn để bạn có thể xây dựng những thứ thú vị hơn với ít mã hơn.

Trong tương lai, công cụ TextKit 2 tạo thành nền tảng của bố cục văn bản và kết xuất trên tất cả các nền tảng của Apple.

Các cải tiến, cập nhật và cải tiến hiệu suất trong tương lai đều sẽ tập trung vào công cụ TextKit 2.

Bằng cách cập nhật lên TextKit 2, ứng dụng của bạn có thể nhận được những lợi ích của những cải tiến này khi chúng tôi triển khai chúng.

Để có phần giới thiệu chuyên sâu về TextKit2, hãy xem video Meet TextKit2.

Video đó bao gồm các nguyên tắc cơ bản và cách xây dựng các thành phần bố cục văn bản của riêng bạn bằng TextKit 2.

Ngược lại, video này đề cập đến những tiến bộ mới nhất trong TextKit 2 và cách tận dụng tối đa chế độ xem văn bản được hỗ trợ 2 của TextKit.

Đúng vậy, tôi đã nói chế độ xem văn bản, số nhiều, bởi vì bây giờ, kể từ iOS 16 và macOS Ventura, tất cả các điều khiển văn bản trong UIKit và AppKit đang sử dụng TextKit 2, bao gồm UITextView.

Vì vậy, chúng tôi đang sử dụng TextKit 2 để bố trí và kết xuất tất cả trong toàn hệ thống.

Điều quan trọng là tất cả các ứng dụng phải chuyển sang TextKit 2 càng sớm càng tốt và chúng tôi đã thêm một số công cụ để giúp bạn chuyển đổi dễ dàng hơn.

Đối với nhiều ứng dụng, đây có thể là một quá trình chuyển đổi mã bằng không.

Và chúng tôi hy vọng điều này sẽ đúng với các ứng dụng không thực hiện bất kỳ sửa đổi đặc biệt nào đối với chế độ xem văn bản của chúng.

Tôi sẽ nói với bạn thêm một chút về điều đó sau.

Nhưng trước tiên, tôi sẽ bắt đầu bằng cách xem xét những gì mới trong TextKit 2, bao gồm một số công cụ mà tôi vừa đề cập.

Sau đó, tôi sẽ đi sâu vào chi tiết của chế độ tương thích TextKit 1 cho chế độ xem văn bản.

Sau đó, tôi sẽ kết thúc với một cuộc thảo luận về các chiến lược hiện đại hóa mà bạn có thể sử dụng khi chuẩn bị chuyển mã của mình sang TextKit 2.

Vì vậy, đầu tiên là những gì mới trong TextKit 2.

TextKit 2 lần đầu tiên xuất hiện trên UIKit trong iOS 15, nơi UITextField được nâng cấp để sử dụng nó.

Trong iOS 16, quá trình chuyển đổi UIKit sang TextKit 2 đã hoàn tất, với tất cả các điều khiển văn bản sử dụng TextKit 2 theo mặc định, bao gồm UITextView.

Hầu hết các chế độ xem văn bản sẽ được tự động chọn tham gia TextKit 2, không yêu cầu bạn chấp nhận.

Chỉ có một vài tình huống mà lượt xem văn bản có thể không được chọn tham gia và tôi sẽ đề cập đến điều đó trong phân đoạn tương thích của video này.

Và đó là một câu chuyện tương tự cho AppKit.

TextKit 2 lần đầu tiên xuất hiện trên AppKit trong macOS Big Sur.

Trong macOS Monterey, NSTextField đã được nâng cấp để sử dụng nó theo mặc định và nó có sẵn cho NSTextView bằng cách chọn tham gia.

Trong macOS Ventura, tất cả các điều khiển văn bản đều sử dụng TextKit 2 theo mặc định.

Cũng giống như UITextView, hầu hết NSTextViews đều tự động chọn tham gia TextKit 2 và không yêu cầu bạn chấp nhận.

TextEdit, một trình bao bọc mỏng xung quanh NSTextView, sử dụng TextKit 2 ở mọi nơi trong macOS Ventura.

TextEdit đã sử dụng TextKit 2 ở chế độ văn bản thuần túy kể từ macOS Big Sur.

Trong macOS Ventura, chế độ văn bản phong phú cũng sử dụng TextKit 2.

Vì TextKit 2 là tiêu chuẩn mới, chúng tôi đã thêm một số hàm tạo tiện lợi cho cả UITextView và NSTextView.

Sử dụng các hàm tạo mới này để chọn vào thời điểm khởi tạo công cụ văn bản nào sẽ sử dụng.

Để tạo chế độ xem văn bản sử dụng TextKit 2, hãy sử dụng hàm tạo mới và chuyển true cho tham số "UsingTextLayoutManager".

Nếu chế độ xem văn bản cần sử dụng TextKit 1 để tương thích, hãy chuyển "sai" thay thế.

Và có một tùy chọn Bố cục Văn bản mới cho các chế độ xem văn bản được tạo trong Trình tạo Giao diện.

Tùy chọn mới này cung cấp cho bạn quyền kiểm soát hệ thống bố cục nào để sử dụng trên cơ sở từng trường hợp.

Cài đặt mặc định là hệ thống mặc định, đó là TextKit 2.

Bạn cũng có thể chọn sử dụng TextKit 2 hoặc TextKit 1 một cách rõ ràng.

TextKit 2 hiện hỗ trợ các vùng chứa văn bản không đơn giản.

Các vùng chứa văn bản không đơn giản có thể có lỗ hoặc khoảng trống trong đó.

Điều này cho phép văn bản bao quanh hình ảnh hoặc nội dung nội tuyến khác.

Để tạo một vùng chứa văn bản không đơn giản, hãy sử dụng thuộc tính exclusionPaths trên NSTextContainer để xác định các khu vực không nên đặt văn bản.

Để biết ví dụ về cách thực hiện việc này, hãy xem mã mẫu TextKitAndTextView từ các tài nguyên được liên kết với video này.

Bạn có thể tìm thấy ví dụ liên quan trên tab "đường dẫn loại trừ".

Chúng tôi đã cải tiến công cụ ngắt dòng trong TextKit 2 để chọn ngắt dòng đồng đều hơn cho các đoạn văn hợp lý.

Đây là một thay đổi tinh tế dễ nhận thấy hơn trên các đoạn văn bản dài hơn.

Ở đây chúng tôi có hai phiên bản của cùng một văn bản, được đặt trong cùng một khu vực.

Chú ý các dòng kéo dài và khoảng cách giữa các từ lớn với ngắt dòng truyền thống.

Điều đó ít xảy ra hơn nhiều với việc phá vỡ dòng chẵn mới.

Điều này làm cho văn bản dễ đọc hơn và bạn nhận được nó miễn phí với TextKit 2.

Không yêu cầu nhận con nuôi.

Và cuối cùng, chúng tôi đã thêm hỗ trợ danh sách văn bản trong TextKit 2 cho tất cả các nền tảng.

Với danh sách văn bản, bạn có thể lập trình tạo danh sách được đánh số hoặc dấu đầu dòng để hiển thị trong chế độ xem văn bản.

TextKit 2 sử dụng NSTextList để biểu diễn danh sách văn bản, giống như TextKit 1.

NSTextList từng chỉ khả dụng trong AppKit, nhưng trong iOS 16, nó cũng có sẵn trong UIKit.

Sử dụng NSTextList cùng với NSmutableParagraphStyle để chỉ định rằng một đoạn văn trong bộ lưu trữ văn bản của bạn nên được định dạng dưới dạng danh sách để hiển thị.

Chế độ xem văn bản chịu trách nhiệm chọn các thuộc tính này từ bộ lưu trữ văn bản và định dạng lại nội dung đoạn văn để trông giống như một danh sách.

Mặc dù bản thân NSTextList không phải là mới, nhưng có một vài bổ sung TextKit 2 mới.

Vì các danh sách có thể có các mục lồng nhau, nên việc biểu diễn chúng như một cấu trúc cây là điều tự nhiên.

Trong TextKit 2, chúng tôi đã cải tiến NSTextElement để hỗ trợ cấu trúc chúng dưới dạng cây với các thuộc tính để truy cập các phần tử con và mẹ.

Và chúng tôi đã thêm một lớp con phần tử mới được gọi là NSTextListElement.

Khi người quản lý nội dung bắt gặp NSTextList trong nội dung văn bản, nó sẽ tạo NSTextListElements để đại diện cho các mục trong danh sách.

Để có cái nhìn sâu sắc hơn về cách tạo danh sách văn bản và thêm các mục, hãy tham khảo mã mẫu TextKitAndTextView.

Bạn có thể tìm thấy ví dụ liên quan trên tab "danh sách".

Và trong khi bạn đang khám phá mã mẫu, đừng bỏ lỡ ví dụ đính kèm văn bản cho thấy cách sử dụng API của nhà cung cấp chế độ xem tệp đính kèm văn bản trong TextKit 2.

Các API này cho phép bạn sử dụng giao diện người dùng hoặc NSView làm tệp đính kèm văn bản và các sự kiện có thể được xử lý trực tiếp bằng chế độ xem tệp đính kèm.

Điều này làm cho việc xử lý sự kiện với các tệp đính kèm văn bản dễ dàng hơn rất nhiều và điều đó chỉ có thể thực hiện được với TextKit 2.

Được rồi, đó là nó cho những gì mới trong TextKit 2.

Tiếp theo, tôi sẽ đi vào chi tiết của chế độ tương thích TextKit 1.

Vì TextKit 2 là một sự khởi đầu triệt để so với thiết kế của TextKit 1, chúng tôi hiểu rằng việc áp dụng đầy đủ TextKit 2 có thể mất một thời gian cho các ứng dụng được đầu tư mạnh vào kiến trúc TextKit 1.

Chúng tôi muốn các ứng dụng này tiếp tục hoạt động tốt cho đến khi quá trình chuyển đổi có thể được thực hiện và đó là lý do tại sao chúng tôi đã thêm chế độ tương thích TextKit 1 đặc biệt cho UITextView và NSTextView.

Khi bạn gọi rõ ràng NSLayoutManager API, chế độ xem văn bản sẽ thay thế NSTextLayoutManager của nó bằng NSLayoutManager và tự cấu hình lại để sử dụng TextKit 1.

Điều này cũng có thể xảy ra nếu chế độ xem văn bản gặp phải các thuộc tính chưa được TextKit 2 hỗ trợ, chẳng hạn như bảng hoặc khi in.

Nếu bạn gặp phải dự phòng thời gian chạy bất ngờ đối với TextKit 1 trong UITextView, hãy kiểm tra nhật ký để biết thông báo cảnh báo về công tắc.

Đặt điểm dừng trên biểu tượng gạch dưới UITextViewEnablingCompatibilityMode để ghi lại dấu vết ngăn xếp và thông tin gỡ lỗi hữu ích khác.

Đối với NSTextView, bạn có thể nhận thêm thông tin về dự phòng thời gian chạy bất ngờ bằng cách đăng ký nhận thông báo willSwitch hoặc didSwitchToNSLayoutManager.

Nếu bạn phải quay lại TextKit 1, tốt nhất bạn nên chọn không tham gia vào thời điểm khởi tạo với chế độ xem văn bản được khởi tạo theo chương trình.

Làm điều này bằng cách sử dụng vùng chứa văn bản của riêng bạn và trình quản lý bố cục TextKit 1.

Một lựa chọn khác là sử dụng hàm tạo tiện lợi mới để khởi tạo chế độ xem văn bản TextKit 1 và chuyển sai làm tham số.

Điều này sẽ làm cho chế độ xem văn bản của bạn sử dụng TextKit 1.

Và tùy chọn thứ ba là sử dụng Trình tạo giao diện và đặt tùy chọn Bố cục văn bản mới thành TextKit 1 trên chế độ xem văn bản của bạn.

Đây là điều cần chú ý.

Nếu bạn đang hoán đổi trình quản lý bố cục của vùng chứa văn bản trong hoặc sau khi khởi tạo, thì chế độ xem văn bản của bạn sẽ quay trở lại TextKit 1 như được thiết kế.

Thật không hiệu quả khi tạo tất cả các đối tượng TextKit 2 trong quá trình khởi tạo chỉ để vứt chúng đi ngay sau đó.

Cũng có những tác dụng phụ tiềm ẩn của người dùng, tùy thuộc vào thời gian.

Nếu nó xảy ra trong khi nhập, chế độ xem văn bản có thể mất tiêu điểm và làm gián đoạn đầu vào, yêu cầu chế độ xem văn bản phải được chọn lại để tiếp tục.

Tránh điều này bằng cách chọn chế độ xem văn bản tại thời điểm khởi tạo.

Bây giờ bạn đã biết tất cả về chế độ tương thích, đã đến lúc nói về cách tránh nó hoàn toàn bằng cách hiện đại hóa ứng dụng của bạn và áp dụng TextKit 2.

Và có một điều thực sự quan trọng mà tôi muốn bạn nhớ.

Chỉ có thể có một trình quản lý bố cục cho mỗi chế độ xem văn bản.

Chế độ xem văn bản không thể có cả NSTextLayoutManager và NSLayoutManager cùng một lúc.

Khi chế độ xem văn bản chuyển sang TextKit 1, không có cách nào tự động quay lại.

Quá trình chuyển đổi hệ thống bố cục rất tốn kém và bạn sẽ mất bất kỳ trạng thái giao diện người dùng nào có mặt tại thời điểm chuyển đổi.

Vì vậy, để có hiệu suất và khả năng sử dụng tối ưu, hệ thống sẽ không bao giờ chuyển chế độ xem văn bản trở lại TextKit 2 từ TextKit 1.

Đó là một hoạt động một chiều.

Điều này có nghĩa là nó thực sự quan trọng để tránh chế độ tương thích.

Và có một vài lý do khác nhau khiến chế độ xem văn bản sẽ chuyển sang chế độ tương thích.

Lý do số một để chế độ xem văn bản vào chế độ tương thích là truy cập thuộc tính Trình quản lý bố cục của chế độ xem văn bản.

Những lý do khác ít phổ biến hơn nhiều.

Vì vậy, một chiến lược quan trọng là tránh truy cập vào thuộc tính trình quản lý bố cục của chế độ xem văn bản.

Cũng tránh truy cập trình quản lý bố cục thông qua vùng chứa văn bản của chế độ xem văn bản.

Kiểm tra mã của bạn để sử dụng các thuộc tính này và xóa chúng hoặc thay thế chúng bằng các thuộc tính tương đương TextKit 2.

Nếu bạn đang triển khai ứng dụng của mình cho các phiên bản hệ điều hành cũ hơn không có TextKit 2, bạn có thể không xóa hoàn toàn mã Trình quản lý bố cục của mình.

Trong trường hợp đó, trước tiên bạn nên kiểm tra NSTextLayoutManager của chế độ xem văn bản.

Đặt mã TextKit 2 của bạn vào mệnh đề if và đặt mã TextKit 1 vào mệnh đề else, bao gồm quyền truy cập layoutManager.

Bằng cách này, mã TextKit 1 chỉ chạy khi TextKit 2 không khả dụng và truy vấn layoutManager của bạn sẽ không gây ra dự phòng ngoài ý muốn cho TextKit 1.

Nếu bạn đã làm theo tất cả lời khuyên này và bạn vẫn gặp phải sự dự phòng bất ngờ đối với TextKit 1 đến từ hệ thống, đó là vấn đề của chúng tôi, vì vậy vui lòng báo cáo sự cố với Trợ lý phản hồi.

Bao gồm việc nắm bắt dấu vết ngăn xếp tại thời điểm dự phòng, mà bạn có thể nhận được từ việc phá vỡ dấu gạch dưới UITextViewEnablingCompatibilityMode trong UIKit hoặc willSwitchToNSLayoutManagerNotification trong AppKit.

Được rồi, bây giờ tôi sẽ đi vào chi tiết cụ thể của việc cập nhật mã liên quan đến các loại TextKit 1, bắt đầu với NSLayoutManager.

Khi bạn đã kiểm tra mã của mình cho các truy vấn NSLayoutManager, bạn sẽ cần tìm ra TextKit 2 tương đương với NSTextLayoutManager.

Một số API quản lý bố cục có tên tương tự giữa TextKit 1 và 2, và việc thay thế rất đơn giản.

Đây là một vài ví dụ.

Trong TextKit 1, bạn gọi usedRect(for: textContainer) trên NSLayoutManager để lấy hình chữ nhật giới hạn cho văn bản bên trong vùng chứa văn bản.

Trong TextKit 2, bạn nhận được điều này từ thuộc tính usageBoundsForTextContainer trên NSTextLayoutManager.

Trong TextKit 1, chúng tôi đã sử dụng tên "thuộc tính tạm thời" cho các thuộc tính chỉ ảnh hưởng đến kết xuất chứ không phải bố cục.

Trong TextKit 2, chúng tôi gọi chính xác hơn những "thuộc tính kết xuất" đó.

Nhưng có một số API TextKit 1 không có tương đương trực tiếp trong TextKit 2.

Để hiểu tại sao, bạn cần hiểu rằng không có ký tự chính xác nào để ánh xạ glyph cho nhiều từ trong các chữ viết Ấn Độ như Kannada.

Trong các tập lệnh này, glyphs có thể được tách ra, sắp xếp lại, kết hợp lại hoặc thậm chí bị xóa.

Các API dựa trên glyph trên NSLayoutManager giả sử bạn có thể liên kết trực tiếp một phạm vi ký tự liền kề với một phạm vi glyph liền kề và điều đó không đúng với tất cả các tập lệnh.

Sử dụng các API này có thể dẫn đến bố cục và kết xuất bị hỏng cho văn bản được viết bằng các tập lệnh như Kannada.

Đó là lý do tại sao không có API glyph trong TextKit 2.

Bạn không thể chỉ thay thế một TextKit 2 API cho TextKit 1 glyph API.

Việc thay thế các API này đòi hỏi một cách tiếp cận khác.

Vì vậy, đây là cách cập nhật mã dựa trên glyph.

Bước đầu tiên là xác định bạn đang sử dụng API glyph nào.

Tiếp theo, hãy xem cách bạn đang sử dụng các API đó và xác định những gì bạn đang cố gắng làm ở cấp độ cao.

Mã dựa trên Glyph ở cấp độ rất thấp và có nhiều chi tiết không liên quan đến nhiệm vụ cấp cao của bạn.

Khi bạn đã xác định nhiệm vụ cấp cao, hãy kiểm tra các cấu trúc có sẵn cho bạn trong TextKit 2 như các đoạn bố cục, đoạn dòng và lựa chọn văn bản.

Những thứ này có thể giúp bạn hoàn thành nhiệm vụ của mình.

Ví dụ, hãy xem xét mã TextKit 1 này.

Có hai API glyph được sử dụng ở đây: numberOfGlyphs và lineFragmentRect(forGlyphAt: index).

Mã TextKit 1 này đang lặp lại tất cả các glyph trong tài liệu và đếm các đoạn thẳng dòng.

Nhiệm vụ cấp cao là đếm số dòng văn bản được bọc trong chế độ xem văn bản.

Vì mã này đang hoạt động với các đoạn thẳng dòng, các cấu trúc TextKit 2 để sử dụng là NSTextLineFragment và NSTextLayoutFragment.

Và đây là mã được viết lại để sử dụng TextKit 2.

Thay vì lặp lại các glyph, nó liệt kê các đoạn bố cục văn bản trong tài liệu và cung cấp một kết thúc đếm tất cả các đoạn dòng văn bản trong mỗi đoạn bố cục.

Hãy ghi nhớ ví dụ đó khi cập nhật mã của riêng bạn cho TextKit 2.

Bây giờ tôi sẽ chuyển số và thảo luận về việc cập nhật mã dựa trên NSRange.

TextKit 1 sử dụng NSRange để lập chỉ mục vào nội dung văn bản và NSRange là một chỉ mục tuyến tính thành một chuỗi.

Đối với dòng chữ "Xin chào TextKit 2!" Dấu chấm than, NSRange đại diện cho "dấu chấm than Văn bản 2" là vị trí 6 và độ dài 10, vì nó bắt đầu ở ký tự thứ 6 và dài 10 ký tự.

Mô hình tuyến tính này rất dễ hiểu và nó hoạt động rất tốt để lập chỉ mục thành các chuỗi.

Nhưng mô hình tuyến tính không hoạt động để lập chỉ mục vào bất kỳ nội dung nào có nhiều cấu trúc hơn một chuỗi.

Đây là một ví dụ.

Tài liệu HTML được biểu diễn dưới dạng cấu trúc cây, trong đó mỗi thẻ là một nút trong cây.

Nếu Hello TextKit 2 của chúng tôi! Văn bản là một phần của tài liệu HTML, không có cách nào để NSRange của chúng tôi cho chúng tôi biết rằng văn bản nằm bên trong thẻ span, lồng sâu 3 cấp độ.

Mô hình tuyến tính không đủ biểu cảm để lưu trữ thông tin đó, vì vậy chúng ta không thể sử dụng nó để lập chỉ mục thành một cấu trúc lồng nhau như thế này.

Đây là lý do tại sao TextKit 2 đã thêm các loại mới để biểu diễn các phạm vi trong nội dung văn bản.

NSTextLocation là một đối tượng đại diện cho một vị trí duy nhất bên trong nội dung văn bản.

NSTextRange bao gồm một vị trí bắt đầu và kết thúc.

Vị trí cuối cùng bị loại trừ khỏi phạm vi.

Các loại mới này có thể đại diện cho cấu trúc lồng nhau của tài liệu HTML này bằng cách xác định vị trí là nút DOM cộng với độ lệch ký tự.

Vì NSTextLocation là một giao thức, bất kỳ đối tượng tùy chỉnh nào cũng có thể là một vị trí miễn là nó triển khai các phương thức giao thức NSTextLocation.

Đây là cơ sở hạ tầng quan trọng để làm việc với các loại cửa hàng sao lưu khác nhau hỗ trợ dữ liệu có cấu trúc trong các mô hình của họ.

Nhưng chế độ xem văn bản được xây dựng trên các cửa hàng sao lưu NSAttributedString không có cấu trúc này và chúng tôi không thể thay đổi điều đó mà không phá vỡ nhiều ứng dụng, bao gồm cả ứng dụng của bạn.

Vì vậy, bạn sẽ tiếp tục sử dụng NSRange khi sử dụng các API xem văn bản như selectedRange hoặc scrollRangeToVisible.

Và bạn sẽ cần chuyển đổi giữa NSRange và NSTextRange khi giao tiếp với trình quản lý bố cục TextKit 2 hoặc trình quản lý nội dung.

Để chuyển đổi NSRange của chế độ xem văn bản thành NSTextRange, hãy xác định vị trí là chỉ mục số nguyên vào chuỗi được gán.

Sử dụng vị trí NSRange làm vị trí bắt đầu cho NSTextRange.

Sử dụng vị trí NSRange cộng với độ dài làm vị trí cuối của NSTextRange.

Về mặt khái niệm, đó là cách ánh xạ từ NSRange sang NSTextRange.

Trong thực tế, mã trông hơi khác một chút vì NSTextLocations phải là đối tượng.

Bạn cần thông qua trình quản lý nội dung để tính toán các vị trí.

Đối với vị trí bắt đầu, hãy hỏi người quản lý nội dung về vị trí bắt đầu tài liệu, sau đó bù đắp nó bằng vị trí của NSRange.

Sau đó bù đắp vị trí bắt đầu bằng chiều dài của NSRange để có được vị trí kết thúc.

Để đi theo hướng khác, hãy sử dụng trình quản lý nội dung văn bản để có được hai độ lệch khác nhau.

Vị trí của NSRange là độ lệch giữa phần đầu của tài liệu và vị trí của NSTextRange.

Và chiều dài của NSRange là độ lệch giữa vị trí bắt đầu và kết thúc của NSTextRange.

UITextViews và UITextFields phù hợp với giao thức UITextInput, sử dụng UITextPosition và phạm vi.

Hầu hết thời gian, bạn sẽ không cần chuyển đổi UITextRange trực tiếp sang NSTextRange khi sử dụng UITextView hoặc UITextField.

Nhưng nếu bạn làm vậy, hãy sử dụng độ lệch số nguyên làm trung gian giữa hai loại phạm vi.

Mặt khác, nếu bạn đang sử dụng chế độ xem tùy chỉnh với UITextInput, bạn có quyền kiểm soát trực tiếp các lớp con UITextPosition và UITextRange được sử dụng với chế độ xem của mình.

Bạn có thể làm cho lớp con UITextPosition của mình phù hợp với NSTextLocation, triển khai phương thức cần thiết và sử dụng lớp con của bạn để tạo trực tiếp NSTextRanges.

Cuối cùng, đây là một lời nhắc nhở để tránh sử dụng lại các đối tượng UITextPosition trên các chế độ xem khác nhau, ngay cả khi nội dung trong cả hai chế độ xem đều giống nhau.

Vị trí UIText chỉ hợp lệ cho chế độ xem được sử dụng để tạo nó.

Được rồi, bây giờ bạn đã có rất nhiều chiến lược theo ý của mình để hiện đại hóa mã của mình.

Áp dụng các chiến lược này và ứng dụng của bạn sẽ sẵn sàng gặt hái những lợi ích của TextKit 2.

Và đó là những gì mới trong TextKit và chế độ xem văn bản.

Tôi đã đề cập đến rất nhiều cải tiến tuyệt vời trong TextKit 2 và chia sẻ một số chiến lược để cập nhật ứng dụng của bạn trong khi vẫn duy trì khả năng tương thích với các phiên bản hệ điều hành cũ hơn.

Sử dụng TextKit 2 trong các ứng dụng của bạn ngay hôm nay để tận dụng tối đa những cải tiến mới.

Kiểm tra chế độ xem văn bản của bạn để đảm bảo rằng chúng không vô tình quay trở lại TextKit 1.

Và cuối cùng, sử dụng các chiến lược hiện đại hóa để tải ứng dụng của bạn trên TextKit 2.

Chúng tôi nóng lòng muốn đọc những gì bạn sẽ tạo với TextKit 2 và chế độ xem văn bản.

Cảm ơn vì đã xem!