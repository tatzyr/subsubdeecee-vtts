110353

♪ ♪

Xin chào, tôi là Slava từ nhóm biên dịch swift.

Chào mừng đến với Thiết kế Giao diện Giao thức trong Swift.

Tôi sẽ tiếp tục nơi mà Embrace Swift Generics nói chuyện đã dừng lại và chỉ cho bạn một số kỹ thuật nâng cao để trừu tượng hóa các loại cụ thể và mô hình hóa các mối quan hệ loại bằng cách sử dụng các giao thức.

Bài nói chuyện này sẽ bao gồm cả các tính năng ngôn ngữ hiện có, cũng như một số khả năng mới được giới thiệu trong Swift 5.7.

Bài nói chuyện này có ba chủ đề chính: Đầu tiên, tôi sẽ chỉ cho bạn cách các giao thức với các loại liên quan tương tác với các loại 'bất kỳ' hiện sinh, bằng cách giải thích cách hoạt động của 'xóa loại kết quả'.

Tiếp theo, tôi sẽ giải thích bằng cách sử dụng các loại kết quả mờ đục để cải thiện việc đóng gói bằng cách tách giao diện khỏi việc triển khai.

Đối với chủ đề cuối cùng, bạn sẽ thấy các yêu cầu cùng loại trong các giao thức có thể mô hình hóa mối quan hệ giữa nhiều bộ loại cụ thể khác nhau như thế nào.

Hãy bắt đầu bằng cách tìm hiểu cách các giao thức với các loại liên quan tương tác với các loại hiện sinh.

Ở đây, chúng tôi có một mô hình dữ liệu với một cặp giao thức và bốn loại cụ thể.

Có hai loại động vật, gà và bò, và hai loại thức ăn, trứng và sữa.

Gà sản xuất trứng, và bò sản xuất sữa.

Để tóm tắt việc sản xuất thực phẩm, tôi sẽ thêm một phương thức produce() vào giao thức Animal.

Bạn có thể nhớ từ bài nói chuyện 'Embrace swift generics' rằng cách tốt nhất để trừu tượng hóa các loại sản phẩm trả về khác nhau () trên Cow and Chicken là sử dụng một loại liên quan.

Bằng cách sử dụng một loại liên quan, chúng tôi đang tuyên bố rằng: đưa ra một số loại Động vật cụ thể, việc gọi produce() trả về một số loại Thực phẩm cụ thể, phụ thuộc vào loại Động vật cụ thể.

Chúng ta có thể thể hiện mối quan hệ này bằng một sơ đồ.

Loại giao thức 'Self' là viết tắt của loại bê tông thực tế phù hợp với giao thức 'Động vật'.

Loại 'Bản thân' có loại 'Hàng hóa' liên quan, phù hợp với 'Thực phẩm'.

Hãy xem xét mối quan hệ giữa các loại Gà và Bò cụ thể và sơ đồ loại liên quan cho giao thức Động vật.

Loại Gà phù hợp với giao thức Động vật với Loại Hàng hóa là 'Trứng'.

Và loại Bò phù hợp với giao thức Động vật với Loại Hàng hóa là 'Sữa'.

Bây giờ, giả sử chúng ta có một trang trại đầy động vật.

Tài sản được lưu trữ 'động vật' trong Trang trại là một mảng không đồng nhất của 'bất kỳ Động vật nào'.

Khi nắm lấy thuốc generic Swift, chúng tôi đã thấy cách 'bất kỳ loại Động vật nào' có biểu diễn hộp có khả năng lưu trữ bất kỳ loại động vật cụ thể nào một cách linh hoạt.

Chiến lược sử dụng cùng một biểu diễn cho các loại cụ thể khác nhau được gọi là xóa loại.

Phương thức produceCommodities() ánh xạ qua mảng động vật, gọi phương thức produce() trên mỗi cái.

Phương pháp này có vẻ đơn giản, nhưng chúng tôi biết rằng việc xóa kiểu sẽ loại bỏ các mối quan hệ kiểu tĩnh với loại động vật cơ bản, vì vậy bạn nên tìm hiểu sâu hơn để hiểu lý do tại sao loại mã này kiểm tra.

Tham số 'động vật' trong đóng bản đồ () có loại 'bất kỳ Động vật nào'.

Kiểu trả về của 'produce()' là một kiểu liên quan.

Khi bạn gọi một phương thức trả về một kiểu liên quan trên một kiểu hiện sinh, trình biên dịch sẽ sử dụng xóa kiểu để xác định loại kết quả của cuộc gọi.

Xóa kiểu thay thế các loại liên quan này bằng các loại hiện sinh tương ứng có các ràng buộc tương đương.

Chúng tôi đã xóa mối quan hệ giữa loại Động vật cụ thể và Loại Hàng hóa liên quan bằng cách thay thế chúng bằng 'bất kỳ Động vật nào' và 'bất kỳ Thực phẩm nào'.

Loại 'bất kỳ Thực phẩm nào' được gọi là giới hạn trên của Loại Hàng hóa liên quan.

Vì phương thức produce() được gọi trên 'bất kỳ Động vật nào', giá trị trả về sẽ bị xóa kiểu, cho chúng ta giá trị của loại 'Bất kỳ Thực phẩm nào'.

Đây chính xác là loại mà chúng tôi mong đợi ở đây.

Chúng ta hãy xem xét kỹ hơn cách hoạt động của việc xóa kiểu liên kết, đây là một tính năng mới trong Swift 5.7.

Một loại liên quan xuất hiện trong loại kết quả của một phương thức giao thức - ở phía bên tay phải của mũi tên - được cho là ở 'vị trí sản xuất', bởi vì việc gọi phương thức sẽ tạo ra một giá trị của loại này.

Khi chúng tôi gọi phương thức này trên 'bất kỳ Động vật nào', chúng tôi không biết loại kết quả cụ thể tại thời điểm biên dịch, nhưng chúng tôi biết rằng nó là một loại phụ của giới hạn trên.

Ở đây trong ví dụ này, chúng tôi đang gọi produce() trên một 'bất kỳ Động vật nào' giữ một Con bò trong thời gian chạy.

Trong trường hợp của chúng tôi, phương thức produce() trên Cow trả về Sữa.

Sữa có thể được lưu trữ bên trong 'bất kỳ Thực phẩm nào', đây là giới hạn trên của Loại Hàng hóa liên quan của giao thức Động vật.

Điều này luôn an toàn, cho tất cả các loại cụ thể phù hợp với giao thức Động vật.

Mặt khác, hãy suy nghĩ về điều gì sẽ xảy ra nếu loại liên quan xuất hiện trong danh sách tham số của một phương thức hoặc trình khởi tạo.

Ở đây, phương thức eat() trên giao thức Animal có FeedType liên quan ở vị trí tiêu thụ.

Chúng ta cần chuyển một giá trị của loại này để gọi phương thức.

Vì việc chuyển đổi đi theo hướng khác, việc xóa kiểu không thể được thực hiện.

Loại hiện sinh giới hạn trên cho loại liên quan không chuyển đổi an toàn sang loại bê tông thực tế, bởi vì loại bê tông không được biết.

Hãy xem xét một ví dụ.

Một lần nữa, chúng ta có một 'bất kỳ Động vật nào' đang cất giữ một Con Bò.

Giả sử rằng phương pháp 'ăn' trên Cow lấy Hay.

Giới hạn trên của 'FeedType' liên quan đến giao thức Animal là 'bất kỳ AnimalFeed' nào.

Nhưng với một 'bất kỳ AnimalFeed' tùy ý, không có cách nào để đảm bảo tĩnh rằng nó lưu trữ loại bê tông 'Hay'.

Xóa loại không cho phép chúng tôi làm việc với các loại liên quan ở vị trí tiêu thụ.

Thay vào đó, bạn phải mở hộp loại 'bất kỳ' hiện sinh bằng cách chuyển nó đến một hàm có kiểu 'một số' mờ đục.

Hành vi xóa loại này với các loại liên quan thực sự tương tự như một tính năng ngôn ngữ hiện có mà bạn có thể đã thấy trong Swift 5.6.

Hãy xem xét một giao thức cho các loại tham chiếu nhân bản.

Giao thức này xác định một phương thức clone() duy nhất, trả về Self.

Khi bạn gọi clone() trên một giá trị của loại 'bất kỳ Cloneable', loại kết quả 'Self', sẽ bị xóa vào giới hạn trên của nó.

Giới hạn trên của loại Self luôn là chính giao thức, vì vậy chúng tôi nhận lại một giá trị mới của loại 'bất kỳ Bản sao nào'.

Vì vậy, để tóm tắt: bạn có thể sử dụng 'bất kỳ' để tuyên bố rằng loại giá trị là một loại tồn tại lưu trữ một số loại cụ thể phù hợp với giao thức.

Điều này thậm chí còn hoạt động với các giao thức có các loại liên quan.

Khi gọi một phương thức giao thức với một kiểu liên quan ở vị trí sản xuất, kiểu liên quan sẽ bị xóa kiểu ở giới hạn trên của nó, đây là một kiểu hiện sinh khác mang các ràng buộc của kiểu liên quan.

Trừu tượng hóa trên các loại cụ thể không chỉ hữu ích cho các đầu vào hàm - nó cũng hữu ích cho các đầu ra hàm, do đó các loại cụ thể chỉ hiển thị từ việc triển khai.

Chúng ta hãy xem cách trừu tượng hóa các loại kết quả cụ thể để tách giao diện thiết yếu của một đoạn mã khỏi các chi tiết triển khai của nó, làm cho các phép gán loại tĩnh trở nên mô-đun và mạnh mẽ hơn khi đối mặt với những thay đổi.

Hãy khái quát hóa giao thức Động vật để cho phép cho Động vật ăn.

Động vật bị đói, và khi chúng đói chúng cần ăn.

Hãy thêm một thuộc tính isHungry vào giao thức Animal.

Phương thức feedAnimals() trên Farm sẽ cung cấp cho tập hợp con động vật đang đói.

Tôi đã chia nhỏ việc tính toán tập hợp con động vật đói này thành một tài sản hungryAnimals.

Việc triển khai ban đầu này của hungryAnimals() sử dụng phương thức filter() để chọn tập hợp con của động vật trong đó thuộc tính isHungry là đúng.

Gọi filter() trên một mảng 'bất kỳ Động vật' nào' trả về một mảng mới của 'bất kỳ Động vật nào'.

Bây giờ bạn có thể nhận thấy rằng feedAnimals() chỉ lặp lại kết quả của hungryAnimals một lần, và sau đó ngay lập tức loại bỏ mảng tạm thời này.

Điều này sẽ không hiệu quả nếu trang trại chứa một số lượng lớn động vật đói.

Một cách để tránh sự phân bổ tạm thời này là sử dụng tính năng bộ sưu tập lười biếng của thư viện tiêu chuẩn.

Bằng cách thay thế lệnh gọi 'filter' bằng 'lazy.filter', chúng ta có được cái được gọi là bộ sưu tập lười biếng.

Một bộ sưu tập lười biếng có các phần tử giống như mảng được trả về bởi một cuộc gọi đơn giản đến 'bộ lọc', nhưng nó tránh được sự phân bổ tạm thời.

Tuy nhiên, bây giờ loại thuộc tính 'hungryAnimals' phải được khai báo là loại cụ thể khá phức tạp này, 'LazyFilterSequence of Array of any Animal'.

Điều này phơi bày một chi tiết triển khai không cần thiết.

Khách hàng, feedAnimals(), không quan tâm rằng chúng tôi đã sử dụng 'lazy.filter' trong việc triển khai 'hungryAnimals'; nó chỉ cần biết rằng nó đang nhận được một số bộ sưu tập mà nó có thể lặp lại.

Một loại kết quả mờ đục có thể được sử dụng để ẩn loại bê tông phức tạp đằng sau giao diện trừu tượng của Bộ sưu tập.

Bây giờ khách hàng gọi là 'hungryAnimals' chỉ biết rằng họ đang nhận được một số loại cụ thể phù hợp với giao thức Bộ sưu tập, nhưng họ không biết loại bộ sưu tập cụ thể cụ thể.

Tuy nhiên như đã viết, điều này thực sự che giấu quá nhiều thông tin kiểu tĩnh khỏi khách hàng.

Chúng tôi đang tuyên bố rằng hungryAnimals xuất ra một số loại cụ thể phù hợp với Bộ sưu tập, nhưng chúng tôi không biết gì về loại Phần tử của Bộ sưu tập này.

Nếu không biết rằng loại phần tử là 'bất kỳ Động vật nào', tất cả những gì chúng ta có thể làm với loại phần tử là chuyển nó đi; chúng ta không thể gọi bất kỳ phương thức nào của giao thức Động vật.

Hãy tập trung vào loại kết quả mờ đục 'một số Bộ sưu tập'.

Chúng ta có thể đạt được sự cân bằng phù hợp giữa việc ẩn các chi tiết triển khai và phơi bày một giao diện đủ phong phú bằng cách sử dụng loại kết quả mờ đục bị hạn chế.

Các loại kết quả mờ đục bị hạn chế là mới trong Swift 5.7.

Một loại kết quả mờ đục bị hạn chế được viết bằng cách áp dụng các đối số loại trong dấu ngoặc góc sau tên giao thức.

Giao thức Bộ sưu tập có một đối số loại duy nhất, loại Phần tử.

Bây giờ một khi 'hungryAnimals' được khai báo với một loại kết quả mờ đục bị hạn chế, thực tế là nó thực sự là một 'LazyFilterSequence của một mảng của bất kỳ Động vật nào' bị ẩn khỏi khách hàng; nhưng khách hàng vẫn biết rằng đó là một số loại cụ thể phù hợp với Bộ sưu tập, có loại

Đây chính xác là giao diện mà chúng tôi muốn ở đây.

Bên trong vòng lặp for trong 'feedAnimals()', biến 'động vật' có loại 'bất kỳ Động vật nào', cho phép các phương thức của giao thức Động vật được gọi trên mỗi động vật đói.

Tất cả điều này hoạt động vì giao thức Bộ sưu tập tuyên bố rằng loại liên kết Phần tử là loại liên kết chính.

Bạn có thể khai báo các giao thức của riêng mình với các loại liên quan chính bằng cách đặt tên cho một hoặc nhiều loại liên quan trong dấu ngoặc nhọn sau tên giao thức, như thế này.

Các loại liên quan hoạt động tốt nhất như các loại liên kết chính là những loại thường được cung cấp bởi người gọi, chẳng hạn như loại Phần tử của bộ sưu tập, trái ngược với chi tiết triển khai, chẳng hạn như loại Trình lặp của bộ sưu tập.

Thông thường, bạn sẽ thấy sự tương ứng giữa các loại giao thức liên quan chính và các tham số chung của một loại cụ thể phù hợp với giao thức này.

Tại đây, bạn có thể thấy rằng loại 'Bộ sưu tập' liên quan đến phần tử chính được thực hiện bởi tham số chung 'Phần tử' của Mảng và Bộ, hai loại cụ thể được xác định bởi thư viện tiêu chuẩn mà cả hai đều phù hợp với Bộ sưu tập.

'Bộ sưu tập của Element' có thể được sử dụng với các loại kết quả mờ đục bằng cách sử dụng từ khóa 'some', cũng như với các loại hiện sinh bị hạn chế bằng cách sử dụng từ khóa 'bất kỳ'.

Trước Swift 5.7, bạn sẽ cần phải viết kiểu dữ liệu của riêng mình để biểu diễn một kiểu hiện sinh với một đối số chung cụ thể.

Swift 5.7 xây dựng khái niệm này thành ngôn ngữ với các kiểu hiện sinh bị hạn chế.

Nếu chúng tôi muốn hungryAnimals có tùy chọn tính toán hungryAnimals một cách lười biếng hay háo hức, việc sử dụng Bộ sưu tập mờ đục của bất kỳ Động vật nào sẽ dẫn đến lỗi mà hàm trả về hai loại cơ bản khác nhau.

Thay vào đó, chúng tôi có thể khắc phục điều này bằng cách trả về 'bất kỳ Bộ sưu tập nào của bất kỳ Động vật nào', báo hiệu rằng API này có thể trả về các loại khác nhau qua các cuộc gọi.

Khả năng hạn chế các loại liên quan chính mang lại cho các loại mờ đục và các loại hiện sinh một cấp độ biểu hiện mới.

Điều này có thể được sử dụng với các giao thức thư viện tiêu chuẩn khác nhau như Bộ sưu tập; bạn cũng có thể khai báo các giao thức của riêng mình có các loại liên quan chính.

Viết mã chung bằng cách sử dụng các kiểu không rõ ràng phải dựa vào các mối quan hệ kiểu trừu tượng.

Hãy thảo luận về cách xác định và đảm bảo các mối quan hệ loại cần thiết giữa nhiều loại trừu tượng bằng cách sử dụng các giao thức liên quan.

Chúng tôi sẽ thêm một loại liên quan mới vào giao thức Động vật cho loại thức ăn chăn nuôi cụ thể mà động vật này ăn, cùng với phương thức eat() yêu cầu động vật tiêu thụ loại thức ăn này.

Để làm cho mọi thứ thú vị hơn, tôi sẽ giới thiệu một biến chứng bổ sung: trước khi chúng ta có thể cho động vật ăn, chúng ta phải trồng loại cây trồng thích hợp và thu hoạch vụ mùa để sản xuất thức ăn.

Đây là bộ loại bê tông đầu tiên.

Một con bò ăn cỏ khô, vì vậy với một con bò, trước tiên chúng ta cần trồng một ít cỏ khô.

Điều này mang lại cho chúng ta cỏ linh lăng, được thu hoạch và chế biến thành cỏ khô, mà bò có thể ăn.

Đây là bộ loại bê tông thứ hai.

Một con gà ăn cào, vì vậy nếu bạn mang cho tôi một con gà, trước tiên chúng ta cần trồng một loại ngũ cốc gọi là kê mà chúng ta thu hoạch và chế biến để tạo ra vết xước gà, thứ mà chúng ta cho gà ăn.

Tôi muốn tóm tắt hai bộ loại cụ thể liên quan này, vì vậy tôi có thể triển khai phương thức feedAnimal() một lần và cho cả bò và gà ăn, cũng như bất kỳ loại động vật mới nào tôi có thể áp dụng trong tương lai.

Vì feedAnimal() cần làm việc với phương thức eat() của giao thức Animal, có kiểu liên quan ở vị trí tiêu thụ, tôi sẽ mở hộp hiện sinh bằng cách khai báo rằng phương thức feedAnimal() lấy 'some Animal' làm kiểu tham số.

Để bắt đầu, tôi sẽ xác định một cặp giao thức, AnimalFeed và Crop, sử dụng những gì chúng ta biết về các giao thức và các loại liên quan cho đến nay.

AnimalFeed có một CropType liên quan, phù hợp với Crop, và Crop có một FeedType liên quan, phù hợp với AnimalFeed.

Như trước đây, chúng ta có thể xem xét sơ đồ các tham số loại cho từng giao thức.

Đầu tiên, hãy nhìn vào AnimalFeed.

Mỗi giao thức đều có một loại 'Bản thân', viết tắt của loại phù hợp cụ thể.

Giao thức của chúng tôi có một 'CropType' liên quan, phù hợp với Crop.

'CropType' liên quan có 'FeedType' liên kết lồng nhau, phù hợp với AnimalFeed, có 'CropType' liên kết lồng nhau phù hợp với Crop, v.v.

Trên thực tế, việc qua lại này tiếp tục mãi mãi, với sự lồng ghép vô hạn của các loại liên quan xen kẽ giữa việc tuân thủ AnimalFeed và Crop.

Với giao thức Crop, chúng tôi có một tình huống tương tự, chỉ thay đổi bởi một.

Chúng tôi bắt đầu với loại 'Bản thân', phù hợp với 'Crop', có 'FeedType' liên quan, phù hợp với AnimalFeed.

Cái này có một 'CropType' liên quan đến lồng nhau, phù hợp với Crop và vân vân...

Đến vô tận.

Hãy xem liệu các giao thức này có mô hình hóa chính xác mối quan hệ giữa các loại cụ thể của chúng ta hay không.

Nhớ lại rằng trước khi chúng ta có thể cho động vật ăn, chúng ta cần trồng cây trồng sau đó được chế biến thành đúng loại thức ăn chăn nuôi.

Grow() là một phương thức tĩnh trong giao thức AnimalFeed, có nghĩa là nó phải được gọi trực tiếp trên một kiểu phù hợp với AnimalFeed, chứ không phải trên một giá trị cụ thể có kiểu phù hợp với AnimalFeed.

Chúng ta cần viết ra tên của một loại phù hợp với AnimalFeed, nhưng tất cả những gì chúng ta có là một giá trị cụ thể, thuộc một số loại phù hợp với Animal, một giao thức khác.

Chà, chúng ta có thể nhận được loại giá trị này, mà chúng ta biết là một số loại phù hợp với Động vật và Động vật có Loại Thức ăn liên quan, phù hợp với AnimalFeed.

Loại này có thể được sử dụng làm cơ sở của phương thức gọi grow().

Phương thức grow() trên AnimalFeed trả về một giá trị có loại là CropType of AnimalFeed được liên kết lồng nhau.

Chúng tôi biết rằng CropType phù hợp với Crop, vì vậy tôi có thể gọi harvest() trên đó.

Nhưng tôi phải lấy lại được gì?

Harvest() được khai báo để trả về FeedType liên quan của giao thức Crop.

Trong trường hợp của chúng tôi, vì cơ sở của cuộc gọi là (một số Động vật). FeedType.CropType, harvest() sẽ xuất ra một giá trị của loại (một số Động vật). FeedType.CropType.FeedType.

Thật không may, đây là loại sai.

Phương thức eat() trên (một số Động vật) mong đợi (một số Động vật). FeedType, và không (một số Động vật). FeedType.CropType.FeedType.

Chương trình không được đánh máy tốt.

Các định nghĩa giao thức này, như đã viết, không thực sự đảm bảo rằng nếu chúng ta bắt đầu với một loại thức ăn chăn nuôi, sau đó trồng và thu hoạch vụ này, chúng ta sẽ lấy lại cùng một loại thức ăn chăn nuôi mà chúng ta đã bắt đầu, đó là những gì động vật của chúng ta mong đợi ăn.

Một cách khác để suy nghĩ về nó là các định nghĩa giao thức này quá chung chung - chúng không mô hình hóa chính xác mối quan hệ mong muốn giữa các loại cụ thể của chúng ta.

Để hiểu tại sao, hãy xem các loại Hay và Alfalfa của chúng tôi.

Khi tôi trồng cỏ khô, tôi nhận được cỏ linh lăng, và khi tôi thu hoạch cỏ linh lăng, tôi nhận được cỏ khô, v.v.

Bây giờ hãy tưởng tượng tôi đang tái cấu trúc mã của mình và tôi vô tình thay đổi kiểu trả về của phương thức harvest() trên Alfalfa để trả về Scratch thay vì Hay.

Sau sự thay đổi ngẫu nhiên này, các loại bê tông vẫn đáp ứng các yêu cầu của giao thức AnimalFeed và Crop, mặc dù chúng tôi vi phạm bất biến mong muốn của mình rằng việc trồng và thu hoạch một loại cây trồng tạo ra cùng một loại thức ăn chăn nuôi mà chúng tôi đã bắt đầu.

Hãy xem lại giao thức AnimalFeed một lần nữa.

Vấn đề thực sự ở đây là theo một nghĩa nào đó, chúng ta có quá nhiều loại liên quan riêng biệt.

Chúng ta cần viết ra thực tế rằng hai trong số các loại liên quan này thực sự là cùng một loại cụ thể.

Điều này sẽ ngăn các loại cụ thể được viết không chính xác tuân thủ các giao thức của chúng tôi; nó cũng sẽ cung cấp cho phương thức feedAnimal() sự đảm bảo mà nó cần.

Chúng ta có thể thể hiện mối quan hệ giữa các loại liên quan này bằng cách sử dụng yêu cầu cùng loại, được viết trong mệnh đề 'ở đâu'.

Yêu cầu cùng loại thể hiện sự đảm bảo tĩnh rằng hai loại liên quan khác nhau, có thể lồng nhau trên thực tế phải là cùng một loại cụ thể.

Thêm một yêu cầu cùng loại ở đây áp đặt một hạn chế đối với các loại cụ thể phù hợp với giao thức AnimalFeed.

Trong yêu cầu cùng loại này ở đây, chúng tôi tuyên bố rằng `Self dot CropType dot FeedType' cùng loại với 'Self'.

Cái này trông như thế nào trong sơ đồ của chúng ta?

Chà, đây là cách chúng ta có thể hình dung nó: Mỗi loại bê tông phù hợp với AnimalFeed có một CropType, phù hợp với Crop.

Tuy nhiên, FeedType của CropType này, không chỉ là một số loại khác phù hợp với AnimalFeed, nó là loại bê tông giống như AnimalFeed ban đầu.

Thay vì một tòa tháp vô hạn của các loại liên quan lồng nhau, tôi đã thu gọn tất cả các mối quan hệ thành một cặp các loại liên quan duy nhất.

Còn giao thức 'Cắt' thì sao?

Ở đây, Crop's FeedType đã giảm xuống còn một cặp loại, nhưng chúng tôi vẫn có quá nhiều loại liên quan.

Chúng tôi muốn nói rằng Loại cây trồng của FeedType giống với Cây trồng mà chúng tôi bắt đầu ban đầu.

Bây giờ hai giao thức này đã được trang bị các yêu cầu cùng loại, chúng ta có thể xem lại phương thức 'feedAnimal()' một lần nữa.

Chúng tôi bắt đầu với loại Động vật nào đó, như trước đây.

Và chúng tôi nhận được loại thức ăn của động vật, mà chúng tôi biết phù hợp với giao thức AnimalFeed.

Khi chúng ta trồng loại cây này, chúng ta nhận được loại cây trồng của một số loại thức ăn chăn nuôi.

Nhưng bây giờ, khi chúng ta thu hoạch vụ mùa này, thay vì nhận được một loại liên quan lồng nhau khác, chúng ta nhận được chính xác loại thức ăn mà động vật của chúng ta mong đợi và động vật hạnh phúc hiện được đảm bảo ăn () đúng loại thức ăn động vật mà chúng ta vừa trồng.

Cuối cùng, hãy xem xét một sơ đồ loại liên quan cho giao thức Động vật, tập hợp mọi thứ lại với nhau mà chúng ta đã thấy cho đến nay.

Đây là hai bộ các loại phù hợp: đầu tiên, chúng ta có Cow, Hay và Alfalfa.

Thứ hai, chúng ta có Chicken, Scratch và Millet.

Lưu ý cách ba giao thức của chúng tôi mô hình hóa chính xác mối quan hệ giữa mỗi bộ ba loại cụ thể.

Bằng cách hiểu mô hình dữ liệu của mình, bạn có thể sử dụng các yêu cầu cùng loại để xác định sự tương đương giữa các loại liên quan lồng nhau này.

Mã chung sau đó có thể dựa vào các mối quan hệ này khi xâu chuỗi nhiều cuộc gọi với nhau đến các yêu cầu giao thức.

Trong phiên này, chúng tôi đã khám phá khi nào việc xóa loại là an toàn và khi nào chúng tôi cần ở trong bối cảnh mà các mối quan hệ loại được đảm bảo.

Sau đó, chúng tôi đã thảo luận về cách đạt được sự cân bằng phù hợp giữa việc bảo tồn thông tin loại phong phú và ẩn các chi tiết triển khai bằng cách sử dụng các loại liên quan chính, có thể được sử dụng với cả loại kết quả mờ đục và loại hiện sinh.

Cuối cùng, chúng tôi đã thấy cách xác định và đảm bảo mối quan hệ loại giữa các bộ loại cụ thể bằng cách sử dụng các yêu cầu cùng loại trên các giao thức đại diện cho các bộ loại liên quan đó.

Cảm ơn vì đã tham gia cùng tôi.

Tôi hy vọng bạn có một WWDC tuyệt vời.