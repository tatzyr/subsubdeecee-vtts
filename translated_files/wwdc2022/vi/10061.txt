10061

♪ Nhạc cụ hip-hip êm dịu ♪

♪

Xin chào mọi người.

Tôi là Jeff, một kỹ sư trong nhóm SwiftUI.

Hôm nay, tôi rất vui được nói chuyện với bạn về việc đưa nhiều cửa sổ vào ứng dụng SwiftUI của bạn trên iPadOS và macOS.

Trong phiên này, chúng tôi sẽ mở đầu với tổng quan về các loại cảnh khác nhau trong vòng đời SwiftUI, bao gồm một vài loại mới mà chúng tôi đang giới thiệu.

Tiếp theo là chỉ ra cách các loại cảnh này có thể được sáng tác với nhau, bằng cách thêm các cảnh phụ trợ.

Sau đó, chúng tôi sẽ đề cập đến một số API mới để mở cửa sổ cho một cảnh cụ thể trong ứng dụng của bạn.

Và chúng tôi sẽ kết thúc mọi thứ bằng một vài cách để tùy chỉnh các cảnh của ứng dụng.

Hãy bắt đầu với một cái nhìn tổng quan về các loại cảnh hiện có trước khi đào sâu vào một số loại mới.

Bạn sẽ nhớ lại từ các phiên trước rằng các ứng dụng trong SwiftUI bao gồm các cảnh và chế độ xem.

Các cảnh thường thể hiện nội dung của chúng bằng một cửa sổ trên màn hình.

Ví dụ, đây là một ứng dụng tôi đã xây dựng để theo dõi những cuốn sách tôi đang đọc.

Nó được định nghĩa là một nhóm cửa sổ duy nhất hiển thị danh sách đọc của tôi theo cách phù hợp với nền tảng.

Trên các nền tảng hỗ trợ nhiều cửa sổ, chẳng hạn như iPadOS và macOS, một cảnh có thể thể hiện chính nó với một số cửa sổ như vậy.

Các hành vi và đại diện của một cảnh khác nhau dựa trên loại được sử dụng.

Ví dụ, một cảnh chỉ có thể đại diện cho chính nó với một trường hợp duy nhất, bất kể khả năng của nền tảng.

Hãy cùng xem danh sách các loại cảnh hiện tại trong SwiftUI.

WindowGroup cung cấp một cách để xây dựng các ứng dụng dựa trên dữ liệu trên tất cả các nền tảng của Apple.

DocumentGroup cho phép bạn xây dựng các ứng dụng dựa trên tài liệu trên iOS và macOS.

Và Cài đặt xác định một giao diện để đại diện cho các giá trị cài đặt trong ứng dụng trên macOS.

Các loại cảnh này có thể được kết hợp với nhau để mở rộng chức năng ứng dụng của bạn.

Chúng tôi đang mở rộng danh sách các cảnh với hai bổ sung mới.

Đầu tiên trong số đó là Window, một cảnh đại diện cho một cửa sổ duy nhất, duy nhất trên tất cả các nền tảng; cũng như một loại cảnh mới cho macOS: MenuBarExtra, hiển thị như một điều khiển liên tục trong thanh menu hệ thống.

Cũng như các loại cảnh khác, bạn có thể sử dụng Window và MenuBarExtra như một cảnh độc lập hoặc sáng tác với các cảnh khác trong ứng dụng của mình.

Không giống như WindowGroup, cảnh Window sẽ chỉ thể hiện nội dung của nó trong một phiên bản cửa sổ duy nhất, duy nhất.

Đặc điểm này có thể hữu ích khi nội dung cảnh của bạn đại diện cho một số trạng thái ứng dụng toàn cầu không nhất thiết phải phù hợp với phong cách trình bày đa cửa sổ của WindowGroups trên macOS và iPadOS.

Ví dụ, một trò chơi có thể chỉ muốn cho phép một cửa sổ chính duy nhất hiển thị nội dung của nó.

MenuBarExtra là một loại cảnh chỉ dành cho macOS mới hoạt động hơi khác so với các cảnh khác của chúng tôi.

Thay vì hiển thị nội dung của nó trong một cửa sổ, nó sẽ đặt nhãn của nó vào thanh menu và hiển thị nội dung của nó trong một menu hoặc cửa sổ được neo vào nhãn.

Ngoài ra, nó sẽ có thể sử dụng được miễn là ứng dụng liên quan của nó đang chạy, bất kể ứng dụng đó có ở trên hết hay không.

MenuBarExtra rất tuyệt vời để tạo các ứng dụng tiện ích độc lập cung cấp quyền truy cập dễ dàng vào chức năng của chúng.

Hoặc nó có thể được sáng tác với các cảnh khác để cung cấp một cách thay thế để truy cập chức năng ứng dụng của bạn.

Nó cũng hỗ trợ hai kiểu kết xuất: kiểu mặc định, hiển thị nội dung trong menu kéo xuống từ thanh menu, cũng như kiểu trình bày nội dung của nó trong một cửa sổ không mạ crôm được neo vào thanh menu.

Với việc bổ sung hai loại cảnh mới này, các ứng dụng SwiftUI có thể đại diện cho một bộ chức năng thậm chí còn phong phú hơn trên tất cả các nền tảng của chúng tôi.

Hãy xem các API mới này có thể được sử dụng kết hợp với các loại cảnh hiện có của chúng ta như thế nào.

Đây là định nghĩa của ứng dụng BookClub mà tôi đã trình bày trước đó.

Nó hiện đang bao gồm một nhóm cửa sổ duy nhất.

Trên macOS, ứng dụng BookClub của tôi có thể hưởng lợi từ một cửa sổ bổ sung để hiển thị hoạt động đọc của chúng tôi theo thời gian.

Đây là một ví dụ tuyệt vời về cách các ứng dụng macOS có thể sử dụng bất động sản màn hình bổ sung và các sắp xếp cửa sổ linh hoạt có trên nền tảng đó.

Chúng tôi sẽ thêm một cảnh phụ trợ vào ứng dụng của mình để đại diện cho giao diện này.

Dữ liệu cửa sổ Hoạt động của chúng tôi có nguồn gốc từ trạng thái ứng dụng tổng thể của chúng tôi, vì vậy cảnh cửa sổ là lựa chọn lý tưởng cho nó.

Mở nhiều cửa sổ với cùng một trạng thái sẽ không phù hợp với thiết kế của chúng tôi.

Tiêu đề được cung cấp cho cảnh của chúng tôi sẽ được sử dụng làm nhãn cho một mục menu được thêm vào một phần của menu Window.

Khi chọn mục này, cửa sổ của cảnh sẽ được mở ra nếu chưa được mở.

Nếu không, nó sẽ được đưa ra phía trước.

Bây giờ chúng tôi đã đề cập đến việc thêm một cảnh phụ trợ vào ứng dụng BookClub của mình, tôi muốn thảo luận về một số API trình bày cảnh mới mà chúng tôi đang thêm và cách bạn có thể tích hợp chúng vào ứng dụng của mình để cung cấp trải nghiệm phong phú hơn.

Ứng dụng BookClub của chúng tôi có một trình đơn ngữ cảnh có thể được gọi cho bất kỳ cuốn sách nào trong ngăn Danh sách Nội dung của chúng tôi.

Trình đơn ngữ cảnh này sẽ bao gồm một nút để kích hoạt bản trình bày cửa sổ của chúng tôi.

Chúng tôi sẽ sớm điền thông tin chi tiết.

SwiftUI cung cấp một số loại có thể gọi mới thông qua môi trường để trình bày các cửa sổ gắn liền với các cảnh mà ứng dụng của bạn xác định.

Đầu tiên trong số này là hành động openWindow, có thể trình bày các cửa sổ cho WindowGroup hoặc cảnh cửa sổ.

Mã định danh được chuyển cho hành động phải khớp với mã định danh cho một cảnh được xác định trong ứng dụng của bạn.

Hành động openWindow cũng có thể có giá trị trình bày, mà cảnh được trình bày sẽ sử dụng để hiển thị nội dung của nó.

Hình thức hành động này chỉ được WindowGroup hỗ trợ, sử dụng trình khởi tạo mới mà chúng ta sẽ xem xét trong thời gian ngắn.

Loại giá trị phải khớp với loại được cung cấp cho trình khởi tạo cảnh.

Ngoài ra còn có hai loại có thể gọi được trong môi trường để trình bày các cửa sổ tài liệu: hành động newDocument, hỗ trợ mở các cửa sổ tài liệu mới cho cả FileDocuments và ReferenceFileDocuments.

Hành động này yêu cầu DocumentGroup tương ứng trong ứng dụng của bạn được xác định với vai trò biên tập viên.

Tài liệu được cung cấp cho hành động này sẽ được tạo ra mỗi khi cửa sổ được trình bày.

Để trình bày các cửa sổ tài liệu nơi nội dung được cung cấp bởi một tệp hiện có trên đĩa, có hành động openDocument.

Hành động này lấy một URL đến tệp bạn muốn mở.

Ứng dụng của bạn phải xác định một DocumentGroup để trình bày cửa sổ và loại tài liệu cho nhóm đó phải cho phép đọc loại tệp tại URL được cung cấp.

Xem lại nút của chúng tôi, chúng tôi sẽ thêm thuộc tính môi trường openWindow vào chế độ xem của chúng tôi.

Vì loại này có thể gọi được, chúng ta chỉ có thể gọi nó trực tiếp từ hành động của nút của chúng ta.

Loại Sách của chúng tôi phù hợp với nhận dạng, vì vậy chúng tôi sẽ chuyển mã định danh của nó làm giá trị để trình bày.

Bây giờ, trước khi chúng ta tiếp tục, tôi muốn thảo luận về các giá trị được chuyển cho hành động openWindow.

Tôi lưu ý rằng tôi đang chuyển mã định danh của cuốn sách, đây là giá trị của loại UUID.

Nói chung, bạn sẽ muốn sử dụng mã định danh mô hình của mình như thế này hơn là chính giá trị đó.

Lưu ý rằng loại Sách của chúng tôi là một loại giá trị.

Như vậy, nếu chúng tôi sử dụng nó làm giá trị được trình bày, cửa sổ mới của chúng tôi sẽ nhận được một bản sao của cửa sổ bắt nguồn từ bản trình bày.

Bất kỳ chỉnh sửa nào cho một trong hai sẽ không ảnh hưởng đến cái kia.

Thay vào đó, việc sử dụng mã định danh của cuốn sách cho phép cửa hàng mô hình của chúng tôi trở thành nguồn gốc của sự thật cho các giá trị này bằng cách cung cấp nhiều ràng buộc cho một giá trị duy nhất.

Để biết thêm thông tin về ngữ nghĩa loại giá trị, vui lòng xem tài liệu dành cho nhà phát triển.

Loại được trình bày cũng phải phù hợp với cả giao thức Hashable và Codable.

Sự phù hợp có thể băm là cần thiết để liên kết giá trị được trình bày với một cửa sổ đang mở; trong khi sự phù hợp có thể mã hóa là bắt buộc để duy trì giá trị được trình bày để khôi phục trạng thái.

Tôi sẽ sớm thảo luận chi tiết hơn về cả hai hành vi này.

Cuối cùng, khi có thể, thích vượt qua các giá trị nhẹ hơn.

Mã định danh cuốn sách của chúng tôi là một ví dụ tuyệt vời khác về điều này.

Vì giá trị sẽ được SwiftUI duy trì để khôi phục trạng thái, việc sử dụng các giá trị nhỏ hơn sẽ dẫn đến khả năng phản hồi tốt hơn cho ứng dụng của bạn.

Bây giờ, nút của chúng tôi bây giờ có các phần cần thiết để trình bày các cửa sổ chi tiết của chúng tôi, nhưng sẽ không có gì hiển thị khi nó được chọn.

Điều này là do chúng tôi đã yêu cầu SwiftUI trình bày một cửa sổ cho một loại dữ liệu nhất định, nhưng chưa xác định một cảnh nào trong ứng dụng của chúng tôi phản ánh điều đó.

Hãy quay lại ứng dụng của chúng tôi và thực hiện thay đổi đó ngay bây giờ.

Cùng với WindowGroup chính và cửa sổ phụ trợ của chúng tôi, chúng tôi sẽ thêm một WindowGroup bổ sung để xử lý chi tiết sách của chúng tôi.

Chi tiết cuốn sách của chúng tôi WindowGroup sử dụng trình khởi tạo mới.

Ngoài tiêu đề, chúng tôi lưu ý rằng nhóm này trình bày dữ liệu cho loại Book.ID - trong trường hợp của chúng tôi, UUIDs.

Loại này phải khớp với giá trị mà chúng tôi đang chuyển cho hành động openWindow mà chúng tôi đã thêm trước đó.

Khi một giá trị nhất định được cung cấp cho WindowGroup để trình bày, SwiftUI sẽ tạo một cảnh con mới cho giá trị đó và nội dung gốc của cửa sổ cảnh đó sẽ được xác định bởi giá trị đó, sử dụng trình tạo chế độ xem của nhóm.

Mỗi giá trị được trình bày độc đáo sẽ tạo ra một khung cảnh mới.

Sự bình đẳng của giá trị sẽ được sử dụng để xác định xem một cửa sổ mới nên được tạo hay liệu một cửa sổ hiện có có có thể được sử dụng lại hay không.

Khi openWindow trình bày một giá trị mà một cửa sổ đã tồn tại, nhóm sẽ sử dụng cửa sổ đó thay vì tạo một cửa sổ mới.

Sử dụng ứng dụng BookClub của chúng tôi làm ví dụ, việc chọn hành động menu ngữ cảnh cho một cuốn sách đã được trình bày trong cửa sổ sẽ dẫn đến việc cửa sổ đó được sắp xếp phía trước, thay vì cửa sổ thứ hai hiển thị cùng một cuốn sách.

Giá trị được trình bày cũng sẽ được SwiftUI tự động duy trì cho mục đích khôi phục trạng thái.

Quan điểm của bạn sẽ được ràng buộc với giá trị được trình bày ban đầu.

Ràng buộc này có thể được sửa đổi bất cứ lúc nào trong khi cửa sổ đang mở.

Khi cảnh được tạo lại để khôi phục trạng thái, SwiftUI sẽ chuyển giá trị gần đây nhất cho chế độ xem Nội dung của cửa sổ.

Ở đây, chúng tôi đang cung cấp ràng buộc Book.ID cho chế độ xem chi tiết của chúng tôi, có thể tra cứu mặt hàng được chỉ định trong cửa hàng mô hình của chúng tôi để hiển thị.

Với tất cả các phần của chúng tôi tại chỗ, bây giờ chúng tôi có thể chọn mục menu ngữ cảnh của mình và xem chi tiết sách của chúng tôi trong cửa sổ riêng của nó.

Cuối cùng, tôi muốn xem qua một số cách mà bạn có thể tùy chỉnh các cảnh trong ứng dụng của mình.

Bởi vì chúng tôi đã xác định ứng dụng của mình với hai cảnh WindowGroup - một cho cửa sổ người xem chính và một cho cửa sổ chi tiết của chúng tôi - SwiftUI theo mặc định sẽ thêm một mục menu cho mỗi nhóm trong menu Tệp.

Tuy nhiên, mục menu cho cửa sổ chi tiết của chúng tôi không hoàn toàn phù hợp với trường hợp sử dụng của chúng tôi.

Tôi muốn các cửa sổ chỉ có thể được mở thông qua menu ngữ cảnh đã được thêm vào trước đó.

Một công cụ sửa đổi cảnh mới, commandsRemoved, cho phép bạn sửa đổi một cảnh sao cho nó sẽ không còn cung cấp các lệnh mặc định nữa, giống như lệnh trong menu Tệp.

Sau khi áp dụng công cụ sửa đổi này, menu Tệp của chúng tôi hiện chỉ chứa một mục để mở cửa sổ cho WindowGroup chính.

Tôi không hoàn toàn hài lòng với bài thuyết trình hiện tại về cảnh cửa sổ phụ trợ để hiển thị hoạt động đọc của mình, vì vậy hãy tập trung vào điều đó tiếp theo.

Vì tôi sẽ áp dụng một vài công cụ sửa đổi cho nó, tôi sẽ trích xuất nó thành một cảnh tùy chỉnh, điều này sẽ giữ cho định nghĩa ứng dụng của tôi sạch hơn.

Không có bất kỳ trạng thái nào trước đó cho một cửa sổ, SwiftUI theo mặc định sẽ đặt nó ở giữa màn hình.

Tuy nhiên, tôi thích nó hơn nếu Hoạt động Đọc được đặt ở một vị trí khác theo mặc định.

Bằng cách thêm công cụ sửa đổi Vị trí mặc định mới, tôi có thể chỉ định một vị trí sẽ được sử dụng khi không có trạng thái nào trước đó khả dụng.

Vị trí này liên quan đến kích thước màn hình và sẽ đặt cửa sổ ở vị trí thích hợp có tính đến ngôn ngữ hiện tại.

Vị trí mới này giúp phân biệt cửa sổ Hoạt động của tôi với các cửa sổ xem khác trên màn hình.

Tôi cũng muốn cửa sổ Hoạt động của mình hiển thị ở một kích thước nhất định theo mặc định, nhưng vẫn có thể thay đổi kích thước.

Cùng với Vị trí mặc định, tôi sẽ thêm công cụ sửa đổi Kích thước mặc định.

Giá trị được cung cấp cho nó sẽ được trao cho hệ thống bố cục để lấy được kích thước ban đầu cho cửa sổ.

Bây giờ tôi đã tùy chỉnh bản trình bày cửa sổ của mình, hãy thêm một công cụ sửa đổi nữa để tùy chỉnh hành vi của nó.

Công cụ sửa đổi keyboardShortcut cũng đã được mở rộng để hoạt động trên các loại cảnh.

Khi được sử dụng ở cấp độ cảnh, công cụ sửa đổi này ảnh hưởng đến lệnh tạo ra một cửa sổ mới.

Ở đây, tôi đã sửa đổi cửa sổ Hoạt động của mình để nó có thể được mở bằng phím tắt Option-Command-0.

Đây có thể là một cách tuyệt vời để tùy chỉnh ứng dụng của bạn bằng cách cung cấp các phím tắt cho các cảnh thường được sử dụng và cũng có thể được sử dụng để tùy chỉnh phím tắt mặc định của Command-N, được thêm vào WindowGroup chính trong ứng dụng của bạn.

Điều này kết thúc chuyến tham quan của chúng tôi về cảnh mới và chức năng cửa sổ trong SwiftUI.

Chúng tôi thực sự vui mừng về tiềm năng của những API mới này và hy vọng bạn cũng vậy!

Để biết thêm thông tin tuyệt vời về cách thêm chức năng vào ứng dụng iPadOS và macOS của bạn, vui lòng xem các phiên khác sau: "SwiftUI trên iPad: Sắp xếp giao diện của bạn" và "SwiftUI trên iPad: Thêm thanh công cụ, tiêu đề và hơn thế nữa."

Cảm ơn vì đã xem.

♪