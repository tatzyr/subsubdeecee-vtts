10114

♪ nhạc cụ hip hop ♪

Chào mừng mọi người. Tên tôi là David Hayward, và tôi là một kỹ sư phần mềm trong nhóm Core Image.

Hôm nay tôi sẽ mô tả cách bạn có thể hiển thị nội dung Dải động mở rộng trong ứng dụng Core Image của mình.

Bài nói chuyện của tôi sẽ được chia thành bốn phần.

Đầu tiên, tôi sẽ giới thiệu một số thuật ngữ quan trọng cho EDR trên nền tảng của chúng tôi.

Thứ hai, tôi sẽ mô tả một dự án mẫu Core Image mới, sau đó tôi sẽ sử dụng để chứng minh cách thêm hỗ trợ cho EDR.

Cuối cùng, tôi sẽ chỉ cho bạn cách sử dụng CIFilters để tạo ra hình ảnh tạo ra nội dung EDR.

Vì vậy, hãy bắt đầu với một số thuật ngữ chính.

SDR, hay Dải động tiêu chuẩn, là cách truyền thống để thể hiện màu RGB bằng cách sử dụng phạm vi chuẩn hóa từ 0 cho màu đen đến 1 cho màu trắng.

Ngược lại, EDR, hay Dải động mở rộng, là cách được đề xuất để thể hiện màu RGB vượt quá phạm vi bình thường.

Như với SDR, 0 đại diện cho màu đen và 1 đại diện cho cùng độ sáng với SDR trắng.

Nhưng với EDR, các giá trị lớn hơn 1 có thể được sử dụng để biểu diễn các điểm ảnh thậm chí còn sáng hơn.

Nhưng hãy nhớ rằng, trong khi các giá trị lớn hơn một được cho phép, các giá trị trên khoảng không sẽ bị cắt bớt.

Khoảng không có nguồn gốc từ Nits tối đa hiện tại của màn hình chia cho Nits của SDR màu trắng.

Lưu ý rằng giá trị khoảng không có thể khác nhau giữa các màn hình hoặc khi điều kiện môi trường xung quanh hoặc độ sáng màn hình thay đổi.

Tôi khuyên bạn nên xem bài thuyết trình "Khám phá EDR trên iOS" để thảo luận sâu hơn về những khái niệm này.

Có một số nguồn cho nội dung EDR mà bạn có thể trình bày trong ứng dụng của mình.

Đầu tiên, một số định dạng tệp, chẳng hạn như TIFF và OpenEXR, có thể lưu trữ các giá trị dấu phẩy động cho EDR.

Ngoài ra, bạn có thể sử dụng AVFoundation để lấy khung hình từ các định dạng video HDR.

Metal APIs có thể được sử dụng để kết xuất môi trường EDR thành một kết cấu.

Ngoài ra, các tệp ProRAW DNG có thể được hiển thị để hiển thị các điểm nổi bật của EDR.

Bài thuyết trình năm 2021 "Chụp và xử lý hình ảnh ProRAW" mô tả chi tiết điều này.

Đối với phần tiếp theo của bài thuyết trình của tôi, tôi sẽ mô tả cách sử dụng Core Image với Metal trong ứng dụng SwiftUI.

Sau đó, tôi sẽ phác thảo cách thêm hỗ trợ EDR cho ứng dụng này.

Gần đây chúng tôi đã phát hành một dự án mã mẫu mới thể hiện các phương pháp hay nhất về cách kết hợp Core Image và Metal Kit View trong ứng dụng đa nền tảng SwiftUI.

Tôi khuyên bạn nên tải xuống mẫu và xem mã, nhưng hãy để tôi nhân cơ hội này để cho bạn thấy nó trông và hoạt động như thế nào.

Mẫu vẽ một CIImage hoạt hình, thủ tục được hiển thị thành chế độ xem Kim loại.

Để có hiệu suất tối ưu, mẫu sử dụng MTKView.

Để giữ cho mã đơn giản, ứng dụng hiển thị bảng kiểm hoạt hình CIImage dưới dạng proxy cho bất kỳ nội dung nào mà ứng dụng của bạn mong muốn.

Ngoài ra, ứng dụng sử dụng SwiftUI để có thể sử dụng cơ sở mã chung trên các nền tảng macOS, iOS và iPadOS.

Dự án được xây dựng từ một vài tệp nguồn ngắn, vì vậy hãy để tôi mô tả cách các lớp tương tác.

Có ba phần quan trọng trong ứng dụng này.

Đầu tiên và quan trọng nhất là "MetalView".

Nó cung cấp một triển khai Chế độ xem tương thích SwiftUI bao bọc lớp MTKView.

Bởi vì lớp MTKView dựa trên NSView trên macOS và UIView trên các nền tảng khác, việc triển khai MetalView sử dụng ViewRepresentable để kết nối giữa SwiftUI và các lớp MTKView dành riêng cho nền tảng.

Tuy nhiên, MTKView không chịu trách nhiệm trực tiếp về việc kết xuất.

Thay vào đó, nó sử dụng đại diện của mình để thực hiện công việc đó.

Trong ứng dụng này, lớp Renderer là đại diện cho MTKView.

Nó chịu trách nhiệm khởi tạo các đối tượng trạng thái đồ họa như hàng đợi lệnh Metal và bối cảnh Core Image.

Nó cũng triển khai phương thức draw() được yêu cầu phải là đại diện MetalView.

Tuy nhiên, Trình kết xuất không chịu trách nhiệm trực tiếp trong việc xác định hình ảnh nào cần vẽ.

Thay vào đó, nó sử dụng khối imageProvider của nó để có được một CIImage để vẽ.

Trong ứng dụng này, lớp ContentView triển khai khối mã cung cấp CIImage sẽ được hiển thị.

Tóm lại ngắn gọn, MetalView kêu gọi đại diện của mình rút thăm.

Phương thức Renderer draw() gọi ContentView để cung cấp hình ảnh để vẽ.

Hãy để tôi nói chi tiết hơn một chút về mã trong ba lớp này, bắt đầu với mã makeView() trong lớp MetalView.

Khi makeView() được gọi để tạo MTKView, nó sẽ đặt đại diện của chế độ xem thành đối tượng trạng thái Renderer.

Đây là cách tiếp cận chuẩn để triển khai chế độ xem SwiftUI bao bọc NSView hoặc UIView.

Tiếp theo, nó đặt khung ưa thích PerSecond để chỉ định tần suất hiển thị chế độ xem.

Thuộc tính này rất quan trọng vì nó xác định điều gì thúc đẩy bản vẽ của chế độ xem.

Hãy để tôi mô tả cách thức hoạt động của nó.

Mẫu này là một ứng dụng hoạt hình, vì vậy mã đặt view.preferredFramesPerSecond thành tốc độ khung hình mong muốn.

Bằng cách cài đặt điều này, MTKView được cấu hình sao cho chính chế độ xem điều khiển thời gian của các sự kiện vẽ.

Điều này khiến đại diện kết xuất của chế độ xem vẽ () theo định kỳ, do đó, sẽ yêu cầu nhà cung cấp nội dung tạo CIImage cho thời gian hiện tại.

Và quá trình sẽ lặp lại và lặp lại cho đến khi hoạt ảnh bị tạm dừng.

Trong các trường hợp khác, chẳng hạn như đối với ứng dụng chỉnh sửa hình ảnh, tốt nhất là các tương tác của người dùng với các điều khiển để điều khiển khi chế độ xem nên được vẽ.

Bằng cách đặt enableSetNeedsDisplay thành true, MTKView được cấu hình để các điều khiển có thể điều khiển thời gian của các sự kiện vẽ.

Khi một điều khiển được di chuyển, phương thức updateView() sẽ được gọi.

Sau đó, đại diện của chế độ xem sẽ được gọi để vẽ() một lần.

Và mỗi lần rút thăm sẽ yêu cầu nhà cung cấp nội dung tạo CIImage cho trạng thái kiểm soát hiện tại.

Cách tiếp cận này cũng phù hợp khi sự xuất hiện của các khung hình video sẽ thúc đẩy các sự kiện bốc thăm.

Điều đó kết thúc cuộc thảo luận của tôi về lớp MetalView.

Tiếp tục, mã quan trọng nhất trong đại diện Renderer là phương thức draw().

Phương thức draw() của trình kết xuất được gọi ở tốc độ khung hình tuần hoàn.

Khi phương thức draw() được gọi, nó cần xác định hệ số tỷ lệ nội dung phản ánh độ phân giải của màn hình mà chế độ xem đang bật.

Điều này là cần thiết vì CIImages được đo bằng pixel, không phải điểm.

Điều quan trọng là phải làm điều này mỗi khi phương thức draw() được gọi vì thuộc tính này có thể thay đổi nếu chế độ xem được chuyển đến một màn hình khác.

Tiếp theo, nó tạo ra một CIRenderDestination với mtlTextureProvider.

Sau đó, nó gọi nhà cung cấp nội dung để tạo CIImage để sử dụng cho thời gian hiện tại và hệ số quy mô.

Hình ảnh trả về này sau đó được căn giữa trong khu vực hiển thị của chế độ xem và được trộn lẫn trên nền mờ đục, và sau đó chúng tôi bắt đầu nhiệm vụ hiển thị CIImage đến đích xem.

Mã quan trọng nhất trong lớp ContentView là phương thức init().

Phương thức init() chịu trách nhiệm tạo nội dung của chế độ xem Nội dung.

Làm điều này sẽ thiết lập các kết nối với các lớp Renderer và MetalView.

Đầu tiên, nó tạo ra một đối tượng Renderer với một khối nhà cung cấp hình ảnh.

Khối đó chịu trách nhiệm trả lại CIImage cho thời gian và quy mô được yêu cầu.

Và cuối cùng, nó đặt phần thân của ContentView thành MetalView sử dụng Trình kết xuất đó.

Được rồi, bây giờ đã xong, chúng tôi có một ứng dụng SwiftUI đơn giản có thể hiển thị bằng Core Image.

Tiếp theo, hãy xem cách bạn có thể sửa đổi ứng dụng này để hỗ trợ kết xuất với khoảng trống EDR.

Thật dễ dàng để thêm hỗ trợ EDR cho ứng dụng này.

Bước 1 là khởi tạo chế độ xem cho EDR, bước 2 là tính toán khoảng không trước mỗi lần kết xuất và bước 3 là xây dựng CIImage sử dụng khoảng không có sẵn.

Hãy để tôi chỉ cho bạn mã thực tế cho những bổ sung này.

Đầu tiên, một bổ sung nhỏ là cần thiết trong lớp MetalView.

Khi bạn thực hiện chế độ xem, bạn cần nói với lớp mà nó muốn ExtendedDynamicRangeContent và cho chế độ xem biết rằng pixelFormat của nó phải là .rgba16Float và không gian màu của nó phải được mở rộng và tuyến tính.

Thứ hai, một số thay đổi là cần thiết trong phương thức draw() của lớp Renderer.

Trong phương thức draw(), chúng ta cần thêm mã lấy màn hình hiện tại cho chế độ xem và sau đó hỏi màn hình về khoảng trống EDR hiện tại.

Sau đó, khoảng không được chuyển như một tham số cho khối nhà cung cấp hình ảnh.

Lưu ý rằng điều quan trọng là phải làm điều này mỗi khi phương thức draw() được gọi.

Khoảng không là một thuộc tính năng động sẽ thay đổi tùy thuộc vào điều kiện môi trường xung quanh hoặc độ sáng màn hình thay đổi như thế nào.

Và thay đổi thứ ba là khối nhà cung cấp trong lớp ContentView.

Ở đây chúng ta cần thêm đối số khoảng trống vào khai báo khối nhà cung cấp hình ảnh.

Sau đó, chúng ta có thể sử dụng khoảng không với CIFilters để trả lại CIImage trông tuyệt vời trên màn hình EDR của người dùng.

Vì vậy, tóm lại, đây là ba bước đơn giản để thêm hỗ trợ EDR cho ứng dụng này: khởi tạo chế độ xem cho EDR, xác định khoảng không trước mỗi lần kết xuất và xây dựng CIImage để hiển thị khoảng không đã cho.

Đây sẽ là chủ đề của phần còn lại của bài thuyết trình này.

Bây giờ ứng dụng hỗ trợ EDR, hãy làm cho nó hiển thị một số nội dung EDR bằng cách sử dụng CIFilters để tạo CIImages.

Hơn 150 bộ lọc được tích hợp trong Core Image hỗ trợ EDR.

Điều này có nghĩa là tất cả các bộ lọc này có thể tạo ra hình ảnh với nội dung EDR hoặc xử lý hình ảnh có chứa nội dung EDR.

Ví dụ, các bộ lọc CIColorControls và CIExposureAdjust có thể cho phép ứng dụng của bạn thay đổi độ sáng, màu sắc, độ bão hòa và độ tương phản của hình ảnh với màu EDR.

Và một số bộ lọc, chẳng hạn như bộ lọc gradient, có thể tạo ra hình ảnh với các thông số màu EDR.

Ba bộ lọc mới mà chúng tôi đã thêm vào trong năm nay cũng hỗ trợ hình ảnh EDR.

Đáng chú ý nhất, CIAreaLogarithmicHistogram có thể tạo ra một biểu đồ cho một phạm vi giá trị độ sáng tùy ý.

Bộ lọc CIColorCube là ví dụ về bộ lọc mà chúng tôi đã cập nhật trong năm nay để hoạt động tốt hơn với hình ảnh đầu vào EDR.

Tất cả các bộ lọc tích hợp này chỉ hoạt động vì không gian màu làm việc của Core Image không bị kẹp và tuyến tính, cho phép các giá trị RGB nằm ngoài phạm vi 0 đến 1.

Khi bạn phát triển ứng dụng của mình, bạn có thể kiểm tra xem một bộ lọc nhất định có hỗ trợ EDR hay không.

Để làm điều này, bạn tạo một phiên bản của bộ lọc, sau đó hỏi các thuộc tính của bộ lọc cho các danh mục của nó và sau đó kiểm tra xem mảng có chứa kCICategoryHighDynamicRange hay không.

Ngoài ra, một tính năng mới mà chúng tôi đã thêm vào là hỗ trợ gỡ lỗi Xcode QuickLook cho các biến CIFilter.

Điều này sẽ hiển thị tài liệu cho từng lớp Bộ lọc, bao gồm các danh mục và yêu cầu của mỗi tham số đầu vào.

Với tất cả các bộ lọc EDR này, có vô số hiệu ứng mà ứng dụng của bạn có thể áp dụng cho nội dung của nó.

Trong ví dụ mà tôi sẽ mô tả hôm nay, tôi sẽ thêm hiệu ứng gợn sóng với phản xạ gương sáng vào mẫu bàn cờ từ ứng dụng mẫu.

Để tạo hiệu ứng này, chúng ta cần một ví dụ của bộ lọc rippleTransition.

Tiếp theo, chúng tôi đặt cả hình ảnh đầu vào và hình ảnh mục tiêu là hình ảnh kiểm tra.

Sau đó, chúng tôi đặt các đầu vào bộ lọc điều khiển trung tâm và thời gian chuyển tiếp của gợn sóng...

Và đặt hình ảnh đổ bóng thành một gradient sẽ tạo ra một điểm nhấn gương trên gợn sóng.

Và cuối cùng, chúng tôi yêu cầu bộ lọc cho outputImage với tất cả các đầu vào bộ lọc mà chúng tôi đã đặt.

Hãy để tôi cũng mô tả cách tạo Hình ảnh đổ bóng sẽ được sử dụng để tạo điểm nổi bật gương cho hiệu ứng gợn sóng.

Chúng tôi có thể tạo hình ảnh này từ dữ liệu bitmap, nhưng để có hiệu suất tốt hơn, chúng tôi có thể tạo CIImage này theo thủ tục.

Để làm điều này, chúng tôi tạo ra một thể hiện của bộ lọc linearGradient.

Bộ lọc này tạo ra một gradient cho hai điểm và hai CIColors.

Chúng tôi muốn gương có màu trắng, với độ sáng dựa trên khoảng không hiện tại nhưng giới hạn ở mức tối đa hợp lý.

Giới hạn mà bạn sử dụng sẽ phụ thuộc vào giao diện của hiệu ứng mà bạn muốn áp dụng.

Màu0 nên được tạo ra bằng cách sử dụng mức độ trắng đó trong một không gian màu tuyến tính không bị kẹp.

Màu 1 được đặt thành màu rõ ràng.

Điểm 0 và điểm 1 được đặt thành tọa độ sao cho gương sẽ xuất hiện từ hướng trên bên trái.

Và sau đó hình ảnh đầu ra của bộ lọc được cắt theo kích thước cần thiết cho bộ lọc gợn sóng.

Kết quả gợn sóng với hiệu ứng gương chỉ là một proxy đơn giản cho những gì bạn có thể làm trong ứng dụng của mình.

Tuy nhiên, nó minh họa một nguyên tắc quan trọng.

Tốt nhất là sử dụng các điểm ảnh sáng ở mức độ vừa phải.

Ít hơn là nhiều hơn.

Các điểm ảnh sáng sẽ có tác động nhiều hơn theo cách đó.

Bây giờ chúng tôi có một ứng dụng hoạt động sử dụng hai CIFilters tích hợp cho hiệu ứng EDR.

Vui lòng thử nghiệm với các bộ lọc EDR tích hợp khác.

Tiếp theo, tôi muốn dành vài phút để thảo luận về cách tốt nhất để sử dụng bộ lọc CIColorCube cũng như một số điều nên và không nên khi viết bộ lọc tùy chỉnh của riêng bạn.

Một bộ lọc rất phổ biến là CIColorCubeWithColorSpace.

Theo truyền thống, bộ lọc này được sử dụng để áp dụng giao diện cho hình ảnh SDR.

Bộ lọc này thậm chí còn được sử dụng để triển khai các hiệu ứng trong ứng dụng Ảnh như Process, Instant và Tonal.

Theo truyền thống, dữ liệu khối lập phương được sử dụng trông như thế này có một hạn chế quan trọng: dữ liệu chỉ nhập và xuất ra các màu RGB trong phạm vi 0-to 1.

Một cách để tránh giới hạn này là yêu cầu bộ lọc CIColorCubeWithColorSpace sử dụng không gian màu EDR như HLG hoặc PQ.

Điều này có thể mang lại kết quả tốt nhất cho nội dung EDR, nhưng điều này sẽ yêu cầu tạo dữ liệu khối lập phương mới hợp lệ trong phạm vi không gian màu.

Ngoài ra, bạn có thể cần tăng kích thước khối lập phương.

Thay vào đó, bạn có thể muốn tiếp tục sử dụng dữ liệu khối lập phương SDR trên hình ảnh EDR: Mới trong năm nay, bạn có thể yêu cầu bộ lọc ngoại suy dữ liệu khối lập phương SDR.

Để kích hoạt tính năng này, hãy đặt dữ liệu khối lập phương SDR như bình thường.

Sau đó đặt thuộc tính ngoại suy mới của bộ lọc.

Với điều này được đặt thành 'true', bạn có thể cung cấp cho bộ lọc một hình ảnh đầu vào EDR và nhận được một hình ảnh đầu ra EDR.

Chủ đề cuối cùng tôi muốn đề cập hôm nay là một số phương pháp hay nhất nếu bạn đang tạo CIKernels tùy chỉnh của riêng mình.

Đầu tiên, hãy xem lại mã hạt nhân của bạn cho toán học giới hạn các giá trị RGB trong phạm vi 0 đến 1 bằng cách sử dụng các hàm như kẹp, tối thiểu hoặc tối đa.

Trong nhiều trường hợp, các giới hạn này có thể được loại bỏ một cách an toàn và hạt nhân sẽ hoạt động chính xác.

Thứ hai, mặc dù các giá trị RGB có thể vượt quá phạm vi 0 đến 1, giá trị alpha phải nằm trong khoảng từ 0 đến 1, nếu không bạn sẽ nhận được hành vi không xác định khi pha trộn hoặc hiển thị hình ảnh.

Trong ví dụ này, hạt nhân vô tình nhân kênh alpha với 5, khi hành vi chính xác là chỉ nhân các giá trị RGB với 5.

Điều đó kết thúc bài thuyết trình của tôi.

Để kết thúc, hôm nay chúng tôi đã học cách thêm hỗ trợ cho khoảng trống EDR vào ứng dụng Core Image SwiftUI cũng như cách sử dụng nhiều loại CIFilters tích hợp để tạo và sửa đổi nội dung EDR.

Cảm ơn bạn đã xem!

♪ nhạc cụ hip hop ♪