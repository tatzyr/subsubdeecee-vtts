10056

♪ ♪

Paul: Xin chào, và chào mừng bạn đến với Soạn Bố cục Tùy chỉnh với SwiftUI.

Tôi là Paul, và tôi làm việc trên tài liệu dành cho nhà phát triển.

SwiftUI cung cấp một tập hợp phong phú các khối xây dựng mà bạn sử dụng để soạn giao diện ứng dụng của mình.

Bạn có thể kết hợp các chế độ xem tích hợp hiển thị các yếu tố như văn bản, hình ảnh và đồ họa để tạo các chế độ xem tổng hợp, tùy chỉnh.

Để sắp xếp tất cả các yếu tố này trong các nhóm phức tạp hơn bao giờ hết, SwiftUI cung cấp các công cụ bố cục.

Các vùng chứa như ngăn xếp ngang và dọc cho phép bạn cho SwiftUI biết nơi đặt các chế độ xem tương đối với nhau, trong khi các công cụ sửa đổi chế độ xem cung cấp cho bạn quyền kiểm soát bổ sung đối với những thứ như khoảng cách và căn chỉnh.

Trong buổi nói chuyện này, tôi sẽ giới thiệu một số công cụ mới giúp một số bố cục phổ biến thậm chí còn dễ xây dựng hơn và có thể tạo ra các bố cục phức tạp hơn.

Trên đường đi, tôi sẽ cung cấp cho bạn một số mẹo để làm việc với bố cục trong SwiftUI.

Tôi sẽ bắt đầu bằng cách hiển thị cho bạn một thành viên mới của họ lưới hoàn hảo cho bố cục hai chiều khi bạn có một bộ chế độ xem tĩnh để hiển thị.

Tiếp theo tôi sẽ nói về cách bạn có thể tạo một loại vùng chứa chế độ xem tùy chỉnh cho phép bạn tương tác trực tiếp với công cụ bố cục, sử dụng giao thức bố cục mới.

Sau đó, tôi sẽ nói về ViewThatFits, một loại vùng chứa tự động chọn từ một bộ sưu tập các chế độ xem cho chế độ xem, tốt, phù hợp với không gian có sẵn.

Và cuối cùng, tôi sẽ chỉ cho bạn cách thêm chuyển tiếp liền mạch giữa các loại bố cục bằng AnyLayout.

Để xem tất cả các tính năng mới này đang hoạt động, chúng ta hãy xem một ứng dụng mà tôi đang làm việc.

Trong những năm gần đây, đã có một số cuộc tranh luận giữa một số đồng nghiệp của tôi về việc ai là người bạn đồng hành lông xù tốt nhất.

Tôi có ý kiến của riêng mình, nhưng tôi tò mò muốn xem liệu chúng ta có thể đi đến sự đồng thuận hay không, vì vậy tôi quyết định tạo một ứng dụng để tham gia một cuộc thăm dò ý kiến.

Và tôi cũng muốn bao gồm những người bị dị ứng lông thú, vì vậy tôi sẽ đưa ra một lựa chọn bổ sung.

Bây giờ, tôi thích thực hiện hầu hết các thiết kế giao diện của mình trong SwiftUI, bởi vì nó rất dễ dàng để tạo mẫu bằng cách sử dụng các bản xem trước, nhưng như một điểm khởi đầu, tôi đã vẽ một bản phác thảo nhanh về những gì tôi đang hướng tới.

Tôi hy vọng cuộc bỏ phiếu sẽ diễn ra trong một khoảng thời gian, vì vậy tôi muốn một bảng xếp hạng ở giữa hiển thị bảng xếp hạng hiện tại.

Tôi sẽ đặt các nút để bỏ phiếu ở dưới cùng.

Và ở trên cùng, tôi sẽ hiển thị một số hình ảnh về những gì mọi người đang bỏ phiếu.

Được rồi, điều đầu tiên tôi muốn làm là xây dựng bảng xếp hạng.

Vì vậy, chúng ta hãy xem xét kỹ hơn về điều đó.

Bảng xếp hạng là một lưới các phần tử hai chiều với các hàng cho mỗi ứng cử viên và các cột hiển thị tên, tỷ lệ phần trăm và số phiếu bầu.

Tôi có một vài điều cụ thể mà tôi muốn đạt được ở đây.

Đầu tiên, tôi muốn hai cột văn bản chỉ rộng như chúng cần để chứa ô rộng nhất trong mỗi trường hợp vì tôi muốn các chế độ xem tiến trình đại diện cho tỷ lệ phần trăm nhận được càng nhiều không gian càng tốt.

Và điều này cần phải đúng cho dù số lượng lớn đến đâu đối với bạn bè của tôi nói các ngôn ngữ khác hoặc cho bất kỳ ai sử dụng các kích thước văn bản khác nhau trên thiết bị của họ.

Thứ hai, tôi muốn các tên được căn chỉnh cạnh hàng đầu, nhưng số lượng được căn chỉnh cạnh sau.

Bây giờ, SwiftUI đã có các lưới lười biếng, rất tốt cho nội dung có thể cuộn.

Các vùng chứa này rất hiệu quả khi bạn có nhiều chế độ xem, bởi vì chúng chỉ tải các chế độ xem có thể nhìn thấy hoặc sắp hiển thị.

Mặt khác, điều đó có nghĩa là thùng chứa không thể tự động định cỡ các ô của nó ở cả hai chiều.

Ví dụ, LazyHGrid có thể tìm ra độ rộng để tạo ra mỗi cột, bởi vì nó có thể đo tất cả các chế độ xem trong một cột trước khi vẽ chúng.

Nhưng nó không thể đo mọi chế độ xem liên tiếp để tìm ra chiều cao của hàng.

Để thực hiện công việc này, các lưới lười biếng cần bạn cung cấp thông tin về một trong các kích thước của chúng tại thời điểm khởi tạo.

Để xem xét kỹ hơn các lưới lười biếng và các loại vùng chứa bố cục SwiftUI hiện có khác, hãy xem các cuộc nói chuyện về Ngăn xếp, lưới và phác thảo từ năm 2020.

Nhưng trong trường hợp của tôi, tôi không cần cuộn và tôi muốn SwiftUI tìm ra cả chiều cao và chiều rộng cho mỗi ô.

Đối với loại bố cục này, SwiftUI hiện cung cấp chế độ xem Lưới.

Không giống như lưới lười, lưới tải tất cả các chế độ xem của nó cùng một lúc, vì vậy nó có thể tự động kích thước và căn chỉnh các ô của nó trên cả cột và hàng của nó.

Hãy xem mã cho việc này.

Đây là phiên bản cơ bản của bảng xếp hạng của tôi được viết dưới dạng Lưới.

Chế độ xem lưới cụ thể này chứa ba trường hợp GridRow.

Trong một hàng, mỗi chế độ xem tương ứng với một cột.

Vì vậy, trong ví dụ này, chế độ xem văn bản đầu tiên trong mỗi hàng tương ứng với cột đầu tiên, chế độ xem tiến trình nằm trong cột thứ hai và chế độ xem văn bản cuối cùng là cột thứ ba.

Lưu ý rằng lưới phân bổ nhiều không gian cho mỗi hàng và cột như nó cần để giữ chế độ xem lớn nhất của nó.

Vì vậy, cột văn bản đầu tiên đủ rộng cho tên dài nhất, nhưng không rộng hơn.

Các chế độ xem linh hoạt như chỉ báo tiến độ chiếm nhiều không gian như lưới cung cấp, trong trường hợp này là bất cứ thứ gì còn sót lại sau khi phân bổ không gian cho các cột văn bản.

Tôi muốn điều chỉnh điều này một chút, nhưng trước tiên, hãy để tôi tạo một mô hình dữ liệu cơ bản để cung cấp cho tôi một nơi nào đó để lưu trữ số phiếu bầu.

Tôi sẽ cần nhiều logic hơn để quản lý và chia sẻ dữ liệu trên mạng, nhưng trong khi tôi đang tạo mẫu giao diện, tôi chỉ cần một cấu trúc đơn giản như thế này.

Tôi sẽ bao gồm sự phù hợp có thể nhận dạng, bởi vì điều đó sẽ giúp việc sử dụng loại này dễ dàng hơn trong ForEach và sự phù hợp có thể đánh đồng để có thể tạo hiệu ứng động cho các thay đổi.

Và tôi sẽ tạo một tập hợp dữ liệu ví dụ để sử dụng trong các bản xem trước của mình trong khi tôi tạo mẫu.

Quay trở lại lưới của mình, tôi có thể tạo một biến trạng thái và khởi tạo nó bằng dữ liệu ví dụ của mình.

Và sử dụng dữ liệu đó, bây giờ tôi có thể tạo các hàng với ForEach.

Lưu ý rằng đầu ra được hiển thị không thay đổi vì nó vẫn hiển thị cùng một dữ liệu.

Điều đó đã khá gần, nhưng tôi cần sửa căn chỉnh ô.

Ngay bây giờ, tất cả các ô đều được căn giữa, đây là mặc định cho lưới, nhưng nếu bạn nhớ, tôi muốn các tên được căn chỉnh cạnh hàng đầu và các giá trị được căn chỉnh cạnh sau.

Để làm điều đó, tôi sẽ khởi tạo lưới với căn chỉnh cạnh trước.

Giá trị tôi sử dụng ở đây áp dụng cho tất cả các ô trong lưới.

Điều đó hoạt động tốt cho hai cột đầu tiên của tôi, nhưng còn cột cuối cùng thì sao?

Để ảnh hưởng đến việc căn chỉnh một cột duy nhất, tôi có thể áp dụng công cụ sửa đổi chế độ xem gridColumnAlignment cho bất kỳ một ô nào trong cột đó.

Vì vậy, tôi sẽ làm điều đó với chế độ xem văn bản ở cột cuối cùng.

Được rồi, nó đang đến đó, nhưng bây giờ tôi đang nhìn vào nó, tôi cảm thấy nó sẽ tốt hơn với một dải phân cách giữa mỗi hàng.

Nếu tôi chỉ thêm một hàng mới vào ForEach bằng một dải phân cách, đây không chính xác là những gì tôi muốn, nhưng lưu ý rằng điều này cho thấy một vài điều thú vị.

Đầu tiên, bởi vì dải phân cách là một chế độ xem linh hoạt, nó khiến cột đầu tiên chiếm nhiều không gian hơn.

Về cơ bản, lưới hiện đang cung cấp cho cột cuối cùng những gì nó cần và chia không gian còn lại giữa hai cột đầu tiên.

Thứ hai, đối với một hàng lưới không có nhiều chế độ xem như các hàng lưới khác, các chế độ xem bị thiếu chỉ tạo các ô trống trong các cột sau.

Nhưng điều tôi thực sự muốn là có dải phân cách trải dài tất cả các cột của lưới và SwiftUI có một công cụ sửa đổi chế độ xem mới cho phép tôi làm điều đó.

Bằng cách thêm công cụ sửa đổi gridCellColumns vào chế độ xem, tôi có thể yêu cầu một chế độ xem duy nhất mở rộng một số cột; trong trường hợp này, cả ba.

Và trên thực tế, đối với trường hợp chế độ xem sẽ mở rộng toàn bộ lưới, tôi có thể đơn giản hóa điều này bằng cách chỉ viết chế độ xem một mình, bên ngoài một hàng lưới.

Được rồi, bảng xếp hạng của tôi ở trong tình trạng khá tốt vì vậy hãy để tôi xem các nút được sử dụng để bỏ phiếu tiếp theo.

Thoạt nhìn, không có gì quá lạ mắt ở đây.

Tuy nhiên, tôi có một yêu cầu đặc biệt.

Một mặt, tôi không muốn thiên vị những người tham gia của mình với các nút nhỏ hơn cho một số lựa chọn nhất định.

Nhưng tôi cũng không muốn các nút phát triển lớn như thùng chứa của chúng, có thể rất lớn trên iPad hoặc Mac.

Thay vào đó, tất cả các nút phải có chiều rộng bằng văn bản nút rộng nhất.

Vậy điều gì sẽ xảy ra nếu tôi cố gắng xây dựng cái này bằng Hstack?

Những gì tôi thấy là mỗi nút tự kích thước để phù hợp với nhãn văn bản của nó và HStack đóng gói chúng lại với nhau theo chiều ngang.

Hành vi ngăn xếp mặc định này chính xác là những gì bạn muốn trong nhiều trường hợp, nhưng nó không hoàn toàn đáp ứng thông số kỹ thuật của tôi cho dự án này.

Để được bồi dưỡng về các nguyên tắc cơ bản về bố cục trong SwiftUI, hãy xem Chế độ xem tùy chỉnh Xây dựng với SwiftUI talk từ năm 2019.

Sử dụng các khái niệm từ cuộc nói chuyện đó, chúng ta hãy xem xét hệ thống phân cấp quan điểm này để xem những gì tôi có thể thay đổi để có được hành vi tôi muốn.

Đầu tiên, thùng chứa của ngăn xếp đề xuất một kích thước cho ngăn xếp.

Dựa trên điều này, ngăn xếp đề xuất kích thước cho ba nút của nó, và sau đó mỗi nút chuyển kích thước đó qua nhãn văn bản của nó.

Chế độ xem văn bản tính toán kích thước mà họ thực sự muốn, điều này phụ thuộc vào chuỗi chúng chứa và báo cáo điều này cho nút.

Nút chuyển thông tin trở lại.

Ngăn xếp tự định cỡ với thông tin này, đặt các nút trong không gian của nó và sau đó báo cáo kích thước riêng của nó cho vùng chứa của nó.

Được rồi, vậy nếu các nút có kích thước văn bản của chúng, điều gì sẽ xảy ra nếu tôi bọc mỗi chế độ xem văn bản trong một khung linh hoạt và cho phép nó phát triển?

Văn bản không thay đổi, nhưng nút nhìn thấy chế độ xem phụ linh hoạt, chiếm nhiều dung lượng như HStack cung cấp.

Ngăn xếp sau đó phân phối không gian của nó bằng nhau giữa các chế độ xem mà nó chứa.

Vì vậy, các nút bây giờ đều có cùng kích thước, điều này thật tuyệt, nhưng kích thước thực tế của chúng phụ thuộc vào thùng chứa của ngăn xếp.

Ngăn xếp sẽ mở rộng để lấp đầy bất kỳ không gian nào mà thùng chứa cung cấp, và đó không phải là điều tôi muốn.

Những gì tôi thực sự muốn là một loại ngăn xếp tùy chỉnh yêu cầu kích thước lý tưởng của mỗi nút, tìm kích thước rộng nhất và sau đó cung cấp dung lượng đó cho mỗi nút.

May mắn thay, SwiftUI có một công cụ mới cho phép tôi làm điều đó.

Sử dụng giao thức Bố cục, tôi có thể xác định một vùng chứa bố cục tùy chỉnh tham gia trực tiếp vào quy trình bố cục với hành vi phù hợp với trường hợp sử dụng của tôi.

Hãy xem cái này hoạt động như thế nào.

Nhìn vào HStack một lần nữa, hãy để tôi thay đổi nó thành EqualWidthHStack một loại mà tôi sẽ xác định để giải quyết vấn đề cụ thể của mình.

Loại này sẽ phân bổ chiều rộng cho các nút bằng nhau, với số lượng rộng bằng chiều rộng lý tưởng của nút rộng nhất.

Tôi sẽ giữ các khung linh hoạt để các nút có văn bản hẹp hơn có thể mở rộng để lấp đầy khoảng trống mà ngăn xếp cung cấp.

Nhưng các nút vẫn sẽ có kích thước lý tưởng mà tôi có thể đo, đó là chiều rộng văn bản của chúng.

Vậy hãy xem làm thế nào tôi có thể triển khai MyEqualWidthHStack.

Tôi bắt đầu bằng cách tạo ra một loại phù hợp với giao thức Bố cục.

Đối với bố cục cơ bản, tất cả những gì tôi cần là hai phương pháp bắt buộc.

Hãy thêm cuống cho những thứ đó.

Phương pháp đầu tiên là sizeThatFits, nơi tôi sẽ tính toán và báo cáo vùng chứa bố cục của mình lớn như thế nào.

Tôi nhận được đầu vào kích thước chế độ xem được đề xuất, đó là đề xuất kích thước từ chế độ xem vùng chứa của riêng bố cục của tôi.

Và tôi có thể đề xuất kích thước cho các chế độ xem con của bố cục của mình bằng cách sử dụng tham số Chế độ xem phụ.

Lưu ý rằng tôi không thể truy cập trực tiếp vào các chế độ xem phụ.

Thay vào đó, đầu vào lượt xem con là một tập hợp các proxy cho phép tôi tương tác theo những cách cụ thể với các lượt xem con, như đề xuất kích thước.

Mỗi proxy trả về một kích thước cụ thể dựa trên đề xuất mà tôi đã đưa ra.

Tôi sẽ thu thập tất cả những câu trả lời đó và sử dụng chúng để thực hiện một số phép tính và sau đó trả lại kích thước cụ thể cho EqualWidthHStack cho thùng chứa của nó.

Phương pháp thứ hai mà tôi phải thực hiện là placeSubviews.

Tôi sẽ sử dụng cái này để cho biết các chế độ xem con của bố cục của tôi nơi xuất hiện.

Phương pháp này có cùng kích thước đề xuất và đầu vào lượt xem phụ, và nó cũng có đầu vào giới hạn đại diện cho khu vực mà tôi cần đặt chế độ xem con của mình vào.

Bounds là một hình chữ nhật có kích thước mà tôi đã yêu cầu trong việc triển khai sizeThatFits của mình.

Hãy nhớ rằng, các chế độ xem chọn kích thước của riêng chúng trong SwiftUI, vì vậy vùng chứa bố cục của tôi sẽ nhận được kích thước mà nó yêu cầu.

Nguồn gốc của vùng nằm ở trên cùng bên trái, với X dương ở bên phải và Y dương ở dưới.

Bạn có thể giả định điều này cho tất cả các tính toán vị trí của mình, ngay cả trong môi trường ngôn ngữ từ phải sang trái, bởi vì khung tự động lật vị trí x của mỗi chế độ xem khi bố trí chế độ xem theo hướng đó.

Tuy nhiên, đừng cho rằng nguồn gốc của hình chữ nhật có giá trị (0,0).

Trong số những thứ khác, cho phép nguồn gốc khác 0 cho phép bố cục bố cục, trong đó phương thức placeSubviews của một bố cục gọi vào cùng một phương thức của một bố cục khác.

Để làm việc dễ dàng hơn một chút, hình chữ nhật cung cấp các thuộc tính để truy cập các phần quan trọng của khu vực, như các điểm tối thiểu, trung tâm và tối đa trong mỗi chiều.

Bây giờ, trước khi tôi tiếp tục, hãy chú ý một tham số khác mà cả hai phương thức này đều có: bộ nhớ cache hai chiều mà tôi có thể sử dụng để chia sẻ kết quả tính toán trung gian qua các cuộc gọi phương thức.

Đối với nhiều bố cục đơn giản, bạn sẽ không cần cái này, và tôi sẽ bỏ qua bộ nhớ cache ngay bây giờ.

Tuy nhiên, nếu việc lập hồ sơ ứng dụng của bạn với Công cụ cho thấy rằng bạn cần cải thiện hiệu quả của mã bố cục của mình, bạn có thể xem xét thêm một mã.

Kiểm tra tài liệu để biết thêm thông tin về điều đó.

Được rồi, hãy thực hiện sizeThatFits.

Hãy nhớ rằng, tôi muốn trả lại một kích thước cho thùng chứa của mình phù hợp với tất cả các nút được sắp xếp theo chiều ngang, tất cả đều có cùng chiều rộng.

Vì vậy, trước tiên, tôi sẽ hỏi mỗi nút về kích thước của nó, điều mà tôi làm bằng cách đề xuất một kích thước và xem những gì quay trở lại.

Để đo lường tính linh hoạt của chế độ xem phụ, tôi có thể thực hiện nhiều phép đo bằng cách sử dụng các đề xuất đặc biệt cho kích thước tối thiểu, tối đa và lý tưởng hoặc tôi có thể đề xuất một kích thước cụ thể.

Trong trường hợp này, tôi sử dụng đề xuất kích thước không xác định để yêu cầu kích thước lý tưởng.

Sau đó, tôi sẽ tìm thấy giá trị lớn nhất trong mỗi chiều cho tất cả các kích thước mà tôi nhận lại.

Trong trường hợp này, nút cá vàng đặt chiều rộng và chiều cao đều giống nhau.

Bây giờ hãy để tôi tái cấu trúc nó thành một phương pháp, bởi vì tôi sẽ cần nó một lần nữa khi tôi đặt các chế độ xem phụ của mình.

Tiếp theo, tôi cần tính đến khoảng cách giữa các chế độ xem.

Tôi chỉ có thể sử dụng khoảng cách không đổi, như 10 điểm, nhưng giao thức bố cục cho phép tôi làm tốt hơn.

Trong SwiftUI, tất cả các chế độ xem đều có tùy chọn khoảng cách cho biết dung lượng không gian mà chế độ xem muốn có giữa chính nó và chế độ xem tiếp theo.

Các tùy chọn này được lưu trữ trong một phiên bản ViewSpacing có sẵn để bố trí các vùng chứa.

Chế độ xem có thể thích các giá trị khác nhau trên các cạnh khác nhau và thậm chí các giá trị khác nhau cho các loại chế độ xem liền kề khác nhau.

Ví dụ, một chế độ xem có thể muốn nhiều hoặc ít hơn không gian giữa chính nó và chế độ xem văn bản hơn là nó muốn giữa chính nó và một hình ảnh.

Và các giá trị cũng có thể thay đổi tùy theo nền tảng.

Bạn có thể bỏ qua các tùy chọn này nếu nó có ý nghĩa đối với bố cục của bạn, về cơ bản đó là những gì đang xảy ra khi bạn khởi tạo ngăn xếp tích hợp với khoảng cách tùy chỉnh, nhưng tôn trọng các tùy chọn này trong bố cục của riêng bạn là một cách tốt để có được kết quả tự động tuân theo các nguyên tắc giao diện của Apple và kết

Bây giờ, mọi chế độ xem đều có tùy chọn trên tất cả các cạnh và khi tôi kết hợp hai chế độ xem lại với nhau, các tùy chọn trên một cạnh chung có thể không khớp.

Để giải quyết vấn đề này, một vùng chứa bố cục tích hợp sử dụng tùy chọn lớn hơn trong hai tùy chọn.

Và tôi có thể làm điều tương tự trong bố cục của riêng mình.

Các proxy xem phụ cho tôi một cách để yêu cầu khoảng cách ưa thích của mỗi nút với một số nút khác dọc theo một trục nhất định.

Vì vậy, hãy để tôi tạo một mảng các giá trị bằng cách quét qua các chế độ xem con và gọi phương thức khoảng cách trên mỗi phiên bản khoảng cách của proxy để đưa khoảng cách đến phiên bản khoảng cách của chế độ xem tiếp theo dọc theo trục ngang.

Cuộc gọi này tính đến sở thích của cả hai quan điểm trên lợi thế chung của chúng.

Phần tử đầu tiên trong mảng này cho tôi biết nút mèo muốn có bao nhiêu không gian theo chiều ngang với nút cá vàng và phần tử tiếp theo cho tôi biết nút cá vàng muốn nút chó bao nhiêu.

Tôi sẽ buộc phần tử cuối cùng trong mảng bằng 0 vì không còn bất kỳ nút nào để so sánh nữa.

Được rồi, hãy để tôi tái cấu trúc nó thành một phương pháp cho sau này.

Bây giờ tôi có thể kết hợp các giá trị khoảng cách để tìm tổng khoảng cách và sử dụng nó với các phép đo chiều rộng và chiều cao để trả về giá trị kích thước.

Đây là kích thước mà bố cục của tôi cần, với kích thước lý tưởng của các chế độ xem phụ và khoảng cách ưa thích của mỗi chế độ xem phụ.

Phương pháp khác mà tôi cần thực hiện là placeSubviews.

Như tôi đã đề cập trước đây, tôi nhận được cả giới hạn của vùng chứa và bộ sưu tập các proxy xem phụ mà tôi có thể sử dụng để điều khiển các nút.

Đầu tiên, tôi tính toán maxSize và mảng khoảng cách giống như tôi đã làm trong phương pháp sizeThatFits, bởi vì tôi cũng sẽ cần những giá trị đó ở đây.

Sau đó, tôi sẽ tạo một đề xuất kích thước mà tôi có thể sử dụng cho mỗi lượt xem phụ của mình, lần này dựa trên kích thước mà tôi muốn chúng có, thay vì kích thước lý tưởng của chúng.

Tôi chỉ cần một đề xuất, bởi vì tôi muốn tất cả các nút có cùng kích thước.

Và tôi sẽ tìm một vị trí bắt đầu trong kích thước ngang cho chế độ xem phụ đầu tiên của mình, được tính là cạnh trước của giới hạn của tôi, cộng với một nửa chiều rộng của nút.

Lưu ý rằng tôi không dựa vào nguồn gốc bằng 0, mà thay vào đó bắt đầu với giá trị minX.

Cuối cùng, tôi có thể xem qua từng proxy xem con và gọi phương thức vị trí của nó bằng một điểm, một tuyên bố về những gì điểm đó đại diện về nút và đề xuất kích thước.

Mỗi lần thông qua vòng lặp, tôi cập nhật vị trí nằm ngang theo chiều rộng của chế độ xem, cộng với khoảng cách cho cặp chế độ xem tiếp theo, để sẵn sàng cho lần lặp tiếp theo.

Và thế là xong.

Bây giờ hãy xem điều gì sẽ xảy ra khi tôi sử dụng kiểu bố cục chế độ xem mới này.

Và nó đây rồi.

Tôi khởi tạo vùng chứa bố cục tùy chỉnh của riêng mình giống như tôi làm với HStack tích hợp và các nút được sắp xếp theo chiều ngang, tất cả đều có cùng chiều rộng.

Bây giờ, tôi muốn tạm dừng ở đây một chút và nói về cách giao thức Bố cục giải quyết một vấn đề mà bạn có thể đã thử sử dụng trình đọc hình học trong quá khứ.

Xét cho cùng, đầu đọc hình học là một công cụ để đo kích thước chế độ xem.

Tuy nhiên, nó không phải là lựa chọn tốt nhất trong trường hợp này.

Và đó là bởi vì một trình đọc hình học được thiết kế để đo chế độ xem vùng chứa của nó và báo cáo kích thước đó cho chế độ xem phụ của nó.

Chế độ xem phụ sau đó sử dụng thông tin để vẽ nội dung của riêng nó.

Lưu ý rằng đối với mục đích sử dụng của trình đọc hình học, thông tin sẽ chảy xuống dưới.

Phép đo mà người đọc thực hiện không ảnh hưởng đến cách bố trí vùng chứa của chính nó.

Điều này thật tuyệt vời cho những thứ như vẽ một con đường có tỷ lệ với vùng chứa của nó.

Trình đọc hình học cho logic đường dẫn biết nó phải làm việc với bao nhiêu không gian và logic đường dẫn bên trong chế độ xem con điều chỉnh cho phù hợp.

Nếu vùng chứa thay đổi kích thước, đường dẫn cũng vậy, bởi vì trình đọc hình học đi dọc theo kích thước mới.

Tuy nhiên, đối với các nút của tôi và tôi sẽ chỉ tập trung vào một nút ở đây để dễ nhìn hơn, tôi cần đo chế độ xem văn bản và sau đó sử dụng nó để quyết định cách đặt khung là vùng chứa của chế độ xem văn bản.

Vì vậy, tôi có thể thêm một trình đọc hình học trong một lớp phủ vào chế độ xem văn bản - hãy nhớ rằng, nó đo vùng chứa của nó - và sau đó bằng cách nào đó gửi dữ liệu đo trở lại khung, bên ngoài luồng bình thường.

Nhưng lưu ý rằng nếu tôi làm điều này, tôi sẽ bỏ qua công cụ bố trí, điều này có thể dẫn đến một vòng lặp.

Người đọc đo bố cục và thay đổi khung, điều này có thể thay đổi bố cục, có thể yêu cầu một phép đo khác, v.v.

Bây giờ có thể làm cho điều này hoạt động, nhưng nếu tôi không cẩn thận, tôi có thể sẽ làm hỏng ứng dụng của mình.

Kết quả là, chiến lược này không được khuyến khích.

May mắn thay, giao thức bố cục cung cấp cho bạn một cách tốt hơn để giải quyết vấn đề này, bằng cách cho phép bạn làm việc trong công cụ bố cục.

Được rồi, hãy nhìn vào các nút một lần nữa.

Có điều gì đó khác tôi muốn làm ở đây.

Đầu tiên, để làm cho điều này dễ đọc hơn một chút, tôi sẽ cấu trúc lại các nút thành chế độ xem phụ của riêng chúng.

Bây giờ, tôi tình cờ biết rằng một trong những đồng nghiệp của tôi sử dụng loại lớn hơn trên thiết bị của họ.

Ứng dụng của tôi tự động hỗ trợ Dynamic Type vì tôi đã sử dụng phông chữ mặc định, vì vậy tôi hầu như sẽ nhận được hành vi phù hợp miễn phí.

Hãy xem điều gì sẽ xảy ra nếu tôi tăng kích thước loại.

Uh-oh, các nút không vừa nữa.

Hãy nhớ rằng ngăn xếp tùy chỉnh của tôi không hạn chế độ rộng của nút, mà chỉ cho phép chúng có kích thước lý tưởng, trong trường hợp này vượt quá chiều rộng của màn hình.

Vậy tôi có thể làm gì?

Chà, tôi có thể sửa đổi bố cục để làm điều gì đó phức tạp hơn khi chế độ xem không phù hợp, có tính đến đề xuất kích thước từ vùng chứa của bố cục.

Nhưng trong trường hợp này, tôi có thể sử dụng vùng chứa ViewThatFits mới để thực hiện hầu hết công việc cho mình.

Loại mới này chọn chế độ xem đầu tiên phù hợp với không gian có sẵn từ danh sách các chế độ xem mà tôi cung cấp cho nó.

Bằng cách gói ngăn xếp tùy chỉnh của tôi trong cấu trúc ViewThatFits và sau đó thêm phiên bản ngăn xếp dọc của cùng một nội dung, tôi có thể để SwiftUI tìm ra khi nào các nút cần được sắp xếp khác nhau.

Tất nhiên, VStack tích hợp không có thuộc tính chiều rộng bằng nhau như ngăn xếp ngang tùy chỉnh của tôi, vì vậy tôi cũng đã tiếp tục và triển khai phiên bản dọc của ngăn xếp tùy chỉnh.

Nó rất giống với cái mà tôi đã mô tả, ngoại trừ việc nó đặt các mục có chiều rộng bằng nhau dọc theo trục dọc thay vì trục ngang.

Và tất nhiên, khi tôi xóa ghi đè kích thước kiểu động, nó sẽ quay trở lại bố cục ngang.

Bây giờ, có một phần cuối cùng của ứng dụng tôi cần xây dựng, và đó là những hình ảnh ở trên cùng.

Tôi có thể làm một cái gì đó đơn giản, như chỉ cho xem một nhóm ảnh đại diện, nhưng tôi nghĩ tôi sẽ có một chút vui vẻ với nó.

Vì vậy, tôi đã tạo một loại bố cục tùy chỉnh khác vẽ các chế độ xem theo cách sắp xếp tròn và sau đó xoay sắp xếp theo thứ hạng.

Vì vậy, cấu hình này cho thấy cá vàng ở vị trí đầu tiên và hai con còn lại được buộc cho vị trí thứ hai.

Và sau đó nếu con chó kéo trước con mèo, tôi có thể xoay một chút để cho thấy điều đó.

Hoặc tôi có thể hiển thị một kết quả thực tế hơn một chút, tất cả bằng cách xoay bố cục xuyên tâm.

Tạo bố cục này thực sự khá đơn giản với giao thức bố cục.

Giống như trước đây, tôi chỉ cần hai phương pháp.

Đối với kích thước phù hợp, tôi muốn chế độ xem của mình lấp đầy không gian có sẵn, vì vậy tôi sẽ trả lại bất kỳ kích thước nào mà chế độ xem vùng chứa đề xuất.

Tôi sẽ chuyển đổi đề xuất thành kích thước cụ thể bằng cách sử dụng phương pháp thay thế kích thước không xác định.

Phương pháp đó tự động xử lý các giá trị nil có thể xuất hiện nếu vùng chứa yêu cầu kích thước lý tưởng.

Sau đó, bên trong phương pháp xem con vị trí, tôi sẽ bù đắp từng chế độ xem con từ giữa bằng một số bán kính dựa trên kích thước của vùng bố cục và áp dụng một vòng quay phụ thuộc vào chỉ mục của chế độ xem.

Làm đường cơ sở, điều này đặt các chế độ xem ở 0, 1 và hai phần ba đường xung quanh một vòng tròn.

Để phản ánh thứ hạng hiện tại, tôi cũng sẽ áp dụng phần bù ảnh hưởng đến tất cả các lượt xem như nhau.

Nhưng tôi lấy thứ hạng ở đâu?

Hãy nhớ rằng, bố cục của tôi chỉ có thể truy cập proxy xem phụ chứ không phải chế độ xem, chứ đừng nói đến mô hình dữ liệu của tôi.

Chà, hóa ra giao thức bố cục có một mẹo khác.

Nó cho phép bạn lưu trữ các giá trị trên mỗi chế độ xem phụ và đọc các giá trị từ bên trong các phương thức giao thức bố cục.

Hãy xem làm thế nào tôi có thể sử dụng nó để truyền đạt thông tin xếp hạng.

Đầu tiên, tôi khai báo một loại mới phù hợp với giao thức LayoutValueKey và cung cấp cho nó một giá trị mặc định.

Ngoài việc cung cấp giá trị cho chế độ xem khi bạn không đặt rõ ràng, giá trị mặc định sẽ thiết lập loại giá trị liên quan, là số nguyên trong trường hợp này.

Sau đó, tôi tạo một phương thức tiện lợi trên View để đặt giá trị bằng cách sử dụng công cụ sửa đổi chế độ xem layoutValue.

Bây giờ trong hệ thống phân cấp chế độ xem của tôi, tôi có thể áp dụng công cụ sửa đổi thứ hạng tiện lợi của mình cho các chế độ xem trong bố cục của mình.

Ở đây, tôi tính toán thứ hạng của từng thú cưng và thêm nó vào chế độ xem hình đại diện tương ứng của thú cưng bên trong bố cục xuyên tâm của tôi.

Cuối cùng, trở lại phương pháp xem phụ vị trí của tôi, tôi có thể thêm một số mã để đọc các giá trị từ mỗi chế độ xem phụ bằng cách sử dụng khóa giá trị bố cục làm chỉ mục.

Và tôi có thể sử dụng các cấp bậc để tính toán độ lệch.

Tôi sẽ không trải qua logic đó ở đây, nhưng về cơ bản nó tạo ra một góc thích hợp cho bất kỳ bộ thứ hạng nào có thể có.

Chà, tất cả ngoại trừ một.

Điều gì xảy ra nếu có một chiếc cà vạt ba chiều?

Không có cách nào để xoay bố cục để có được tất cả các chế độ xem trong một dòng, vì vậy tôi phải thay thế logic bố cục hoàn toàn khác cho trường hợp đó.

Tuy nhiên, đã có một loại bố cục thực hiện điều này và đó là HStack tích hợp sẵn.

Vì vậy, điều tôi thực sự muốn là chuyển sang HStack khi tôi phát hiện ra cà vạt ba chiều.

Và hóa ra cũng có một công cụ mới cho điều đó.

Loại AnyLayout cho phép bạn áp dụng các bố cục khác nhau cho một hệ thống phân cấp chế độ xem duy nhất, để bạn duy trì danh tính của các chế độ xem khi bạn chuyển từ loại bố cục này sang loại bố cục khác.

Vì vậy, ở đây tôi có bố cục xuyên tâm mà chúng ta đã thấy trước đây và tất cả những gì tôi phải làm là thay thế nó bằng một loại bố cục mới phụ thuộc vào việc có cà vạt ba chiều hay không.

Bởi vì thuộc tính isThreeWayTie có nguồn gốc từ trạng thái, SwiftUI nhận thấy khi nó thay đổi và nhận ra rằng nó cần vẽ lại chế độ xem này.

Nhưng bởi vì bản sắc cấu trúc của hệ thống phân cấp chế độ xem luôn giữ nguyên, SwiftUI coi đây là một chế độ xem thay đổi, chứ không phải là một chế độ xem mới.

Kết quả là, chỉ với một dòng nữa, tôi có thể tạo ra sự chuyển tiếp mượt mà giữa các loại bố cục.

Và trên thực tế, bằng cách thêm công cụ sửa đổi chế độ xem hoạt ảnh, tôi cũng nhận được hoạt ảnh giữa tất cả các trạng thái khác nhau của bố cục xuyên tâm, bởi vì cấu hình của bố cục xuyên tâm phụ thuộc vào cùng một dữ liệu.

Và đây là tất cả những gì trông giống như trong hành động.

Khi tôi nhấn vào các nút khác nhau để thay đổi số phiếu bầu, bạn có thể thấy cách các hình đại diện di chuyển trơn tru để phản ánh bảng xếp hạng hiện tại.

Vì vậy, đó là một số công cụ mới mà SwiftUI có để soạn bố cục chế độ xem ứng dụng của bạn.

Bạn có thể sử dụng loại Lưới để xây dựng bố cục hai chiều, có thể tùy chỉnh cao của thông tin tĩnh.

Bạn có thể sử dụng giao thức Bố cục để xác định mục đích chung của riêng bạn, bố cục có thể tái sử dụng hoặc bố cục được nhắm mục tiêu cao đến một trường hợp sử dụng cụ thể.

Bạn có thể sử dụng ViewThatFits khi bạn muốn SwiftUI chọn từ một nhóm chế độ xem để phù hợp nhất với không gian có sẵn.

Và bạn có thể chuyển đổi liền mạch giữa các loại bố cục bằng cách sử dụng AnyLayout.

Cảm ơn vì đã tham gia cùng tôi hôm nay, và tôi hy vọng bạn sẽ vui vẻ khi chơi với những công cụ bố cục mới này như tôi.