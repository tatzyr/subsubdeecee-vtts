10007

♪ Nhạc hip-hop nhạc cụ êm dịu ♪

♪

Dani Chootong: Xin chào, và chào mừng đến với "Có gì mới với mua hàng trong ứng dụng."

Tôi là Dani, và tôi là một kỹ sư trong nhóm StoreKit.

Hôm nay tôi sẽ trình bày với đồng nghiệp Ian của mình và chúng tôi sẽ xem xét những cải tiến mới mà chúng tôi sẽ mang đến để mua hàng trong ứng dụng trong năm nay.

Năm ngoái, chúng tôi đã giới thiệu StoreKit 2, một bộ API mới được thiết kế từ đầu để giúp việc tích hợp mua hàng trong ứng dụng trở nên đơn giản.

StoreKit 2 sử dụng các tính năng ngôn ngữ hiện đại, bao gồm Swift đồng thời bằng cách sử dụng mẫu không đồng bộ/chờ đợi.

Về phía máy chủ, chúng tôi đã bổ sung các tính năng StoreKit mới này với một bộ điểm cuối Máy chủ App Store hoàn toàn mới.

Các điểm cuối máy chủ này giúp bạn dễ dàng truy xuất thông tin giao dịch và kiểm tra trạng thái đăng ký trên máy chủ của mình.

Chúng tôi cũng đã phát hành Phiên bản 2 của Thông báo Máy chủ App Store, để giúp việc theo dõi vòng đời đăng ký trên máy chủ của bạn dễ dàng hơn bao giờ hết.

Hôm nay tôi sẽ xem xét các API mới này, cũng như các cải tiến mà chúng tôi đang đưa vào các mô hình StoreKit mới.

Sau đó, Ian sẽ hướng dẫn bạn một số cập nhật máy chủ mới thú vị, bao gồm các cải tiến API Máy chủ App Store và API hoàn toàn mới cho Thông báo Máy chủ App Store.

Đầu tiên, tôi sẽ xem qua API Giao dịch Ứng dụng mới để xác minh việc mua ứng dụng của bạn.

Tiếp theo, tôi sẽ tìm hiểu một số thuộc tính mới mà chúng tôi đã thêm vào các mô hình StoreKit của mình.

Tôi sẽ giới thiệu cho bạn các API thân thiện với SwiftUI mới để đổi mã ưu đãi đăng ký và yêu cầu khách hàng xem lại ứng dụng của bạn.

Sau đó, tôi sẽ giới thiệu cho bạn về StoreKit Messages, một API được sử dụng để hiển thị tin nhắn App Store cho khách hàng của bạn.

Và cuối cùng, tôi sẽ xem xét một cải tiến mà chúng tôi đang thêm vào để bảo toàn Tên người dùng ứng dụng khi bạn di chuyển từ bản gốc sang API StoreKit hiện đại.

Trong suốt bài thuyết trình này, tôi sẽ sử dụng ứng dụng yêu thích của mình, Food Truck.

Trong ứng dụng Food Truck, tôi quản lý một chiếc xe tải thực phẩm bánh rán bật lên đến thăm nhiều thành phố khác nhau để giao bánh rán.

Vì vậy, hãy bắt đầu nào!

Gặp gỡ Giao dịch Ứng dụng.

Giao dịch ứng dụng là API mới của chúng tôi để xác minh việc mua ứng dụng của bạn.

Giao dịch ứng dụng đại diện cho thông tin đã ký để mua ứng dụng của bạn cho thiết bị mà nó đang chạy.

Nó được ký bằng JWS và nó thay thế phần chi tiết ứng dụng của biên lai ứng dụng từ StoreKit API ban đầu.

Cũng giống như xác minh giao dịch, StoreKit thực hiện xác minh tự động giao dịch ứng dụng cho bạn.

Tuy nhiên, nếu bạn muốn, bạn cũng có thể thực hiện xác nhận của riêng mình.

Xác thực chữ ký JWS là một tiêu chuẩn được ghi chép đầy đủ.

Bạn có thể tham khảo tài liệu công khai để thực hiện xác thực của riêng bạn.

StoreKit đảm nhận việc tự động cập nhật Giao dịch Ứng dụng khi cần thiết.

Tuy nhiên, trong trường hợp hiếm hoi mà người dùng nghĩ rằng có điều gì đó không ổn, nó có thể được làm mới.

Bạn nên cung cấp giao diện người dùng trong ứng dụng của mình để cho phép khách hàng của bạn làm mới giao dịch ứng dụng.

Điều này chỉ nên được sử dụng để đáp ứng với hành động của người dùng, vì việc làm mới Giao dịch Ứng dụng sẽ nhắc người dùng xác thực.

Ngăn chặn gian lận không phải là lý do duy nhất để yêu thích Giao dịch Ứng dụng.

Nếu bạn đang tìm cách chuyển đổi mô hình kinh doanh từ ứng dụng trả phí sang ứng dụng miễn phí cung cấp dịch mua hàng trong ứng dụng, nếu bạn tò mò về khách hàng nào đã đặt hàng trước ứng dụng của mình hoặc thậm chí nếu bạn chỉ muốn biết khi nào ứng dụng của mình được mua, đây là tất cả các tình huống bạn có thể xử lý với Giao dịch ứng dụng

Trong biên lai ứng dụng, tải trọng biên lai kết hợp dữ liệu mua hàng về ứng dụng của bạn cùng với tất cả các giao dịch mua trong ứng dụng đã xảy ra.

Chúng hiện được chia thành hai thành phần riêng biệt trong StoreKit.

Đầu tiên trong số này là Lịch sử Giao dịch.

API giao dịch của StoreKit cung cấp cho bạn cái nhìn sâu sắc về toàn bộ lịch sử mua hàng trong ứng dụng của người dùng, ngay trên thiết bị.

Các API này cho phép bạn tìm thông tin chính xác mà bạn cần, bao gồm các giao dịch mới nhất của người dùng, các giao dịch chưa hoàn thành và các quyền hiện tại.

Nếu bạn muốn thực hiện các phép tính này trên máy chủ của mình, bạn cũng có thể lấy lịch sử mua hàng của người dùng từ API Máy chủ App Store.

Ian sẽ có một số cập nhật thú vị về điều này vào cuối phiên này.

Và thành phần thứ hai là Giao dịch ứng dụng, chứa dữ liệu bạn cần để đảm bảo rằng ứng dụng của bạn hợp lệ với thiết bị mà nó đang chạy.

Thật dễ dàng để xác minh việc mua ứng dụng của bạn bằng Giao dịch ứng dụng và chỉ trong giây lát, tôi sẽ xem xét một ví dụ về cách bạn có thể sử dụng nó.

Nhưng trước tiên, hãy để tôi cung cấp cho bạn một số thông tin cơ bản về ứng dụng yêu thích của tôi.

Với Food Truck, tôi có thể giao bánh rán, kiểm tra nguồn cấp dữ liệu xã hội cơ bản và hình dung lịch sử bán hàng của mình.

Giữ tất cả thông tin này trong cơ sở dữ liệu là chi phí liên tục cho ứng dụng của tôi, vì vậy để giúp tôi trang trải chi phí, tôi sẽ biến biểu đồ lịch sử bán hàng hàng năm thành mua hàng một lần.

Ngoài ra, tôi muốn tăng cường nguồn cấp dữ liệu xã hội.

Vì vậy, thay vì chỉ nhìn thấy những gì người khác đang nói về xe bán đồ ăn của tôi, tôi muốn cung cấp các công cụ để tôi cũng có thể tương tác với khách hàng của mình.

Đây sẽ là một dịch vụ đăng ký, và tôi sẽ có một gói hàng tháng và một gói hàng năm.

Food Truck bắt đầu như một ứng dụng trả phí, nhưng tôi sẽ chuyển sang một ứng dụng miễn phí cung cấp dịch vụ mua hàng trong ứng dụng.

Nhưng tôi không muốn những khách hàng hiện tại của tôi đã mua Food Truck cảm thấy bị bỏ rơi.

Vì vậy, tôi sẽ sử dụng Giao dịch ứng dụng để đảm bảo rằng những khách hàng đã mua Food Truck tiếp tục có quyền truy cập vào nội dung cao cấp mà họ đã trả tiền.

Đây là dòng thời gian cho Xe tải thực phẩm.

Tại lần phát hành đầu tiên, Food Truck bắt đầu như một ứng dụng trả phí có giá 4,99 đô la.

Phiên bản 1.0 cung cấp dịch vụ giao bánh rán, nguồn cấp dữ liệu xã hội cơ bản và biểu đồ lịch sử bán hàng.

Sau đó, khi phát hành phiên bản 8.0, mô hình kinh doanh của tôi đã thay đổi.

Food Truck hiện miễn phí, nhưng bao gồm nhiều giao dịch mua trong ứng dụng mở khóa các tính năng cao cấp.

Biểu đồ lịch sử bán hàng hàng năm hiện là giao dịch mua một lần không thể tiêu thụ và bây giờ có dịch vụ đăng ký mới cho nguồn cấp dữ liệu xã hội cao cấp cung cấp cho bạn các công cụ tương tác nâng cao.

Bây giờ chúng ta hãy xem xét hai loại khách hàng khác nhau có thể bị ảnh hưởng bởi điều này.

Alice đã tìm hiểu về ứng dụng Food Truck của tôi trong phiên bản 2.5, và cô ấy quyết định muốn chia sẻ niềm đam mê của mình đối với bánh rán trong thế giới kỹ thuật số.

Vì vậy, cô ấy đã mua ứng dụng của tôi với giá 4,99 đô la và bắt đầu hành trình giao bánh rán của mình.

Khách hàng thứ hai, Bob, tìm hiểu về ứng dụng Food Truck của tôi mặc dù là một người bạn và tải xuống miễn phí trong App Store ở phiên bản 8.2.

Trong trường hợp này, Alice, người đã mua ứng dụng của tôi trước khi nó trở nên miễn phí, vẫn có quyền truy cập vào tất cả nội dung cao cấp mà cô ấy đã trả tiền.

Cô ấy vẫn có tùy chọn mua đăng ký nguồn cấp dữ liệu xã hội cao cấp, nhưng tôi không muốn phủ nhận cô ấy biểu đồ lịch sử bán hàng hàng năm ban đầu được bao gồm.

Bob, tuy nhiên, đã nhận được ứng dụng của tôi miễn phí.

Sau đó tôi biết không mở khóa các tính năng và nội dung cho đến khi họ hoàn tất việc mua hàng trong ứng dụng.

Vì vậy, hãy xem làm thế nào chúng ta có thể đạt được điều này với Giao dịch ứng dụng trong mã.

Tôi sẽ bắt đầu bằng cách tìm nạp giao dịch ứng dụng bằng cách gọi AppTransaction.shared.

Cuộc gọi này giúp tôi có được Kết quả Xác minh có chứa giao dịch ứng dụng của tôi.

Trong kết quả, loại AppTransaction chứa tải trọng JWS.

Tiếp theo, tôi sẽ bật kết quả lên.

Nếu kết quả chưa được xác minh, đây sẽ là thời điểm tốt để cảnh báo người dùng rằng việc mua ứng dụng của họ không thể được xác minh bởi App Store, và sau đó, tôi có thể nhắc họ làm mới giao dịch ứng dụng.

Tại thời điểm này, tôi sẽ cung cấp trải nghiệm tối thiểu cho ứng dụng của mình.

Nếu kết quả được xác minh, tôi sẽ sử dụng điều này như một cơ hội để kiểm tra xem người dùng đã mua ứng dụng của tôi chưa.

Khách hàng đã mua ứng dụng của tôi nên được cấp các dịch vụ mà họ đã thanh toán.

Đối với điều này, tôi sẽ sử dụng thuộc tính phiên bản ứng dụng gốc.

Thuộc tính này cho tôi biết phiên bản ứng dụng mà khách hàng đã tải xuống ứng dụng của tôi lần đầu tiên.

Phiên bản 8.0 là phiên bản mà ứng dụng của tôi trở nên miễn phí khi mua hàng trong ứng dụng.

Tôi sẽ chuyển phiên bản ứng dụng gốc của khách hàng sang chức năng của mình để kiểm tra xem người dùng có mua ứng dụng của tôi trước phiên bản 8.0 hay không.

Và với điều đó, tôi có thể đưa ra quyết định sáng suốt về cách tôi nên cung cấp nội dung cao cấp cho người dùng của mình.

Đối với những khách hàng như Alice, người đã mua ứng dụng của tôi, tôi sẽ cung cấp nội dung mà người dùng được hưởng mà họ có tại thời điểm mua.

Trong trường hợp của tôi, tôi sẽ mở khóa biểu đồ lịch sử bán hàng hàng năm cho việc giao hàng của cô ấy.

Ngoài ra, tôi muốn kiểm tra bất kỳ giao dịch mua bổ sung nào trong ứng dụng mà họ có thể đã thực hiện để tôi cũng có thể cung cấp điều đó.

Nếu không, tôi có thể tự tin rằng người dùng đã tải xuống ứng dụng của tôi sau khi tôi chuyển đổi mô hình kinh doanh của mình, như Bob.

Đây có thể là thời điểm tốt để kiểm tra các quyền hiện tại của người dùng để tôi có thể mở khóa các tính năng và nội dung mà họ đã trả tiền.

Và chỉ với một vài dòng mã, tôi đã có thể xác minh việc mua ứng dụng của mình, kiểm tra xem người dùng có tải xuống phiên bản trả phí của ứng dụng của tôi hay không và tôi có thể ngay lập tức bắt đầu cung cấp nội dung cao cấp của mình, cho dù khách hàng có mua ứng dụng của tôi hay không.

Với Giao dịch ứng dụng, bạn có thể dễ dàng hỗ trợ khách hàng của mình cho dù họ là những người ủng hộ sớm hay nếu họ vừa tải xuống ứng dụng của bạn gần đây.

Bây giờ tôi muốn chuyển sang các thuộc tính mới mà chúng tôi đang thêm vào các mô hình StoreKit của mình.

Tài sản đầu tiên trong số này là địa phương giá cả.

Giá địa phương hiện đã được bao gồm trong các sản phẩm StoreKit.

Bạn có thể đã quen thuộc với ngôn ngữ giá từ giao tiếp với API mua hàng ban đầu của chúng tôi.

Tiếp theo, tôi sẽ đào sâu vào tài sản môi trường máy chủ.

Bây giờ, bạn có thể cho môi trường máy chủ biết thông tin giao dịch hoặc gia hạn đã xảy ra.

Sau đó, tôi sẽ chuyển sang tài sản ngày bắt đầu đăng ký gần đây.

Bạn có thể sử dụng điều này như một công cụ để đưa ra quyết định sáng suốt cho khách hàng của mình dựa trên mô hình đăng ký của họ.

Và cuối cùng, tôi sẽ xem xét một số cân nhắc đặc biệt cho các thuộc tính này khi bạn sử dụng chúng với Kiểm tra StoreKit trong Xcode.

Các thuộc tính này trả về các giá trị trọng điểm trong các hệ điều hành cũ hơn và tôi sẽ giải thích điều này có nghĩa là gì chỉ trong một chút.

Các API StoreKit được thiết kế linh hoạt, vì vậy tôi tự hào thông báo rằng bạn có thể tận dụng các thuộc tính mới này trên các thiết bị từ các hệ điều hành năm ngoái, mặc dù ban đầu chúng không đi kèm với chúng.

Tất cả những gì bạn cần để thực hiện điều này là sử dụng Xcode 14 để xây dựng ứng dụng của mình và bạn sẽ có quyền truy cập vào các thuộc tính này trong các hệ điều hành trước đó.

Điều này có thể thực hiện được vì việc triển khai các thuộc tính này được tổng hợp vào ứng dụng của bạn, vì vậy khi khách hàng của bạn cập nhật lên phiên bản mới, họ sẽ có thể nhận được lợi ích của những cải tiến này mà không cần cập nhật hệ điều hành của họ.

Tuy nhiên, có một điều cần lưu ý khi sử dụng các thuộc tính này.

Các thuộc tính này sẽ trả về các giá trị trọng điểm khi bạn đang sử dụng thử nghiệm StoreKit trong Xcode trong các hệ điều hành cũ hơn này.

Khi tôi nói các giá trị trọng điểm, tôi đang đề cập đến các giá trị giữ chỗ báo hiệu rằng đây không phải là các giá trị thực mà bạn nên làm việc và tôi sẽ giải thích lý do tại sao điều này xảy ra.

Hộp cát và môi trường sản xuất sử dụng các thuộc tính này bằng cách trích xuất các giá trị từ phản hồi của máy chủ App Store.

Tuy nhiên, thử nghiệm StoreKit trong Xcode là một môi trường thử nghiệm cục bộ hoạt động độc lập với máy chủ App Store.

Điều này có nghĩa là chúng tôi không thể chuyển ngược giá trị của các thuộc tính này sang các hệ điều hành trước đó ở đó.

Bạn có thể dễ dàng vượt qua giới hạn này bằng cách cập nhật thiết bị thử nghiệm của mình lên hệ điều hành mới và bạn sẽ sẵn sàng kiểm tra các giá trị này trong môi trường cục bộ.

Hãy thảo luận về một số tình huống chứng minh cách bạn có thể bắt đầu sử dụng các thuộc tính mới này, đầu tiên trong số đó là địa phương giá cả.

Các sản phẩm StoreKit đã có thuộc tính giá hiển thị để gắn nhãn giá mua, nhưng với ngôn ngữ giá, bạn có thể định dạng các số xuất phát từ giá thập phân của sản phẩm.

Nếu bạn có đăng ký hàng năm, bạn có thể sử dụng điều này như một cơ hội để cho khách hàng của mình thấy họ sẽ phải trả bao nhiêu mỗi tháng.

Trong ví dụ này, bạn có thể thấy rằng đăng ký hàng năm lên tới 4,17 đô la mỗi tháng.

Hoặc có lẽ bạn muốn cho họ thấy họ sẽ tiết kiệm được bao nhiêu nếu họ mua dịch vụ hàng năm của bạn thay vì dịch vụ hàng tháng của bạn.

Với thông tin này, khách hàng của bạn có thể đưa ra quyết định sáng suốt khi họ đang xem xét các lựa chọn mua hàng của bạn.

Bây giờ, hãy chuyển sang tài sản môi trường.

Tài sản môi trường có sẵn trong Thông tin Giao dịch và gia hạn.

Thuộc tính này cho bạn biết môi trường máy chủ nơi thông tin giao dịch hoặc gia hạn bắt nguồn, có thể là Xcode, hộp cát hoặc sản xuất.

Ứng dụng của bạn có thể truyền đạt thông tin giao dịch đến máy chủ của bạn sau khi khách hàng mua hàng để ghi sổ và phân tích.

Khi ứng dụng của bạn tạo ra các giao dịch này, nó có thể đến từ bất kỳ một trong những môi trường máy chủ này.

Giống như hầu hết các bạn, tôi không muốn thêm nhiễu vào phân tích của mình với dữ liệu kiểm tra không liên quan.

Vì vậy, biết môi trường có thể giúp bạn lọc ra những thông tin không cần thiết được gửi đến máy chủ của bạn.

Cuối cùng, chúng ta hãy xem ngày bắt đầu đăng ký gần đây.

Ngày bắt đầu đăng ký gần đây có sẵn trong thông tin đăng ký của sản phẩm và nó đại diện cho giai đoạn đăng ký liên tục gần đây nhất.

Đăng ký được coi là liên tục nếu không có khoảng cách quá 60 ngày giữa hai giai đoạn đăng ký bất kỳ.

Hãy nhớ rằng khoảng thời gian này có thể chứa những khoảng trống mà khách hàng không đăng ký sản phẩm của bạn, vì vậy đừng sử dụng điều này làm chỉ báo cho số ngày khách hàng đã đăng ký.

Ngày bắt đầu đăng ký gần đây có thể giúp bạn xác định mô hình trung thành giữa bạn và khách hàng của bạn.

Đối với những khách hàng trung thành của bạn, bạn có thể trao cho họ phần thưởng như một cách để giữ cho họ tương tác với sản phẩm của bạn.

Hoặc nếu bạn nhận thấy rằng một khách hàng đã hủy đăng ký dịch vụ của bạn, bạn có thể sử dụng nó như một cơ hội để giành lại một khách hàng đã hết hạn bằng cách khuyến khích họ bắt đầu sử dụng lại sản phẩm của bạn.

Tôi đã đề cập trước đó rằng chúng ta sẽ xem xét kỹ hơn các giá trị trọng điểm cho các thuộc tính này.

Xin nhắc lại, khi tôi nói các giá trị trọng điểm, tôi đang đề cập đến các giá trị giữ chỗ đóng vai trò là chỉ báo về sự vắng mặt của giá trị thực.

Các giá trị trọng điểm cho các thuộc tính này rất dễ xác định.

Khi bạn đang xử lý ngôn ngữ giá, giá trị trọng điểm là một ngôn ngữ với mã định danh xx_XX.

Đối với thuộc tính môi trường, nó sẽ là một chuỗi trống.

Và cuối cùng, đối với ngày bắt đầu đăng ký gần đây, giá trị này là Date.distantPast.

May mắn thay, sự xuất hiện của các giá trị trọng điểm này có thể dự đoán được - bạn sẽ chỉ gặp chúng nếu bạn đang sử dụng thử nghiệm StoreKit trong Xcode trong các hệ điều hành cũ hơn và bạn có thể giải quyết vấn đề này bằng cách cập nhật thiết bị thử nghiệm của mình.

Vì vậy, bây giờ bạn đã thấy những cải tiến mà chúng tôi đã thực hiện cho các mô hình StoreKit của mình.

Và phần yêu thích của tôi là, chúng tương thích ngược với hệ điều hành nơi các mô hình được giới thiệu, vì vậy khách hàng của bạn có thể thấy các lợi ích ngay lập tức chỉ bằng cách cập nhật ứng dụng của bạn.

Khi bạn thực hiện số học với các giá trị giá, ngôn ngữ giá sẽ giúp bạn định dạng chính xác để nó khớp với ngôn ngữ của App Store.

Đối với các giao dịch và thông tin đăng ký, môi trường cho bạn biết chính xác nguồn gốc của chúng, vì vậy nếu bạn lưu trữ dữ liệu này trên máy chủ của mình, bạn có thể hành động tương ứng tùy thuộc vào môi trường.

Ngày bắt đầu đăng ký gần đây giúp bạn hiểu được lòng trung thành của khách hàng, vì vậy bạn có thể điều chỉnh các ưu đãi cụ thể cho khách hàng lâu năm hoặc có thể bạn có thể cung cấp ưu đãi cho những khách hàng đã hủy đăng ký.

Và trong trường hợp bạn đang thắc mắc, vâng, môi trường và ngày bắt đầu đăng ký gần đây cũng có sẵn thông qua API Máy chủ App Store và Thông báo Máy chủ Cửa hàng Ứng dụng, mà Ian sẽ thảo luận.

Bây giờ tôi muốn nói về các API SwiftUI mới mà chúng tôi đang cung cấp để đổi mã ưu đãi và yêu cầu đánh giá.

Mã ưu đãi có thể giúp bạn có được, giữ chân và giành lại người đăng ký bằng cách cung cấp đăng ký giảm giá hoặc miễn phí trong thời gian giới hạn.

Bây giờ trong App Store Connect, bạn có thể tạo các mã tùy chỉnh được đặt tên duy nhất.

Ở đó, bạn có thể đặt giới hạn đổi quà tối đa và bạn có thể chọn có đặt thời hạn sử dụng hay không.

Hãy xem xét việc triển khai SwiftUI để trình bày bảng đổi mã ưu đãi trực tiếp từ ứng dụng của bạn.

Ở đây, tôi có chế độ xem SwiftUI với một nút để kích hoạt bảng đổi mã ưu đãi.

Bảng đổi mã ưu đãi hiện có công cụ sửa đổi chế độ xem riêng trong SwiftUI.

Công cụ sửa đổi chế độ xem rất dễ sử dụng, nó chỉ cần một Boolean ràng buộc để bắt đầu quá trình.

Và một khi bảng mã đề nghị bị loại bỏ, bạn sẽ nhận được kết quả đại diện cho việc bảng có được trình bày thành công hay không.

Khi khách hàng đổi mã ưu đãi cho ứng dụng của bạn, giao dịch kết quả sẽ được gửi đến người nghe giao dịch.

Vì vậy, hãy đảm bảo thiết lập trình nghe giao dịch ngay khi ứng dụng của bạn khởi chạy để nhận các giao dịch mới và cập nhật trong khi ứng dụng của bạn đang chạy.

Công cụ sửa đổi chế độ xem mã ưu đãi có sẵn bắt đầu từ iOS 16.

Tiếp theo, tôi muốn nói về các bản cập nhật để yêu cầu xem xét.

Nhận phản hồi của khách hàng là điều quan trọng.

Khách hàng tiềm năng mới có thể sử dụng các đánh giá như một yếu tố quyết định trong quyết định tải xuống ứng dụng của bạn.

Những người khác có thể muốn để lại đánh giá như một cách để cung cấp phản hồi hoặc đề xuất.

Dù bằng cách nào, chúng tôi muốn cung cấp cho bạn các công cụ để giúp bạn dễ dàng yêu cầu xếp hạng từ khách hàng của mình, vì vậy bạn có thể cho họ biết bạn đang lắng nghe và bạn có thể tiếp tục tương tác với họ.

Hãy xem lại mã.

Ở đây tôi có một cái nhìn rất đơn giản để chứng minh các API Đánh giá Yêu cầu.

Trong SwiftUI, bây giờ có một giá trị môi trường được gọi là requestReview.

Bạn có thể sử dụng giá trị này để lấy một phiên bản của RequestReviewAction và khi bạn đã sẵn sàng yêu cầu xếp hạng, chỉ cần gọi phiên bản đó làm hàm để yêu cầu hiển thị lời nhắc đánh giá.

Bạn có thể quyết định thời điểm thích hợp để yêu cầu đánh giá cho ứng dụng của mình.

Tuy nhiên, bạn nên lưu ý rằng lời nhắc sẽ chỉ được hiển thị cho khách hàng tối đa ba lần trong khoảng thời gian 365 ngày.

Và bạn không nên yêu cầu khách hàng xem lại cùng một phiên bản ứng dụng của bạn nhiều lần.

Tránh làm gián đoạn khách hàng bằng lời nhắc đánh giá.

Thời điểm tốt để yêu cầu đánh giá có thể là sau khi họ đã có sự tương tác tích cực, chẳng hạn như hoàn thành giao dịch mua trên ứng dụng thương mại điện tử hoặc hoàn thành cấp độ trong trò chơi.

Cuối cùng, khách hàng có thể vô hiệu hóa các yêu cầu xuất hiện trên thiết bị của họ, vì vậy bạn không nên yêu cầu đánh giá do hành động của người dùng.

Những API này thực sự sẽ có ích cho các ứng dụng SwiftUI của bạn.

Tiếp theo, tôi muốn giới thiệu với bạn API mới của chúng tôi cho các tin nhắn StoreKit.

Thông báo StoreKit đại diện cho một trang tính xuất hiện trên ứng dụng của bạn để hiển thị thông tin quan trọng cho người dùng.

Tin nhắn được bán bởi App Store.

Mỗi tin nhắn có một lý do, được bao gồm trong siêu dữ liệu tin nhắn.

Tin nhắn StoreKit được truy xuất khi ứng dụng của bạn ở phía trước.

Ví dụ, chúng ta hãy xem xét một trong những lý do thông điệp - sự đồng ý tăng giá.

Khi bạn tăng giá đăng ký và nó yêu cầu sự đồng ý của người dùng, App Store sẽ thông báo cho những người đăng ký bị ảnh hưởng thông qua email, thông báo đẩy và bảng chấp thuận giá trong ứng dụng.

Trong trường hợp này, App Store yêu cầu người dùng đồng ý với giá đăng ký mới của bạn trước khi gia hạn ở mức giá cao hơn.

Vì vậy, nếu bạn quyết định tính phí nhiều hơn cho đăng ký của mình, bảng chấp thuận tăng giá có thể xuất hiện khi người dùng mở ứng dụng của bạn nếu họ chưa phản hồi việc tăng giá của bạn.

Theo mặc định, thông báo StoreKit xuất hiện trên ứng dụng của bạn khi người dùng đưa ứng dụng của bạn lên nền trước và nó có thể yêu cầu người dùng thực hiện một số hành động liên quan đến ứng dụng của bạn.

Hãy xem lại cái này.

Toàn bộ quá trình bắt đầu với ứng dụng của bạn.

Khi ứng dụng của bạn vào tiền cảnh, StoreKit biết kiểm tra xem có tin nhắn đang chờ xử lý để hiển thị hay không.

Và nếu có, StoreKit kiểm tra với App Store.

App Store trả lại thông tin về tin nhắn cho StoreKit.

Tại thời điểm này, StoreKit kiểm tra xem ứng dụng của bạn có được thiết lập để nhận tin nhắn hay không.

Bạn có thể làm điều này bằng cách thiết lập trình nghe tin nhắn trong ứng dụng của bạn, tôi sẽ sớm tham gia.

Nếu ứng dụng của bạn đã thiết lập trình nghe tin nhắn, StoreKit sẽ gửi thông tin về tin nhắn đến ứng dụng của bạn.

Bây giờ là cơ hội của bạn để quyết định xem đây có phải là thời điểm tốt để ứng dụng của bạn hiển thị tin nhắn hay không, hoặc nếu bạn muốn trì hoãn bài thuyết trình cho sau này.

Nếu bạn không thiết lập trình nghe tin nhắn, StoreKit sẽ hiển thị tin nhắn ngay lập tức bằng cách trình bày bảng tin nhắn qua ứng dụng của bạn.

Tôi sẽ xem xét cách làm điều này trong mã.

Nhưng trước khi tôi làm điều đó, tôi sẽ giải thích một tình huống trong đó sẽ rất hữu ích khi kiểm soát việc trình bày tin nhắn App Store.

Trong ứng dụng Food Truck, tôi có thể tùy chỉnh bánh rán mà tôi đang giao đến các thành phố khác nhau.

Nếu một tin nhắn được gửi đến ứng dụng của tôi trong thời gian này, sẽ gây nhầm lẫn cho người dùng nếu họ đột nhiên bị gián đoạn bởi một bảng tin nhắn, vì vậy tôi sẽ triển khai API tin nhắn để đảm bảo điều này không xảy ra bằng cách kiểm soát khi nào tin nhắn đến được hiển bày.

Bây giờ chúng ta hãy đi vào mã.

Ở đây, tôi có một cái nhìn đơn giản cho trình chỉnh sửa bánh rán.

Như tôi đã đề cập trước đó, các tin nhắn đang chờ xử lý được gửi mỗi khi ứng dụng của bạn đến tiền cảnh.

Vì vậy, tôi muốn thiết lập một trình nghe tin nhắn trong mỗi chế độ xem mà tôi muốn trì hoãn việc trình bày tin nhắn.

Tôi sẽ thêm một mảng ràng buộc để thu thập tất cả các tin nhắn được gửi đến ứng dụng của tôi trong khi tôi đang ở chế độ xem chỉnh sửa.

Điều này rất quan trọng, bởi vì nếu tôi không thiết lập trình nghe tin nhắn, StoreKit sẽ hiển thị bảng tin nhắn ngay lập tức khi ứng dụng của tôi ở phía trước.

Ngay khi chế độ xem xuất hiện, tôi đã thiết lập trình nghe tin nhắn của mình.

Tôi sẽ làm điều này bằng cách thiết lập một tác vụ lặp lại một thuộc tính tĩnh trên loại tin nhắn.

Thuộc tính này là một chuỗi không đồng bộ và tôi có thể nhận tin nhắn khi chúng đến.

Đối với trường hợp sử dụng của tôi, tôi sẽ lưu tin nhắn trong mảng pendingMessages.

Vì các tin nhắn đang chờ xử lý được gửi mỗi khi ứng dụng của bạn vào tiền cảnh, ứng dụng của bạn có thể nhận được cùng một tin nhắn nhiều lần, vì vậy tôi có điều kiện này để tránh thêm tin nhắn trùng lặp vào mảng của mình.

Sau đó, khi chế độ xem bị loại bỏ, tôi sẽ hiển thị các tin nhắn trong chế độ xem phụ huynh.

Đây là chế độ xem mẹ chứa liên kết điều hướng đến trình chỉnh sửa bánh rán.

Ở đây, tôi đã thu thập tất cả các tin nhắn đang chờ xử lý mà tôi cần hiển thị trong mảng pendingMessages này.

Vậy làm cách nào để hiển thị những tin nhắn đang chờ xử lý này?

Chà, bây giờ có một giá trị môi trường displayStoreKitMessage.

Điều này giúp bạn có được một phiên bản của DisplayMessageAction, sau đó bạn có thể sử dụng để hiển thị một tin nhắn nhất định.

Khi chế độ xem xuất hiện, tôi sẽ lặp lại các tin nhắn đang chờ xử lý và gọi displayStoreKitMessage chuyển trong tin nhắn tôi muốn hiển thị.

StoreKit đảm nhận việc trình bày bảng tin nhắn.

Trước đó, tôi đã đề cập rằng cùng một tin nhắn có thể được gửi đến ứng dụng của bạn nhiều lần.

Đó là bởi vì một tin nhắn không được đánh dấu là đã đọc cho đến khi nó được trình bày cho người dùng.

Vì vậy, StoreKit đảm bảo rằng mỗi tin nhắn duy nhất chỉ được trình bày một lần.

Và đó là một triển khai nhanh chóng của Messages API.

Hãy nhớ rằng, tin nhắn StoreKit được gửi đến ứng dụng của bạn mỗi khi nó đến tiền cảnh, vì vậy bạn sẽ muốn thiết lập trình nghe tin nhắn trong mỗi chế độ xem mà bạn muốn kiểm soát thời gian khi tin nhắn được hiển bày.

Bạn có thể đảm bảo khách hàng có trải nghiệm tuyệt vời bằng cách đảm bảo các tờ tin nhắn không xuất hiện vào những thời điểm bất ngờ.

Hoặc có lẽ bạn muốn điều chỉnh logic của mình cho một số loại tin nhắn nhất định.

Với thông báo đồng ý tăng giá, bạn có thể muốn giáo dục khách hàng của mình về giá trị bổ sung mà bạn đang cung cấp trước khi bảng chấp thuận tăng giá xuất hiện.

Cuối cùng, hãy xem lại cách StoreKit bảo quản tên người dùng ứng dụng dưới dạng appAccountToken sau khi người dùng mua hàng.

Nếu bạn có hệ thống tài khoản người dùng trên máy chủ của mình, rất có thể bạn đã sử dụng thuộc tính Tên người dùng ứng dụng.

Tên người dùng ứng dụng là một chuỗi mà bạn tạo để liên kết giao dịch với tài khoản người dùng trên dịch vụ của mình.

Trong API ban đầu để mua hàng trong ứng dụng, bạn đặt giá trị Tên người dùng ứng dụng khi bạn thêm thanh toán vào hàng đợi thanh toán.

Mặc dù tên người dùng ứng dụng chấp nhận bất kỳ chuỗi nào, chúng tôi khuyên bạn nên cung cấp biểu diễn chuỗi của UUID.

Khi bạn cung cấp cho nó một chuỗi UUID, StoreKit vẫn duy trì giá trị và bạn sẽ thấy nó trong giao dịch mà hàng đợi cập nhật.

Nếu bạn không cung cấp chuỗi UUID cho tên người dùng ứng dụng, StoreKit có thể không duy trì nó.

Không có gì đảm bảo giá trị sẽ tồn tại giữa thời điểm bạn thêm giao dịch thanh toán vào hàng đợi và khi hàng đợi cập nhật giao dịch.

Khi bạn cung cấp biểu diễn chuỗi của UUID, bạn có thể xác định tài khoản người dùng ứng dụng nào của mình đã bắt đầu và hoàn tất giao dịch.

Trong các API StoreKit hiện đại, chúng tôi triển khai khái niệm này dưới dạng tùy chọn mua hàng được gọi là appAccountToken và nó yêu cầu định dạng UUID.

Bây giờ, khi bạn đặt tên người dùng ứng dụng thành chuỗi UUID trong quá trình thanh toán, máy chủ App Store sẽ lưu trữ nó dưới dạng appAccountToken.

Vì vậy, bạn sẽ thấy UUID của nó xuất hiện trong thông tin giao dịch đã ký được trả về bởi API Máy chủ App Store và trong Thông báo Máy chủ Cửa hàng Ứng dụng V2.

Và với tư cách là UUID, nó tương thích với appAccountToken trong API giao dịch StoreKit hiện đại.

Vì vậy, bây giờ bạn có thể chắc chắn rằng khi bạn cập nhật cơ sở mã của mình lên các API StoreKit hiện đại, UUID bạn đã sử dụng cho ứng dụng Tên người dùng được giữ nguyên dưới dạng appAccountToken trong các giao dịch StoreKit.

Hôm nay chúng tôi đã đề cập đến rất nhiều thứ.

Trước khi chuyển sang các bản cập nhật máy chủ, hãy xem lại các bản cập nhật StoreKit năm nay.

Chúng tôi đã thảo luận về việc xác thực giao dịch mua ứng dụng của bạn bằng Giao dịch ứng dụng, đổi mã ưu đãi và yêu cầu đánh giá trong SwiftUI và kiểm soát việc trình bày tin nhắn StoreKit.

Chúng tôi đã nói về địa phương giá mới, môi trường và các thuộc tính ngày bắt đầu đăng ký gần đây.

Và, chúng tôi đã xem xét tầm quan trọng của việc sử dụng biểu diễn chuỗi của UUID cho Tên người dùng ứng dụng để duy trì nó dưới dạng mã thông báo tài khoản ứng dụng.

Tôi thực sự khuyên bạn nên xem phiên khác của chúng tôi "Có gì mới trong thử nghiệm StoreKit."

Và nếu bạn cần bồi dưỡng về API StoreKit 2, hãy xem phiên năm ngoái "Gặp gỡ StoreKit 2".

Bây giờ tôi muốn giao nó cho Ian để hướng dẫn bạn các bản cập nhật cho máy chủ App Store.

Ian Zanger: Cảm ơn, Dani.

Xin chào mọi người. Tên tôi là Ian, và tôi là một kỹ sư trong nhóm App Store Server.

Bây giờ bạn đã nghe tin mới nhất về việc mua hàng trong ứng dụng với StoreKit, tôi sẽ chuyển số và nói về máy chủ.

Đầu tiên, tôi sẽ xem xét một số phát triển gần đây từ năm ngoái trước khi chuyển sang một số bản cập nhật mới thú vị sắp ra mắt cho API Máy chủ App Store và Thông báo Máy chủ App Store Phiên bản 2.

Hãy bắt đầu nào.

Năm ngoái thật lớn.

Chúng tôi đã mang đến cho bạn một bộ điểm cuối hoàn toàn mới với API Máy chủ App Store và Thông báo Máy chủ App Store V2, bao gồm hỗ trợ kiểm tra hộp cát đầy đủ cho tất cả các tính năng mới này.

Chúng tôi đã chia sẻ cách bạn có thể sử dụng điểm cuối Nhận Lịch sử Giao dịch để nhận toàn bộ lịch sử mua hàng trong ứng dụng của người dùng hoặc điểm cuối Nhận Tất cả Trạng thái Đăng ký để cập nhật trạng thái đăng ký hiện tại của người dùng.

Cả hai điểm cuối này đều thuận tiện khóa khỏi originalTransactionId của người dùng, vì vậy bạn có thể truy cập kho dữ liệu này bằng cách chỉ lưu trữ một giá trị đơn giản này.

Chúng tôi cũng đề cập đến cách phiên bản 2 của Thông báo Máy chủ App Store có thể đơn giản hóa việc xử lý sự kiện trên máy chủ của bạn và bổ sung cho API Máy chủ App Store.

Với thông báo V2, máy chủ App Store gọi trực tiếp cho máy chủ của bạn, cung cấp các bản cập nhật mua hàng trong ứng dụng khi chúng xảy ra.

Loại thông báo được sắp xếp hợp lý và loại phụ giúp bạn dễ dàng hiểu những gì đang xảy ra.

Bạn có thể sử dụng những thứ này để theo dõi các thay đổi liên quan đến đăng ký trong ứng dụng và các sự kiện khác.

Với tất cả các nguồn dữ liệu này, chúng tôi muốn phân tích dữ liệu đó dễ dàng nhất có thể.

Biên lai bây giờ đã là quá khứ, vì các dịch vụ mới này cung cấp dữ liệu trong ứng dụng ở định dạng JSON đã ký, vì vậy bạn có thể dễ dàng phân tích cú pháp và tin tưởng rằng nó đến từ máy chủ App Store.

Năm ngoái là một năm trọng đại đối với máy chủ App Store.

Nó cũng có thể lớn đối với bạn nếu bạn làm việc để cập nhật mã máy chủ của mình để tận dụng tất cả các tính năng mới này.

Hãy yên tâm rằng nỗ lực sẽ tiếp tục được đền đáp khi chúng tôi mang đến những cải tiến và tính năng mới mạnh mẽ cho API Máy chủ App Store và Thông báo Máy chủ Cửa hàng Ứng dụng V2.

Đó là năm đánh giá của chúng tôi, nhưng nếu bạn muốn bồi dưỡng thêm sau khi nghe các bản cập nhật năm nay, hãy nhớ xem các phiên WWDC21 có tiêu đề "Quản lý mua hàng trong ứng dụng trên máy chủ của bạn", "Gặp gỡ StoreKit 2" và "Hỗ trợ khách hàng và xử lý hoàn tiền."

Bây giờ hãy chuyển sang các bản cập nhật hoàn toàn mới đến với máy chủ App Store cho WWDC22.

Đầu tiên tôi sẽ chia sẻ một số cập nhật cho các trường thông tin giao dịch và gia hạn.

Tiếp theo tôi sẽ cho bạn biết về những cải tiến mới đối với API Máy chủ App Store.

Và cuối cùng, tôi sẽ chia sẻ các tính năng mới thú vị sắp ra mắt trên App Store Server Notifications V2.

Bây giờ chúng ta hãy đi sâu vào chủ đề mới đầu tiên của chúng ta: các trường mới được tìm thấy trong thông tin giao dịch và gia hạn.

Trước đó, bạn đã nghe từ Dani về một vài lĩnh vực mới đến với thông tin giao dịch và gia hạn của các giao dịch mua trong ứng dụng.

Các trường này, môi trường và recentSubscriptionStartDate, cũng đang đến với tải trọng thông tin giao dịch và gia hạn mà bạn nhận được từ API Máy chủ App Store và trong Thông báo Máy chủ Cửa hàng Ứng dụng V2.

Hãy cùng xem xét mới dữ liệu mà bạn có thể mong đợi nhận được từ máy chủ App Store với các trường mới này được bao gồm.

Đầu tiên là tải trọng thông tin giao dịch, mà chúng ta có thể thấy ở đây sau khi giải mã.

Ở phía dưới, bạn có thể thấy lĩnh vực mới của chúng tôi: môi trường.

Bạn có thể sử dụng nó để biết, trong nháy mắt, liệu giao dịch đã diễn ra trong môi trường sản xuất hay hộp cát.

Tiếp theo là tải trọng thông tin gia hạn, cũng được thấy ở đây sau khi giải mã.

Như bạn có thể thấy, trường môi trường cũng có sẵn ở đây để bạn tham khảo.

Ngoài ra, recentSubscriptionStartDate bây giờ sẽ xuất hiện trong mọi tải trọng thông tin gia hạn.

Đây là ngày bắt đầu mua đăng ký đầu tiên của người dùng trong chuỗi gia hạn gần đây nhất của họ, bỏ qua bất kỳ khoảng trống nào từ 60 ngày trở xuống.

recentSubscriptionStartDate là một cách dễ dàng để có được ý tưởng về lòng trung thành của khách hàng trong nháy mắt.

Nhưng nếu bạn muốn biết thêm chi tiết, bao gồm thời gian và độ dài của bất kỳ khoảng trống nào trong dịch vụ, bạn có thể gọi điểm cuối Nhận Lịch sử Giao dịch và kiểm tra toàn bộ lịch sử mua hàng gia hạn đăng ký của người dùng.

Hoặc để biết thêm chi tiết, với Thông báo Máy chủ App Store V2, máy chủ App Store tự động gửi thông tin cập nhật về đăng ký người dùng đến máy chủ của bạn.

Những thông báo này cung cấp cho bạn cái nhìn sâu sắc tối đa về thời gian của các sự kiện như thay đổi tùy chọn gia hạn, đổi ưu đãi, thất bại thanh toán và hơn thế nữa.

Như bạn có thể thấy, recentSubscriptionStartDate làm tròn một bộ tùy chọn để xác định lòng trung thành của khách hàng.

Sử dụng các công cụ này để nhắm mục tiêu các ưu đãi và thưởng cho những khách hàng trung thành nhất của bạn.

Bây giờ hãy chuyển sang một số cải tiến mới thuận tiện cho điểm cuối Nhận Lịch sử Giao dịch.

Với điểm cuối Nhận Lịch sử Giao dịch, bạn có thể tìm nạp toàn bộ lịch sử mua hàng của người dùng trong ứng dụng của mình.

Phản hồi điểm cuối được phân trang để bạn có thể xử lý dữ liệu này theo các phần hợp lý.

Mỗi phản hồi chứa một mã thông báo sửa đổi mà bạn cung cấp trong yêu cầu tiếp theo để có được trang tiếp theo.

Và các trang được sắp xếp theo ngày sửa đổi, có nghĩa là mỗi trang tiếp theo chứa các giao dịch được sửa đổi gần đây hơn.

Hãy cùng xem cái này hoạt động như thế nào.

Bạn gọi điểm cuối Get Transaction History và cung cấp originalTransactionId.

Máy chủ App Store sẽ trả lại tối đa 20 giao dịch đã ký cho người dùng đó.

Nó cũng sẽ trả về một giá trị sửa đổi cập nhật mà bạn sẽ cung cấp trong yêu cầu trang tiếp theo của mình cho người dùng này.

Bạn sẽ biết có nhiều dữ liệu hơn khi trường hasMore trong phản hồi là đúng.

Giả sử trong trường hợp này có một trang dữ liệu khác có sẵn.

Bạn đưa ra một yêu cầu khác đến điểm cuối và bạn bao gồm giá trị sửa đổi đó từ phản hồi đầu tiên.

Bạn nhận được trang dữ liệu tiếp theo, bao gồm giá trị sửa đổi được cập nhật.

hasMore bây giờ là sai, vì vậy bạn biết rằng bạn đã cập nhật dữ liệu giao dịch mới nhất.

Ngoại trừ lần này, bạn nhận thấy điều gì đó về giao dịch cuối cùng trong phản hồi; bạn đã thấy nó trước đây!

Đó là một trong 20 ban đầu bạn nhận được để đáp ứng yêu cầu đầu tiên của mình.

Điều này có nghĩa là giao dịch phải được sửa đổi, vì vậy nó đã được đặt lại ở đầu thứ tự sắp xếp.

Bây giờ, bạn có thể kiểm tra dữ liệu của giao dịch đó và lưu ý những gì đã thay đổi.

Trong trường hợp này, bạn nhận thấy các trường revocationDate và revocationReason hiện đã được điền, có nghĩa là giao dịch đã bị thu hồi.

Bạn có thể thực hiện hành động bằng cách thu hồi bất kỳ nội dung nào liên quan đến giao dịch mua.

Bạn nên lưu trữ giá trị sửa đổi từ phản hồi cuối cùng này cùng với originalTransactionId mà bạn đã sử dụng để xác định người dùng.

Lần tới khi bạn gọi điểm cuối cho người dùng này, bạn có thể cung cấp bản sửa đổi đó và biết rằng bạn chỉ nhận lại dữ liệu giao dịch mới đã được sửa đổi kể từ yêu cầu cuối cùng của bạn.

Như bạn đã thấy, điểm cuối Nhận Lịch sử Giao dịch cung cấp cho bạn một cách đơn giản để truy xuất một bộ dữ liệu mua hàng trong ứng dụng toàn diện.

Nhưng có lẽ đôi khi nó có thể hơi quá toàn diện.

Một số người dùng có lịch sử mua hàng dài từ vài năm trước.

Đối với những người dùng này, điểm cuối này có thể trả lại hàng trăm giao dịch mua thuộc nhiều loại khác nhau.

Ngay cả với các trang, điều này có thể rất nhiều để xử lý.

Đó là lý do tại sao năm nay, chúng tôi đang tăng cường điểm cuối này với nhiều tùy chọn sắp xếp và lọc mới.

Bây giờ, bạn có thể cho chúng tôi biết chính xác dữ liệu bạn muốn ngay từ đầu, tiết kiệm thời gian xử lý trên máy chủ của bạn và giảm số lượng cuộc gọi mạng cần thiết để truy xuất tất cả các trang có sẵn.

Bạn có thể sắp xếp theo ngày sửa đổi giảm dần nếu bạn muốn xem các giao dịch mua được sửa đổi gần đây nhất trên trang kết quả đầu tiên.

Bạn cũng có thể lọc theo một số trường hữu ích như loại sản phẩm, ID sản phẩm, trạng thái chia sẻ trong gia đình và hơn thế nữa.

Để áp dụng các tùy chọn sắp xếp và lọc mới này, chỉ cần thêm chúng dưới dạng tham số truy vấn vào yêu cầu của bạn đến điểm cuối Nhận Lịch sử Giao dịch.

Chúng ta hãy xem xét kỹ hơn cách thức hoạt động của nó.

Tại đây bạn có thể thấy tất cả các tùy chọn tham số mới.

Những thứ này có thể trông quen thuộc, vì hầu hết được lấy trực tiếp từ tải trọng thông tin giao dịch.

Bạn có thể trộn và kết hợp các thông số này để có được kết quả rất cụ thể.

Ví dụ, có lẽ chúng tôi chỉ muốn tìm nạp các giao dịch mua không tiêu hao mà người dùng đã thực hiện kể từ đầu năm nay.

Chúng tôi cũng muốn loại trừ bất kỳ giao dịch mua bị thu hồi nào.

Chúng tôi sẽ xây dựng yêu cầu tùy chỉnh của mình bằng cách đặt productType thành NON_CONSUMABLE và chỉ định startDate là đầu năm nay được biểu thị bằng mili giây.

Cuối cùng, chúng tôi sẽ đặt excludeRevoked thành true.

Và đó là yêu cầu của chúng tôi!

Vì chúng tôi không chỉ định thứ tự sắp xếp, phản hồi sẽ mặc định sắp xếp theo ngày sửa đổi tăng dần.

Bây giờ ngay cả với một yêu cầu cụ thể như thế này, có thể có nhiều trang mua hàng để truy xuất.

Đối với các yêu cầu tiếp theo, chúng ta nên đảm bảo bao gồm các tham số truy vấn giống hệt nhau, ngoài bản sửa đổi từ phản hồi trước đó.

Để linh hoạt hơn nữa, ba trong số các trường bộ lọc hỗ trợ nhiều giá trị, vì vậy bạn chỉ có thể lọc những giao dịch mua khớp với ít nhất một trong các giá trị được cung cấp.

Các trường này là productType, productId, và subscriptionGroupIdentifier.

Để cung cấp nhiều giá trị cho các tham số này, chỉ cần xác định chúng nhiều lần.

Tiếp theo, hãy chuyển sang cập nhật Thông báo Máy chủ App Store.

Với App Store Server Notifications V2, bạn có thể đưa máy chủ của mình lên một tầm cao mới.

Thông báo V2 cung cấp thông tin chi tiết về các sự kiện mua hàng trong ứng dụng mà bạn không thể nhận được ở bất kỳ nơi nào khác.

Những thứ này đặc biệt hữu ích để theo dõi vòng đời của các đăng ký tự động gia hạn được cung cấp trong ứng dụng của bạn.

Bạn có thể sử dụng những thông tin chi tiết này để giữ chân khách hàng, giành lại những khách hàng đã khuấy động, giải quyết các yêu cầu hỗ trợ khách hàng và hơn thế nữa.

Với tất cả những lợi ích này, bạn có thể tự hỏi làm thế nào để bắt đầu.

Như với bất kỳ tính năng mới nào, môi trường thử nghiệm hộp cát là nơi tốt nhất để bắt đầu.

Đó là lý do tại sao năm ngoái, chúng tôi đã thêm khả năng đặt URL máy chủ riêng biệt trong App Store Connect để nhận Thông báo Máy chủ App Store trong hộp cát.

Sau khi đăng ký URL máy chủ của bạn, bạn sẽ muốn xác nhận máy chủ của mình đang nhận thông báo từ máy chủ App Store.

Bạn có thể thiết lập một tài khoản hộp cát chỉ để kích hoạt thông báo thông qua hành động của người dùng.

Ví dụ, giả sử bạn thực hiện lần đầu tiên mua đăng ký bằng tài khoản sandbox đó.

Bạn sẽ nhận được thông báo V2 thuộc loại ĐĂNG KÝ và loại phụ INITIAL_BUY.

Nhưng nếu thông báo đó không đến thì sao?

Bạn có thể tự hỏi liệu có vấn đề gì với máy chủ của bạn hay các bước bạn đã thực hiện để kích hoạt thông báo hay không.

Tình huống này có thể tạo ra rất nhiều điều không chắc chắn ngay khi bạn bắt đầu.

Chúng tôi muốn đơn giản hóa trải nghiệm này và cung cấp cho bạn cách để dễ dàng xác minh rằng Thông báo Máy chủ App Store có thể đến máy chủ của bạn.

Đó là lý do tại sao năm nay, chúng tôi giới thiệu điểm cuối Yêu cầu Thông báo Kiểm tra mới.

Bằng cách gọi điểm cuối đơn giản này, bạn có thể yêu cầu chúng tôi gửi Thông báo V2 thuộc loại KIỂM TRA đến URL máy chủ đã đăng ký cho ứng dụng của bạn trong App Store Connect.

Loại thông báo TEST mới được sử dụng riêng cho điểm cuối này.

Bạn có thể gọi điểm cuối trong hộp cát hoặc sản xuất để kiểm tra URL đã lưu của mình cho một trong hai môi trường.

Sử dụng điểm cuối mới này để nhanh chóng kiểm tra các URL và cấu hình máy chủ mới.

Hãy xem điều này đơn giản hóa việc thiết lập lần đầu như thế nào.

Bây giờ, nếu bạn chỉ muốn kích hoạt thông báo đầu tiên của mình, không cần thiết lập tài khoản hộp cát hoặc thực hiện mua hàng.

Chỉ cần gọi điểm cuối mới trong bất kỳ môi trường nào bạn muốn kiểm tra và bạn sẽ nhận được phản hồi HTTP 200 xác nhận yêu cầu của mình.

Phản hồi sẽ chứa một trường mới, testNotificationToken, xác định thông báo kiểm tra mà máy chủ của bạn sẽ nhận được.

Chúng tôi sẽ quay lại lĩnh vực này sau.

Ngay sau đó, máy chủ của bạn sẽ nhận được thông báo V2 thuộc loại KIỂM TRA tại URL được lưu trong App Store Connect.

Bây giờ hãy xem cách gọi điểm cuối này.

Chỉ cần gửi một yêu cầu POST đơn giản đến đường dẫn mới này trên máy chủ App Store.

Bạn sẽ nhận được phản hồi HTTP 200 và biết rằng yêu cầu của bạn đã được gửi.

Phản hồi sẽ chứa trường mới mà tôi đã đề cập, testNotificationToken.

Hãy lưu ý điều này để dùng sau.

Bạn sẽ sớm nhận được Thông báo KIỂM TRA đã ký.

Đây là thông báo đó sẽ trông như thế nào khi nó được giải mã.

Bạn sẽ nhận thấy nó chứa tất cả các trường cấp cao nhất thông thường của thông báo V2, bao gồm Loại thông báo mới, KIỂM TRA.

Nội dung của đối tượng dữ liệu ngắn hơn một chút so với thông báo thông thường.

Vì đây chỉ là một bài kiểm tra, không có dữ liệu liên quan đến giao dịch nào để bao gồm, vì vậy chúng tôi bỏ qua các trường giao dịch cụ thể, đáng chú ý nhất là signedTransactionInfo.

Khi gọi điểm cuối Yêu cầu Thông báo Kiểm tra mới, hãy nhớ rằng Thông báo Máy chủ App Store được gửi không đồng bộ.

Cuộc gọi thành công của bạn đến điểm cuối sẽ trả về HTTP 200 nhưng thông báo kiểm tra thực tế sẽ đến riêng, một thời gian ngắn sau đó.

Cho rằng điểm cuối này là tất cả về việc kiểm tra cấu hình máy chủ của bạn, bạn có thể tự hỏi phải làm gì khi kiểm tra đó không thành công.

Nói cách khác, nếu thông báo kiểm tra không đến thì sao?

Để nâng cao hơn nữa khả năng kiểm tra của bạn, chúng tôi sẽ phát hành điểm cuối Nhận Trạng thái Thông báo Kiểm tra mà bạn sẽ sử dụng cùng với điểm cuối Yêu cầu Thông báo Kiểm tra.

Với điểm cuối mới này, bạn có thể kiểm tra trạng thái của thông báo KIỂM TRA được yêu cầu trước đó.

Phản hồi điểm cuối sẽ cho bạn biết liệu máy chủ App Store có thể tiếp cận máy chủ của bạn và gửi thành công thông báo KIỂM TRA hay không.

Nếu việc gửi không thành công, nó sẽ cho bạn ý tưởng về lý do tại sao, vì vậy bạn có thể khắc phục sự cố cấu hình máy chủ của mình tốt hơn.

Hãy kiểm tra xem bạn sẽ sử dụng điểm cuối này như thế nào.

Gửi yêu cầu GET đến đường dẫn này trên máy chủ App Store.

Trong đường dẫn, bao gồm testNotificationToken bạn nhận được từ điểm cuối Yêu cầu Thông báo Kiểm tra.

Điều này sẽ cho chúng tôi biết bạn muốn kiểm tra trạng thái của thông báo kiểm tra nào.

Bây giờ để phản hồi.

Trường signedPayload chứa tải trọng thông báo TEST mà máy chủ App Store đã cố gắng gửi đến máy chủ của bạn.

Và trường firstSendAttemptResult cho biết kết quả của nỗ lực gửi đó.

Ở đây, SUCCESS chỉ ra rằng việc gửi đã thành công, có nghĩa là máy chủ App Store đã nhận được phản hồi HTTP 200 từ máy chủ của bạn.

Nếu việc gửi không thành công, thay vào đó bạn sẽ thấy một trong một số giá trị lỗi khác nhau.

Những giá trị này cho thấy lỗi mà máy chủ App Store gặp phải khi cố gắng tiếp cận máy chủ của bạn bằng thông báo kiểm tra.

Với thông tin này, bạn có thể khắc phục sự cố máy chủ của mình, yêu cầu thông báo kiểm tra mới khi cần và giúp máy chủ của bạn chạy đáng tin cậy.

Nói chung, các điểm cuối thông báo thử nghiệm này rất dễ sử dụng và có thể giúp bạn tiết kiệm rất nhiều rắc rối khi thiết lập hoặc cấu hình lại máy chủ của mình để nhận Thông báo Máy chủ V2 App Store.

Giờ đây với sự trợ giúp của các điểm cuối này, bạn có thể thiết lập máy chủ của mình và xác nhận nó đang chạy trơn tru.

Nhưng các máy chủ không hoàn hảo và sự cố ngừng hoạt động xảy ra.

Làm thế nào để bạn khôi phục khi máy chủ của bạn ngừng hoạt động, khiến bạn bỏ lỡ Thông báo Máy chủ App Store?

Giải pháp hiện tại cho việc này là một hệ thống thử lại.

Khi máy chủ App Store không đến được máy chủ của bạn, nó sẽ bắt đầu quá trình thử lại.

Nó sẽ thử gửi lại cùng một thông báo tối đa năm lần, với thời gian chờ đợi lâu hơn giữa mỗi lần thử.

Những thử lại này chỉ diễn ra trong môi trường sản xuất.

Các thử lại cuối cùng sẽ giúp bạn phục hồi sau khi mất điện, nhưng chúng không hoàn hảo cho mọi tình huống.

Ví dụ, một số sự cố mất điện có thể lan rộng.

Nếu máy chủ của bạn ngừng hoạt động đủ lâu để bỏ lỡ lần thử lại cuối cùng từ máy chủ App Store, thông báo đó sẽ bị mất.

Hoặc phổ biến hơn, máy chủ của bạn có thể gặp phải một vấn đề rất ngắn, trong thời gian đó nó chỉ bỏ lỡ một số ít thông báo.

Nhưng bỏ lỡ dù chỉ một thông báo có nghĩa là một số hồ sơ khách hàng của bạn đã lỗi thời trong ít nhất một giờ.

Tuy nhiên bạn không biết cái nào!

Rõ ràng, sự cố ngừng hoạt động của máy chủ rất căng thẳng và việc phục hồi từ chúng có thể là một nhiệm vụ phức tạp.

Đó là lý do tại sao chúng tôi muốn khôi phục Thông báo Máy chủ App Store bị bỏ lỡ dễ dàng nhất có thể, vì vậy bạn có thể đưa máy chủ của mình trở lại đúng hướng càng sớm càng tốt.

Đó là lý do tại sao năm nay, chúng tôi giới thiệu điểm cuối Nhận Lịch sử Thông báo mới.

Với điểm cuối này, bạn có thể tìm nạp lịch sử của Thông báo Máy chủ Cửa hàng Ứng dụng V2 được tạo cho ứng dụng của mình.

Cho dù máy chủ của bạn có nhận được thông báo thành công hay không, thông báo đó sẽ xuất hiện trong phản hồi của điểm cuối này.

Khi gọi điểm cuối này, bạn sẽ chỉ định một phạm vi ngày của các thông báo để tìm nạp.

Với WWDC, chúng tôi đã bắt đầu ghi lại dữ liệu này và chúng tôi sẽ xây dựng giới hạn của sáu tháng lịch sử mới nhất hiện có.

Bạn có thể tùy chọn lọc yêu cầu của mình theo loại và loại phụ hoặc chỉ tìm nạp thông báo của một người dùng bằng cách cung cấp originalTransactionId.

Và hệ thống thử lại hiện tại vẫn có sẵn, vì vậy bạn có thể sử dụng nó song song với điểm cuối mới này.

Hãy xem bạn sẽ gọi điểm cuối này như thế nào.

Bạn sẽ gửi yêu cầu POST đến đường dẫn mới này trên máy chủ App Store.

Trong nội dung yêu cầu, bạn sẽ bao gồm Ngày bắt đầu và Ngày kết thúc.

Phản hồi sẽ chỉ chứa các thông báo mà chúng tôi đã cố gắng gửi lần đầu tiên trong cửa sổ này.

Hãy nhớ rằng các thông báo sớm nhất có sẵn sẽ là những thông báo được gửi sáu tháng trước ngày yêu cầu của bạn.

Tùy chọn, bạn có thể chỉ định một Loại thông báo và Loại phụ thông báo.

Nếu bạn làm vậy, lịch sử sẽ chỉ được lọc thành các thông báo khớp với cả hai giá trị này.

Hãy nhớ rằng một số thông báo không có loại phụ.

Ngoài ra, bạn có thể cung cấp originalTransactionId của người dùng, để tìm nạp lịch sử thông báo của chỉ người dùng đó.

Cuối cùng, bạn nên cung cấp mã thông báo phân trang làm tham số truy vấn cho mọi yêu cầu tiếp theo để có được trang tiếp theo.

Đảm bảo rằng bạn sử dụng cùng một nội dung yêu cầu cho các yêu cầu tiếp theo, chỉ thay đổi mã thông báo phân trang này.

Bây giờ chúng ta hãy xem phản hồi.

Mảng notificationHistory chứa tối đa 20 thông báo, với các thông báo cũ nhất trước tiên.

Mỗi mục nhập trong mảng này đại diện cho một thông báo và bên trong bạn sẽ tìm thấy Payload đã ký, bạn có thể giải mã như bình thường để xem dữ liệu giao dịch.

Dữ liệu bên trong giống hệt với tải trọng mà máy chủ App Store đã gửi trong thông báo ban đầu.

Bạn sẽ thấy rằng chúng tôi cũng đã đưa trường firstSendAttemptResult mới vào phản hồi điểm cuối này.

Bạn có thể sử dụng trường này để tìm kiếm chuỗi thời gian chờ và các lỗi khác để hiểu rõ hơn lý do tại sao máy chủ của bạn bỏ lỡ thông báo trong quá khứ.

Phản hồi cũng chứa mã thông báo phân trang nếu có nhiều trang hơn để truy xuất.

Bạn nên cung cấp điều này trong yêu cầu tiếp theo của mình để nhận được trang thông báo tiếp theo.

Bạn sẽ biết có nhiều trang hơn để truy xuất miễn là trường hasMore là đúng.

Và đó là tất cả những gì bạn cần biết về điểm cuối mới hữu ích này.

Điều đó kết thúc các bản cập nhật máy chủ App Store của chúng tôi cho ngày hôm nay.

Mọi tính năng máy chủ được công bố hôm nay hiện đều có sẵn trong cả hộp cát và sản xuất.

Chúng tôi hy vọng bạn sẽ tận dụng các tính năng mới này để làm cho máy chủ của bạn tốt nhất có thể.

Để biết thêm nội dung tuyệt vời về việc sử dụng máy chủ có mua hàng trong ứng dụng, bao gồm cách sử dụng các tính năng mới nhất trong khi hỗ trợ các khách hàng cũ, tôi khuyến khích bạn xem một phiên khác tại WWDC22, "Khám phá tích hợp và di chuyển mua hàng trong ứng dụng."

Cả hai: Cảm ơn vì đã tham gia cùng chúng tôi tại WWDC22!

♪