110358

♪ ♪

Xin chào, tôi là Richard, tôi là một kỹ sư trong nhóm Thư viện Tiêu chuẩn Swift.

Hôm nay, hãy bắt tay vào một cuộc hành trình vượt ra ngoài những điều cơ bản của Swift Regex.

Swift 5.7 đang đạt được những khả năng mới mạnh mẽ để xử lý chuỗi.

Họ bắt đầu với loại 'Regex', một loại mới trong Thư viện Tiêu chuẩn Swift.

Một ngôn ngữ tích hợp cú pháp theo nghĩa đen Regex, làm cho khái niệm mạnh mẽ và quen thuộc này thậm chí còn hạng nhất hơn.

Và cuối cùng, một API xây dựng kết quả được gọi là RegexBuilder.

Đây là một ngôn ngữ dành riêng cho miền, hoặc DSL, tận dụng sự đơn giản về cú pháp và khả năng kết hợp của các trình tạo kết quả, đồng thời đẩy khả năng đọc của Regex lên một cấp độ hoàn toàn mới.

Để biết thông tin cơ bản về lý do tại sao Swift Regex giúp xử lý chuỗi dễ dàng hơn, hãy xem phiên Meet Swift Regex của đồng nghiệp Michael của tôi.

Hãy xem một ví dụ rất đơn giản về Swift Regex.

Giả sử tôi có một chuỗi dữ liệu và muốn khớp và trích xuất ID người dùng từ chuỗi này.

Tôi có thể tạo một biểu thức chính quy từ văn bản như tôi thường làm với 'NSRegularExpression'.

Nó khớp với dấu hai chấm "user_id" theo sau là không hoặc nhiều khoảng trắng theo sau là một hoặc nhiều chữ số. Điều khác biệt lần này là chúng tôi đang tạo ra một giá trị thuộc loại Regex.

Đây là một loại mới trong Thư viện Tiêu chuẩn Swift.

Sau đó, tôi có thể sử dụng thuật toán 'FirstMatch' của chuỗi để tìm sự xuất hiện đầu tiên của mẫu được xác định bởi Regex này và in toàn bộ kết quả khớp, giống như vậy.

Bởi vì chuỗi Regex của tôi được biết đến tại thời điểm biên dịch, tôi có thể chuyển sang sử dụng ký tự Regex để trình biên dịch kiểm tra lỗi cú pháp và Xcode có thể hiển thị tô sáng cú pháp.

Nhưng để có khả năng đọc và tùy chỉnh tối ưu, tôi có thể sử dụng trình tạo Regex DSL.

Với trình tạo Regex, việc đọc nội dung của Regex dễ dàng như đọc Swift API gốc.

Trong phiên này, tôi sẽ chỉ cho bạn cách Regex hoạt động và cách bạn có thể áp dụng Regex trong quy trình làm việc của mình.

Regex là một chương trình được thực thi bởi công cụ Regex cơ bản của nó.

Khi thực thi Regex, công cụ Regex nhận một chuỗi đầu vào và thực hiện khớp từ đầu đến cuối chuỗi.

Hãy cùng xem một Regex rất đơn giản.

Regex này khớp với một chuỗi bắt đầu bằng một hoặc nhiều chữ cái "a" theo sau là một hoặc nhiều chữ số.

Tôi sử dụng một trong các thuật toán kết hợp, 'wholeMatch', để khớp đầu vào "aaa12".

Công cụ Regex sẽ khởi động từ ký tự đầu tiên của đầu vào.

Đầu tiên, nó khớp với một hoặc nhiều ký tự a.

Tại thời điểm này, nó đạt đến ký tự "1" và cố gắng ghép nhân vật này với nhân vật "a".

Nhưng nó không khớp.

Vì vậy, công cụ Regex chuyển sang mẫu tiếp theo trong Regex, để khớp với một hoặc nhiều chữ số.

Khi chúng ta đến cuối chuỗi, việc khớp sẽ thành công.

Trong phần còn lại của phiên này, tôi sẽ giải thích thêm một chút về mô hình thực thi này.

Với Regex được xây dựng trên công cụ Regex cơ bản của nó, DSL xây dựng Regex và các thuật toán hỗ trợ Regex mở rộng sức mạnh và tính biểu cảm của Regex.

Các thuật toán được hỗ trợ bởi Regex là các API dựa trên bộ sưu tập cung cấp một số hoạt động phổ biến nhất như trận đấu đầu tiên, tìm thấy sự xuất hiện đầu tiên của Regex trong chuỗi, 'wholeMatch', khớp toàn bộ chuỗi với Regex, 'prefixMatch', khớp với tiền tố của chuỗi với Regex.

Bên cạnh việc khớp, thư viện tiêu chuẩn Swift cũng đã thêm các API để dự đoán, thay thế, cắt tỉa và tách dựa trên Regex.

Ngoài ra, Regex hiện có thể được sử dụng trong cú pháp khớp mẫu của Swift trong các câu lệnh luồng điều khiển, giúp việc chuyển đổi chuỗi dễ dàng hơn bao giờ hết.

Cuối cùng, ngoài trình tạo Regex và các thuật toán do Regex cung cấp, năm nay, Foundation đã giới thiệu hỗ trợ Regex của riêng mình hoạt động liền mạch với trình tạo Regex.

Hỗ trợ Regex trong Foundation không ai khác chính là các trình định dạng và trình phân tích cú pháp mà bạn có thể đang sử dụng, chẳng hạn như các trình định dạng và Số.

Nếu bạn muốn tìm hiểu thêm về các API này, hãy xem phiên Có gì mới trong Foundation từ WWDC21.

Năm nay, Foundation cũng đang bổ sung hỗ trợ định dạng và phân tích cú pháp URL.

Với sự hỗ trợ của Regex trong Foundation, bạn có thể nhúng các trình phân tích cú pháp Foundation trực tiếp vào trình tạo Regex.

Ví dụ: để phân tích cú pháp sao kê ngân hàng như thế này, tôi có thể sử dụng trình phân tích cú pháp ngày do Foundation cung cấp với định dạng tùy chỉnh và trình phân tích cú pháp tiền tệ với chiến lược phân tích cú pháp dành riêng cho miền.

Đây là một vấn đề thực sự lớn bởi vì bạn có thể tạo Regexes từ các trình phân tích cú pháp được thử nghiệm chiến đấu hiện có để xử lý các trường hợp góc và hỗ trợ bản địa hóa, đồng thời soạn chúng với tính biểu hiện của trình tạo Regex DSL.

Để chỉ cho bạn cách bạn có thể áp dụng Swift Regex vào quy trình làm việc của mình, hãy cùng nhau tìm ra một ví dụ.

Tôi đã viết một tập lệnh để phân tích các bản ghi từ việc chạy các bài kiểm tra đơn vị dựa trên XCTest.

Nhật ký kiểm tra bắt đầu và kết thúc với trạng thái của một bộ kiểm tra.

Sau đó XCTest chạy mọi trường hợp thử nghiệm và báo cáo trạng thái của trường hợp thử nghiệm.

Hôm nay chúng ta hãy phân tích cú pháp dòng đầu tiên và dòng cuối cùng của nhật ký.

Đó là thông tin về một bộ kiểm tra.

Đầu tiên, tôi nhập RegexBuilder.

RegexBuilder là một mô-đun mới trong Thư viện Tiêu chuẩn Swift cung cấp RegexBuilder DSL.

Regex có thể được khởi tạo với một phần đóng cuối đại diện cho phần thân của Regex.

Hãy xem một thông báo nhật ký ví dụ.

Có ba chuỗi con biến đổi mà chúng tôi quan tâm trong nhật ký này; tên của bộ kiểm tra, trạng thái, cho dù nó bắt đầu, vượt qua hay thất bại và dấu thời gian.

Tôi có thể phân tích cú pháp các phần khác của nguyên văn dòng này, trong khi đưa ra một mẫu để phân tích ba chuỗi con biến đổi.

Thông báo nhật ký bắt đầu bằng từ "bộ kiểm tra", theo sau là dấu cách và một trích dẫn duy nhất.

Sau đó chúng tôi phân tích cú pháp tên của bộ kiểm tra.

Tên là một mã định danh, có thể chứa các chữ cái hoặc chữ số viết thường hoặc viết hoa, nhưng ký tự đầu tiên không bao giờ có thể là một chữ số.

Vì vậy, chúng tôi tạo ra một lớp ký tự tùy chỉnh để khớp một chữ cái làm ký tự đầu tiên.

Sau đó, tôi khớp số không hoặc nhiều ký tự là một chữ cái hoặc một chữ số từ 0 đến số chín.

Điều này rất rõ ràng và dễ đọc, nhưng nó hơi cồng kềnh.

Nhiều người trong số các bạn có thể quen thuộc với cú pháp Regex văn bản.

Trong RegexBuilder, tôi thực sự có thể nhúng một ký tự Regex súc tích trực tiếp vào cơ thể.

Một Regex theo nghĩa đen bắt đầu và kết thúc bằng một dấu gạch chéo.

Swift suy ra loại mạnh chính xác cho nó.

Ví dụ, Regex này khớp với chuỗi con, "Xin chào, WWDC!".

Vì vậy, loại đầu ra của nó là chuỗi con.

Nhưng điều thực sự thú vị về một Regex hạng nhất theo nghĩa đen là các nhóm bắt được đánh máy mạnh mẽ.

Ví dụ, tôi có thể viết một nhóm chụp để chụp hai chữ số như năm.

Và đặt tên cho nhóm bắt giữ này, "năm".

Khi tôi làm điều này, một chuỗi con khác sẽ xuất hiện trong loại đầu ra.

Sau đó trong bài nói chuyện này, tôi sẽ chỉ cho bạn cách bạn có thể sử dụng ảnh chụp để trích xuất thông tin từ một chuỗi.

Bên cạnh các ký tự Regex tiêu chuẩn, Swift cũng hỗ trợ các ký tự Regex mở rộng, bắt đầu bằng dấu gạch chéo pound và kết thúc bằng dấu gạch chéo pound.

Chữ mở rộng cho phép các khoảng trắng không ngữ nghĩa.

Trong chế độ này, bạn có thể chia các mẫu của mình thành nhiều dòng.

Với một Regex literal được nhúng trong RegexBuilder của tôi, nó sạch sẽ và quen thuộc.

Sau khi tôi phân tích cú pháp tên bài kiểm tra, tôi phân tích cú pháp một trích dẫn duy nhất và một khoảng trắng.

Bây giờ tôi đạt đến trạng thái kiểm tra.

Có nhiều loại trạng thái kiểm tra: bắt đầu, thất bại và vượt qua.

Để phù hợp với một trong những tùy chọn này, chúng tôi sử dụng 'ChoiceOf'.

'ChoiceOf' phù hợp với một trong nhiều mẫu con và đó chính xác là những gì chúng ta cần.

Tiếp theo, chúng tôi phân tích những gì xuất hiện ngay sau trạng thái, một khoảng trắng theo sau là "at" theo sau là một khoảng trắng.

Phần còn lại của chuỗi là dấu thời gian.

Chúng ta có thể kết hợp điều này như một hoặc nhiều nhân vật của bất kỳ nhân vật nào.

Nhưng khi tôi xem thêm một số ví dụ, một thông báo nhật ký đôi khi kết thúc bằng một dấu chấm.

Chúng tôi vẫn muốn sử dụng 'Tùy chọn' để khớp với khoảng thời gian khi nó tồn tại.

Để khớp đầu vào với Regex, hãy sử dụng một trong các thuật toán khớp được cung cấp.

Hãy sử dụng 'wholeMatch', khớp toàn bộ chuỗi với Regex.

Với 'wholeMatch', tôi khớp từng thông báo nhật ký này và in nội dung phù hợp.

Nó phù hợp!

Nhưng chúng tôi không chỉ muốn biết liệu nó có khớp với các chuỗi hay không.

Chúng tôi cũng muốn trích xuất thông tin mà chúng tôi quan tâm, chẳng hạn như tên bài kiểm tra, trạng thái và dấu thời gian.

Vì vậy, hãy tiếp tục và làm điều này với một trong những tính năng thú vị nhất của Regex, Captures!

A Capture lưu một phần đầu vào trong quá trình khớp.

Nó có sẵn dưới dạng "Chụp" trong RegexBuilder và dưới dạng một cặp dấu ngoặc đơn trong cú pháp Regex.

Chụp nối thêm chuỗi con phù hợp vào loại bộ đầu ra.

Một loại bộ đầu ra bắt đầu với toàn bộ chuỗi con khớp với toàn bộ Regex, tiếp theo là lần chụp đầu tiên, lần chụp thứ hai, v.v.

Thuật toán kết hợp trả về một Regex Match, từ đó bạn có thể lấy bộ đầu ra.

Toàn bộ trận đấu, lần chụp đầu tiên và lần chụp thứ hai.

Hãy để tôi sử dụng ảnh chụp trong bộ kiểm tra của tôi nhật ký Regex.

Tôi nắm bắt tên của bộ kiểm tra, trạng thái và dấu thời gian.

Hãy chạy lại Regex này trên một số đầu vào và in ba thứ mà chúng tôi đã chụp được.

Đó có vẻ là một trận đấu thành công!

Nó đã in tên, trạng thái và dấu thời gian.

Nhưng khi tôi nhìn kỹ, một cái gì đó trong buổi hẹn hò hơi khác một chút.

Nó bao gồm khoảng thời gian trong đầu vào như một phần của việc chụp.

Vậy hãy để tôi quay lại và kiểm tra Regex xem có lỗi không.

Tôi muốn tập trung vào dấu thời gian Regex và xem có vấn đề gì với nó.

Sau đó, tôi nhận ra, mẫu "một hoặc nhiều ký tự bất kỳ" tiêu thụ mọi thứ từ chữ số đầu tiên của dấu thời gian, cho đến cuối dòng.

Vì vậy, mô hình "Kế đoạn tùy chọn" bên dưới nó không bao giờ khớp.

Tôi có thể khắc phục điều này bằng cách làm cho OneOrMore này miễn cưỡng.

"B miễn cưỡng" là một trường hợp của các hành vi lặp lại.

Một hoặc nhiều, không hoặc nhiều, tùy chọn và lặp lại là những gì Swift Regex gọi là lặp lại.

Một sự lặp lại là háo hức theo mặc định.

Nó khớp với càng nhiều lần xuất hiện càng tốt.

Hãy để tôi sử dụng ví dụ từ trước đó.

Khi công cụ Regex cố gắng khớp với OneOrMore của bất kỳ ký tự nào một cách háo hức, nó sẽ bắt đầu với ký tự đầu tiên và nó chấp nhận bất kỳ ký tự nào trên đường đi cho đến khi kết thúc đầu vào.

Sau đó, công cụ Regex chuyển sang khớp với khoảng thời gian Tùy chọn.

Không còn khoảng thời gian nào để phù hợp nữa, nhưng dù sao nó cũng là tùy chọn, vì vậy nó đã thành công.

Bởi vì chúng tôi đang chạy thuật toán 'wholeMatch', và cả đầu vào và mẫu Regex đều kết thúc, việc khớp thành công.

Mặc dù kết hợp đã thành công, giai đoạn này đã được ghi lại một cách bất ngờ như một phần của OneOrMore.

Khi chúng ta thay đổi hành vi lặp lại thành miễn cưỡng, công cụ Regex khớp với sự lặp lại hơi khác một chút.

Nó khớp với càng ít ký tự càng tốt.

Vì vậy, khi công cụ Regex khớp với chuỗi đầu vào lần này, nó cẩn thận tiến về phía trước bằng cách luôn cố gắng khớp với phần còn lại của Regex trước, trước khi tiêu thụ sự xuất hiện lặp lại.

Khi phần còn lại của Regex không khớp, động cơ quay trở lại sự lặp lại và tiêu thụ một lần xuất hiện bổ sung.

Hãy nhanh chóng chuyển tiếp đến nhân vật cuối cùng, khoảng thời gian.

Không giống như hành vi háo hức, công cụ Regex ban đầu không tiêu thụ khoảng thời gian như một phần của OneOrMore, mà thay vào đó cố gắng khớp với mô hình "Kếp thời gian tùy chọn".

Điều này phù hợp, và công cụ Regex đạt đến cuối mẫu.

Vì vậy, việc kết hợp thành công, và nó tạo ra sự bắt giữ chính xác mà không có một khoảng thời gian kéo dài trong đó.

Bởi vì háo hức là hành vi mặc định, khi bạn tạo Regex của mình bằng cách sử dụng sự lặp lại, bạn nên suy nghĩ về ý nghĩa của nó đối với trận đấu dự định của bạn.

Bạn có thể chỉ định hành vi ở cấp độ lặp lại, bằng cách chuyển một đối số bổ sung hoặc, bạn có thể sử dụng công cụ sửa đổi 'repetitionBehavior' để ghi đè nó cho tất cả các lần lặp lại không chỉ định hành vi.

Vì chúng tôi đã sửa đổi hành vi lặp lại để dấu thời gian miễn cưỡng, Matching bây giờ trích xuất dấu thời gian phù hợp mà không bao gồm dấu thời gian.

Hãy quay lại Regex.

Khi tôi sử dụng Capture để trích xuất trạng thái kiểm tra từ đầu vào, loại của nó là Chuỗi con.

Nhưng sẽ tốt hơn nhiều nếu tôi có thể chuyển đổi chuỗi con thành thứ gì đó thân thiện hơn với lập trình, như cấu trúc dữ liệu tùy chỉnh.

Để làm điều này, tôi có thể sử dụng chụp chuyển đổi.

Chụp biến đổi là Chụp với đóng biến đổi.

Sau khi khớp, công cụ Regex gọi đóng biến đổi trên chuỗi con được khớp, tạo ra kết quả của loại mong muốn.

Loại đầu ra Regex tương ứng trở thành kiểu trả về của đóng.

Ở đây, bằng cách chuyển đổi ảnh chụp bằng trình khởi tạo của Int từ String, tôi nhận được một Int tùy chọn trong loại bộ đầu ra.

Để có được đầu ra không tùy chọn, TryCapture có thể trợ giúp.

TryCapture là một biến thể của Capture chấp nhận một biến đổi trả về một tùy chọn và loại bỏ tính tùy chọn trong loại đầu ra.

Trả về nil trong quá trình khớp sẽ khiến công cụ Regex quay lại và thử một đường dẫn thay thế.

TryCapture hữu ích nhất khi bạn chuyển đổi ảnh chụp bằng trình khởi tạo không thể thất bại.

Một sự phù hợp tự nhiên để lưu trữ trạng thái kiểm tra đã chụp, sẽ là một bảng liệt kê.

Vậy hãy định nghĩa một cái.

Tôi đã xác định một TestStatus enum với ba trường hợp: bắt đầu, vượt qua và thất bại.

Các giá trị chuỗi thô làm cho enum này có thể khởi tạo từ một chuỗi.

Trong Regex, tôi chuyển sang 'TryCapture' với một phép biến đổi.

Trong phần đóng biến đổi, tôi gọi trình khởi tạo TestStatus để chuyển đổi chuỗi con phù hợp thành giá trị TestStatus.

Bây giờ loại đầu ra tương ứng là TestStatus.

Sử dụng cấu trúc dữ liệu tùy chỉnh như thế này làm cho loại đầu ra khớp Regex an toàn.

Quay lại Regex.

Có một cải tiến bổ sung mà tôi muốn thực hiện.

Hiện tại, tôi khớp dấu thời gian bằng cách sử dụng mẫu ký tự đại diện.

Nó sẽ tạo ra một chuỗi con.

Điều này có nghĩa là nếu ứng dụng của tôi muốn hiểu dấu thời gian, nó sẽ phải phân tích chuỗi con một lần nữa thành một cấu trúc dữ liệu khác.

Trước đó trong phiên họp, tôi đã đề cập rằng Foundation hiện hỗ trợ Swift Regex, cung cấp các trình phân tích cú pháp sức mạnh của ngành như Regexes.

Vì vậy, thay vì phân tích cú pháp ngày như một chuỗi con, tôi có thể chuyển sang trình phân tích cú pháp ngày ISO 8601 của Foundation để phân tích dấu thời gian dưới dạng ngày.

Bây giờ loại suy ra cho thấy Regex này xuất ra một Ngày.

Khi tôi chạy 'wholeMatch' trên các đầu vào, tôi có thể thấy rằng chuỗi ngày đã được phân tích cú pháp thành giá trị Ngày nền tảng.

Có quyền truy cập vào các trình phân tích cú pháp được kiểm tra chiến đấu dưới dạng Regex, giống như trình phân tích cú pháp ngày Foundation, cực kỳ tiện dụng trong các tác vụ xử lý chuỗi hàng ngày.

Tiếp theo, tôi sẽ chỉ cho bạn một tính năng nâng cao, sử dụng lại trình phân tích cú pháp đã có từ trước được xác định ở nơi khác trong Swift Regex.

Hãy xem xét một ví dụ mà chúng ta muốn phân tích thời lượng của một trường hợp thử nghiệm.

Thời lượng là một số dấu phẩy động, chẳng hạn như, 0, 0,001.

Tất nhiên, cách tốt nhất để làm điều này là sử dụng trình phân tích cú pháp dấu phẩy động do Foundation cung cấp với sự hỗ trợ đầy đủ cho việc bản địa hóa.

Nhưng hôm nay, tôi muốn chỉ cho bạn những gì dưới mui xe và cách bạn có thể tự kết nối với công cụ Regex để tận dụng trình phân tích cú pháp hiện có để phân tích cú pháp số dấu phẩy động.

'Strtod' là một hàm từ thư viện chuẩn C.

Nó lấy một con trỏ chuỗi, phân tích cú pháp chuỗi cơ bản và gán vị trí kết thúc của trận đấu cho con trỏ kết thúc.

Hãy phân tích thời lượng, cách C.

Để làm điều này, tôi có thể tự xác định một loại trình phân tích cú pháp và làm cho nó phù hợp với giao thức CustomConsumingRegexComponent.

Tôi định nghĩa một cấu trúc có tên là CDoubleParser.

'RegexOutput' của nó là Double, bởi vì chúng tôi đang phân tích cú pháp một số Double.

Trong phương pháp "tiêu thụ", chúng tôi thực hiện cuộc gọi đến trình phân tích cú pháp kép từ thư viện tiêu chuẩn C, chuyển các con trỏ chuỗi đến nó và lấy lại một số.

Trong nội dung phương thức, tôi sử dụng phương thức withCString để lấy địa chỉ bắt đầu.

Sau đó, tôi gọi hàm 'strtod' C, chuyển địa chỉ bắt đầu và con trỏ để nhận địa chỉ kết thúc kết quả.

Sau đó tôi kiểm tra lỗi.

Khi phân tích cú pháp thành công, địa chỉ kết thúc lớn hơn địa chỉ bắt đầu.

Nếu không, đó là một lỗi phân tích cú pháp, vì vậy tôi trả về số không.

Tôi tính giới hạn trên của trận đấu từ con trỏ được tạo ra bởi C API.

Và cuối cùng, tôi trả về giới hạn trên của trận đấu và đầu ra số.

Tôi có thể quay lại Regex và sử dụng 'CDoubleParser' của mình trực tiếp trong Regex.

Loại đầu ra được suy ra là Double.

Khi tôi gọi 'wholeMatch' và in số được phân tích cú pháp, nó xuất ra 0,001, như tôi mong đợi.

Tóm lại, hôm nay chúng ta đã nói về một số cách sử dụng phổ biến và nâng cao của Swift Regex, một tính năng mới trong Swift 5.7 cho phép bạn tích hợp sức mạnh của xử lý chuỗi trong ứng dụng của mình.

Một phương pháp hay khi sử dụng Swift Regex là cố gắng đạt được sự cân bằng tốt giữa độ chính xác và khả năng đọc, đặc biệt là khi bạn kết hợp các ký tự RegexBuilder DSL và Regex.

Khi bạn gặp phải các mẫu phổ biến như ngày tháng và URL, hãy luôn thích các trình phân tích cú pháp sức mạnh của ngành do Foundation cung cấp, vì việc phân tích cú pháp các mẫu này bằng mã tùy chỉnh có thể dễ bị lỗi.

Để biết thêm thông tin về Swift Regex, hãy xem loạt đề xuất xử lý chuỗi khai báo trên Swift Evolution.

Tôi hy vọng bạn sẽ thích xử lý chuỗi với Swift.

Cảm ơn bạn, và chúc bạn có một WWDC tuyệt vời.