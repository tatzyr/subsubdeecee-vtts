10160

♪ Nhạc hip-hop nhạc cụ êm dịu ♪

♪

Xin chào, tên tôi là Keyi Yu, và tôi là một kỹ sư từ nhóm Hệ sinh thái kim loại.

Hôm nay, tôi rất hân hạnh được giới thiệu metal-cpp.

Chúng tôi đã tạo ra metal-cpp cho bất kỳ ai sử dụng C++ và muốn xây dựng các ứng dụng Metal cho nền tảng Apple.

Metal-cpp là một thư viện chi phí thấp kết nối các ứng dụng C++ của bạn với Metal.

Đầu tiên, tôi sẽ bắt đầu với tổng quan về metal-cpp là gì và nó hoạt động như thế nào, và sau đó tôi sẽ đề cập đến một số chi tiết về vòng đời của các đối tượng Objective-C.

C++ và Objective-C xử lý vòng đời hơi khác một chút và tôi sẽ chỉ cho bạn cách xử lý những khác biệt đó.

Xcode và metal-cpp có một số tiện ích tuyệt vời có thể giúp bạn quản lý vòng đời đối tượng trong ứng dụng của mình.

Và cuối cùng, tôi sẽ chỉ cho bạn cách tích hợp mã C++ với các lớp Objective-C.

Vì vậy, đây là một cái nhìn về metal-cpp và cách nó hoạt động.

Metal là nền tảng cho đồ họa và tính toán tăng tốc trên nền tảng Apple, cho phép các ứng dụng và trò chơi của bạn khai thác sức mạnh đáng kinh ngạc của GPU.

Ban đầu nó được thiết kế bằng cách sử dụng các tính năng mạnh mẽ và các quy ước được cung cấp bởi Objective-C.

Nhưng nếu cơ sở mã của bạn ở C++, bạn có thể cần thứ gì đó để kết nối giữa mã của mình và mã Objective-C của Metal.

Giới thiệu metal-cpp!

Nó đóng vai trò là trung tâm giữa ứng dụng C++ của bạn và Objective-C Metal.

Với metal-cpp trong ứng dụng của bạn, bạn có thể sử dụng các lớp và hàm Metal trong C++, và metal-cpp có thể giúp bạn gọi các hàm Objective-C trong thời gian chạy.

Metal-cpp là một trình bao bọc Metal C++ nhẹ.

Tôi nói rằng nó nhẹ, bởi vì nó được triển khai như một thư viện chỉ tiêu đề với các lệnh gọi hàm nội tuyến.

Nó cung cấp phạm vi bảo hiểm 100 phần trăm của Metal API bằng cách triển khai ánh xạ 1-1 của các lệnh gọi C++ đến API Objective-C.

Để làm điều này, metal-cpp bao bọc các phần của khung Foundation và CoreAnimation.

Nó là mã nguồn mở theo Giấy phép Apache 2, vì vậy bạn có thể sửa đổi thư viện và đưa nó vào các ứng dụng của mình một cách dễ dàng.

Metal-cpp sử dụng C để gọi trực tiếp vào thời gian chạy Objective-C.

Đây chính xác là cơ chế mà trình biên dịch Objective-C sử dụng để thực thi các phương thức Objective-C.

Vì vậy, giấy gói này giới thiệu rất ít chi phí.

Vì metal-cpp thực hiện ánh xạ 1-1 các cuộc gọi C++ sang Objective-C, nó tuân theo các quy tắc quản lý bộ nhớ Cocoa giống nhau.

Tôi sẽ thảo luận chi tiết hơn về điều này sau.

Bản đồ 1-1 này cũng cho phép tất cả các công cụ dành cho nhà phát triển hoạt động liền mạch, bao gồm GPU Frame Capture và trình gỡ lỗi Xcode.

Đây là chuỗi các cuộc gọi cần thiết để vẽ một hình tam giác bằng kim loại-cpp.

Nếu bạn đã quen thuộc với C++, đây là thời điểm tốt để học Metal, bởi vì bạn không cần phải lo lắng về cú pháp ngôn ngữ.

Nếu bạn đã sử dụng Metal với Objective-C, về các lệnh gọi hàm, có rất ít sự khác biệt giữa giao diện Objective-C của Metal và metal-cpp.

Tôi sẽ chứng minh việc sử dụng metal-cpp dễ dàng như thế nào.

Đầu tiên, tôi tạo một bộ đệm lệnh, mà tôi sẽ điền bằng các lệnh để GPU thực thi.

Tôi có thể đơn giản sử dụng con trỏ thô trong C++ làm ánh xạ đến ID trong Objective-C.

Tôi có thể tạo một bộ mã hóa lệnh kết xuất và viết các lệnh kết xuất với bộ đệm lệnh.

Hàm C++ renderCommandEncoder và phương thức Objective-C renderCommandEncoder WithDescriptor đều giống nhau.

Sự khác biệt duy nhất là quy ước tên của các ngôn ngữ.

Sau đó, tôi đặt một đối tượng trạng thái đường ống kết xuất có chứa các bộ đổ bóng đỉnh và phân đoạn và nhiều trạng thái kết xuất khác.

Sau đó, tôi mã hóa cuộc gọi vẽ của mình để hiển thị một tam giác duy nhất.

Sau đó tôi chỉ ra rằng tôi đã hoàn thành việc mã hóa các lệnh kết xuất.

Tôi trình bày bản vẽ, vì vậy hình tam giác được hiển thị trên màn hình.

Cuối cùng, tôi cam kết bộ đệm lệnh của mình.

Điều này cho GPU biết rằng nó có thể bắt đầu thực hiện các lệnh của tôi.

Rõ ràng, metal-cpp và Objective-C Metal gần như giống nhau.

Bạn không cần phải lo lắng về cú pháp ngôn ngữ bây giờ với metal-cpp, bạn có thể trực tiếp xem tài liệu Metal để tìm hiểu các khái niệm và cách sử dụng của Metal.

Bạn có thể đã chơi với mẫu ánh sáng hoãn lại này trước đây.

Bây giờ chúng tôi cung cấp một phiên bản mới của mẫu chiếu sáng hoãn lại này sử dụng metal-cpp.

Chúng tôi hy vọng điều này có thể giúp bạn học cách viết mã với metal-cpp trong thực tế.

Tôi cũng rất vui mừng được giới thiệu một loạt các mẫu C++ gia tăng giới thiệu Metal API và chỉ cho bạn cách hoàn thành các nhiệm vụ khác nhau với nó.

Vậy bây giờ bạn đã biết một chút về metal-cpp, bạn thực sự sử dụng nó như thế nào?

Chúng tôi đã xuất bản metal-cpp vào năm ngoái.

Đây là trang web nơi bạn có thể tìm thấy các bản tải xuống và hướng dẫn.

Hãy để tôi chỉ cho bạn các bước bạn sẽ cần thực hiện.

Sau khi tải xuống metal-cpp, bạn nên cho Xcode biết nơi để tìm nó.

Ở đây, tôi đặt metal-cpp theo dự án hiện tại.

Sau đó, bạn cần đặt C++17 hoặc cao hơn làm phương ngữ ngôn ngữ C++.

Tiếp theo, thêm ba khuôn khổ vào dự án: Foundation, QuartzCore và Metal.

Bây giờ chỉ còn một việc phải làm trước khi sử dụng giao diện C++ của các khuôn khổ đó.

Có ba tiêu đề trong metal-cpp.

Vì metal-cpp là thư viện chỉ dành cho tiêu đề, bạn cần tạo các triển khai của chúng trước khi nhập các tệp tiêu đề.

Để làm điều này, hãy xác định ba macro: NS_PRIVATE_IMPLEMENTATION, CA_PRIVATE_IMPLEMENTATION, VÀ MTL_PRIVATE_IMPLEMENTATION.

Nếu bạn quan tâm đến những gì metal-cpp làm với các macro dưới mui xe, vui lòng xem các tệp cầu nối tiêu đề trong thư mục metal-cpp.

Bạn có thể sử dụng các tiêu đề riêng biệt hoặc đặt chúng vào một tiêu đề duy nhất.

Bạn có thể nhập các tệp tiêu đề bất cứ khi nào bạn cần.

Nhưng hãy nhớ rằng, đừng xác định các macro NS, CA hoặc MTL_PRIVATE_IMPLEMENTATION nhiều lần.

Nếu không, bạn có thể gây ra lỗi định nghĩa trùng lặp.

Để sử dụng metal-cpp hiệu quả, bạn sẽ cần biết các quy tắc quản lý bộ nhớ của Cocoa, cách sử dụng các tiện ích tuyệt vời có thể giúp bạn quản lý vòng đời đối tượng và cách thiết kế kiến trúc ứng dụng của bạn khi bạn giao tiếp với các khung khác.

Tôi sẽ bắt đầu với quản lý vòng đời đối tượng.

Trong quá trình hoạt động của ứng dụng, bạn thường cần phân bổ và giải phóng bộ nhớ.

Bạn cũng cần quản lý bộ đệm lệnh, đối tượng đường ống và tài nguyên.

Để giúp quản lý bộ nhớ này, các đối tượng Objective-C và Cocoa bao gồm số lượng tham chiếu.

Điều này cũng có mặt trong metal-cpp.

Đếm tham chiếu giúp bạn quản lý trí nhớ của mình.

Sử dụng đếm tham chiếu, tất cả các đối tượng đều chứa thuộc tính retainCount.

Các thành phần trong một ứng dụng tăng số lượng để giữ cho các đối tượng mà chúng đang tương tác tồn tại và giảm nó khi chúng được hoàn thành với chúng.

Khi retainCount đạt đến 0, thời gian chạy sẽ định vị đối tượng.

Có hai loại đếm tham chiếu trong Objective-C.

Một cái được gọi là Phát hành Giữ lại Thủ công - MRR; cái còn lại là Đếm Tham chiếu Tự động - ARC.

Khi biên dịch mã với tính năng ARC, trình biên dịch nhận các tham chiếu bạn tạo và tự động chèn các cuộc gọi vào cơ chế quản lý bộ nhớ cơ bản.

Các vật thể kim loại-cpp được giữ lại và giải phóng thủ công.

Vì vậy, bạn cần hiểu các quy ước của Cocoa để biết khi nào nên giữ lại và giải phóng các đối tượng.

Không giống như tạo các đối tượng trong C++, các đối tượng metal-cpp không được tạo bằng mới cũng như không bị phá hủy khi xóa.

Với các quy ước của Cocoa, bạn sở hữu bất kỳ đối tượng nào bạn tạo bằng các phương thức bắt đầu bằng alloc, new, copy, mutableCopy hoặc create.

Bạn có thể sở hữu một đối tượng bằng cách sử dụng retain.

Khi bạn không còn cần nó nữa, bạn phải từ bỏ quyền sở hữu đối tượng mà bạn sở hữu.

Bạn có thể phát hành nó ngay lập tức hoặc phát hành nó sau đó.

Bạn không được từ bỏ quyền sở hữu đối tượng mà bạn không sở hữu vì bạn có nguy cơ được tự do gấp đôi.

Tiếp theo, tôi sẽ xem qua một ví dụ về các quy ước Ca cao này.

Trong lớp A, một phương thức sử dụng alloc để tạo một đối tượng và init để khởi tạo đối tượng này.

Hãy nhớ rằng, đừng bao giờ gọi init trên một đối tượng hai lần.

Loại A nắm quyền sở hữu và chịu trách nhiệm phân bổ nó.

Bây giờ số lượng giữ lại cho đối tượng này là một.

Tiếp theo, lớp B sử dụng retain để lấy đối tượng và sở hữu đối tượng này.

Cho đến nay, tôi có hai đối tượng chia sẻ quyền sở hữu đối tượng này được đại diện bởi khối lập phương màu cam.

Số lượng giữ lại tăng thêm một.

Lớp A không cần đối tượng này nữa, vì vậy lớp A nên gọi phát hành theo cách thủ công cho nó.

Kết quả là, số lượng giữ lại giảm đi một.

Bây giờ, chỉ có lớp B sở hữu đối tượng.

Được rồi, cuối cùng, lớp B cũng muốn giải phóng đối tượng này.

Bây giờ số lần giữ bằng 0, vì vậy thời gian chạy giải phóng đối tượng.

Đây là một tình huống mà một phương thức trong lớp B trả về một đối tượng.

Bạn vẫn cần đối tượng này trong phần còn lại của các chương trình.

Nói cách khác, bạn muốn từ bỏ quyền sở hữu một đối tượng trong một phương thức trong lớp B, nhưng bạn không muốn nó được phân bổ ngay lập tức.

Trong trường hợp này, bạn nên gọi tự động phát hành trong lớp B.

Số lượng giữ lại vẫn là một sau khi bạn gọi tự động phát hành, và do đó, bạn vẫn có thể sử dụng đối tượng sau này.

Đây là câu hỏi: vì lớp B không còn sở hữu đối tượng này nữa, ai chịu trách nhiệm phân bổ nó?

Khung nền tảng cung cấp một đối tượng quan trọng, được gọi là AutoreleasePool.

API Tự động phát hành đặt đối tượng vào một AutoreleasePool.

Bây giờ, AutoreleasePool nắm quyền sở hữu đối tượng.

AutoreleasePool làm giảm số lượng lưu giữ của người nhận khi AutoreleasePool bị phá hủy.

Bạn không phải là người duy nhất có thể tạo các đối tượng tự động phát hành.

Metal tạo ra một số vật thể tự động giải phóng như một phần hoạt động của nó.

Tất cả các phương pháp tạo các đối tượng tạm thời thêm chúng vào AutoreleasePools bằng cách gọi autorelease dưới mui xe.

Trách nhiệm của AutoreleasePool là phát hành chúng.

Nói cách khác, với AutoreleasePool, bạn có thể viết mã theo cách thanh lịch hơn.

Bạn có thể có một AutoreleasePool cho ứng dụng chính.

Chúng tôi cũng khuyến khích bạn tạo và quản lý các hồ bơi tự động phát hành bổ sung ở phạm vi nhỏ hơn để giảm bộ hoạt động của chương trình.

Bạn cũng cần AutoreleasePools cho mọi chủ đề bạn tạo.

Đây là một ví dụ cho thấy cách sử dụng AutoreleasePool và các đối tượng tự động phát hành.

Trong mẫu này, một AutoreleasePool được tạo bởi alloc, có nghĩa là bạn nắm quyền sở hữu và nó sẽ được phát hành thủ công.

Bây giờ chúng ta có một AutoreleasePool.

Như chúng ta đã thảo luận lúc đầu, bạn nên tạo một bộ đệm lệnh.

Nó không được tạo ra với alloc hoặc create, vì vậy bạn không sở hữu nó.

Thay vào đó, nó là một đối tượng được tự động phát hành do Metal tạo ra.

Bộ đệm lệnh này sẽ được đưa vào AutoreleasePool.

Trách nhiệm của AutoreleasePool là giải quyết nó.

Bạn có thể sử dụng nó như bạn muốn cho đến khi bạn phát hành AutoreleasePool.

Sau đó bạn cần tạo một RenderPassDescriptor.

RenderPassDescriptor này cũng sẽ được đưa vào AutoreleasePool.

Tương tự với RenderCommandEncoder.

Nó cũng là một đối tượng được tự động phát hành do Metal tạo ra.

Đừng quên đối tượng có thể vẽ hiện tại này.

Nó cũng sẽ được đưa vào AutoreleasePool.

Ở cuối đoạn mã, tôi sử dụng pPool->release để phát hành AutoreleasePool.

Trước khi được phân bổ, AutoreleasePool phát hành mọi thứ mà nó sở hữu, trong trường hợp này, nó phát hành CommandBuffer, RenderPassDescriptor, RenderCommandEncoder và currentDrawable.

Sau đó AutoreleasePool được phát hành.

Cho đến nay, bạn đã biết các quy ước của Cocoa, các đối tượng được tự động phát hành và AutoreleasePools.

Điều quan trọng là phải quản lý chính xác vòng đời của đối tượng để tránh rò rỉ bộ nhớ và các đối tượng zombie, và chúng tôi có các công cụ tuyệt vời để giúp bạn tránh và gỡ lỗi những vấn đề này.

Tôi sẽ tập trung vào hai tiện ích: NS::SharedPtr và NSZombie.

NS::SharedPtr là một tiện ích mới có thể giúp bạn quản lý vòng đời của đối tượng.

Bạn có thể tìm thấy nó trong khung Foundation trong thư mục metal-cpp.

Lưu ý rằng nó không hoàn toàn giống với std:shared_ptr.

Vì vậy, không có sự phụ thuộc vào thư viện tiêu chuẩn C++ và không có thêm chi phí lưu trữ số lượng tham chiếu.

Đây là NS::SharedPtr như thế nào.

Các chức năng chuyển và giữ lại thể hiện rõ ý định tiêu thụ một đối tượng.

Chuyển nhượng tạo ra một SharedPtr mà không làm tăng Số tham chiếu của người chỉ điểm, chuyển quyền sở hữu một cách hiệu quả sang SharedPtr.

Hàm giữ lại gửi một giữ lại đến đối tượng được truyền vào.

Sử dụng chức năng này để giữ cho các đối tượng sống sót trong AutoreleasePools và để thể hiện rằng chủ sở hữu của con trỏ có quyền lợi trong vòng đời của con trỏ.

Bạn có thể truy cập đối tượng cơ bản như mong đợi thông qua get và thông qua toán tử->.

Chia sẻ Ptr sao chép, di chuyển, xây dựng và phân công công việc như mong đợi, với bản sao tăng số lượng giữ lại.

Di chuyển nhanh và không ảnh hưởng đến số lượng giữ lại trong trường hợp chung.

SharedPtrs luôn gửi chính xác một bản phát hành đến pointee khi bị phá hủy.

Bạn có thể tránh điều này nếu bạn muốn bằng cách gọi hàm tách.

Quay trở lại đầu trang, điều quan trọng là phải biết sự khác biệt giữa việc tạo một con trỏ bằng cách chuyển hoặc giữ lại nó.

Vì vậy, đối với TransferPtr, giả sử tôi có một đối tượng MRR, với số tham chiếu là 1.

Sau khi tôi chuyển nó sang hàm TransferPtr, SharedPtr sẽ nắm quyền sở hữu đối tượng, nhưng retainCount của nó không thay đổi.

Khi con trỏ đi ra khỏi phạm vi, trình hủy của SharedPtr sẽ chạy và gọi phát hành trên đối tượng MRR, điều này làm giảm retainCount thành 0.

Một chức năng khác là NS::RetainPtr.

Khi bạn muốn tránh phân bổ một đối tượng vì bạn muốn sử dụng nó sau này, bạn nên sử dụng NS::RetainPtr.

Giả sử chúng ta có đối tượng MRR này; retainCount là một.

Sau khi chúng tôi chuyển nó sang hàm RetainPtr, retainCount tăng thêm một.

Sau khi hết phạm vi, RetainPtr này gọi phát hành cho đối tượng MRR này.

Vì vậy, retainCount là một.

Nói chung, NS::TransferPtr nhận quyền sở hữu một đối tượng cho bạn.

Nhưng NS::RetainPtr giúp bạn giữ lại một đối tượng khi bạn không muốn nó được phân bổ.

Khi bạn chuyển một đối tượng đến hai hàm này, NS::TransferPtr không thay đổi số lượng tham chiếu nhưng NS::RetainPtr tăng số lượng tham chiếu lên một khi nó gọi giữ lại cho bạn dưới mui xe.

Trình hủy của hai hàm này vừa gọi phát hành cho đối tượng được truyền vào và do đó, số lượng tham chiếu giảm đi một.

Nếu số lượng tham chiếu bằng không, đối tượng sẽ được giải phóng trong thời gian chạy.

Đây là một ví dụ về NS::TransferPtr.

Khi tôi nói về đường chuyền kết xuất, đã vẽ một tam giác duy nhất, tôi cần trạng thái đường ống kết xuất này.

Đây là các cuộc gọi để tạo ra một đối tượng trạng thái đường ống kết xuất.

Đây là những thuộc tính mà một bộ mô tả đường ống kết xuất cần.

Theo quy ước của Cocoa, vì những cuộc gọi này bắt đầu bằng new và alloc, tôi sở hữu những đồ vật này.

Vì vậy, tôi cần gọi phát hành cho những đối tượng này.

Với NS::SharedPtr, tôi không cần gọi phát hành cho các đối tượng MRR đó vì NS::SharedPtrs nắm quyền sở hữu các đối tượng này.

Vì vậy, ở đây, tôi chuyển các con trỏ thô đến hàm TransferPtr.

Sau khi làm điều đó, không cần phải gọi phát hành như tôi đã làm trong slide trước.

Nếu bạn quen thuộc với ARC, bạn có thể thấy rằng MRR được sử dụng với NS::SharedPtr tương tự như sử dụng ARC.

Bạn có thể gặp lỗi sử dụng sau khi miễn phí khi xử lý bộ nhớ theo cách thủ công.

Chúng xảy ra khi bạn đang cố gắng sử dụng một đối tượng đã được phát hành.

NSZombie là một cách hay để kiểm tra những lỗi đó.

Khi xảy ra lỗi sử dụng sau khi miễn phí, nó sẽ kích hoạt điểm dừng và cung cấp cho bạn dấu vết ngăn xếp.

Bạn có thể kích hoạt Zombies rất dễ dàng với một biến môi trường.

Chỉ cần đặt NSZombieEnabled thành CÓ.

Hoặc nếu bạn đang sử dụng Xcode, bạn có thể kích hoạt Zombies trong một sơ đồ.

Đây là cách nó hoạt động.

Tôi muốn tạo một đối tượng trạng thái đường ống kết xuất mới với cùng cài đặt đường ống kết xuất.

Vì vậy, trong hàmenderPipelineState mới này, tôi sử dụng lại đối tượng pDesc.

Sau khi nhấp vào chạy, Xcode kích hoạt điểm dừng và hiển thị cho tôi dấu vết ngăn xếp.

Điều đó có nghĩa là tôi đã làm sai điều gì đó.

Hừm, có vấn đề gì vậy?

Có lẽ NSZombie có thể giúp đỡ ở đây, vì vậy tôi kích hoạt NSZombie trong sơ đồ.

Khi tôi chạy lại chương trình, NSZombie sẽ kích hoạt một điểm dừng.

Tôi nhận được một cái gì đó mới trong đầu ra bảng điều khiển: "tin nhắn được gửi đến phiên bản deallocated."

Ồ, tôi đã sử dụng lại một đối tượng mà tôi đã phát hành.

Và đó là mô tả đường ống kết xuất.

Vì vậy, tôi cần sử dụng bộ mô tả đường ống kết xuất này trước khi gọi phát hành.

Bằng cách đó, tôi đã khắc phục sự cố.

Nhiều công cụ và chi tiết hơn được đề cập trong bài nói chuyện năm nay, "Hồ sơ và tối ưu hóa bộ nhớ trò chơi của bạn."

Ví dụ, bạn có thể học cách theo dõi retainCount trong phân bổ trong các công cụ.

Hãy thoải mái kiểm tra các công cụ khác trên nền tảng Apple.

Bạn sẽ phát hiện ra rằng họ có thể giúp bạn gỡ lỗi trò chơi của mình và cải thiện hiệu suất.

Bây giờ bạn đã biết cách quản lý vòng đời đối tượng trong metal-cpp.

Nhưng bạn vẫn có thể cần giao tiếp với các khuôn khổ khác, như bộ điều khiển trò chơi và âm thanh.

Những thứ này vẫn còn trong Objective-C.

Làm thế nào bạn có thể giao tiếp với các API đó và thiết kế một kiến trúc ứng dụng thanh lịch?

Giả sử bạn đã viết một ViewController trong Objective-C, nhưng bạn đã viết một trình kết xuất trong C++ với metal-cpp.

Bạn cần gọi các phương thức kết xuất, như vẽ, từ ViewController.

Thách thức ở đây là tách biệt hai ngôn ngữ một cách độc đáo nhưng để chúng hoạt động cùng nhau.

Giải pháp là tạo một lớp bộ điều hợp gọi C++ từ các tệp Objective-C.

Bằng cách này, bạn có thể tập trung vào Objective-C hoặc C++ trong các tệp nơi bạn triển khai các tính năng.

Ví dụ, tôi có thể tạo một lớp RendererAdapter trong Objective-C.

Và trong quá trình triển khai, tôi thêm một phương thức Objective-C để tôi có thể gọi nó trực tiếp từ ViewController.

Bên trong giao diện, tôi khai báo một con trỏ C++ đến một đối tượng kết xuất.

Bên trong phần thân của phương thức, tôi trực tiếp gọi phương thức C++ của trình kết xuất.

Phương pháp này cần chuyển MTK::View dưới dạng đối tượng C++ vào phương thức vẽ, vì vậy nó chuyển chế độ xem dưới dạng loại C++ bằng cách sử dụng từ khóa __bridge.

Tôi sẽ nói nhiều hơn về dàn diễn viên này sau.

Ngược lại, bạn cần gọi MTKView được viết bằng Objective-C trong Renderer được viết bằng C++.

Nó cũng đầy thử thách.

Tương tự, giải pháp là tạo một lớp bộ điều hợp.

Với lớp này, trong các tệp C++, bạn có thể gọi các phương thức Objective-C bằng giao diện C++.

Ví dụ, tôi có thể tạo một lớp ViewAdapter.

Tôi viết các giao diện trong C++, vì vậy trong lớp Renderer, tôi có thể gọi các phương thức xem C++ đó một cách dễ dàng.

Trong khi triển khai, tôi gọi các phương thức Objective-C từ MTKView, bao gồm currentDrawable và depthStencilTexture.

Bạn có thể nhận thấy có một số từ khóa __bridge ở đây.

Tôi sử dụng chúng để đúc giữa các vật kim loại-cpp và các vật thể Objective-C.

Như bạn đã học lúc đầu, các đối tượng metal-cpp được giữ lại và giải phóng thủ công, nhưng các đối tượng được tạo bởi Objective-C sử dụng tính tham chiếu tự động.

Bạn cần di chuyển các đối tượng từ MRR sang ARC và từ ARC sang MRR.

Đây là ba loại đúc cầu nối có thể giúp bạn sử dụng giữa Objective-C và C++.

Chúng cũng có thể giúp bạn chuyển quyền sở hữu _ đúc cầu giữa các vật thể Objective-C và kim loại-cpp.

Không có sự chuyển giao quyền sở hữu giữa họ.

__Bridge_retained casting đúc một con trỏ Objective-C đến một con trỏ kim loại-cpp và lấy quyền sở hữu từ ARC.

__Bridge_transfer casting di chuyển một con trỏ metal-cpp đến Objective-C và chuyển quyền sở hữu sang ARC.

Quay trở lại vấn đề, bạn cần đúc giữa các đối tượng kim loại-cpp và các đối tượng Objective-C.

Nếu không có chuyển quyền sở hữu, bạn có thể sử dụng __bridge cast.

Nếu bạn muốn truyền từ các đối tượng metal-cpp sang Objective-C và chuyển quyền sở hữu sang Objective-C, bạn nên sử dụng __bridge_transfer cast.

Nếu bạn muốn truyền từ các đối tượng Objective-C sang metal-cpp và lấy quyền sở hữu ra khỏi ARC, bạn nên sử dụng __bridge_retained cast.

Đây là một trường hợp khi tôi phải sử dụng MetalKit để tận dụng mã tải tài sản.

Điều đó có nghĩa là trong ứng dụng C++ của tôi, tôi cần một kết cấu như một đối tượng metal-cpp, nhưng nó được tạo ra bằng các phương thức Objective-C.

Tôi cần khả năng chuyển quyền sở hữu ra khỏi ARC để tôi có thể phát hành nó theo cách thủ công.

Và trong trường hợp này, tôi cần chọn __bridge_retained cast.

Tôi có chức năng C++ này tải một kết cấu từ danh mục và tôi muốn trả lại một kết cấu metal-cpp.

Nhưng bên trong, tôi đang gọi một số hàm Objective-C trong MetalKit.

Tôi cần xác định các tùy chọn mà trình tải kết cấu cần.

Sau đó, tôi tạo một trình tải kết cấu bằng cách gọi phương thức Objective-C từ MetalKit.

Với trình tải đó, tôi có thể tạo một đối tượng kết cấu và tải một kết cấu từ danh mục.

Phương pháp này cũng là một phương pháp Objective-C từ MetalKit.

Bây giờ tôi có một kết cấu loại Objective-C, tôi cần đúc nó vào đối tượng kim loại-cpp và lấy nó ra khỏi ARC.

Với những bước này, đã đến lúc viết mã và tôi sẽ chỉ cho bạn cách sử dụng trong thực tế.

Bước đầu tiên là xác định các tùy chọn trình tải kết cấu mà trình tải kết cấu cần.

Tôi có thể đúc chế độ lưu trữ và cách sử dụng kim loại-cpp một cách an toàn sang loại Objective-C, vì loại kim loại-cpp xác định chúng với cùng giá trị.

Ở đây tôi tạo ra một trình tải kết cấu.

Tôi có một thiết bị là một đối tượng metal-cpp, và tôi cần chuyển nó sang phương thức initWithDevice.

Bởi vì đối tượng kim loại-cpp là một đối tượng Objective-C, tôi có thể đúc nó như một đối tượng miễn phí.

Không có sự chuyển giao quyền sở hữu.

Bây giờ tôi sử dụng các tùy chọn trình tải kết cấu và trình tải kết cấu để tạo kết cấu.

Và tôi muốn trả lại kết cấu đã tải dưới dạng một đối tượng kim loại-cpp.

Vì vậy, tôi cần lấy nó ra khỏi ARC và chuyển nó sang loại con trỏ tương ứng.

Điều này được thực hiện với dàn diễn viên __bridge_retained.

Sau đó, tôi có thể sử dụng kết cấu này như bất kỳ đối tượng kim loại-cpp nào.

Tôi chịu trách nhiệm phát hành nó.

Trong phần này, tôi đã cung cấp một mẫu bộ điều hợp có thể giúp bạn xử lý hai ngôn ngữ khác nhau trong chương trình của mình.

Tôi cũng đã chỉ ra cách giao tiếp với Objective-C và C++ với ba loại diễn viên.

Tóm lại, metal-cpp là một trình bao bọc Metal C++ nhẹ và rất hiệu quả.

Tôi đã nói về cách quản lý vòng đời đối tượng khi sử dụng metal-cpp, cách giao tiếp với Objective-C một cách thanh lịch và cách các công cụ dành cho nhà phát triển của chúng tôi có thể giúp bạn gỡ lỗi.

Tải xuống metal-cpp và chơi với tất cả các mẫu tuyệt vời ngay bây giờ!

Xem những gì bạn có thể tạo ra với Metal.

Chúng tôi mong muốn thấy các ứng dụng C++ của bạn chạy trên tất cả các nền tảng của Apple.

Cảm ơn vì đã xem!

♪