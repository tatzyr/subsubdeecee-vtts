10142

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

「効率性が待っている：SwiftUIのバックグラウンドタスク」へようこそ。

私はwatchOSフレームワークチームのエンジニア、ジョン・ギャラガーです。

この講演では、Swift Concurrencyを使用して、Appleのすべてのプラットフォームで一貫した方法でバックグラウンドタスクを処理するための新しいSwiftUI APIについて学びます。

まず、バックグラウンドタスクを利用した嵐の日に空の写真を撮るためのアプリ、ストーミーと呼ばれるサンプルアプリについて説明します。

次に、アプリがバックグラウンドタスクをどのように使用し、バックグラウンドタスクが内部でどのように機能するかを掘り下げます。

次に、SwiftUIの新しいAPIを使用してこれらのバックグラウンドタスクを処理する方法を学びます。

そして最後に、APIがSwift Concurrencyを使用してバックグラウンドタスクの処理をこれまで以上に簡単にする方法を確認します。

新しいAPIは、Macで実行されているiOSアプリを含むwatchOS、iOS、tvOS、Mac Catalyst、ウィジェット間で共有されます。つまり、あるプラットフォームのバックグラウンドタスクを処理する概念とパターンは、他のプラットフォームで行う作業に適用できます。

Swift Concurrencyを利用して、新しいAPIは、深くネストされた完了ハンドラとコールバックの必要性だけでなく、しばしば副作用であった変更可能な状態の多くを減らします。

Swift Concurrencyのネイティブタスクキャンセルは、アプリケーションがタイムリーにタスクを優雅に完了し、システムによってバックグラウンドで終了されるのを避けるのに役立ちます。

雲の中に頭を置くのが好きな人のために、外が嵐のときに空の写真を撮ることをユーザーに思い出させるStormyというアプリを構築します。

アプリは、嵐の日の正午に、ユーザーが空の写真を撮ることを要求する通知を表示します。

ユーザーが通知をタップすると、空の写真を撮って、将来の賞賛のためにプロフィールにアップロードします。

この写真を背景にアップロードします。

アップロードが完了すると、アプリは別の通知を送信します。

バックグラウンドタスクでこれを行う方法に飛び込みましょう。

この図では、バックグラウンドタスクを利用して嵐の日にのみ通知がどのように送信されるかを高いレベルで検討します。

フォアグラウンドアプリケーションランタイムを左側のバーで表し、バックグラウンドアプリケーションランタイムを中央にバーで表現し、システムは右側で表されます。

アプリがユーザーによって最初にフォアグラウンドに起動されたとき、私たちは正午にバックグラウンドアプリの更新タスクをスケジュールする最初の機会を利用することができます。

その後、ユーザーがアプリを離れ、アプリが一時停止されると、システムはスケジュールした時間にバックグラウンドでアプリケーションを再び起動することを知っています。

タスクを正午にスケジュールしたので、システムはバックグラウンドでアプリをスリープ解除し、バックグラウンドアプリの更新タスクを送信します。

このバックグラウンドランタイムでは、外が嵐であるかどうかを把握し、その場合はユーザーに通知を送信する必要があります。

まず、現在の天気を確認するために気象サービスにネットワークリクエストを行います。

URLSessionがバックグラウンドにスケジュールされている場合、アプリケーションは一時停止し、ネットワーク要求が完了するのを待つことができます。

気象データのバックグラウンドネットワーク要求が完了すると、アプリケーションには新しいURLSessionバックグラウンドタスクで再びバックグラウンドランタイムが与えられます。

天気データ要求の結果を手にして、私たちのアプリケーションは外が嵐であるかどうかを知っており、ユーザーに空の写真を撮るように促す通知を送信するかどうかを選択できます。

URLSessionタスクの作業が完了したので、システムは再びアプリケーションを一時停止することができます。

単一のバックグラウンドタスクの詳細を掘り下げて、それがどのように機能するかを見てみましょう。

これを行うには、単一のアプリリフレッシュバックグラウンドタスクのライフサイクルを詳しく見ていきます。

ここで少しズームインしましょう。

まず、システムはアプリケーションをスリープ解除し、アプリのリフレッシュバックグラウンドタスクを送信します。

その後、まだバックグラウンドで、外が嵐であるかどうかを確認するためにネットワーク要求を行います。

理想的には、当社のネットワーク要求は、アプリケーションがアプリの更新のために割り当てられているバックグラウンドランタイム内に完了します。

ネットワークの応答を受け取ったら、すぐに通知を投稿したいと思います。

通知が投稿されたことで、アプリの更新中に行う必要があることをすべて完了し、システムはアプリケーションを再び一時停止することができます。

しかし、気象データのネットワーク要求が時間内に完了しない場合はどうでしょうか?

アプリが現在のタスクのバックグラウンドランタイムで不足している場合、システムは時間が不足していることをアプリに通知し、この状況を優雅に処理する機会を与えます。

アプリケーションがランタイムの有効期限が切れる前にバックグラウンド作業を完了したことを通知しない場合、アプリケーションはシステムによって終了され、将来のバックグラウンドタスク要求のためにスロットルされる可能性があります。

この場合、ネットワーク要求がバックグラウンドネットワーク要求であることを確認する必要があります。これにより、アプリの更新タスクをすぐに完了し、ネットワーク要求が完了したときに追加のバックグラウンドランタイムのために再び目を覚ますことができます。

バックグラウンドURLSessionがスケジュールされている場合、システムはアプリケーションを再び一時停止できます。

では、SwiftUIのBackgroundTask APIがStormyの構築にどのように役立つかについて掘り下げてみましょう。

まず、基本的なアプリケーションが必要です。

次に、明日の正午にバックグラウンドアプリの更新をスケジュールする関数を書きます。

まず、明日の正午を表す日付を作成します。

次に、最も早い開始日が明日の正午でバックグラウンドアプリの更新リクエストを作成し、スケジューラに提出します。

これは、明日の正午にアプリケーションをウェイクするようにシステムに指示するものです。

ユーザーが最初にアプリケーションを開き、正午に毎日のストーム通知を要求するときに、この関数を呼び出す必要があります。

新しいバックグラウンドタスクシーン修飾子を使用して、スケジュールしたバックグラウンドタスクに対応するハンドラを登録できます。

アプリがバックグラウンドタスクを受信すると、受信したバックグラウンドタスクに一致するこの修飾子で登録されたブロックが実行されます。

この場合、事前にスケジュールできるappRefreshタスクタイプを使用して、目的の日付にバックグラウンドで限られた量のランタイムをアプリケーションに提供しました。

バックグラウンドタスク修飾子でリクエストとハンドラーに同じ識別子を使用すると、システムは、対応するタスクがアプリケーションによって受信されたときに呼び出すハンドラを識別できます。

明日に再びスケジュールされていることを確認するために、明日の正午にバックグラウンドランタイムを再びスケジュールするために書いたscheduleAppRefresh関数を呼び出して、バックグラウンドタスクを開始します。

正午のバックグラウンドランタイムが繰り返されるようになったので、外が嵐であるかどうかを確認し、await Swiftキーワードを使用して結果を待ちます。

その後、ネットワーク要求が返され、実際に外が嵐になっている場合は、空の写真をアップロードするように促す通知をユーザーに送信するのを待っています。

クロージャの本体が戻ると、システムによってアプリケーションに割り当てられた基礎となるバックグラウンドタスクは暗黙的に完了としてマークされ、システムはアプリケーションを再び一時停止することができます。

ここでは、Swift Concurrencyを使用すると、作業が完了したときに明示的なコールバックを必要とせずに、バックグラウンドタスクで潜在的に長時間実行される操作を行うことができます。

通知の追加など、Appleプラットフォーム全体の多くのAPIは、すでに非同期操作のためのSwift Concurrencyをサポートしています。

ここでは、NotifyForPhoto非同期機能は、UserNotificationCenterにある非同期addNotificationメソッドを使用して、簡単な方法で実装できます。

Swift Concurrencyとasync/awaitがどのように私たちのためにいくつかの重い作業を行い、バックグラウンドタスクの処理をこれまで以上に簡単にする方法に飛び込みましょう。

私たちが参照してきた非同期isStormy関数を書いてみましょう。

この非同期機能は、外の天気をチェックするネットワーク要求を行う必要があります。

まず、共有URLSessionを取得し、気象データのリクエストをインスタンス化します。

URLSessionはSwift Concurrencyを採用しており、非同期コンテキストから待つことができるネットワークからデータをダウンロードする方法があります。

ネットワーク応答を手にして、気象データを読み取り、結果を返すことができます。

しかし、ランタイムの有効期限が切れる前に、アプリケーションがネットワーク要求を完了できない場合はどうでしょうか?

この場合、URLSessionをバックグラウンドセッションとして設定し、URLSessionバックグラウンドタスクを使用してアプリケーションに起動イベントを送信することを確認したかったことを思い出してください。

私たちのコードに戻ります。

共有URLSessionを使用していました。

代わりに、sessionSendsLaunchEventsプロパティをtrueに設定して、バックグラウンド設定からURLSessionを作成する必要があります。

これは、アプリが一時停止されていても一部のネットワーク要求が実行され、その要求が完了したときにURLSessionバックグラウンドタスクのためにアプリをウェイク解除する必要があることをシステムに伝えます。

watchOSでバックグラウンドで実行されているアプリによって行われたすべてのネットワーク要求は、バックグラウンドURLSessionsを通じて要求する必要があるため、これはwatchOSで特に重要であることに注意してください。

しかし、私たちはまだ終わっていません。

バックグラウンドタスクランタイムの有効期限が切れると、システムはバックグラウンドタスク修飾子に提供されるクロージャを実行している非同期タスクをキャンセルすることを思い出してください。

これは、バックグラウンドランタイムが期限切れになると、ここで行われたネットワーク要求もキャンセルされることを意味します。

そのキャンセルに対応して処理するには、Swift Concurrencyに組み込まれたwithTaskCancellationHandler関数を使用できます。

直接結果を待つ代わりに、ダウンロードをwithTaskCancellationHandler呼び出しに配置し、これも待ちます。

withTaskCancellationHandlerに渡された最初のブロックは、実行して待機したい非同期手順です。

2番目のonCancelトレーリングクロージャは、タスクがキャンセルされたときに実行されるコードです。

ここでは、ランタイムの期限切れのために即時のネットワーク要求がキャンセルされた場合、ネットワーク要求をバックグラウンドダウンロードタスクに昇格させ、そこでresumeを呼び出すことができ、アプリが一時停止されても持続するバックグラウンドダウンロードをトリガーします。

このコードは、同じURLSessionを使用して両方をバックアップしているため、基礎となるネットワーク要求を2回行いません。URLSessionは、内部で処理中の要求を重複排除します。

最後に、バックグラウンドURLSessionからの起動を処理するようにアプリケーションが設定されていることを確認する必要があります。

バックグラウンドタスク修飾子を再度使用できますが、今回はURLSessionタスクタイプを使用します。

先ほど作成したバックグラウンドURLSession設定に同じ識別子を使用することで、その特定のURLSessionがバックグラウンドタスクを生成する場合にのみ、このブロックが呼び出されるようにすることができます。

バックグラウンドタスクを処理するための新しい統合SwiftUI APIを掘り下げ、Swift Concurrencyがタスクの完了と有効期限の管理をこれまで以上に簡単にする方法を発見しました。

Swift Concurrencyの詳細については、WWDC 2021の「Meet Async/await in Swift」トークをご覧ください。

また、SwiftUIの並行性の詳細については、WWDC 2021の「SwiftUIで並行性を発見」をお勧めします。

「Efficiency awaits: Background Tasks in SwiftUI」をご覧いただきありがとうございます。

♪