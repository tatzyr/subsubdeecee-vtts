110356

♪インストゥルメンタルヒップホップ音楽♪

♪

こんにちは！私の名前はコンラッドで、スウィフトチームのエンジニアです。

「スウィフトで配布された俳優に会う」へようこそ。

このセッションでは、Swiftの並行性ベースのアプリを単一のプロセスを超えて進める方法を学びます。

スウィフトアクターは、同じプロセスで低レベルのデータレースからあなたを守るために設計されました。

彼らはコンパイル時にアクターの分離チェックを強制することによってこれを行います。

分散アクターは、同じ概念アクターモデルを洗練し、クラスター内の複数のデバイスやサーバーなど、複数のプロセスに拡張します。

したがって、まだスウィフトの俳優に精通していない場合に備えて、まずWWDC 2021の「スウィフト俳優で可変状態を保護する」セッションを見ることをお勧めします。

このセッションで取り組むアプリは、私が最近開発しているチックタックトースタイルのゲームです:チックタックフィッシュ!

ここでの楽しいアイデアは、あなたがプレイしているチームを選択できることです。これは、ゲームをプレイする際に動きをマークするために使用される絵文字に対応します。

その後、フィールドで動きをマークすると、プレイヤーの1人が勝つまで、チームの絵文字がフィールドに配置されます。

現在、私はボットの対戦相手と対戦できるオフラインモードのみを実装していますが、アプリを次のレベルに引き上げるためにいくつかのマルチプレイヤーモードを導入したいと思います。

私はすでにこのアプリで俳優を使用して、並行性を管理し、ゲームに関与するプレイヤーをモデル化しています。

これらのプレイヤーアクターをさまざまなプロセスに移行するために必要なことと、分散アクターがこれを行うのにどのように役立つかを見てみましょう。

コードにジャンプする前に、一歩下がって、俳優が同時および分散アプリケーションの構築に適している理由を視覚化しましょう。

WWDCセッションを通して、俳優について話すときに「並行性の海」という用語を使うのを聞くかもしれません。

これは、彼らについて考える素晴らしいメンタルモデルだからです。

各俳優は並行性の海にある独自の島であり、お互いの島に直接アクセスするのではなく、それらの間でメッセージを交換します。

Swiftでは、これらのメッセージを島間で送信することは、非同期メソッド呼び出しとasync/awaitとして実装されます。

これにより、アクターの状態分離と組み合わせることで、コンパイラは、アクターベースのプログラムがコンパイルされると、低レベルのデータレースから解放されることを保証することができます。

それでは、この同じ概念モデルを取り、分散システムとして再考されたゲームに適用してみましょう。

各デバイス、クラスター内のノード、またはオペレーティングシステムのプロセスを、独立した並行性の海であるかのように考えることができ、ここではより小さな暗い長方形としてマークされています。

その中で、彼らはまだ同じメモリスペースを共有していたので、私たちはかなり簡単に情報を同期することができました。

そして、メッセージパッシングの同じ概念は、並行性と配布のために完全にうまく機能しますが、それがすべて機能するためには、さらにいくつかの制限配布を実施する必要があります。

これは、配布された俳優が絵に出てくる場所です。

分散アクターを使用することで、2つのプロセス間のチャネルを確立し、それらの間でメッセージを送信することができます。

言い換えれば、スウィフトのアクターが並行性の海の島である場合、分散アクターは分散システムの広大な海で同じです。

プログラミングモデルから、実際にはあまり変わっていません - 俳優はまだ彼らの状態を分離し、まだ非同期メッセージを使用してのみ通信することができます。

同じプロセスでより多くの分散アクターを持つことができ、すべての意図と目的のために、彼らは地元のアクターと同じくらい有用であり、必要に応じてリモートインタラクションに参加する準備ができているという違いがあります。

このような分散アクターとのやり取り方法を変更することなく、潜在的に遠隔地になるこの機能は、「場所の透明性」と呼ばれます。

これは、分散型アクターがどこにいるかに関係なく、同じように対話できることを意味します。

これは、ローカルアクターで同じロジックを実行するため、テストにとって素晴らしいだけでなく、実装を変更することなく、アクターをどこにでも透過的に移動させることができます。

さて、私たちはいくつかのコードを見て、最初の俳優を分散俳優に変換する準備ができていると思います。

まず、一般的なゲームUIと、それが私のプレイヤー俳優とどのように相互作用するかを簡単に見てみましょう。

ビューはかなり標準的なSwiftUIコードであり、ゲームフィールドを表すテキストとボタンの要素がいくつかあります。

ユーザーがGameCellをクリックすると、プレイヤーアクターに移動を生成し、UIを強化するビューモデルを更新するよう依頼します。

Swiftの並行性のおかげで、これらのアップデートはすべてスレッドセーフで行儀が良好です。

現在、ユーザー入力を表すアクターはオフラインプレーヤーとして実装されています。

次にそれを見てみましょう。 見ていきましょう。

このアクターは、ゲームの動きを生成できる状態をカプセル化します。

具体的には、すでに行った動きの数と、どのチームのためにプレーしているかを追跡する必要があります。

各チームには、移動ごとに選択できる絵文字の数があるため、移動回数を使用して絵文字の文字IDを選択します。

また、移動が作成されたら、モデルを更新する必要があります。

モデルはMainActor単離クラスであるため、その突然変異はスレッドセーフです。

ただし、userMadeMoveの呼び出しを行うときに「await」を使用する必要があります。

最後に、オフラインプレーヤーは、対戦相手が動くたびに呼び出されるメソッドも宣言します。

ここでする必要があるのは、ビューモデルを更新することだけです。これにより、ゲームフィールドが再びアクティブになり、人間のプレイヤーが動きを選択でき、ゲームが終了するまでサイクルが続きます。

私たちのボットプレーヤーも俳優を使って表現されています。

その実装は、ビューモデルの更新を心配する必要がないため、実際にはオフラインプレーヤーよりもかなり簡単です。GameStateを追跡し、ゲームの動きを生成するだけです。

ボットプレーヤーは少しシンプルなので、分散アクターへの変換を開始するのは良いことだと思います。

さて、私たちはいくつかのコードを見て、最初の俳優を分散俳優に変換する準備ができていると思います。

分散型Tic Tac Fishゲームへの最初のステップは、BotPlayerタイプを分散アクターに変換し、ローカルでのみ使用することです。

Xcodeを開いて、どうすればそれができるか見てみましょう。

分散アクターを宣言するには、Swift 5.7で導入した新しい分散モジュールをインポートする必要があります。

このモジュールには、分散アクターを宣言して使用するために必要なすべてのタイプが含まれています。

このように、BotPlayerアクター宣言の前に分散キーワードを追加できるようになりました。

これにより、アクターは自動的にDistributedActorプロトコルに準拠し、多くの追加のコンパイル時間チェックを有効にします。

コンパイラが今修正するように求めるエラーの種類を見てみましょう。

コンパイラは、BotPlayerが使用できるアクターシステムを宣言しないことを有益に教えてくれます。

分散アクターは常に、リモートコールを実行するために必要なすべてのシリアル化とネットワーキングを処理する分散アクターシステムに属しているため、このアクターを使用する予定のアクターシステムを宣言する必要があります。

今のところ、私の唯一の目標は、リモートホストで実際に実行することなく、ボットプレーヤーにすべての分散分離チェックに合格させることなので、分散モジュールに付属のLocalTestingDistributedActorシステムを使用できます。

特定のアクターの本体にモジュール全体のDefaultDistributedActorSystemタイプエイリアスまたはアクターシステムタイプエイリアスを宣言することで、使用するアクターシステムについてコンパイラに伝えることができます。

後者のビットはもう少し具体的なので、それで行きましょう。

次のエラーは、両方のプレイヤーアクターが準拠する必要がある識別可能なプロトコルに準拠するために、以前に手動で実装していた「id」プロパティに関するものです。

エラーは、分散アクター合成プロパティと競合するため、IDプロパティを明示的に定義できないというエラーが表示されます。

IDは、分散型アクターの重要な部分です。

それらは、それが一部である分散アクターシステム全体のアクターを一意に識別するために使用されます。

それらは、アクターが初期化されると分散アクターシステムによって割り当てられ、後でそのシステムによって管理されます。

そのため、IDプロパティを手動で宣言または割り当てることはできません。アクターシステムはこれを行います。

言い換えれば、アクターシステムに任せて、手動で宣言したIDプロパティを削除することができます。

ここで対処する必要がある最後のエラーは、分散アクターの初期化子です。

コンパイラは、actorSystemプロパティが使用前に初期化されていないと述べています。

これは、すべての分散アクターの一部である別のコンパイラ合成プロパティです。

使用するアクターシステムの種類を宣言する必要があるだけでなく、合成されたactorSystemプロパティを具体的なアクターシステムで初期化する必要があります。

一般的に、ここで行う正しいことは、初期化子のアクターシステムを受け入れ、それをプロパティに渡すことです。

このようにして、簡単な単体テストを容易にするために、テストで別のアクターシステムの実装に合格することができます。

また、新しいボットプレーヤーを作成するたびにインスタンスを渡す必要があるので、今すぐやりましょう。

すごい！宣言側のエラーはすべて終わりました。

しかし、まだ対処する必要があるコールサイトのエラーがいくつかあります。

潜在的にリモート分散アクターでは、分散メソッドのみを呼び出すことができるようです。

これは、システム内の一部のアクターのみを分散アクターとして注釈を付けるのと似ています。

分散アクターのすべてのメソッドが必ずしもリモートで呼び出されるように設計されているわけではありません。

彼らは小さなヘルパー関数、または呼び出し者がすでに認証されていると仮定する関数を持つことができます。

これが、Swiftが分散APIサーフェスについて明確にするように求める理由です。リモート呼び出し者に公開したいと考えています。

ありがたいことに、これはこれらの関数に分散キーワードを追加するだけで簡単に修正できます。

makeMoveメソッドと opponentMovedメソッドの両方がリモートで呼び出されることを意図しているので、分散キーワードを両方に追加させてください。

OK！それだけで、私たちが世話をしなければならない最後のことは1つだけです。

分散メソッド呼び出しはネットワークの境界を越える可能性があるため、すべてのパラメータと戻り値がアクターシステムのシリアル化要件に準拠していることを確認する必要があります。

私たちの場合、アクターシステムはSwiftのネイティブシリアル化メカニズムであるCodableを使用しています。

具体的には、コンパイラは「結果タイプのGameMoveはシリアル化要件Codableに準拠していない」と教えてくれます。

GameMoveタイプを簡単に見てみましょう。

幸いなことに、必要な適合性を追加するだけで簡単にコード可能にできるクリーンな小さなデータタイプのようです。

Swiftコンパイラは、私のために必要なCodable実装を合成します。

そして、それで、私たちは終わりました!

予想通りゲームの実行を確認できます。

OK、チームフィッシュのポイント！

そして、ボットプレーヤーはまだ同じローカルデバイスで実行していますが、私たちはすでにエキサイティングな次のステップへの道を開きました。

このステップでは、ボットプレイヤーが新たに獲得した場所の透明性の力の恩恵を実際に享受します。

これに使用できるWebSocketベースのサンプルアクターシステムをすでに準備しました。

このアクターシステムを利用することで、ボットプレーヤーをサーバー側のSwiftアプリケーションに移動し、モバイルゲームからのリモート参照を解決することができます。

アクターに関する限り、宣言されたActorSystemをLocalTesting DistributedActor Systemから、サンプルアプリ用に準備したSampleWebSocketActorSystemに変更するだけです。

残りのアクターコードは同じままです。

次に、ローカルで作成するのではなく、リモートボットプレーヤーの参照を解決しましょう。

「ローカル」と「リモート」という用語は、分散型アクターに関しては視点の問題であることを覚えておく価値があります。

リモート参照ごとに、分散アクターシステムの他のノードにいくつかの対応するローカルインスタンスがあります。

分散アクターのローカルインスタンスの作成は、他のSwiftオブジェクトとほぼ同じ方法で実行されます。初期化子を呼び出すことによって。

しかし、分散アクターへのリモート参照を取得することは、わずかに異なるパターンに従います。

俳優を作成する代わりに、具体的な俳優システムを使用して俳優IDを解決しようとします。

静的解決方法を使用すると、アクターシステムに、そのIDを持つアクターの既存のアクターインスタンスを提供しようとしたり、それによって識別されたアクターにリモート参照を返したりすることができます。

アクターシステムは、識別子を解決するときに実際のリモートルックアップを実行すべきではありません。なぜなら、ご覧のとおり、解決方法は非同期ではないため、すぐに戻り、ネットワーキングやその他のブロッキング操作を実行すべきではないからです。

アイデンティティが有効に見え、有効な遠隔地を指しているように見える場合、システムはそのようなアクターが存在すると仮定し、それへのリモート参照を返すものとします。

IDを解決する時点で、リモートシステム上の実際のインスタンスはまだ存在しない可能性があることを覚えておいてください!

たとえば、ここでは、私たちと一緒にゲームをプレイすることに専念するべき相手のボットプレーヤーのランダムな識別子を作成しています。

このボットはまだ存在しませんが、このIDに指定された最初のメッセージが受信されると、サーバーサイドシステムで作成されます。

次に、サーバー側のSwiftアプリケーションに移行します。

私が準備したサンプルWebSocketアクターシステムのおかげで、それを実装するのは簡単です。

まず、WebSocketアクターシステムをサーバーモードで作成します。これにより、ポートに接続するのではなく、ポートにバインドしてリッスンします。

そして、システムが終了するまでアプリを待ちます。

次に、アクターインスタンスがまだ割り当てられていないIDに宛てられたメッセージを受信する際に、何らかの形でアクターをオンデマンドで作成するパターンを処理する必要があります。

一般的に、アクターシステムは着信メッセージを受信し、受信者IDを解決してローカルの分散アクターインスタンスを見つけようとし、見つかったアクターに対してリモートコールを実行します。

しかし、先ほど議論したように、私たちのボットプレーヤーIDは文字通り作成されているため、システムはそれらについて知ることができず、さらに適切なタイプのアクターを単独で作成することはできません。

ありがたいことに、私たちのサンプルアクターシステムの実装には、オンデマンドアクターの作成という適切なパターンが用意されています。

これは単なるパターンであり、分散アクターモジュールによって内蔵または提供されるものではないことに注意してください。

しかし、これは、アクターシステムの実装がどれほど柔軟で強力であるかを示す素晴らしい例です。

システムはさまざまなパターンを提供し、複雑なタスクを簡単に処理できます。

このパターンを使用して、アクターシステムは、通常どおりすべての着信IDのローカルアクターを解決しようとします。

ただし、既存のアクターが見つからない場合は、CreateOnDemandを解決しようとします。

IDとサーバーコードの一部を作成するクライアントコードの両方を管理しているため、必要なアクターをオンデマンドで作成することで、アクターシステムを支援することができます。

クライアントで作成しているボット識別子は、ActorIdentityにタグを追加したり、認識可能な名前を使用したりするなど、認識可能な命名スキームを使用しているため、これらのIDを検出し、まだアクティブになっていないすべてのメッセージに対して新しいボット対戦相手を作成できます。

後続のリモートコールは既存のインスタンスを単に解決するため、指定された最初のメッセージに対して新しいボットプレーヤーのみを作成します。

そして、それがすべてです!

サーバーの実装が完了し、リモートボットプレーヤーでゲームをプレイできるようになりました。

Swift runを使用してコマンドラインからサーバーを実行するか、Xcodeを使用してサーバースキームを選択して、通常どおり[実行]をクリックします。

最初の動きが終わったら、作成したリモートプレーヤー参照でmakeMoveを呼び出して、ボットプレーヤーに同じことをするように依頼します。

これにより、サーバー側のシステムで解決がトリガーされます。

このIDの既存のボットが見つからないので、試行して成功し、オンデマンドでボットを作成します。

ボットはmakeMoveコールを受信し、生成したGameMoveで返信します。

それはもうかなり素晴らしかったです!

ボットプレーヤーを分散アクターに変換するためにいくつかの先行作業を行う必要がありましたが、実際にリモートシステムに移動するのはかなり簡単でした。

そして、ネットワーキングやシリアル化の実装の詳細をまったく処理する必要はありませんでした!

すべての重い作業は、分散アクターシステムによって私たちのために行われました。

そして、まだ利用可能な強化された機能の完全な実装はあまりありませんが、この配布のしやすさは、この機能で努力しているものです。

次に、ゲームの真のマルチプレイヤー体験を構築する方法を見てみましょう。

以前の例では、クライアント/サーバーのシナリオで分散アクターを使用していましたが、作業した他のアプリからすでに慣れ親しんでいるかもしれません。

ただし、分散アクターは、専用のサーバーコンポーネントがまったく存在しないピアツーピアシステムでも使用できます。

これは私が私たちのゲームのために持っていた別のアイデアと一致します。

時々、旅行中に、あなたは本当に素晴らしいインターネットを持っていないこれらの場所に終わるが、ローカルWi-Fiはうまく機能します。

このような状況に陥ったので、同じネットワークに接続されている友人と挑戦して遊べるようになりたいです。

私は先に進み、今回はネットワークフレームワークが提供するローカルネットワーキング機能を使用して、別のアクターシステムの実装を実装しました。

この講演では、そのアクターシステムの実装には掘り下げていませんが、WWDC 2019の「Advances in Networking, Part 2」を見て、そのようなカスタムプロトコルを実装する方法を学ぶことができます。

また、ローカルネットワークへのアクセスは非常にプライバシーに敏感な情報が公開される可能性があるので、慎重に使用するように注意してください。

今回は、他のデバイス上の既存の分散アクターを扱うことになるので、前の例のようにIDを構成することはできません。

ゲームをプレイしたい他のデバイスで特定の俳優を発見する必要があります。

この問題は、分散アクターに固有のものではなく、一般的にサービス発見メカニズムを使用して解決されます。

しかし、分散アクターの領域では、すべてのコード全体で強く型付けされたAPIに固執することを可能にするAPIアクターシステムの共通のパターンとスタイルを提供することが期待されています。

私たちはそれを受付パターンと呼んでいます。なぜなら、ホテルと同様に、俳優は他の人が会うために知られ、利用可能になるためにそれでチェックインする必要があるからです。

すべてのアクターシステムには独自の受付係があり、アクターの発見を実装するために基礎となる輸送メカニズムに最も適した手段を使用できます。

場合によっては、これは既存のサービスディスカバリーAPIに依存し、その上にタイプセーフなAPIのみを重ねるか、ゴシップベースのメカニズム、または完全に何か他のものを実装するかもしれません。

しかし、これはアクターシステムのユーザーの観点からの実装の詳細です。私たちが気にする必要があるのは、アクターをチェックして発見可能にし、アクターを発見する必要があるときにタグやタイプでアクターを検索することだけです。

SampleLocalNetworkActorSystemに実装したシンプルな受付係を見てみましょう。

これにより、アクターがチェックインできるため、分散アクターシステム内のすべての受付担当者がそれを発見できます。

その後、そのシステムで利用可能になると、特定のタイプとタグのすべてのアクターのリストを取得できます。

この受付係を使って、一緒にゲームをしたい具体的な対戦相手俳優を見つけましょう。

以前は、GameViewはビュー初期化子で対戦相手を直接作成または解決しました。

対戦相手がネットワークに現れるのを非同期に待つ必要があるため、これはもうできません。

これを行うには、発見しようとしている間に「相手を探しています...」というメッセージを表示するマッチメイキングビューを紹介します。

この見解が表示されたら、マッチメイキングを開始します。

マッチメイキングは、新しい非構造化タスクで行われ、地元の俳優システムの受付係に、相手チームのタグを使用してタグ付けされたすべての俳優のリストを依頼します。

だから、私たちがチームフィッシュのためにプレーしているなら、私たちはチームのげっ歯類から選手を探し、その逆も同様です。

次に、非同期forループを使用して、対戦相手の俳優を待ちます。

システムが私たちがプレイできる対戦相手と一緒に近くのデバイスを発見すると、このタスクループが再開されます。

対戦相手が常にゲームをプレイする準備ができていると仮定し、すぐにモデルに保存し、彼らと一緒にゲームを開始しましょう。

ヘルパー機能を使用して、誰が最初の動きをすべきかを決定し、最後に、相手と一緒にゲームを始めたいと相手に伝えます。

マッチメイキングタスクで完了する必要があるのは1人の対戦相手だけなので、非同期のループから抜け出すために、必ずここに戻ってきてください。

このゲームプレイモードでは、オフラインプレイヤーの実装を少し変更する必要があります。

LocalNetworkPlayerと呼び、SampleLocalNetworkActorSystemを使用します。

それについて最も興味深いのは、人間のプレーヤーを表す俳優のmakeMoveメソッドがリモートで呼び出される可能性があることです!

しかし、動きをすることは、実際には人間のプレーヤーの責任です。

この課題を解決するために、ビューモデルにhumanSelectedField非同期関数を導入します。

これは、人間のユーザーがフィールドの1つをクリックしたときにトリガーされる@Published値によって駆動されます。

人間のプレイヤーがフィールドをクリックすると、makeMove機能が再開され、実行されたGameMoveをリモート呼び出し元に返すことでリモートコールを完了します。

そしてまた、それがすべてです!

真のマルチプレイヤーゲームモードを処理するために、アクターの実装を少し変更する必要がありましたが、システムの全体的なデザインには何も変わりませんでした。

そして最も重要なことは、私たちのゲームロジックの変更は、私たちがローカルネットワーキングを使用するという事実に本当に固有のものではなかったということです。

私たちは対戦相手を発見し、プレイヤーの俳優に分散された方法を呼び出すことによって彼らとゲームをプレイします。

このゲームモードをデモするには、一緒にプレイする対戦相手が必要です。

ふわふわのアシスタントのカプリン・ザ・カピバラに聞いてみましょう。

彼はそれがかなり得意だと聞きました！

OK、彼はかなり頭がいい。

彼はそれがかなり得意です。

ここで試してみましょう。

ああ、彼は私を捕まえた！

今回はあなたが勝ちます、小さな生き物、しかし、私たちは別のセッションをプレイします。

助けてくれてありがとう、カプリン!

最後になりましたが、異なるアクターシステムを組み合わせることで何が達成できるかをお伝えします。

たとえば、WebSocketシステムを使用して、サーバー側のロビーシステムにデバイスホストされたアクタープレーヤーアクターを登録し、それらをペアリングし、それらの間の分散コールのプロキシとして機能します。

デバイスホストのプレイヤーアクターが自分自身を登録できるGameLobbyアクターを実装するかもしれません。

デバイスがプレイオンラインモードに入ると、受付係を使用してGameLobbyを発見し、参加を呼び出します。

GameLobbyは、利用可能なプレイヤーを追跡し、プレイヤーのペアが特定されたときにゲームセッションを開始します。

ゲームセッションは、ゲームのドライバーとして機能し、動きをポーリングし、サーバーに保存されたゲームの表現でそれらをマークします。

ゲームが完了したら、結果を集めてロビーに報告することができます。

しかし、もっと興味深いことに、このデザインを水平にスケーリングすることができます。

もちろん、より多くのゲームセッションアクターを作成して、単一のサーバーでより多くのゲームを同時に提供できますが、分散アクターのおかげで、クラスター全体の同時ゲーム数の負荷バランスを取るために、他のノードでゲームセッションを作成することもできます。

つまり、クラスターアクターシステムがあればいいのに。

そして、実際、私たちはそうします!

このようなシナリオで使用するために、機能豊富なクラスターアクターシステムライブラリをオープンソース化しました。

SwiftNIOを使用して実装され、サーバー側のデータセンタークラスタリングに特化しています。

障害検出のための高度な技術を適用し、クラスター全体の受付係の独自の実装が付属しています。

アクターシステムの高度なリファレンス実装であり、強力なサーバーサイドアプリケーションであるため、それを見ることをお勧めします。

このセッションで学んだことをまとめましょう。

まず、分散アクターと、追加のコンパイラ支援アクターの分離とシリアル化チェックを提供する方法について学びました。

私たちは、彼らが場所の透明性を可能にする方法と、発信者と同じプロセスに配置される必要性から俳優を解放するためにそれを利用する方法を学びました。

また、分散アクターを使用して構築できるものについてインスピレーションを得るために、いくつかのアクターシステムの実装が実行されているのを見ました。

分散アクターは、使用されているアクターシステムと同じくらい強力です。

参考までに、このセッションで見たアクターシステムのリストです。

デフォルトでSwiftに同梱されているローカルテストシステムと、クライアント/サーバースタイルのWebSocketベースのシステムとローカルネットワーキングベースの2つのサンプルアクターシステム。

これらのシステムはかなり不完全であり、分散アクターを使用して構築する可能性のあるもののインスピレーションとしてより役立ちました。

このセッションに関連付けられているサンプルコードアプリで表示できます。

最後になりましたが、オープンソースのフル機能のサーバーサイドクラスタリングの実装です。

現在ベータパッケージとして利用可能で、Swift 5.7と一緒に成熟します。

分散アクターの詳細については、次のリソースを参照してください。このセッションに関連するサンプルコードには、Tic Tac Fishゲームのすべてのステップが含まれているため、自分でコードを深く掘り下げることができます。

分散アクター言語機能に関連するSwift進化の提案は、それらを強化するメカニズムを非常に詳細に説明しています。

また、Swiftフォーラムで手を差し伸べることもできます。ここでは、アクターシステム開発者とユーザー専用の分散アクターカテゴリを見つけることができます。

聞いてくれてありがとう、そして私はあなたがあなたのアプリで何のために分散俳優を使うかを見るのを楽しみにしています!

♪