10099

♪ ♪

キアラ・ローズ：こんにちは、私の名前はキアラ・ローズで、Safari拡張エンジニアとして働いています。

今日は、今年のSafari Web拡張機能の新機能について皆さんにお話しできることをとても楽しみにしています。

今日のプレゼンテーションに飛び込む前に、iOS、iPadOS、macOSの拡張機能をApp Storeに提出してくれた皆さんに感謝したいと思います。

今後、私たちの目標は、ユーザーにさらに優れた体験を提供できるように、新しい機能とAPIを実装し続けることです。

そして今日は、拡張機能の新しいマニフェストバージョン、更新されたAPI、複数のデバイス間での拡張機能の同期など、過去1年間に実装したエキサイティングな新機能のいくつかを強調します。

マニフェストバージョン3から始めましょう。

マニフェストバージョン3は、ウェブ拡張プラットフォームの次のイテレーションです。

パフォーマンスとセキュリティの改善を導入し、一般的な拡張APIを統合します。

すでにバージョン3を使用するように拡張機能を更新している人のために、拡張機能はSafari 15.4以降で動作します。

まだ持っていない人のために、Safariでマニフェストバージョン2を使用して拡張機能をサポートし続けるので、心配する必要はありません。

マニフェストバージョン3の主な新機能の1つは、拡張機能がバックグラウンドページの代わりにサービスワーカーを使用できることです。

あなたがウェブ開発者なら、おそらくサービスワーカーに精通しているでしょう。

これらは、addEventListener APIを使用してリスナーを登録できるイベント駆動型ページです。

これらのページは、マニフェストバージョン3をサポートする他のブラウザとも互換性があります。

拡張機能にバックグラウンドページを使用し続けることを好む場合は、大歓迎ですが、非永続的でなければなりません。

バージョン3のもう1つの改善点は、WebページでJavaScriptとスタイリングを実行するためのAPIがタブAPIから新しいスクリプトAPIに移行したことです。

これらのメソッドの機能のほとんどは同じままですが、Webページにコードを注入する新しい方法、ページ上のどのフレームでコードを実行するかのより多くのオプション、コードを実行するかを決定する機能など、スクリプトが提供するいくつかの新しい追加機能があります。

新しいスクリプトAPIのコードがタブAPIとどのように異なるかを見てみましょう。

このコードスニペットでは、tabs.executeScript APIを使用して、ウェブページの背景色を青に変更しています。

そして、このAPIでは、「コード」プロパティを渡すことによってのみ、文字列に含まれるコードを注入できますが、新しいスクリプトAPIを使用すると、このコードを含む関数オブジェクトを渡すことができます。

そして、他の関数と同様に、渡すことができる引数を含めることができます。

これは、文字列でコードを書くことに限定されないため、スクリプトを実行するはるかに改善された方法です。

また、スクリプティングでは、ターゲットと呼ばれる新しいプロパティがあることに注意してください。

このプロパティは、スクリプトを実行する場所を指定するために使用されます。

スクリプトを実行するには、スクリプトを実行するタブのIDを指定する必要があります。

タブIDが指定されていない場合、このAPIはエラーを返します。

次に、コードを注入するウェブページのどのフレームを選択するかを選択したい場合は、フレームIDを指定できます。

タブAPIでは、IDを1つしか指定できないことに注意してください。

しかし、スクリプトでは、複数のIDを指定できます。

しかし、私はもっと多くのコードを持っていて、それを複数のファイルに含めることができれば、はるかにきれいに見えるとしましょう。

tabs.executeScript APIでは1つのファイルしか指定できませんが、scripting.executeScriptでは複数のファイルを指定できます。

同様に、ウェブページにスタイリングを注入できるinsertCSSでも同じことができ、ウェブページから注入されたスタイリングを削除できるremoveCSSでも同じことができます。

これらのAPIは、マニフェストバージョン2と3の両方で使用できます。

ただし、tabs.executeScript APIはバージョン3では利用できません。

新しいスクリプトAPIに加えて、他のいくつかのAPIにもわずかな変更がありました。

これらの変更の1つは、web_accessible_resources用です。

マニフェストバージョン2では、リソースを含める場合は、Webページにアクセスしたいファイルの配列を渡すことでそうします。

しかし、マニフェストで指定したすべてのリソースにウェブページにアクセスできるため、これは問題になる可能性があります。

バージョン3の新しいフォーマットでは、特定のサイトで利用可能なリソースを制御できます。

例を見てみましょう。 例を見てみましょう。

以前は、クッキーとパイの画像は、拡張機能がアクセスできるすべてのサイトで利用可能でした。

しかし今、バージョン3では、パイ画像はapple.comのURLでのみ利用可能になり、クッキー画像はwebkit.orgページでのみ利用可能になります。

それでは、browser_actionとpage_action APIの変更を見てみましょう。

マニフェストバージョン2では、アクションはこのように明確に指定されました。

しかし、これらのAPIは同様の役割を果たすため、バージョン3では1つのAPIのみを使用するように統合されています。これはアクションです。

また、拡張機能のコンテンツセキュリティポリシーを宣言する方法も更新しました。

バージョン2では、拡張機能のポリシーが文字列を使用して定義されました。

ただし、バージョン3では、ポリシーはキー「extension_pages」を持つオブジェクトを使用して定義されています。

スクリプトのリモートソースは、バージョン3では許可されなくなったことに注意することが重要です。

最終的なAPIの変更は、非推奨のbrowser.extension.getURL APIでした。

このAPIはバージョン3ではサポートされなくなりました。

代わりに、browser.runtimeで同等のAPIを使用してください。

そこで、マニフェストバージョン3で導入された新機能について話しました。では、これらの新機能を使用できるように、拡張機能を更新するプロセスを進めましょう。

昨年のプレゼンテーションからSea Creatorの拡張機能を更新して、マニフェストバージョン3を使用します。

この拡張機能は、魚という単語のすべての出現を絵文字に置き換えます。

最初に行うことは、バージョン番号を2から3に変更することです。

また、バージョン3の非永続的な背景ページはまだ使用できますが、拡張機能がChromeと互換性があるように、これをサービスワーカーを使用するように更新します。

最後に、browser_actionをactionに変更します。

そして、マニフェストの構造の面では、この拡張機能がバージョン3の新しい仕様と互換性を持たせるために私が行う必要がある重要な変更です。

だから、これをテストするために、拡張機能を構築し、Safariで有効にします。

次に、webkit.orgのブログページに移動し、この拡張機能を使用して、魚という言葉のすべてのインスタンスを魚の絵文字に置き換えます。

しかし、何かがうまくいかなかったようです。

ご覧のとおり、このページの単語はどれも絵文字に置き換えられていません。

ポップオーバーを調べて、エラーメッセージがないか確認しましょう。

コンソールタブには、browser.tabs.executeScriptが未定義であるというエラーメッセージが表示されていることがわかります。

これは、このAPIがバージョン3では利用できなくなったため、代わりに新しいスクリプトAPIを使用するように拡張機能を更新する必要があります。

Xcodeでは、popup.jsファイルに戻り、代わりにスクリプトを使用するようにこの行を変更します。

スクリプトをどこに注入するかを指定するために使用されるターゲットプロパティを追加します。

また、新しいスクリプトAPIでは、タブのIDを指定する必要があります。

tabs.getCurrent APIを使用して、現在のタブの情報を含むオブジェクトを取得することで、これを行うことができます。

その後、そのオブジェクトを使用してタブIDを取得できます。

次に、実行するスクリプトを含むファイルを追加します。

最後に、私が行う最後の変更は、マニフェストにスクリプト権限を追加することです。

先に進んで拡張機能を構築し、これらの変更をSafariで使用します。

ご覧のとおり、この拡張機能は、マニフェストバージョン3の新機能を使用して、Safariで動作します。

だから、拡張機能をアップグレードするのは簡単です。

しかし、これらの新しい変更にまだ慣れていない場合は、スクリプトやサービスワーカーなどの多くの機能もバージョン2で使用できます。

それでは、宣言的なネットリクエストから始めて、今年更新したAPIのいくつかを見てみましょう。

宣言的なネットリクエストは、ルールセットを使用してネットワークリクエストをブロックまたは変更するための高速でプライバシーを保護する方法をWeb拡張機能に提供するコンテンツブロックAPIです。

このAPIを使用すると、リクエストの傍受と変更のすべての作業をSafariに委任することができ、あなたがしなければならないのは、適用すべきコンテンツブロックルールを指定することだけです。

マニフェストでルールセットを指定できます。

ここでは、宣言的なネットリクエスト許可を追加し、declarative_net_requestキーを使用して、すべてのページに適用されるルールセットを1つ追加しました。

以前は、マニフェストで最大10のルールセットしか宣言できませんでした。

しかし、この機能の新しいアップデートにより、最大50のルールセットを宣言できます。つまり、拡張機能をよりカスタマイズ可能にすることができます。

しかし、これらのルールセットのうち、一度に有効にできるのは10個しかないことを覚えておいてください。

ルールセットの作成方法の詳細については、昨年のSafari Web Extensionsのプレゼンテーションをご覧ください。このAPIについて詳しく説明します。

宣言的なネットリクエストの新機能のいくつかに移りましょう。

以前は、マニフェストでルールセットを宣言することしかできませんでしたが、ルールを動的に更新できる次の2つのAPIを実装しました。

最初のAPIはupdateSessionRulesで、拡張機能のルールを追加または削除できます。

しかし、これらのルールはブラウザのセッションや拡張機能の更新では持続しないことに注意することが重要です。

持続するルールを更新したい場合は、代わりにupdateDynamicRules APIを使用してください。

これにより、拡張機能全体を更新せずにブロックルールを更新できます。

これらのAPIの1つを使用してルールセットを変更する方法を見てみましょう。 ルールセットの変更方法を見てみましょう。

シークリエイター拡張機能を使用してウェブページ上のコンテンツをブロックし、新しいAPIを使用して選択したページのコンテンツのブロックを解除します。

拡張マニフェストで、私が最初に行うことは、宣言的なネットリクエスト許可を追加することです。

次に、宣言的なネットリクエストキーを使用してルールセットを追加します。

適用されているルールは、rules.jsonファイルにあります。

このファイルでは、すべてのURL上のすべての画像をブロックする1つのルールを宣言しました。

拡張機能を構築し、このルールがSafariでどのように適用されるかを見てみましょう。

ご覧のとおり、このページの画像は消えました。

それはまさに私たちが期待していたことです。

これは、Safariがコンテンツブロックルールを正常に適用したことを示しています。

そして、魚に関するこのウィキペディアのページに移動すると、このサイトの画像もブロックされていることがわかります。

しかし、webkit.orgのブログページを期待しているすべてのページの画像をブロックするようにルールを更新したいとしましょう。

宣言的なネットリクエストに更新されたAPIの1つを使用して、それを行うことができます。

Xcodeに戻って、いくつかの変更を加えましょう。

Popup.jsファイルで、コンテンツブロックルールを更新する関数を宣言します。

Webkit.org/blog-filesページの画像を許可するルールを設定します。

次に、updateSessionRules APIを使用して、このルールをルールセットに追加します。

最後に、拡張機能を構築し、Safariで変更をテストします。

ご覧のとおり、このブログ記事の画像が読み込まれ、このサイトの画像を許可する新しいルールが機能していることを示しています。

そして、ウィキペディアのサイトに行くと、このページの画像がまだブロックされていることがわかります。これは、新しいルールがこのページに適用されていないことを示しています。

そのため、新しい宣言型ネットリクエストAPIを使用して、コンテンツブロックルールを更新できます。

それでは、拡張機能がウェブページと通信する方法を見てみましょう。

この素晴らしい機能により、ユーザーが拡張機能を有効にしている場合、ウェブサイトはカスタム動作を作成できます。

APIはexternally_connectableと呼ばれます。

それを使用するには、マニフェストでマッチパターンを宣言します。

これらのマッチパターンは、どのページが拡張機能と通信できるかを決定します。

そして、注意すべき重要なことは、この機能はブラウザの名前空間でのみ機能するということです。

そして最後に、ユーザーはメッセージを送受信する前に、拡張機能にページへのアクセスを許可する必要があります。

この機能を使用するために、ウェブページに追加するコードを見てみましょう。 

まず、extensionIDを取得する必要があります。

これは、この形式の拡張機能とチーム識別子のバンドル識別子です。

チーム識別子は、developer.apple.comのアカウント設定のメンバーシップタブで確認できます。

次に、送信メッセージAPIを使用して、拡張機能にメッセージを投稿します。

関数を渡すことで、拡張機能から受け取る応答を処理できます。

それでは、拡張機能がメッセージを受信しなければならないコードを見てみましょう。

拡張機能は、onMessageExternalと呼ばれるイベントをリッスンすることで、ウェブページからメッセージを受信できます。

拡張機能は、イベントリスナーに渡されたメソッドを使用して、Webページにメッセージを送り返すことができます。

ブラウザごとに異なる拡張ウェブストアがあるため、拡張機能は多くの異なる識別子を持つことができます。

したがって、ChromeやEdgeの拡張機能ではなく、SafariのWeb拡張機能にメッセージを送信していることを確認するために、使用する正しいものを決定する必要があります。

これを行うには、Promise.allを呼び出すとbrowser.runtime.sendMessage APIを使用できます。

次に、これを行うのに役立つコードの例を見てみましょう。 これを行うのに役立つコードの例を見てみましょう。

ウェブページから、複数の拡張IDを使用して複数のメッセージをブロードキャストできます。

拡張機能から正確に1つの応答が得られ、さらなる通信に使用する拡張機能IDがわかります。

ここには、rea determineExtensionIDという関数があります。

この関数は、browser.runtime.sendMessage APIを使用して拡張機能にメッセージを送信します。

複数のIDがあり、使用する正しいIDを決定したい場合は、Promise.allを使用して、 determineExtensionID関数を使用して複数の呼び出しを行うことができます。

Promise.allは約束の配列を受け取り、解決されたすべての値の配列を持つ単一の約束を返します。

この配列を使用して、ユーザーがインストールした拡張機能を見つけることができます。

拡張機能のバックグラウンドページでは、ウェブページからのメッセージを聞く必要があります。

メッセージを受信したら、拡張機能がインストールされていることをウェブページに伝えるために1つを送り返す必要があります。

これが、新しいexternally_connectable APIを使用して、拡張機能がWebページと通信できるようにする方法です。

私たちが更新した次の機能は、私の個人的なお気に入りであり、それはunlimitedStorageです。

そして、unlimitedStorageが実際に無制限であることを発表できることをとても嬉しく思います!

この機能があなたによって非常に強く要求されたことを考えると、私たちはあなたの拡張機能がもはや10 MBのクォータを持っていないことを共有することに興奮しています。

必要に応じて、できるだけ多くのデータを自由に使用できます。

ただし、ユーザーはいつでも拡張機能で使用されているデータを消去できることに注意することが重要です。

したがって、ユーザーがデータを消去する気がしないように、厳密に必要なデータのみを保存してください。

この機能を使用するには、マニフェストでストレージとunlimitedStorageの許可を請求するだけで、大丈夫です。

これらは、昨年ウェブ拡張機能用に更新したすべてのAPIでした。

最後に、ユーザーがすべてのデバイスで拡張機能を簡単に取得できる新機能について話しましょう。

Safari 16では、拡張機能の使用体験をよりシームレスにしました。

ユーザーが自分のデバイスの1つで拡張機能をオンにすると、すべてのデバイスでオンになります。

これに加えて、拡張機能をダウンロードするプロセスをはるかに簡単にしました。

これがどのように機能するかを見てみましょう。

ユーザーがMacで拡張機能の1つを有効にしているとしましょう。

他のデバイスの拡張機能設定では、拡張機能をダウンロードするオプションが与えられます。

ダウンロードされると、デバイスで自動的に有効になり、ユーザーエクスペリエンスが向上します。

では、ウェブ拡張機能やコンテンツブロッカーにこれを設定する方法に飛び込みましょう。

まず、App Storeに提出する際に、iOS、iPadOS、macOSの拡張機能をリストアップすることをお勧めします。

このようにして、拡張機能はすべてのユーザーのデバイスで利用できるようになります。

次に、拡張機能がデバイス間で同期できるようにするには、次の2つの方法のいずれかを使用する必要があります。

最も簡単で推奨される方法は、ユニバーサル購入を採用することです。

ユニバーサル購入により、ユーザーは一度だけ購入することで、すべてのプラットフォームで拡張機能を楽しむことができます。

この方法を使用すると、すべて設定できます。

ユーザーは、拡張機能を一度ダウンロードした後、私が示したすべての機能を取得します。

ユニバーサル購入を設定するには、App Store Connectで同じアプリレコードに関連付けることができるように、拡張機能全体で単一のバンドル識別子を使用する必要があります。

これを行う方法の詳細については、拡張機能のユニバーサル購入を設定する方法に関するドキュメントをご覧ください。

しかし、ユニバーサル購入を設定しないことを選択した場合は、アプリを手動でリンクすることができます。

これを行うには、Xcodeを使用して、同期したいアプリや拡張機能の情報plistにバンドル識別子を追加します。

iOSアプリと拡張機能をmacOSのものと同期するには、情報plistで特定のキーを使用する必要があります。

このキーはmacOSアプリのplistに、このキーはmacOS拡張機能のplistに入力します。

同様に、macOSアプリを同期するために同じプロセスに従います。

このキーをiOSアプリplistに追加し、このキーをiOS拡張plistに追加します。

これがXcodeでどのように機能するか見てみましょう。

Xcodeでは、最初に行う必要があるのは、各ターゲットの設定を更新して、同期したい拡張機能とアプリのバンドル識別子を含めることです。

まず、対応するmacOSアプリのバンドル識別子をiOSアプリの情報plistに追加します。

そして、ご覧のとおり、iOSアプリのバンドル識別子を追加することで、macOSアプリにも同じプロセスを実行しました。

そして、macOS拡張機能バンドル識別子を追加することで、iOS拡張機能も同様です。

そして最後に、iOS拡張機能バンドル識別子を追加して、macOS拡張機能について。

そして、ユーザーがどこでも使用できるように、アプリと拡張機能をリンクするのがいかに簡単かです。

要約すると、ユニバーサル購入を設定するか、Xcodeで各iOSおよびmacOSアプリと拡張機能のバンドル識別子を追加することで、ユーザーがこの機能を利用できるようにすることができます。

今日は、マニフェストバージョン3、更新したAPI、および複数のデバイス間での拡張機能の同期について議論しました。

Safari Web拡張機能のこれらすべての新機能について、あなたが私と同じくらい興奮していることを願っています。

今日のセッションのコードを含むサンプルプロジェクトを自由にダウンロードして、私たちが紹介したAPIのいくつかで遊んでください。

次に、あなたの考えを知りたいです。

フィードバックアシスタントを使用してバグを提出したり、Safari開発者フォーラムで私たちとチャットしたりして、拡張機能の開発をより良くする方法についてのフィードバックを提供します。

いいえ、本当に。私たちはあなたがどう思うか知りたいです!

Web拡張機能の未来を形作るために、WebExtensionsコミュニティグループへの参加を検討してください。

最後に、ウェブインスペクタ拡張機能の作成に関するWWDCプレゼンテーションをチェックしてください。

このセッションにチューニングしてくれてありがとう、そしてWWDCの素晴らしい残りをお過ごしください。