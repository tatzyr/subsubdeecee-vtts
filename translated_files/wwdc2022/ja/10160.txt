10160

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

こんにちは、私の名前はKeyi Yuで、Metal Ecosystemチームのエンジニアです。

今日は、metal-cppを紹介できて光栄です。

C++を使用し、Appleプラットフォーム用のMetalアプリケーションを構築したい人のためにmetal-cppを作成しました。

Metal-cppは、C++アプリケーションをMetalに接続する低オーバーヘッドライブラリです。

まず、metal-cppとは何か、それがどのように機能するかの概要から始め、次にObjective-Cオブジェクトのライフサイクルに関するいくつかの詳細について説明します。

C ++とObjective-Cはライフサイクルを少し異なる方法で処理し、それらの違いを処理する方法を紹介します。

Xcodeとmetal-cppには、アプリのオブジェクトライフサイクルを管理するのに役立つ優れたユーティリティがいくつかあります。

最後に、C++コードをObjective-Cクラスと統合する方法を紹介します。

ここでは、metal-cppとその仕組みを見てみましょう。

Metalは、Appleプラットフォームでグラフィックスとコンピューティングを加速するための基盤であり、アプリやゲームがGPUの信じられないほどのパワーを活用できるようにします。

もともとは、Objective-Cが提供する強力な機能と慣習を使用して設計されました。

しかし、コードベースがC++の場合、コードとMetalのObjective-Cコードを橋渡しする何かが必要になるかもしれません。

Metal-cppを紹介!

これは、C++アプリケーションとObjective-C Metalの間のハブとして機能します。

アプリケーションにmetal-cppを使用すると、C ++でMetalクラスと関数を使用でき、metal-cppは実行時にObjective-C関数を呼び出すのに役立ちます。

metal-cppは軽量のMetal C++ラッパーです。

インライン関数呼び出しでヘッダーのみのライブラリとして実装されているため、軽量だと言います。

Objective-C APIへのC++呼び出しの1対1のマッピングを実装することで、Metal APIの100%のカバレッジを提供します。

これを行うには、metal-cppはFoundationとCoreAnimationフレームワークの一部をラップします。

Apache 2ライセンスの下でオープンソースなので、ライブラリを変更してアプリケーションに簡単に含めることができます。

metal-cppはCを使用してObjective-Cランタイムに直接呼び出します。

これは、Objective-CコンパイラがObjective-Cメソッドを実行するために使用するのとまったく同じメカニズムです。

したがって、このラッパーはオーバーヘッドをほとんど導入しません。

metal-cppはC++からObjective-Cへの呼び出しの1対1のマッピングを実装しているため、同じCocoaメモリ管理ルールに従います。

これについては後で詳しく説明します。

この1対1のマッピングにより、GPUフレームキャプチャやXcodeデバッガなど、すべての開発者ツールがシームレスに動作することもできます。

これらは、metal-cppで三角形を描くために必要な一連の呼び出しです。

C++に精通している場合は、言語構文を心配する必要がないので、Metalを学ぶのに良い時期です。

すでにObjective-CでMetalを使用している場合、関数呼び出しの面では、Metalとmetal-cppのObjective-Cインターフェースにはほとんど違いはありません。

私は金属cppを使用するのがいかに簡単かを示すつもりです。

まず、コマンドバッファを作成し、GPUが実行するコマンドで埋めます。

C++の生のポインタを、Objective-CのIDへのマッピングとして簡単に使用できます。

レンダリングコマンドエンコーダを作成し、コマンドバッファでレンダリングコマンドを書くことができます。

C++関数renderCommandEncoderとObjective-CメソッドrenderCommandEncoder WithDescriptorは同じです。

唯一の違いは、言語の名前の慣習です。

次に、頂点とフラグメントシェーダー、その他のさまざまなレンダリング状態を含むレンダリングパイプライン状態オブジェクトを設定します。

次に、描画呼び出しをエンコードして、単一の三角形をレンダリングします。

次に、レンダリングコマンドのエンコードが終了したことを示します。

ドローブルを提示するので、三角形が画面に表示されます。

最後に、コマンドバッファをコミットします。

これは、私のコマンドの実行を開始できることをGPUに伝えます。

明らかに、metal-cppとObjective-C Metalはほぼ同じです。

metal-cppで言語構文を心配する必要はありません。Metalのドキュメントを直接調べて、Metalの概念と使用法を学ぶことができます。

あなたはすでにこの延期された照明サンプルで遊んだことがあるかもしれません。

私たちは今、金属cppを使用するこの延期照明サンプルの新しいバージョンを提供しています。

これが実際にmetal-cppでコーディングする方法を学ぶのに役立つことを願っています。

また、Metal APIを導入し、さまざまなタスクを達成する方法を示す一連のインクリメンタルC++サンプルを紹介することに興奮しています。

Metal-cppについて少し知っているので、実際にどのように使用しますか？

私たちは昨年metal-cppを出版しました。

これは、ダウンロードと手順を見つけることができるウェブページです。

あなたが取る必要があるステップをお見せしましょう。

metal-cppをダウンロードした後、それを見つける場所をXcodeに伝える必要があります。

ここでは、現在のプロジェクトの下にmetal-cppを入れました。

次に、C++17以上をC++言語の方言として設定する必要があります。

次に、Foundation、QuartzCore、Metalの3つのフレームワークをプロジェクトに追加します。

今、これらのフレームワークのC++インターフェイスを使用する前にやるべきことは1つだけです。

Metal-cppには3つのヘッダーがあります。

Metal-cppはヘッダーのみのライブラリであるため、ヘッダーファイルをインポートする前に実装を生成する必要があります。

これを行うには、NS_PRIVATE_IMPLEMENTATION、CA_PRIVATE_IMPLEMENTATION、MTL_PRIVATE_IMPLEMENTATIONの3つのマクロを定義します。

Metal-cppがボンネットの下のマクロで何をするかに興味がある場合は、metal-cppフォルダのヘッダーブリッジファイルをチェックしてください。

ヘッダーを別々に使用することも、1つのヘッダーに入れることもできます。

ヘッダーファイルは、必要なときにいつでもインポートできます。

ただし、NS、CA、またはMTL_PRIVATE_IMPLEMENTATIONマクロを複数回定義しないでください。

そうしないと、重複した定義エラーが発生する可能性があります。

metal-cppを効果的に使用するには、Cocoaのメモリ管理ルール、オブジェクトのライフサイクルの管理に役立つ優れたユーティリティの使用方法、他のフレームワークとインターフェイスするときにアプリケーションアーキテクチャを設計する方法を知る必要があります。

オブジェクトのライフサイクル管理から始めます。

アプリケーションの動作中は、通常、メモリを割り当てて解放する必要があります。

また、コマンドバッファ、パイプラインオブジェクト、およびリソースも管理する必要があります。

このメモリを管理するために、Objective-CとCocoaオブジェクトには参照カウントが含まれています。

これは金属cppにも存在します。

参照カウントは、記憶を管理するのに役立ちます。

参照カウントを使用すると、すべてのオブジェクトにretainCountプロパティが含まれています。

アプリのコンポーネントは、相互作用しているオブジェクトを生き続けるために数を増やし、それらが終わったらそれを減らします。

retainCountがゼロになると、ランタイムはオブジェクトの割り当てを解除します。

Objective-Cの参照カウントには2つのタイプがあります。

1つは手動保持リリース-MRRと呼ばれ、もう1つは自動参照カウント-ARCです。

ARC機能でコードをコンパイルするとき、コンパイラは作成した参照を受け取り、基礎となるメモリ管理メカニズムへの呼び出しを自動的に挿入します。

Metal-cppオブジェクトは手動で保持され、解放されます。

したがって、オブジェクトを保持して解放するタイミングを知るには、ココアの慣習を理解する必要があります。

C++でオブジェクトを作成するのとは異なり、metal-cppオブジェクトは新規で作成されず、削除で破棄されません。

Cocoaの規約では、alloc、new、copy、mutableCopy、またはcreateで始まるメソッドで作成したオブジェクトを所有します。

保持を使用してオブジェクトの所有権を取得することができます。

もはやそれを必要としないときは、所有しているオブジェクトの所有権を放棄する必要があります。

すぐにリリースすることも、後でリリースすることもできます。

二重の自由を危険にさらすため、所有していないオブジェクトの所有権を放棄してはいけません。

次に、これらのココアコンベンションの例を見ていきます。

クラスAでは、メソッドはallocを使用してオブジェクトを作成し、initを使用してこのオブジェクトを初期化します。

オブジェクトにinitを2回呼び出しないことを覚えておいてください。

クラスAは所有権を取得し、それを割り当てる責任があります。

さて、このオブジェクトの保持カウントは1つです。

次に、クラスBはretainを使用してオブジェクトを取得し、このオブジェクトの所有権を取得します。

これまでのところ、私はオレンジ色の立方体で表されるこのオブジェクトの所有権を共有する2つのオブジェクトを持っています。

保持数は1つ増加します。

クラスAはもうこのオブジェクトを必要としないので、クラスAは手動でリリースを呼び出す必要があります。

その結果、保持数は1つ減少します。

現在、クラスBのみがオブジェクトを所有しています。

さて、最後に、クラスBもこのオブジェクトをリリースしたいと考えています。

これで、保持カウントはゼロなので、ランタイムはオブジェクトを解放します。

これは、クラスBのメソッドがオブジェクトを返す状況です。

残りのプログラムにはまだこのオブジェクトが必要です。

言い換えれば、クラスBのメソッド内のオブジェクトの所有権を放棄したいが、すぐに割り当て解除されたくない。

この場合、クラスBのオートリリースを呼び出す必要があります。

オートリリースを呼び出した後も保持カウントは1つであるため、後でオブジェクトを使用できます。

ここに質問があります:クラスBはもうこのオブジェクトを所有していないので、誰がそれを割り当て解除する責任がありますか?

Foundation Frameworkは、AutoreleasePoolと呼ばれる重要なオブジェクトを提供します。

Autorelease APIは、オブジェクトをAutoreleasePoolに入れます。

今、AutoreleasePoolはオブジェクトの所有権を取ります。

AutoreleasePoolは、AutoreleasePoolが破壊されると、レシーバーの保持数を減少させます。

自動リリースされたオブジェクトを作成できるのはあなただけではありません。

金属は、その操作の一環として、いくつかの自動解放されたオブジェクトを作成します。

一時的なオブジェクトを作成するすべてのメソッドは、ボンネットの下でautoreleaseを呼び出すことによって、それらをAutoreleasePoolsに追加します。

それらを解放するのはAutoreleasePoolの責任です。

言い換えれば、AutoreleasePoolを使用すると、よりエレガントな方法でコーディングできます。

メインアプリケーション用のAutoreleasePoolを持つことができます。

また、プログラムの作業セットを減らすために、より小さなスコープで追加のAutoreleasePoolsを作成および管理することをお勧めします。

また、作成するすべてのスレッドにAutoreleasePoolsも必要です。

以下は、AutoreleasePoolと自動解放オブジェクトの使用方法を示す例です。

このサンプルでは、AutoreleasePoolがallocによって作成されます。つまり、所有権を取得し、手動でリリースする必要があります。

今、私たちはオートリリースプールを持っています。

冒頭で説明したように、コマンドバッファを作成する必要があります。

アロクやクリエイトで作成されていないので、あなたはそれを所有していません。

代わりに、それはメタルによって作成された自動リリースされたオブジェクトです。

このコマンドバッファはAutoreleasePoolに入れられます。

割り当てを解除するのはAutoreleasePoolの責任です。

AutoreleasePoolをリリースするまで、好きなように使用できます。

次に、RenderPassDescriptorを作成する必要があります。

このRenderPassDescriptorは、AutoreleasePoolにも入れられます。

RenderCommandEncoderも同様です。

また、Metalによって作成された自動リリースオブジェクトでもあります。

このcurrentDrawableオブジェクトを忘れないでください。

オートリリースプールにも入れられます。

コードの最後に、pPool->releaseを使用してAutoreleasePoolをリリースします。

割り当てが解除される前に、AutoreleasePoolは所有するすべてのものをリリースします。この場合、CommandBuffer、RenderPassDescriptor、RenderCommandEncoder、およびcurrentDrawableをリリースします。

その後、AutoreleasePoolがリリースされます。

これまでのところ、Cocoaの慣習、自動リリースオブジェクト、AutoreleasePoolsを知ることができました。

メモリリークやゾンビオブジェクトを避けるために、オブジェクトのライフサイクルを正しく管理することが重要であり、これらの問題を回避およびデバッグするのに役立つ優れたツールがあります。

NS::SharedPtrとNSZombieの2つのユーティリティに焦点を当てます。

NS::SharedPtrは、オブジェクトのライフサイクルを管理するのに役立つ新しいユーティリティです。

metal-cppフォルダのFoundationフレームワークの下にあります。

Std:shared_ptrとまったく同じではないことに注意してください。

したがって、C ++標準ライブラリへの依存はなく、参照数を格納するための追加費用もありません。

NS::SharedPtrはこんな感じです。

転送と保持機能は、オブジェクトを消費する意図を明確に表現します。

転送は、ポワン先のreferenceCountを増やすことなくSharedPtrを作成し、SharedPtrに所有権を効果的に譲渡します。

保持関数は、渡されたオブジェクトに保持を送信します。

この機能を使用して、AutoreleasePoolsにあるオブジェクトを生き続け、ポインタの所有者がポワン先のライフサイクルに既得権益を持っていることを表現します。

期待どおりに、getとオペレーター->を介して、基礎となるオブジェクトにアクセスできます。

SharedPtrのコピー、移動、構築、および割り当ては期待どおりに作業し、コピーはretainCountを増やします。

移動は速く、一般的なケースでは保持数には影響しません。

SharedPtrsは常に破壊時にポワンティーに正確に1つのリリースを送信します。

必要に応じて、detach関数を呼び出すことでこれを回避できます。

トップに戻ると、ポインタを転送または保持してポインタを作成することの違いを知ることが重要です。

したがって、TransferPtrの場合、参照カウントが1のMRRオブジェクトを持っているとします。

TransferPtr関数に渡すと、SharedPtrはオブジェクトの所有権を取りますが、そのretainCountは変更されません。

ポインタがスコープ外になると、SharedPtrのデストラクタが実行され、MRRオブジェクトでreleaseを呼び出し、retainCountが0に減少します。

もう1つの機能はNS::RetainPtrです。

後で使用したいため、オブジェクトの割り当て解除を避けたい場合は、NS::RetainPtrを使用する必要があります。

このMRRオブジェクトがあるとします。retainCountは1つです。

RetainPtr関数に渡すと、retainCountが1つ増加します。

スコープを使い果たした後、このRetainPtrはこのMRRオブジェクトのリリースを呼び出します。

したがって、retainCountは1つです。

一般的に、NS::TransferPtrはあなたのためにオブジェクトの所有権を取ります。

しかし、NS::RetainPtrは、割り当てを解除したくないときにオブジェクトを保持するのに役立ちます。

これら2つの関数にオブジェクトを渡すと、NS::TransferPtrは参照数を変更しませんが、NS::RetainPtrは、内部で保持を呼び出すため、参照数を1つ増加させます。

これら2つの関数のデストラクタは、渡されたオブジェクトのリリースを呼び出すため、参照数は1つ減少します。

参照数がゼロになると、オブジェクトは実行時に解放されます。

NS::TransferPtrの例を次に示します。

単一の三角形を描いたレンダリングパスについて話すとき、このレンダリングパイプラインの状態が必要でした。

レンダリングパイプライン状態オブジェクトを作成するための呼び出しを次に示します。

これらは、レンダリングパイプライン記述子が必要とする属性です。

Cocoaの慣習によると、これらの呼び出しはnewとallocで始まるので、私はこれらのオブジェクトを所有しています。

だから、私はこれらのオブジェクトのリリースを呼び出す必要があります。

NS::SharedPtrでは、NS::SharedPtrsがこれらのオブジェクトの所有権を取得するため、これらのMRRオブジェクトのリリースを呼び出す必要はありません。

そこで、ここでは、TransferPtr関数に生のポインタを渡します。

その後、前のスライドのようにリリースを呼び出す必要はありません。 前のスライドのように。

ARCに精通している場合は、NS::SharedPtrで使用されるMRRがARCの使用に似ていることがわかります。

メモリを手動で処理すると、use-after-freeのバグに遭遇する可能性があります。

これらは、すでにリリースされたオブジェクトを使用しようとしているときに発生します。

NSZombieは、これらのバグをチェックする良い方法です。

Use-after-freeのバグが発生すると、ブレークポイントをトリガーし、スタックトレースを提供します。

環境変数を使用すると、ゾンビを非常に簡単に有効にできます。

NSZombieEnabledをYESに設定するだけです。

または、Xcodeを使用している場合は、スキームでゾンビを有効にすることができます。

これがその仕組みです。

同じレンダリングパイプライン設定で新しいレンダリングパイプライン状態オブジェクトを作成したいです。

したがって、この新しいRenderPipelineState関数では、pDescオブジェクトを再利用します。

実行をクリックすると、Xcodeはブレークポイントをトリガーし、スタックトレースを表示します。

それは私が何か間違っていたことを意味します。

うーん、何が問題なの？

NSZombieがここで助けてくれるかもしれないので、私はスキームでNSZombieを有効にします。

プログラムを再度実行すると、NSZombieはブレークポイントをトリガーします。

コンソール出力に何か新しいものが入りました：「割り当て解除されたインスタンスに送信されたメッセージ」。

ああ、私はすでにリリースしたオブジェクトを再利用しました。

そして、それはレンダリングパイプライン記述子です。

そのため、リリースを呼び出す前に、このレンダリングパイプライン記述子を使用する必要があります。

そうすることで、私は問題を解決します。

より多くのツールと詳細は、今年の講演「ゲームのメモリのプロフィレと最適化」で取り上げられています。

たとえば、機器の割り当てでretainCountを追跡する方法を学ぶことができます。

Appleプラットフォームの他のツールを自由にチェックしてください。

彼らがあなたのゲームをデバッグし、パフォーマンスを向上させるのに役立つことがわかります。

これで、metal-cppでオブジェクトのライフサイクルを管理する方法がわかりました。

しかし、ゲームコントローラーやオーディオなどの他のフレームワークとインターフェースする必要があるかもしれません。

これらはまだObjective-Cにあります。

これらのAPIとどのようにインターフェースし、エレガントなアプリケーションアーキテクチャを設計できますか?

Objective-CでViewControllerを書いたが、metal-cppでC++でレンダラーを書いたとします。

ViewControllerからdrawのようなレンダラーメソッドを呼び出す必要があります。

ここでの課題は、2つの言語をうまく分離し、それらを連携させることです。

解決策は、Objective-CファイルからC++を呼び出すアダプタークラスを作成することです。

これにより、機能を実装するファイルでObjective-CまたはC++に集中できます。

たとえば、Objective-CでRendererAdapterクラスを作成できます。

そして、実装では、ViewControllerから直接呼び出すことができるように、Objective-Cメソッドを追加します。

インターフェイス内で、レンダラーオブジェクトへのC++ポインタを宣言します。

メソッドの本体の中で、レンダラーのC++メソッドを直接呼び出します。

このメソッドは、MTK::ViewをC ++オブジェクトとしてdrawメソッドに渡す必要があるため、__bridgeキーワードを使用してビューをC++タイプとしてキャストします。

このキャストについては後で詳しく話します。

対照的に、C++で書かれたRendererでObjective-Cで書かれたMTKViewを呼び出す必要があります。

それも挑戦的です。

同様に、解決策はアダプタークラスを作成することです。

このクラスでは、C++ファイルでは、C++インターフェイスを使用してObjective-Cメソッドを呼び出すことができます。

たとえば、ViewAdapterクラスを作成できます。

私はC++でインターフェイスを書くので、Rendererクラスでは、これらのC++ビューメソッドを簡単に呼び出すことができます。

実装中は、currentDrawableやdepthStencilTextureなど、MTKViewからObjective-Cメソッドを呼び出します。

ここには__bridgeのキーワードがあることに気付くかもしれません。

私はそれらを使用して、metal-cppオブジェクトとObjective-Cオブジェクトの間でキャストします。

最初に学んだように、metal-cppオブジェクトは手動で保持および解放されますが、Objective-Cによって作成されたオブジェクトは自動参照カウントを使用します。

オブジェクトをMRRからARCに、ARCからMRRに移動する必要があります。

Objective-CとC++の間でキャストするのに役立つ3種類のブリッジキャスティングを次に示します。

彼らはまた、あなたが所有権を譲渡するのを助けることができます_Objective-Cとmetal-cppオブジェクトの間で鋳造キャストをブリッジします。

両者の間に所有権の移転はありません。

__Bridge_retained castingは、Objective-Cポインタをmetal-cppポインタにキャストし、ARCから所有権を取ります。

__Bridge_transfer castingは、metal-cppポインタをObjective-Cに移動し、所有権をARCに譲渡します。

問題に戻ると、metal-cppオブジェクトとObjective-Cオブジェクトの間でキャストする必要があります。

所有権の譲渡がない場合は、__bridge castを使用できます。

metal-cppからObjective-Cオブジェクトにキャストし、所有権をObjective-Cに譲渡する場合は、__bridge_transfer castを使用する必要があります。

Objective-Cからmetal-cppオブジェクトにキャストし、ARCから所有権を取得したい場合は、__bridge_retained castを使用する必要があります。

これは、資産の読み込みコードを活用するためにMetalKitを使用しなければならないケースです。

つまり、私のC++アプリケーションでは、metal-cppオブジェクトとしてテクスチャが必要ですが、Objective-Cメソッドによって作成されます。

手動でリリースできるように、ARCから所有権を譲渡する能力が必要です。

そして、この場合、私は__bridge_retainedキャストを選ぶ必要があります。

カタログからテクスチャをロードするこのC++関数があり、metal-cppテクスチャを返したいです。

しかし、内部では、MetalKitでいくつかのObjective-C関数を呼んでいます。

テクスチャローダーに必要なオプションを定義する必要があります。

次に、MetalKitからObjective-Cメソッドを呼び出してテクスチャローダーを作成します。

そのローダーを使用すると、テクスチャオブジェクトを作成し、カタログからテクスチャを読み込むことができます。

この方法は、MetalKitのObjective-C方法でもあります。

今、私はObjective-Cタイプのテクスチャを持っているので、それをmetal-cppオブジェクトにキャストしてARCから取り出す必要があります。

これらのステップを念頭に置いて、コード化する時が来ました。キャスティングが実際にどのように機能するかをお見せします。

最初のステップは、テクスチャローダーが必要とするテクスチャローダーのオプションを定義することです。

metal-cppタイプがそれらを同じ値に定義するので、metal-cppストレージモードと使用法をObjective-Cタイプに安全にキャストできます。

ここでは、テクスチャローダーを作成します。

私はmetal-cppオブジェクトであるデバイスを持っており、それをinitWithDeviceメソッドに渡す必要があります。

metal-cppオブジェクトはObjective-Cオブジェクトなので、フリーダイヤルオブジェクトのようにキャストできます。

所有権の譲渡はありません。

今、私はテクスチャローダーオプションとテクスチャローダーを使用してテクスチャを作成します。

そして、ロードされたテクスチャをmetal-cppオブジェクトとして返したい。

そのため、ARCから取り出して、対応するポインタタイプにキャストする必要があります。

これは__bridge_retainedキャストで行われます。

この後、このテクスチャを任意のmetal-cppオブジェクトとして使用できます。

私はそれを解放する責任があります。

このセクションでは、プログラムで2つの異なる言語を処理するのに役立つアダプターパターンを提供しました。

また、3種類のキャストでObjective-CとC++とインターフェースする方法も示しました。

要約すると、metal-cppは軽量で非常に効率的なMetal C++ラッパーです。

metal-cppを使用する際のオブジェクトライフサイクルの管理方法、Objective-Cとのエレガントなインターフェース方法、開発者ツールがデバッグにどのように役立つかについて話しました。

Metal-cppをダウンロードして、今すぐすべての素晴らしいサンプルで遊ぼう!

メタルで作れるものを見てください。

C++アプリケーションがすべてのAppleプラットフォームで実行されるのを楽しみにしています。

見てくれてありがとう!

♪