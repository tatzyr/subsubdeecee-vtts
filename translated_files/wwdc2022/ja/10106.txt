10106

♪ ♪

プロフィールへようこそ、ゲームのメモリを最適化してください。

私はアップルのGPUソフトウェアチームのジャック・シュー(许)です。

同僚のセス・ル(陆)が加わります。

ここ数年、私たちのチームはあなたのようなゲーム開発者と協力して、一緒にゲームメモリを理解し、改善してきました。

今日、私たちは学習を共有したいので、ゲームのメモリをデバッグし、最高のプレイヤー体験で素晴らしいゲームを作成するときに、有利なスタートを切ることもできます。

CPUオブジェクトとGPUオブジェクトの両方から、ゲームのメモリ使用量を分解します。

さらに、ゲーム内の割り当て、物理メモリでの実際の使用、およびオブジェクト間の参照を分析します。

記憶には多くの側面があるため、当社の開発者ツールはまた、さまざまな角度から記憶の謎を明らかにします。

ガイド付きツアーに参加し、Xcode、Instruments、ターミナルのコマンドラインツールなど、それらすべての使用方法を体験します。

今日のガイド付きツアーでは、ゲームの記憶を理解するための前奏曲から始めます。

そして、メモリとメモリの成長をプロファイリングし始め、セスがインストゥルメントについて教えてくれます。

Instrumentsで時間的アプローチを取った後、私たちは旅を進め、Xcodeとターミナルのツールを使用してゲームのメモリグラフを分析します。

これらのワークフローは、メモリ使用の現在の状態と、ゲーム全体のメモリの内訳に焦点を当てています。

最後に、セスは、メタルデバッガを使用してメタルリソースを最適化する方法を共有します。メタルリソースは、ややスタンドアロンでありながら、ゲームメモリのコア領域です。

では、ゲームのメモリの理解から始めましょう。

Modern Rendering with Metalのサンプルコードなど、Xcodeからゲームを起動すると、Xcodeのデバッグナビゲーターでこのメモリレポートを開くことができます。

これは、ゲームの現在および最近のメモリ使用量、およびシステムへの影響レベルに関する最初の見解です。

ゲージの数字は、ゲームの現在のメモリ使用量を示しています。

メモリデバッグの重要な最初のステップは、この数字が何を意味するのかを理解することです。

1行にまとめると、ゲームでの実際のメモリ使用量は割り当てと同じではありません。

実際のメモリ使用量は物理メモリにあります。

割り当てはゲームによって要求されるメモリですが、仮想メモリアドレス空間にあります。

そして、さまざまな種類の割り当ては自然に別々に計算されます。

ゲームがメモリを割り当てるとき、これらの新しい割り当てはすぐにも、直接物理的なメモリのスペースを占有することはありません。

それどころか、システムが各プロセスに提供する仮想メモリアドレス空間にいくつかのスペースを予約します。

そして、プログラムが後で実際にこの割り当てを使用する場合、システムは物理メモリのスペースを準備します。

同じ種類の割り当てはカテゴリにグループ化され、仮想アドレス空間をまばらに占有します。

これらのカテゴリには、プログラムの実行可能バイナリ、すべてのライブラリとフレームワーク、ローカル変数と一時変数といくつかの関数引数のストレージを提供するスタック、ヒープとも呼ばれる動的メモリ領域、プログラムが手動で割り当てるクラスインスタンスストレージとメモリを含む、ゲームアセットファイルなどの読み取り専用リソースからマッピングされた領域、そしてもちろん、バッファ、テクスチャ、パイプライン状態オブジェクトなどのゲーム内のメタルオブジェクトが含まれます。

そして、これらのカテゴリは地域で構成されています。

ボンネットの下では、メモリ操作は、最新のAppleデバイスでそれぞれ16キビバイトのメモリページの粒度で機能します。

これは、各地域が1つ以上のページを占有し、少なくとも16キビバイトの大きさであることを意味します。

ゲームが続くにつれて、メモリの状態は進化し続けます。新しいオブジェクトが割り当てられ、古いアイテムが破壊され、領域は変化し続けます。

しかし、地域で使用されているページのみが物理メモリ上にあり、システムは他のアプリと同様に、あなたのゲームに熱心に請求します。

ゲームのメモリページは、ダーティ、圧縮、クリーンの3種類のうちの1つです。

それらが何であるかを確認しましょう。

ダーティメモリページには、ゲームが書いたメモリが含まれています。

これには、ゲームがこれらの変数やシンボルを変更すると、ヒープでのメモリ割り当てとフレームワークが含まれます。

Appleシリコンを搭載したデバイスでは、アクセスされた金属リソースもこのカテゴリに分類されます。これは、CPUとGPUが同じ高速ユニファイドメモリのプールを共有しているためです。

ただし、一部のダーティページが長期間使用されていない場合、システムはこれらのページを圧縮するか、スワップと呼ばれるフラッシュまたはディスクに保存することで、物理メモリ上の存在を減らす可能性があります。

これにより、デバイスはより多くのアプリやサービスを実行できるようになります。

後で、ゲームが再びこれらのページを要求すると、システムはディスクから解凍またはページを読み込みます。

なお、あなたのゲームは圧縮されていないサイズに対して引き続き課金されます。

クリーンなメモリページの場合、テクスチャやオーディオアセットなど、ディスクからマッピングされた読み取り専用ファイルと、プロセスにロードされたフレームワークが含まれます。

システムはいつでもディスクから空にしたりリロードしたりできるため、ゲームのメモリフットプリントにはカウントされません。

しかし、それらはメモリに常駐している可能性があり、過度に使用するとシステムとゲームが遅くなります。

通常、メモリフットプリントと呼ばれる最初の2つの部分を見るのが最も興味深いです。

そして、システムはこれを使用してメモリ制限を強制します。

いくつかの用語では、汚いはクリーンの反対であるため、人々はメモリフットプリントを意味するときに「ダーティメモリ」と言います。

しかし、心配しないでください、物事が曖昧になったとき、私たちはどちらを意味するかを呼び出します。

だから今、あなたはメモリがどのように機能し、システムがそれをゲームにどのように充電するかを知っています。

このXcodeメモリゲージのほかに、Macのアクティビティモニターアプリなど、システム上の多くの場所でメモリフットプリントを見つけることができます。

また、一部のAppleプラットフォームでは、アプリのメモリ制限に使用しています。

あなたのゲームは、メモリの使用を導くためにこのメトリックを使用することもできます。

現在のフットプリントと利用可能なメモリを照会するための便利なAPIがあります。

簡単に見てみましょう。

iOS、iPadOS、またはtvOSゲームで利用可能なシステムメモリを取得するには、os/proc.hヘッダーファイルにあるos_proc_available_memoryを呼び出します。

また、Appleプラットフォームのメモリフットプリントについては、現時点でバージョン6である「get pid」、「rusage_info_current」、およびデータストアからのプロセスIDを使用して、proc_pid_rusageを介して取得できます。

そして、その物理フットプリントまたはライフタイム最大物理フットプリントプロパティを取得します。

要約すると、この最初のセクションでは、メモリに関するいくつかの概念を復習しました。

ゲーム内の割り当ては仮想メモリアドレス空間で行われ、ゲームによってアクセスされると、16キビバイトページとして物理的なメモリスペースを占有します。

メモリフットプリントは、ゲームの実際のメモリ使用量を決定するためのAppleプラットフォームの主要かつ普遍的な指標です。

メモリフットプリントには、汚れたページ、圧縮されたページ、交換されたページが含まれています。

Appleシリコン上のCPUとGPUの両方のオブジェクトが含まれています。

そして、それはメモリ制限の適用に使用されます。

あなたのゲームは、そのフットプリントと利用可能なメモリを取得するためにシステムAPIを呼び出すことができます。

記憶が舞台裏でどのように機能するかがわかったので、それがあなたのゲームでどのように見えるかを調べてみましょう。

もっと話すために、セスに渡しましょう。

セス・ルー:ありがとう、ジャック。

では、ゲームのメモリの成長を捉えることから始めましょう。

そして、私はモダンレンダラーのサンプルプロジェクトを使い続けます。

Xcodeからゲームを実行すると、メモリゲージは時間の経過とともにメモリフットプリントを表示します。

ただし、Instrumentsでゲームをプロファイリングすることで、メモリ使用量をより詳細に見ることができます。

多くの場合、ゲームは起動時に多くのメモリを割り当てることができるため、既存の実行に添付するのではなく、新しいゲームの起動からプロファイリングを開始することをお勧めします。

Xcodeから、ゲームのプロファイリングをすばやく開始するには、実行ボタンを長押しし、「プロフィール」を選択します。

これにより、自動的にインスツルメンツに移動します。

インスツルメンツアプリには、システムのさまざまな側面を記録し、記録されたデータをタイムラインに視覚化するプロファイリングツールのコレクションが含まれています。

今年の新しいのは、メタルゲームのメモリの成長をよりよく理解するのに役立つゲームメモリテンプレートです。

このテンプレートには、履歴でメモリ割り当てを記録するための割り当てとメタルリソースイベント機器、メモリフットプリントを記録するためのVMトラッカー、仮想メモリアクティビティを記録するための仮想メモリトレース、メタル関連のイベントを記録するためのメタルアプリケーションとGPUが付属しています。

そして、このデモでは、割り当て、金属資源イベント、VMトラッカーの最初の3つの機器を強調します。

しかし、まず、ゲームの痕跡を記録しましょう。

ここで録音ボタンを押すと、録音を開始できます。

そして後で、録音を停止するには、同じボタンを押すか、単にゲームを終了することができます。

インストゥルメントがモダンレンダラーを録音している間、トレースを記録する別の方法をお見せしましょう。

Xctraceコマンドを使用すると、録画をプログラムで実行でき、自動化ワークフローに役立ちます。

さらに、デバイス名を指定して、ターゲットとしてiPhone、iPad、またはApple TVを選択できます。

インスツルメントのトレースをキャプチャしたので、まず割り当てを見てみましょう。

割り当て機器は、メモリ割り当て、そのサイズ、およびオブジェクト参照数の詳細なビューを提供します。

ただし、民間の金属資源は含まれていません。

統計ビューには、すべてのヒープ割り当てと匿名VMが表示されます。

すべてのヒープ割り当てには、オブジェクトを含む可能性のあるmalloc'edバッファが含まれており、すべての匿名VMには、汚れている可能性のある興味深いVM領域が含まれています。

そして、すぐにいくつかの金属資源がこのカテゴリに属していることがわかります。

では、すべてのヒープ割り当ての内部を見てみましょう。

通常、より大きな割り当ては最適化にとってより興味深いものです。

単一の最大の割り当てを見つけるには、サイズテーブル列をクリックして、割り当てをサイズで並べ替えることができます。

割り当てについては、この矢印をクリックすると、SwiftおよびObjective-Cオブジェクトの参照数の変更を確認できます。

そして、この大きな割り当てがリストで選択されると、インスペクタに割り当て履歴のスタックトレースがあります。

ボタンをクリックすると、システムライブラリやフレームワークを非表示にすることができます。

そしてここで、スタックトレースによると、割り当てはModern Rendererがアセットをロードしたときに起こりました。

フレームをダブルクリックすると、ソースコードにもアクセスできます。

では、戻って「すべての匿名VM」カテゴリを見てみましょう。

メタルゲームでは、IOacceleratorとIOSurfaceのカテゴリで多くの割り当てを見つけることができます。

IOAcceleratorの割り当ては、金属資源に対応しています。

スタックトレースから、この割り当てがアセットのロード中に発生したことがわかります。

IOSurfaceの割り当てはドローアブルに対応します。

そしてここで、スタックトレースは、描画可能を要求したMetalKitビューを示しています。

割り当て機器は、デフォルトでは、割り当てサイズを視覚化します。

しかし、それはまた、別のルックスが付属しています。

割り当てトラックの矢印ボタンで、表示モードをカスタマイズして、割り当て密度を視覚化できます。

これにより、グラフが更新され、時間の経過とともに実行された割り当ての量が表示され、メモリ割り当てのスパイクが明らかになります。

これらのスパイクは、記憶の成長の原因である可能性があります。

したがって、割り当てに表示されるデータはかなり低レベルです。

割り当てられた金属資源をよりよく理解するために、金属資源イベントに移りましょう。

メタルリソースイベント機器は、メタルリソースを中心に設計されています。

リソースイベントビューでは、金属資源の割り当てと割り当て解除の履歴を見つけることができます。

ここでは、Metal APIを通じてプログラムで指定できるラベルでMetalリソースを識別することもできます。

また、割り当てツールと同様に、インスペクタで割り当て履歴のスタックトレースを見つけることができます。

この機器は、Metalデバイスの下にAllocationとDeallocationsトラックも追加します。

それらはイベントの密度を視覚化するのに役立ちます。

これまでのところ、割り当てと金属リソースイベントは、メモリ割り当てを理解するのに役立ちます。

ただし、割り当ては必ずしもメモリフットプリントに変換されるとは限りません。

それでは、VMトラッカーに移り、実際のメモリ使用量を調査してみましょう。

VM Trackerインストゥルメントは、非圧縮されたダーティおよび圧縮またはスワップされたメモリを表示します。

ダーティサイズは、圧縮されていないダーティメモリを表します。

そして、スワップされたサイズは、圧縮またはスワップされたメモリを表します。

この録音では、モダンレンダラーからの圧縮またはスワップされたメモリの使用はありません。

詳細なサマリービューには、VMリージョンが表示されます。

また、「マップされたファイル」領域には、ゲームアセットのようなメモリマップされたリソースが見つかる場合があります。

ここでは、Modern Rendererはビストロアセットファイルをメモリにマッピングします。

これは、インスツルメントの割り当て、金属資源イベント、VMトラッカーの簡単な概要です。

メモリの成長をプロファイリングする方法を簡単に要約するには、まず、ゲームメモリテンプレートを選択し、次にトレースを記録して分析します。

メモリの成長パターンを再現または検証するときに、このプロセスを数回繰り返すことがあります。

新しいゲームメモリテンプレートが、ゲームのメモリ割り当てやフットプリントの成長をよりよく理解するのに役立つことを願っています。

また、インスツルメントの使用の詳細については、これらの他のビデオをチェックしてください。

さて、ジャックに戻ります。

ゲームのメモリテンプレートは本当にクールに見え、時間の経過に伴うメモリ使用の変化を理解するのに非常に役立ちます。

さらに、特定の時間にゲームのメモリ状態をキャプチャしたいので、そのメモリ状態を深く掘り下げ、さまざまなレンズで調べることもできます。

そのために、メモリグラフと一連のツールがあります。

メモリグラフは、オブジェクトの作成履歴、参照、圧縮やスワップなど、ゲームのメモリ状態の完全なスナップショットを効率的に保存するためのファイルです。

問題が発生したときや、比較のために問題が発生した前後に、それらのペアなど、いつでもスナップショットを撮ることができます。

物事を盛り上げるために、メモリグラフでメモリを分析する方法についての料理本のアナロジーを使用しましょう。

成分と準備部分が含まれています。

成分については、ゲームが必要です。マロックスタックロギングと呼ばれるもの。そして、キャプチャされたメモリグラフ。

Malloc Stack Loggingをすばやく設定し、メモリグラフをキャプチャします。

Malloc Stack Loggingは、ゲームプロセスで割り当て情報を記録します。

スキームの設定で見つけることができます。

[実行] アクションを選択し、[診断] に移動し、[Malloc Stack Logging] チェックボックスをオンにします。

2つのオプションが何であるか疑問に思う場合、すべての割り当てと無料履歴は、割り当てが解除された後でもすべてのオブジェクトを追跡します。

ロギングデータはより多くのメモリを消費する可能性がありますが、フラグメンテーションなどの問題のデバッグに役立ちます。

一方、Live Allocation Onlyは、その履歴から割り当てを解除されたオブジェクトを破棄するので、より軽いです。

この場合、私はライブオブジェクト上の参照のみを調査しているので、このオプションを選ぶことができます。

実際、ほとんどの場合、ライブ割り当てのみが推奨されるオプションです。

または、Xcodeから起動しない場合は、環境変数を設定することもできます。

追加の録音モードについては、mallocのマニュアルページをチェックしてください。

その後、メモリグラフも準備します。

デバッグ領域のデバッグメモリグラフボタンをクリックするだけです。

Xcodeはメモリスナップショットを撮り、それを処理し、メモリデバッガを入力します。

Xcodeメモリデバッガは、ゲームのメモリ使用に関する直感的な視点を提供します。

少し時間を取って景色を探りましょう。

左側のDebug Navigatorは、オブジェクトインスタンスの階層リストを提供します。

右側のファイルインスペクタは、メモリフットプリント、稼働時間、キャプチャ日などの有用な情報を提供します。

中央の領域には、左から選択したオブジェクトがあるメモリグラフビューと、参照がこのオブジェクトにどのように接続されているかが輝いています。

すぐにこのグラフに戻ります。 

また、ファイルメニューには、将来の分析のためにこのメモリグラフを保存したり、チームと簡単に共有したりできます。

Macゲームでは、プロセスIDまたは名前を使用して、リークコマンドラインプログラムでメモリグラフをキャプチャすることもできます。

つまり、安全なシェルでリモートで実行できるので、ゲームがフルスクリーンで実行され、ピントを合わせる必要がある場合に備えて、カーソルはゲーム内にとどまります。

だから、それはあなたがメモリグラフ分析を開始するために必要なものです。

今度は、Xcodeメモリデバッガとターミナルの汎用性の高いコマンドラインツールを使用して、このメモリグラフを調べて、割り当て、フットプリントなどを調べる時です。

良い最初のステップは、カテゴリ別にメモリの使用を分解することです。

フットプリントプログラムはまさにそれを行います。

フットプリントは、メモリグラフの情報を使用して、この高レベルの要約を再作成します。

通常、まずより大きなカテゴリに焦点を当てたいと思うでしょう。

モダンレンダリングのサンプルコードからこのようなゲームメモリグラフの場合、IOacceleratorは通常最大のものです。

セスが言ったように、それには金属資源が含まれています。

ここでは、システムがパフォーマンスを向上させるためにサイズプールにヒープ割り当てをグループ化するため、ヒープ割り当てはいくつかのMALLOC_(接頭辞)カテゴリに移動します。

これらのオブジェクトは、ゲームが効果音や物理シミュレーションを行うサードパーティのプラグインやライブラリなど、多くの場所から来る可能性があります。

これは、William "Cheer" Studioによって作成された素晴らしいApple Arcadeゲーム、Manifold Gardenのメモリグラフです。

ゲームのメモリ使用量を見せてもらえてうれしいです。

ゲームがUnityを使用したマニホールドガーデンなどのゲームエンジン、またはメモリマップの上にあるカスタムアロケータを使用している場合、そのメモリはこのようにタグなしVM_ALLOCATEとして表示されます。

ここにプロのヒントがあります：Appleプラットフォームでは、ゲームは最大16のアプリ固有のタグを使用できるため、メモリ使用量を掘り下げるときにより明確にすることができます。

それは1行の変更と同じくらい簡単です。

まず、16のオプションの1つからタグを作ります。

次に、「em map」を呼び出すときに、マイナス1を「ファイル記述子」としてこの新しいタグに置き換えます。

タグとカテゴリの定義方法については、「em map」のマニュアルページをご覧ください。

「Mach VM allocate」を使用する場合は、割り当て時にフラグ引数に同じフラグを含めます。

フットプリントプログラムの世界では、ダーティサイズにはスワップと圧縮も含まれているので、各カテゴリの合計請求額と考えてください。

これは、現在のメモリ使用の構成と、それがフットプリントをどのように構成するかについての簡単なアイデアです。

このメモリの一部は使用が少なく、圧縮またはスワップされます。

それらは記憶の節約の源かもしれません。

次のステップは、ゲームが使用する圧縮または交換されたメモリの量を調べ、最適化することです。

このため、vmmapでメモリグラフを実行できます。

それは、2つの組み合わせではなく、汚れて交換されたサイズを提供します。

このダーティ列には、現在スワップまたは圧縮されていない通常のダーティメモリが含まれていますが、スワップされた列には、圧縮またはスワップされたメモリの元のサイズが含まれています。

システムは、フットプリントを決定するために、これら2つの列を一緒に追加します。

しかし、交換されたサイズの列のコンテンツはそれほど頻繁に使用されないため、ゲームのメモリを最適化するために何を探すべきかの良い指標です。

ああ、ところで、これが割り当てサイズで、仮想サイズの列があります。

また、レジデントサイズには、実行可能ファイルやメモリマップファイルなどのクリーンなページが含まれます。

便利なことに、vmmapは別のテーブルでヒープ割り当てを表示します。

出力の下部では、vmmapはヒープメモリをゾーンごとにグループ化します。

これらのゾーンは、ゲームの使用状況やライフサイクルを反映しています。

MallocStackLoggingをオンにしたので、ヒープの割り当てはツールのゾーンにあります。

それ以外の場合は、割り当てサイズに基づいて、MallocHelperZoneとDefaultMallocZoneの2つのデフォルトゾーンになります。

また、通常、QuartzCoreゾーンなどの小さなシステムユーティリティゾーンをスキップできます。

また、数十または数百メガバイトのような高い断片化サイズまたはパーセンテージによって示される断片化が疑われる場合、WWDC 2021セッションは断片化の問題について詳しく取り上げます。

また、ダッシュダッシュサマリーなしでvmmapを実行するか、標準モードでvmmapを使用するには、これらのカテゴリ内の各vm領域を1行ずつ表示します。

先ほど説明したように、仮想アドレス空間がどのように見えるかと同じように。

したがって、vmmapを使用すると、アクティブに使用されているものから、使用されていないダーティメモリを抽出できます。

そして、通常、さまざまなサイズの動的割り当て、またはゲーム内のmalloc'dヒープメモリ使用量もかなりの量があります。

彼らには特別な外観が必要です。

ヒープツールは、malloc'dリソースをクラスごとにグループ化し、インスタンス数でソートします。

これらのクラスは、VTable、Objective-C、またはSwiftを使用してC++で決定されます。

メタデータに関するヘッダーをスキップするために、-quiet引数を使用しています。

今年は新しい、ヒープはオブジェクトタイプを識別するのがよりインテリジェントです。

Malloc Stack Loggingによって記録された情報を使用して、発信者または責任あるライブラリを提示するため、巨大な非オブジェクトは過去のものです。

そして、これは再びマニホールドガーデンからのメモリグラフです。

この例では、FMOD StudioなどのプラグインやGameAssembly.dylibなどのゲームコンポーネントがどれだけのヒープ使用量を消費しているかが初めて明らかになりました。

だから今、あなたはメモリがどのように広がっているかについてより多くの情報を得ることができます。

また、これらのオブジェクトに関するより多くの情報を得るためにどの方向に行くべきかを示唆しています。

この例では、開発者はFMOD Studioを開いてゲームのサウンドトラックとサウンドエフェクトを微調整したり、Unityにアクセスしてゲームコードの最適化を探したりできます。

場合によっては、クラスのインスタンス数ではなく、クラスの合計サイズで並べ替える方が便利です。

モダンレンダリングサンプルプロジェクトのメモリグラフでは、トップコントリビューターは2億5800万バイト以上を使用するクラスです。

Modern Renderingサンプルでより大きなオブジェクトを探し続けるには、ヒープを使用して-sortBySizeでクラスの合計サイズでオブジェクトをソートし、各クラスの要約ではなく-showSizesですべてのオブジェクトをリストします。

そして、2億5500万バイトのサイズのバイトストレージにNSConcreteMutableDataの1つのオブジェクトがあります:それは見る価値のあるもののように見えます。

次に、それが何であるかを知りたいです。

そして、私は最初にその住所を知りたいです。

アドレスを追加し、パターンNSConcreteMutableDataに続いてワイルドカードドットスターと、括弧内のサイズフィルターを入力して、10メガバイト以上のオブジェクトのみをリストします。

そして、これがオブジェクトのアドレスです。

より詳細な分析のために、次の手順で使用します。

つまり、インスタンスのオブジェクト識別が改善されたヒープツールです。

これまでのところ、どのオブジェクトがゲームでメモリを使用しているかを理解するための3つのツールを見てきましたが、それらはすべて異なるビューを提供します。

私が示したのは、たった1つのワークフローでした。

ゲームで使用される特定のメモリパターンや技術に応じて、ニーズに合った方法で使用できます。

その存在について確信が持てないオブジェクトの発見で、次のステップは、その割り当てコールスタックであるその起源を取得することです。

モダンレンダリングの2億バイトオブジェクトの場合、-callTreeモードを使用し、そのアドレスをmalloc_historyに渡します。

追加の反転引数とともに、割り当てに最も近い関数に集中できます。

そして、出来上がり。

これが割り当てのバックトレースです。

同様に、Xcodeメモリデバッガは、インスペクタでオブジェクトの割り当て履歴も表示します。

オブジェクトを選択し、メモリインスペクタをクリックするだけで、そこにあります。

別の例として、アドレスの代わりにクラスパターンとしてVM_ALLOCATEを渡して、カスタムアロケータのデバッグなど、ゲームやプラグインでの匿名VMの使用状況を確認します。

Xcodeとmalloc_historyのどちらを使用するかにかかわらず、割り当てバックトレースを知り、ラインにブレークポイントを設定するなど、より深く掘り下げるかどうかを判断できます。

最後になりましたが、オブジェクト参照を調査することも役立ちます。

メモリグラフは、さまざまな理由でMallocStackLoggingが有効になっていなくても、常にオブジェクト参照を記録します。

以前にリークを使用して、Xcodeの外でメモリグラフをキャプチャしました。

リークはより多くを行います。

メモリグラフ内のすべての参照をチェックし、それがリークと保持サイクルについて知っている理由です。

Leaksは、トレースツリー引数とヒープからのオブジェクトアドレスを使用して、オブジェクトへの参照ツリーを取得します。

しかし、この例ではかなり大きな木であるため、ターミナルよりも見るにはやや良い方法があります。

Xcode 14では、選択したオブジェクトの送受信エッジと発信エッジの両方を表示するようにメモリグラフビューを再設計しました。

Xcodeに描画するエッジを選択するための新しいネイバー選択ポップオーバーもあります。

これにより、複雑なゲーム状態でオブジェクト参照を理解しようとすると、生産性が大幅に向上します。

少し探索した後、テクスチャマネージャーがこのオブジェクトにアクセスしていると確信しています。

ゲームでは、リークツールとメモリグラフビューを使用して重要なオブジェクト参照関係を見つけ、これらのオブジェクトがゲーム内でどのようにアクセスされるかを学ぶことを検討してください。

そのため、リークまたはXcodeを使用してオブジェクトの重要な参照を表示して見つける方法。

これらのツールの使用の詳細については、リークのマニュアルページとXcodeのヘルプを確認してください。

このメモリグラフ分析クックブックでは、各ステップはいくつかの特定のツールを使用します。

それらはすべて協力して、メモリグラフの分析を完了します。

要約すると、まず、メモリグラフでメモリをキャプチャして分析することを期待するときに、MallocStackLoggingを有効にすることです。

次に、ゲーム用にXcodeでメモリグラフをキャプチャするか、Macゲーム用にリークツールを使用します。

次に、大きくて面倒な物体を見つけます。

フットプリント、vmmap、およびヒープツールは、高レベルと詳細の両方でメモリの内訳を提供します。

Malloc_historyを使用すると、オブジェクトが割り当てられている場所を知ることができ、リークはオブジェクトの使用状況や参照を分析することができます。

これらの以前のセッションには、詳細なウォークスルーと、これらのツールのより多くの使用のデモが含まれています。

今まで、私たちは金属資源の調査を延期してきました。

さて、今がその時です。

もっと詳しく言うと、これがセスです。

またこんにちは!

ゲームでは、金属資源は大きなメモリを使用できます。

しかし、メモリの使用を最適化する方法があります。

ここでは、ゲーム内のメタルリソースを最適化する際に使用できるメモリ節約のリストをまとめました。

メタルデバッガーがリソースの監査にどのように役立つかを見て、ゲームのメモリをさらに削減するための高度なテクニックを学びます。

メタルデバッガーは、メタルゲームをデバッグするためのワンストップショップです。

GPUフレームキャプチャを取得した後、サマリーページを見つけることができます。

これにより、キャプチャされたワークロードに関する一般的な統計情報が得られます。

ページの下半分には、4つのカテゴリに分かれた洞察のリストがあります。

「メモリ」カテゴリのインサイトは、ゲームのメモリの節約を示唆しています。

このトレースに特有のメモリインサイトはあまりありません。これらのインサイトに対処した後、わずか数メガバイトのメモリを節約できます。

しかし、あなたのゲームに特有のより多くのメモリ節約があるかもしれません。

メタルリソースで使用されるメモリの全体像を把握するには、[メモリを表示]ボタンをクリックしてメモリビューアを使用できます。

メモリービューアは、ゲームからキャプチャされたリソースの完全なリストを提供します。

上半分は、フィルタリングのための異なるカテゴリを示しています。

これを使用して、リソース、例えばテクスチャをすばやく検索できます。

そして、下半分では、テーブルはテクスチャのみを表示します。

とりあえずフィルターを取り出しましょう。

リソーステーブルには、ゲームを最適化するのに役立つ列のコレクションがあります。

そして、いくつかの興味深いリソースをすばやく特定するのに役立つかもしれないいくつかの列を強調したいと思います。

インサイト列は、要約ページで見たものと似ています。

この列で表を並べ替えるときに、すべてのリソースを洞察とともにすばやく表示できます。

そして、洞察アイコンをクリックすると、発見を説明し、いくつかの可能なアクションを提供するポップオーバーが表示されます。

この列のすぐ隣に割り当てられたサイズがあります。

この列で並べ替えて、最大のリソースを確認できます。

一部のリソースが実際にメモリサイズをうまく利用している場合は、監査すると便利です。

たとえば、一部のテクスチャはより小さな解像度にサイズ変更され、バッファにロードされた一部のモデルは、ゲームの視覚品質に影響を与えないことを考えると、より低いポリカウントを使用する場合があります。

すぐに言及するテクスチャメモリを保存する別の方法がいくつかあります。

ここでのもう一つの興味深いコラムは、Last Boundからの時間です。

この列でリソースを並べ替えて、最近使用されていないリソースを見つけることができます。

リソースが使用されていない場合は、資産をロードする価値があるかどうかを再確認することをお勧めします。

しばらくバインドされていないリソースについては、将来再び使用されない場合は、リリースを検討するかもしれません。

あるいは、パージ可能な状態を揮発性に設定することもできます。

金属資源は、不揮発性、揮発性、空の3つのパージ可能な状態のいずれかにある可能性があります。

デフォルトでは、リソースは不揮発性です。

パージ可能な状態を揮発性に設定することで、システム内のメモリ圧力が高い場合、金属はメモリからリソースを追い出す可能性があります。

リソースが空になると、システムはゲームのフットプリントに対してそれを充電しなくなります。

ゲームが再びリソースを必要とするときは、コンテンツがまだそこにあるかどうかを確認し、必要に応じてリロードします。

パージ可能な状態があなたに不利にならないように、めったに使用されないリソースにのみ揮発性を使用することを検討してください。

したがって、これらはすべてのリソースの一般的なメモの一部です。

そして今、テクスチャを詳しく見てみましょう。

メモリビューアでは、すべての列がデフォルトで表示されるわけではありません。

テーブルヘッダーを右クリックすると、テクスチャのピクセル形式などの列を表示および非表示にできます。

テクスチャのピクセルフォーマットを最適化することで、さまざまな節約を得ることができます。

ゲーム内の多くのテクスチャは、16ビットの半精度ピクセルフォーマットを使用して、メモリ使用量と帯域幅を削減できます。

単一のアルファ成分を持つテクスチャが必要な場合は、複数のカラーチャンネルを避けることができます。

そして最後に、いくつかの読み取り専用テクスチャは、より低いメモリ使用のためのブロック圧縮の恩恵を受けるかもしれません。

ブロック圧縮ピクセルフォーマットには、ASTCやBCなどのオプションがあります。

さらに、A15 Bionic以降、テクスチャに非可逆圧縮を使用し、ターゲットをレンダリングして、可能な限り品質を維持しながらメモリを節約できます。

詳細については、これらの以前のビデオをチェックしてください。

そして、これらは、メモリビューアを使用してすぐに発見できるメモリの節約の一部です。

しかし、ゲームをさらに最適化するために取るかもしれないいくつかの追加のテクニックがあります。

テクスチャがシングルパスでのみ使用される場合、ストレージモードをメモリレスに設定してメモリと帯域幅を節約できます。

メモリーレステクスチャは、深さ、ステンシル、マルチサンプリングテクスチャなどの一時的なレンダリングターゲットにうまく機能します。

それ以外の場合、テクスチャがGPUによってのみ使用されている場合は、ストレージモードをプライベートに設定したり、共有または管理したりできます。

念のため、iPhoneやiPadと同じように、AppleシリコンMacではマネージドモードは必要ありません。

ケースの例を次に示します。

このゲームにはDepth32Float_Stencil8のテクスチャがあります。

深度テクスチャはパス全体で使用されますが、ステンシルテクスチャの内容は破棄され、フレームの後半では使用されません。

そのため、代わりに、ゲームは2つのテクスチャを使用し、ステンシルテクスチャをメモリレスにして、メモリと帯域幅を節約することができます。

最後に、あなたのゲームの記憶を最大限に活用するために、あなたにとって面白いかもしれない別のテクニックについて言及したいと思います。

ゲームが同時に使用しない場合は、ヒープからエイリアスされたリソースを使用できます。

彼らは同じ割り当てでバックアップされたメモリを共有できます。

しかし、これらのリソースへのアクセスを同期するときは特に注意してください。

「Go bindless with Metal 3」トークをチェックして、ヒープから割り当てられたリソースの使用について詳しく知ることができます。

それで、メモリ節約のチェックリストを締めくくります。

そして、このチェックリストがゲームのメタルリソースを監査するのに役立つことを願っています。

ゲームメモリを最適化するためのメタルデバッガーの使用の詳細については、これらの他のWWDCトークをチェックしてください。

そして、あなたに戻って、ジャック。

ありがとう、セス。

今日、私たちはガイド付きツアーに参加し、ゲームのメモリ使用量を理解し、改善するためにできる多くの興味深いことを探求しました。

まず、メモリフットプリントは、ゲームのメモリ使用量を理解するための主要な指標であり、ダーティプラス圧縮およびスワップメモリが含まれます。

その後、強力なメモリデバッグツールを体験しました。

セスは、インスツルメンツが有用なテレメトリトラックでメモリプロファイリングを強化する方法を教えてくれました。

新しいゲームメモリテンプレートは、この仕事のために正確に調整されています。

その後、ゲームのメモリ状態のスナップショットを保存するためにメモリグラフを提示しました。

オブジェクト、参照、および割り当て履歴のメモリグラフを分析するための柔軟で強力なコマンドラインプログラムがあります。

ヒープツールの改善と再設計されたXcodeメモリデバッガは、ゲームメモリ分析を強化します。

最後に、セスはメタルリソースのメモリ節約チェックリストと、メタルデバッガーがゲーム内のメタルリソースの使用に関する質問に答えるのにどのように役立つかを共有しました。

また、他のWWDCセッション、ドキュメント、マニュアルページから詳細を学ぶこともできます。

私たちは常にあなたのために最良かつ最も柔軟なツールを進歩させています。

では、それらを試してみてみませんか?

それらはちょうどあなたが探しているものかもしれません。

そして、フィードバックアシスタントなどのチャネルを通じて、あなたが持っているかもしれないフィードバックを私たちと共有することを躊躇しないでください。

記憶の旅を楽しんでください、そして見てくれてありがとう。♪ ♪