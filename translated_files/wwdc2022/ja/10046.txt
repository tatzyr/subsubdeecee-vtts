10046

♪インストゥルメンタルヒップホップ音楽♪

♪

「宣言型デバイス管理を採用する」セッションへようこそ。

私の名前はサイラス・ダブーで、デバイス管理チームのエンジニアです。

宣言型デバイス管理のエキサイティングな新機能についてお話しします。

WWDC21で、同僚のメリッサは、Appleデバイスを管理するための新しいパラダイムである宣言型デバイス管理を導入し、MDMプロトコル自体を再構想しました。

そのセッションで学んだように、宣言的なデバイス管理は、デバイスが自律的でプロアクティブなものになることを可能にするため、強力です。

デバイスは、独自の状態の変化に反応し、サーバーからプロンプトを表示することなく、管理ロジックを自分自身に適用するため、自律的です。

デバイスはプロアクティブであり、重要な状態の変化が発生したときにステータスチャネルがサーバーに非同期に報告し、サーバーがデバイスをポーリングする必要性を回避します。

宣言型デバイス管理データモデルには、宣言とステータスの2つの重要な要素があります。

宣言には、アクティベーションと述語、構成、資産、および管理タイプが含まれます。

また、ステータスはステータス項目とステータスレポートをカバーしています。

なぜこれが重要なのか、それがあなたにとって何を意味するのか、そしてあなたの製品を使用する組織について話しましょう。

私たちは、新しい複雑な管理戦略をサポートし、管理対象デバイスの全体的なユーザーエクスペリエンスを向上させ、IT管理者の反復的で面倒なタスクを軽減し、デバイスが独自の管理状態でドライバーになることを可能にするために、この技術を作成しました。

デバイス管理ソリューションの開発者として、宣言的なアプローチにより、サーバーは軽量で反応的になります。

また、宣言型データモデルが組織の構造をより密接にマッピングすると、デバイスの変更がより直感的になります。

ステータスレポートは、豊富なフィードバックチャネルを提供します。これにより、サーバーは、ポーリングの実装に使用される複雑な戦略を必要とせずに、デバイスをより綿密に監視し、よりタイムリーで信頼性の高い方法で関連情報を提示できます。

これはすべて、より簡単な開発努力を意味し、最も重要な場所に価値を付加するデバイス管理機能に集中し、顧客が気に入るソリューションを作成することができます。

IT管理者にとって、宣言的なアプローチは、デバイスが期待される状態にあるという自信を高めます。

また、そうでない状況では、サーバーへの接続が失われた場合でも、機密性の高い組織データを保護する安全な状態にあります。

ステータスレポートを介してデバイスからの重要なフィードバックを提供し、ネットワーク帯域幅などのリソースの利用率を減らすことで、管理者の効率も向上します。

組織のユーザーにとって、デバイス管理は、より迅速なオンボーディング、より迅速な回復時間、組織からのより良いサポートにより、より応答性と信頼性の高いエクスペリエンスになります。

これらすべての利点を念頭に置いて、将来のプロトコル機能の焦点は宣言型デバイス管理であり、今日の製品に宣言型デバイス管理を採用することがさらに重要になります。

宣言型デバイス管理の詳細な紹介とそれを採用するために必要な手順については、WWDC21セッションビデオを必ずご覧ください。

このリリースでは、宣言型デバイス管理の範囲の拡大、ステータスレポートの強化、述語の強化の3つの重点分野があります。

宣言型デバイス管理の範囲を拡大することから始めましょう。

宣言型デバイス管理が導入されたとき、ユーザー登録のiOSでのみサポートされていました。

現在、宣言型デバイス管理は、MDMがサポートするすべての登録タイプで利用可能です。監視対象デバイスを含む自動デバイス登録、プロファイルベースの登録、プロファイルとアカウントベースのユーザー登録。

宣言型デバイス管理は、共有iPadでも利用可能になりました。

iOS 16では、ユーザーは設定アプリのMDMプロファイル詳細ビューで設定を見つけることができるようになりました。

設定行をタップすると、アクティブな設定の詳細が表示されます。

また、宣言型デバイス管理は、MDMがサポートするすべてのプラットフォームで利用可能であることを発表できることを嬉しく思います。

macOS Venturaは、macOSでサポートされているすべてのMDM登録タイプについて、宣言型デバイス管理をサポートするようになりました。

tvOS 16は、MDMデバイス登録タイプの宣言型デバイス管理をサポートするようになりました。

OSでサポートされている場合、iOSで利用可能な同じ宣言とステータスのセットは、macOSとtvOSでも利用可能です。

macOSでは、MDMプロファイルの詳細ビューに構成セクションがあり、アクティブな構成が表示されます。

MDMプロファイルの詳細ビューに構成セクションがあるtvOSにも同じことが言えます。

ここで最後に注意すべきことは、macOSと共有iPadデバイスの両方にはそれぞれ2つのMDMチャンネルがあります。

これらはデバイスとユーザーチャネルです。

デバイスチャネルはデバイスレベルの状態の管理を可能にしますが、ユーザーチャネルは特定のユーザーの管理状態をターゲットにしています。

任意のチャネルで宣言型デバイス管理を使用するには、そのチャネルに対して個別に有効にする必要があります。

これは、対応するチャネルでDeclarativeManagementコマンドを送信することを意味します。

また、宣言型デバイス管理ステータスレポートはチャネルごとに個別に生成されるため、個別に監視する必要があります。

次に、2番目の重点分野であるステータスレポートです。

ステータスレポートを簡単に確認しましょう。

デバイスは、サブスクライブされたステータスアイテムのステータスをサーバーに段階的に報告できます。

デバイスは、サーバーからの正常な応答を追跡し、ステータスの更新が信頼性が高く、ネットワークやその他の種類の問題の場合に見逃さないようにします。

ステータスレポートは、デバイスをプロアクティブにします。

サーバーが状態の変化を監視するためにデバイスを継続的にポーリングする必要はありません。

iOS 15では、モデルタイプやオペレーティングシステムのバージョンなど、デバイスプロパティの一連のステータス項目を導入しました。

このリリースでは、パスコードの状態、構成によってインストールされたアカウント、およびMDMインストールされたアプリの3つの領域でステータスを拡大しています。

パスコードのステータスから始めましょう。

iOS 15では、パスコードポリシーの設定を導入しました。

MDMパスコードポリシープロファイルと同様に、適用されるポリシーと、ユーザーが変更したときにパスコードが準拠することとの間にいくつかのラグがある可能性があります。

したがって、MDMサーバーは、パスコードがいつ準拠するかを判断するためにデバイスをポーリングする必要があります。

しかし、新しい宣言型デバイス管理パスコードステータス項目では、それを行う必要はありません。

Passcode.is-compliantとpasscode.is-presentの2つのステータス項目を追加しました。

コンプライアンスは、パスコードがMDMプロファイルまたは構成を介して適用されるすべてのパスコードポリシーに準拠しているかどうかを示します。

これらのステータス項目には、MDMクエリを介して取得できる同等のプロパティを反映するブール値があります。

典型的なサーバーの動作を探りましょう。

多くの場合、組織はデバイスに適用するセキュリティに敏感な状態を持っています。

たとえば、保護されたネットワークへのアクセスを許可するVPNまたはWi-Fiプロファイル。

その状態は、強力なパスコードポリシーが存在し、パスコードがそのポリシーに準拠している場合にのみ、デバイスでアクティブである必要があります。

従来のMDMでは、サーバーはパスコードポリシープロファイルを送信してからデバイスをポーリングし、ユーザーがパスコードを変更したときにパスコードが準拠するのを待つ必要があります。

最初はパスコードが準拠していない可能性が高いため、Wi-Fiプロファイルを送信できません。

最終的に、ユーザーはパスコードを変更してコンプライアンスに適合させます。

サーバーの次のポーリングでは、変更された準拠状態を検出し、Wi-Fiプロファイルを送信しても大丈夫だと判断し、Wi-Fiプロファイルはデバイスにインストールされます。

宣言型デバイス管理は、パスコードコンプライアンス状態によってトリガーされるアクティベーション述語を使用して、サーバーがポーリングする必要がなくなります。

サーバーは、パスコードポリシーとWi-Fiプロファイルの両方を構成として送信し、Wi-Fi構成はパスコードのコンプライアンスに基づいてアクティベーションに関連付けられています。

パスコード設定はすぐに有効になり、強力なパスコードポリシーが適用されます。

当初、パスコードは準拠していない可能性が高いため、アクティベーション述語はfalseと評価され、Wi-Fi設定はアクティブ化されません。

ある時点で、ユーザーはパスコードを更新して準拠します。

これにより、アクティベーションの再評価がトリガーされ、述語がtrueに評価され、Wi-Fi設定がアクティブになります。

これはすべて、サーバーからの介入なしに起こり、実際にはサーバーへの接続がなくても発生する可能性があります。

サーバーは、構成がアクティブになると自動的にデバイスからステータスレポートを取得するため、変更がいつ行われるかがわかっています。

これは、ポーリングの必要性を回避し、より応答性が高く信頼性の高いデバイスの動作を得るために、ビジネスロジックをサーバーからデバイスにうまく移動した方法を示しています。

では、アカウントのステータスに目を向けましょう。

iOS 15では、デバイスにさまざまな種類のアカウントをインストールするためのアカウント構成を導入しました。

これらは通常、組織アカウントであり、ユーザーは組織データにアクセスできます。

管理者は、アカウントがいつ正常にインストールされ、どの状態にあるかを知ることで、問題が発生している可能性のあるユーザーをサポートするのに役立ちます。

このリリースでは、メール、カレンダー、その他のアカウントタイプの8つのアカウントステータス項目が追加されます。

ステータスは、構成によってインストールされたアカウントに対してのみ報告され、手動で作成されたアカウントやMDMプロファイルを介してインストールされたアカウントは含まれません。

各新しいステータス項目はアカウント設定タイプに対応し、受信メールアカウントと送信メールアカウントのステータスは別々に報告されます。

新しいステータス項目は、それぞれ異なるタイプのJSONオブジェクトを使用して、対応するアカウントタイプのステータスを表します。

受信メールのステータス項目と、購読したカレンダーのステータス項目の例を次に示します。

識別子キーの値は、ステータスアイテムオブジェクトの配列内のオブジェクトの一意の識別子です。

宣言識別子キーの値は、アカウントをインストールした構成の識別子プロパティ値と一致し、ステータス項目オブジェクトと関連する構成を簡単に相互参照できます。

これら2つのキーは、すべてのタイプのアカウントステータスアイテムオブジェクトに常に存在します。

他のキーはアカウントの種類に固有のものです。

たとえば、メールサーバーのホスト名とポート、または購読したカレンダーのカレンダーURL。

このリリースでは、同じタイプの1つ以上のアカウントのレポートをサポートするために、値が配列であるステータスアイテムが導入されます。

このような配列値には特別な動作があります。

配列内の各項目は、単一の配列内のすべてのオブジェクトに使用されるのと同じスキーマを持つJSONオブジェクトです。

各オブジェクトタイプには常に識別キーがあり、配列内のオブジェクトを見つけるための主キーとして機能します。

他のキーが存在し、報告されている基礎となるタイプのステータスに結びついています。

将来のOSリリースで追加されたキーとの互換性を確保するために、サーバーは配列オブジェクト内の未知のキーを受け入れる必要があります。

配列値の変更は、パフォーマンス上の理由から、常にオブジェクトごとにサーバーに段階的に報告されます。

この新機能がどのように機能するかを示す例を見てみましょう。

この例では、サーバーは2つのメールアカウント設定をデバイスに送信します。

これらは両方ともアクティブであるため、デバイスに2つのメールアカウントが存在します。

サーバーは、メールアカウントのステータス項目のステータスサブスクリプションを送信するようになりました。

サブスクリプションが有効になると、アカウントのステータスが収集され、デバイスはサーバーにステータスレポートを送信します。

ステータスレポートには、ステータス配列に2つのアカウントステータスオブジェクトが含まれ、サーバーにデバイスに現在存在するものの全体像を提供します。

各配列オブジェクトには異なる識別子があります。

このレポートを処理した後、サーバーは2つのメールアカウントのステータスを持ち、デバイス上にあるものと一致します。

サーバーが新しい構成を送信してデバイスにメールアカウントを追加すると、デバイスのステータスアイテムに新しいオブジェクトが配列値に追加され、別のステータスレポートがサーバーに送信されます。

新しいアイテムのみが報告されます。

識別子キーの値は、サーバーがすでに持っている値と一致しないため、サーバーはこれが新しいアカウントに対応していると推測できます。

このレポートを処理した後、サーバーは3つのメールアカウント、2つの最初のアカウントと新しいアカウントのステータスを持ち、再びデバイス上にあるものと正確に一致します。

ユーザーがメールやメモの有効状態を切り替えるなど、アカウントのステータスが変更されると、デバイス上のステータスアイテムは配列値に更新されたオブジェクトを持ち、再びステータスレポートがサーバーに送信されます。

変更された項目のみが報告されます。

この場合、ユーザーはアカウントのメモ機能をオフにしました。

識別子キーの値は、サーバーがすでに持っているものと一致するため、サーバーはこれが既存のアカウントの更新であると推測できます。

その結果、既存のステータスアイテム配列オブジェクトを新しいものに置き換えます。

このレポートを処理した後、サーバーは3つのメールアカウントのステータスを持っていますが、1つは変更されました。

アカウント設定がデバイスから削除されると、デバイス上のステータス項目には削除のためにマークされた対応するオブジェクトがあり、別のステータスレポートがサーバーに送信されます。

削除されたアイテムのみが報告されます。

削除を示すために、配列項目オブジェクトには2つのキーのみが含まれています。識別子キー（その値はサーバーがすでに持っているものと一致します）と削除されたキーは、値trueに設定されています。

これにより、サーバーは既存のアイテムを削除することで、デバイス状態の表現を更新できます。

このレポートを処理した後、サーバーのステータスは2つのメールアカウントのみで、デバイスの状態と正しく一致します。

ステータスレポートに関する最後のポイント。

デバイスは、パフォーマンスの問題を回避するために、ステータスレポートが送信される速度を制限します。

デバイスは、ステータスレポートをサーバーに送信する前に、最大1分間の可変間隔でステータス項目への変更を集約します。

これは、ステータスが迅速に報告されることを意味しますが、即時ではありません。

次に、長年のMDMボトルネック問題の解決に注意を向けましょう。アプリケーションのインストールステータスを監視します。

MDMサーバーは、多くの場合、デバイスにアプリをインストールして、ユーザーが仕事や教育に必要なツールにアクセスできるようにします。

サーバー側のロジックは、多くの場合、アプリが正常にインストールされたかどうかによって決定されます。

したがって、MDMサーバーは、アプリのインストールの進捗状況を監視し、ユーザーがデバイスで管理対象アプリを削除する可能性を監視する必要があります。

現在、MDMサーバーは、InstalledApplicationListまたはManagedApplicationListコマンドを使用してデバイスをポーリングし、アプリのインストールの進行状況を観察できます。

デバイスにアプリのインストールの進捗状況を積極的にサーバーに送信させることで、ポーリングを回避できます。

そして、それを行うためのツールは、宣言的なデバイス管理ステータスレポートです。

このリリースでは、mdm.appのステータス項目が追加されます。

その値は、それぞれがMDMサーバーによってインストールされたアプリを表すオブジェクトの配列です。

この値は配列であるため、前述の手順を使用して段階的に報告されます。

ここでは、監視対象のデバイスでも、MDMによってインストールされたアプリのみが報告されることに注意してください。

このステータスレポートには、インストールが完了したアプリのステータス項目が含まれています。

識別子キーは、配列項目オブジェクトの一意の識別子であり、この場合、アプリのバンドル識別子です。

ネームキーはアプリの名前を示します。

3つのバージョンキーは、通常、短い、および外部のバージョン識別子を提供します。

そして、ステートキーは、アプリの現在のインストールフェーズを示す列挙です。

これらのキーの値は、MDM ManagedApplicationListコマンド応答の同等の項目に対応しています。

これらすべての情報を使用して、サーバーはどのアプリが報告され、その状態であるかをすぐに識別できます。

アプリのインストール時のデータの流れの例を見てみましょう。

右側には、MDMサーバーによって管理されているiOS 16デバイスがあります。

サーバーはすでに宣言的なデバイス管理を有効にしており、MDMがインストールしたアプリのステータス項目のステータスサブスクリプションを送信しています。

サーバーの次のステップは、MDM InstallApplicationコマンドを使用してアプリをインストールすることです。

これはユーザー登録であるため、アプリをインストールするにはユーザーの承認が必要なため、デバイスがアプリのインストールコマンドを処理するときにプロンプトが表示されます。

この時点で、インストールの進行状況は一時停止され、ユーザーの入力を待ちます。

デバイスはサーバーにステータスレポートを送信し、アプリのバンドルIDと状態がプロンプトに設定されている単一のMDMインストールアプリのステータスオブジェクトが含まれます。

ある時点で、ユーザーがインストールボタンをタップすると、アプリのインストールがデバイスで開始されます。

インストールが進むにつれて、別のステータスレポートが送信され、今回はアプリの状態がインストールに設定されます。アプリがダウンロードされ、インストールされていることを示します。

最終的には、アプリはインストールを完了し、使用できるようになります。

その時点で、アプリの状態が管理対象に設定されている別のステータスレポートが送信され、アプリが適切にインストールされ、管理されていることを示します。

さて、ユーザーがデバイス上のアプリを手動で削除したとしましょう。

繰り返しになりますが、今回はアプリの状態が管理済みがアンインストールに設定されている状態で、ステータスレポートが送信されます。

これは、アプリがインストールされなくなったが、その管理状態がまだデバイスで追跡されていることを示しています。

サーバーがアプリ管理状態を削除したいと仮定しましょう。

これは、デバイスにRemoveApplicationコマンドを送信することによって行います。

これにより、内部で維持されている管理状態が削除され、アプリがまだ存在する場合は、それも削除されます。

別のステータスレポートが送信され、アプリオブジェクトがアプリのステータス配列から削除されたとマークされます。

これは、アプリのインストールの応答性と信頼性を向上させるのに役立つ新しいMDMステータスアイテムの力を示しており、実装にはほんの数ステップしかかかりません。

それでは、3番目の重点分野である述語を調べてみましょう。

アクティベーション述語をすばやく確認しましょう。

アクティベーションには、アクティベーションで参照される構成がデバイスに適用されるかどうかを決定するオプションの述語を含めることができます。

述語は、ステータス項目を参照して、それらのステータス項目の値をテストできるようにすることができます。

述語で参照されるステータス項目が変更されると、デバイスはすべてのアクティベーションを再処理し、述語を再評価します。

述語は、Apple Developerサイトに記載されているNSPredicate構文を使用して文字列として指定されます。

より複雑な述語式をサポートするために、式内のステータス項目を検出しやすくするために述語構文を拡張しました。

新しい構文は、述語文字列の@status項内にステータス項目名を配置します。

この例では、シリアル番号のステータス項目は、新しい構文を使用して述語式に表示されます。

以前の構文は下位互換性のために引き続き機能しますが、現在は非推奨なので、新しいものに切り替えてください。

述語がステータス項目の配列値でどのように使用できるかを調べてみましょう。

先ほど説明したように、アカウントとMDMがインストールしたアプリのステータスアイテムの配列であるステータスアイテム値ができるようになりました。

配列内のアイテムのアクティベーションを述語できると便利です。

たとえば、特定のバンドル識別子を持つアプリがデバイスにインストールされ、管理されているときに、アクティベーションをトリガーしたい場合があります。

NSPredicateには、配列を操作するために使用できるSUBQUERY用語があります。

このNSPredicate式は、MDMにインストールされたアプリのステータスアイテムをターゲットにしたSUBQUERYを使用します。

ステータス項目は、サブクエリの最初の引数として使用されます。

2番目の引数は、配列の各要素を参照する変数を定義します。

3番目の引数は、その変数によって識別される各要素をテストする述語式です。

SUBQUERY式は、3番目の引数の述語に一致する要素の配列を返します。

次に、@count演算子はその配列の長さを返し、長さをチェックして、結果の一致が1つあるかどうかを判断します。

指定されたアプリがインストールされ、管理されると、このSUBQUERY式は単一の要素を持つ配列を返し、述語はtrueと評価されます。

アプリがインストールされていない場合、SUBQUERY式は空の配列を返し、述語はfalseと評価されます。

ステータス項目配列オブジェクトのキーを参照するには、キーパスが適切に処理されていることを確認するために、@key拡張用語を使用する必要があることに注意してください。

新しい述語構文は拡張可能であり、新しいタイプのデータの述語用語を追加するためにどのように使用できるかについて説明します。

サーバーは、複雑なサーバー側のロジックが、それらの変更をトリガーするために大規模な構成セットを同期することなく、デバイス上の単純な状態変更に変換できるように、述語の評価をより直接制御できる必要があります。

この例としては、複数の役割を持つユーザーがいて、ユーザーに配布されるデバイスの効率的でタイムリーな割り当てを希望する組織、または交換用デバイスを迅速に配布する必要がある組織、または組織データを保護するためにデバイスをセーフモードにすばやく配置する必要がある組織です。

これをサポートするために、サーバーがアクティベーション述語で直接使用できる任意のプロパティをデバイスに設定できるようにする新しい宣言を追加していることを嬉しく思います。

これは新しい管理プロパティ宣言です。

宣言は、キー名がサーバーによって定義されているJSONオブジェクトで構成されています。

JSONオブジェクト値は、配列やオブジェクトを含む任意のJSON値タイプにすることができます。

ここでの管理プロパティ宣言には、文字列と整数値を持つ名前と年齢プロパティ、および文字列の配列であるロールプロパティの3つのプロパティが含まれています。

これは、いくつかの管理プロパティを参照する述語を持つアクティベーションです。

まず、age プロパティをテストして、その整数値が 18 より大きいかどうかを判断し、次に roles プロパティをテストして、文字列 Grade12 がプロパティ配列値にあるかどうかを判断します。

各プロパティは、@property拡張用語を使用して参照され、プロパティキー名は用語内にあります。

複数の管理プロパティ宣言をデバイスに送信できますが、キーはすべてで一意である必要があります。

重複したキーがある場合、プロパティが述語で参照されると、値の1つが任意に選択され、予測不可能な結果につながります。

したがって、重複したキー名の使用は避けてください。

ユースケースの例を探ってみましょう。

この例には学校が関係しています。

そしてもちろん、学校には教師がいます。

学校には上と下の2つの部門があります。

各部門には、独自のWi-Fiネットワークを備えた独自のキャンパスがあります。

一部の教師はIT管理者として機能し、共有メールアカウントへのアクセスが必要です。

一部の教師はスポーツコーチとしても機能し、すべてのチームの試合スケジュールのカレンダーを購読する必要があります。

したがって、教師には4つの異なる役割があり、時には複数の役割があります。

各役割には、デバイスに割り当てられた教師の役割に基づいてデバイスに適用する必要がある一連の構成があります。

私たちの例では2人の教師を考えてみましょう。

教師は中学校で教えており、スポーツコーチでもあります。

教師2は高校で教えており、IT管理者でもあります。

このようなユースケースは、従来のMDMサーバーでどのように処理されますか?

通常、サーバーは、そのデバイスを完全に設定する前に、デバイスが教師に割り当てられるのを待たなければなりません。

サーバーは、教師がどのような役割を持っているかを決定する必要があります。

次に、各ロールにリンクされているプロファイルを決定します。

次に、各プロファイルを一度に1つずつデバイスにインストールする必要があります。

教師が役割を変更した場合、サーバーは新しい役割に合わせてプロファイルを追加または削除しなければなりません。

これは時間がかかり、特にピーク時にデバイス管理システムに大きなボトルネックをもたらす可能性があります。私たちの場合、課題が終わった学校の初日になります。

新しい管理プロパティ宣言により、これに代わるより効率的な代替手段があります。

これには、事前にデバイスにフルセットの宣言をプリロードすることが含まれます。

構成はアクティベーションに割り当てられ、管理プロパティを介して異なる役割に対してトリガーされる述語があります。

デバイスが教師に割り当てられると、サーバーは教師の役割を持つ管理プロパティ宣言のみを送信し、それらの役割の構成のアクティブ化をトリガーします。

この方法は、サーバーとネットワーク全体のトラフィックを最小限に抑え、デバイスの状態に迅速な変更を加えることの複雑さを軽減します。

私たちの学校の例に戻りましょう。

サーバーは、次の一連の宣言をプリロードします。各部門のWi-Fiネットワークを設定する2つのアクティベーション/構成ペア。

次に、メールアカウントをインストールするIT管理者の役割のアクティベーション/設定ペアがあります。

最後に、購読したカレンダーをインストールするアクティベーションと設定があります。

各アクティベーションには、ロール管理プロパティを使用して除算または関数の名前をテストする述語があります。

未割り当てのデバイスに最初にロードすると、すべての述語がfalseと評価されるため、何も適用されません。

では、課題の日に何が起こるかを調べてみましょう。

サーバーがする必要があるのは、各教師にカスタマイズされた管理プロパティ宣言を作成することだけです。

教師1には、ローワーとスポーツをリストする役割プロパティがあります。

教師2には、上部とIT管理者をリストするロールプロパティがあります。

これらの宣言が割り当てられた各デバイスに別々に送信されると、プリロードされたアクティベーションはすべて再評価されます。

したがって、教師のデバイスには、ローワーとスポーツの役割の構成が有効になっています。

そして、教師2のデバイスは、上部とIT管理者の役割の構成がアクティブになっています。

多くの設定の適用をトリガーするには、単一の宣言のみが必要です。

最後に、教師が役割を変えたときに何が起こるかを調べてみましょう。

この場合、教師2は既存の役割に加えてスポーツコーチになりました。

教師に割り当てられたデバイスの管理プロパティ宣言が更新され、追加の役割名が追加されました。

その宣言がデバイスで更新されると、すべてのアクティベーションが再評価されます。

この場合、新しいスポーツロールのサブスクライブカレンダー設定が適用されます。

繰り返しますが、トリガーとして必要な宣言の変更は1つだけです。

これは、管理プロパティ宣言が、複雑なサーバーサイドロジックがデバイス上の単純な状態変更に変換できるように、デバイス上の構成セットを迅速かつ簡単に切り替える強力な方法を提供する方法を示しています。

さあ、締めくくりましょう。

iOS 16、tvOS 16、macOS Venturaの宣言型デバイス管理の範囲を拡大し、共有iPadを含むすべての適用可能なタイプのMDM登録で利用できるようにしました。

これにより、MDMをサポートするすべてのAppleデバイスで宣言的なデバイス管理を完全にサポートします。

パスコード、アカウント、MDMでインストールされたアプリの新しいステータス項目を追加しました。

MDMにインストールされたアプリのステータスは、MDMの重要なボトルネックの1つに優れたソリューションを提供します。

最後に、述語構文を強化して、より拡張可能で使いやすくし、サーバーに複雑なビジネスロジックをデバイスに移動するさらに多くの機会を与える新しい管理プロパティ宣言を追加しました。

今、あなたの製品に宣言的なデバイス管理を追加する時です。

そして、宣言的なデバイス管理を使用してデバイス管理ソリューションを再考するために何をするかを学ぶことに興奮しています!

いつものように、あなたのフィードバックは大歓迎です。

ありがとう、WWDCの残りの部分を楽しんでください。

♪ ♪