10120

♪ ♪

David Stites: こんにちは、「コアデータスキーマを進化させる」へようこそ。

私の名前はDavid Stitesで、Core Dataチームのエンジニアです。

このセッションでは、アプリのコアデータスキーマを更新および移行する方法についてお話しできることを嬉しく思います。

このセッションの議題は、スキーマ移行とは何か、データモデルを更新した後にアプリが実行しなければならない理由、既存のスキーマを移行する方法、CloudKitとスキーマ移行がどのように相互作用するかを学ぶことです。

まず、スキーマ移行とは何か、データモデルを更新するときにアプリを移行する必要がある理由。

アプリケーションが進化するにつれて、データモデルを変更する必要があるかもしれません。

データモデルを更新するには、これらの変更が基礎となるストレージスキーマで具体化される必要があります。

このデータモデルを考えてみましょう。

エンジンの種類と数の2つの属性を持つ航空機エンティティがあります。

これらの属性は、基礎となるストレージに反映されます。

多数の乗客属性を追加すると、対応するストレージを追加する必要があります。

移行後、変更は基盤となるストレージに完全に反映されます。

基礎となるストレージの変更を移行せずに、新しく変更されたモデルがストレージに使用されるモデルと一致しないため、Core Dataは永続的なストアを開くことを拒否します。

互換性のないストアを開こうとすると、コードNSPersistentStore-IncompatibleVersionHashErrorでエラーが発生します。

このエラーが表示された場合は、移行が必要であることを示す必要があります。

スキーマ移行とは何か、なぜアプリを進化させるのに不可欠なのかを説明したので、移行がどのように達成されるかをお教えしましょう。

Core Dataには、現在のデータモデルでアプリのデータストレージを最新の状態に保つためのデータ移行ツールが組み込まれています。

総称して、これらのツールは「軽量移行」と呼ばれます。

軽量移行は、移行の好ましい方法です。

軽量移行は、ソースと宛先管理オブジェクトモデルの違いから移行を自動的に分析し、推測します。

実行時に、Core Dataは、NSBundleクラスの.allBundlesおよび.allFrameworksメソッドによって返されるバンドル内のモデルを探します。

その後、軽量移行は、データベーススキーマでアプリで行った変更を具体化するためのマッピングモデルを生成します。

軽量移行を使用するには、明らかな移行パターンに合わせてデータモデルを変更する必要があります。

属性を含む軽量操作には、属性の追加、属性の削除、オプション以外の属性のオプション化、オプション属性の非オプション化、デフォルト値の定義、属性の名前の変更などがあります。

属性の名前を変更する場合は、宛先モデルの名前変更識別子をソースモデルの対応する属性の名前に設定します。

名前変更識別子は、Xcode Data Model Editorのプロパティインスペクタにあります。

たとえば、航空機エンティティのカラー属性の名前をペイントカラーに変更できます。

名前変更識別子は正規名を作成するため、その属性にすでに名前変更識別子がない限り、名前変更識別子をソースモデルの属性の名前に設定します。

これは、モデルのバージョン2で属性の名前を変更し、バージョン3で再び名前を変更できることを意味します。

名前の変更は、バージョン2からバージョン3、またはバージョン1からバージョン3に正しく機能します。

軽量の移行は、汗をかくことなく関係の変更を処理することもできます。

新しい関係を追加したり、既存の関係を削除したりできます。

属性と同じように、名前変更識別子を使用して関係の名前を変更することもできます。

さらに、関係カーディナリティを変更できます。たとえば、a to-oneからa to-manyへの移行、または非順序付けられたto-manyへの移行、またはその逆です。

エンティティも軽量移行の対象となると推測したなら、あなたは正しいです。

新しいエンティティを追加したり、既存のエンティティを削除したり、エンティティの名前を変更したりできます。

また、新しい親または子エンティティを作成し、エンティティ階層内で属性を上下に移動することもできます。

エンティティを階層にまたは階層外に移動できます。

ただし、エンティティ階層をマージすることはできません。

2つの既存のエンティティがソースで共通の親を共有しない場合、宛先で共通の親を共有することはできません。

軽量移行は、NSMigratePersistent-StoresAutomaticallyOptionとNSInferMappingModelAutomaticallyOptionの2つのオプションキーによって制御されます。

ストアが永続コーディネーターに追加されたときにこれらの2つのキーの存在が真の値に設定されると、永続ストアが現在のモデルと一致しなくなったことを検出した場合、Core Dataは自動的に軽量移行を実行します。

NSPersistentContainerまたはNSPersistentStoreDescriptionを使用している場合、これらのオプションは自動的に設定され、何もする必要はありません。

NSPersistentStoreCoordinator .addPersistentStore (type:configuration:at:options:) などの代替 API を使用している場合、キーセット NSMigratePersistent- StoresAutomaticallyOption と NSInferMappingModelAutomaticallyOption を YES の値に設定して渡すことで、軽量移行を

Core Dataは、永続ストアが現在のモデルと一致しなくなったことを検出すると、自動的に軽量移行を実行します。

これがコードでどのように機能するかです。

まず、CoreDataをインポートし、管理オブジェクトモデルを作成します。

次に、先ほど作成したモデルを使用して、永続的なストアコーディネーターを作成します。

私が作成したオプション辞書に注意してください。ストアを永続コーディネーターに追加するときに渡します。

最後に、必要に応じて移行が自動的に行われるコーディネーターにストアを追加します。

使用するAPIに関係なく、データモデルの変更は、アプリケーションに同梱されているのと同じモデルで直接行うことができます。

変更を加えるためにモデルの新しいバージョンを作成する必要はありません。

Core Data が実際に移行作業を行うことなく、ソースモデルと宛先モデル間のマッピング モデルを推測できるかどうかを事前に判断したい場合は、NSMappingModel .inferredMappingModel メソッドを使用できます。

このメソッドは、Core Dataが作成できた場合、推論されたモデルを返します。

それ以外の場合は、nilを返します。

場合によっては、スキーマへの結合された変更は、軽量移行の機能を超える可能性があります。

その問題に対処し、まだ軽量の移行を使用する方法を説明します。

以前の例モデルに戻ると、FLIGHT_DATAに保存されているファイルパスによって示されるバイナリデータに外部ストレージを使用する「flightData」という属性を以前に追加したと仮定します。

さらに、その属性を変更してデータを内部に保存し、外部ストレージを削除する必要があると仮定します。

この移行が軽量移行の機能のいずれかに適合しているかどうかを確認すると、そうではないことが判明しました。

一見すると、私たちは立ち往生していて、この変更を行うことができないようです。

しかし、恐れるな!

軽量移行は、複数のステップではありますが、より複雑で不適合な移行を実行するために引き続き使用できます。

目標は、軽量移行の対象とならない移行タスクを、軽量移行の対象となる最小限の一連の移行に分解することです。

一般的に、元のモデルがAで、目的モデルがBであるが、モデルBに軽量移行の対象とならない変更がある場合、それらの変更を分解する1つ以上のモデルバージョンを導入することでブリッジを作成できます。

導入された各モデルには、不適合な変更を構成する機能の範囲内にある1つ以上の操作があります。

これにより、一連の移行が発生し、各モデルは軽量で移行可能ですが、不適合の移行と同等になります。

軽量移行の対象ではなかった私の例に戻ると、元のモデルはモデルAです。

新しいモデルバージョン、Aプライムを導入してタスクの分解を開始し、外部ファイルからインポートされたデータを保存するために一時的に使用される新しい属性「tmpStorage」を追加します。

次に、外部ファイルから新しい属性にデータをインポートします。

このデータをインポートするコードは、Core Dataが提供する機能とは別です。

このインポートの実行は、移行の間に介在しています。

データが安全にインポートされたら、AプライムからモデルAダブルプライムの別の新しいバージョンを作成します。

ダブルプライムでは、古い外部ストレージ属性を削除し、同時に新しい属性の名前を変更します。

説明されているこれらの各ステップは、軽量移行の機能の範囲内です。

直感的には、軽量移行オプションを設定して永続的なストアを開き、各未処理モデルをシリアルオーダーで反復的にステップスルーするイベントループを構築することができ、Core Dataはストアを移行します。

前の例で外部ファイルからデータをインポートする方法など、移行中にアプリ固有のロジックを実行する場合、プロセスの終了により移行が中断された場合、そのロジックは「再スタート可能」でなければなりません。

アプリがCore DataとCloudKitを使用している場合、Core Dataでデータモデルを設計する際に留意すべき重要なポイントがいくつかあります。

コアデータストアとCloudKitデータベースの間でレコードを渡すには、データモデルに対する共通の理解が必要です。

このモデルは、コアデータモデルエディタで定義します。

そのモデルはその後、CloudKitスキーマを生成するために使用されます。

生成されたスキーマは、最初に開発環境で作成され、その後プロダクションに昇格されます。

CloudKitはコアデータモデルのすべての機能をサポートしていないことに注意する必要があります。

モデルを設計する際には、次の制限事項を認識し、互換性のあるデータモデルを作成してください。

たとえば、エンティティに対する一意の制約はサポートされていません。

未定義とobjectIDの属性タイプは、属性タイプとしてサポートされていません。

そして、関係はオプションでなければならず、逆の関係を持つ必要があります。

さらに、CloudKitは削除拒否ルールをサポートしていません。

アプリを開発する際には、開発環境を使用します。

CloudKitスキーマは、この環境で自由に変更できます。

ただし、スキーマをプロダクションに昇格した後、レコードタイプとそのフィールドは不変です。

軽量移行は多くの異なるシナリオを処理しますが、CloudKitはサポートするものがより制限されています。

先に説明した軽量操作の多くはサポートされていません。

具体的には、CloudKitでサポートされているのは、既存のレコードタイプに新しいフィールドを追加し、新しいレコードタイプを追加することです。

既存のレコードタイプやフィールドを変更または削除することはできません。

モデルスキーマを変更するときは、これらの制限を考慮してください。

データモデルを更新するときは、軽量移行はローカルストアファイルのスキーマ変更のみを具体化することに注意してください。

特定のストアがCloudKitで使用されているかどうかにかかわらず、移行はディスク上のストアを変更するだけで、CloudKitスキーマは変更されません。

スキーマ初期化子を実行し、CloudKitコンソールを使用して開発でそれらの変更を本番環境に昇格させることで、開発データベースでこれらの変更を具体化する必要があります。

アプリのユーザーは、古いバージョンと新しいバージョンを使用することを覚えておいてください。

アプリの最新バージョンは、もちろん、スキーマへの新しい追加について知っているでしょう。

アプリの古いバージョンでは、新しいフィールドやレコードタイプについてはわかりません。

CloudKitスキーマは本質的に付加的であるため、古いバージョンのアプリを実行しているデバイスへのスキーマ移行の影響を考慮してください。

たとえば、一般的な落とし穴の1つは、アプリの古いバージョンでは使用しますが、新しいバージョンでは使用しない古いフィールドを更新するのを忘れることです。

CloudKitスキーマを移行するための戦略をいくつか紹介します。

最初のオプションは、既存のレコードタイプに新しいフィールドを段階的に追加することです。

このアプローチを採用すると、アプリの古いバージョンは、ユーザーが作成したすべてのレコードにアクセスできますが、すべてのフィールドにはアクセスできません。

2番目のオプションは、バージョン属性を含めてエンティティをバージョン化し、フェッチ要求を使用して、アプリの現在のバージョンと互換性のあるレコードのみを選択することです。

このアプローチを採用すると、古いバージョンのアプリは、ユーザーがより新しいバージョンで作成したレコードを取得せず、そのデバイスに効果的に非表示にします。

最後の戦略は、NSPersistentCloudKitContainerOptionsを使用してまったく新しいコンテナを作成し、新しいストアを新しいコンテナに関連付けることです。

ユーザーが大きなデータセットを持っている場合、データセットをiCloudにアップロードするには長い時間がかかる可能性があることに注意してください。

どのような方法を使用しても、データモデルの設計には注意してください。

クロスバージョンの互換性の問題を考慮し、データモデルの異なるバージョンを一緒にテストしてください。

データモデル、移行、CloudKitについて徹底的に議論したので、これを実際に実演します。

推測かもしれませんが、私はパイロットです。

飛行時間を記録するための小さなアプリを作成しました。

これがそのアプリのデータモデルです。

私は「LogEntry」と呼ばれる単一のエンティティを持っており、必要な経験情報を記録できるように、航空機の種類、飛行時間、出発地、目的地、尾行番号など、多くの属性を追加しました。

このアプリケーションを初めて実行すると、Core Dataはストアを作成し、そのストアでスキーマを具体化します。

アプリケーションを実行する前に、com.apple.CoreData.SQLDebugとcom.apple.CoreData.MigrationDebug環境変数をオンにします。

これにより、Core Dataは実行している手順をログに記録します。

これらの引数があれば、アプリを実行します。

アプリが起動すると、Core Dataは、ファイルの作成、ストアのメタデータの作成、スキーマの具体化など、実行している手順を記録しています。

SQLiteは、スキーマを含むテーブルZLOGENTRYを作成しました。

これは、sqlite3コマンドラインツールを使用してストアファイルを見ることでも確認できます。

ここにはLogEntryテーブルがあり、データモデルで作成した属性に対応する列があります。

今、私はいくつかの軽量な変更を加えるつもりです。

私はいくつかの新しいエンティティ、航空機、パイロット、空港を追加しています。

これはスキーマを正規化するのに役立ちます。

LogEntryエンティティの属性の一部を関係に変更しています。

たとえば、宛先と原点が文字列属性から空港と1の関係に移行します。

空港エンティティには、icaoIdentifierとfaaIdentifierの2つの新しい属性もあります。

type属性は新しいエンティティに昇格されます。航空機と私は、tailNumberとregistrationNumberの2つの新しい属性を追加します。

LogEntryでは、LogEntryから航空機との対1の関係を作成しています。

最後に、名前と証明書IDを持つパイロットエンティティを追加しました。

各ログエントリは、パイロットエンティティに関連付けられます。

データモデルの変更が完了したので、アプリをもう一度実行します。

おっと！アプリの実行中にエラーが発生しました。

コードを調べると、NSPersistentStore- IncompatibleVersionHashErrorです。

そのエラーは、私の現在のモデルがストア内のモデルのスキーマと一致しなくなったことを意味します。

ストアスキーマを移行する必要があります。

私は3つの方法のいずれかでそれを行うことができます。

最初の方法を使用すると、軽量の移行オプションが自動的に設定されるため、コードをNSPersistentContainerを使用するように変換できます。

2番目の方法を使用すると、軽量移行オプションが自動的に設定されるため、NSPersistentStoreDescriptionを使用できます。

最後に、3番目の方法を使用して、オプション辞書で軽量移行オプションを手動で設定し、ストアを開くときにその辞書をコーディネーターに渡すことができます。

NSPersistentContainerを使用して、最初のオプションで行こうと思います。

NSPersistentContainerを使用するようにコードを変換したので、アプリを起動し、Core Dataがストアファイル内のスキーマを移行していることを再度観察します。

繰り返しますが、これはsqlite3コマンドラインツールを使用して確認できます。

新しいスキーマは、軽量の移行を使用して、Core Dataによって自動的に具体化されたことに注意してください。

何がもっと簡単でしょうか?

デモを終了する前に、オプション番号3を表示したかった。

このオプションを思い出すと、オプション辞書で軽量移行オプションを手動で設定し、ストアを開くときにその辞書をコーディネーターに渡します。

最終的な結果は、ストアが新しいスキーマに移行されるという点で同じです。

データモデルを変更するときは、軽量の移行を使用してください。

軽量移行は非常に柔軟で、大部分のデータモデルの変更に使いやすいです。

より複雑なデータモデルがある場合は、そのモデルを軽量な変更で構成されたモデルに分解してください。

最後に、アプリでCloudKitを使用する場合は、データモデルの変更の影響を慎重に検討してください。

データモデルの変更を徹底的にテストします。

この情報が役に立ち、プロジェクトのモデルを更新して素晴らしい新機能を構築することを検討することを願っています。

私と一緒に飛んでくれてありがとう、そして素晴らしいWWDCをお過ごしください。