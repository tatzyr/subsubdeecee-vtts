10054

♪インストゥルメンタルヒップホップ音楽♪

♪

こんにちは。私はSwiftUIチームのエンジニア、Curtです。

SwiftUIには、ナビゲーション用のエキサイティングな新しいAPIがいくつかあります。

私はこれらの新しいAPIでアプリを構築するのを楽しんでおり、それらをあなたと共有できることに興奮しています。

これらのAPIは、Apple TV、iPhone、Apple Watchなどの基本的なスタックから、強力な複数列のプレゼンテーションまで拡張できます。

新しいAPIは、プログラマティックナビゲーションとディープリンクの堅牢なサポートをもたらし、アプリに最適な構造を構築するための作品を作成できます。

この講演では、SwiftUIのナビゲーションでアプリを調理するための簡単なレシピをいくつか紹介します。

また、すでにSwiftUIを使用している場合は、これらの新しいAPIがワンランクアップに役立つことを願っています。

新しいデータ駆動型ナビゲーションAPIに入る成分から始めます。

次に、テイスティングメニューに移動します。ナビゲーションの完全なプログラム制御のためのいくつかの迅速かつ簡単なレシピ。

デザートコースでは、新しいAPIを使用してアプリでナビゲーション状態を持続させるためのヒントをいくつか紹介します。

以前にSwiftUIでナビゲーションを使用したことがあるなら、新しいAPIがどのように違うのか疑問に思うかもしれません。

だから、掘り下げる前に、既存のAPIのいくつかを確認しましょう。

既存のAPIは、他の列またはスタックに表示されるビューを送信するリンクに基づいています。

たとえば、ルートビューにナビゲーションリンクのリストがあるかもしれません。

これらのリンクの1つをタップすると、リンクはスタック上のビューをプッシュします。

これは基本的なナビゲーションに最適で、このパターンを使い続けることができます。

しかし、ルートビューに戻りましょう。

既存のナビゲーションAPIでは、プログラムでリンクを表示するために、リンクにバインディングを追加します。

たとえば、item.showDetailをtrueに設定することで、このリンクのビューを表示できます。

しかし、これはリンクごとに個別のバインディングが必要であることを意味します。

新しいAPIでは、NavigationStackと呼ばれるコンテナ全体にバインディングを持ち上げます。

ここのパスは、スタックにプッシュされたすべての値を表すコレクションです。

NavigationLinksはパスに値を追加します。

パスを変更してディープリンクしたり、パスからすべてのアイテムを削除してルートビューにポップしたりできます。

この講演では、新しいナビゲーションAPIがデータ駆動型のプログラマティックナビゲーションを可能にする方法を紹介します。

パワフルで使いやすいと願っています。

新しいナビゲーションAPIを使用するためのレシピに飛び込む前に、メニューにあるものを共有することが役立つと思いました。

私は最近本当に料理に夢中になっていて、自分のレシピを追跡するためのアプリに取り組んでいます。

私はこの情報を提示するさまざまな方法について多くのアイデアを持っています。

例えば、ここに3列のアプローチがあります。

最初の列では、レシピのカテゴリを選択できます。

カテゴリを選択すると、2番目の列に収集したレシピが一覧表示されます。

そして、レシピを選択すると、詳細領域にそのレシピの材料が表示されます。

詳細エリアには、関連するレシピの選択へのリンクもあります。

おばあちゃんはいつも「皮がパイを作る」と言っていました。

だから、それが私たちが今日料理しているものです。

私たちの材料は新しいナビゲーションAPIです。

それらを掘り下げてから、それらを混ぜ合わせた特定のナビゲーションレシピを見てみましょう。

新しいナビゲーションAPIは、ゲストがその構造を移動するのを助けるためにNavigationLinkの新鮮な新しい品種とともに、アプリの構造を記述するために使用できるいくつかの新しいコンテナタイプを導入します。

最初の新しいコンテナはNavigationStackです。

NavigationStackは、Apple Watchの「探す」、iPhoneの設定、macOS Venturaの新しいシステム設定アプリに見られるようなプッシュポップインターフェースを表しています。

2番目の新しいコンテナタイプはNavigationSplitViewです。

NavigationSplitViewは、MacやiPadのメールやメモなどの複数列のアプリに最適です。

また、NavigationSplitViewは、iPhone、iPadのSlide Over、さらにはApple WatchやApple TVの単一列のスタックに自動的に適応します。

NavigationSplitViewには2組の初期化子があります。

ここに示されているように、1つのセットは、2列のエクスペリエンスを作成します。

他の初期化子のセットは、3列のエクスペリエンスを作成します。

NavigationSplitViewには、列の幅、サイドバーの表示をカスタマイズしたり、プログラムで列を表示したり非表示にしたりできる設定オプションのカートロードが付属しています。

この講演では設定オプションについては説明しませんが、同僚のRajの講演「SwiftUI on iPad: Organize your interface」と、NavigationSplitViewをアプリにぴったりになるように調整する方法に関する素晴らしいドキュメントをチェックしてください。

以前は、NavigationLinksには常にタイトルと表示するビューが含まれていました。

新しい品種にはまだタイトルが含まれていますが、提示するビューではなく、価値を提示します。

例えば、このリンクはアップルパイのレシピを提示しています。

ご覧のとおり、NavigationLinkはスマートです。

リンクの動作は、NavigationStackまたは表示されるリストによって異なります。

これらのおいしい新しいAPIがどのように連携するかを見るために、私の料理本アプリとあなたのアプリでそれらを使用するためのいくつかの特定のレシピを見てみましょう。

私たちの最初のレシピは、Apple WatchのFind MyやiPhoneのSettingsにあるような、基本的なビューのスタックです。

カテゴリごとにセクションがあります。

セクション内で、レシピをタップして詳細を確認できます。

どのレシピでも、関連するレシピの1つをタップしてスタックにプッシュできます。

戻るボタンを使って元のレシピに戻り、次にカテゴリリストに戻ることができます。

このレシピは、NavigationStackと新しい種類のNavigationLink、およびナビゲーション先修飾子を組み合わせたものです。

やり方を見てみましょう。

基本的なNavigationStackから始めます。

内部には、すべてのカテゴリとナビゲーションタイトルを反復するリストがあります。

リストの中には、各カテゴリのセクションがあります。

次に、各セクション内に、カテゴリ内の各レシピのナビゲーションリンクを追加します。

今のところ、リンクに私のRecipeDetailビューを表示させます。

これは、既存のビュー先NavigationLinkを使用しています。

そして、それはこのナビゲーション体験を一緒に調理するのに十分です。

しかし、プログラマティックナビゲーションはどうですか?

プログラムによるナビゲーションを追加するには、このナビゲーションリンクの2つの部分を区別する必要があります。それが提示する値と、その値に付随するビューです。

やり方を見てみましょう。

まず、リンクから宛先ビューを引き出し、新しいnavigationDestination修飾子にします。

この修飾子は、それが責任を負う提示されたデータのタイプを宣言します。ここでは、それがレシピです。

修飾子は、レシピ値が提示されたときにスタックにプッシュするビューを記述するビュービルダーを取ります。

次に、新しいNavigationLinksの1つに切り替えて、レシピの値を提示します。

ボンネットの下を覗いて、NavigationStackがどのように機能するかを見てみましょう。

すべてのナビゲーションスタックは、スタックが表示しているすべてのデータを表すパスを追跡します。

ここに示されているように、スタックがルートビューを表示している場合、パスは空です。

次に、スタックは、その内部、またはスタックにプッシュされたビュー内で宣言されたすべてのナビゲーション先も追跡します。

一般的に、これはセットですが、この例では、目的地は1つしかありません。

プッシュされたビューも図に追加しましょう。

さて、パスが空なので、プッシュされたビューのリストも空です。

さて、牛乳やクッキーのように、これらをまとめると魔法が起こります。

値を提示するリンクをタップすると、その値がパスに追加されます。

次に、ナビゲーションスタックはパス値の上に宛先をマップし、スタックにプッシュするビューを決定します。

さて、私のアップルパイのレシピから、パイクラストをタップすると、リンクもパスに追加されます。

NavigationStackはその魔法を行い、別のRecipeDetailビューをスタックにプッシュします。

パスに値を追加するたびに、NavigationStackは別のビューをプッシュします。

戻るボタンをタップすると、NavigationStackはパスとプッシュされたビューから最後のアイテムを削除します。

そして、NavigationStackにはもう1つのトリックがあります。

バインディングを使用してこのパスに接続できます。

私たちのコードに戻りましょう。

ここが私たちがいた場所です。

パスをバインドするには、まずいくつかの状態を追加します。

このスタックにプッシュされるすべての値はレシピであるため、レシピの配列をパスとして使用できます。

スタック上にさまざまなデータを表示する必要がある場合は、新しいタイプ消去NavigationPathコレクションを必ずチェックしてください。

パス状態になったら、NavigationStackに引数を追加し、パスにバインディングを渡します。

それがあれば、スタックをシズルにすることができます。

たとえば、特定のレシピにジャンプする方法を追加できます。

または、スタックのどこからでも、パスをリセットするだけでルートに戻ることができます。

これは、新しいNavigationStack、価値提示NavigationLinks、およびSwiftUIのnavigationDestinationsを使用してプッシュ可能なスタックを準備する方法です。

このレシピは、Macを含むすべてのプラットフォームで動作しますが、iPhone、Apple TV、Apple Watchで本当に輝いています。

NavigationStackの動作を確認するには、「Apple Watch用の生産性アプリを構築する」を必ずチェックしてください。

私たちの次のレシピは、MacやiPadのメールで見られるように、スタックのないマルチカラムプレゼンテーションです。

iPadでは、サイドバーは最初は非表示になっています。

私はそれを明らかにして、カテゴリを選ぶことができます。

次に、2番目の列でレシピを選択できます。

3番目の列はレシピの詳細を示しています。

このレシピは、NavigationSplitViewと新しい種類のNavigationLink、およびリスト選択を組み合わせたものです。

このレシピは、モダリティを回避するのに役立つため、より大きなデバイスに最適です。

掘り下げることなく、すべての情報を見ることができます。

やり方を見てみましょう。

コンテンツと詳細のプレースホルダビューを含む3列のNavigationSplitViewから始めます。

次に、サイドバーにすべてのカテゴリを反復するリストとナビゲーションタイトルを追加します。

リストの中には、各カテゴリのナビゲーションリンクがあります。

次に、どのカテゴリが選択されているかを追跡するために、いくつかの州を紹介します。

サイドバーのリストを微調整して、選択したカテゴリを使用します。

選択範囲にバインディングを渡していることに注意してください。

これにより、リストとその内容が選択を操作できます。

一致する選択タイプ（カテゴリ）を持つリスト内に値表示リンクを入れると、クリックまたはクリックすると、リンクは自動的に選択を更新します。

だから今、サイドバーでカテゴリを選択すると、SwiftUIは選択したカテゴリを更新します。

選択とリストに関する素晴らしい情報については、先ほど述べたRajの「インターフェイスを整理する」トークをチェックしてください。

次に、コンテンツ列のプレースホルダを選択したカテゴリのレシピのリストに置き換え、この列のナビゲーションタイトルも追加します。

選択したカテゴリと同様に、同じテクニックを使用して、コンテンツリストで選択したレシピを追跡できます。

選択したレシピにStateを使用し、コンテンツリストにその状態を使用し、各レシピに値表示リンクを使用します。

最後に、詳細列を更新して、選択したレシピの詳細を表示します。

これを導入することで、私は再びナビゲーションを完全にプログラムで制御できます。

たとえば、その日のレシピに移動するには、選択状態を更新するだけです。

これは、新しいNavigationSplitView、価値提示NavigationLinks、およびSwiftUIで選択したリストを使用して、複数列のナビゲーション体験を準備する方法です。

このようにリスト選択とNavigationSplitViewを組み合わせることの1つの非常にクールな点は、SwiftUIが分割ビューをiPhoneまたはiPadのSlide Overの単一のスタックに自動的に適応できることです。

選択の変更は、iPhoneの適切なプッシュとポップに自動的に変換されます。

もちろん、この複数列のプレゼンテーションはMacでもうまく機能します。

また、Apple TVとApple Watchには複数の列は表示されませんが、これらのプラットフォームは1つのスタックへの自動翻訳も取得します。

SwiftUIのNavigationSplitViewは、すべてのプラットフォームで動作します。

次に、iPadやMacの写真でそのような2列のナビゲーション体験を構築することで、これらすべての成分をまとめる方法を見てみましょう。

カテゴリを選択すると、詳細領域にそのカテゴリのすべてのレシピのグリッドが表示されます。

レシピをタップすると、詳細領域のスタックに押し込まれます。

関連するレシピをタップすると、それもスタックにプッシュされます。

そして、私はレシピのグリッドに戻ることができます。

このレシピは、ナビゲーション分割ビュー、スタック、リンク、宛先、およびリストを組み合わせたpièce de résistanceです。

これらすべての材料がどのように一緒になるか見てみましょう。

2列のNavigationSplitViewから始めます。

最初の列は前のレシピとまったく同じです。

選択したカテゴリと、その状態へのバインディングと値を提示するNavigationLink、および必要なnavigationTitleを使用するリストを追跡するための状態があります。

このレシピの違いは詳細領域にあります。

新しいナビゲーションAPIは、コンポジションを本当に利用しています。

NavigationSplitViewの列の中にリストを入れるのと同じように、列の中にNavigationStackを入れることもできます。

このナビゲーションスタックのルートビューは私のRecipeGridです。

RecipeGridがNavigationStack内にあることに注意してください。

つまり、RecipeGrid内にスタック関連の修飾子を入れることができます。

RecipeGridの本体にズームインして、それが何を意味するのか見てみましょう。

RecipeGridはビューであり、パラメータとしてカテゴリを取ります。

ここではカテゴリはオプションなので、if-letから始めます。

Elseケースは空の選択を処理します。

Ifの中に、スクロールビューと遅延グリッドを追加します。

怠惰なグリッドレイアウトは、一連のビューを取ります。

ここでは、ForEachを使用してレシピを反復しています。

レシピごとに、私は価値を提示するNavigationLinkを持っています。

リンクはレシピの値を示しています。

リンクのラベルは、この末尾のクロージャで、サムネイルとタイトルが付いた私のRecipeTileです。

では、このグリッドを完成させるために何が残っていますか?

さて、私はレシピから詳細ビューにマッピングする方法をNavigationStackに言っていません。

最初のレシピで述べたように、新しいNavigationStackはnavigationDestination修飾子を使用して、パス上の値からスタックに表示されるビューにマッピングします。

では、navigationDestination修飾子を追加しましょう。

しかし、どこに添付すればよいですか?

リンクに直接添付したいと思っていますが、これは2つの理由で間違っています。

List、Table、またはここではLazyVGridなどのレイジーコンテナは、すべてのビューをすぐに読み込むわけではありません。

ここに修飾子を置くと、宛先が読み込まれない可能性があるため、周囲のNavigationStackには表示されない可能性があります。

第二に、ここに修飾子を置くと、グリッド内のすべての項目に対して繰り返されます。

代わりに、ScrollViewに修飾子を添付します。

ScrollViewの外側に修飾子を添付することで、スクロール位置に関係なく、NavigationStackがこのnavigationDestinationを見ることができるようにします。

ここに修飾子を置くことについて私が好きなもう一つのことは、それがまだそれをターゲットとするリンクに近いということです。

ナビゲーションの目的地は、私や私のチームにとって意味のある方法で私のコードを整理する柔軟性を与えてくれます。

私のNavigationSplitViewに戻ると、ここで完全なプログラムナビゲーションを有効にすることがもう1つあります。

ナビゲーションパスを追加する必要があります。

状態を追加してパスを保持し、状態をNavigationStackにバインドします。

完全なプログラマティックナビゲーションを導入することで、このナビゲーション体験でその日のレシピを表示する方法を書くことができます。

これは、新しいNavigationSplitView、NavigationStack、値表示NavigationLinks、およびSwiftUIで選択したリストを使用して、スタックでマルチカラムナビゲーション体験を準備する方法です。

以前のレシピと同様に、これは狭いプレゼンテーションにも自動的に適応し、すべてのプラットフォームで動作します。

私のアプリでナビゲーションを構造化するためにこれらのレシピを探索するのは楽しかったですが、私たちのナビゲーションのごちそうはデザートなしでは完了しません。

そのために、ナビゲーション状態を永続化する方法を見てみましょう。

アプリでナビゲーション状態を持続させるには、CodableとSceneStorageの2つの要素が必要です。

このレシピには3つの基本的なステップがあります。

まず、ナビゲーション状態をNavigationModelタイプにカプセル化します。

これにより、ユニットとして保存して復元できるので、常に一貫しています。

次に、ナビゲーションモデルをCodableにします。

最後に、SceneStorageを使用してモデルを保存および復元します。

私は途中で注意する必要があります - 私は私のアプリが落ちたスフレのようにクラッシュしたくありません - しかし、手順は簡単です。

ステップ1を見てみましょう。

これが最後のレシピの最後からのコードです。

私のナビゲーション状態は、選択したカテゴリとパスのプロパティに保存されます。

selectedCategoryは、サイドバーの選択を追跡します。

パスは、詳細領域のスタックにプッシュされたビューを追跡します。

新しいNavigationModelクラスを導入し、ObservableObjectに準拠させます。

次に、ナビゲーション状態をモデルオブジェクトに移動し、プロパティラッパーを状態から公開に変更します。

次に、NavigationModelのインスタンスを保持するStateObjectを紹介し、新しいモデルオブジェクトを使用するようにパラメータを変更します。

次に、ナビゲーションモデルをコード化可能にします。

クラスにCodableコンフォーマンスを追加することから始めます。

多くの場合、Swiftは自動的にコード可能な適合性を生成できますが、ここで独自の適合性を実装したいと思います。

主な理由は、レシピがモデル値だからです。

状態復元のためにモデル値全体を保存したくありません。

これには2つの理由があります。

まず、私のレシピデータベースにはすでにレシピのすべての詳細が含まれています。

保存したナビゲーション状態でその情報を繰り返すのは、ストレージの良い使い方ではありません。

第二に、レシピデータベースがローカルナビゲーション状態とは無関係に変更できる場合、つまり、最終的に同期を追加するようになったため、ローカルナビゲーション状態に古いデータを含めたくありません。

カスタムコード性については、次にCodingKeysを追加します。

キーの1つはちょうど選択されたカテゴリです。

しかし、私は他の「recipePathIds」と名付けたことに注意してください。私はレシピの識別子をパスに保存することを計画しています。

エンコード方法では、コーディングキーを使用してキー付きコンテナを作成し、選択したカテゴリをコンテナに追加します。

私はencodeIfPresentを使用しているので、nilでない場合にのみ値を書きます。

次に、レシピパスの識別子を追加します。

エンコードする識別子を取得するためにパスをマッピングしていることに注意してください。

たとえば、私のナビゲーション状態に、上部の緑色のボックスに示されているように、パスにアップルパイとパイクラストを含む、選択したカテゴリとしてデザートが含まれているとします。

これは、この他のボックスに示されているように、JSONにエンコードされている可能性があります。

Codabilityを完成させるために、必要な初期化子を追加します。

興味深いのは、レシピIDをデコードし、共有データモデルを使用してIDをレシピに変換することです。

compactMapを使用して、見つからなかったレシピを破棄しています。

たとえば、同期作業後に別のデバイスでレシピを削除すると、これは発生する可能性があります。これは、いつか間違いなく行うことです。

これは、復元されたナビゲーション状態がまだ理にかなっていることを確認するために、自分のアプリで裁量を使用する必要がある場所です。

最後に、モデルを読み書きするための計算されたプロパティをJSONデータとして追加します。

今、私はナビゲーションモデルを持っていて、それ自体をエンコードしてデコードする方法を知っているので、残っているのは実際に保存して復元することだけです。

そのためにSceneStorageを使います。

これが私たちがメインビューを残したところです。

私はNavigationModelを保持するためにStateObjectを使用していました。

さて、NavigationModelを永続化するために、いくつかのSceneStorageを紹介します。

SceneStorageプロパティは、関連する値を自動的に保存および復元します。

ストレージのタイプがオプションの場合、ここの私のデータのように、新しいシーンが作成されると値はnilになります。

システムがシーンを復元すると、SwiftUIはSceneStorageプロパティの値も復元されることを保証します。

これを利用してNavigationModelを永続化します。

これを行うには、ビューにタスク修飾子を追加します。

タスク修飾子は、クロージャを非同期に実行します。

ビューが表示されたときに始まり、ビューが消えるとキャンセルされます。

私のビューが表示されるたびに、まずアプリの以前の実行から既存のデータがあるかどうかを確認します。

もしそうなら、そのデータでナビゲーションモデルを更新します。

次に、ナビゲーションモデルが変更されるたびに反復する非同期forループを開始します。

このループの本体は変更ごとに実行されるため、それを使用してナビゲーション状態をシーンストレージデータに保存できます。

そして、それだけです!

私がウェブ上でいくつかのヴィンテージジュリアチャイルドの料理番組をチェックしに行くために私のアプリを離れるとき、それは私がどこにいたかを覚えています。

アプリに戻ると、中断したところに戻ります。

さて、便利なキッチンのヒントで最後に奇妙なセクションがなければ、料理本は完成しません。

私はコリアンダーの3つの素晴らしい代替品を持っていませんが、共有するナビゲーションのヒントがいくつかあります。

できるだけ早く新しいNavigationStackとNavigationSplitViewに切り替えてください。

スタックスタイルでNavigationViewを使用している場合は、NavigationStackに切り替えてください。

NavigationStackは、Apple TV、Apple Watch、またはスタックスタイルが常にデフォルトであったiPadやiPhoneのシートでも良い最初の選択肢です。

複数列のNavigationViewを使用している場合は、NavigationSplitViewに切り替えてください。

また、バインディングを取るリンクを使用してプログラムによるナビゲーションをすでに採用している場合は、ナビゲーションパスとリストの選択とともに、新しい値を提示するNavigationLinkに移行することを強くお勧めします。

古いスタイルのプログラマティックリンクは、iOS 16と整列されたリリースから非推奨です。

新しいAPIへの移行の詳細と例については、開発者ドキュメントの「新しいナビゲーションタイプへの移行」の記事をご覧ください。

次に、Listと新しいNavigationSplitViewとNavigationStackが混在するように作られたことを覚えておいてください。

あなたのゲストが愛するナビゲーション体験を作成するためにそれらを構成してください。

ナビゲーションスタックを使用する場合、ナビゲーションの宛先はスタックまたはそのサブビュー内の任意の場所に置くことができます。

メンテナンスを容易にするために、対応するリンクの近くに目的地を置くことを検討してください。ただし、遅延コンテナの中に置かないことを忘れないでください。

最後に、理にかなっている場合は、NavigationSplitViewでナビゲーション体験を構築し始めることをお勧めします。

最初にiPhone用に開発している場合でも、NavigationSplitViewはより狭いデバイスに自動的に適応します。

また、iPhone Pro Maxを横向きでサポートしたり、アプリをiPadやMacに持ち込む準備ができたら、NavigationSplitViewは追加のスペースをすべて利用します。

新しいSwiftUIナビゲーションAPIをあなたと共有する機会をありがとう!

先に述べた講演に加えて、アプリで新しいウィンドウやシーンを開くための素晴らしい情報については、「SwiftUIアプリに複数のウィンドウをブリングする」をチェックしてください。

私たちの料理本アプリでのナビゲーションのためのこれらのレシピが味覚を喜ばせることを願っています。

私はあなたがあなた自身のアプリで調理する素晴らしい経験を見るのを楽しみにしています。

どうぞ召し上がってください！

♪