110362

♪ ♪

Nick Kledzik: こんにちは、Appleのリンカーチームのリードエンジニア、Nick Kledzikです。

今日は、速くリンクする方法を皆さんと共有したいと思います。

Appleがリンクを改善するために何をしたかをお伝えします。また、アプリのリンクパフォーマンスを向上させるために、リンク中に実際に何が起こるかを理解するのに役立ちます。

では、リンクとは何ですか?

あなたはコードを書きましたが、他の誰かがライブラリやフレームワークの形で書いたコードも使用します。

コードがこれらのライブラリを使用するには、リンカーが必要です。

さて、実際には2種類のリンクがあります。

アプリを構築するときに発生する「静的リンク」があります。

これは、アプリの構築にかかる時間や、アプリの大きさに影響を与える可能性があります。

そして、「ダイナミックリンク」があります。

これは、アプリが起動したときに発生します。

これは、顧客がアプリの起動を待たなければならない時間に影響を与える可能性があります。

このセッションでは、静的リンクと動的リンクの両方について話します。

まず、いくつかの例を挙げて、静的リンクとは何か、どこから来たのかを定義します。

次に、Appleの静的リンカーであるld64の新機能を発表します。

次に、静的リンクに関するこの背景で、静的リンクのベストプラクティスについて詳しく説明します。

この講演の後半では、動的リンクについて説明します。

動的リンクとは何か、どこから来たのか、動的リンク中に何が起こるかを示します。

次に、今年のディルドの新機能を明らかにします。

次に、アプリの動的リンク時間のパフォーマンスを向上させるために何ができるかについて話します。

そして最後に、カーテンの後ろを覗くのに役立つ2つの新しいツールで締めくくります。

バイナリに何があるか、動的リンク中に何が起こっているかを見ることができます。

静的リンクを理解するために、すべてが始まったときに戻りましょう。

当初、プログラムはシンプルで、ソースファイルは1つだけでした。

建物は簡単でした。

1つのソースファイルでコンパイラを実行しただけで、実行可能プログラムが生成されました。

しかし、すべてのソースコードを1つのファイルにまとめることはスケールしませんでした。

複数のソースファイルでどのように構築しますか?

そして、これは大きなテキストファイルを編集したくないからだけではありません。

本当の節約は、構築するたびにすべての機能を再コンパイルすることではありません。

彼らがしたことは、コンパイラを2つの部分に分割することでした。

最初の部分は、ソースコードを新しい中間「再配置可能なオブジェクト」ファイルにコンパイルします。

2番目の部分は、再配置可能な.oファイルを読み取り、実行可能プログラムを生成します。

私たちは今、第二部を「ld」、静的リンカーと呼んでいます。

だから今、あなたは静的リンクがどこから来たのか知っています。

ソフトウェアが進化するにつれて、すぐに人々は.oファイルを回していました。

しかし、それは面倒になりました。

誰かが「.oファイルのセットを「ライブラリ」にパッケージ化できたら素晴らしいと思いませんか?」と思いました。

当時、ファイルをバンドルする標準的な方法は、アーカイブツール「ar」でした。

バックアップと配布に使用されました。

だから、ワークフローはこれになりました。

複数の.oファイルをアーカイブに「ar」することができ、リンカーはアーカイブファイルから直接.oファイルを読み取る方法を知るために強化されました。

これは、共通のコードを共有するための大きな改善でした。

当時、それはちょうど図書館またはアーカイブと呼ばれていました。

今日、私たちはそれを静的ライブラリと呼んでいます。

しかし今、これらの関数のほんの一部しか使用されなかったとしても、これらのライブラリからの何千もの関数がそれにコピーされたため、最終的なプログラムは大きくなっていました。

そこで、巧妙な最適化が追加されました。

リンカーに静的ライブラリからすべての.oファイルを使用させる代わりに、リンカーは静的ライブラリから.oファイルを取得するだけで、未定義のシンボルが解決されます。

それは、誰かがすべてのC標準ライブラリ関数を含む大きなlibc.a静的ライブラリを構築できることを意味しました。

すべてのプログラムは1つのlibc.aとリンクできますが、各プログラムはプログラムが実際に必要とするlibcの部分しか得られませんでした。

そして、私たちは今日もそのモデルを持っています。

しかし、静的ライブラリからの選択的な読み込みは明らかではなく、多くのプログラマーをトリップします。

静的ライブラリの選択的な読み込みを少し明確にするために、簡単なシナリオがあります。

Main.cには、関数「foo」を呼び出す「main」という関数があります。

Foo.cには、バーと呼ばれるfooがあります。

Bar.cには、barの実装がありますが、たまたま未使用の別の関数の実装もあります。

最後に、baz.cには、undefという名前の関数を呼び出す関数bazがあります。

次に、それぞれを独自の.oファイルにコンパイルします。

Foo、bar、undefは未定義であるため、灰色のボックスがないことがわかります。

つまり、定義ではなくシンボルの使用です。

さて、bar.oとbaz.oを静的ライブラリにまとめることに決めたとしましょう。

次に、2つの.oファイルと静的ライブラリをリンクします。

実際に何が起こるかをステップスルーしましょう。

まず、リンカーはコマンドライン順にファイルを処理します。

最初に見つけたのはmain.oです。

Main.oをロードし、シンボルテーブルにここに示されている「メイン」の定義を見つけます。

しかし、メインには未定義の「フー」があることもわかった。

その後、リンカーはコマンドライン上の次のファイル（foo.o）を解析します。

このファイルは「foo」の定義を追加します。

つまり、fooはもはや未定義ではないということです。

しかし、foo.oをロードすると、「bar」の新しい未定義のシンボルも追加されます。

コマンドライン上のすべての.oファイルがロードされたので、リンカは未定義のシンボルが残っているかどうかをチェックします。

この場合、「バー」は未定義のままであるため、リンカはコマンドラインでライブラリを見て、ライブラリが欠落している未定義のシンボル「バー」を満たすかどうかを確認します。

リンカーは、静的ライブラリのbar.oがシンボル「bar」を定義していることを発見しました。

そのため、リンカーはアーカイブからbar.oをロードします。

その時点で、未定義のシンボルがなくなったため、リンカーはライブラリの処理を停止します。

リンカーは次の段階に進み、プログラム内のすべての機能とデータにアドレスを割り当てます。

次に、すべての機能とデータを出力ファイルにコピーします。

出来上がり！あなたは出力プログラムを持っています。

Baz.oは静的ライブラリにあったが、プログラムにロードされていないことに注意してください。

リンカーが静的ライブラリから選択的にロードする方法のため、ロードされませんでした。

これは明らかではありませんが、静的ライブラリの重要な側面です。

これで、静的リンクと静的ライブラリの基本を理解できます。

ld64として知られるAppleの静的リンカーの最近の改善に移りましょう。

人気のある需要により、今年はld64の最適化に時間を費やしました。

そして、今年のリンカーは...

多くのプロジェクトで2倍の速さ。

どうやってこれをやったの？

私たちは今、あなたの開発マシンのコアをよりよく利用しています。

複数のコアを使用してリンカー作業を並行して実行できる多くの分野を見つけました。

これには、入力から出力ファイルへのコンテンツのコピー、LINKEDITのさまざまな部分を並行して構築すること、UUID計算の変更、および並行して行うハッシュの共同設計が含まれます。

次に、多くのアルゴリズムを改善しました。

各シンボルの文字列スライスを表すためにC ++ string_viewオブジェクトを使用するように切り替えると、exports-trieビルダーは本当にうまく機能することがわかりました。

また、バイナリのUUIDを計算する際にハードウェアアクセラレーションを利用する最新の暗号ライブラリを使用し、他のアルゴリズムも改善しました。

リンカーのパフォーマンスの向上に取り組んでいる間、リンク時間に影響を与えるいくつかのアプリで設定の問題に気づきました。

次に、リンク時間を改善するためにプロジェクトで何ができるかについて話します。

5つのトピックを取り上げます。

まず、静的ライブラリを使用すべきかどうか。

そして、リンク時間に大きな影響を与える3つのあまり知られていないオプション。

最後に、あなたを驚かせるかもしれない静的リンクの動作について説明します。

最初のトピックは、静的ライブラリにビルドされるソースファイルに積極的に取り組んでいる場合、ビルド時間の減速を導入したことです。

ファイルがコンパイルされた後、目次を含め、静的ライブラリ全体を再構築する必要があります。

これはちょうど多くの余分なI/Oです。

静的ライブラリは、安定したコードに最も理にかなっています。

つまり、コードは積極的に変更されていません。

ビルド時間を短縮するために、静的ライブラリからアクティブな開発中のコードを移動することを検討する必要があります。

先ほど、アーカイブからの選択的な読み込みを示しました。

しかし、その欠点は、リンカーの速度を低下させることです。

これは、ビルドを再現可能にし、従来の静的ライブラリのセマンティクスに従うために、リンカーは静的ライブラリを固定されたシリアルオーダーで処理しなければならないためです。

つまり、ld64の並列化の勝利の一部は静的ライブラリでは使用できません。

しかし、この歴史的な行動を本当に必要としない場合は、リンカーオプションを使用してビルドを高速化できます。

そのリンカーオプションは「すべての負荷」と呼ばれます。

リンカーに、すべての静的ライブラリからすべての.oファイルを盲目的に読み込むように指示します。

これは、アプリがとにかくすべての静的ライブラリからほとんどのコンテンツを選択的に読み込む場合に役立ちます。

-All_loadを使用すると、リンカーはすべての静的ライブラリとそのコンテンツを並行して解析できます。

しかし、アプリが同じシンボルを実装する複数の静的ライブラリを持つ巧妙なトリックを行い、どの実装が使用されるかを駆動する静的ライブラリのコマンドラインの順序に依存する場合、このオプションはあなたのためではありません。

リンカーはすべての実装をロードし、必ずしも通常の静的リンクモードで見つかったシンボルセマンティクスを取得するわけではないからです。

-All_loadのもう1つの欠点は、「未使用の」コードが追加されているため、プログラムが大きくなる可能性があることです。

それを補うために、リンカーオプション-dead_stripを使用できます。

このオプションにより、リンカーは到達不能なコードとデータを削除します。

現在、デッドストリッピングアルゴリズムは高速で、通常は出力ファイルのサイズを小さくすることで支払います。

しかし、-all_loadと-dead_stripの使用に興味がある場合は、これらのオプションの有無にかかわらずリンカのタイミングをタイムして、特定のケースの勝利であるかどうかを確認する必要があります。

次のリンカーオプションは-no_exported_symbolsです。

ここに少し背景があります。

リンカーが生成するLINKEDITセグメントの一部は、エクスポートトリエです。これは、エクスポートされたすべてのシンボル名、アドレス、フラグをエンコードするプレフィックスツリーです。

すべてのdylibsはエクスポートされたシンボルを持っている必要がありますが、メインアプリのバイナリは通常、エクスポートされたシンボルを必要としません。

つまり、通常、メイン実行可能ファイルでシンボルを調べるものは何もありません。

その場合は、アプリターゲットに-no_exported_symbolsを使用して、LINKEDITでのトライデータ構造の作成をスキップできます。これにより、リンク時間が改善されます。

しかし、アプリがメイン実行可能ファイルにリンクするプラグインをロードする場合、またはxctestバンドルを実行するためのホスト環境としてアプリでxctestを使用する場合、アプリにはすべてのエクスポートが必要です。つまり、その設定に-no_exported_symbolsを使用することはできません。

今、それが大きい場合にのみ、輸出を抑制しようとすることは理にかなっています。

ここに表示されているdyld_infoコマンドを実行して、エクスポートされたシンボルの数を数えることができます。

私たちが見た1つの大きなアプリには、約100万のシンボルがエクスポートされていました。

そして、リンカーは、その多くのシンボルのエクスポートトライを構築するのに2〜3秒かかりました。

したがって、-no_exported_symbolsを追加すると、そのアプリのリンク時間が2〜3秒短縮されました。

Dyld_infoツールについては、この講演の後半で詳しく説明します。

次のオプションは、-no_deduplicateです。

数年前、同じ命令を持つが異なる名前を持つ関数をマージするために、リンカーに新しいパスを追加しました。

C++テンプレートの拡張では、それらの多くを得ることができることがわかりました。

しかし、これは高価なアルゴリズムです。

リンカーは、重複を探すのを助けるために、すべての関数の命令を再帰的にハッシュしなければなりません。

費用のため、アルゴリズムを制限したので、リンカーは弱い定義のシンボルだけを見ます。

これらは、インライン化されていないテンプレート拡張用にC++コンパイラが発行するものです。

さて、de-dupはサイズの最適化であり、デバッグビルドは高速ビルドに関するものであり、サイズに関するものではありません。

したがって、デフォルトでは、Xcodeはデバッグ設定のリンカに-no_deduplicateを渡すことで、de-dup最適化を無効にします。

また、-O0でclangリンクラインを実行すると、clangはno-dedupオプションをリンカに渡します。

要約すると、C ++を使用してカスタムビルドを使用している場合、つまり、Xcodeで非標準構成を使用するか、他のビルドシステムを使用する場合は、デバッグビルドに-no_deduplicateを追加して、リンク時間を改善する必要があります。

先ほどお話ししたオプションは、実際のコマンドライン引数です。

Xcodeを使用する場合は、製品のビルド設定を変更する必要があります。

ビルド設定内で、「その他のリンカーフラグ」を探します。

-All_loadに設定するものは次のとおりです。

そして、「デッドコードストリッピング」オプションもここにあることに注意してください。

そして、-no_exported_symbolsがあります。

そして、ここに-no_deduplicateがあります。

それでは、静的ライブラリを使用する際に経験するかもしれないいくつかの驚きについて話しましょう。

最初の驚きは、アプリがリンクする静的ライブラリにビルドされるソースコードがあり、そのコードが最終的なアプリに終わらない場合です。

たとえば、ある関数に「使用される属性」を追加したり、Objective-Cカテゴリがあります。

リンカーが選択的にロードするため、静的ライブラリ内のオブジェクトファイルがリンク中に必要なシンボルも定義しない場合、それらのオブジェクトファイルはリンカーによってロードされません。

もう1つの興味深い相互作用は、静的ライブラリとデッドストリッピングです。

デッドストリッピングは、多くの静的ライブラリの問題を隠すことができることが判明しました。

通常、シンボルが欠落したり、シンボルが重複したりすると、リンカーがエラーになります。

しかし、デッドストリッピングにより、リンカーはメインから開始してすべてのコードとデータに到達可能性パスを実行し、不足しているシンボルが到達不能なコードからのものであることが判明した場合、リンカーは不足しているシンボルエラーを抑制します。

同様に、静的ライブラリから重複したシンボルがある場合、リンカーはエラーではなく最初のシンボルを選択します。

静的ライブラリを使用する最後の大きな驚きは、静的ライブラリが複数のフレームワークに組み込まれている場合です。

これらのフレームワークのそれぞれは単独で正常に動作しますが、ある時点で、いくつかのアプリは両方のフレームワークを使用し、ブーム、複数の定義のために奇妙なランタイムの問題が発生します。

最も一般的なケースは、同じクラス名の複数のインスタンスに関するObjective-Cランタイム警告です。

全体として、静的ライブラリは強力ですが、落とし穴を避けるためにそれらを理解する必要があります。

それは静的リンクを締めくくります。

では、ダイナミックリンクに移りましょう。

まず、静的ライブラリとの静的リンクの元の図を見てみましょう。

ソースコードが増えているので、これが時間の経過とともにどのように拡大するかを考えてください。

ますます多くのライブラリが利用可能になるにつれて、エンドプログラムのサイズが大きくなる可能性があることは明らかです。

つまり、そのプログラムを構築するための静的リンク時間も時間の経過とともに増加するということです。

では、これらのライブラリがどのように作られているかを見てみましょう。

もし私たちがこのスイッチをしたらどうなりますか?

「Ar」を「ld」に変更すると、出力ライブラリは実行可能なバイナリになりました。

これは90年代の動的ライブラリの始まりでした。

略語として、動的ライブラリを「dylibs」と呼びます。

他のプラットフォームでは、それらはDSOまたはDLLとして知られています。

では、ここで正確に何が起こっているのですか?

そして、それはスケーラビリティにどのように役立ちますか?

重要なのは、静的リンカが動的ライブラリとのリンクを異なる方法で扱うことです。

ライブラリから最終的なプログラムにコードをコピーする代わりに、リンカーは一種の約束を記録するだけです。

つまり、動的ライブラリから使用されるシンボル名と、実行時にライブラリのパスがどうなるかを記録します。

これはどのように利点ですか?

これは、プログラムのファイルサイズが管理下にあることを意味します。

コードと、実行時に必要な動的ライブラリのリストが含まれているだけです。

プログラムでライブラリコードのコピーを取得しなくなりました。

プログラムの静的リンク時間は、コードのサイズに比例し、リンクするディリブの数とは無関係になります。

また、仮想メモリシステムが輝くようになりました。

複数のプロセスで使用されているのと同じ動的ライブラリを見ると、仮想メモリシステムは、そのdylibを使用するすべてのプロセスで、そのdylibに対して同じ物理ページのRAMを再利用します。

動的ライブラリがどのように始まり、どのような問題を解決するかをお見せしました。

しかし、それらの「利益」の「コスト」は何ですか?

まず、動的ライブラリを使用する利点は、ビルド時間を高速化することです。

しかし、コストは、アプリの起動が遅くなるということです。

これは、起動がもはや1つのプログラムファイルを読み込むだけではないためです。

これで、すべてのディリブも一緒にロードして接続する必要があります。

言い換えれば、ビルド時間から起動時間まで、リンクコストの一部を延期しただけです。

第二に、動的ライブラリベースのプログラムには、より汚いページがあります。

静的ライブラリの場合、リンカはすべての静的ライブラリからすべてのグローバルをメイン実行可能ファイルの同じDATAページに共同配置します。

しかし、dylibsでは、各ライブラリにはDATAページがあります。

最後に、動的リンクのもう一つのコストは、それが何か新しいものの必要性を導入することです:動的リンカー!

ビルド時に実行可能ファイルに記録された約束を覚えていますか？

今、私たちはライブラリをロードするという約束を果たすランタイムで何かが必要です。

ダイナミックリンカーであるdyldはそのためです。

実行時に動的リンクがどのように機能するかを掘り下げてみましょう。

実行可能なバイナリはセグメント、通常は少なくともTEXT、DATA、LINKEDITに分割されます。

セグメントは常にOSのページサイズの倍数です。

各セグメントには異なる権限があります。

たとえば、TEXTセグメントには「実行」権限があります。

つまり、CPUはページ上のバイトをマシンコード命令として扱う可能性があります。

実行時に、dyldはここで示すように、各セグメントの権限を持つメモリに実行可能ファイルをmmap（）しなければなりません。

セグメントはページサイズでページが整列されているため、仮想メモリシステムはプログラムまたはdylibファイルをVM範囲のバッキングストアとして簡単に設定できます。

つまり、これらのページにメモリアクセスがあるまで、何もRAMにロードされません。これにより、ページ障害が発生し、VMシステムがファイルの適切なサブレンジを読み取り、必要なRAMページにその内容を埋めます。

しかし、マッピングだけでは不十分です。

どういうわけか、プログラムは「配線」されているか、dylibにバインドされている必要があります。

そのために、私たちは「フィックスアップ」と呼ばれる概念を持っています。

図では、プログラムが使用するディリブの部分にそのポイントを設定したポインタを持っていることがわかります。

フィックスアップとは何かを掘り下げてみましょう。

これが私たちの友人、mach-oファイルです。

さて、テキストは不変です。

そして実際、それはコード署名に基づくシステムにある必要があります。

では、malloc()を呼び出す関数がある場合はどうなりますか?

それはどのように機能しますか?

_Mallocの相対アドレスは、プログラムがいつ構築されたかを知ることができません。

さて、何が起こるかというと、静的リンカーはmallocがdylibにあるのを見て、コールサイトを変換しました。

コールサイトは、同じTEXTセグメント内のリンカーによって合成されたスタブへの呼び出しになるため、相対アドレスはビルド時に知られているため、BL命令を正しく形成できます。

それが役立つのは、スタブがDATAからポインタをロードし、その場所にジャンプすることです。

現在、実行時にTEXTの変更は必要ありません。DATAだけがdyldによって変更されます。

実際、dyldを理解する秘訣は、dyldによって行われるすべての修正は、DATAにポインタを設定するだけです。

だから、ディルドが行う修正をもっと掘り下げてみましょう。

LINKEDITのどこかには、どのような修正が行われるかを推進するために必要な情報があります。

修正には2種類あります。

1つ目はリベースと呼ばれ、ディリブまたはアプリがそれ自体内を指すポインタを持っているときです。

現在、ASLRと呼ばれるセキュリティ機能があり、dyldはランダムなアドレスでdylibsをロードします。

そして、それは、これらの内部ポインタがビルド時に設定できないことを意味します。

代わりに、dyldは起動時にこれらのポインタを調整または「リベース」する必要があります。

ディスク上では、dylibがアドレスゼロでロードされた場合、これらのポインタにはターゲットアドレスが含まれています。

そうすれば、LINKEDITが記録する必要があるのは、各リベース場所の場所だけです。

Dyldは、ディリブの実際のロードアドレスを各リベース場所に追加するだけで、正しく修正できます。

2番目の種類のフィックスアップはバインドです。

バインドは象徴的な参照です。

つまり、彼らのターゲットは数字ではなくシンボル名です。

例えば、関数「malloc」へのポインタ。

文字列「_malloc」は実際にはLINKEDITに格納され、dyldはその文字列を使用してlibSystem.dylibのエクスポートトリでmallocの実際のアドレスを検索します。

次に、dyldはその値をバインドで指定された場所に格納します。

今年は、私たちが「チェーンフィックスアップ」と呼ぶフィックスアップをエンコードする新しい方法を発表します。

最初の利点は、LINKEDITを小さくすることです。

LINKEDITは、すべての修正場所を保存する代わりに、新しい形式は、最初の修正場所が各DATAページにある場所と、インポートされたシンボルのリストのみを保存するため、より小さいです。

その後、残りの情報は、修正が最終的に設定される場所で、DATAセグメント自体にエンコードされます。

この新しいフォーマットは、修正場所が一緒に「鎖でつながれている」という事実から、チェーン固定と呼ばれる名前を取得します。

LINKEDITは、最初の修正がどこにあったかを述べ、次にDATAの64ビットポインタの場所で、一部のビットには次の修正場所へのオフセットが含まれています。

また、フィックスアップがバインドまたはリベースであるかどうかというビットが詰め込まれています。

バインドの場合、残りのビットはシンボルのインデックスです。

リベースの場合、残りのビットは画像内のターゲットのオフセットです。

最後に、連鎖修正のランタイムサポートは、iOS 13.4以降にはすでに存在します。

つまり、展開ターゲットがiOS 13.4以降である限り、今日からこの新しいフォーマットを使い始めることができます。

そして、連鎖修正フォーマットは、今年発表する新しいOS機能を可能にします。

しかし、それを理解するために、私はディルドがどのように機能するかについて話す必要があります。

Dyldはメインの実行可能ファイルで始まります - あなたのアプリを言ってください。

そのmach-oを解析して、依存するディリブ、つまり必要な約束された動的ライブラリを見つけます。

それはそれらのdylibsとmmap()sを見つけます。

次に、それらのそれぞれについて、mach-o構造を再帰して解析し、必要に応じて追加のディリブをロードします。

すべてが読み込まれると、dyldは必要なすべてのバインドシンボルを調べ、修正を行うときにそれらのアドレスを使用します。

最後に、すべての修正が完了すると、dyldはボトムアップで初期化子を実行します。

5年前、私たちは新しいdyld技術を発表しました。

上記の緑色のステップは、アプリが起動するたびに同じであることに気づきました。

したがって、プログラムとdylibsが変更されない限り、緑色のすべてのステップは最初の起動時にキャッシュされ、その後の起動時に再利用される可能性があります。

今年は、追加のディルドパフォーマンスの改善を発表します。

「ページインリンク」と呼ばれる新しいdyld機能を発表します。

起動時にすべてのディリブにすべてのフィックスアップを適用する代わりに、カーネルはページインでデータページに遅延してフィックスアップを適用できるようになりました。

Mmap()ed領域のあるページでいくつかのアドレスを最初に使用すると、そのページでカーネルが読み込まれることは常にありました。

しかし、今、それがデータページである場合、カーネルはそのページに必要な修正も適用します。

dyld共有キャッシュのOS dylibsの10年以上にわたってページインリンクの特別なケースがありました。

今年はそれを一般化し、誰もが利用できるようにしました。

このメカニズムは、汚れたメモリと起動時間を短縮します。

また、DATA_CONSTページがクリーンであることを意味し、TEXTページと同じように立ち退かして再作成できるため、メモリの圧力が軽減されます。

このページインリンク機能は、iOS、macOS、watchOSの今後のリリースで行われます。

しかし、ページインリンクは、チェーン付きフィックスアップで構築されたバイナリでのみ機能します。

これは、チェーン化されたフィックスアップでは、ほとんどのフィックスアップ情報がディスク上のDATAセグメントにエンコードされるため、ページイン中にカーネルで利用できるためです。

1つの注意点は、dyldは打ち上げ時にのみこのメカニズムを使用することです。

後でdlopen（）されたdylibsは、ページインリンクを取得しません。

その場合、dyldは従来のパスを取り、dlopenコール中にフィックスアップを適用します。

それを念頭に置いて、dyldワークフロー図に戻りましょう。

5年間、dyldは最初の打ち上げでその作業をキャッシュし、後の打ち上げで再利用することで、上記の手順を緑色で最適化してきました。

今、dyldは、実際にフィックスアップを実行せず、カーネルにページインで怠惰に実行させることで、「修正を適用する」ステップを最適化することができます。

Dyldの新機能を見たので、ダイナミックリンクのベストプラクティスについて話しましょう。

ダイナミックリンクのパフォーマンスを向上させるために何ができますか?

先ほど示したように、dyldはすでに動的リンクのほとんどのステップを加速しています。

あなたがコントロールできることの1つは、あなたが持っているディリブの数です。

Dylibsが多ければ多いほど、それらをロードするためにdyldがしなければならない作業が増えます。

逆に、ディリブが少ないほど、ディルドが実行しなければならない作業は少なくなります。

次に見ることができるのは、静的初期化子です。これは、常に実行されるコードです。

たとえば、静的初期化子でI/Oやネットワーキングを行わないでください。

数ミリ秒以上かかる可能性のあるものは、初期化子で行うべきではありません。

ご存知のように、世界はますます複雑になり、ユーザーはより多くの機能を望んでいます。

したがって、ライブラリを使用してすべての機能を管理することは理にかなっています。

あなたの目標は、動的ライブラリと静的ライブラリの間のスイートスポットを見つけることです。

静的ライブラリが多すぎて、反復的なビルド/デバッグサイクルが遅くなります。

一方、動的ライブラリが多すぎて起動時間が遅く、顧客は気づきます。

しかし、今年はld64をスピードアップしたので、より多くの静的ライブラリ、またはより多くのソースファイルをアプリで直接使用し、同じ時間でビルドできるため、スイートスポットが変わった可能性があります。

最後に、インストールベースで機能する場合、新しい展開ターゲットに更新すると、チェーン化された修正を生成し、バイナリを小さくし、起動時間を短縮できます。

最後に皆さんに知ってもらいたいのは、リンクプロセスの中を覗くのに役立つ2つの新しいツールです。

最初のツールはdyld_usageです。

あなたはそれを使って、ディルドが何をしているかの痕跡を得ることができます。

このツールはmacOSのみですが、シミュレーターでのアプリの起動、またはMac Catalyst用に構築されたアプリを追跡するために使用できます。

これは、macOSのテキストエディットに対する実行例です。

上位数行からわかるように、打ち上げは全体で15msかかりましたが、ページインリンクのおかげで、修正には1msしかかかりませんでした。

現在、大部分の時間は静的初期化子に費やされています。

次のツールはdyld_infoです。

ディスクと現在のディルドキャッシュの両方でバイナリを検査するために使用できます。

このツールには多くのオプションがありますが、エクスポートと修正を表示する方法を紹介します。

ここで、-fixupオプションは、dyldが処理するすべての修正場所とそのターゲットを表示します。

ファイルが古いスタイルの修正か新しいチェーン修正かに関係なく、出力は同じです。

ここで、-exportsオプションは、dylibにエクスポートされたすべてのシンボルと、dylibの先頭から各シンボルのオフセットを表示します。

この場合、dyldキャッシュのdylibであるFoundation.frameworkに関する情報が表示されています。

ディスクにファイルはありませんが、dyld_infoツールはdyldと同じコードを使用しているため、それを見つけることができます。

静的ライブラリと動的ライブラリの歴史とトレードオフを理解したので、アプリが何をするかを確認し、スイートスポットを見つけたかどうかを判断する必要があります。

次に、大きなアプリを持っていて、ビルドがリンクするのに時間がかかることに気づいたら、新しいより高速なリンカーを備えたXcode 14を試してみてください。

それでも静的リンクをさらに高速化したい場合は、私が詳述した3つのリンカーオプションを調べて、ビルドで理にかなっているかどうかを確認し、リンク時間を改善してください。

最後に、iOS 13.4以降のアプリと埋め込みフレームワークを構築して、連鎖修正を有効にすることもできます。

次に、iOS 16でアプリが小さく、より速く起動するかどうかを確認します。

見てくれてありがとう、そして素晴らしいWWDCをお過ごしください。