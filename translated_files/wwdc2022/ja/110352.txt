110352

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

みなさん、こんにちは、私はスウィフトコンパイラチームのホリーです。

「Embrace Swift generics」へようこそ。

ジェネリックは、Swiftで抽象的なコードを書くための基本的なツールであり、コードが進化するにつれて複雑さを管理するために不可欠です。

抽象化は、アイデアを特定の詳細から分離します。

コードでは、抽象化が役立つ方法はたくさんあります。

常に使用している可能性のある抽象化の1つの形式は、コードを関数またはローカル変数に因数分解することです。

これは、同じ機能や値を複数回使用する必要がある場合に本当に便利です。

関数に機能を抽出すると、詳細が抽象化され、抽象化を使用するコードは、詳細を繰り返すことなく何が起こっているかという考えを表現することができます。

Swiftでは、具体的なタイプを抽象化することもできます。

異なる詳細を持つすべての同じアイデアであるタイプのセットがある場合は、それらの具体的なタイプのすべてで動作するように抽象的なコードを書くことができます。

今日は、具体的なタイプでコードをモデリングし、一連の具体的なタイプの共通の機能を特定し、それらの機能を表すインターフェイスを構築し、最後に、そのインターフェイスを使用して一般的なコードを書くことに飛び込みます。

ファームをシミュレートするためのコードを構築しながら、Swiftの抽象化ツールを掘り下げます。

では、いくつかの具体的なタイプを書くことから始めましょう。

「カウ」と呼ばれる1つの構造体から始めます。

牛には、ヘイ型のパラメータを受け入れる「食べる」というメソッドがあります。

干し草は別の構造体です。

それは、アルファルファである干し草を生産する作物を育てるために「栽培」と呼ばれる静的な方法を持っています。

アルファルファ構造体には、アルファルファの例から干し草を収穫する方法があります。

最後に、牛に餌をやる方法を持つ「農場」と呼ばれる構造体を追加します。

飼料方法は、最初に干し草を生産するためにいくつかのアルファルファを栽培し、次に干し草を収穫し、最後に牛に干し草を与えることによって実装することができます。

そして今、私は農場で牛に餌をやることができます。

しかし、私はより多くの種類の動物を追加したいです。

馬や鶏のような他の動物を表すために、より多くの構造を追加することができます。

そして、農場で牛、馬、鶏に餌をやれるようになりたいです。

フィードメソッドをオーバーロードして、各タイプのパラメータを別々に受け入れることができますが、各オーバーロードには本当に同様の実装があります。

より多くの種類の動物を追加すると、これは余分なボイラープレートになり、とにかくほとんどが繰り返されるコードです。

反復的な実装で過負荷を書くことに気づいたら、それは一般化する兆候かもしれません。

基本的に、異なる種類の動物が機能的に似ているため、これらの実装は非常に似ています。

次のステップは、動物の種類間の共通の能力を特定することです。

私たちは、あらゆる種類の食べ物を食べる能力を持つ動物タイプのセットを構築しました。

動物の各タイプは異なる食べ方を持っているので、食べ方の各実装には行動の違いがあります。

私たちがやりたいことは、抽象コードがeatメソッドを呼び出すことを可能にし、その抽象コードが動作している具体的なタイプに応じて異なる動作をすることです。

抽象コードが具体的なタイプによって異なる動作をする能力は「多型」と呼ばれます。

多相性により、コードの使用方法に応じて、1つのコードが多くの動作を持つことができます。

適切に、多型自体はさまざまな形で来ます。

1つ目は関数のオーバーロードで、同じ関数呼び出しは引数の種類によって異なる意味を持ちます。

オーバーロードは、実際には一般的な解決策ではないため、「アドホック多型」と呼ばれています。

オーバーロードがどのように反復的なコードにつながるかを見ました。

次はサブタイプポリモーフィズムで、スーパータイプで動作するコードは、実行時にコードが使用している特定のサブタイプに基づいて異なる動作を持つことができます。

最後に、ジェネリックを使用して達成されるパラメトリック多型があります。

汎用コードは、型パラメータを使用して、異なる型で動作する1つのコードを書き込むことができ、具体的な型自体が引数として使用されます。

すでに過負荷を除外したので、サブタイプ多型を使ってみましょう。

サブタイプ関係を表す1つの方法は、クラス階層です。

「動物」というクラスを紹介することができます。

次に、各動物の種類を構造体からクラスに変更します。

各特定の動物クラスは、動物のスーパークラスを継承し、食べる方法を上書きします。

今、私たちはすべての特定の動物タイプを表すことができる抽象的なベースクラスの動物を持っています。

Animalクラスでeatを呼び出すコードは、サブタイプ多型を使用してサブクラスの実装を呼び出します。

しかし、私たちはまだ終わっていません。

私たちはまだAnimalのeatメソッドのパラメータタイプを記入しておらず、このコードには他にもいくつかの赤旗があります。

まず、クラスを使用すると、異なる動物のインスタンス間で状態を共有する必要がない、または共有したくない場合でも、参照セマンティクスを余儀なくされました。

この戦略では、サブクラスが基本クラスのメソッドを上書きすることも必要ですが、これを行うのを忘れることはランタイムまでキャッチされません。

しかし、この抽象化モデルのより大きな問題は、各動物のサブタイプが異なる種類の食物を食べることであり、この依存性はクラス階層で表現するのが本当に困難です。

私たちが取ることができる1つのアプローチは、メソッドにAnyのようなあまり具体的ではないタイプを受け入れてもらうことです。

しかし、この戦略は、実行時に正しい型が渡されたことを確認するために、サブクラスの実装に依存しています。

そのため、オーバーライドされた各方法で余分なボイラープレートを課しましたが、さらに重要なことに、誤って間違った種類の食品を渡すことができ、実行時にしかキャッチできない別のバグが残ります。

では、何か他のことを試してみましょう。

代わりに、動物のスーパークラスにタイプパラメータを導入することで、動物の飼料タイプをタイプセーフな方法で表現することができます。

このタイプパラメータは、各サブクラスの特定のフィードタイプのプレースホルダとして機能します。

このアプローチでは、食品タイプのパラメータを動物クラスの宣言に昇格させる必要があります。

動物は操作するために食べ物を必要としますが、食べ物を食べることは動物の中核的な目的ではなく、動物で動作する多くのコードはおそらく食べ物をまったく気にしないので、これは少し不自然に思えます。

それにもかかわらず、動物クラスへのすべての参照は、食品の種類を指定する必要があります。

たとえば、各動物サブクラスは、継承句の角括弧で食品タイプを明示的に指定する必要があります。

動物クラスの各使用サイトのこのボイラープレートは、各動物に固有のタイプを追加すると、面倒になる可能性があります。

だから、ここでの私たちのアプローチはどれも良い人間工学や適切な意味論を持っていません。

根本的な問題は、クラスがデータ型であり、スーパークラスを複雑化して、具体的なタイプに関する抽象的なアイデアを表すようにすることです。

代わりに、機能がどのように機能するかの詳細なしに、タイプの機能を表すように設計された言語構造が必要です。

動物には2つの共通の能力があります。

各動物は、その食品の一部を消費するための操作とともに、特定の種類の食品を持っています。

これらの機能を表すインターフェースを構築できます。

Swiftでは、これはプロトコルを使用して行われます。

プロトコルは、適合型の機能を記述する抽象化ツールです。

プロトコルを使用すると、タイプが何をするかについてのアイデアを実装の詳細から分離できます。

タイプが何をするかについてのアイデアは、インターフェイスを通じて表現されます。

動物の機能をプロトコルインターフェースに翻訳しましょう。

プロトコルの名前は、私たちが説明しているタイプのカテゴリを表しているので、私はこのプロトコルを「動物」と呼びました。

各機能はプロトコル要件にマッピングされます。

特定の種類の食品は、関連するタイプの動物プロトコルにマッピングされます。

型パラメータと同様に、関連する型は具体的な型のプレースホルダとして機能します。

関連するタイプを特別なものにしているのは、プロトコルに準拠した特定のタイプに依存することです。

この関係は保証されているので、特定の種類の動物の各インスタンスは常に同じ種類の食べ物を持っています。

次に、食品を消費する操作は、方法にマッピングされます。

この方法は「食べる」と呼ばれ、動物の飼料タイプのパラメータを受け入れます。

プロトコルにはこの方法の実装がなく、実装には具体的な動物タイプが必要です。

動物プロトコルがわかったので、それぞれの具体的な動物タイプをそれに適合させることができます。

宣言または拡張でプロトコル適合性を持つ具体的なタイプに注釈を付けることができます。

プロトコルはクラスに限定されないため、構造体、列挙型、アクターを含むプロトコルも使用できます。

この適合性アノテーションを書くと、コンパイラは具体的な型が各プロトコル要件を実装していることを確認します。

各動物タイプはeatメソッドを実装する必要があり、コンパイラはパラメータリストで使用されるため、フィードタイプが何であるかを推測できます。

フィードタイプは、タイプエイリアスを使用して明示的に書き込むこともできます。

私たちは、動物の共通の能力をうまく特定し、プロトコルインターフェースを使用してそれらの能力を表現しました。

今、私たちは一般的なコードを書き始めることができます。

動物プロトコルを使用して、農場で飼料方法を実装することができます。

私たちは、すべての具体的な動物タイプで動作する1つの実装を書きたい。

パラメトリック多型を使用し、メソッドが呼び出されたときに具体的な型に置き換えられる型パラメータを導入します。

型パラメータは、関数名の後に角括弧で記述されます。

通常の変数や関数パラメータと同様に、タイプパラメータに好きな名前を付けることができます。

そして、他のタイプと同様に、その名前を使用して、関数の署名全体でtypeパラメータを参照できます。

ここでは、「A」という型パラメータを宣言し、動物関数パラメータの型としてAを使用しました。

私たちは常に具体的な動物タイプが動物プロトコルに準拠していることを望んでいるので、プロトコル適合性でタイプパラメータに注釈を付けます。

プロトコル適合性は、山括弧で書くことも、末尾の「where」句で書くこともできます。ここでは、異なる型パラメータ間の関係を指定することもできます。

名前付き型パラメータと末尾の「where」句は、洗練された要件と型関係を書くことができるため、本当に強力です。

しかし、ほとんどの一般的な機能は、この一般性を必要としません。

フィード方法に焦点を当てましょう。

型パラメータAはパラメータリストに一度表示され、「where」句は型パラメータの適合要件を一覧表示します。

この場合、型パラメータに名前を付け、「where」句を使用すると、メソッドが実際よりも複雑に見えます。

この一般的なパターンは本当に一般的なので、それを表現する簡単な方法があります。

型パラメータを明示的に書く代わりに、「some Animal」と書くことで、この抽象型をプロトコル適合性の観点から表現できます。

この宣言は前の宣言と同じですが、それらが提供する表現力を必要としなかったため、不要な型パラメータリストと「where」句はなくなりました。

「いくつかの動物」を書くことは、構文ノイズを減らし、パラメータ宣言に動物パラメータに関する意味情報が含まれているため、より簡単です。

動物の構文を分解しましょう。

「Some Animal」の「some」は、あなたが作業している特定のタイプがあることを示しています。

「Some」キーワードの後には常に適合要件が続きます。

この場合、特定のタイプはAnimalプロトコルに準拠する必要があります。これにより、Animalプロトコルの要件をパラメータ値に使用できます。

「Some」キーワードは、パラメータと結果タイプで使用できます。

以前にSwiftUIコードを書いたことがある場合は、すでに「some View」を使用して結果位置に「some」を使用しています。

「いくつかのビュー」の結果タイプはまったく同じ概念です。

SwiftUIビューでは、ボディプロパティは特定のタイプのビューを返しますが、ボディプロパティを使用するコードは、特定のタイプが何であるかを知る必要はありません。

特定の抽象的なタイプの概念をよりよく理解するために、一歩下がってみましょう。

特定の具体的なタイプのプレースホルダを表す抽象型は、不透明な型と呼ばれます。

置換される特定のコンクリートタイプは、基礎となるタイプと呼ばれます。

不透明な型の値の場合、基礎となる型は値のスコープに対して固定されます。

このようにして、値を使用するジェネリックコードは、値にアクセスするたびに同じ基礎となる型を取得することが保証されます。

「Some」キーワードと山括弧内の名前付きtypeパラメータを使用する型は、どちらも不透明な型を宣言します。

不透明な型は、入力と出力の両方に使用できるため、パラメータ位置または結果位置で宣言できます。

関数の矢印は、これらの位置の境界線です。

不透明なタイプの位置は、プログラムのどの部分が抽象タイプを見て、プログラムのどの部分が具体的なタイプを決定するかを決定します。

名前付き型パラメータは常に入力側で宣言されるため、呼び出し先が基礎となる型を決定し、実装は抽象型を使用します。

一般に、不透明なパラメータまたは結果タイプの値を提供するプログラムの一部が基礎となるタイプを決定し、値を使用するプログラムの一部は抽象タイプを見ます。

パラメータと結果値に関する直感に従って、これがどのように機能するかを掘り下げてみましょう。

基礎となる型は値から推測されるため、基礎となる型は常に値と同じ場所から来ています。

ローカル変数の場合、基礎となる型は代入の右側の値から推測されます。

これは、不透明な型のローカル変数が常に初期値を持たなければならないことを意味します。そして、あなたがそれを提供しない場合、コンパイラはエラーを報告します。

基礎となるタイプは変数のスコープに合わせて固定する必要があるため、基礎となるタイプを変更しようとするとエラーも発生します。

不透明なタイプのパラメータの場合、基礎となるタイプはコールサイトの引数値から推測されます。

パラメータ位置に「some」を使用することは、Swift 5.7では新しいことです。

基礎となるタイプは、パラメータのスコープに対してのみ固定する必要があるため、各呼び出しは異なる引数タイプを提供できます。

不透明な結果型の場合、基礎となる型は実装の戻り値から推測されます。

不透明な結果型を持つメソッドまたは計算されたプロパティは、プログラム内のどこからでも呼び出すことができるので、この名前付き値の範囲はグローバルです。

これは、基礎となるリターンタイプがすべてのリターンステートメントで同じでなければならないことを意味します。そうでない場合、コンパイラは基礎となるリターン値の型が一致しないというエラーを報告します。

不透明なSwiftUIビューの場合、ViewBuilder DSLはコントロールフローステートメントを変換して、ブランチごとに同じ基礎となるリターンタイプを持つことができます。

したがって、この場合、ViewBuilder DSLを使用して問題を解決できます。

メソッドに@ViewBuilderアノテーションを書き、リターンステートメントを削除すると、ViewBuilderタイプによって結果が構築されます。

feedAnimalメソッドに戻りましょう。

他の場所で不透明なタイプを参照する必要がないため、パラメータリストで「一部」を使用できます。

関数シグネチャで不透明なタイプを複数回参照する必要がある場合は、名前タイプのパラメータが便利です。

たとえば、「ハビタット」と呼ばれる動物プロトコルに別の関連タイプを追加すると、特定の動物の農場に生息地を構築できるようになるかもしれません。

この場合、結果タイプは特定の動物タイプに依存するため、パラメータタイプとリターンタイプにタイプパラメータAを使用する必要があります。

不透明なタイプを複数回参照する必要があるもう1つの一般的な場所は、ジェネリックタイプです。

コードは、多くの場合、ジェネリック型に型パラメータを宣言し、格納されたプロパティに型パラメータを使用し、再びメンバーワイズ初期化子で宣言します。

異なるコンテキストでジェネリック型を参照するには、型パラメータを角括弧で明示的に指定する必要があります。

宣言の山括弧は、ジェネリック型の使用方法を明確にするのに役立つため、不透明な型は常にジェネリック型に名前を付ける必要があります。

では、フィードメソッドの実装を構築しましょう。

動物パラメータのタイプを使用して、飼料関連タイプを介して成長する作物タイプにアクセスできます。

Feed.grow() を呼び出して、このタイプのフィードを生成する作物のインスタンスを取得します。

次に、作物から農産物を収穫する必要があります。これは、「収穫」と呼ばれる作物タイプによって提供されるメソッドを呼び出すことによって行うことができます。

そして最後に、私たちはこの農産物を動物に与えることができます。

基礎となる動物型は固定されているため、コンパイラは、さまざまなメソッド呼び出しにわたる植物型、農産物型、および動物型の関係を知っています。

これらの静的な関係は、私たちが動物に間違った種類の食べ物を与えるという間違いを犯すのを防ぎます。

この動物の正しい食品タイプであることが保証されていないタイプを使用しようとすると、コンパイラが教えてくれます。

動物飼料タイプとその植物の関係を表現するために、他の農場プロトコルがどのように作られたかを学ぶには、「Swiftでプロトコルインターフェイスを設計する」をチェックしてください。

最後に、すべての動物に餌をやる方法を追加しましょう。

配列を受け入れるfeedAllというメソッドを追加します。

要素タイプが動物プロトコルに準拠する必要があることは知っていますが、配列がさまざまな種類の動物を保存できるようにしたいです。

動物がここで私たちを助けることができるかどうか見てみましょう。

「いくつか」には、変化できない特定の基礎となるタイプがあります。

基礎となる型は固定されているため、配列内のすべての要素が同じ型を持つ必要があります。

だから、私は異なる動物の種類を保持できる配列が欲しいので、いくつかの動物の配列は正しいことを表現しません。

ここでは、あらゆる種類の動物を表現できるスーパータイプが本当に必要です。

「どんな動物でも」と書くことで、任意の種類の動物を表現することができます。

「Any」キーワードは、このタイプが任意のタイプの動物を保存でき、基礎となる動物の種類が実行時に異なる可能性があることを示しています。

「Some」キーワードと同様に、「any」キーワードには常に適合要件が続きます。

任意の動物は、任意の具体的な動物タイプを動的に格納する機能を持つ単一の静的型であり、値型のサブタイプ多型を使用することができます。

この柔軟なストレージを可能にするために、どの動物タイプもメモリに特別な表現を持っています。

この表現は箱のように考えることができます。

時々、値は箱の中に直接収まるほど小さいです。

また、他の値はボックスには大きすぎるので、値を他の場所に割り当てる必要があるため、ボックスはその値へのポインタを格納します。

任意の具体的な動物タイプを動的に格納できる動物の静的タイプは、正式には実存タイプと呼ばれます。

そして、異なる具体的なタイプに同じ表現を使用する戦略は「タイプ消去」と呼ばれます。

コンクリートタイプはコンパイル時に消去されると言われ、コンクリートタイプは実行時にのみ知られています。

実存タイプのこれら2つのインスタンスは、どの動物も同じ静的タイプですが、動的タイプは異なります。

タイプ消去は、異なる動物値間のタイプレベルの区別を排除し、異なる動的タイプの値を同じ静的タイプとして交換可能に使用できるようにします。

型消去を使用して、値型の異種配列を書くことができます。これはまさにfeedAllメソッドに望むものです。

したがって、任意の動物の配列をパラメータタイプとして使用します。

関連するタイプのプロトコルに「any」キーワードを使用することは、Swift 5.7で新しく追加されたものです。

feedAllメソッドを実装するには、まず動物の配列を反復します。

動物ごとに、動物のプロトコルから食べる方法を呼び出したい。

このメソッドを呼び出すには、この反復で基礎となる動物の特定の飼料タイプを取得する必要があります。

しかし、任意の動物で食べるとすぐに、コンパイラエラーが発生します。

特定の動物タイプ間のタイプレベルの区別を排除したため、関連するタイプを含む特定の動物タイプに依存するすべてのタイプ関係も排除しました。

だから、この動物がどんな種類の飼料を期待しているかはわかりません。

タイプ関係に頼るには、特定のタイプの動物が固定されているコンテキストに戻る必要があります。

任意の動物に直接食べるを呼び出す代わりに、いくつかの動物を受け入れる飼料方法を呼び出す必要があります。

現在、任意のAnimalは一部のAnimalとは異なるタイプですが、コンパイラは、基礎となる値をボックス化解除して一部のAnimalパラメータに直接渡すことで、AnimalのインスタンスをAnimalに変換できます。

この開梱引数の機能は、Swift 5.7で新しいものです。

ボックス化解除は、コンパイラがボックスを開き、内部に格納されている値を取り出すと考えることができます。

一部のAnimalパラメータの範囲では、値は固定された基礎となる型を持つため、関連する型へのアクセスを含む、基礎となる型に関するすべての操作にアクセスできます。

これは、必要なときに柔軟なストレージを選択できると同時に、関数の範囲の基礎となるタイプを修正することで、静的タイプシステムの完全な表現力を持つコンテキストに戻ることができるため、本当にクールです。

そして、ほとんどの場合、Animalでプロトコルメソッドを呼び出すことが実際に基礎となるタイプのメソッドを呼び出すのと同様に、期待どおりに機能するため、ボックス化解除について考える必要はありません。

したがって、各動物を飼料方法に渡すことができ、各反復で特定の動物に餌を与えるために適切な作物を栽培して収穫することができます。

このプロセスを通して、私たちは「いくつか」と「どれでも」が異なる能力を持っているのを見てきました。

「いくつか」では、基礎となるタイプが固定されています。

これにより、ジェネリックコードの基礎となるタイプへのタイプ関係に頼ることができるため、作業中のプロトコルのAPIと関連タイプに完全にアクセスできます。

任意の具体的なタイプを格納する必要がある場合は、「any」を使用してください。

「Any」は型消去を提供します。これにより、異種コレクションを表現し、基礎となる型の欠如を表し、オプションを使用し、抽象化を実装の詳細にします。

一般に、デフォルトで「some」と書き、任意の値を保存する必要があることがわかっている場合は、「some」を「any」に変更します。

このアプローチでは、タイプ消去のコストとその意味的な制限は、それが提供するストレージの柔軟性が必要な場合にのみ支払うことができます。

このワークフローは、突然変異が必要であることがわかるまで、デフォルトでlet-constantsを書くのと似ています。

このセッションでは、コードが進化し、より多くの機能を得るにつれて、コードを一般化するワークフローを説明しました。

私たちは具体的なタイプを書くことから始めました。

コードがより多くの機能を得るにつれて、私たちは異なる具体的なタイプ間の繰り返しに気づきました。

そこから、共通の機能を特定し、プロトコルを使用して一般化しました。

最後に、「some」と「any」を使用して抽象的なコードを書き、より表現力豊かなコードのために「some」を好むことについて話し合いました。

プロトコルの作成とタイプの消去の理解を深く掘り下げるには、「Swiftでプロトコルインターフェイスを設計する」をチェックしてください。

参加してくれてありがとう、素晴らしいWWDCをお過ごしください。

♪