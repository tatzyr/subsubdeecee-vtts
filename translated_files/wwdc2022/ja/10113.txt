10113

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

こんにちは、私の名前はデニスで、ここアップルのディスプレイとカラーテクノロジーチームの一員です。

今日は、EDRに関するいくつかのエキサイティングなアップデートと、iOS開発者への影響を探ります。

昨年のプレゼンテーションを見たことがあるなら、すでにEDRに精通しているかもしれませんが、短い要約として、EDRは拡張ダイナミックレンジを指し、AppleのHDR技術です。

EDRは、レンダリング技術とピクセル表現の両方を指し、EDRのピクセル表現は、標準とハイダイナミックレンジの両方のコンテンツを一貫して表しているため、特に重要です。

よく露出したコンテンツでは、被写体（この例では、キャンパー）は画像の標準ダイナミックレンジ内に収まるはずですが、キャンプファイヤーなどの鏡面および発光ハイライトはより高い範囲に収まるでしょう。

標準範囲表現では、これらの要素は最終的にクリップされますが、EDRでは表現可能なままです。

他のピクセル表現は固定範囲の輝度値を表すように設計されていますが、EDRの表現は本当に動的で、任意の値を記述することができます。

さらに、未使用のバックライトを利用することで、EDRはディスプレイのピークに関係なく、あらゆるディスプレイが高ダイナミックレンジのコンテンツをレンダリングできるようにします。

そして、HDRコンテンツがはるかに普及し、アクセスしやすくなるにつれて、macOSでEDRを採用しているアプリケーションのリストもそうです。

「Baldur's Gate 3」、「Divinity: Original Sin 2」、「Shadow of the Tomb Raider」は、すでにmacOSのEDRで出荷されています。

EDRを採用することで、ゲームはより明るく、より飽和した色をレンダリングするだけでなく、よりリアルな照明、反射、よりカラフルなコンテンツを生成することができます。

明るい要素がSDRピークホワイトに限定される場合、EDRでは、著者が意図したように活気と深さを取り戻します。

EDRは、SafariやQuickTimeプレーヤーなど、Appleのエコシステム全体に統合されています。

その結果、Apple TVやNetflixなどのビデオオンデマンドアプリやサービスは、増え続けるHDR10、ドルビービジョン、ProResコンテンツのカタログを消費者に配信することができます。

EDRを採用したプロアプリは、HDRの静止画やビデオを正確に編集、グレーディング、マスター、レビューするためのさまざまなプロフェッショナルなワークフローを提供することで、ユーザーが素晴らしいHDRコンテンツを作成できるようにします。

macOSでのEDRの採用に関するすべての興奮で、私たちはEDRにいくつかの新しいアップデートをもたらすことに興奮しています。

まず第一に、EDR APIがiOSとiPadOSで利用可能になったことをお知らせします。

さらに、プロユーザーをサポートするAppleの取り組みの一環として、今年はLiquid Retina XDRディスプレイを搭載した12.9インチiPad Proに2つの新しいプロカラー機能を導入します。

サイドカーを上るリファレンスモードとEDRレンダリング。

リファレンスモードは、macOSのリファレンスプリセットと同様に、さまざまな一般的なビデオフォーマットのリファレンスレスポンスを提供することで、カラーグレーディング、編集、コンテンツレビューなどのカラークリティカルなワークフローを可能にするように設計された新しいディスプレイモードです。

これを行うには、リファレンスモードはSDRのピーク輝度を100ニト、HDRのピーク輝度を1000ニトに固定し、10倍のEDRヘッドルームを与えます。

リファレンスモードは、マッピングを表示するための1対1のメディアも提供します。

また、True Tone、Auto-Brightness、Night Shiftなど、アンビエントサラウンドのすべてのダイナミックディスプレイ調整を無効にし、代わりにユーザーが手動でホワイトポイントを細かく調整できるようにします。

このようにして、ディスプレイはそれぞれの仕様で説明されているとおりに色を生成します。

このチャートは、参照モードがサポートするフォーマットのリストを提供します。

macOSの参照プリセットとは異なり、参照モードは、最も一般的な5つのHDRおよびSDRビデオフォーマットをサポートする単一のトグルであり、メディアタイプ間で一貫した参照応答を提供することに注意してください。

そして、この表に記載されていない形式のコンテンツがある場合でも心配しないでください。

サポートされていないフォーマットは、デフォルトの表示モードと同様にカラー管理されます。

例として、リファレンスモードでのLumaFusionを見てみましょう。

iOSでリファレンスモードを有効にすることで、LumaFusionはビデオポストプロダクションのためのより強力なツールになります。

HDRビデオを表示する場合、1000ニトピークまでのP3色域内の色が正確にレンダリングされるため、ユーザーは自分のビデオが常に正しく一貫して表示されていることを確信できます。

リファレンスモードとLumaFusionの新しいビデオスコープ機能の組み合わせにより、iPad Proでカラークリティカルなワークフローが可能になりました。

参照モードを無効にすると、EDRヘッドルームは動的に変化する可能性があり、iOSがビデオの明るさを変調するので、ここで見ることができます。

ユーザーはLumaFusionプロジェクトをXMLとしてエクスポートすることができ、他の人気のあるMacポストプロダクションアプリでインポートすることができ、コンテンツクリエイターのチームが両方のプラットフォームで簡単にコラボレーションできます。

LumaFusionがリファレンスモードを採用し、プロのコンテンツクリエイターにもたらす価値と柔軟性を見るのはとてもエキサイティングです。

しかし、リファレンスモードだけが新機能ではありません。

2019年には、MacユーザーがiPadをセカンダリディスプレイとして使用できる技術であるSidecarを導入しました。

そして今、リファレンスモードの導入により、SidecarでのEDRレンダリングのサポートが追加されています。これは、リファレンスモードがリファレンスグレードのSDRとHDRコンテンツをサポートするために有効になっているときにSidecarの機能を拡張し、プロのコンテンツクリエイターがiPad ProをAppleシリコンMacのセカンダリリファレンスディスプレイとして使用できるようにします。

言うまでもなく、サイドカーでレンダリングされたコンテンツは、参照モードでネイティブiOSと同じビデオフォーマットの参照応答を提供します。

たとえば、HDRビデオプリセットでMacでレンダリングされたこのHDR10テストパターンを見て、Sidecarを使用したiPad Proのレンダリングと比較しましょう。

この構成では、両方のデバイスがP3カラーとD65ホワイトポイントのリファレンスディスプレイとして機能します。

P3のプライマリカラーバーとセカンダリカラーバーからわかるように、MacとiPadの両方が予想と同様の反応を生み出します。

さらに、両方の構成は1000ニトのピーク輝度をサポートし、グラデーションに見られるように、これらの値は忠実にレンダリングされ、1000ニトを超える値はクリップされます。

私たちは、サイドカーをレンダリングするEDRがプロユーザーにもたらす見通しと新しい機会に興奮しています。

また、より多くの開発者が独自のアプリでEDRを採用することで、これらの機能を利用することを楽しみにしています。

そのメモでは、EDRレンダリングを独自のiOSおよびiPadOSアプリに統合する方法を探りましょう。

まず、EDRのピクセル表現とレンダリングパイプラインの影響を見てみましょう。

伝統的に、SDRの浮動小数点表現は0対1の範囲の値で、0は黒、1はSDRは白でした。

EDRでは、SDRコンテンツは依然として0から1の範囲で表されますが、1を超える値はSDRよりも明るいコンテンツを表します。

EDRは線形空間で表されることに注意してください。これは、2.0 EDRが1.0の2倍明るくないことを意味します。

他のHDRフォーマットとは異なり、EDRは0から1の範囲に値をトーンマップせず、これはレンダリングにいくつかの意味があります。

その点で、EDRはSDRコンテンツ、または0から1までの値が常にレンダリングされることを保証します。

そして、1を超える値は、現在のEDRヘッドルームにトーンマッピングすることなく適切にレンダリングされます。

ただし、より明るい値はクリップされます。

当初、この動作は不可能に思えるかもしれませんが、HDRで制作されたコンテンツは、従来の表現のように明るすぎるハイライトで、可能な限り意図に近くレンダリングされることを意味します。

明らかに、ヘッドルームが高ければ高いほど、コンテンツはより明るく、よりダイナミックになります。

しかし、私たちはどのくらいのヘッドルームを持っていますか?

さて、瞬間的なEDRヘッドルームは動的値であり、デバイスの特定のディスプレイ技術や現在のディスプレイの明るさを含むがこれらに限定されない多くの要因に基づいていることに注意してください。

しかし、単純化しすぎとして、現在のEDRヘッドルームは、ディスプレイの最大輝度を現在のSDR輝度で割った値とほぼ同じです。

先ほど、リファレンスモードが10倍のEDRヘッドルームを提供すると言ったのは、EDR 1.0（またはSDRの明るさ）を100ニトに固定し、HDRのピーク輝度を1000ニトに修正したからです。

したがって、1000ニトを100ニトで割ると、EDRの10倍の一定のヘッドルームが得られます。

この表は、さまざまなデバイスとその最大潜在的なヘッドルームの例をもう少し示します。

これは潜在的なヘッドルームであり、真のヘッドルームは、現在のディスプレイの明るさを含む他のさまざまな要因に依存することに注意してください。

この講演の後半では、ヘッドルームについてさらに詳しく説明し、ヘッドルームを照会して使用してレンダリングについて情報に基づいた決定を下す方法の例を紹介します。

しかし、今のところ、あなたはEDRとあなたがそれを望むときによく理解しているはずです。

それでは、実際にいくつかのEDRコンテンツをレンダリングするようにギアをシフトしましょう。

このセクションでは、HDRコンテンツをレンダリング可能な形式に読み取る方法について説明します。

私たちが取り上げる特定の例は、イメージI/Oワークフローですが、別のフレームワークをお探しの場合は、今年の他のEDRトークの1つをご覧ください。

静止メディアの場合は、読み込む画像ファイルから始めます。

この画像は通常、二平面YUV空間でエンコードされます。

最初に読み込むと、画像とバッファは元の形式になります。

残念ながら、その形式では、意味のある方法で画像を解釈して作業するのは難しい場合があります。

したがって、CGBitmapContextの助けを借りて、画像をデコードしてより使用可能な形式に変換します。

その時点で、コンテキストのバッキングピクセルデータからMTLTextureを作成し、Metalエンジンでレンダリングすることができます。

より具体的には、これを達成するためには、4つのステップをカバーする必要があります。

まず、HDR静止画用のCGImageを作成し、そのCGImageをビットマップコンテキストに描画し、Metalテクスチャを作成し、最後に、ビットマップのデータを新しく作成されたテクスチャにロードします。

最初のステップでは、画像を読んで、少しセットアップを行います。

まず、URLからCGImageSourceに画像を読み込み、そのソースからCGImageを作成します。

この場合、nilオプション辞書を渡して画像を作成しました。

ただし、特定のHDRフォーマットの浮動小数点バッファをご希望の場合は、設定したい新しいkCGImageSourceShouldAllowFloatオプションがあります。

次に、CGBitmapInfoをインスタンス化します。

この場合、事前に乗算されたアルファで16ビットの浮動小数点コンテキストを作成しています。

メタルテクスチャを同じフォーマットにしたいので、これを覚えておいてください。

次に、作成したビットマップ情報とCGImageの幅と高さを使用して、CGBitmapContextを構築します。

コンテキストの色空間は、レンダリングするCAMetalLayerの色空間と一致するようにしたいことに注意してください。

それ以外の場合は、適切なカラーマネジメントを自分で実行する必要があります。

最後に、CGImageをビットマップコンテキストに描画します。

この時点で、コンテキストからメタルテクスチャの作成に進むことができます。

メタルテクスチャを作成するには、まずMTLTextureDescriptorをインスタンス化します。

以前から、ビットマップコンテキストにハーフフロートを使用することを選択したことを思い出してください。しかし、EDRをレンダリングするときは、10ビットの青、緑、赤、2ビットアルファの32ビットパックピクセル形式で2Dテクスチャを持つこともできます。

次のセクションで詳しく説明しますが、今のところ、テクスチャのピクセル形式がコンテンツのピクセル形式と一致する必要があることを知るだけで十分です。私たちの場合、ハーフフロートです。

この時点で、メタルレイヤーのデバイスと新しく作成されたテクスチャ記述子でテクスチャをインスタンス化します。

最後に、ビットマップコンテキストからデータを入手し、テクスチャにコピーします。

それにより、レンダリングのためにMetalパイプラインに送信できるEDR値を含むMetalテクスチャがあります。

このセクションでは、URLから始めてメタルテクスチャまで、HDR静止画を調達するためのサンプルワークフローを取り上げました。

次に、iOSとiPadOSでそのようなテクスチャをレンダリングするために必要な最小限のコード変更について確認します。

新しいiOSおよびiPadOS APIでEDRを選択するプロセスは、macOSのプロセスと同じです。

したがって、アプリのmacOSビルドのEDRサポートがすでにある場合は、変更を加える必要はありません。

EDRにオプトインするには、CAMetalLayerを使用していることを確認し、そのレイヤーに適切なフラグとタグを設定し、サポートされているEDR形式で明るいコンテンツがあることを確認する必要があります。

まず、コンテンツをレンダリングするCAMetalLayerを取ります。

そのレイヤーでは、 wantsExtendedDynamicRange Content フラグを有効にします。

次に、同じレイヤーで、ピクセルフォーマットとCGColorSpaceのサポートされている組み合わせを設定する必要があります。

コンテンツの種類とソース方法によって、特定のピクセル形式と色空間が異なります。

私たちの場合、画像を16ビットの浮動小数点バッファにロードし、ここでは拡張リニアディスプレイP3色空間と一致させることを選択しました。

iOSは、線形色空間と組み合わせた16ビット浮動小数点ピクセルバッファでのEDRのレンダリングをサポートしています。

ただし、これらの組み合わせのいずれかを使用する場合は、必ず色空間の拡張バリアントを使用してください。

そうしないと、コンテンツはSDRにクリップされます。

iOsは、先に簡単に述べた10ビットパックされたBGRAピクセルバッファもサポートしています。

このようなバッファは、このチャートで概説されているように、PQまたはHLG色空間のいずれかでレンダリングするためにサポートされています。

このセクションでは、 wantsExtendedDynamicRangeContentフラグや、EDRをサポートするさまざまなピクセル形式や色空間など、EDRレンダリングをサポートするためにレンダリングレイヤーに必要な最小限のコード変更を取り上げました。

この時点で、Metalテクスチャをレンダリングする場合、前のセクションからこのセクションのCAMetalLayerに供給すると、EDRをレンダリングします。

しかし、私たちができるトリックがいくつかあります。

概要で述べたように、EDRのデフォルトの動作は、現在のEDRヘッドルームにクリップすることです。

ヘッドルームがEDRコンテンツのレンダリングを正当化するのに十分な高さではないと判断し、代わりにSDRパスを下る場合があります。

または、現在のヘッドルームを使用して、表示する前にコンテンツをトーンマップしたい場合。

いずれの場合も、iOSにはヘッドルームのクエリをサポートする新しいAPIがあります。このセクションでは、呼び出しとmacOSとの違いについて説明し、そのような決定を下すことができます。

macOSでは、ヘッドルームクエリはNSScreenにあります。

NSScreenでは、ディスプレイがサポートできる最大EDRヘッドルーム、現在の参照プリセットの最大EDRヘッドルーム、および現在のEDRヘッドルームに関するクエリがあります。

さらに、macOSはEDRのヘッドルームが変更されるたびに通知を提供します。

ただし、iOSでは、ヘッドルームクエリはUIScreenにあり、NSScreenとは異なり、代わりにディスプレイがサポートする最大EDRヘッドルームと現在のEDRヘッドルームのクエリがあります。

さらに、UIScreenは、参照モードがサポートされ、有効になっているかどうかを示すために使用される参照表示モードのステータスを提供します。

UIScreenはEDRヘッドルームの変更に関する通知を提供しませんが、参照モードのステータスが変更されるたびに通知を送信することに注意してください。

また、最大参照ヘッドルームクエリがリストから欠落していることに気付くかもしれません。

専用のクエリを使用する代わりに、参照モードのステータスが参照モードが有効になっていることを示しているときに、潜在的な最大ヘッドルームを照会することで、その値を決定できます。

ヘッドルームを照会する方法をよりよく理解するために、いくつかのサンプルコードを見てみましょう。

UIScreenでは、潜在的なEDRHeadroomを照会して、ディスプレイの可能な最大ヘッドルームを確認できます。

この値が低すぎると判断した場合は、代わりにSDRパスをレンダリングすることを選択して、処理能力を節約できます。

その後、EDRパスを決定した場合は、レンダリングデリゲートまたは定期的にスケジュールされたドローコールがあるかもしれません。

この呼び出しでは、現在のEDRHeadroomを照会し、それを使用してコンテンツをトーンマップして、どれもヘッドルームを超えないようにし、クリップしないようにすることができます。

参照モードのステータスを知りたい場合は、UIScreen.referenceDisplayMode StatusDidChangeNotificationを使用して、ステータスが変更されるたびに通知を受け取るように登録できます。

その後、ステータスが変更されるたびに、新しいステータスと新しい潜在的なEDRヘッドルームを取得し、それらを使用してレンダリングに関するさらなる決定を下すことができます。

参照モードのステータスについては、知っておくべき4つの固有の状態があります。

StatusEnabledは、参照モードが有効になっており、期待どおりにレンダリングされていることを示します。

StatusLimitedは、参照モードが有効になっているが、何らかの理由で一時的に参照応答を達成できないことを示しています。

このステータスが発生した場合、参照応答が侵害されたことをユーザーに通知する参照外のUI通知が添付されることに注意してください。

StatusNotEnabledは、このデバイスで参照モードがサポートされているが、有効になっていないことを示します。

そして最後に、StatusNotSupportedは、このデバイスで参照モードがサポートされていないことを示します。

これらの新しいAPIは、開発者にディスプレイの現在の状態に関するより深い洞察を提供し、EDRコンテンツのレンダリング方法について十分な情報に基づいた決定を下すために必要なツールを提供する必要があります。

前のセクションでは、コンテンツをトーンマップし、クリッピングを避けるために使用できる現在のEDRヘッドルームを含む、さまざまなヘッドルームパラメータを照会する方法を取り上げました。

しかし、独自のトーンマッピングアルゴリズムを掘り下げたり実装したりしたくない場合はどうなりますか?

さて、ビデオコンテンツの場合、Appleの内蔵トーンマッピングを利用したいと思うかもしれません。

コンテンツでAppleのトーンマッピングを有効にしたい場合は、HDR10とHLGの両方のメタデータコンストラクタを含むCAEDRメタデータインターフェイスを使用して有効にすることができます。

トーンマッピングはすべてのプラットフォームでサポートされているわけではありませんが、プラットフォームにこのサポートがあるかどうかを確認できるクエリがあることに注意してください。

プラットフォームがトーンマッピングをサポートしているかどうかを確認するには、CAEDRMetadata.isAvailableに問い合わせてください。

利用可能な場合は、CAEDRMetadataをインスタンス化する必要があります。

すぐに特定のコンストラクタを調べますが、今のところこのステップをスキップしましょう。

EDRメタデータを取得したら、レンダリングするレイヤーに適用します。

これにより、提供されたメタデータに基づいて、レイヤーがシステムトーンマッパーによって処理されることが選択されます。

前述のように、HDRビデオフォーマットに固有のEDRメタデータコンストラクタがいくつかあります。

ここには、パラメータを取らないHLGメタデータのコンストラクタがあります。

次に、利用可能な2つのHDR10コンストラクタのうちの1つです。

これには3つのパラメータが必要です。マスタリングディスプレイの最小輝度（nits）、マスタリングディスプレイの最大輝度（nits）、およびEDR 1.0のコンテンツマッピングとnitsの明るさを示す光出力スケールです。

通常、これを100に設定します。

最後に、MasterDisplayColourVolume SEIメッセージ、ContentLightLevelInformation SEIメッセージ、およびopticalOutputScaleを取るHDR10コンストラクタの2番目があり、前述のように、通常は100ニトに設定されています。

これらのコンストラクタの1つを使用してCAEDRMetadataオブジェクトを作成したら、アプリケーションのCAMetalLayerに設定します。

これにより、このレイヤーでレンダリングされたすべてのコンテンツがシステムトーンマッパーによって処理されるため、マッピングを自分で実行せずにクリッピングを回避できます。

どのコンストラクタを使用するかは、コンテンツがどのようにソースまたは作成されたかに完全に依存しますが、通常、コンテンツがHLG色空間にある場合は、HLGコンストラクタを使用する必要があります。

そして、それがPQ色空間にある場合は、HDR10コンストラクタを使用したいと思うでしょう。

コンテンツにSEIメッセージがすでに添付されている場合は、著者の意図を最もよく遵守するために、2番目のHDR10コンストラクタを使用することをお勧めします。

それ以外の場合は、最初のコンストラクタを使用する必要があります。

線形色空間を使用している場合、使用するコンストラクタは、コンテンツの作成方法に完全に依存します。

したがって、Appleのトーンマッピングで使用する場合は、HDR10とHLGメタデータに関する開発者ドキュメントを読むことを強くお勧めします。

それでは、PixelmatorとそのEDRの採用を見てみましょう。

EDRのおかげで、より鮮やかでリアルな方法で画像をレンダリングできます。

たとえば、RAW写真を開いて露出とハイライトを増やすと、最も明るい領域の詳細は、SDRとも呼ばれるディスプレイの標準ダイナミックレンジを使用してレンダリングできません。

さて、EDRをオンにすると、SDRホワイトを超えたすべての詳細が目に見えるようになります。

キャンバスのSDR色と比較して、EDRコンテンツがどれだけ鮮やかに表示されるかに注意してください。

EDRをオフにすると、SDRとEDRの視覚的な違いがより明らかになります。

そして、それでセッションは終わりました。

この講演では、iOSとiPadOSに登場するいくつかの新しいエキサイティングな機能を取り上げました。

EDRに関する簡単な復習を提供し、画像I / OでHDR画像を読み取り、それをメタルテクスチャに変換するためのサンプルワークフローを検討し、SDRにクリッピングせずにそのテクスチャをレンダリングできるようにEDRにオプトインする方法を調べました。

また、ヘッドルームクエリAPIと、EDRレンダリングに関する情報に基づいた決定を下す際の有用性、および一般的なHDRフォーマットのトーンマッピングを提供するAppleのシステムにオプトインする方法についても簡単に触れました。

EDRとそれをiOSとiPadOSのアプリに採用する方法をよりよく理解して、この話から出てきたことを願っています。

HDR、または一般的なEDRコンテンツでの作業についてもっと知りたい場合は、前年のいくつかのセッションと、私がお勧めするいくつかの今後のセッションがあります。

とはいえ、私たちのセッション「iOSでのEDRの探索」にご参加いただきありがとうございます。

そして、素晴らしいWWDCを!

♪