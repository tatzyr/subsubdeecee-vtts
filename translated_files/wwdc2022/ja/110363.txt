110363

♪ ♪

Ahmed: こんにちは、私の名前はAhmedで、ClangとSwiftのコンパイラに取り組んでいます。

このセッションでは、アプリのサイズとランタイムのパフォーマンスを向上させるために、一般的なSwiftとObjective-Cの操作をより迅速かつ効率的にするために行った変更を深く掘り下げます。

SwiftまたはObjective-Cでコードを書くとき、あなたは常に2つの主要なコンポーネントと本当に相互作用しています。

まず、Xcodeを使用してビルドし、SwiftとClangのコンパイラを使用します。

しかし、アプリを実行すると、多くの重い作業がSwiftとObjective-Cランタイムで行われます。

ランタイムは、すべてのプラットフォームのオペレーティングシステムに組み込まれています。

コンパイラがビルド時にできないことは、ランタイムは実行時に行います。

コンパイラとランタイムの両方で行ったいくつかの改善を見ていきます。

さて、このセッションは少し珍しいです。新しいAPI、言語の変更、または新しいビルド設定はありません。

コードを変更する必要がないので、これらの改善はすべて開発者にとって透明です。

飛び込みましょう。

4つの改善点を見ていきます。

Swiftでのプロトコルチェックをより効率的にし、Objective-Cのメッセージ送信コールを小さくし、最後に自動リリースの省略をより速く、より小さくしました。

詳しく見てみましょう。 

Swiftのプロトコルチェックから始めましょう。

ここにはCustomLoggableプロトコルがあります。

読み取り専用の計算プロパティcustomLogStringがあり、CustomLoggableオブジェクトの特別な処理を持つログ関数で使用できます。

後で、名前と日付のフィールドを持つイベントタイプを定義します。

また、customLogStringプロパティのゲッターを定義することで、CustomLoggableプロトコルに準拠しています。

これにより、イベントオブジェクトを「ログ」関数に渡すことができます。

このコードを実行するとき、「log」関数は、渡した値がプロトコルに準拠しているかどうかを確認する必要があります。

そして、それは「as」演算子を使用してそれを行います。「Is」演算子も見たことがあるかもしれません。

可能な限り、このチェックはビルド時にコンパイラで最適化されます。

しかし、私たちはまだ常に十分な情報を持っているわけではありません。

したがって、これは多くの場合、以前に計算したプロトコルチェックメタデータの助けを借りて、ランタイムで起こる必要があります。

このメタデータを使用すると、ランタイムはこの特定のオブジェクトが本当にプロトコルに準拠しているかどうかを知り、チェックは成功します。

メタデータの一部はコンパイル時に構築されますが、特にジェネリックを使用する場合は、起動時にのみ多くを構築できます。

多くのプロトコルを使用すると、これは最大数百ミリ秒になる可能性があります。

現実世界のアプリでは、これが打ち上げ時間の最大半分かかるのを見てきました。

新しいSwiftランタイムでは、アプリの実行可能ファイルと起動時に使用するdylibのdyldクロージャの一部として、これらを事前に事前計算します。

何よりも、これはiOS 16、tvOS 16、またはwatchOS 9で実行している既存のアプリでも有効になります。

dyldとローンチの閉鎖についてもっと知りたい場合は、トーク「App Startup Time: Past, Present, and Future」をご覧ください。

それはSwiftのプロトコルチェックでした。

メッセージの送信に移りましょう。

Xcode 14の新しいコンパイラとリンカーにより、ARM64では12バイトから最大8バイト小さくなりました。

すぐにわかるように、メッセージ送信は本当にどこにでもあるので、これは加算され、バイナリのコードサイズが最大2%改善されました。

これは、古いOSリリースをデプロイターゲットとして使用している場合でも、Xcode 14でビルドするときに自動的に有効になります。

デフォルトはサイズの勝利とパフォーマンスのバランスですが、objc_stubs_smallリンカーフラグを使用して、サイズのみの最適化を選択できます。

では、何が変わったのかを見てみましょう。

では、例から始めましょう。

ここでは、会議の開始日にNSDateを作成しようとしています。

まず、NSCalendarを作成し、NSDateComponentsに記入し、そこから日付を作成し、最後に返します。

では、コンパイラが生成するアセンブリを見てみましょう。

さて、アセンブリの詳細はそれほど重要ではありません。

私たちコンパイラの人々は、あなたがする必要がないように、一日中それを見つめています。

重要なのは、ここでのほぼすべての行が、日付コンポーネントのようにプロパティアクセスを行う場合でも、objc_msgSendを呼び出す命令を必要とすることです。

これは、コンパイル時にどのメソッドを呼び出すべきかわからないためであり、objcランタイムのみが呼び出すためです。

そこで、objc_msgSendを使用してランタイムを呼び出して、正しいメソッドを見つけるように依頼します。

これらの呼び出しの1つに集中しましょう。

objc_msgSendを呼び出す指示についてはすでに言及しました。

しかし、もっとあります。

どのメソッドを呼び出すかをランタイムに伝えるには、これらのobjc_msgSend呼び出しにセレクタを渡す必要があります。

セレクターを準備するには、さらにいくつかの指示が必要です。

バイナリを見ると、これらの指示のそれぞれに少しスペースがかかります。

ARM64では、それぞれ4バイトです。

したがって、これらのobjc_msgSend呼び出しごとに、12バイトを使用しており、これらの呼び出しごとにそれが必要です。それは本当に加算されます。

それを改善するために何ができるか見てみましょう。 

さて、前に見たように、これらのバイトのうち8バイトはセレクタの準備に専念しています。

興味深いことに、どのセレクタでも、それは常に同じコードです。

そして、これが私たちの最適化の出番です。

これは常に同じコードであるため、共有でき、メッセージを送信するたびにではなく、セレクタごとに1回しか発行できません。

私たちはそれを取り出して、小さなヘルパー関数に入れて、代わりにその関数を呼び出すことができます。

同じセレクタを使用して多くの呼び出しで、これらすべての命令バイトを保存できます。

私たちはこのヘルパー関数を「セレクタースタブ」と呼んでいます。

しかし、私たちはまだ実際のobjc_msgSend関数を呼び出す必要があるので、それを続けます。

そして再び、それは関数自体のアドレスをロードし、それを呼び出すための別の、異なる、間接を持っています。

詳細は重要ではありませんが、重要なのは、それを行うにはさらに数バイトのコードが必要であるということです。

そして、これは私が先に述べたように、あなたが望むモードを選択できる場所です。

ここで行ったように、これら2つの小さなスタブ機能を別々にしておくことができます。

私たちは最も多くのコードを共有し、これらの機能をできるだけ小さくすることができます。

しかし、残念ながら、これは2回バックコールを行いますが、これはパフォーマンスには理想的ではありません。

そのため、代替バージョンでこれをさらに改善することができます。

作成したこの2つのスタブ関数を1つにまとめることができます。

そうすれば、コードを近づけ、それほど多くの呼び出しを必要としません。

そして、それはここの右側にあります。

したがって、これらは2つのオプションです。

サイズだけを最適化するかどうかを選択し、利用可能な最大のサイズ節約を得ることができます。

-Objc_stubs_smallリンカフラグを使用して有効にすることも、最高のパフォーマンスを維持しながらサイズの利点を提供するコード生成を使用することもできます。

そして、サイズに厳しい制約がない限り、これを使用することをお勧めします。そのため、デフォルトです。

そして、それはスタブを使用して送信する小さなメッセージでした。

私たちが行ったもう1つの改善は、保持/リリースを安くすることです。

Xcode 14の新しいコンパイラにより、保持/リリースコールはARM64の8バイトから最大4バイト小さくなりました。

すぐにわかるように、メッセージの送信と同じように、保持/リリースもどこにでもあります。

これにより、バイナリのコードサイズが最大2%改善されました。

さて、メッセージ送信スタブとは異なり、これにはランタイムサポートが必要なため、iOS 16、tvOS 16、またはwatchOS 9の展開ターゲットに移行すると、これが自動的に取得されます。

では、何が変わったのかを見てみましょう。

私たちの例に戻りましょう。

msgSendコールについて話しましたが、自動参照カウント（ARC）では、コンパイラによって多くの保持/リリースコールが挿入されます。

非常に高いレベルでは、オブジェクトへのポインタのコピーを作成するたびに、それをライブに保つために保持数を増やす必要があります。

そしてここで、これは私たちの変数cal、dateComponent、およびtheDateで起こります。

Objc_retainを使用して、ランタイムを呼び出すことによってそれを行います。

変数がスコープ外になると、objc_releaseを使用して保持カウントを減少させる必要があります。

もちろん、ARCの利点の一部は、これらの呼び出しの多くを排除し、それらを最小限に抑えるすべてのコンパイラの魔法です。

そして、私たちは少し後でこれらの手品の1つに入るつもりです。

しかし、すべての魔法があっても、私たちはまだしばしばこれらの呼び出しを必要とします。

この例では、カレンダーとdateComponentsのローカルコピーをリリースする必要があります。

ボンネットの下では、これらのobjc_retain/release関数は単なるC関数です。単一の引数、解放されるオブジェクトを取ります。

したがって、ARCでは、コンパイラはこれらのC関数への呼び出しを挿入し、適切なオブジェクトポインタを渡します。

そのため、これらの呼び出しは、当社のプラットフォームApplication Binary Interface（ABI）によって定義されたC呼び出し規約を尊重する必要があります。

具体的には、これらの呼び出しを行い、正しいレジスタにポインタを渡すために、さらに多くのコードが必要であることを意味します。

だから、私たちはそのためだけにいくつかの追加の「移動」指示で終わります。

そして、それが私たちの新しい最適化の出番です。

カスタム呼び出し規約で保持/リリースに特化することで、オブジェクトポインタがすでにどこにあるかに応じて適切なバリアントを日和見的に使用できるため、移動する必要はありません。

具体的には、これが意味することは、これらすべての呼び出しに対して冗長なコードの束を取り除くということです。

そして再び、これはこれらのちっぽけな小さな指示のために多くのようには思えないかもしれませんが、アプリ全体にわたって、それは本当に加算されます。

それが、私たちが保持/リリース操作を安くした方法です。

最後に、自動放出の省略について話しましょう。

今、これはさらに面白いです。

Objcランタイムの変更により、自動リリースの省略が速くなりました。

これは、新しいOSリリースで実行すると、既存のアプリで自動的に発生します。

それに加えて、追加のコンパイラの変更により、コードも小さくしました。

また、iOS 16、tvOS 16、またはwatchOS 9の展開ターゲットに移行すると、このサイズの利点が自動的に得られます。

さて、これはすべて素晴らしいですが、そもそも自動リリースの省略とは何ですか?

私たちの例に戻りましょう。

先ほど、ARCはすでに保持とリリースを最適化するための多くのコンパイラの魔法を与えていると述べました。

では、ここで1つのケースに焦点を当てましょう。自動リリースされた戻り値です。

この例では、一時的なオブジェクトを作り、それを発信者に返しています。

それでは、それがどのように機能するかを見てみましょう。

したがって、一時的なtheDateがあり、それを返し、呼び出しが完了し、呼び出し元はそれを独自の変数に保存します。

それでは、それがARCでどのように機能するかを見てみましょう。

ARCは、呼び出し元のリテンションを挿入し、呼び出された関数にリリースを挿入します。

ここでは、一時的なオブジェクトを返すときは、スコープ外になるため、関数で最初にリリースする必要があります。

しかし、まだ他の参考文献がないので、まだそれを行うことはできません。

もし私たちがそれをリリースしたら、それは私たちが戻る前に破壊されるだろうし、それは良くない。

したがって、一時的なものを返すことができるように、特別な慣習が使用されます。

発信者がそれを保持できるように、返品前に自動リリースします。

あなたはおそらく以前に自動リリースと自動リリースプールを見たことがあるでしょう:それは単にいくつかの後のポイントまでリリースを延期する方法です。

ランタイムは、リリースがいつ発生するかについて実際には保証しませんが、それがここにない限り、今、この一時的なオブジェクトを返すことができるので、それは便利です。

さて、これは無料ではありません。

自動リリースを行うには多少のオーバーヘッドがあります。

ここでオートリリースエミッションの出番です。

だから、それがどのように機能するかを理解するために、アセンブリを見て、このリターンをたどりましょう。

オートリリースを呼び出すと、それはobjcランタイムに入り、そこで楽しみが始まります。

ランタイムは、何が起こっているかを認識しようとします。自動リリースされた値を返しています。

それを助けるために、コンパイラは私たちが決して使用しない特別なマーカーを発行します。

これは自動リリースの省略の対象となることをランタイムに伝えるためにそこにあります。

そして、その後に保持が続き、後で実行します。

しかし、今、私たちはまだ自動リリース中であり、それを行うと、ランタイムは特別なマーカー命令をデータとしてロードし、それを比較して、それが期待する特別なマーカー値であるかどうかを確認します。

もしそうなら、それはコンパイラがすぐに保持される一時を返すことをランタイムに伝えたことを意味します。

これにより、一致する自動リリースを解除または削除し、コールを保持することができます。

そして、それは自動放出の回避です。

しかし、これも無料ではありません。データとしてコードをロードすることは、そうでなければ非常に一般的なものではないので、CPUでは最適ではありません。

私たちはもっとうまくやれる。

では、今回は新しい方法を使用して、もう一度戻りシーケンスをたどりましょう。

私たちはオートリリースから始めました。

それはまだObjective-Cランタイムに入ります。

この時点で、私たちは実際にすでに貴重な情報を持っています：返送先住所。

この関数の実行が完了した後、どこに戻る必要があるかを教えてくれます。

だから、私たちはそれを追跡することができます。

ありがたいことに、返送先住所を取得するのはとても安いです。

それは単なるポインタで、側面に保管できます。

その後、ランタイムの自動リリースコールを残します。

発信者に戻り、保持時にランタイムを再入力します。

そして、これは新しい魔法が起こる場所です。

その時点で、私たちがどこにいるかを見て、現在のリターンアドレスへのポインタを得ることができます。

実行時に、保持中に手に入れたばかりのこのポインタと、オートリリースをしていたときに以前に保存したポインタを比較できます。

そして、私たちは2つのポインタを比較しているだけなので、これは超安いです。

高価なメモリアクセスを行う必要はありません。

比較が成功すれば、自動リリース/保持ペアを省略でき、パフォーマンスを向上させることができます。

その上、この特別なマーカー命令をデータとして比較する必要がなくなったので、必要ないので、削除できます。

そして、コードサイズも保存できます。

それが私たちがオートリリースの省略をより速く、より小さくした方法です。

SwiftとObjective-Cのランタイムをいくつか改善しました。

締めくくりましょう。

アプリが新しいOSで実行されると、ランタイムの改善により、Swiftプロトコルチェックがより効率的になります。

オートリリースの省略をしようとするたびに、それも速くなります。

Xcode 14の新しいコンパイラとリンカーとメッセージ送信スタブのおかげで、アプリを再構築することでコードサイズの最大2%を節約できます。

そして最後に、デプロイメントターゲットをiOS 16、tvOS 16、またはwatchOS 9に更新すると、リテンション/リリースコールを小さくすることで、さらに2%を節約できます。

さらに、より小さな自動放出エリシオンシーケンスのおかげです。

SwiftとObjective-Cのランタイムを深く掘り下げて楽しんでいただければ幸いです。ご覧いただきありがとうございます。