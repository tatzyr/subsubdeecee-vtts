110379

♪ ♪

ジェレミー:こんにちは。私はジェレミーです。AVFoundationを使用して、より応答性の高いメディアアプリを作成する方法を紹介します。

アプリでメディアアセットを使用する場合は、単に再生する以上のことをしたいかもしれません。

サムネイルを表示したり、メディアを新しいコンポジションに結合したり、アセットに関する情報を入手したりしたいと思っています。

これらのタスクにはデータの読み込みが必要で、ビデオのような大きなファイルでは、完了までに時間がかかる場合があります。

残念ながら、この作業がメインスレッドで同期的に行われる場合、アプリにレイテンシの問題を導入するのは簡単です。

アプリの応答性を維持するための素晴らしい方法は、データを非同期にロードし、完了したらUIを更新することです。

AVFoundationには、これを簡単にするためのツールがあります。

だから、今日私たちが話すことは次のとおりです。

まず、AVFoundationの新しい非同期APIを紹介します。

次に、昨年導入したasync load(_:)メソッドを使用して、資産検査に関する最新情報を提供します。

また、AVAssetResourceLoaderを使用して、ローカルおよびキャッシュされたメディアのカスタムデータ読み込みを最適化する方法を紹介します。

しかし、まず、新しい非同期APIに飛び込みましょう。

AVAssetImageGeneratorでビデオから静止画をつかむことは、サムネイルを作成するのに最適な方法です。

しかし、画像の生成は瞬間的ではありません。

画像を生成するには、画像ジェネレータはビデオファイルからフレームデータをロードする必要があります。

また、リモートサーバーまたはインターネットに保存されているメディアの場合、その読み込みははるかに遅くなります。

そのため、画像をどのように生成するかが重要です。

メインスレッドでcopyCGImageのようにデータを同期的にロードする方法を使用すると、ビデオが読み込まれるのを待つときにUIがフリーズする可能性があります。

今年は、画像ジェネレータがデータをロードしている間、async/awaitを使用して呼び出しスレッドを解放するimage(at: time)asyncメソッドを追加しました。

画像ジェネレーターは、画像とアセット内の実際の時間を含むタプルを返します。

実際の時間がリクエストした時間とはいくつかの理由がありますが、画像のみが必要な場合は、.imageプロパティで直接アクセスできます。

圧縮ビデオの一部のフレームは、他のフレームよりも読み込まれやすい。

iFrameは独立してデコードできますが、他のフレームは近くのフレームに依存してデコードできます。

要求された時間に対して、デフォルトで画像ジェネレータは最も近いiFrameを使用して画像を生成します。

要求された時間の正確なフレームを取得するために、公差をゼロに設定するのは魅力的かもしれません。

しかし、そのフレームは、画像ジェネレータもロードする必要がある他の近くのフレームに依存する可能性が高いことを覚えておいてください。

代わりに、まだあなたが探している結果を与える広い公差を設定することを検討してください。

広い公差は、より多くのフレームを選択することで、画像ジェネレータがデータの読み込みを最小限に抑えるのに役立ちます。

読み込みに必要なフレームが少なければ少ないほど、画像を返すのが速くなります。

アセットで数回一連の画像を取得するために、画像ジェネレータはgenerateCGImagesAsynchronously(forTimes:)を持っています。

しかし、Swiftでは、それを使用するために注意すべきニュアンスがあります。

今年新しく、画像(for: times)メソッドを追加しました。

CMTimesの配列が必要なので、最初にNSValuesにマッピングする必要はありません。

また、非同期シーケンスを使用して結果を提供します。

Swiftでは、シーケンスでは、for in loopを使用してアイテムを反復処理できます。

一度に準備ができていないアイテムのシーケンスの場合、非同期シーケンスを使用すると、各反復の後に次の要素を待つことができます。

正常に生成された各画像について、結果には最初に要求された時間と画像と並んで実際の時間が含まれます。

失敗した場合、結果には理由を説明するエラーがあります。

また、画像にのみ興味がある場合、結果にはその値に直接アクセスするプロパティがあり、生成が失敗した場合にもエラーが発生する可能性があります。

非同期シーケンスの詳細については、「非同期シーケンスを満たす」セッションをチェックすることをお勧めします。

画像生成のようなタスクでは、データの読み込みがどのように含まれるかを確認するのが少し簡単です。

しかし、AVFoundationには、問題のあるスポットとして選ぶのが難しい他の同期領域がいくつかあります。

AVMutableCompositionはこれらの分野の1つです。

コンポジションにそれらへの参照を追加するために、アセットのトラックに関する資産ニーズ情報の時間範囲を挿入します。

トラックを同期的に検査するので、トラックがまだロードされていない場合は、同期的にロードされ、新しいコンポジショントラックが作成されます。

以前は、アセットのトラックをコンポジションに挿入する前に、アセットのトラックを読み込むのを待つことが解決策でした。

しかし、今年は、必要に応じてトラックを非同期にロードするinsertTimeRangeの非同期バージョンを導入します。

ビデオコンポジションと可変ビデオコンポジションには、アセットのプロパティをロードする必要がある追加の方法もあります。

今年の新機能、「propertiesOf asset」コンストラクタとisValid(for:timeRange:)メソッドも非同期のカウンターパートを持つようになりました。

これらの新しいメソッドは、アセットのトラックと期間を非同期にロードするので、それらをプリロードする必要はありません。

これらの新しい非同期メソッドは、必要なプロパティを非同期にロードすることで、アセットとのやり取りを容易にします。

しかし、自分で資産のプロパティをロードする必要がある場合は、非同期資産検査の復習をしましょう。

資産の財産を検査するには2つの方法があることに気づいたかもしれません。

AVFoundationが導入されたとき、プロパティを検査する最善の方法は、非同期キー値の読み込みでした。

昨年、非同期ロード(_:)を導入しました。

タイプセーフキーを使用してロードするプロパティを識別し、古い非同期キー値のロード技術はハードコードされた文字列をキーとして使用しました。

これらの文字列キーの誤字はキャッチしにくいです。

キーのスペルミスは、それが非同期にロードされるのを防ぎ、プロパティが後で使用されると、ロード中にブロックされます。

また、ロードするキーに新しいプロパティを追加するのを忘れたり、非同期のロードを完全に忘れたりすることも非常に簡単です。

これらの理由から、今年は非同期キー値のロードとSwiftの同期プロパティを廃止し、非同期ロードを支持します。

非同期ロードは、タイプセーフ識別子を使用してタイプミスを防ぎます。

アンロードされたプロパティへのアクセスを避けるために、要求に応じてプロパティ値を直接返します。

また、これらすべてがコンパイル時にチェックされるため、新しいIOバウンドパフォーマンスの問題の導入を防ぐことができます。

非同期ロードは、AVAsset、AVAssetTrack、AVMetadataItem、およびそれらのサブクラスのプロパティを非同期に検査する唯一の推奨方法です。

しかし、これらのクラスのほんの一握りは、引き続き同期プロパティ検査を提供します。

それは、それらのプロパティのデータがすでにメモリ内で利用可能だからです。

変更可能な構成をもう一度見て、その理由を見てみましょう。

可変コンポジションを使用して、2つの既存のビデオトラックのセグメントをつなぎ合わせます。

空のコンポジションを作成し、空のビデオトラックを追加することから始めます。

次に、最初のビデオトラックの一部をコンポジショントラックに同期的に挿入できます。

舞台裏では、このステップはデータをロードしていません。

代わりに、目的のトラックを指す新しいトラックセグメントを追加します。

その後、同じ方法で2番目のトラックの一部を追加できます。

コンポジション自体はファイルではなくインメモリ構造によって裏打ちされているため、最初にロードすることなく、そのプロパティを安全に同期的に検査できます。

繰り返しますが、このため、同期プロパティ検査はこれらのクラスで引き続き利用可能であり、すべてのクラスは非同期検査に非同期負荷を使用します。

AVFoundationのこれらの新しい非同期メソッドはすべて、メディアデータの読み込み中にブロッキングを防ぐことが容易になります。

しかし、初めてアプリに並行性を導入するのは難しいかもしれません。

Swift並行性を使い始めるためのヘルプと、アプリでのAVFoundationの非同期ロードへの移行については、WWDC 21のこれらのセッションをチェックしてください。

最後のトピックでは、アセットのカスタムデータ読み込みの最適化について話しましょう。

まず、AVAssetがデフォルトでデータをロードする方法を見てみましょう。

URLでAVAssetを作成すると、メディアはネットワーク上にあるか、デバイスにローカルに保存できます。

ネットワーク上にある場合、AVAssetはスムーズな再生を確保するために一定量のデータを動的にキャッシュします。

メディアがローカルの場合、AVAssetはキャッシュをバイパスし、再生するために必要に応じてデータをロードできます。

場合によっては、AVAssetにメディアへの直接ポインタを与えることができない場合があります。

Mp4の生のバイトをカスタムプロジェクトファイル内に格納するかもしれません。

このような状況では、AVAssetはAVAssetResourceLoaderを使用できます。

リソースローダーは、特別な方法でロードするメディアから任意のバイトを要求する方法をアセットに提供します。

しかし、アセットはデータの読み取りを処理しなくなったため、各チャンクの読み込みにどれくらいの時間がかかるかを予測することはできません。

したがって、メディアへのアクセスにはネットワーク通信が含まれることを前提とし、再生の準備が整う前にデータをキャッシュするまで待ちます。

今年は、メディアがローカルで利用可能であれば、リソースローダーで全体LengthAvailableOnDemandを有効にすることができます。

このフラグを設定すると、要求されたときにデータを受信することを期待できることをアセットに伝えるので、キャッシュをスキップできます。

ローカルメディアの場合、 entireLengthAvailableOnDemandは、余分なデータをキャッシュする必要がないため、再生中のアプリのメモリ使用量を減らすのに役立ちます。

また、アセットはキャッシュが最初にいっぱいになるのを待つ必要がないため、再生を開始するのにかかる時間を短縮することもできます。

ただし、このフラグを有効にするときは注意してください。

ロードにネットワークファイルストレージを含むネットワーク操作が必要な場合は、再生が信頼できない可能性があります。

それがリソースローダーの新しい機能強化です。

それでは、あなたのアプリの次のステップで物事をまとめましょう。

メディアを操作するときは、async/awaitを使用して、バックグラウンドで読み込まれている間、アプリの応答性を維持します。

より速い結果を得るために画像ジェネレータを使用する場合は、公差を増やすことを検討してください。

また、ローカルで利用可能なメディアにリソースローダーを使用している場合は、オンデマンドで利用可能な全長を有効にして、パフォーマンスを向上させます。

それは私が今日持っているすべてです。

ご覧いただきありがとうございます。WWDC 22をお楽しみください。