110354

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

こんにちは、私はアンジェラです。

そして私はベッカです。

スウィフトの新機能へようこそ!

今日、Swift 5.7のすべての素晴らしい新機能についてお話しできることを本当に楽しみにしています。

今日話すことの多くは、開発者としての生活を楽にするというSwiftの目標を示しています。

ワークフローといくつかの驚くべき改善をカスタマイズするのに役立つ新しいツールを見ていきます。

次に、最新のSwiftの並行性モデルと、フルスレッドの安全性を含むSwift 6への道について話します。

最後に、よりクリーンでシンプルなジェネリック、強力な新しい文字列処理機能など、Swiftの読み書きを容易にするいくつかの言語改善を案内します。

しかし、まず、スウィフトを特別なものにしているものの1つについて話すことから始めましょう。

あなたのインプットと貢献は、Swiftが急速に拡大することを可能にしたものです。

コミュニティの関与はスウィフトの中核です。

今年は、昨年発表されたドキュメント生成ツールであるdocCとSwift.orgのウェブサイトがオープンソース化されたときに、より多くのSwiftプロジェクトがコミュニティで利用可能になりました。

オープンソースは、活発なコミュニティがそれを羊飼いしているときに最もよく機能します。

私たちは、サーバー上のSwiftとSwiftのDiversityのワークグループモデルを使用して、特定の分野に関心のあるコミュニティメンバーにスチュワードシップとサポートを提供してきました。

これは本当にうまくいっているので、2つの新しいワークグループを開始しました。

1つはSwiftのウェブサイトで反復してコミュニティリソースにするためのもので、もう1つはC ++の相互運用性で、C ++とSwiftの間のモデルのデザインを形作るためです。

新しい分野に進出する際には、コミュニティ内のメンバーからのサポートが必要です。

その一環として、Diversity in Swiftワークグループは昨年、Swiftメンターシッププログラムを導入しました。

このプログラムは、開始方法を知らない、または特定の分野で専門知識を深めようとしている人々のために、すべてのワークグループ分野に貢献するための経路を提供します。

昨年のプログラムは大成功でした。

興味のあるメンティーがたくさんいました。それで、私たちは41のメンターシップペアを作ることができました。

この成功は、プログラムが2年目に戻ってくる理由です。

このプログラムには、興味のあるすべての人を含めたいと思っています。しかし、それを行うには、私たちはあなたが必要です - 今聞いている興奮した経験豊富な開発者は、彼らの知識の幅を共有し、新しい接続を作る準備ができています。

メンターシッププログラムは、コードだけでなく、コミュニティ内で関係を築くことだからです。

そして、少しのガイダンスは永続的な効果をもたらすことができます。

私の言葉を信じないでください。 

昨年、アムリットはメンターシッププログラムに参加し、コンパイラと言語設計に焦点を当てました。

アムリットの陰謀として始まったものは、具体的な貢献に変わりました。

新しいドメインに飛び込むのは簡単ではありません。

それでも、彼女は成功を見つけ、もっと貢献するインスピレーションを感じながら立ち去りました。

他の多くの人と同様に、この経験はアムリットの扉を開きました。

コンパイラと言語設計に加えて、昨年は、テクニカルライティングやテストからSwiftパッケージへの貢献まで、幅広い重点分野がありました。

今年はさらに追加し、常に新しいトピックの機会があります。

このリストに興味のあるものが見当たらない場合は、アプリケーションで言及することができます。

もう1つの追加は、今年のプログラムは、参加する能力が低いかもしれないが、まだ参加することに興奮している人を収容するために、スターターバグ貢献のためのメンターシップを一年中提供することです。

応募に興味がある場合、またはもっと聞きたい場合は、最新のSwiftブログ記事をチェックしてください。

そこでは、ハイライトされたメンティーからの詳細な考察へのリンクを見つけることができます。

メンターシッププログラムは、Diversity in Swiftの傘下にある1つのイニシアチブにすぎません。

メンターシッププログラムやその他のDiversity in Swiftの取り組みの詳細については、Swift.org/diversityをご覧ください。

さらにドアを開けるために、あなたが持っているリソースでSwiftをできるだけ簡単に使用できるようにしたいと考えています!

Linuxパッケージ形式のサポートを追加することで、LinuxプラットフォームのSwiftツールチェーン配布プロセスを合理化しました。

新しいネイティブツールチェーンインストーラーを使用すると、Amazon Linux 2とCentOS 7のRPMをSwift.orgから直接ダウンロードできます。

これらのツールチェーンは実験的なので、必ずSwift.orgフォーラムでフィードバックを共有してください。

Swiftは主にアプリの構築に使用されます。

しかし、ビジョンは常にSwiftがスケーラブルになることでした。高レベルのスクリプトからベアメタル環境まで、あらゆるものから使用されています。

これまでに使用されたことのない場所でスウィフトを使用することを奨励するために、スウィフトは今年いくつかの大きな変更を受けました。

スタンドアロンの静的にリンクされたバイナリの標準ライブラリを小さくするために、外部Unicodeサポートライブラリへの依存を削除し、より高速なネイティブ実装に置き換えました。

イベント駆動型サーバーソリューションで実行する場合、より小さく、より高速なバイナリは大きな利点です。

サーバーのコンテナ化された展開をよりよくサポートするために、デフォルトでLinuxで静的リンクを取得します。

このサイズ縮小により、Swiftは制限された環境にも適しており、AppleのSecure Enclaveプロセッサーで使用できるようになりました。

Swiftは、アプリからサーバー、制限されたプロセッサまで便利です。それをすべて結びつけるのは、パッケージエコシステムです。

今年のSwiftパッケージの新機能は、あなたの人生をより良くするでしょう。

まず、Swift Package ManagerはTOFUを導入しました。

いいえ、おいしいおやつではありません。

TOFUはTrust On First Useの頭字語です。

これは、パッケージが最初にダウンロードされたときにパッケージの指紋が記録される新しいセキュリティプロトコルです。

その後のダウンロードでは、この指紋を検証し、指紋が異なる場合はエラーを報告します。

これは、信頼とセキュリティがパッケージエコシステムのコアに組み込まれ、自信を持って使用できるようにするための一例にすぎません。

コマンドプラグインは、Swift開発者のワークフローを改善する素晴らしい方法です。

これらは、より拡張可能で安全なビルドツールを提供するための第一歩です。

コマンドプラグインは、ドキュメントの生成、ソースコードの再フォーマットなどに使用できます。

シェルスクリプトで自動化を書き、別々のワークフローを維持する代わりに、Swiftを使用できます!

オープンソースのフォーマッタとリンターを考えてください。

現在、これらのオープンソースツールはすべてXcodeとSwift Package Managerで利用できます。

コマンドプラグインは、オープンソースツールとSwift Package Managerの間の接着剤です。

Swiftプロジェクトは、自動化されたワークフローとのシームレスな統合を提供するために、オープンソースコミュニティの開発者ツールを採用しています。

docCは、ドキュメントをソースコードに統合するための素晴らしいツールです。

今年は、Objective-CとCのサポートでさらに良くなりました。

docCでプラグインを作成するために何時間がかかるかを見てみましょう。

プラグインは単純なSwiftコードです。

CommandPluginプロトコルに準拠した構造体を作成することで、プラグインを定義できます。

そして、どのツールを呼び出すかをプラグインに伝える関数を追加するだけです。

この関数内では、docCを呼び出す場所です。

プラグインを定義すると、Swift PMコマンドラインインターフェイスとXcodeをメニューエントリとして利用できるようになります。

これで、Swift PMにドキュメントを生成するように指示することができ、このアクションをdocC実行可能ファイルに渡すことを知っています。

それはそこで止まりません。

ビルドツールプラグインと呼ばれる2番目のプラグインがあります。

これらのプラグインは、ビルド中に追加のステップを注入できるパッケージです。

ビルドツールプラグインを実装すると、ビルドシステムがサンドボックスで実行するためのコマンドが作成されます。

これらは、いつでも直接実行するコマンドプラグインとは異なり、パッケージ内のファイルを変更する明示的な許可を与えることができます。

ビルドツールプラグインは、ソースコードの生成や特別な種類のファイルのカスタム処理に使用できます。

ビルドツールプラグインでは、これはパッケージレイアウトになります。

この例では、plugin.Swiftは、パッケージプラグインターゲットを実装するSwiftスクリプトです。

プラグインはSwift実行可能ファイルとして扱われます。

そして、Swiftの実行可能ファイルを書くのと同じ方法でプラグインを書きます。

実行する実行可能なコマンドと結果として期待される出力をビルドシステムに指示するビルドコマンドのセットを定義することで、プラグインを実装できます。

パッケージプラグインは、パッケージの拡張性を提供する安全なソリューションです。

「Swiftパッケージプラグインに会う」と「Swiftパッケージプラグインを作成する」の2つのセッションで、プラグインの仕組みと独自のプラグインを実装する方法について詳しく知ることができます。

パッケージの使用を拡大すると、モジュールの衝突に遭遇した可能性があります。

それは、2つの別々のパッケージが同じ名前のモジュールを定義するときです。

この状況を解決するために、Swift 5.7はモジュールの曖昧さ回避を導入しています。

モジュールの曖昧さ回避は、モジュールを定義するパッケージの外部からモジュールの名前を変更できる機能です。

ここStunningアプリケーションでは、ロギングモジュールを定義する2つのパッケージが導入されているので、それらは衝突します。

見事なアプリケーションでこれを修正するには、パッケージマニフェストの依存関係セクションにmoduleAliasesキーワードを追加するだけです。

そうすれば、2つの異なる名前を使用して、以前は同じ名前のモジュールを区別できます。

Swift 5.7は、いくつかの素晴らしいパフォーマンスの向上をもたらします。

ビルド時間を見ることから始めましょう。

昨年、SwiftでSwiftソースコードのコンパイルを調整するプログラムであるSwift Driverをどのように書き換えたかについて話しました。

昨年の再アーキテクチャは、ビルドを大幅にスピードアップするいくつかの本当に重要な変更のロックを解除しました。

ドライバーは、別の実行可能ファイルとしてではなく、Xcodeビルドシステム内で直接フレームワークとして使用できるようになりました。

これにより、ビルドシステムとより密接にビルドを調整して、並列化などを可能にすることができます。

クイックビルドのサウンドを愛する人なら、「Xcodeビルドで並列化を解明する」セッションで詳細を確認できます。

ビルドがどれだけ速いかを示すために、Swiftで書かれたよく使用するツールのいくつかを構築するのにどれくらいの時間がかかるかの例を見てみましょう。

10コアのiMacでは、改善は5%から25%までの範囲でした。

次に、タイプチェックの速度が改善されます。

今年は、ジェネリックシステムの重要な部分、つまりプロトコルや「where」句などから関数の署名を計算する部分を再実装することで、タイプチェッカーのパフォーマンスを改善しました。

古い実装では、より多くのプロトコルが関与するにつれて、時間とメモリの使用が指数関数的に拡大する可能性があります。

たとえば、ここでは、座標系を定義する複雑なプロトコルのセットがあり、多くの関連するタイプに多くの一般的な要件があります。

以前は、このコードの入力チェックに17秒かかりました。

しかし今、Swift 5.7では、この例は1秒未満で大幅に速くタイプチェックすることができます。

また、同様に印象的なランタイムの改善もあります。

Swift 5.7より前は、アプリの起動時のプロトコルチェックがiOSで4秒もかかるのを見てきました。

アプリを起動するたびにプロトコルを計算する必要があり、その結果、追加したプロトコルが増えるほど起動時間が長くなりました。

今、それらはキャッシュされています。

アプリがどのように書かれたか、使用したプロトコルの数に応じて、これはiOS 16で実行しているときに一部のアプリで起動時間が半分に短縮されることを意味します。

「アプリのサイズとランタイムのパフォーマンスを向上させる」セッションでは、これらの改善を独自のアプリケーションで活用する方法をより深く掘り下げます。

今、あなたの多くが聞きたがっていると確信している何かのための時間です。

昨年、私たちは新しい並行性モデルを導入し、俳優と非同期/待機を結集しました。

これは、アプリケーションの並行性アーキテクチャに変革的な影響を与えました。

非同期/待機とアクターは、コールバックや手動キュー管理よりも安全で簡単です。

今年は、データレースの安全性を最前線に、モデルをさらに具体化しました。

並行性は、アプリのコードベースにとって非常に根本的かつ重要な改善であったため、これらの変更をiOS 13とmacOS Catalinaにさかのぼって展開することを可能にしました。

古いオペレーティングシステムにデプロイするために、アプリは古いOS用のSwift 5.5並行性ランタイムのコピーをバンドルします。

これは、ABIの安定性の前にSwiftをオペレーティングシステムにバックデプロイするのと似ています。

次に、このモデルを新しい方向に導きました。

言語機能とサポートパッケージを導入しました。

まず、データレース回避について話しましょう。

それに飛び込む前に、私はおそらく一歩下がって、Swiftの本当に重要な機能の1つは、デフォルトでのメモリの安全性であると言うべきです。

Swiftユーザーは、変更中に値を読み込むなど、予測不可能な動作を行うことはできません。

この例では、同じ配列のカウントに一致する配列内のすべての数値を削除しています。

最初は、配列のカウントは3なので、配列から3を削除します。

しかし、それを行うと、カウントは2になります。

配列から3と2を削除しますか、それとも3だけですか？

答えはどちらでもない。

Swiftは、変更中に配列のカウントにアクセスするのは安全ではないため、これを行うのを防ぎます。

私たちの目標は、糸の安全性のために似たようなことをすることです。

私たちは、デフォルトで低レベルのデータレースを排除する言語を想定しています。

言い換えれば、予測不可能な動作を引き起こす可能性のある並行性のバグを防ぎたい。

これは別の例です。

同じ番号の配列を使用して、配列に0を追加するバックグラウンドタスクを作成し、配列の最後の要素を削除します。

しかし、待ってください、最後の要素を削除することは、0を追加する前または後に起こりますか?

答えも、やはり、どちらでもない。

Swiftは、アクターのようなものとアクセスを同期せずにバックグラウンドタスクから配列を変更するのは安全ではないため、これを行うことをブロックします。

俳優は、データレースを排除するための最初の大きな一歩でした。

今年は、最終目標に向けてさらに前進するために、並行性モデルを洗練しました。

それぞれの俳優は、並行性の海にある他のすべてから隔離された独自の島と考えることができます。

しかし、異なるスレッドが各孤立したアクターによって保存された情報を照会したい場合、どうなりますか?

この比喩は、「Swift Concurrencyを使用してデータレースを排除する」セッションで深く掘り下げられます。

メモリの安全性からデフォルトでスレッドの安全性まで、それがSwift 6の目標です。

そこに着くために、私たちは最初に私が言及した新しい言語機能で昨年の並行性モデルを改善しました。

私がまだ言及していない2番目のことは、潜在的なデータレースを特定する新しいオプトイン安全チェックです。

ビルド設定で有効にすることで、より厳格な並行性チェックを試すことができます。

俳優をもう一度見てみましょう。

私たちは、この俳優の孤立の概念を取り、分散した俳優とそれをさらに進めることができます。

分散アクターは、それらの間のネットワークを持つ異なるマシンにそれらの島を置きます。

この新しい言語機能により、分散システムの開発がはるかに簡単になります。

ゲームアプリを作りたいとしましょう。これで、Swiftでバックエンドを簡単に書くことができます。

ここでは、配布された俳優は俳優のようなものですが、別のマシン上にあるかもしれません。

この例では、ユーザーとのゲーム中に状態を維持するコンピュータープレーヤーを見ています。

分散キーワードは、リモートマシン上にある可能性のあるアクターで呼び出す必要があると予想される関数に追加することもできます。

endOfRoundという別の関数を追加しましょう。

プレイヤーをループし、それぞれでmakeMoveを呼び出します。

これらのプレーヤーの中には、ローカルまたはリモートであるものもありますが、どちらがどちらであるかを気にする必要がないという利点があります。

通常のアクターコールとの唯一の違いは、ネットワークエラーのために分散アクターコールが失敗する可能性があることです。

ネットワーク障害が発生した場合、アクターメソッドはエラーをスローします。

したがって、tryキーワードと、アクターの外で関数を呼び出すときに必要な通常のawaitキーワードを追加する必要があります。

これらのコア言語プリミティブに基づいて、Swiftでサーバー側のクラスター化された分散システムを構築することに焦点を当てたオープンソースの分散アクターパッケージも構築しました。

このパッケージには、SwiftNIOを使用した統合ネットワーク層が含まれており、クラスター全体の状態を管理するためのSWIMコンセンサスプロトコルを実装しています。

「Swiftで分散アクターに会う」セッションでは、これらの新機能を使用して分散システムを構築する方法について詳しく説明します。

また、Swift 5.5でリリースされたAsyncSequenceを扱う際の一般的な操作にすぐに使える簡単なソリューションを提供するために、オープンソースアルゴリズムの新しいセットを立ち上げました。

これらのAPIをパッケージとしてリリースすることで、開発者はプラットフォームやオペレーティングシステムのバージョン間で柔軟に展開できます。

複数の非同期シーケンスを結合し、値をコレクションにグループ化する方法はいくつかあります。

これらはパッケージに含まれているアルゴリズムのほんの一部です。

「Meet Swift Async Algorithms」トークをチェックして、この新しい強力なAPIをどのように使用できるかを確認してください。

しかし、並行性のもう1つの側面があり、それはパフォーマンスです。

今年は、俳優の優先順位付けにより、俳優は最も優先度の高い仕事を最初に実行します。

そして、オペレーティングシステムスケジューラとの深い統合を継続し、このモデルには優先反転防止が組み込まれているため、重要度の低い作業は優先度の高い作業をブロックすることはできません。

歴史的に、アプリの並行性のパフォーマンスへの影響を視覚化することは本当に困難でした。

しかし今、私たちはまさにそれを行うための素晴らしい新しいツールを持っています。

Instrumentsの新しいSwift並行性ビューは、パフォーマンスの問題を調査するのに役立ちます。

Swift TasksとSwift Actorsのインストゥルメントは、並行性コードを視覚化して最適化するのに役立つツールの完全なスイートを提供します。

トップレベルでは、Swift Tasks Instrumentは、同時に実行されているタスクの数や、その時点で作成されたタスクの合計など、有用な統計情報を提供します。

このウィンドウの下半分には、タスクフォレストと呼ばれるものを見ることができます。

これは、構造化された並行コード内のタスク間の親子関係のグラフィカルな表現を提供します。

これは、Swift Actor Instrumentの詳細なビューの1つにすぎません。

このエキサイティングな新しいツールの使い方を学ぶには、「Swiftの並行性を視覚化して最適化する」というトークに飛び乗りたいと思うでしょう。

そして、それらの新しいパッケージを試してみることを忘れないでください。

フォーラムで何が起こっているのかを私たちに知らせることを恥ずかしがらないでください。

さて、私はそれをベッカに引き渡して、Swift言語の使いやすさの多くの改善について話します。

言語はツールであり、ツールには面白いことがあります - 彼らはあなたがそれらを使って構築するものに本当に影響を与える可能性があります。

あなたが持っているのがハンマーだけなら、ネジの代わりに釘で物を作るつもりです。

そして、あなたがツールのフルセットを持っている場合でも、あなたのドライバーがプラスチックで持ちにくい間、あなたのハンマーが大きくてグリッピーなハンドルを持っている場合、あなたはまだ釘に傾くかもしれません。

言語も同じです。

スウィフトが何かを表現するための良いツールを持っているなら、人々はそれをより頻繁に使うだろう。

そして今年、コードに何をしてほしいかを表現するためのSwiftのツールは、多くの点で改善されました。

これらの変更のいくつかは、あなたが頻繁に行うことのための単純な利便性です。

たとえば、Swiftでは、等号の両側に同じ名前でif letを使用することが本当に一般的です。

結局のところ、おそらくあなたがオプションの名前を与えた名前よりも、ラップされていない値のためのより良い名前はありません。

しかし、名前が本当に長いとき、その繰り返しは面倒になり始めます。

名前を省略したくなるかもしれませんが、コードが不可解になります。

また、後でオプションの変数の名前を変更すると、略語が同期しなくなる可能性があります。

Swift 5.7は、この一般的なパターンの新しい省略形を導入します。

オプションをアンラップしていて、アンラップされた値を同じ名前にしたい場合は、右側をドロップするだけです。

スウィフトはそれが同じだと仮定するだろう。

そしてもちろん、これはガードでも機能し、その間でも機能します。

また、軽微な変更を加えると、機能が突然機能しなくなる場所も調べました。

たとえば、Swiftは、1つのステートメントクロージャ内に書かれたコードに基づいて、コールが返すタイプを常に把握することができました。

このcompactMap呼び出しでは、クロージャはparseLineの値を返し、parseLine関数はMailmapEntryを返すので、SwiftはエントリがMailmapEntryの配列である必要があることを理解できます。

これは、複数のステートメントまたは制御フロー機能を持つ、より複雑なクロージャに対して機能するようになりました。

そのため、クロージャの結果タイプを手動で指定することなく、do-catch、if...else、または単に印刷コールを追加できます。

私たちが見たもう一つのことは、実際の危険にフラグを立てていない危険フラグです。

スウィフトは、タイプとメモリの安全性に非常に関心を持っています。

間違いを防ぐために、異なるポインタタイプのポインタ間、または生のポインタと型付きポインタの間で自動的に変換されることはありません。

これは、特定の変換を可能にするCとは大きく異なります。

たとえば、ポインタの符号性を変更したり、Cのポインタルールに違反することなく、ポインタを文字星にキャストしてバイトとしてアクセスしたりできます。

しかし、ポインタの動作のこれらの違いは、C APIがSwiftにインポートされたときに問題を引き起こすことがあります。

元の開発者は、Cの自動変換によって処理されるが、Swiftのエラーであるわずかな不一致でAPIを設計した可能性があります。

Swiftでは、別のタイプであるかのように1つのタイプのポインタにアクセスすることは非常に危険であるため、非常に明示的に何をしているかを説明する必要があります。

しかし、ポインタをCに直接渡す場合、それはすべて無意味です。なぜなら、Cでは、そのポインタの不一致は完全に合法だからです!

だから、この場合、私たちは何かを危険であるかのように本当に率直に扱いました。

Swiftがタイプの安全性を評価するのと同じくらい、Cファミリーコードへの簡単なアクセスも重視しているため、これは重要です。

それが、CとObjective-Cの相互運用が非常に豊かでシームレスである理由であり、Swiftプロジェクトがアンジェラが先に述べたC ++ワーキンググループを形成し、同等に有能なC ++相互運用の構築を開始する理由です。

このようなC関数の使用が不必要に苦痛になることを望んでいません。

そのため、Swiftには、インポートされた関数とメソッドを呼び出すための別のルールセットがあります。

通常はSwiftになくても、Cで合法になるポインタ変換を可能にします。

そうすれば、SwiftコードはこれらのAPIをシームレスに使用できます。

これまでのところ、あなたがすでに持っていたツールの小さな改善について話しました。

しかし、今年、Swiftには文字列から情報を抽出するためのまったく新しいツールもあります。

これは、文字列からいくつかの情報を解析する関数です。

この種のタスクは、Swiftでは常にちょっとした課題でした。

欲しいものを手に入れるまで、検索し、分割し、スライスし、何度も何度もスライスすることになります。

人々がこれに気づくと、文字列インデックスを操作することがどれほど冗長であるかなど、ささいなことに焦点を当てる傾向がありますが、それは全体像を見逃していると思います。

この構文を変更しても、このコードを見たときに尋ねている基本的な質問に答えるのに役立たないからです - 渡された行変数は実際にどのように見えますか?

どんな弦を分解しようとしているのですか?

十分に長く見つめていると、メールマップの簡略化されたバージョンを解析していることに気付くかもしれません。これは、古いコミットで開発者の名前を修正するためにgitリポジトリに入れたファイルです。

しかし、検索とスライスによってその情報を抽出することは非常に複雑であるため、それを理解することは困難です。

弦をスライスする方法に迷うので、その弦が何であるかを見失います。

問題はこれら2つの表現ではなく、問題は全体です。

私たちはこれをすべて引き裂いて、より良いものに置き換える必要があります。

別のアプローチが必要です。コードが一致させたい文字列の絵を描き、言語がその方法を理解するアプローチです。

宣言的なアプローチであり、必須のアプローチではありません。

Swift 5.7では、正規表現を書くことでそれができるようになりました。

正規表現は、文字列内のパターンを記述する方法です。

50年以上にわたり、言語とツールにより、開発者は緻密で情報満載の構文で正規表現を書くことができました。

すでにXcode検索バー、grepなどのコマンドラインツール、FoundationのNSRegularExpressionクラス、または他のプログラミング言語で使用している人もいます。

その構文は現在、Swiftの正規表現リテラルでサポートされており、他の開発者ツールと同じように機能します。

しかし、あなた方の何人かは以前に正規表現を使ったことがなく、おそらく「それは本当のコードですか、それとも猫がキーボードを横切って歩いたのですか?」と言うでしょう。

そして、私はあなたを責めません。

正規表現リテラルは、それらを読むために暗記しなければならない記号とニーモニックで書かれています。

言語を知っている人にとっては、開発者の名前に一致する部分のように、この正規表現の最も厄介な部分でさえ、いくつかの単純なマッチングルールの組み合わせにすぎません。

しかし、それは11文字に詰め込むための多くの行動です。

正規表現リテラルは非常にコンパクトであるため、経験豊富な開発者でさえ、複雑なものを理解するのに1分かかることがあります。

しかし、記号の代わりに単語だけで、同じ種類のマッチングルールを書くことができたらどうでしょうか?

それは理解しやすいようです。それは理解しやすいようです

実際、すべてをまとめると、SwiftUIによく似たものが手に入る。

それは正規表現リテラルに代わる素晴らしい選択肢ですよね?

だから、スウィフトがそれをサポートするのは良いことです!

RegexBuilderライブラリは、従来の構文よりも使いやすく、読みやすい正規表現用のまったく新しいSwiftUIスタイルの言語を提供します。

正規表現リテラルと同じことをすることができますが、暗記しなければならない記号や略語の代わりに、理解したり調べたりできる言葉でその動作を説明しています。

正規表現ビルダーは初心者に最適ですが、これは初心者のみの機能とは程遠いです。

それは、正規表現リテラルができることをはるかに超えた強力な機能を持っています。

まず、SwiftUIビュー階層をビューに変えるのと同じように、正規表現を再利用可能な正規表現コンポーネントに変えることができます。

ビルダー構文で作成された他の正規表現からこれらのコンポーネントを使用することができ、それらを再帰的にすることもできます。

正規表現ビルダーは、いくつかのSwiftタイプを正規表現に直接ドロップすることもサポートしています。

たとえば、文字列リテラルは、その中の正確なテキストと一致するだけで、特別なエスケープは必要ありません。

正規表現ビルダーの途中で正規表現リテラルを使用することもできます。

そのため、正規表現ビルダーの明快さと正規表現リテラルの簡潔さのバランスを取ることができます。

また、このFoundationの日付フォーマットスタイルのような他のタイプは、カスタム解析ロジックを正規表現ビルダーと統合し、データをキャプチャする前にデータをよりリッチなタイプに変換することもできます。

最後に、どの構文を使用しても、正規表現は、使いやすい便利なマッチングメソッドと強く型付けされたキャプチャの束をサポートしています。

現在、席で身をかがめている正規表現オタクのために、Swift Regexは、最先端の正規表現の実装に匹敵する機能セットを備えた、まったく新しいオープンソースマッチングエンジンを使用しています。

リテラル構文はUnicode正規表現標準と互換性があり、珍しいレベルのUnicodeの正確性を持っています。

たとえば、ドットはデフォルトでUnicode.ScalarやUTF-8バイトではなく、文字全体に一致します。

Swift Regexを使用するには、macOS 13やiOS 16など、Swift Regexエンジンが組み込まれたOSでアプリを実行する必要があります。

Swift Regexは言語全体です-まあ、2つの言語、本当に-なので、それについて言うべきことはもっとたくさんあります。

「Meet Swift Regex」と「Swift Regex: Beyond The Basics」の2つのセッションでは、その使用についてさらに詳しく説明します。

最後に、私たちが持っているツールを包括的に検討し、それらを改善するために多くの変更を加えた場所が1つあります。

それはジェネリックとプロトコルです。

これらのツールがどのように改善されたかを示すために、プロトコルの例が必要です。

Gitクライアントを書いていて、メールマップを2つの異なる方法で表現しなければならないとしましょう。

コミットを表示するときは、辞書付きのタイプを使用して名前をすばやく検索します。

しかし、ユーザーにメールマップを編集させるときは、配列を持つタイプを使用して、エントリを元の順序で保持します。

また、両方とも準拠するMailmapというプロトコルがあるので、mailmapパーサーはどちらのタイプにもエントリを追加できます。

しかし、パーサーがMailmapプロトコルを使用できる方法は2つあります。

私はそれらを説明するためにこのaddEntries関数の2つの異なるバージョンを書きましたが、Swiftは2つの異なるものに同じ構文を使用しているため、実際にどのように異なるかを説明するのは難しいです。

「メールマップ」という言葉はここでは1つのことを意味するが、ここでは微妙に異なることを意味することがわかった。

継承リスト、汎用パラメータリスト、汎用適合性制約、または不透明な結果型でプロトコルに名前を付けると、「このプロトコルに準拠したインスタンス」を意味します。

しかし、変数型、ジェネリック引数、ジェネリック同型制約、または関数パラメータまたは結果型では、実際には「このプロトコルに準拠したインスタンスを含むボックス」を意味します。

この区別は、ボックスは通常、より多くのスペースを使用し、操作に時間がかかり、内部のインスタンスのすべての機能を備えていないため、重要です。

しかし、あなたが箱を使用している場所は、あなたがいない場所のように見えるので、あなたが箱を使用しているかどうかを理解するのは難しいです。

Swift 5.7はこの見落としを修正します。

適合型を含むこれらのボックスの1つを使用している場合、Swiftは任意のキーワードを書くことを期待します。

これは、Swift 5.7より前に有効だったコードでは必須ではありませんが、明示的に書き出さなくても、生成されたインターフェイスやエラーメッセージに表示されることが推奨されています。

したがって、右側の列にこれらすべてを書く好ましい方法は、任意のキーワードです。

そうすると、これらのボックスの1つを使用しているときにわかります。

この例では、任意のキーワードがパラメータの1つをマークしたので、これら2つの関数の違いを説明するのがはるかに簡単になりました。

addEntries1はMailmapを汎用型として受け取り、addEntries2は任意の型として受け取ります。

また、エラーメッセージは、任意のタイプの制限の1つにヒットしたときに何が起こっているかを説明するのも簡単です。

たとえば、このmergeMailmaps関数は、任意のMailmapを一般的なMailmapパラメータに渡そうとします。

これは、Mailmapがそれ自体に準拠できないというエラーを生成するために使用されていましたが、これは常に逆説的に思えました。

しかし、今、私たちはあらゆるタイプの概念を持っているので、何が起こっているのかをより明確に説明することができます。

問題は、メールマップ（メールマップを含むボックス）がメールマッププロトコルに準拠していないことです。

しかし、ボックスはあなたが渡そうとしているものであり、一般的なパラメータには収まりません。

ここのボックス内のインスタンスを渡したい場合は、何とかボックスを開き、その中のメールマップを取り出し、代わりにそれを渡す必要があります。

しかし、実際には、このような単純なケースでは、スウィフトは今あなたのためにそれを行います。

ボックスを開き、その中のインスタンスを取り出し、一般的なパラメータに渡します。

だから、あなたはもうこのエラーメッセージを見ることはないでしょう。

しかし、それよりもどんなタイプにもさらにエキサイティングな改善があります。

以前は、プロトコルがセルフタイプを使用した場合、または関連するタイプがある場合、またはEquatableのようなプロトコルに準拠している場合は、どのタイプとしても使用できませんでした。

しかし、Swift 5.7では、このエラーはちょうど--poof--消えました。

多くの開発者がこれに苦労しているので、ソースで修正したことに興奮しています。

さて、それはMailmapのようなプロトコルのためだけに十分にエキサイティングですが、これはさらに進んでいます。

コレクションのような非常に洗練されたプロトコルでさえ、あらゆるタイプとして使用できるからです。

「プライマリ関連タイプ」と呼ばれる新機能のおかげで、要素タイプを指定することもできます。

関連する多くのタイプは、基本的に実装の詳細にすぎません。

通常、コレクションがインデックス、イテレータ、またはサブシーケンスにどのタイプを使用するかは気にしません。サポートするタイプを使用するだけです。

しかし、その要素は別の話です。

コレクションがどの要素タイプを使用するかを必ずしも気にしていないかもしれませんが、おそらく要素で何かをするつもりなので、それらを制限するか、それらを返すか、何かを返す必要があります。

プロトコルのほぼすべてのユーザーが気にするElementのような関連タイプがある場合、プロトコルの名前の後にその名前を角括弧に入れて、主要な関連タイプにすることができます。

これを行うと、プロトコルの主要な関連タイプを、コレクションを含め、プロトコルの名前を書くことができる場所ならどこでも、アングルブラケット構文で制限できます。

さて、このタイプを見て、「ちょっと待ってください。」と行く人もいるかもしれません。

AnyCollectionと呼ばれるものがすでに存在しませんか、ただ一緒に実行し、「任意の」を大文字にして実行するだけですか?

そして、あなたは正しいです、あります!

古いAnyCollectionは、タイプ消去ラッパーであり、任意のタイプと同じ目的を果たす手書きの構造体です。

違いは、AnyCollection構造体は、あなたが今まで見た中で最も退屈な定型コードの行に次ぐものであるということです。一方、任意のタイプは基本的に同じことをする組み込みの言語機能です - 無料で!

今、AnyCollection構造体は下位互換性のために固執し、どのタイプもまだ完全に一致できないいくつかの機能を持っているため、固執します。

しかし、コードに独自のタイプ消去ラッパーがある場合は、ボックスクラスやクロージャの代わりに組み込みの任意のタイプを使用してそれらを再実装できるかどうかを確認したいと思うかもしれません。

あるいは、それらをタイプエイリアスに置き換えることもできます。

そのため、Swiftはあらゆるタイプを劇的に改善しました。

任意のキーワードが導入されているので、使用している場所を確認できます。

これにより、それらを一般的な引数に渡すことができます。

多くのプロトコルがそれらと一緒に使用されないようにする制限を廃止しました。

また、任意のタイプのプライマリ関連タイプを制限することもできます。

しかし、これらすべての改善があっても、どのタイプにもまだ制限があります。

たとえば、MailmapがEquatableに準拠している場合、任意のMailmapsを使用できるようになりましたが、equals演算子は両方のmailmapが同じ具体的なタイプを持つ必要があるため、equals演算子を使用することはできませんが、2つのMailmapを使用している場合は保証されません。

したがって、Swiftはあらゆるタイプを大幅に改善しましたが、機能とパフォーマンスの両方にはまだ重要な制限があります。

だからこそ、多くの場合、それらを使用すべきではなく、代わりにジェネリック医薬品を使用する必要があります。

それでは、addEntriesの2つのバージョンに戻り、その知恵を適用しましょう。

どちらのバージョンもまったく同じことをしますが、上部のものはジェネリックタイプを使用し、下部のものは任意のタイプを使用します。

ジェネリックバージョンは、より効率的で有能である可能性が高いので、それを使用する必要があります。

それでも、読み書きがとても簡単なので、おそらくどんなタイプでも使いたくなるでしょう。

ジェネリックバージョンを書くには、2つのジェネリックタイプ名を宣言し、両方を制約し、最後に、それらのジェネリックタイプ名をパラメータのタイプとして使用する必要があります。

「任意のコレクション」と「任意のメールマップ」を書くのに比べて、それはただ疲れます。

だから、欠点にもかかわらず、どんなタイプでも使いたくなるでしょう。

しかし、それは私が前に話していたのと同じことです - ハンマーは大きくてグリップ力のあるハンドルを持っているので、ドライバーの代わりにハンマーを使用してください。

あなたはその選択をする必要はありません。

そのため、Swiftはジェネリック医薬品をあらゆるタイプと同じくらい使いやすいものにしています。

汎用パラメータが1か所でのみ使用されている場合は、略語としてsomeキーワードで書くことができます。

また、主要な関連タイプもサポートしているので、はるかに理解しやすいコードでメールマップエントリのすべてのコレクションを受け入れることができます。

それはあなたのツールボックスで、もうジェネリック医薬品を避ける理由はありません。

ジェネリックと任意のタイプのどちらかを選択できる場合、ジェネリックは同じように使いやすいです。「any」ではなく「some」と書くだけです。

だから、仕事に最適なツールを使った方がいいかもしれません。

私はプロトコルとジェネリックへのこれらの変更の表面を引っ掻いただけです。

詳細な外観と、Swiftのすべてのジェネリック機能の素晴らしいレビューについては、今年はさらに2つの講演があります。「Embrace Swiftジェネリック」と「Swiftでプロトコルインターフェイスを設計する」です。

さて、アンジェラと私はスウィフトの2ダース近くの変更について話しましたが、このセッションに収まらないことがたくさんあります。

これらの変更はすべて、スウィフトフォーラムのEvolutionボードで売り込まれ、提案され、レビューされ、公に受け入れられました。

そして、それらはすべて、Apple外部のコミュニティメンバーの助けを借りて形作られ、実現されました。

あなたがその一人なら、Swift 5.7を素晴らしいリリースにしてくれてありがとう。

そして、次に何が起こるかを決めるのを手伝いたい場合は、Swift.org/contributingにアクセスして参加方法を確認してください。

お時間をいただきありがとうございます。

そして幸せなコーディング。

♪