110347

♪ ♪

こんにちは、WWDCへようこそ。

私の名前はデビッドです。MusicKitでより多くのコンテンツを探索する方法についてお話ししたいと思います。

MusicKitフレームワークは2021年に開始され、Swiftでネイティブに音楽にアクセスして再生するための一連のAPIを提供します。

このフレームワークにより、アプリがApple Musicと簡単に統合でき、Apple Musicカタログ全体にアクセスできます。

今日は、MusicKitの主な機能強化についてお話ししたいと思います。 いくつかお話ししたいと思います。

新しい音楽アイテムの種類、新しいリクエスト、新しいメタデータを使用して、Apple Musicカタログをさらに引き出すために、いくつかの追加から始めます。

その後、パーソナライズされたコンテンツを取得して、ユーザーごとにカスタマイズされたエクスペリエンスを提供する方法について説明します。

次に、Apple Musicのカタログを超えます。

今年は、ユーザーのライブラリから音楽を含めることで、アプリをまったく新しいレベルに引き上げることができます。

最後に、ライブラリやプレイリストにアイテムを追加したり、プレイリストを作成したり編集したりするなど、ライブラリと積極的にやり取りする方法について説明します。

カタログコンテンツの追加に飛び込みましょう。

MusicKitの最初のリリースでは、曲、アルバム、プレイリストなどのコアタイプを含む音楽の新しいモデルレイヤーが導入されました。

今年は、キュレーターとラジオショーの2つの新しいタイプを追加して、MusicKitで新しい音楽を簡単に発見できるようにしています。

さらに、MusicKitでは、カタログを検索するための優れたUIを構築したり、トップチャートにアクセスして最も人気のある曲、アルバムなどを取得したり、ドルビーアトモスの空間オーディオなどの高品質のオーディオメタデータなどの新しい属性を取得したりすることもできます。

音楽の発見のための素晴らしいリソースであるキュレーターとラジオ番組から始めましょう。

ここでは、キュレーターのナイキの例を見ていきます。

キュレーターの他の例は、ShazamとBeats by Drです。ドレー。

ここでは、このキュレーターによって生成されたすべてのプレイリストを簡単に見つけることができます。

この機能により、人々は好きなプレイリストにすばやくアクセスしたり、新しい曲を見つけたり、古いお気に入りを再訪したりすることができます。

では、より技術的な詳細を掘り下げてみましょう。

キュレーターはさまざまな属性をホストしています。

この新しいキュレータータイプの主な属性のいくつかは、名前、URL、アートワーク、および種類です。

種類のプロパティは、特定のキュレーターがAppleキュレーターであるか第三者キュレーターであるかを示す「編集」または「外部」のいずれかであることができる列挙です。

キュレーターはまた、そのキュレーターによって作られたプレイリストを示すプレイリスト関係を持っており、私たちが今見た音楽発見の概念に本当に奉仕しています。

次に、ラジオ番組タイプがあります。

「New Music Daily by Zane Lowe」や「Pop Hits Radio by Brooke Reese」などのラジオ番組は、熟練した専門家を通じて新しい音楽を発見するもう1つの方法です。

キュレータータイプと同様に、ラジオ番組には、ラジオ番組の特徴である音楽を見つけるためのプレイリストの関係もあります。

これら2つの新しいタイプがプレイリストとの関係を保持するように、私たちはまた、逆のロジックのためにプレイリストタイプの「キュレーター」と「ラジオショー」の2つの新しい関係を公開しています。プレイリストが与えられた場合、そのプレイリストを生成したエンティティの構造を簡単に取得できます。

MusicKitでは、多数のタイプのコンテンツをカタログで検索できます。現在、キュレーターやラジオ番組などの新しいアイテムタイプのサポートを追加しています。

リストは増え続けており、その結果、優れたUIの構築はますます困難になっています。

だからこそ、今年は、最高の結果と提案を通じて、あなたのためにそれをはるかに簡単にしています。

これらの機能強化がUIにもたらすユーティリティを見てみましょう。

コンテンツを検索するために入力するときは、音楽関連の強力なオートコンプリートサポートを提供したいと思うかもしれません。

そこで提案が作用し、人々が到達しようとしている可能性のある条件を提供します。

さらに一歩進んで、トップの結果を表示して、人々が探しているものにすばやくアクセスすることもできます。

最良の結果を得るには、アイテムの種類を気にせず、代わりに関連性に焦点を当てたいと思うかもしれません。

これがトップ結果の力です。

さて、トップ結果から始めて、これを実装する方法を見てみましょう。

ここでは、カタログ検索リクエストを作成する既存の方法があり、検索語と表現したいアイテムの種類が必要です。

応答には、要求されたタイプによって分類されたコレクションを含み、タイプ固有の結果の複数のリストを意味します。

これは素晴らしいことですが、型に依存しない最も関連性の高い結果の単一のリストを公開したいと考えています。

そして、この情報を要求するのは、1行を追加するのと同じくらい簡単です。

ここでは、リクエストのincludeTopResultsプロパティをtrueに設定し、応答に新しいプロパティが入力されます。

この新しいプロパティは、要求されたタイプの項目を含むtopResultsという名前です。

印刷ステートメントの出力は次のようになります。

返されるトップの結果は、単一のコレクションの曲、アーティスト、アルバムのミックスであり、関連性によって順序付けられていることがわかります。

さて、私は人々が提案でより早く検索先に着くのを助ける方法を紹介します。

文字列用語で提案リクエストを作成するだけです。

応答を呼び出すと、提案応答が返されます。

応答には、提案の配列が含まれています。

また、各提案には、UIに適した表示用語と検索用語が含まれています。

ユーザーが提案を選択すると、検索語で検索リクエストを実行することで、対応する結果を取得できます。

カタログチャートは、最も人気のある曲を最新の状態に保つのに最適な方法です。

MusicKitは、トレンドを確認するために、さまざまな種類のチャートを提供しています。

提供されているチャートの種類は、最も再生された音楽、都市チャート、毎日のトップ100に対応するトップソングやトップアルバムなどのトップチャートです。

また、特定のジャンルでフィルタリングする要求されたチャートを指定することもできます。

コードでこれらのチャートを取得するのは非常に簡単です。

カタログチャート要求は、カタログ検索要求ですでに使用されている確立されたパターンに従います。

まず、チャートリクエストを初期化します。

その後、好きなチャートの種類を指定できます。

デフォルトでは、これは最も再生されたコンテンツを取得しますが、毎日のグローバルトップチャートや都市トップチャートを含めることもできます。

最後に、チャートに含めるタイプを指定するだけです。

そして、それだけです。

応答の最初のプレイリストチャートにアクセスすると、毎日のグローバルトップチャートを表すMusicCatalogChartを取得します。

そのアイテムは「Top 100: Global」や「Top 100: USA」などのプレイリストです。

過去にMusicDataRequestを使用してカタログチャートを取得していた場合は、アイテムのコレクションにページネーションサポートが組み込まれているため、MusicKitがあなたのために仕事をするので、もはやする必要はありません。

2021年には、真の多次元サウンドと明瞭さを備えた画期的なオーディオ体験を導入しました。ドルビーアトモスをサポートする空間オーディオです。

この没入型体験はすでに何千もの曲で利用でき、このデータにアクセスできるようになりました。

MusicKitは、Audio Variantsを通じて任意の曲やアルバムで利用可能なオーディオリソースを公開するので、この情報を他の人に伝えることができます。

オーディオバリアントの例は、前述のドルビーアトモス付き空間オーディオ、ロスレスオーディオなどです。

また、オーディオバリアントと並んで新しいブールプロパティを公開しています。Apple Digital Masterは、サポートされている最高品質のマスターです。

このメタデータはアイテムレベルで公開されるため、オーディオバリアントは詳細ビューに最適で、このようなUIを実現できます。

ここでは、アルバムの詳細ビューがあります。

そして、ここでは、前述のオーディオバリアントプロパティに基づいて適切なバッジを見ることができ、ユーザーに期待できるオーディオ品質を知らせることができます。

この場合、この特定のアルバムでは空間オーディオとロスレスオーディオが利用可能です。

それでは、これを達成するためにコードを書く方法を見てみましょう。

オーディオバリアントの読み込みは、他の拡張属性の読み込みに似ています。

既存のアルバムまたは曲、この場合はアルバムを取り、withメソッドを使用してaudioVariants拡張属性をロードします。

これで、detailAlbumにaudioVariantsプロパティが入力されました。

ここでは、要素がAudioVariantである配列であるaudio variantsプロパティを見ることができます。

これらの値を使用すると、先ほど見たように、その特定の要素で利用可能なオーディオリソースをUIで示すことができます。

さて、これは素晴らしいですが、これらのオーディオバッジをトップレベルや詳細ビュー以上のもので表示したいと思うかもしれません。

だからこそ、私たちはさらに一歩進んで、音楽プレーヤーのアクティブなオーディオバリアントを公開しています。

アクティブなオーディオバリアントにアクセスすると、このビューでドルビーアトモスなど、現在再生中のアイテムのオーディオ品質を視覚的に表示できます。

また、MusicKitプレーヤーAPIは、ユーザーの設定とネットワーク条件に基づいて正しいオーディオ品質を自動的に選択します。

プレーヤーからアクティブな特性にアクセスするには、まず、観察されたオブジェクトでApplicationMusicPlayerの再生状態にアクセスします。

その後、再生状態から直接アクティブなaudioVariantにアクセスできます。今、audioVariantプロパティをチェックしてdolbyAtmosであるかどうかを確認し、追加UIを追加するだけです。

再生状態は観察されたオブジェクトであるため、このビューは、現在再生中のアイテムが変更されるたびに自動的に更新され、ビューが常に最新であることを確認します。

カタログの追加をいくつか見てきたので、パーソナライズされたコンテンツの取得に飛び込みましょう。

パーソナライズされたコンテンツは、加入者に固有のデータであり、アプリ内のすべてのユーザーにユニークでカスタマイズされた体験を提供します。

通常、パーソナライズされたコンテンツには特別な認証とユーザートークンが必要ですが、MusicKitフレームワークでは、これをすべて自動化したので、面倒に対処する必要はありません。

私たちが開発者にもたらしているパーソナライズされたコンテンツは、最近再生されたアイテムや個人的な推奨事項へのアクセスです。

最近再生されたコンテンツは、人の音楽消費体験のための貴重なデータです。

それはあなたが彼らが楽しんでいることを知っている音楽アイテムに迅速かつ簡単にアクセスすることができます。

そして、新しい音楽を聴くとき、それは人々が後で戻って彼らの歴史を参照することを可能にします。

アルバム、プレイリスト、ステーションなどの最近再生されたコンテナを取得するには、最近再生されたコンテナリクエストを作成できます。

プレイリストやアルバムから曲を再生すると、コンテナタイプが検索されることに注意してください。

応答には、タイトル、字幕、アートワークの便利なアクセサを提供する、最近再生された音楽アイテムがあります。

曲やステーションなど、より具体的なタイプの最近再生されたアイテムを取得することもできます。

ここでは、最近再生されたリクエストを作成し、山括弧で示される汎用パラメータを使用してソングタイプを指定します。

私たちの回答には、私たちが演奏した曲のみが含まれています。

さて、個人的な推薦について。

個人的な推奨事項は、ユーザーのライブラリとリスニング履歴に基づいて生成されるため、アプリ体験をより親密で魅力的に感じさせます。

推奨事項はテーマごとにうまく整理され、ジャンル、アーティスト、「Made for You」などのコレクションごとにグループ化されます。

個人的な推薦を取得するには、個人的な推薦リクエストを作成するだけです。

回答は推奨事項の集まりです。

最初の推奨事項を記録すると、この特定の要素が「Made for You」の推奨事項を表していることがわかります。

推奨事項には、ID、タイトル、およびnextRefreshDateがあります。

nextRefreshDateは、最新の提案のためにこの推奨事項を更新する必要がある日時を表します。

プレイリストのプロパティには、私のために作られたすべてのプレイリストが含まれています。

推奨事項の別の例を見てみましょう。

ここでは、推奨事項の応答の2番目の要素を印刷します。

私はたくさんのオルタナティブ音楽を聴いていますが、この推奨事項には、さまざまなタイプ、この場合はアルバムとプレイリストのミックスが含まれています。

これらは、カタログ検索のトップ結果と同様に、関連性順に並べられたアイテムの単一のコレクションにグループ化されています。

では、さらに一歩進んで、ユーザーのライブラリのコンテンツをアプリに組み込むことで、音楽に関するより関連性の高い体験を作成する方法について話しましょう。

今年、MusicKitを使用すると、アプリは2種類のリクエストでライブラリからアイテムを取得できます。ライブラリリクエストとライブラリセクションリクエスト、ユーザーのライブラリ内のコンテンツの検索、特にライブラリから拡張属性と関係をロードします。

技術的な詳細を見る前に、ライブラリコンテンツを使用してアプリを強化する方法を見てみましょう。

私はあなたの屋外ランニングを追跡するミュージックマラソンというフィットネスアプリに取り組んできました。

プロジェクトにMusicKitを組み込むことで、Apple Musicアプリとこのアプリの間でコンテキストを切り替えるのではなく、アプリから直接音楽を再生できるようにします。

新しいワークアウトを始めて、音楽コンテンツを探そう。

ここでは、人々が彼らが気に入ると思うプレイリストにすばやくアクセスできるように、個人的な推奨リクエストから取得されたいくつかの推奨プレイリストが表示されます。

ライブラリタブに行くと、空のビューであることがわかります。

私の個人的なプレイリストをすべて見ることができるのは素晴らしいので、その機能を書きましょう。

私はすでにこのビューの基本を処理するためにいくつかのUIを設定しています、そして今、私は私のライブラリからプレイリストをロードしたいです。

まず、図書館のリクエストをします...

一般的なパラメータでプレイリストを指定して、ユーザーのライブラリからプレイリストが欲しいことを示します。

そして、それをローカル変数に格納し、「request」と名付けます。

次に、このリクエストを受けて、応答関数を呼び出します。

このメソッドは非同期スローメソッドなので、try and awaitキーワードを追加しましょう。

そして、もう一度それを応答変数に格納します。

次に、この応答を受け取るために状態オブジェクトを更新します。

今、残っているのは、私のUIでプレイリストを見ることができるようにリストを更新することだけです。

ForEachを使用して、応答の項目を反復します。

そして、MusicItemCollectionで各プレイリストを取得します。

プレイリストがわかったので、すでに作ったPlaylistCellに渡します。

今、私たちが再実行したら...

そして、アプリに戻ると、ライブラリで私の個人的なプレイリストをすべて見ることができます。

今、私は個人的な推奨事項、Apple Musicカタログから何でも、そして自分の個人的なライブラリを聴くことを選ぶことができます。

ライブラリのコンテンツへのアクセスがどれほど簡単かがわかったので、ライブラリのリクエストで他に何ができるかを見てみましょう。

音楽ライブラリのリクエストは、ユーザーのライブラリからアイテムを取得するための強力なAPIです。

iOSでは、音楽カタログからコンテンツを取得する他のリクエストとは異なり、MusicLibraryRequestは実際にネットワークからデータをロードしません。

代わりに、デバイスに保存されているユーザーのライブラリのコピーからアイテムをロードします。

このリクエストの基本では、必要な音楽アイテムの種類を指定するだけです。

このアイテムタイプは、MusicLibraryRequestの一般的なパラメータを介して渡されます。

要件に合わせて通話を細かく調整するために、リクエストにさまざまなフィルターとソートオプションを適用できます。

このリクエストは、すでにダウンロードしたコンテンツを取得することもでき、完全にオフラインのエクスペリエンスをサポートします。

シンプルな基本リクエストから始めましょう。ミュージックマラソンアプリで書いたのと同じリクエストですが、今回はライブラリのアルバムを依頼してください。

アルバムタイプは、一般的なパラメータで指定されます。

要求を実行するには、応答関数を呼び出します。

出力を見ると、MusicLibraryResponseがあり、そのアイテムはユーザーの音楽ライブラリ内にあるすべてのアルバムのMusicItemCollectionです。

ここでは、これらのアルバムは、さまざまなカタログリクエストの1つから得られるのと同じアルバム構造であり、同じ機能を持っていることがわかります。

この例では、ライブラリ内のすべてのアルバムを取得していますが、アルバムの特定のサブセットのみを必要なシナリオがあることを知っています。

そのため、MusicLibraryRequestでは、ライブラリから取得したいアイテムをより具体的にすることもできます。

前に書いたのと同じリクエストを受けて、フィルターを追加しましょう。

ここでは、isCompilationプロパティがtrueに等しいすべてのアルバムをロードします。

フィルターメソッドを呼び出すと、Xcodeのオートコンプリートは、要求するアイテムのタイプでサポートされている特定のキーパスのみを提供します。

さて、応答にはコンピレーションであるアルバムしかありません。

しかし、それはMusicLibraryRequestが提供するすべての力ではありません。

複数のフィルターをチェーン接続できるため、追加するたびにより洗練されたリクエストが得られます。

特定のジャンルのすべてのコンピレーションが欲しかったらどうなりますか?

リクエストに別のフィルターを追加できます。

例えば、ここには「ダンス」という名前のジャンルのインスタンスがあります。

ジャンルの関係でフィルタリングして、この特定のジャンルを含むコンパイルのみを含むように結果を制限できます。

今、私たちの応答にはダンスコンピレーションのみが含まれています。

すでにダウンロードされているダンスコンピレーションだけを含めるのはどうですか？

これを行うには、リクエスト時にincludeOnlyDownloadedContentをtrueに設定するだけです。

そして、それだけです。

応答は同じMusicLibraryResponseですが、アイテムにはダウンロードされた要素のみが含まれています。

ご覧のとおり、音楽ライブラリのリクエストは非常に強力で、カスタムMusicDataRequestでは不可能だった新しい機能のロックを解除します。

しかし、MusicKitは、ユーザーのライブラリからデータを取得するためのさらに多くのオプションを提供します。

図書館のセクションリクエストを満たします。

セクション化されたリクエストは、セクションごとにグループ化されたアイテムを取得できます。

その結果、セクション化された要求は2つの異なる汎用パラメータを取ります。

1つ目はセクションタイプを表し、2つ目はアイテムタイプを表します。

ライブラリセクション要求は、セクションまたはアイテムのいずれかに適用できるさまざまなフィルタおよびソートメソッドなど、通常のライブラリ要求と同じ機能をサポートしています。

ライブラリのセクションリクエストを使用して、ジャンルごとにセクション化されたすべてのアルバムを取得する方法は次のとおりです。

セクション化された応答には、「セクション」という名前のプロパティがあり、各要素は要求の最初の汎用パラメータ、この場合はジャンルに対応します。

各ジャンルは、独自の属性を公開するだけでなく、アイテムプロパティを介してアクセスできるアルバムのコレクションも含まれています。

これらの項目は、2番目の一般的な引数に対応しています。

ここでは、ハイライトはジャンルがオルタナティブであるアルバムを示しています。

そして、前述したように、フィルタリングとソートの機能もこのセクション化された要求で利用できます。

ジャンル別に区切られた同じアルバムが欲しいが、アルバムはアーティストの名前でソートされたとしましょう。

ソートフィルターを追加します。

アルバムでartistName keyPathを指定し、これらを昇順にしたいと言うことで、応答をソートしています。

セクションではなくアイテムに適用するソートを指定しているため、メソッドはsortItemsであることに注意してください。

セクションを指定したい場合は、filterSectionsとsortSectionメソッドのセットが利用可能です。

新しい反応を見てみましょう。 見てみましょう。

アルバムがタイトルではなくアーティスト名でアルファベット順に並べられていることがわかります。

ライブラリ要求とライブラリセクション要求の両方が非常に強力ですが、ユーザーのライブラリから検索結果を追加することで、音楽検索UIを補完することもできます。

そのため、カタログ検索とほぼ同じように動作する新しい構造化要求を追加しましたが、カタログから結果をロードする代わりに、ユーザーのライブラリで関連するアイテムを見つけます。

カタログと同様に、ライブラリの検索要求には検索語と型の配列のみが必要です。

ユーザーのライブラリからアイテムを取得するさまざまな方法を見たので、拡張属性と関係を読み込むのはどうですか?

ご存知かもしれませんが、MusicKitの最初のリリースでは、Apple Music APIからこれらのプロパティを簡単にロードするwithメソッドが導入されました。

今年は、好ましいソースパラメータも取り込む方法で電流を増強します。

この優先ソースは、Apple Musicカタログとユーザーのライブラリの両方で利用可能な拡張属性と関係について、どこからデータをロードするかを示します。

また、カタログまたはライブラリにのみ存するプロパティについては、優先ソースに関係なくフェッチされ、何も無視されません。

さらに、カタログリクエスト、ライブラリリクエストなど、最初のアイテムがどこから来たのかに関係なく、この機能を使用できます。

それはすべてうまくいきます。

ここでは、音楽アイテムの関係を受け取る既知の方法があります。

アルバムのトラックをロードしており、出力を表示すると、そのアルバムのすべてのトラックを見ることができます。

ただし、preferredSourceプロパティの新しい追加により、ライブラリからこの関係を取得することを指定できます。

現在、私たちの出力には、ライブラリで見つかったアルバムのトラックのみが含まれています。

ユーザーのライブラリからアイテムを取得できるさまざまな方法で、ユーザーがMusicKitを通じてライブラリを直接操作できるようにすることは理にかなっています。

私のサンプルアプリ、ミュージックマラソンに戻って、ライブラリが提供する機能のいくつかを見てみましょう。

ワークアウト中、私の個人的な推奨事項のいくつかを閲覧したいと思います。

トラックを見ると、これらの曲の1つが私のワークアウトプレイリストに最適であることに気づきます。

これらのセルの1つを押したままにすると、コンテキストメニューがポップアップし、この曲をプレイリストに追加できます。

それを押すと、すべてのプレイリストのポップアップが再び表示されます。

選択したトラックをどのプレイリストにでも追加するコードを書きましょう。

私はすでに選択したアイテムをAddToPlaylistCellセルにパイプしたので、共有インスタンスを介してMusicLibraryにアクセスするだけです。

「追加」メソッドを呼び出して、選択したトラックと追加するプレイリストを指定します。

このメソッドは非同期スロー関数でもあるので、try and awaitキーワードをもう一度追加します。

最後に、isShowingPlaylistPickerバインディング変数をfalseに設定して、ピッカーを閉じます。

今、再実行してプレイリストにトラックを追加し、プレイリストの1つを選択すると、このアイテムが追加されることを期待する必要があります。

アプリ内のライブラリタブに戻ると、曲がワークアウトプレイリストに追加されていることがわかります。

そして、プレイリストにアイテムを追加するのはとても簡単です。

ライブラリが提供する他の機能のいくつかを見てみましょう。

ライブラリと対話する他のさまざまな方法は、ライブラリにコンテンツを追加したり、プレイリストを作成したり、プレイリストのメタデータとトラックリストを編集したりすることです。

ユーザーの音楽ライブラリにコンテンツを追加すると、Apple Musicアプリのライブラリタブで特定の曲やアルバムを見つけることができ、設定で「ライブラリを同期」がオンになっているときにすべてのデバイス間で同期できます。

この機能をアプリで直接提供することで、Apple Musicアプリとあなたのアプリの間のコンテキストの切り替えから人々を救うので、彼らはあなたが提供しているコンテンツに関わり続けることができます。

また、新しく導入されたライブラリリクエストと一緒にライブラリへの追加を統合することで、アプリはこれらの結果からすぐに恩恵を受けることができ、ユーザーは好きなコンテンツに簡単にアクセスできます。

この強力なサービスでも、あなたはまだ特定の音楽体験を作りたいと思うかもしれません。

だから今年は、プレイリストの作成と編集をMusicKitにもたらします。

ユーザーに代わってプレイリストを作成できるようになりました。

また、曲やアルバム全体などのアイテムを、ユーザーのライブラリの対象となるプレイリストに追加することも許可しています。

プレイリストの作成は、人々が愛するコンテンツをグループ化したり、アプリが設定したい気分に合わせるのに最適です。

また、既存のプレイリストにコンテンツを追加することで、MusicKitが提供するさまざまな音楽発見ツールが人々に直接影響を与えることができます。

作成したプレイリストを編集して、トラックリストとメタデータを編集して、すべてがあなたが望むとおりであることを確認できるようになりました。

そして、これらはアプリ内からユーザーのライブラリと対話する方法です。

最後に、MusicKitは今年いくつかの大きなアップグレードを受けました。

新しいタイプ、プロパティ、検索拡張のカタログ機能強化を既存のアプリに簡単に組み込むことで、さらに優れた体験ができます。

ライブラリのコンテンツと機能を統合して、まったく新しい機能のロックを解除し、ユーザーが自分の経験をコントロールできるようにします。

また、MusicKitを使用すると、複数の異なるタイプのアプリを強化できます。

フィットネスアプリ、ゲーム、ソーシャルメディアアプリ、マッピングアプリなどはすべて、音楽を再生または共有することで恩恵を受けることができます。

さらに進むには、関連するセッションをいくつか確認してください。

Swiftを深く掘り下げて、MusicKitやその他のAppleフレームワークを最大限に活用するための言語への新しい追加について学びましょう。

2021年のMusicKitセッションをチェックして、フレームワークを使用するようにアプリを設定し、再生を開始し、サブスクリプションオファーを提示する方法を学んでください。

また、Androidやウェブ上のApple Musicとの統合に興味がある場合は、Apple Music APIを直接使用する方法について説明する別のセッションがあります。

あなたが私たちのセッションを楽しんだことを願っています、そして私たちの開発者フォーラムを通じて最新情報とエンゲージメントを維持してください。

ご覧いただきありがとうございます。WWDC 2022をお楽しみください。