10119

こんにちは、アップルのコアデータチームのエンジニア、ニック・ギレットです。

このセッションでは、開発者ツールを使用して、NSPersistentCloudKitContainerを使用するアプリケーションについて詳しく知る方法を紹介します。

まず、生産的で教育的な方法でアプリケーションを探索する方法を詳しく見ていきます。

次に、私のお気に入りのツールのいくつかを使用して、アプリケーションがどのように動作するかを分析します。

そして最後に、NSPersistentCloudKitContainerでの経験について、詳細で実用的なフィードバックを提供する方法を見ていきます。

私はエンジニアリングを水循環のように考えるのが好きです。

通常、私は機能が存在する空間を探索することで、機能に取り組み始めます。

次に、学んだことに基づいて、ツールとテストを組み合わせて、再現可能な環境で作業を分析します。

最後に、同僚や同僚と結果を確認し、フィードバックを集めます。

このサイクルの目標は、私が仕事中に学んだことを永続的に捉えることです。

Appleのプラットフォームには、私が学んだことをキャプチャするために使用するXcode、Instruments、XCTestなどのツールの素晴らしい選択が含まれています。

これらのツールはまた、実用的なフィードバックを提供するために使用できる豊富な診断情報を収集することを可能にします。

このセッションでは、過去数年間の多くの知識を参照しています。

NSPersistentCloudKitContainerとCore Data CloudKitサンプルアプリケーションについて、本日、セッション「CloudKitとCore Dataを介してデータを共有するアプリを構築する」とセッション「CloudKitでCore Dataを使用する」で詳しく説明しました。

また、XcodeとInstrumentsを使用してテストを実行する方法と、デバイスオーガナイザーを使用してデバイスからデータをキャプチャする方法も実演します。

必要に応じて、「Instrumentsを使い始める」と「Xcodeオーガナイザーでパフォーマンスの問題を診断する」セッションを確認して、ツールチェーンのこれら2つの重要な部分について詳しく知ることをお勧めします。

さて、サイクルの最初の部分、探検から始めましょう。

私にとって、探検の主な目標は学ぶことです。

アプリケーションがどのように機能するかについて私が持っているすべての仮定に挑戦し、検証したいと思います。

私は尋ねるかもしれません：このボタンをタップするとどうなりますか？

永続ストアにデータを保存すると、NSPersistentCloudKitContainerは同期しますか?

大規模なデータセットで作業するとき、アプリケーションはメモリを使い果たしますか?

コアデータの観点から、これらの質問はすべて、アプリケーションが作業するデータの影響を受けます。

たとえば、Core Data CloudKitサンプルアプリケーションは、このデータモデルを使用します。

タイトルとコンテンツのテキストフィールドを含む一連の投稿を管理します。

投稿は添付ファイル、一般的に画像に関連している可能性があり、これは非常に大きくなる可能性があります。

したがって、ImageDataは、オンデマンドでロードできるように、to-oneリレーションシップ全体で保存されます。

そして、私はそのデータセット、特にそのデータの形状、構造、分散を変更するときにサンプルアプリケーションに何が起こるかに焦点を当てます。

リリース以来、サンプルアプリケーションには、それを探索するための組み込みの方法が含まれています。

1000件の投稿の生成ボタンは、ラベルに書かれていることを正確に行います。

タップすると、短いタイトルの1,000件の投稿のサンプルデータセットが生成されます。

投稿テーブルビューは、このレベルのデータを簡単に処理できます。

だから、私が尋ねる次の質問は、このアプリケーションで異なる形状やサイズのデータセットを探索するにはどうすればよいですか?

1000投稿の生成ボタンは、私がアルゴリズムデータジェネレータと呼ぶものを実行します。

アルゴリズムデータジェネレータは、「1000個のオブジェクトを挿入する」や「すべてのフィールドに値があることを確認する、またはフィールドに値がないことを確認する」などの一連の所定のルールに従います。

結局のところ、私たちもデータジェネレータです。

コード、SQL、またはアプリケーションと直接対話することで、特定のデータセットを手作りすることができ、これらの生成されたデータセットは、後で使用または分析するために保存することができます。

より大きなデータセットを探索するには、新しいデータジェネレータであるLargeDataGeneratorを定義し、単一のメソッドであるgenerateDataを使用して新しいデータセットを構築できます。

わずか2つのforループで、それぞれがそれらに関連付けられた11の画像添付ファイルを持つ60の投稿のセットを生成することができます。

それは合計660枚の画像です。

画像あたり10〜20メガバイトの平均サイズで、生成されたデータセットはほぼ10GBのデータを消費します。

このようなシンプルなインターフェースで、このようなテストではデータジェネレータを簡単に呼び出すことができます。

この1行のコードは、このテストで使用するために10GB以上の代表的なデータを生成します。

さらに、各投稿が実際に11の画像添付ファイルを取得すると主張するなど、データジェネレータが正しく動作することを検証するテストで検証方法を構築できます。

もちろん、このデータを同期しなければ、これはNSPersistentCloudKitContainerの話ではないでしょう。

だから、それを行うための新しいテストを作りましょう。

最初に必要なのは、使用するNSPersistentCloudKitContainerのインスタンスです。

私はそれを簡単にするためのヘルパーメソッドを作成しました。

次に、LargeDataGeneratorを使用して、目的のデータセットをコンテナに入力します。

そして最後に、コンテナがデータのエクスポートを完了するのを待ちます。

この特定のテストでは、大きなデータセットをアップロードする時間を与えるために最大20分待ちます。

あなたの中のワシの目は、このテストがさまざまな種類のイベントを待っているように見えることに気づいたかもしれません。

ここでは、コンテナを作成するときに、コンテナのセットアップが完了するのを待ちます。

そしてここでは、コンテナからのエクスポートイベントのXCTestExpectationsを作成するために書いたヘルパーメソッドを使用します。

それを詳しく見てみましょう。

このメソッドは、目的のイベントタイプとNSPersistentCloudKitContainerのインスタンスを引数として取ります。

NSPersistentCloudKitContainerのeventChanged通知を観察するために、XCTestCaseのexpectForNotificationメソッドを使用して、コンテナ内の各永続ストアに1つの期待値を作成します。

通知ハンドラブロックでは、着信イベントがこの期待値が対象である特定のストアの正しいタイプであり、endDateがnilに等しくないことを確認することで終了したことを確認します。

この手法を使用することで、テストのコントロールポイントをNSPersistentCloudKitContainerのイベントと強く関連付けることができます。

テストに戻って、エクスポートされたばかりのデータをインポートするための新しいコンテナを追加します。

このテクニックはトリックを使います。

空のストアファイルを使用して、NSPersistentCloudKitContainerの新しいインスタンスを作成します。

これにより、テストはNSPersistentCloudKitContainerの初回インポートを利用して、このすべてのデータがデバイスによってダウンロードされたときに何が起こるかを調べることができます。

今、テストは素晴らしいですが、時々私はアプリケーションでデータセットがどのように振る舞うかを感じたいです。

これを行うには、サンプルアプリケーションで行ったように、データジェネレータをユーザーインターフェイスにバインドできます。

「大きなデータの生成」ボタンをタップすると、データジェネレータがデータセットに入力されるのを見ることができます。

2台目のデバイスでは、NSPersistentCloudKitContainerが生成されたデータのダウンロードを進めるにつれて、テーブルビューが入力されるのを見ることができます。

個々の投稿をタップすると、このアプリケーションのユーザーと同じように、添付ファイルがダウンロードされ、段階的に入力されます。

この特定のユーザーインターフェイスは、アラートコントローラーによって駆動されます。

LargeDataGeneratorのシンプルなインターフェースにより、この2行のコードだけで新しいアラートアクションを簡単に追加できます。

それは明確で、簡潔で、理解しやすいです。

このセクションでは、データジェネレータの概念を使用して、アプリケーションの動作を探りました。

データジェネレータは、私が実証したように、テストやカスタムUI、またはコマンドライン引数のようなもの、または特定のユースケースで機能する他の何かによって、私たちが選択した方法でアプリケーションで駆動することができます。

アプリケーションにデータを入力する方法がわかったので、それがアプリケーションの動作をどのように変えるかを分析する準備が整いました。

このセクションでは、アプリケーションが大規模なデータセットでどのように動作するかを分析するためのいくつかのツールとテクニックについて学びます。

具体的には、Instrumentsを使用して、LargeDataGeneratorによって作成されたデータセットの時間とメモリの複雑さを分析します。

次に、システムログで利用可能な豊富な情報を見ていきます。 

そこでは、NSPersistentCloudKitContainer、CloudKit、システムスケジューラ、およびプッシュ通知からアクティビティの記録を見つけることができます。

インスツルメンツで見つめましょう。

私がテストが好きな理由の1つは、Xcodeがテストの動作を簡単に分析できるからです。

私のテストケースでは、側溝でテストの開示を右クリックして、プロファイルを選択できます。

Xcodeはテストを構築し、自動的にインストゥルメントを起動します。

タイムプロファイラー機器をダブルクリックして、テストが作業に時間を費やしている場所を調べることができます。

記録ボタンをクリックすると、Instrumentsはアプリケーションを起動し、選択したテストを実行します。

このテストは実行にかなり時間がかかるようです。

先にスキップして理由を見てみましょう。

インストゥルメントはすでにメインスレッドを選択しており、右側にはテスト実行の最も重いスタックトレースが見えます。

もう少し読みやすくしましょう。

行くよ。

さて、一番下までスクロールすると、LargeDataGeneratorがサムネイルの生成に多くの時間を費やしていることがわかります。

これがバグなのか機能なのか、どのように判断しますか?

LargeDataGeneratorには、添付ファイルごとに新しいサムネイルを生成するコード行があります。

しかし、私はアプリケーションのデータモデルから、サムネイルが特別であることを知っています。

それらは関連するimageDataからオンデマンドで計算されます。

つまり、この行は不要であり、私のデータジェネレータはそれらに多くの時間を無駄にしています。

だから、私はそれを取り除くことができます。

それがテストのパフォーマンスをどのように変えるか見てみましょう。

更新されたデータジェネレータでアプリを再構築した後、Instrumentsでテストを再実行できます。

正直なところ、あまり変化は見られませんが、あと数秒でテストは完了します。

それは前回の実行よりもずっと速いです。

テストがほとんどの時間をどこに費やしたのか見てみましょう。

右の引き出しでは、最も重いスタックトレースが永続ストアに画像を保存することであり、それはまさに私がこれだけのデータを管理するテストに期待するものです。

その1つの変更により、generateDataテストのランタイムがこれからこれに短縮されました。

それは10分の1の時間で実行されます。

このようにテストを分析すると、必ずしもバグが明らかになるとは限りません。特定のデータセットで作業するときに、アプリケーションが時間を費やしている場所について詳しく学ぶこともあります。

しかし、いずれにせよ、それは貴重な学習です。

そのため、タイムプロファイラ機器は、アプリケーションがデータセットに時間を費やす場所を調査するのに役立ちます。

さて、このデータセットのサイズのために、テストがどれだけのメモリを使用しているかにも興味があります。

では、割り当て機器を使用して実行してみましょう。

Xcodeを使用してInstrumentsを起動し、テストをプロファイリングします。

タイムプロファイラ機器を選択する代わりに、割り当てをダブルクリックします...

そして、[記録]をクリックします。

このテストは迅速に実行されていますが、実際には10GBを超える多くのメモリを使用しています。

これは、テスト実行中にデータセットのほぼ全体がメモリに保持されていることを示しています。

理由を調べてみましょう。

見るための割り当ての範囲を選択できます。

下のペインには、多くの大きな割り当てがあることがわかります。

この開示をクリックしてそれらを掘り下げ、テストに割り当てられた大きなデータブロブの1つをクリックすることができます。

この特定のブロブは割り当てられましたが、ほぼ2秒間解放されませんでした。

それはテスト時間の永遠です。なぜそんなに長く生きていたのですか?

右側のスタックトレースを展開することで、それを探索できます。

経験から、割り当てと割り当て解除スタックトレースは、このオブジェクトがCoreDataによって障害を受け、管理オブジェクトコンテキストが作業を終了したときにリリースされたことを教えてくれます。

これは通常、オブジェクトがフェッチ、オートリリースプール、またはテストのオブジェクトによって保持されたことを示しています。

コードの問題のあるセクションは、私の検証者にあります。

添付ファイルから画像をロードして確認します。

ただし、これにより、添付ファイルと関連する画像データが管理オブジェクトコンテキストに登録されたままになります。

これを解決する方法はいくつかあります。この問題を解決する方法はいくつかあります。

たとえば、テーブルビューでは、バッチフェッチを使用して、テーブルが投稿の上をスクロールするときに画像を解放することができます。

しかし、このテストは、それが効果的であるにはあまりにも速く実行されています。

私はアプローチを変える必要があります。

投稿を取得して検証する代わりに、代わりに添付ファイルを取得できます。

オブジェクトIDのみを取得する場合、管理オブジェクトコンテキストは、私が要求するまでロードされたオブジェクトをキャプチャしません。

NSManagedObjectContextのobjectWithIDメソッドを使用して、検証のために添付ファイルを取得できます。

最後に、検証する10個の添付ファイルごとに、コンテキストをリセットし、キャッシュされた状態と関連するメモリをすべて解放します。

この変更でテストを再実行すると、はるかに予測可能で調整可能なレベルのメモリ消費になることがわかります。

実際、検証者は、これらのオブジェクトを挿入するときにLargeDataGeneratorよりもさらに少ないメモリを使用します。

修正がどのように機能するかを学ぶために、特定の割り当てを掘り下げてみましょう。

まず、作業する割り当ての範囲を選択します。

次に、検査する特定のサイズを選択し、破壊されたオブジェクトがこの間に解放されたものを見つけることができるようにする必要があり、その後、検査する特定の割り当てを選択できます。

右側では、Instrumentsには割り当てスタックトレースが表示されますが、どこで解放されたのか知りたいので、割り当て解除イベントを選択します。

このスタックトレースは、NSManagedObjectContextがこのブロブを保持したオブジェクトを非同期に割り当て解除し、消費されたメモリを解放することを意味することをたまたま知っています。

この技術により、テストの高いウォーターマークを確立し、メモリの少ないシステムで実行することができます。

テストとインスツルメンツを組み合わせることで、この特定のテストには望ましくない動作があることがわかりました。

ターゲットを絞った変更を行い、その行動に直接対処し、結果を確認しました。

さらに、システムログには、CloudKit、スケジューリング、プッシュ通知など、アプリケーションとそれが依存するシステムサービスに関する豊富な情報も含まれています。

MacBook ProとiPhoneの間で1つの投稿を同期するつもりです。

Macに新しい投稿を挿入し、短いタイトルを付けてiCloudにアップロードすると、システムログは多くのイベントをキャプチャします。

私のiPhoneに同期すると、時には中間状態をキャプチャすると、システムログは対応する一連のイベントをキャプチャします。

MacBook Proでは、NSPersistentCloudKitContainerはアプリケーションプロセス、この場合はCoreDataCloudKitDemo内で機能します。

データが永続ストアに書き込まれると、DASDと呼ばれるシステムサービスに、そのデータをCloudKitにエクスポートする良い時期かどうかを尋ねます。

もしそうなら、DASDはNSPersistentCloudKitContainerにアクティビティを実行するように指示します。

NSPersistentCloudKitContainerは、変更されたオブジェクトをCloudKitにエクスポートするためにclouddと呼ばれるプロセスで作業をスケジュールします。

コンソールアプリを使用して、これらの各プロセスのログを観察できます。

アプリケーションログについては、アプリケーションプロセスであるCoreDataCloudKitDemoを探すだけです。

ここでは、エクスポート完了を示すものを選択しました。

スケジューリングログについては、プロセスdasdとアプリケーションの特定のストアからのログを見たいです。

ここでは、アプリケーションのプライベートストアのエクスポートアクティビティの開始を選択しました。

このログをもう少し詳しく調べてみましょう。

NSPersistentCloudKitContainerがdasdで作成したアクティビティは、特定の形式に従います。

アクティビティ識別子は、NSPersistentCloudKitContainerが使用する特定のプレフィックスと、アクティビティが属するストアのストア識別子で構成されています。

Dasdログには、サービスがアクティビティを実行できるかどうかを決定する方法に関する情報が含まれています。

アプリケーションの作業能力に影響を与えるポリシーは、最終決定とともにログにリストされます。

最後に、プロセスはCloudKitから情報をクラウド化し、私が作業しているコンテナ識別子でこれらのログをフィルタリングしたいと思います。

ここでは、先に述べたエクスポートに対応するレコード変更操作を選択しました。

受信デバイスに変更がインポートされると、観察すべき追加のプロセスが1つあります。

プロセスapsdは、プッシュ通知を受信し、アプリケーションに転送する責任があります。

これにより、NSPersistentCloudKitContainerは、エクスポートプロセスに似た一連のアクティビティを開始します。

dasdにインポートを実行する時間を要求し、clouddと連携してCloudKitから更新されたすべてのオブジェクトを取得し、ローカルストアにインポートします。

Apsdは、アプリケーションのプッシュ通知を受信したときにログを記録し、このログは多くの重要な詳細をキャプチャします。

ログメッセージには、ここにコンテナ識別子と、プッシュ通知をトリガーしたサブスクリプション名とゾーン識別子が含まれています。

これらはNSPersistentCloudKitContainerによって管理され、常にプレフィックスcom.apple.coredata.cloudkitで始まります。

今、コンソールアプリは素晴らしいです。

しかし、Macで開発しているときは、ターミナルのログストリームコマンドを使用して、これらのログをアプリと一緒に表示するのが好きです。

次の述語ごとに1つのターミナルウィンドウまたはタブを開き、まずアプリケーションを開きます。

次に、CloudKitサーバーで何が起こっているかを確認できるように、クラウドからのログ。

次に、プッシュ通知ログのapsd。

そして最後に、dasdは、NSPersistentCloudKitContainerが私に代わってスケジュールする活動で何が起こっているのかを見ることができます。

これらの述語は、コンソールアプリでクエリを導くためにも使用できます。

私たちが使用するデバイスには、非常に多くの情報があります。

課題は、本当に、それを見つけて分析するために使用するツールを知ることです。

インスツルメントだけで、ランタイムやメモリパフォーマンスなどの多くのトピックについて学ぶことができます。

システムログは、アプリケーションが行う作業と、システムが舞台裏で何をしているかを説明するキャプチャイベントをキャプチャします。

私の開発サイクルの最後の段階は、実用的なフィードバックを収集して提供することです。

このセクションでは、デバイスから診断情報を収集する方法を紹介します。

私たちの目標は、この情報を使用して、実行可能で特定の目標に沿ったフィードバックを生成することです。

これらのテクニックは、所有しているデバイスであろうと顧客のデバイスであろうと、あらゆるデバイスからフィードバックを収集するのに役立ちます。

デバイスから診断情報を収集するには3つのステップがあります。

まず、問題を特定し、効果的にトリアージするために使用できるログを可能にするCloudKitロギングプロファイルをインストールする必要があります。

次に、影響を受けるデバイスからsysdiagnoseを収集します。

そして最後に、デバイスに物理的にアクセスできる場合は、Xcodeから永続的なストアファイルを収集することもできます。

ロギングプロファイルをインストールするには、開発者ポータルのプロファイルとログページにアクセスするだけです。

CloudKitプロファイルを検索し、プロファイルリンクをタップしてダウンロードできます。

一部のデバイスでは、プロファイルをインストールするための通知が表示されます。

ただし、ここiOSでは、設定アプリから手動でインストールする必要があります。

設定では、プロファイルダウンロードセルをタップするためにナビゲートできます。

その後、ダウンロードしたプロファイルをタップしてインストールできます。

手順に従ってインストールを完了してください。

プロファイルがインストールされた後、デバイスを再起動することができ、有効になります。

デバイスが再起動したら、キャプチャしたい動作を再現し、sysdiagnoseを取ることができます。

Sysdiagnoseの取得は、特別な一連のボタンであるキーコードを使用して行われます。

これらは、プロフィールの手順ページに記載されています。

iPhoneの場合、音量ボタンとサイドボタンを数秒間押し続けてから放すことを知っています。

しばらくすると、sysdiagnoseが設定で利用可能になります。

それを見つけるための指示は、プロファイルの指示ファイルに含まれています。

[設定] で、[プライバシーとセキュリティ]、[分析と改善] に移動し、[分析データ] を選択し、sysdiagnose が見つかるまでログをスクロールします。

Sysdiagnoseをタップしてから[共有]ボタンをタップすると、いくつかの共有方法を選択できます。

例えば、私は分析のためにそれらを私のMacにAirDropするのが好きです。

最後に、可能であれば、デバイスオーガナイザーを使用してXcodeからストアファイルを収集できます。

インストールされたアプリリストのサンプルアプリケーションをクリックし、開示ボタンをクリックし、ダウンロードコンテナを選択し、ダウンロードディレクトリに保存することで、このiPhoneからファイルを収集できます。

そのすべてが完了すると、システムログとストアファイルの両方が分析可能になりました。

ログストリームコマンドについてはすでに話しましたが、sysdiagnoseを使用すると、log showコマンドを使用してsysdiagnoseからログを印刷できます。

ここでは、先ほど話したapsdログの述語をコピーしました。

Log show コマンドの最後の引数は、使用する logarchive です。

何も指定されていない場合は、実行中のマシンのシステムログが表示されます。

ここでは、sysdiagnoseから取ったログを読み取るようにsystem_logs.logarchiveを指定しました。

たとえば、興味のあるイベントが発生した時間に焦点を当てるために、正確な時間範囲を指定できます。

また、先ほど説明した述語の多くを組み合わせて、アプリケーションに関連するすべてのアクティビティの統一されたログを形成することもできます。ここのアプリケーションログ、ここのクラウドログ、ここのapsdログ、そして最後にここのdasdログ。

この強力なコマンドは、フィードバックレポートに含めたり、チームメイトと共有したりして、誰もが分析のために特定のログセットに集中できるようにすることができます。

このセッションでは、データジェネレータを使用してアプリケーションの動作を探索し、機器とシステムログを使用してアプリケーションを分析し、NSPersistentCloudKitContainerを使用するアプリケーションから実用的なフィードバックを提供または収集する方法について話しました。

私はニック・ジレットです。このプレゼンテーションをお届けできて光栄です。

見てくれてありがとう、アクティブでいて、リングを閉じて、素晴らしいWWDCをお過ごしください。

。