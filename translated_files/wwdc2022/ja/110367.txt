110367

♪ ♪

アレックス：こんにちは、私の名前はアレックスで、開発者ツールに取り組んでいます。

今日は、Xcode 14でサポートされている新しいC++ 20の機能についてお話ししたいと思います。

C ++ 20の概念が一般的なC++コードの型安全性をどのように簡素化し、改善するかに特に焦点を当てます。

コンセプトの使い方を実演し、独自のコンセプトを作成する方法も説明します。

Xcodeでサポートされている他のいくつかの新しいC ++ 20機能をリストアップして講演を終了し、コンパイル時コード評価の力を通じてC ++プロジェクトのパフォーマンスを向上させるためにそれらのいくつかをどのように使用できるかについて説明します。

C++の概念に飛び込む前に、まずC++でジェネリックコードを書く方法の概要を簡単に説明しましょう。

数値が奇数かどうかをチェックする関数を書きたいとしましょう。

私は「int」パラメータを取り込む関数を書くことができ、それは「int」型で表現できる任意の値で動作します。

64ビットの符号なし整数値を渡すとどうなりますか?

このような具体的な関数は、「int」タイプに収まるように切り捨てられるため、64ビット値では正しく動作しません。

これを修正するには、「isOdd」を関数テンプレートにすることができます。

関数テンプレートがわかったので、64ビットの符号なし整数値を渡すことができます。

コンパイラは、「uint64_t」タイプで正しく動作する「isOdd」の特殊化を自動的に生成します。

これは、2つの異なるタイプで動作する「isOdd」の2つのバージョンを書く必要がないことを意味するので、本当に便利です。

C++テンプレートを使用して、「isOdd」などの汎用関数や汎用コンテナクラスを書くこともできます。

「isOdd」の使用方法を見てみましょう。

この機能は、テストファイルに追加したいくつかのテストケースでテストされます。

残念ながら、私はテストの1つで間違いを犯しました。

コンパイラは間違いをキャッチしましたが、私が間違いを犯した場所を指す代わりに、コンパイラは「isOdd」テンプレート内にエラーを表示します。

タイプミスをして、テストで「11」ではなく「1.1」と書いたようです。

そのため、コンパイラは「ダブル」型を取る「isOdd」の特殊化を生成します。

残念ながら、Xcodeは「isOdd」が間違ったタイプで呼び出された特定の場所を指し示さなかったため、このタイプミスを見つけるのに時間がかかりました。

言語とコンパイラは、このような間違いをより早く見つけるのに役立ちますか?

さて、現在の例では、「isOdd」に許可されるタイプの要件は明示的に指定されていません。

整数型を使用してisOddを呼び出す必要があるというドキュメントコメントしかありません。

C ++ 20以前は、C ++プログラマーは、一般的なC ++コードを書くときにテンプレートの要件を指定する良い方法を持っていませんでした。

テンプレートの要件を指定する際には、多くの場合、ドキュメントのコメント、特定のパラメータ名、または複雑なenable_ifチェックに頼らなければなりませんでした。

さて、聞いたことがあるかもしれませんが、C ++ 20はコンセプトと呼ばれる新しいC ++機能を導入しています。

概念を使用して、一般的なC++コードのテンプレート要件を検証できます。

概念が「isOdd」に渡すことができるタイプを検証するのにどのように役立つかを見てみましょう。

まず、「isOdd」の宣言に戻りましょう。

現在、「class」キーワードを使用して、このテンプレートで使用されているタイプ「T」を任意のタイプに指定しています。

C++ 20では、「クラス」キーワードの代わりに概念を使用して、このテンプレートで使用できるタイプのセットを制限できます。

標準ライブラリが提供する「積分」の概念を使用して、この「isOdd」関数テンプレートを組み込みの整数型のみに制限できます。

Tがこの概念を満たさない場合、コンパイラはこの関数テンプレートを専門化しようとさえしません。

積分概念は、C++標準ライブラリで宣言されています。

そのため、コードに使用するには、概念ヘッダーを含める必要があります。

「isOdd」関数テンプレートのタイプ_T_に「インテグラル」要件を追加したので、コンパイラは、テストで間違いを犯した場所を直接指摘する、より明確な診断を提供することができます。

「1.1」はダブルであり、したがって、「インテグラル」の概念を満たしていないことが判明しました。

コンパイラは、このタイプミスを以前よりもはるかに迅速に見つけて修正するのに役立つ明確なエラーメッセージでこれを私に説明することができます。

バグを修正するのを助けることに加えて、「isOdd」に渡された型を制限することは、私が持っているすべてのテストケースが「isOdd」が整数型でのみ機能し、実際にアルゴリズムの意図した動作をテストしているという安心感を与えてくれます。

概念を使用して、テンプレートを使用するタイプの意図を宣言できます。

コンパイラは、テンプレートが専門化される前に型要件を検証します。

概念がどのように使用できるか、そしてどのコア概念がC++標準ライブラリによって提供されているかを詳しく見てみましょう。

C++標準ライブラリは、概念ライブラリを提供します。

型のコア動作を検証するために使用できる一連のコア言語の概念を実装しています。

コードにコンセプトヘッダーを含めることで、このライブラリにアクセスできます。

以前の例で「インテグラル」の概念を使用する方法をすでに示しました。

さて、このライブラリが提供する他の概念を見てみましょう。

このライブラリは、タイプが組み込み型の1つであるかどうかをテストする概念など、多くの有用なコア言語の概念を提供します。

たとえば、「floating_point」の概念は、「float」や「double」などの組み込み型によって満たされます。

ここに示されている「static_assert」は、これが実際に当てはまることを検証します。

また、タイプが構築可能、破壊可能、コンバーチブル、または別のタイプと同じかどうかを確認する他の多くの有用なコアコンセプトも提供します。

たとえば、「convertible_to」の概念は、型を別の型に変換できるかどうかをテストします。

そして、「move_constructible」の概念は、同じ型の別の値から直接構築できる型によって満たされます。

このライブラリは、タイプを他のタイプと比較できるかどうかをテストするいくつかの比較概念も提供します。

たとえば、「equality_comparable」の概念は、同じ型の値で動作する有効な「==」演算子を持つ型によって満たされます。

このスライドに記載されている概念に加えて、このライブラリは他の多くのコア言語の概念を提供します。

また、タイプを移動またはコピーできるかどうかをテストする概念も提供します。

それに加えて、型が呼び出し可能なオブジェクトであるかどうかを確認する概念も提供します。

C ++標準ライブラリから提供された概念を調べたところで、概念を使用してテンプレートを制約する方法を見てみましょう。

先に示したように、テンプレート内のクラスキーワードの代わりに概念を使用して、このテンプレートに許可されるタイプを制限できます。

それに加えて、型を複数の概念に制限する必要がある場合は、テンプレート宣言で「必須」句を使用できます。

それがどのようにできるかを見るために、少し異なる例を見てみましょう。

ここに「isDefaultValue」関数テンプレートがあります。

指定された値がその型のデフォルト値と等しい場合、trueを返します。

標準ライブラリの2つの概念を使用して、このテンプレートが専門化される前に、このタイプがこれらの操作をサポートしていることをテストできます。

この関数テンプレートで許可されているタイプのセットを制限するために、「必須」句を追加します。

コンセプトライブラリのどの概念が、ここでタイプを検証するのに役立つか見てみましょう。

まず、「equality_comparable」の概念は、_T_を同じタイプの別の値と比較できるかどうかをテストします。

次に、「default_constructible」の概念は、_T_がデフォルトのコンストラクタを持つ型であるかどうかをテストします。

それらの間の論理演算子と演算子は、両方の概念を検証するようにコンパイラに指示します。

これにより、この関数テンプレートはサポートされているタイプでのみ特殊になります。

概念についてこれまでに学んだことを見てみましょう。

コンセプトを使用して、テンプレートで使用できるタイプを制限する必要があります。

コンパイラは、型の不一致が発生した場合にテンプレートを専門化する必要がないため、より明確な診断を表示できるようになります。

型のコア動作を検証する必要がある場合は、概念ライブラリの概念を再利用する必要があります。

タイプが複数の要件に準拠しているかどうかをテストする必要がある場合は、テンプレートに「必須」句を追加する必要があります。

私たちは今、C++プログラムで概念を使用する方法を見てきました。

C++を使用すると、型の特定の動作を検証するカスタム概念を宣言できます。

特定のタイプの動作を検証する独自の概念を作成する方法を見てみましょう。

しかし、その前に、宣言したい概念によって検証されなければならない行動要件を特定する方法を検討する必要があります。

概念を使用して特定のタイプの動作を検証する方法を説明するために、新しい例を使用します。

さまざまな2次元形状を画像にレンダリングできるC++ライブラリを構築しているとします。

ライブラリでさまざまな図形をサポートしたいです。

レンダリングするのが最も簡単なので、私は円の形から始めています。

C++クラスを使用して、位置や半径などのプロパティを保存します。

円をレンダリングするには、レンダリングされた画像の各ピクセルで実行される距離関数ベースのレンダリングアルゴリズムを使用します。

このアルゴリズムは、それをレンダリングするために図形の表面までの距離を計算する必要があります。

Circleクラスの「getDistanceFrom」メソッドがそれを計算します。

円の内側の負の距離と、円の外側の正の距離を返します。

円に加えて、他の図形をレンダリングしたいと思います。

たとえば、別の円の形から1つの円の形を幾何学的に減算することで、三日月の形もレンダリングできます。

私もクラスを使ってレンダリングしたいクレセントのような図形を表現します。

各新しいシェイプクラスには、「getDistanceFrom」メソッドが含まれています。

いくつかの図形クラスを作成した後、これらの図形をレンダリングして実装を検証したいと思います。

任意の形状で動作するレンダリング機能を作成する方法について、いくつかのオプションがあります。

図形のクラス階層を作成し、仮想メソッドを使用して図形の表面までの距離を計算できます。

ただし、この関数はレンダリング中に数百万回呼び出されるため、仮想コールのオーバーヘッドを避けたいので、パフォーマンス上の理由から代わりに関数テンプレートを使用します。

これが私がこのレンダリング関数テンプレートを作成した理由です。

computePixelColor関数は、図形の値を取り込み、指定されたピクセルが図形の内側にあるかどうかをチェックします。

中にある場合は、無地の白色を返します。

これにより、図形を正しく入力できることを確認できるようになりました。

この関数はテンプレートであり、円、三日月、またはその他の一致するタイプなど、任意の形状タイプで動作します。

テンプレートはここでうまく機能しますが、概念を使用して、この関数に渡すことができる型を制限したいと思います。

この関数に渡された型を制限することで、型の不一致が発生したときにコンパイラはより明確な診断を生成できます。

それに加えて、この関数に渡されたタイプを制限することで、この関数のオーバーロードを追加することもできます。

タイプを制約するために、シェイプのコンセプトを作成します。

この概念は、タイプの動作を検証し、円、三日月、および将来追加したいかもしれない他の形状クラスのようなクラスを受け入れます。

「シェイプ」のような概念を作成するには、まずこの概念によって検証する必要がある要件を特定する必要があります。

これがどのようにできるか見てみましょう。 

この関数テンプレートは、ジェネリック型として型「T」を使用します。

次に、タイプ「T」の「shape」という名前の引数がこの関数に渡されます。

「shape」引数は、関数内で「getDistanceFrom」メソッドを呼び出すと使用されます。

ご覧のとおり、この関数では形状に対して他の操作が実行されていないため、これは私のコンセプトで検証したい唯一の要件です。

「Requires」式を使用して、型が特定の方法で動作するかどうかをテストできます。

「requires」を使用してShapeコンセプトを作成する方法を見てみましょう。

「Requires」内の型の動作をテストする一連の表現を提供する必要があります。

私はすでにテストする必要がある単一の要件として「getDistanceFrom」への呼び出しを特定したので、今、私は先に進んで「シェイプ」の概念を作成することができます。

「コンセプト」キーワードを使用して形状の概念を宣言しました。

次に、タイプを検証するために、この概念に「必須」式を追加しました。

「Requires」式に引数リストを追加しました。

この引数リストでは、タイプ「T」の値「形状」を宣言し、「必須」内でテストします。

Requires式で引数リストを使用して、任意のタイプの値を宣言できます。

その後、これらの値を要件内で使用できるようになります。

「Requires」式の本文には、この概念を満たすために合格しなければならない一連の要件が含まれています。

「shape」の概念には、「getDistanceFrom」へのメソッド呼び出しが有効かどうかを確認する単純な式要件が1つだけあります。

この式は実際にはプログラムで実行されません。

型の動作を検証するためにコンパイル時にのみ必要であり、検証後に破棄されます。

式の要件を使用して、特定の式がコンパイルされるかどうかをテストすることで、型の動作を検証できます。

ただし、「getDistanceFrom」メソッド呼び出しの引数が欠落しているため、この特定の式はまだ完全ではありません。

このメソッドに「float」型の2つの値を取りたいので、2つの浮動小数点リテラルを使用してこの式を完成させることができます。

「getDistanceFrom」メソッドが浮動小数点値を返すことをテストするために追加のチェックを追加します。

私は現在、タイプに「getDistanceFrom」メソッドがあるかどうかをテストするために、単純な式要件を使用しています。

ただし、式要件の代わりに複合要件を使用して、浮動小数点数の値を返すことをテストできます。

矢印演算子は複合要件に従うことができます。

矢印演算子は右側に制約を期待しているので、「same_as」のような標準ライブラリの概念を使用して、「getDistanceFrom」メソッドの呼び出しが浮動小数点数値を返すことを検証できます。

今、このコンセプトは私には準備ができているように見えます。

先に進んで、それを使って「computePixelColor」関数に渡すことができるタイプを制約することができます。

これで、私の一般的な「computePixelColor」関数は、「Shape」の概念を満たすタイプでのみ動作します。

これは、CircleやCrescentなどのクラスは、これらのタイプの両方が「Shape」の概念を満たすため、この特定の一般的な「computePixelColor」関数を使用してレンダリングされることを意味します。

無地の図形がレンダリングされたのを見た後、私の図形のいくつかに色を追加する「computePixelColor」の別のバージョンを作成したいと思います。

シェイプライブラリにカラフルなGradientCircleクラスを追加したいとしましょう。

今、画像内のピクセルカラーを計算するための新しい機能が必要です。

C++ 20では、「computePixelColor」関数テンプレートの複数のバリアントを作成できます。

各バリアントは、異なる概念を使用して制約する必要があります。

GradientCircleのようなクラスで満足する新しいGradientShapeコンセプトを作成します。

この概念は、グラデーションを持つ図形でのみ機能する「computePixelColor」の新しいバリアントを制限します。

この概念は、シェイプの概念と同様に、「必須」式を使用して実装されています。

しかし、GradientShapeも元のShapeコンセプトを満たしたいので、新しいコンセプトの最初の要件としてそれを含めます。

これにより、GradientShapeの概念を満たすクラスがShapeの概念も満たすことができます。つまり、そのようなクラスの値に対して「getDistanceFrom」メソッドを呼び出すことができます。

次に、論理式と演算子と「必須」式を使用して、GradientShapeの概念が「getGradientColor」メソッドを持つクラスによってのみ満たされるようにします。

GradientShapeコンセプトを作成したので、「computePixelColor」の新しいバリアントを作成できます。

この関数テンプレートは、GradientShapeの概念によって制約されるため、GradientCircleクラスのようなグラデーションを持つ図形クラスでのみ機能します。

すべてのピースが整ったので、グラデーションで円をレンダリングしてみることができます。

ここでは、GradientCircleをレンダリングしています。

コンパイラが「render」関数内でどの「computePixelColor」のオーバーロードを選択するか見てみましょう。

GradientCircleはcomputePixelColorの両方のバリアントで安全に使用できますが、コンパイラは最初のオーバーロードよりも特異的であるため、GradientShapeの概念で制約されたオーバーロードを選択します。

コンパイラは「computePixelColor」の最も一致するオーバーロードを選択するため、ライブラリをテストすると、この美しいグラデーション円がレンダリングされるのを見ることができます。

すごい！

それでは、コンセプトの作成について学んだことを確認しましょう。

既存のジェネリックコードの行動要件を特定することで、概念を作成できます。

型の動作を検証するための概念を作成するには、requires式を使用する必要があります。

また、概念を使用して、汎用関数やクラスのより具体的なバリアントを作成することもできます。

私たちは今、概念であなたの一般的なC++コードを強化する方法を見ました。

サポートコンセプトに加えて、Xcode 14は他のC++20機能のサポートも改善しました。

具体的には、Xcode 14でのコンパイル時のC++コード評価の改善されたサポートを強調したいと思います。

コンパイル時間コードの評価は、C ++コードの変数の初期化コストを削減できるため便利です。

これは、アプリに複雑な初期化シーケンスに依存する多くのC ++コードがある場合、アプリの起動時間を短縮するのに役立ちます。

それに加えて、コンパイル時コードの評価は、コンパイル時に検証が必要な定数を検証するのに役立ちます。

これは、コードが実行される前にバグをキャッチするのに役立ちます。

C++でコンパイル時コード評価を使用する方法を示す例を見てみましょう。

ここには、シェイプレンダリングライブラリでカラーパレットを初期化するコードのスニペットがあります。

このライブラリは、図形をディスプレイにレンダリングするiOSアプリで使用されます。

パレットの各色は、色のHTML 16進コードで文字列リテラルを解析することによって初期化されます。

現在、「fromHexCode」関数は、配列の初期化中に3つの文字列リテラルを解析する必要があります。

このような複雑な定数初期化操作は、アプリの起動時間がたくさんある場合、アプリの起動時間に測定可能な影響を与える可能性があります。

コンパイル時のコード評価を使用して、この配列が代わりに一定の色値で初期化されていることを確認できます。

これができることをお見せしましょう。

「constexpr」キーワードは、C++でコンパイル時のコード評価を可能にします。

パレットが一定の色の配列であることを確認するために、私の例のいくつかの場所にそれを追加する必要があります。

まず、「fromHexCode」関数に「constexpr」キーワードを追加する必要があります。

コンパイラは、コンパイル時の初期化シーケンスで使用されるコンパイル時にこの関数のコードを実行できるようになります。

コンパイル時に評価可能にしたい場合は、C++関数を「constexpr」にする必要があります。

コンパイラは、「constexpr」初期化シーケンスで使用するときにエラーを表示することで、コンパイル時にそのような関数のコードを評価できない場合に知らせます。

ただし、「constexpr」を追加する前に関数を調べて、コンパイル時に評価できるかどうかを確認することもできます。

fromHexCodeを覗いて、このような関数がコンパイル時コード評価の良い候補になるかどうかを確認する方法を見てみましょう。

この関数は、if文のような多くの言語構造と、比較演算子や算術演算子のようなプリミティブ演算を使用します。

これらの操作はすべて、コンパイル時に評価できます。

また、この関数は別の関数にいくつかの呼び出しを行います。hexToInt。

私はすでに「constexpr」でhexToInt関数に注釈を付けているので、この関数の呼び出しはコンパイル時に評価できます。

全体として、fromHexCodeには、コンパイラがコンパイル時に評価できるコードが含まれているように見えるので、コンパイル時の初期化シーケンスで続行して使用しても安全だと思います。

コンパイル時にfromHexCodeを評価できることを確認した後、「colorPalette」変数宣言に「constexpr」キーワードを追加する必要があります。

コンパイラは、コンパイル時にこの配列の初期化シーケンス全体を評価することを保証します。

具体的には、コンパイラはfromHexCode関数への各呼び出しを評価します。

評価は、パレットの初期化子の関数への元の呼び出しを置き換える一定の色値を生成します。

fromHexCodeへのすべての呼び出しが定数色値に置き換えられるようになったため、「colorPalette」変数は、定数色値を含む配列リテラルによって初期化されることが保証されるようになりました。

これは、このパレットが初期化されたときに、私のアプリが色の値を解析するための追加費用を支払う必要がないことを意味します。

これは、アプリ内のこのC ++ライブラリが起動時に行わなければならない作業量を減らすので、私のアプリの起動時間に最適です。

定数値で初期化されるようにする場合は、C++変数を「constexpr」にする必要があります。

Xcode 14は、実際にコンパイル時評価のための標準ライブラリのサポートを大幅に改善しました。

今年は、コンパイル時のコード評価中に使用できる、いくつかの異なる標準ライブラリタイプとアルゴリズムに「constexpr」サポートを追加しました。

それに加えて、Xcode 14はC++20の標準サポートを大幅に改善しました。

ここに示されているすべての機能は、C++ 20モードで使用できるようになりました。

まだ切り替えていない場合は、今日C++ 20モードに切り替える必要があります。

Xcodeプロジェクトの「C++言語方言」設定を使用して、C++ 20にアップグレードできます。

C++20に切り替えると、コードで概念などの機能を使用できます。

C++ 20は最低展開ターゲットを必要としないため、現在ターゲットとしているのと同じOSバージョンのコードを出荷できます。

今日C++20を試してみてください。

ありがとう！

開発者会議の残りの部分をお楽しみください。