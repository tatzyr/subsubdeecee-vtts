10032

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

こんにちは、皆さん。私の名前はショートカットエンジニアリングのマイケル・ゴーバックです。

アプリの機能をシステムに公開するための新しいフレームワークであるApp Intentsを深く掘り下げていただきありがとうございます。

これが私たちのダイビングの計画です。

簡単な紹介の後、意図とそのパラメータ、およびエンティティを定義する方法について説明します。

構築できる強力な検索とフィルタリング機能、および意図がユーザーとどのようにやり取りできるかについて説明します。

最後に、App Intentsのアーキテクチャとライフサイクルについて説明します。

最初から始めましょう。

iOS 10では、メッセージング、ワークアウト、支払いなどのSiriドメインにアプリの機能を接続できるSiriKit Intentsフレームワークを導入しました。

今、私たちはApp Intentsと呼ばれる新しいフレームワークを導入しています。

それには3つの重要な要素があります。

意図は、システム全体で使用できるアプリに組み込まれたアクションです。

インテントは、アプリのコンセプトを表すためにエンティティを使用します。

アプリのショートカットは、それらを自動的かつ発見可能にするためにあなたの意図をラップします。

App Intentsがアプリの機能をより多くの場所で利用できるようにし、顧客に利益をもたらす方法について話しましょう。

アプリショートカットを使用すると、誰もが最初に何も設定することなく、Siriを介して自分の声でアプリの機能を使用できます。

同じ採用により、人々があなたのアプリを検索し、あなたのアプリが提案されたときに、あなたの意図がSpotlightに表示されます。

これはあなたの仕事を前面と中央に置くでしょう。

アプリインテントを使用すると、フォーカスフィルターを構築して、顧客が特定のフォーカスに合わせてアプリをカスタマイズできるようにすることもできます。

たとえば、実際に仕事中に作業カレンダーのみを表示するようにカレンダーアプリを設定する場合があります。

フォーカスフィルターの採用方法の詳細については、このセッションをご覧ください。

アプリショートカットを使用すると、手動で追加することなく、インテントがショートカットアプリに自動的に表示されます。

アクションをショートカットに統合することは、システム内の多くの場所からショートカットを実行し、アプリの機能を活用できるため、顧客にとって非常に価値があります。

ホーム画面、macOSのメニューバー、その他多くの方法でワンタップでショートカットを実行できます。

オートメーションで自動的に実行するようにショートカットを設定することもできます。

ショートカットのサポートは、アプリをショートカットエコシステム全体に接続し、Appleや他の開発者からの一連のアプリの力を活用することで、アプリのパワーと機能を倍増させます。

なぜなら、ショートカットは複数のアプリのアクションを組み合わせることができ、ユーザーが作業をしなくてもまったく新しい機能や機能を発明できるからです。

あなたの行動が他の人とうまく機能し、このエコシステムにシームレスにフィットする方法を学びたい場合は、私たちのデザイントークをチェックしてください。

アプリインテントを構築する私たちの目標は、開発する喜びにすることでした。

アプリの意図は簡潔です。

単純なインテントを書くには数行のコードしかかかりませんが、APIはより深く、よりカスタマイズ可能なアクションにも拡張できます。

アプリの意図は現代的です。

私たちはSwiftに全力を尽くし、結果ビルダー、プロパティラッパー、プロトコル指向のプログラミング、ジェネリックを活用しました。

これらのAPIは、最先端の言語機能なしでは存在できませんでした。

製品やターゲットを再設計したり、フレームワークを作成したりする必要がないため、App Intentsの採用も簡単です。

拡張機能を必要とせず、アプリですぐに採用できます。

そして、App Intentsコードはメンテナンス可能です。

SwiftUIと同様に、App Intentsはコードを真実の基本的な情報源として使用し、個別のエディタや定義ファイルの必要性を回避します。

これにより、採用を迅速に構築して反復し、すべてが1か所に存在するため、メンテナンスを簡素化できます。

とはいえ、新しいフレームワークの中心的な構成要素である意図から始めて、これらの新しいAPIを探りましょう。

アプリの意図、または略して「意図」は、アプリがシステムに公開する単一の分離された機能ユニットです。

たとえば、インテントは新しいカレンダーイベントを作成したり、特定の画面を開いたり、注文したりすることができます。

インテントは、ショートカットを実行したり、Siriに頼んだり、フォーカスフィルターやショートカットの自動化を使用するなど、リクエストに応じてユーザーが実行できます。

インテントが実行されると、結果を返すか、エラーをスローします。

インテントには、メタデータ、またはローカライズされたタイトルを含むインテントに関する情報、インテントが実行時に使用できる入力であるパラメータ、およびインテントが実行されたときに実際の作業を行う実行メソッドの3つのキーピースが含まれます。

今日の出発点は、この図書館アプリです。

私は巨大な本の虫なので、読んだ本、読みたい本、または現在読んでいる本を追跡することがすべてです。

各カテゴリは、私がシェルフと呼ぶアプリの別々のタブに表示されます。

私のユーザーは、現在読んでいる棚を常に訪問しているので、私はそれをより速く、より便利に開くためにアプリの意図を公開するつもりです。

AppIntentプロトコルに準拠したSwift構造体を定義して、ここでOpenCurrentlyReadingインテントを作成します。

実行と呼ばれるメソッドを1つだけ実装する必要があります。

私のアプリでは、私はすでにタブを開くことができるナビゲーターを持っているので、私のために意図を実装するのはほんの数行のコードです。

ナビゲーターがメインスレッドを期待しているので、@MainActorでperformメソッドに注釈を付けます。

私の意図にもタイトルが必要です。

今日お見せする他のすべての文字列と同様に、文字列ファイルにキーを追加すると、これは自動的にローカライズされます。

基本的なアプリの意図を機能させるために私がする必要があるのはこれだけです。

私のコードで定義されているので、ショートカットエディタに自動的に表示され、ユーザーがショートカットに追加できます。

この意図を公開するだけで、大きなレバレッジが得られます。なぜなら、顧客がこの意図をショートカットに変えると、これらすべてを含むシステム内の多くの場所から使用できるからです。

私の新しい意図を使いやすく、発見しやすくするために、アプリショートカットのサポートも追加します。

少しのコードで、Spotlightとショートカットアプリに私の意図を自動的に表示させることができ、人々が自分の声でこの意図を使用するようにSiriに言うことができるフレーズを定義することができます。

「App IntentsでApp Shortcutsを実装する」セッションをチェックして、すべての詳細を入手してください。

これまでのところ、私は現在読んでいる棚を開く意図を明らかにしました。

次に、それを一般化し、任意の棚を開くことができるようにパラメータを追加します。

私は棚を表す列挙型を持っています。

インテントパラメータとして使用するには、AppEnumプロトコルに準拠する必要があります。

AppEnumには文字列の生の値が必要なので、最初にそれを追加します。

また、列挙型ケースごとにローカライズ可能で人間が読めるタイトルを提供する必要があります。

これらは、コンパイラがビルド時にこのコードを読み取るため、辞書リテラルとして提供する必要があります。

最後に、typeDisplayNameを追加します。これは、この列挙型全体のユーザー可視でローカライズ可能な名前です。

「シェルフ」を使います。

インテントでは、各パラメータは@Parameterプロパティラッパーを使用して宣言され、タイトルなどのパラメータに関する情報で初期化されます。

ここでは、performメソッドで読んだ新しいシェルフパラメータを定義します。

パラメータは、数字、文字列、ファイル、アプリのエンティティや列挙型など、これらすべてのタイプをサポートします。

ショートカットエディタでこの意図がどのように見えるかは次のとおりです。

シェルフパラメータはテーブルの行に表示されることに注意してください。

ParameterSummary APIを使用することで、UIをより合理化し、ショートカットによりよく適合させることができます。

パラメータサマリーは、「開く」のように、エディタであなたの意図とそのパラメータを表す文です。

ショートカットで最良の結果を得るには、作成するすべてのインテントのパラメータサマリーを常に提供する必要があります。

また、折り目の下に表示されるパラメータと非表示のパラメータを定義することもできます。

これらのAPIは、When and Otherwise API、またはSwitch、Case、およびDefault APIを使用して、意図のパラメータの実際の値に基づいて要約を変化させるなど、かなりクールなことを行うことができます。

パラメータサマリーを追加するには、この静的プロパティを実装します。

ここでは、文字列「Open」を返し、シェルフパラメータを補間します。

Open Shelfを動作させるために私がする必要がある最後のことは、このように、実行時にインテントがライブラリアプリを開くことを確認することです。

アプリを開くのは、静的プロパティopenAppWhenRunによって制御されます。

デフォルトはfalseで、ほとんどの意図に最適です。

しかし、このようなUIで何かを開く意図については、trueに設定する必要があります。

私はちょうど棚を開ける意図を作成しました。

棚のセットが固定されているので、これは超簡単です。

しかし、セットが固定ではなく動的である本を開く意図を構築したい場合はどうなりますか?

そのために、エンティティが必要になります。

エンティティは、アプリがApp Intentsに公開する概念です。

ノートのメモや写真の写真やアルバムのように、値が動的またはユーザー定義の場合は、列挙型の代わりにエンティティを使用する必要があります。

エンティティのインスタンスを提供するために、アプリはクエリを実装し、インテントの結果としてエンティティを返すことができます。

アプリで本を開く意図を作ることから始めます。

ショートカットエディタでは、次のようになります。

人々がブックパラメータをタップすると、私のアプリが提供した提案されたエンティティのセットを含む、本を選択するためのピッカーを取得します。

また、ピッカーの上部にあるこの検索フィールドを使用して、ライブラリ内の任意の本を見つけることができます。

インテント自体を構築する前に、ブックエンティティと対応するクエリを作成する必要があります。

エンティティには、識別子、表示表現、エンティティタイプ名の少なくとも3つのものが含まれています。

エンティティを追加するには、まずAppEntityプロトコルに構造体を合わせることから始めます。

ここでは、BookEntityの新しい構造体を定義しますが、モデルから既存の型を適合させることもできます。

エンティティを識別可能なプロトコルに準拠させることで、識別子を提供します。

App Intentsは、この識別子を使用して、アプリとシステムの他の部分の間で渡されるエンティティを参照します。

識別子は、顧客が作成したショートカットに保存される可能性があるため、安定して永続的である必要があります。

表示表現は、このエンティティをユーザーに表示するために使用されます。

これは、本のタイトルのようなテキストの文字列と同じくらい簡単です。

字幕と画像を提供することもできます。

typeDisplayNameは、エンティティの型を表す人間が読める文字列です。

この例では、「本」です。

さて、ブックエンティティを締めくくるには、クエリを追加する必要があります。

クエリは、アプリからエンティティを取得するためのインターフェイスをシステムに提供します。

クエリは、いくつかの方法でエンティティを検索できます。

すべてのクエリは、識別子に基づいてエンティティを検索できる必要があります。

文字列クエリは検索をサポートします。

そして後で、より柔軟なプロパティクエリに遭遇します。

すべてのクエリは、ユーザーがリストから選択できる、提案されたエンティティを提供することもできます。

システムがそのエンティティのインスタンスを検索できるように、すべてのエンティティをクエリに関連付ける必要があります。

EntityQueryプロトコルに準拠したSwift構造体を作ることで、クエリを提供します。

基本的なクエリには、識別子の配列が与えられたエンティティを解決するために実装する、必要なメソッドが1つしかありません。

モデルデータベースに行き、それらの識別子に一致する本を見つけることで、これを実装しました。

今、私はエンティティにクエリを接続する必要があります。

これを行うには、BookEntityタイプにdefaultQuery staticプロパティを実装し、BookQueryのインスタンスを返します。

ユーザーが本を選択すると、その識別子がショートカットに保存されます。

ショートカットが実行されると、App IntentsはBookEntityインスタンスを取得するために私のクエリに識別子を渡します。

BookEntityタイプがAppEntityプロトコルに準拠したので、OpenBookインテントのパラメータとして使用できます。

実行方法は、私のナビゲーターを使用して本に移動します。

ブックピッカーをサポートするために、私のクエリも提案された結果を提供する必要があります。

これを行うには、クエリにもう1つのメソッドを実装し、ライブラリアプリに追加されたすべての本を返す必要があります。

ショートカットはこれらの結果でピッカーを埋めます。

ショートカットUIの上部に検索フィールドがあることに注意してください。

私のアプリは多くのブックエンティティを持つことができるので、私は本当に私のデータベースに対して、私のアプリプロセスで検索を実行する必要があります。

StringQuery APIでは、それを行うことができます。

StringQueryサブプロトコルを採用すると、文字列が与えられた結果を返すために、エンティティ(一致文字列:)と呼ばれる実装するもう1つの方法が得られます。

ここでは、本のタイトルに対する単純な大文字と小文字を区別しないマッチとして実装しましたが、たとえば、著者やシリーズ名を検索するなど、より豪華なことをすることができました。

書籍の膨大なリストとお気に入りのリストが少ない場合は、suggestedEntitiesのお気に入りだけを返し、エンティティ（一致文字列：）に依存して、ユーザーがより長いリストを検索できるようにすることができます。

今、私はアプリで本を開く方法を公開し、その過程でブックエンティティとブッククエリを構築しました。

同じエンティティとクエリを使用して、より多くのインテントを作成できます。

私の次の仕事は、図書館に本を追加する意図を構築することです。

お客様は、共有シートのショートカットを使用してオンラインで閲覧しながら本をすばやく追加したり、画面を見ずに本を追加するようにHomePodのSiriに指示したりできます。

UIを表示せずにモデルを直接操作するこのような意図を構築することは、本当にユーザーに力を与えることができます。

これは、本のタイトルと著者のオプション名をパラメータとして、私のAddBookインテントの実装です。

また、どの友人が本を推薦したかを記録するためのオプションのメモも含まれています。

performメソッドは、async/awaitを使用してAPI呼び出しで調べることで、ブックをライブラリに追加します。

一致するものが見つからない場合、エラーがスローされます。

このエラーをローカライズするために、エラータイプをCustomLocalizedString ResourceConvertibleプロトコルに適合させます。

このプロパティからローカライズされた文字列キーを返し、そのキーを文字列ファイルに追加します。

このAdd Bookの意図は、Siri、ウィジェットなどで非常に便利です。

しかし、他の意図と組み合わせることができれば、さらに柔軟になります。

少しの作業で、Add Bookの意図と以前に構築したOpen Bookの意図を組み合わせて、結果を一方から他方へと渡すことができます。

これを行うには、Add Bookの意図に結果の一部として値を返してもらいます。

私のperformメソッドの戻り値タイプが、私が返す値を表す新しいプロトコルを拾ったことに注意してください。

これで、ユーザーはこのインテントの結果値を、ブックエンティティをパラメータとして取る他のインテントに接続できます。

Add Bookの意図とOpen Bookの意図は非常に自然にペアになるので、本を追加し、すぐにライブラリで開くショートカットを作成できます。

意図から結果を返してアプリで開くのは一般的なパターンです。

アプリのインテントには、openIntentと呼ばれるこれを表現する方法が組み込まれています。

openIntentを追加すると、顧客はショートカットで「実行時に開く」という新しいスイッチを取得します。

スイッチをオフにすると、このインテントを中断することなくバックグラウンドでショートカットの一部として使用できます。

スイッチを入れたままにしておくと、新しく追加された本がすぐに私の図書館アプリで開きます。

openIntentの採用は、Open Bookインテントのインスタンスを作成し、結果の一部として返すのと同じくらい簡単です。

このインテントが実行されると、Open When Runスイッチがオンの場合、Add Bookインテントが終了すると、Open Bookインテントが自動的に実行されます。

エンティティとクエリでできることはもっとたくさんあります。

APIの次のセットで、AppIntentsはSiriKit Intentsフレームワークでこれまでになかったいくつかの強力な能力を開きます。

エンティティからより多くの情報を公開し、顧客がそれに基づいて見つけてフィルタリングできるようにする方法を見てみましょう。

これまでのところ、私は本の実体にすべての基本的な要件を追加しました。

しかし、人々が本をショートカットにもっと深く統合できるようにするために、私は自分の本についてもう少し暴露する必要があります。

エンティティは、ユーザーに公開したいエンティティに関する追加情報を保持するプロパティをサポートします。

この場合、本の著者、出版日、既読日、推奨者を追加して、ショートカットでこれらのプロパティを使用できるようにします。

@Propertyというプロパティラッパーを使用して、BookEntityにプロパティを追加します。

プロパティは、パラメータと同じタイプをすべてサポートし、それぞれがローカライズされたタイトルを取ります。

これらの新しいプロパティを使用すると、私の顧客はショートカットのマジック変数を使用して、ブックエンティティで作業するときに新しい情報を引き出すことができます。以前のAdd Bookインテントを使用すると、ショートカットで新しく追加された本の著者または公開日を使用できます。

プロパティとクエリを組み合わせると、この柔軟な述語エディタUIを使用して、アプリはショートカットでこれらの非常に強力な検索とフィルターアクションを自動的に取得します。

今、私の顧客は、読んだ日付、タイトル、著者などに基づいて本を見つけてフィルタリングすることができます。

例えば、デリア・オーウェンズのすべての本を見つけるのは簡単です。

並べ替えと制限オプションを使用すると、デリア・オーウェンズによって最近出版された3冊の本を見つけるなど、さらに高度なクエリをサポートできます。

お客様は、これらのビルディングブロックを使用して、コレクション内の3つの最も一般的な著者を見つけるなど、かなりクールなことを行うことができます。

これらすべてを有効にするには、プロパティクエリと呼ばれる別の種類のクエリを採用する必要があります。

プロパティクエリは、文字列や識別子ではなく、エンティティ内のプロパティに基づいてエンティティを検索します。

プロパティクエリを実装するには3つのステップがあります。

まず、クエリプロパティを宣言します。これは、プロパティを使用してエンティティを検索する方法を指定します。

次に、クエリ結果をソートする方法を定義するソートオプションを追加します。

そして最後に、検索を実行するためにエンティティ(matching:)を実装します。

クエリプロパティは、AppIntentsがこのクエリに関連付けられたエンティティで検索できるあらゆる方法を宣言します。

それぞれに、私のエンティティのプロパティと、利用可能な比較演算子（包含、等しい、またはそれ以下）がリストされています。

ここでは、日付プロパティの「未満」と「より大きい」コンパレータをリストし、タイトルプロパティの「contains」と「equal to」をリストします。

クエリプロパティは、プロパティとコンパレータの各組み合わせを、コンパレータマッピングタイプと呼ばれる選択したタイプにマップします。

ここでは、CoreDataを使用しているので、NSPredicateを使用します。

カスタムデータベースまたはREST APIを使用している場合は、独自のコンパレータタイプを設計し、代わりにそれを使用することができます。

これが私の本のクエリプロパティを設定するコードです。

BooksQueryをEntityPropertyQueryプロトコルに適合させます。

次に、QueryProperties結果ビルダーを使用して静的varプロパティを実装します。

各エントリは、照会できるプロパティのキーパスを指定し、その中で、そのプロパティに適用される各コンパレータを指定します。

コンパレータごとに、コンパレータマッピングタイプとしてNSPredicateを選択したため、NSPredicateを提供します。

システムがアプリにクエリの結果を返すように要求すると、ここで構築しているNSPredicatesが返されます。

ソートにも同様の定義があります。

これは、私のモデルが本を並べ替えることができるすべてのプロパティのリストです。

この場合、タイトル、既読日、公開日で並べ替えることができます。

最後に、データベースを照会し、一致するエンティティを返すエンティティ(matching:)を実装します。

このメソッドは、以前に定義されたクエリパラメータ（この場合はNSPredicate）で使用したコンパレータマッピングタイプの配列を取ります。

これらの述語は、私がクエリしたいエンティティのプロパティの基準を記述しています。

また、述語を「and」または「or」と組み合わせるかどうか、並べ替えるキーパス、および結果数のオプションの制限を示すモードも必要です。

私の実装では、これらのパラメータを使用して、CoreDataデータベースに対してクエリを実行します。

顧客はこのプロパティクエリで何ができますか?

彼らは図書館からランダムな本を選んで読むことができます。

彼らは20世紀初頭に出版されたすべての本を見つけることができます。

彼らはショートカットのエコシステムを活用し、他のアプリに接続することで私のアプリをより便利にすることができます。

たとえば、スプレッドシートアプリを使用して、今年読んだすべての本をCSVファイルにエクスポートできます。

または、グラフ作成アプリを使用して、過去10年間に毎年読んだ本のチャートを作成することもできます。

そして、それはほんの始まりに過ぎません。

この種の深いアプリインテントの採用により、顧客はアプリを使用して必要なことを行うことができ、ワークフローの重要な部分になります。

たとえば、グラフの作成など、これらの統合のそれぞれは、構築する必要がない機能です。

意図が実行されると、アプリは、Siriのリクエストであろうとショートカットであろうと、結果を表示したり話したり、あいまいさを解決したりするために、ユーザーと対話する必要があるかもしれません。

アプリインテントは、インテントが完了したときにユーザーにテキストと音声のフィードバックを与えるためのダイアログと、視覚的なフィードバックを与えるためのスニペットなど、これらのインタラクションの数をサポートしています。

ユーザーに意図パラメータの値を明確にするように依頼するための要求値と曖昧さの解消、およびパラメータ値を検証したり、トランザクション的または破壊的な意図についてユーザーに確認したりするための確認を要求します。

ダイアログは、インテントを実行している人に音声またはテキストの応答を提供します。

音声体験で意図がうまく機能するための対話を提供することは本当に重要です。

先ほどのAdd Bookのインテントでは、本のタイトルと、performメソッドから返された結果ダイアログを尋ねるときに話されるneedsValueDialogを追加します。

これらは、多くのプラットフォームでショートカットやSiriによって読み取られたり表示されたりします。

スニペットはダイアログと視覚的に同等のものと考えることができ、意図の結果に視覚的な表現を追加できます。

スニペットを使用するには、選択したSwiftUIビューをインテント結果の末尾のクロージャとして追加するだけです。

ウィジェットと同様に、SwiftUIビューはアーカイブされ、ショートカットまたはSiriに送信されます。

App Intentsは、requestValueをスローしてユーザーに値を尋ねることもサポートしています。

たとえば、これは、時にはオプションのパラメータの値が必要な場合に便利です。

ここでは、文字列検索で複数の本が返されたときに、requestValueが役立ちます。

この場合、私はプロンプトし、著者に本の検索を絞り込むように依頼します。

requestValueは、私がスローできるエラーを与え、ユーザーにプロンプトを表示し、更新された著者名でアクションを再実行します。

一方、曖昧さ回避は、ユーザーがパラメータの値のセットから選択する必要がある場合に最適です。

これにより、Add Bookアクションで複数の可能な結果を処理するためのさらに優れた方法が得られます。

ここでは、生成された書籍から著者名のリストを取得し、それらの可能な値で曖昧さ回避を要求します。

ユーザーはそれらの間で選択するように求められ、私は結果を取り戻します。

最後に、App Intentsは2種類の確認をサポートしています。

最初の種類は、パラメータ値の確認です。

その値がどうあるべきかを推測しているが、確認したいときにこれを使うかもしれません。

本を追加するとき、時々私がタイトルで本を調べるために呼び出すウェブサービスはいくつかの一致を返しますが、そのうちの1つははるかに人気があります。

このような場合、ユーザーがその人気のある本を追加するつもりだったと仮定しますが、正しいことを確認するために確認を追加します。 確認を追加します。

これを行うには、タイトルパラメータでrequestConfirmationを呼び出します。

2番目の種類は、意図の結果の確認です。

例えば、これは注文に最適です。

ライブラリアプリを収益化し、書店を通じて注文を追加したい場合は、注文が正しいことを確認したいです。

これを行うには、私の意図についてrequestConfirmationを呼び出すことができ、配置される順序を渡します。

ここでもスニペットを指定し、注文のプレビューを表示します。

ユーザーが確認する代わりにキャンセルすると、requestConfirmationがエラーをスローするため、呼び出しの前に「try」を付けます。

私があなたを離れる前に、私がカバーしたいApp Intentsアーキテクチャのいくつかの側面があり、フレームワークを採用する際に知っておくべきです。

アプリインテントを構築するには、実際には2つの方法があります。アプリ内または別の拡張機能です。

これらのうち、アプリに直接インテントを実装することが最も簡単です。

フレームワークやコードを複製する必要はなく、プロセス間で調整する必要がないので、これは素晴らしいことです。

アプリを使用すると、より高いメモリ制限も提供され、オーディオの再生など、拡張機能でより難しい種類の作業を行うことができます。

trueを返す意図でopenAppWhenRunを実装すると、アプリはフォアグラウンドで実行できます。

そうでなければ、バックグラウンドで実行されます。

バックグラウンドで実行すると、パフォーマンスを最大化するためにシーンが起動されることなく、アプリは特別なモードで起動します。

実際、アプリにバックグラウンドアプリのインテントを実装する場合は、シーンサポートも実装することを強くお勧めします。

または、拡張機能でアプリのインテントを構築することもできます。

これにはいくつかの利点があります。

拡張プロセスはアプリの意図のみを処理し、アプリをスピンアップする必要がないため、軽量です。

フォーカスインテントを処理している場合、拡張機能を使用すると、アプリが最初にフォアグラウンドで実行されているという要件なしに、フォーカスが変更されたときに拡張機能ですぐにインテントが実行されることを意味します。

拡張機能は、新しいターゲットを追加し、いくつかのコードをフレームワークに移動し、アプリと拡張機能の間の調整を処理する必要があるため、もう少し作業です。

App Intents拡張機能を作成するには、Xcodeの[ファイル]>[新しいターゲット]に移動し、[App Intents拡張機能]を選択します。

App Intentsでは、あなたのコードが唯一の真実の源です。

App Intentsは、ビルド時にインテント、エンティティ、クエリ、およびパラメータに関する情報を静的に抽出することで、このエレガントな開発者体験を実現します。

Xcodeは、ビルドプロセス中にアプリまたは拡張バンドル内にメタデータファイルを生成し、コードで実行されるSwiftコンパイラから受け取った情報を含みます。

これらすべてが機能することを確認するには、App Intentsタイプをフレームワークではなく、ターゲットまたは拡張機能に直接保持してください。

同様に、ローカライズされた文字列は、App Intentsタイプが生息する同じバンドル内の文字列ファイルにある必要があります。

アップグレードしたいSiriKit Intentsを備えた既存のアプリをお持ちの方のために、ウィジェットやメッセージングやメディアなどのドメインと統合するIntentsを採用する場合は、SiriKit Intentsフレームワークを使用し続ける必要があります。

しかし、Siriとショートカットのカスタムインテントを追加する場合は、先に進んでアプリインテントにアップグレードする必要があります。

SiriKit Intents定義ファイルの「App Intentに変換」ボタンをクリックすると、アップグレードプロセスを開始できます。

App Intentsを使用してアプリをショートカットに統合することは、開発者としてのレバレッジを最大化する素晴らしい方法です。なぜなら、App Intentsを採用するために少量の作業を行うことで、顧客に大きな価値を生み出すことができるからです。

参加してくれてありがとう!

今日、App Intentsを試して、フィードバックをいただければ幸いです。

この新しいフレームワークが、アプリを使用している人々を驚かせ、喜ばせ、力を与えるのにどのように役立つかに興奮しています!

幸せな読書とあなたのWWDCが壮大であることを願っています!

♪