10070

♪ ♪

モハメッド：こんにちは、私はUIKitのモハメッドです。

デスクトップクラスのiPadアプリの構築に深く参加していただきありがとうございます。

このビデオでは、iPadOS 16 APIを使用して、既存のiPadアプリをデスクトップクラスのエクスペリエンスに更新します。

新しいナビゲーションバーAPIを使用して、強力な機能を表面化し、UI密度を高め、カスタマイズ性を提供することから始めます。

次に、新しいUICollectionViewとメニューAPIを採用して、複雑なワークフローと複数の選択に対する迅速なアクションを有効にします。

そして、新しい検索と置換のエクスペリエンスを有効にし、新しい編集メニューでテキスト編集を強化することで、物事を締めくくります。

アップデートするアプリは、iPadOS 15用に構築されたMarkdownエディタです。

近代化プロセスの各ステップを歩きながら、私たちの選択の背後にあるベストプラクティスと動機について話し合い、同様のプロセスを通じて独自のアプリを受講しながら考慮すべき要因のアイデアを提供します。

始める前に少し入門書をご希望の場合は、「Meet Desktop Class iPad」でUIKitのすべての新しいiPadOS APIの内訳を確認し、「iPadアプリデザインの新機能」をチェックして、可能な限り最高のデスクトップクラスのiPadアプリを設計する方法のヒントを確認してください。

よし、すぐに飛び込もう！

物事を始めるために、アプリのコントロールの構成を考えてみましょう。

このアプリはiPadOS 15用に設計されているため、すでにナビゲーションバーに最も重要なコントロールを公開し、さまざまなメニューやポップオーバーにセカンダリコントロールを配置しています。

iPadOS 16では、UIKitは既存のナビゲーションスタイルを形式化し、より密度が高く、よりカスタマイズ可能なレイアウトで2つの新しいスタイルを導入します。

これにより、アプリはUIの最前線により多くの機能をもたらしながら、コンテンツに最も適したレイアウトを表現することができます。

ナビゲーターアプリには、使い慣れたプッシュ/ポップナビゲーションモデルがあります。

これは通常、設定などの階層データを表示するアプリに適しています。

Safariやファイルなどのブラウザは、複数のドキュメントやフォルダ構造の間を行き来したりナビゲートしたりするのに理想的です。

また、編集者は、個々のドキュメントの集中的な表示や編集に最適です。

マークダウンエディターとして、このスタイルは私たちのアプリに最適です。

エディタスタイルは、タイトルをバーの最前縁に合わせ、新しいアイテムセットの中心を開きます。

これにより、他のビューやメニューに隠されていた可能性のある追加機能を公開することができます。

このデザインをできるだけ活用するために、いくつかのことをします。

まず、ニーズに合わせて組み込みのバックアクションをカスタマイズすることから始めます。

次に、ドキュメント情報と一般的なドキュメントアクションを含むタイトルメニューを追加します。

また、新しい組み込みのリネームUIによる名前変更のサポートも追加します。

そして最後に、以前に埋もれた機能をバーの中央に持っていくことで、より簡単にアクセスできるようにします。

まず、ビューコントローラーのnavigationItemのstyleプロパティを.editorに設定して、エディタスタイルを選択することから始めましょう。

これはすぐに私たちに主要な整列されたタイトルを与え、センターエリアを開きます。

その後、末尾の完了ボタンを削除し、新しいbackAction APIを使用して置き換えましょう。

このようにして、このビューを却下し、ドキュメントピッカーに戻るアクションのより標準的な外観が得られます。

次に、私たちのアプリがタイトルメニューの恩恵を受けるかどうかを調べてみましょう。

名前が示すように、タイトルメニューはナビゲーションバーのタイトルビューから表示されます。

ドキュメント全体に適用されるドキュメントメタデータとサーフェスアクションを表示するのに最適な場所です。

アプリがドキュメントベースでない場合は、ビュー全体に適用されるアクションを表示するのに適した場所かもしれません。

私たちのアプリでは、ドキュメントメニューのヘッダーを使用して、ドキュメントに関する有用な情報を表示することは理にかなっています。

また、ドキュメントのドラッグ可能な表現を提供し、共有機能に簡単にアクセスすることもできます。

そして今、いくつかのコードを書く時が来ました!

私たちのアプリはUIDocumentバックアップされているので、UIDocumentのfileURLを使用してUIDocumentPropertiesオブジェクトをインスタンス化できます。

次に、同じURLを使用してNSItemProviderを作成します。

次に、アイテムプロバイダーを使用して、プロパティオブジェクトの dragItemsProviderから返すUIDragItemを作成します。

また、プロパティオブジェクトのactivityViewControllerProviderから返すUIActivityViewControllerを構築するためにも使用します。

そして最後に、プロパティオブジェクトをエディタビューコントローラーのnavigationItemのdocumentPropertiesとして設定します。

先ほど書いたコードは、このドキュメントヘッダーに表示され、名前、サイズ、アイコン表現など、ドキュメントの簡単な概要を提供します。

ドラッグアイテムとアクティビティビューコントローラーのプロバイダーを指定したので、アイコンをドラッグしてドキュメントをアプリの外にコピーしたり、共有ボタンをタップしてアクティビティビューコントローラーを表示したりできます。

ドキュメントヘッダーを表示することに加えて、タイトルメニューは、ドキュメント全体に適用される機能を提供するのに適した場所です。

このメニューに表示できるアクションには2種類あります。事前に定義されたローカライズされたタイトルとシンボル画像を持つシステム提供のアクションと、アプリが提供する完全にカスタムのアクションです。

追加の動作が付属しているので、名前変更のアクションから始めましょう。

リネームデリゲートプロトコルに準拠することで、このアクションをメニューに追加できます。

トリガーされると、アクションはバーの組み込みの名前変更UIを表示します。

まず、ビューコントローラーをナビゲーションアイテムのrenameDelegateとして割り当てます。

次に、表示されたドキュメントの実際の名前変更を処理するために、navigationItemDidEndRenamingWithTitleを実装します。

この関数は、名前変更アクションがコミットされたときに呼び出されます。

実際にドキュメントの名前を変更してこれを処理するのはアプリの責任です。

APIは、アプリが持つ可能性のあるあらゆる種類のデータモデルをサポートするために、意図的にオープンエンドです。

他のシステムが提供するアクションに移るには、まずエディタービューコントローラーでそれらの機能をオーバーライドする必要があります。

ここでは、重複機能と移動機能を実装しました。

UIKitは、name変更アクションを含むシステムが提供するアクションを、提案されたUIMenuElementsの配列として、navigationItemのtitleMenuProviderに自動的に表示します。

タイトルメニューに含めるには、返されたメニューの子供に追加するだけです。

システムで導入されたアクションに加えて、完全にカスタムアクションやメニュー全体の階層を追加することもできます。

ここでは、HTMLおよびPDFサブアクションとしてエクスポートするエクスポートサブメニューを追加しました。

これにより、タイトルビューをタップすると、ドキュメントヘッダーと追加したすべてのアクションを含むメニューが表示されます。

そして、名前の変更を選択すると、組み込みの名前変更UIが有効になり、ドキュメントの名前を変更できます。

アプリの基本構造を確立し始めたので、Mac触媒でアプリを構築するときに物事がどのように見えるかを確認する良い機会です。

Macでアプリを実行すると、先頭に整列したタイトルのエディタスタイルがうまく翻訳されていることがわかります。

私たちのバックアクションも引き継がれ、クリックするとファイルブラウザが表示されます。

システムが提供するアクションと名前変更機能は、アプリのファイルメニューに自動的に表示されます。

titleMenuProviderはMac Catalystでは呼び出されないため、カスタムアクションはファイルメニューに含まれていないことに注意してください。

これらのアクションを公開するには、メインのUIMenuSystemを使用してアプリのメインメニューに手動で追加する必要があります。

よし、近代化のプロセスを続けましょう。

目標に向かって前進するにつれて、私たちはMacをチェックし続けます。

バーのセンターエリアで利用可能な機会を考えてみましょう。

iOS 15バージョンのアプリには、多くのセカンダリコントロールとツールを保持するメニューがあります。

センターアイテムを使用すると、これらのツールをより見つけやすくすることができます。

センターエリアはカスタマイズ可能であるため、あまり一般的に使用されていないものでUIを埋めることを心配することなく、コントロールの大規模なセットを含めることができます。

各人は、自分のワークフローに合わせてバーの内容を調整できます。

カスタマイズを有効にする最初のステップは、ナビゲーション項目にcustomizationIdentifierを指定することです。

次に、センターアイテムをUIBarButtonItemGroupsとして定義します。

グループは、UINavigationBarに拡張され、iOS 16でのカスタマイズをサポートするように強化された既存の概念です。

このスクリーンショットは、デフォルトで表示したいセンターアイテムのセットを示しています。

左側の同期スクロールボタンは、他の手段では到達できない重要な機能を提供するため、UIBarButtonItemの新しいcreatingFixedGroup（）関数を使用して固定グループに配置することは理にかなっています。

固定グループはカスタマイズできず、ユーザーが移動することはできません。

一方、リンクの追加ボタンは重要な機能を提供せず、エディタでリンクタグを入力することで同じタスクを達成できるため、createtOptionalGroupを使用して完全にカスタマイズ可能なアイテムを作成します。

そして、アプリの起動時中にカスタマイズが持続するように、一意のcustomizationIdentifierを与えます。

同様のプロセスに従って、デフォルトセットの残りの項目を定義し、デフォルトで使用する必要のない優先順位の低い項目に進みます。

そのような項目の1つは、太字、斜体、下線付きの項目を含むテキスト形式グループです。

デフォルトで表示するほど重要ではありませんが、バーにドラッグできるようにカスタマイズポップオーバーに入れたいです。

これを実現するには、isInDefaultCustomizationがfalseに設定されているUIBarButtonItemGroupのoptionalGroup初期化子を使用します。

また、ポップオーバーにタイトルがあり、バーのスペースがなくなったときに折りたたむことができるコンパクトな表現を持つように、グループに代表的なアイテムを与えるようにしてください。

iPadに戻ると、私たちが定義した中央のアイテムがバーの中央に表示されます。

新しく追加された詳細ボタンをクリックすると、メニューがツールバーのカスタマイズアクションとともに表示されます。

それをクリックすると、カスタマイズモードが有効になります。

固定としてマークした同期スクロールボタンは強調解除され、静的ですが、他のすべてのアイテムは持ち上げて振ってカスタマイズ可能であることを示しています。

フォーマットグループなどのオプション項目がポップオーバーに表示され、バーにドラッグできます。

Macでアプリを実行すると、中央の項目が完全にカスタマイズ可能なmacOSツールバーボタンに変換されていることがわかります。

先に進む前に、ちょっとiPadに戻って、アプリのサイズを変更しましょう。

ツールバーで利用可能なスペースが少なくなったため、中央の項目は表示されなくなりました。

UIKitは、利用可能なスペースに応じて、センターアイテムの表示と非表示を自動的に処理します。

合わないアイテムはオーバーフローメニューに表示されます。

標準のバーボタン項目は自動的にメニュー表現に変換されますが、必要に応じてカスタムメニュー表現を提供することもできます。

UIKitはカスタムビューアイテムの目的についての洞察がないため、スライダーアイテムは自動的に翻訳されません。

メニュー表現を手動で指定する必要があります。

これが私たちのスライダーアイテムです。

これは、カスタムビューを持つ単一のバーボタンアイテムで、オプションのバーボタングループで囲まれています。

スライダーのコア機能を提供するために、メニュー表現を減少、リセット、増加アクションを含むUIMenuとして定義します。

UIMenuの新しいpreferredElementSizeプロパティを使用すると、メニューをよりコンパクトなサイドバイサイドの外観にすることができます。

また、新しいKeepsMenuPresented属性を使用すると、各アクションが実行された後にメニューを表示し続けることができ、メニューを却下して再表示することなく、フォントサイズを複数回変更できます。

これをiPadでもう一度実行しましょう。

オーバーフローメニューを表示すると、スライダーは3つのサイドバイサイドアクションを持つインラインメニューとして表示され、スライダーの全機能をカバーしています。

小さな要素サイズはMacには存在しないため、アクションは標準のmacOSメニュー項目として表示されます。

そして、それはUIの整理とカスタマイズのためのものです。

次に、新しいコレクションビューとメニューAPIを使用して、アプリのワークフローを高速化することを検討しましょう。

私たちのアプリには、ドキュメントをすばやくナビゲートしたり、トップレベルのタグでアクションを実行したりするために使用できる目次サイドバーがあります。

iOS 16以前は、複数のアイテムを編集する機能を追加すると、バルクアクションがツールバーのボタンに追いやられ、個別の編集モードを実装することを意味する可能性があります。

iOS 16では、マルチアイテムメニューの新しいデザインが導入され、メニューがどのアイテムに影響するかを明確に伝え、マルチアイテムドラッグへの直接移行を提供します。

デスクトップクラスのiPadアプリでは、この新しいメニューデザインは、より軽い重量選択スタイルと組み合わせるのが最適です。

ここでの「軽量」とは、コレクションビューを編集モードにしたり、アプリのUIに大幅な変更を加えたりすることなく、複数のアイテムを選択することを意味します。

これを達成し、既存のAPIを使用してキーボードフォーカスを有効にすることができます。

まず、allowsMultipleSelectionをtrueに設定します。

次に、allowsFocusをtrueに設定して、キーボードフォーカスを有効にします。

そして、selectionFollowsFocusをtrueに設定することで、フォーカスが選択を促進できるようにします。

iPadでこれを実行すると、各アイテムが選択に追加されると、まだ選択アクションが実行され、エディタビューがスクロールされることにすぐに気付きます。

コードに戻って、何が起こっているのかを把握しましょう。 

そこにある！

didSelectItemAtIndexPathのコードは、collectionViewのisEditingプロパティをチェックすることで、編集モードでのスクロールを禁止しようとします。

編集モード以外で複数の選択を許可したので、このコードはすべての選択に対して実行されます。

新しいUICollectionViewDelegateメソッドを使用して修正できます。

performPrimaryActionForItemAtIndexPathを実装し、スクロールコードをこの新しい関数に移動するだけです。

この関数は、単一のアイテムがタップされ、コレクションビューが編集されていない場合にのみ呼び出されるため、編集モードのチェックは不要になりました。

また、選択関連の動作がないため、indexPathで選択した項目の実装を削除できます。

iPadに戻って、複数のアイテムを選択すると、エディタビューで対応するテキストにスクロールしなくなりました。

それが終わったら、実際にメニューのサポートを追加しましょう。

iPadOS 16では、UICollectionViewDelegateの既存の単一項目メニューメソッドは非推奨です。

その代替品は、ゼロから多くのアイテムのメニューの表示をサポートしています。

指定されたindexPaths配列の項目の数は、選択される項目の数と、メニューが呼び出される場所によって異なります。

配列が空の場合、メニューはセル間の空白で呼び出されました。

単一のindexPathがある場合、選択解除されたアイテム、または唯一選択されたアイテムで呼び出されました。

複数の項目がある場合、メニューは複数の選択の一部である項目で呼び出されました。

iPadに戻り、上位4つの項目をもう一度選択し、選択した項目の1つを2本指でクリックすると、新しいマルチアイテムメニューが表示されます。

Macで同じことをすると、選択したセルの周りにリングが描かれ、それらを強調表示します。

マルチアイテムメニューが完了したら、新しい検索と置換と編集メニュー機能を使用して、テキスト編集体験を強化することを検討しましょう。

私たちのアプリはエディタにUITextViewを使用し、カスタムの検索と置換の動作を必要としないため、デフォルトのシステム機能を有効にするために必要なのは、テキストビューのisFindInteractionEnabledプロパティをtrueに設定することだけです。

その設定では、テキストの編集中にCommand + Fを押すと、検索と置換のUIが表示されます。

テキストビューの編集メニューにカスタムアクションを追加することはそれほど多くなく、いくつかの優れたクイック編集機能を有効にすることができます。

推奨されるアクションの範囲内のテキストの新しいUITextViewDelegateメソッド編集メニューを実装するだけです。

実装では、この非表示アクションのようなカスタムアクションとシステムメニューを組み合わせたUIMenuを構築して返すことができます。

そして、これが結果です。テキストを選択して編集メニューを表示すると、カスタムアクションとシステム提供アクションの両方が表示されます。

検索と置換と編集メニューの詳細については、「デスクトップクラスの編集インタラクションを採用する」を参照してください。そして、それだけです!

これらのいくつかの変更により、私たちはアプリのデスクトップクラスを作り、それをMacにシームレスに翻訳するためのいくつかの素晴らしい基本的なステップを踏み出しました。

iPadOS 16で提供されているAPIを使用して、独自のアプリを同様のプロセスで実行します。

アプリに合ったナビゲーションスタイルを選択することから始めます。

ドキュメントのプロパティとタイトルメニューを使用して、ドキュメントのワークフローを強化します。

そして、重要な機能を表面化し、センターアイテムでカスタマイズ性を提供します。

マルチアイテムメニューを使用して、複数のアイテムにすばやく対応できるようにします。

また、検索と置換と新しい編集メニューを使用して、アプリのテキスト編集体験を向上させます。

新しいアプリを構築する場合でも、既存のアプリを更新する場合でも、これらの新しいツールで構築したアプリを使用するのが待ちきれません。

見てくれてありがとう。