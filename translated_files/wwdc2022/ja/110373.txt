110373

♪ ♪

Souvik Banerjee:こんにちは、「DriverKitでドライバーをiPadに運んでください」へようこそ。

私はSouvikです。今日はDriverKitのいくつかのエキサイティングな新しい開発について説明します。

今日は3つのトピックについて話し合います。

まず、DriverKitの概要を簡単に説明します。

次に、AudioDriverKitのアップデートについて説明します。

そして、あなたのドライバーをiPadに持ち込む方法から締めくくります。概要から始めましょう。

2019年には、IOKitデバイスドライバの代替品であるDriverKitを導入しました。

DriverKitは、ユーザースペースで実行される、より信頼性が高く安全なシステムを拡張する新しい方法をもたらしました。

そして、あなたのプロセスはカーネルにないので、開発が簡単です。

これらのドライバー拡張機能は、dextsとも呼ばれ、アプリにバンドルされており、Mac App Storeでアプリやドライバーを簡単に配布できます。

人々は検索でドライバーを簡単に見つけることができ、ドライバーが不要になった場合は、アプリを削除してアンインストールできます。

DriverKitを導入して以来、多くの新しいドライバーファミリーのサポートを追加しました。

現在、USB、PCI、HIDなどのトランスポートに加えて、ネットワーキング、ブロックストレージ、シリアル、オーディオ、SCSIコントローラと周辺ドライバをサポートしています。

DriverKitで構築できるドライバの種類の詳細については、WWDC 2021の「DriverKitでオーディオドライバを作成する」セッションと、WWDC 2020の「DriverKitでPCIおよびSCSIドライバをモダナイズする」セッションをご覧ください。

次に、最近、強調したいAudioDriverKitにいくつかの新機能を追加しました。

これらの機能の1つはリアルタイム操作です。

リアルタイムのコールバックを登録できるAudioDriverKitの新機能を導入できることを嬉しく思います。

このコールバックは、IO操作が発生するたびに呼び出されます。

信号処理など、リアルタイムスレッド上のオーディオバッファを変更する必要がある場合は、このコールバックを使用できます。

AudioDriverKitにリアルタイムコールバックを登録するには、IOUserAudioDeviceに設定するIOOperationHandlerブロックを宣言します。

このブロックは、デバイスのIOUserAudioStreamバッファでIO操作が発生すると、リアルタイムのコンテキストから呼び出されます。

ブロック内では、操作が何であるかを確認し、必要に応じてデータを変更することができます。

最後に、SetIOOperationHandlerを呼び出すと、オーディオデバイスのブロックが設定されます。

では、資格について話しましょう。

AudioDriverKitを導入したとき、ドライバーで許可された任意のユーザークライアントアクセス権限を使用する必要がありました。

macOS 12.1では、AudioDriverKit専用の新しい資格を導入しました。

Allow-any-userclient-accessエンタイトルメントの代わりに、新しいオーディオファミリーエンタイトルメントを使用するようにオーディオドライバを更新してください。

アプリがドライバーと通信できるようにしたい場合は、allow-any-userclient-accessの資格を保持できます。

この新しい資格は開発のために公開されているので、リクエストを提出せずに今日から使い始めることができます。

実際、すべてのDriverKitファミリーの資格が開発に使用できるようになりました。

この配布資格をリクエストするには、developer.apple.comのシステム拡張機能ページにアクセスしてください。

さて、iPadのDriverKitについてお話しできることを本当に楽しみにしています。

専門家は、最高の仕事をするためにiPadをますます使用しています。

しかし、多くはiPadでは使用できない外部ハードウェアに依存しています。

そこで今日、DriverKitがiPadに登場することを発表できることを嬉しく思います。

macOSのDriverKitは、安全で安全な方法でシステムを拡張することを可能にし、同じ技術をiPadに導入しています。

実際、すでにMacのDriverKitでドライバーを作成している場合は、ドライバーを変更することなく、まったく同じドライバーをiPadに持ち込むことができます。

USB、PCI、オーディオはiPadOS 16でサポートされます。

これにより、初めてiPadのThunderboltオーディオインターフェイスと、さらに多くのデバイスが可能になります。

これはM1チップのパワーで可能になりました。

M1を搭載したすべてのiPadはDriverKitをサポートします。

iPadOSのDriverKitはmacOSと同じです。

これは、1つのDriverKitドライバを構築し、両方のプラットフォームで動作させることができ、ソースの変更を必要としないことを意味します。

さらに、Xcode 14の新しいマルチプラットフォームアプリ機能を使用すると、MacとiPadの両方でドライバーを配信するための単一のアプリターゲットを簡単に作成できます。

マルチプラットフォームアプリの詳細については、「Xcodeを使用してマルチプラットフォームアプリを開発する」セッションをチェックしてください。

Xcodeは、DriverKitドライバの自動署名もサポートするようになりました。

iPadOSでDriverKitを処理する方法を知っており、MacとiPadの両方にプロビジョニングできます。

DriverKitドライバの手動署名を設定する必要がなくなりました。

iPadOSアプリとドライバーは、macOSと同じようにApp Storeで配布できます。

これは、アプリ内購入などの機能を活用し、ユーザーがドライバーを簡単に発見できることを意味します。

既存のmacOSドライバとアプリをiPadに持ち込むのがどれほど簡単か見てみましょう。

ここには、DriverKitSampleAppというアプリがあります。

ラベルとボタン付きのSwiftUIビューがあり、ユーザーはドライバーをインストールできます。

私たちのドライバーはNullDriverと呼ばれています。

ドライバーが起動するとメッセージが出力され、タイマーが1秒ごとに起動し、timerCountと呼ばれるカウンタをインクリメントします。

これをiPadアプリにするには、XcodeでDriverKitSampleAppターゲットを選択するだけです。

そして、サポートされている目的地にiPadを追加します。

これで、実行先をMacに接続したiPadに変更できます。

これをiPadで実行してみましょう。

これが私たちのiPadアプリです。

Xcodeで見たビューのラベルとボタンがあります。

Install Dextボタンをタップすると、設定に移動し、この新しいドライバーのリンクが表示されます。

そのリンクをタップすると、このアプリにバンドルされているすべてのドライバーのリストが表示されます。

その後、ヌルドライバーを有効にすることができます。

だから、あなたはデモでいくつかのことに気づいたかもしれません。

Null DriverはiPadOSアプリ内にバンドルされており、インストール後にシステムによって自動的に検出されます。

macOSでは、SystemExtensionフレームワークを使用して、ユーザーにドライバのインストールを促す必要があります。

iPadOSには、SystemExtensionsフレームワークはありません。

Xcode内では、ドライバーがアプリに埋め込まれていることがわかります。

ドライバーは低レベルのソフトウェアであり、特権があるため、実行する前にユーザーの承認を得る必要があります。

macOSでは、ユーザーはセキュリティとプライバシーの環境設定に移動して、システム拡張を許可する必要があります。

iPadOSでは、ドライバーの承認は設定アプリにあります。

ドライバーの承認には2つのオプションがあります。

ドライバーがインストールされているアプリが少なくとも1つある場合は、一般設定内にメニューがあり、利用可能なすべてのドライバーのリストが表示されます。

各ドライバーはオンまたはオフを切り替えることができます。

アプリに設定バンドルが含まれている場合は、アプリの設定内にドライバーリンクがあります。

アプリは、設定でドライバーを有効にするようにユーザーに促す必要があります。

macOSドライバープロジェクトをもう一度やり直して、アプリが設定でドライバーを有効にするようにユーザーに促す方法を見てみましょう。

サポートされている目的地にiPadを追加することから始めます。

SwiftUIビューにはドライバーをインストールするボタンがあり、ビューモデルにはSystemExtensionsフレームワークと対話するステートマシンがあります。

このプロジェクトはMacとiPadの両方で構築されるため、Macのビューとビューモデルを維持したいと考えていますが、iPadで使用される新しいビューを作成したいと考えています。

次に、ビルドフェーズとコンパイルソースに移動し、各ファイルのプラットフォームフィルターを変更して、iOSまたはmacOS用に条件付きでコンパイルすることができます。

では、アプリに設定バンドルを追加しましょう。

今のところ、デフォルトの設定例を使用しますが、後でアプリが使用できる実際の設定に変更できます。

では、先ほど作成したiOSビューを確認しましょう。

macOSビューをiOSビューにコピーして、出発点として使用できます。

私たちのiOSビューはビューモデルを使用していないので、それを削除することができます。

また、設定バンドルを開くためにボタンのアクションを変更する必要があります。

これにより、ユーザーは設定に移動し、ドライバーを有効にすることができます。

最後に、ボタンのテキストを変更して、ユーザーが設定でドライバーを有効にする必要があることを明確にします。

これを実際に見てみましょう。

設計したビューがあり、ボタンをタップすると設定バンドルに移動します。

次に、ドライバーに入り、ヌルドライバーを有効にします。

ドライバーはオンデマンドで起動することを心に留めておくことが重要です。

設定でドライバーを有効にしましたが、ハードウェアデバイスがiPadに接続されている場合にのみ、ドライバーが起動します。

ドライバの実行が開始されたら、Xcodeワイヤレスデバッグを使用してデバッガを添付できます。

これを行うには、Xcodeのデバッグメニューに移動し、プロセスに添付してから、NullDriverプロセスを選択します。

添付したら、ブレークポイントを設定したり、実行を一時停止したりできます。

ここでは、タイマーにブレークポイントを設定しました。

timerCountを印刷して、タイマーが何回呼び出されたかを確認します。

デバッグが完了したら、Xcodeのデバッグメニューを使用してドライバープロセスから切り離します。

だから今、私たちには運転手がいます。

しかし、ドライバー自体はあまり役に立ちません。

システムの残りの部分と通信する必要があります。

AudioDriverKitのようないくつかのDriverKitフレームワークは、あなたのためにこれを処理します。

しかし、ハードウェア用のカスタムコントロールパネルアプリを作成するなど、より高度なことをする必要がある場合は、アプリがドライバーと通信できるようにする必要があります。

これは、ユーザークライアントが許可していることです。

独自のインターフェイスを定義でき、アプリとドライバーの通信が可能になります。

アプリはIOKit.frameworkを使用してユーザークライアントを開きます。

これがどのように機能するかの例については、developer.apple.comのサンプルコードを参照してください。

だから、私たちはアプリがドライバーと通信できることを知っています。

しかし、セキュリティを念頭に置いておくことが重要です。

ドライバーは特権を持っているので、すべてのアプリがドライバーと通信することを許可したくありません。

macOSでは、アプリはドライバーキットのユーザークライアントアクセス権限を必要とし、値は許可されたドライバーバンドル識別子の配列です。

iPadOSでは、ドライバーとのコミュニケーションという新しい資格を追加しました。

これは、macOSユーザーのクライアント資格を置き換えます。

この資格は、アプリにユーザークライアントをドライバーに開く機能を付与します。

Communicates With Driversエンタイトルメントをアプリに手動で追加したい場合は、ここにXMLエンタイトルメント文字列があります。

Xcodeからこのエンタイトルメントを追加することもできます。

Xcodeでは、Signing and Capabilitiesに移動し、新しい機能を追加します。

その後、「ドライバーとのコミュニケーション」を検索し、アプリに機能を追加できます。

ユーザークライアントのもう1つのユースケースは、他の開発者のアプリがドライバーと対話できるようにすることです。

したがって、この場合、アプリとドライバーがあり、他の開発者のアプリを含む他のアプリにサービスを提供したいとします。

DriverKitユーザークライアントもこれをサポートしています。

ドライバーと通信する必要がある各アプリは、ドライバーの資格との通信を必要とします。

ドライバーには、サードパーティのユーザークライアントの資格を許可する必要があります。

これにより、別のチーム識別子で構築されたアプリは、ユーザークライアントをドライバーに開くことができます。

この資格がなければ、同じチームのアプリだけがドライバーと通信できます。

「サードパーティのユーザークライアントを許可する」エンタイトルメントをドライバーに手動で追加する場合は、ここにXMLエンタイトルメント文字列があります。

または、ドライバーの署名と機能に進んで、Xcodeからこの機能を追加することもできます。

これらの新しいユーザークライアントの資格は開発のために公開されています。つまり、承認なしに今日からこれを使い始めることができます。

配布のためにこれらの資格をリクエストするには、開発者のウェブサイトをご覧ください。

DriverKitドライバは、アプリのアップデートにも重要な影響を及ぼします。

アプリの自動更新により、ユーザーはアプリの最新バージョンを常に入手できます。

ただし、ドライバを含むアプリの場合、更新プロセスは少し異なります。

アプリのバージョン1をアプリストアで配布するとしましょう。

次に、そのアプリとバンドルされたドライバをiPadにインストールし、設定でドライバを有効にします。

ドライバーにハードウェアデバイスを接続すると、ドライバーが実行を開始し、ドライバーが実行を開始すると、アプリはユーザークライアントを使用してドライバーとの通信を開始できます。

さて、アプリにバグを見つけて、バージョン2をApp Storeに提出したとします。

アプリの自動更新のため、バージョン2のアプリが自動的にダウンロードされ、iPadにインストールされます。

ドライバーの承認状態は更新によって維持されるため、ドライバーを再度承認する必要はありません。

ただし、ハードウェアがまだ接続されており、バージョン1のドライバがまだ実行されていることに注意してください。

ドライバーバージョン2はアプリのアップデートでダウンロードされましたが、起動しません。

古いドライバはまだ実行中なので、バージョン2のアプリはバージョン1のドライバと通信する必要があるかもしれません。

ハードウェアデバイスのプラグを抜くと、ドライバーの実行が停止するので、ドライバーバージョン1が完了し、ドライバーをバージョン2に更新できます。

さて、デバイスを再度接続すると、バージョン2のドライバを起動し、アプリが新しいドライバと通信しています。

要約：アプリは自動アプリアップデートでいつでも更新されます。

デバイスのプラグを抜いた後、ドライバーが更新されます。

そして、あなたのアプリは古いドライバーと通信するかもしれません。

アプリとドライバーの準備ができたら、App Storeに提出できます。

ドライバーは、DriverKitをサポートするデバイスでのみ実行できます。

アプリがドライバーのみをインストールする場合など、アプリをこれらのデバイスに制限したい場合は、アプリのUIRequiredDeviceCapabilitiesにDriverKitを追加します。

これにより、ユーザーがDriverKitをサポートしていないデバイスにアプリをインストールできなくなります。

また、アプリとドライバーがハードウェアデバイスでどのように機能するかを示すビデオをApp Reviewに提出することをお勧めします。

それがiPadのDriverKitです。

M1でUSB、PCI、およびオーディオドライバをiPadに持ち込み、それらのドライバをApp Storeのアプリ内に配信できるようになりました。

そして、すでにドライバーを持っているなら、それをiPadに持ち込むのは簡単です。

開発者は、iPadでDriverKitを使用してみて、フィードバックアシスタントを使用してフィードバックを提供することをお勧めします。

ご覧いただきありがとうございます。