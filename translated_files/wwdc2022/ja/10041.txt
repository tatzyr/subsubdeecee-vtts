10041

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

Lais Minchillo: こんにちは、私の名前はLaisです。

デビッド・シルバー:そして、私はデビッドです。そして、今年のWalletとApple Payの新機能を紹介します。

私たちは2014年にApple Payを立ち上げ、店舗、オンライン、アプリ内で高速で安全でプライベートな支払いを行うための新しいベンチマークを設定しました。

それ以来、私たちはApple Payを世界中に拡大してきました。

Apple Payは現在72の国と地域で利用可能で、毎日100万件以上の取引を処理しています。

本日、WalletとApple Payにエキサイティングな新機能とAPIを導入します。

ライスはもっと教えてくれるでしょう。

ライス：ありがとう、デビッド！

今日のメインアジェンダを見てみましょう。 では。

まず、いくつかの簡単なアップデートについて話します。

1つのトランザクションで複数のマーチャントへの支払いのサポートを追加しています。

また、サブスクリプションを含む自動支払いのサポートを大幅に改善しています。注文追跡を使用すると、顧客の購入後体験を向上させることができます。

そして最後に、デビッドはウォレットのIDによる本人確認について話します。

共有するエキサイティングなアップデートがいくつかあります。

iPhoneでタップして支払うことは今年初めに発表され、米国ではiOS 15.4で発売されました。

iPhoneでタップして支払うことは、非接触型決済を受け入れるための安全でプライベートで簡単な方法を提供します。

これをアプリに簡単に統合して、シームレスかつ安全に非接触型決済を受け入れることができます。

これには、Apple Pay、非接触型クレジットカードとデビットカード、その他のデジタルウォレットが含まれます。

取引はiPhoneをタップするだけで完了し、追加のハードウェアや決済端末が不要になります。

一方、macOS 13では、Apple Payの体験を再設計しました。

昨年のiOSペイメントシートの再設計は大成功を収め、今年はmacOSに同様の体験をもたらします。

SwiftUIを使用してこれを実装し、iOSと同時にmacOSに新しい機能を導入するのに役立ちました。

今日導入するすべてのApple Pay機能は、Macでもサポートされています。

新しいSwiftUI APIを導入しています。

SwiftUIアプリでApple WalletまたはApple Payボタンに追加を統合する方がはるかに簡単になります。

これらの新しいAPIは、書く必要があるコードの量を大幅に減らします。

ユーザーに航空会社のパスを追加するように促すボタンを追加する方法を見てみましょう。

まず、パスを作成します。

正常にロードされなかったケースを処理する必要があります。

これは、たとえば、パスデータの形式が間違っている場合や、適切に署名されていない場合に発生する可能性があります。

次に、パスの配列でAddPassToWalletButtonを呼び出します。

この例では、1つの要素のみの配列がありますが、同じボタンで複数のパスを持つことができます。

結果はブールとして渡され、ユーザーがパスを追加したかどうかに基づいて、アプリ内の他のアクションを保存、記録、またはトリガーできます。

この例では、私はそれを状態変数に保存しています。

そして、それだけです!

最小値のセット内でボタンのサイズとスタイルをカスタマイズすることもできます。

これはデフォルトのサイズです:幅250と高さ50。

あなたはそれをより広くすることもできます...

...または背が高い。

これは、SwiftUIでApple Walletに追加ボタンを追加する方法をまとめています。

では、Apple Payボタンでペイを追加する方法を見てみましょう。

まず、PKPaymentRequestクラスを使用して支払いリクエストを作成し、通常の設定を設定します。

次に、authorizationChangeメソッドを作成します。

これら2つのピースの準備ができたので、ボタンを表示するコードを追加しましょう。

PayWithApplePayButtonへの呼び出しを追加し、ラベル、paymentRequestオブジェクト、およびauthorizationChangeメソッドを渡します。

現在のデバイスでApple Payがサポートされていないケースを処理するには、フォールバックビューで渡すことができます。

パスの追加ボタンと同様に、サイズとスタイルをカスタマイズすることもできます。

合計で17の異なるラベルがあるので、ユースケースに合わせて支払いボタンをカスタマイズできます。

これらはiOS、iPadOS、macOS、watchOSで利用できます。

では、マルチマーチャントの支払いを見てみましょう。

iOS 16では、同じトランザクションで異なるマーチャントに対して複数の支払いトークンを要求する機能を導入しています。

これは、オンラインマーケットプレイス、旅行予約、発券サービスなどに役立ちます。

例を詳しく見てみましょう。

アリソンが旅行を計画していると想像してみてください。

彼女は旅行代理店のウェブサイトに行き、航空券、ホテル滞在、レンタカーなど、予約する必要があるすべてのものを便利に提供しています。

アリソンは合計500ドルを支払う必要があります。

アリソンは旅行代理店に彼女の完全なクレジットカード情報を提供します。

さて、旅行代理店がアリソンのクレジットカードに500ドルを請求し、関係する他の会社に支払うと想像するかもしれません。

しかし、通常起こることは、旅行代理店がクレジットカード情報を各企業に渡すだけで、個別の請求を行います。

これは機能しますが、アリソンのプライバシーとセキュリティがクレジットカード情報を共有するのは素晴らしいことではありません。

これで、新しいマルチマーチャント支払いAPIを使用すると、取引に関与する各マーチャントの支払いトークンをリクエストすることができます。

これらの支払いトークンを使用して、関係する複数の企業は、それぞれ彼女が承認した関連金額をアリソンに請求することができます。

アリソンは、Apple Payが提供するプライバシーとセキュリティの利点を活用しながら、旅行の予約と支払いができます。

支払いシートが更新され、取引に関与するサブマーチャントの内訳を顧客に表示しました。

お客様は合計フィールドをタップして、支払いの概要に移動できます。

ここでは、取引に関与するすべての商人の内訳と、それぞれに承認された金額を見ることができます。

では、アプリにマルチマーチャントの支払いを追加する方法を見てみましょう。

まず、PKPaymentRequestクラスを使用して支払いリクエストを作成し、通常の設定を設定します。

次に、合計を含む支払いの要約項目を追加します。

次に、新しいPKPaymentTokenContextクラスを使用して、トランザクションに関与する追加のマーチャントごとに支払いトークンコンテキストを作成します。

各マーチャントの詳細と、それぞれに承認する金額を提供します。

最後に、支払い要求に支払いトークンのコンテキストを設定します。

すべての支払いトークンコンテキストの金額の合計は、支払い要求自体の合計金額以下でなければならないことに注意してください。

また、アプリでそのマーチャントの支払いトークンを要求するときはいつでも、常に同じマーチャントに同じ外部識別子を使用する必要があります。

ウェブ上でApple Payでマルチマーチャント決済を採用するには、Apple Pay JS APIのドキュメントをご覧ください。

では、自動支払いの改善を見てみましょう。

iOS 16では、ウォレットアプリから直接、マーチャントで設定した自動支払いを表示および管理する機能を導入しています。

このリリースでは、サブスクリプション、分割払い、定期的な請求などを含む定期的な支払いと、ストアカード残高のチャージなどの自動リロード支払いの2種類の自動支払いをサポートしています。

支払いリクエストを行う際に自動支払いの設定をリクエストできるように、新しいAPIを導入しています。

また、顧客のApple IDに関連付けられた新しい種類の支払いトークンであるApple Payマーチャントトークンも導入しています。これにより、継続的に顧客に請求をより確実に行うことができます。

Apple Payのマーチャントトークンを詳しく見て、どのように役立つかを見てみましょう。

ジュリーがiPhoneでApple Payを使ってブッククラブの会費を支払っていると想像してみてください。

ブッククラブは支払い要求を行い、ジュリーが支払いを承認すると、ブッククラブは支払いトークンを受け取り、毎月それを使ってジュリーに会費を請求することができます。

この支払いトークンは、ジュリーが支払いを承認するために使用したデバイスにリンクされています。

しかし、ジュリーが新しいiPhoneを手に入れたらどうなりますか?

新しい自動支払い機能により、ジュリーの支払いネットワークがサポートしている場合、ブッククラブは代わりにApple Payマーチャントトークンを受け取ります。

この支払いトークンは、彼女のiPhoneではなく、ジュリーのApple IDに結び付けられており、継続的な承認のためのより良い保証を提供します。

これは、ジュリーがiPhoneをアップグレードしたり、現在の携帯電話をリセットしたりした場合、ブッククラブはジュリーに毎月の会費を確実に請求し続けることができることを意味します。

これらの種類の支払いにApple Payを受け入れる場合は、顧客に確実に請求し続け、サービスの中断を避けるために、自動支払いを採用することをお勧めします。

このリリースでサポートする自動支払いの最初のタイプは、定期的な支払いです。

定期的な支払いには、毎週、毎月、または毎年などの定期的なスケジュールで請求される固定または変動額があります。

これらの支払いは、特定の日に終了することも、キャンセルされるまで継続することもできます。

試用期間または入門期間もサポートされています。

サブスクリプション、分割払いプラン、および通常の請求は、このタイプの支払いに最適です。

自動支払いを使用してアプリで定期的な支払いを設定する方法を見てみましょう。 アプリ内での定期的な支払いを設定する方法を見てみましょう。

PKRecurringPaymentSummaryItemクラスを使用して、定期的な支払いの金額と期間を指定することから始めます。

定期的な支払いの場合、通常の請求期間と導入期間または試用期間の両方を指定できます。

startDateとendDateのプロパティを使用して、試用期間が終了し、通常の請求期間がいつ開始されるかを示すことができます。

次に、新しいPKRecurringPaymentRequestクラスを使用して recurringPaymentRequestを作成します。

支払いの説明、通常の請求期間、および顧客が定期的な支払いの支払い方法を更新または削除できるWebページに管理URLを提供します。

オプションで、トライアル請求期間と請求契約テキストを提供して、顧客への支払い条件を説明することもできます。

最後に、オプションで、サーバーが発行された場合、支払いのApple Payマーチャントトークンに関するライフサイクル通知を受信できるtokenNotificationURLを提供できます。

たとえば、カード発行者またはユーザーがトークンを削除した場合に通知を受け取ることができます。

マーチャントトークンライフサイクル通知の詳細については、Apple Payマーチャントトークン管理APIのドキュメントを参照してください。

最後に、paymentRequestオブジェクトに recurringPaymentRequestを設定します。

サマリーアイテムに関する簡単なメモ、定期的な支払いは支払いリクエストのサマリーアイテムに自動的に追加されません。

したがって、必ず要約項目配列に項目を追加してください。

支払い要求の合計は、顧客に請求される最初の金額でなければなりません。

したがって、この例では、顧客が請求される最初の金額であるため、合計は試用期間の金額を表示するように設定されています。

支払いシートには、顧客への定期的な支払いの詳細が表示され、請求の詳細セクションをタップしてさらに読むことができます。

さて、このリリースでサポートしている2番目のタイプの自動支払いを見てみましょう。自動リロード支払いです。

このタイプの支払いでは、残高が特定のしきい値を下回るたびに、残高が自動的に固定額で補充されます。

自動リロード支払いは、店舗カードのチャージやプリペイド残高などに最適です。

自動リロード支払いの設定をリクエストするには、新しいPKAutomatic ReloadPaymentSummaryItemクラスを使用して、リロードとしきい値の金額を指定することから始めます。

次に、新しいPKAutomatic ReloadPaymentRequestクラスを使用してautomaticReloadPaymentRequestを作成し、定期的な支払いと同様に、支払いの説明、請求、および管理URLを渡します。

オプションで、請求契約のテキストとトークン通知URLを提供することもできます。

最後に、支払い要求オブジェクトに自動リロード支払い要求を設定します。

繰り返しますが、要約項目に自動リロード支払いを必ず含め、支払いリクエストの合計を適切に設定してください。

ウェブ上でApple Payで自動支払いを採用するには、Apple Pay JS APIのドキュメントをご覧ください。

自動リロード支払いが顧客の支払いシートに表示される方法は次のとおりです。

最後に、アプリで自動支払いを採用する際に、顧客に可能な限り最高の体験を提供するために覚えておくべきことがいくつかあります。

これらは追加されないため、自動支払いの要約項目を含めることを忘れないでください。

支払い要求の合計金額は、顧客に請求される最初の金額である必要があります。

請求契約のテキストを短くしておく必要があります。

支払いシートには最初の500文字しか表示されなくなります。

請求契約のテキストは、通常の請求および法的契約に代わるものではありません。

現地の定期請求法に準拠するのはあなた次第です。

顧客に見せる法的契約がある場合は、支払いシートを提示する前に顧客に表示することを意味するかもしれません。

1つのトランザクションで1種類の自動支払いのみをリクエストできます。

また、自動支払いはマルチマーチャントの支払いでは使用できません。

最後に、支払いのために発行されたApple Payマーチャントトークンのライフサイクル通知を受け取りたい場合は、必ずトークン通知URLを提供し、サーバーでApple Payマーチャントトークン管理APIを採用してください。

これらの新しいAPIとApple Payマーチャントトークンの利点を気に入っていただけると思います。

以下は、自動支払いのサポートを採用するパートナーのほんの一部です。

Apple Payマーチャントトークンは、American Express、Discover、Mastercard、Visaによってサポートされ、将来的には他の決済ネットワークもサポートされます。

購入後の体験を向上させるために、注文追跡を導入できることを嬉しく思います。

iOS 16の新機能で、注文追跡により、ユーザーは参加加盟店との注文を追跡できます。

ウォレットは、アクティブな注文、最近完了した注文、過去の注文の直感的な概要を提供します。

私は現在、いくつかのベーカリーグッズの単一のアクティブな注文を持っています。

私の注文はまだ処理中です。後でそれに戻ります。

とりあえず、ペットアベニューから猫用のおもちゃやアクセサリーを買いたいです。

私はApple Payでチェックアウトすることを選択します。

支払いを承認した直後に、ウォレットで注文を追跡する通知が届きます。

その通知とやり取りすると、現在のステータスを確認できる注文の詳細が表示されます。

配送情報や追跡情報、注文したラインアイテムのリストなど、注文状況を見ることができます。

さらに以下では、ペットアベニューに連絡し、支払い情報を確認し、ペットアベニューのアプリに戻るための複数のオプションがあります。

さて、ペットアベニューが着信注文の処理が本当に速く、彼らはちょうど私のアイテムを出荷したと想像してください。

ペットアベニューが私の注文を出荷するとすぐに、彼らは利用可能な情報を更新しました。

ステータスが「オン・ザ・ウェイ」に変更され、配達予定日は6月10日です。

また、出荷のカスタムメッセージと追跡情報も含まれていました。

ああ、私のベーキンググッズを覚えていますか？

私はちょうど彼らがピックアップの準備ができているという通知を受け取りました。

調べてみましょう。

ピックアップのためにベーカリーグッズを注文しました。

彼らはピックアップの準備ができています、それは素晴らしいです!

Bake My Breath Awayは、私のピックアップウィンドウ、ピックアップの指示、および到着時に提示するバーコードを提供しました。

注文追跡がApple Payでシームレスに機能するのを見てきました。

注文追跡を顧客体験に統合する方法を見てみましょう。

注文追跡を開始するには、まず、開発者アカウントで注文タイプIDを作成する必要があります。

注文タイプIDは、注文情報を提供するエンティティとして組織を識別します。

複数の注文タイプIDを登録できます。たとえば、複数の加盟店に代わって注文情報を提供するなどです。

注文タイプID証明書も作成します。

証明書を使用して、注文パッケージを作成し、注文を更新します。

注文は注文パッケージとして配布されます。

注文パッケージには、注文のすべてのメタデータと情報が含まれています。

出荷、ピックアップ、マルチフルフィルメント注文など、幅広いシナリオを表すことができます。

注文パッケージには、ロゴやラインアイテムの画像などの画像も含まれています。

また、ローカリゼーションを追加して、多様な顧客をサポートすることもできます。

すべての注文パッケージは、その起源を確認するために暗号署名する必要があります。

すべてが整ったら、注文パッケージは配布のために圧縮されます。

このセッションに添付されているサンプル注文パッケージをチェックしてください。

また、注文パッケージの詳細については、開発者ドキュメントを参照してください。

ウォレットに注文を追加すると、Apple Payとシームレスに連携します。

顧客が支払いを承認すると、アプリまたはWebページは支払い情報を受け取り、処理のためにサーバーに送信します。

支払い情報の処理が成功すると、サーバーは注文とメタデータを作成します。

その後、サーバーはその順序の詳細をアプリまたはWebページに返し、結果に含めます。

注文の詳細により、デバイスはサーバーから非同期に注文を要求できます。

その後、サーバーは注文パッケージをデバイスに返します。

サーバーが注文を作成するときは、注文タイプIDの名前空間内で一意の注文IDを割り当てます。

サーバーは安全な認証トークンも生成する必要があります。

これは、注文の詳細の一部である共有秘密です。

デバイスは、注文を要求するときにトークンを使用して自分自身を認証します。

支払い承認結果を返す例を見てみましょう。 支払い承認結果を返します。

顧客が支払いを承認すると、アプリは支払い情報をサーバーに送信し、注文を作成するように要求します。

サーバーの結果が成功を示しているかどうかを確認し、サーバーから返されたエラーを処理します。

サーバーの結果が成功を示している場合は、適切な承認結果で支払いを完了します。

注文の詳細を含む支払い承認結果を返すには、まずサーバーの結果からそれらを抽出します。

次に、Order Ttype ID、Order ID、サーバーへのURL、およびauthenticationTokenを使用してPKPaymentOrderDetailsオブジェクトを作成します。

PKPaymentOrderDetailsオブジェクトをPKPaymentAuthorizationResultの新しいorderDetailsプロパティに割り当てます。

それでおそれ！

ウェブ上の注文の詳細で支払いを完了することもできます。

以前と同様に、サーバーの結果から注文の詳細を抽出します。

次に、支払いを完了するデータに注文の詳細を含めます。

注文を更新できるようにするには、自動更新のサポートを示す注文パッケージを作成します。

注文が追加されると、デバイスは更新のために登録されます。

サーバーは登録に関する情報を保存する必要があります。

後で、サーバーが注文を更新するときは、登録情報を使用して、更新のために登録したデバイスに通知します。

デバイスがプッシュ通知を受信すると、サーバーから再び注文を要求します。

その後、サーバーは更新された注文パッケージをデバイスに返します。

あなたの顧客とあなただけが、彼らが注文したものを知るべきです。

私たちはプライバシーを念頭に置いて注文追跡を設計しました。

注文情報は、デバイスとサーバー間で直接交換されます。

注文がiCloud経由で同期されると、それらはエンドツーエンドで暗号化されます。

可能な限り最高の顧客体験を提供するために、これらの慣行に従ってください。

あなたのアプリをあなたが提供する注文に関連付けてください。

アプリが通知を配信してインストールされている場合は、注文追跡通知を無効にすることができます。

これは、通知の重複を防ぐのに役立ちます。

顧客の好みに関する知識を使用して、関連するローカリゼーションのみを提供します。

注文パッケージのサイズに注意してください。

高価なネットワークコストを削減するために、サイズを小さく保つようにしてください。

注文を更新するときは、更新を登録したデバイスに速やかに通知してください。

ウォレット内の注文は、注文の実際の状態と一致する必要があります。

注文追跡のためにHIGも必ずチェックしてください。

プラットフォームは、注文追跡の統合をはるかに簡単にすることができます。

Shopify、Narvar、Routeが秋までに注文追跡をサポートすることをお知らせします。

今後数ヶ月で注文追跡をサポートするより多くのプラットフォームを探してください。

注文追跡は、顧客の購入後の体験を向上させる素晴らしい方法です。

自動更新により、顧客は注文の状況を常に最新の状態に保つことができます。

私たちはあなたの顧客がこの経験を気に入ると信じており、すぐにあなたと一緒に注文することを楽しみにしています!

さて、私はデビッドに渡します。

David: ありがとう、Lais!

iOS 16のウォレットのIDに追加した新機能について話すのがとても楽しみです。

今年初めにiOS 15.4でWalletでIDを立ち上げました。

サポートされている米国の州のユーザーは、運転免許証または州IDをウォレットに追加できます。

ウォレットのIDは、ユーザーの物理的なIDと同じ発行機関によって発行されます。

米国では、それは彼らの州の自動車省または同等の組織です。

iOS 16では、アプリやアプリクリップがユーザーの年齢や身元を確認するためにウォレットのIDから情報を要求できる新しいAPIを追加しました。

アプリは情報を要求し、ユーザーはリクエストを確認して承認し、アプリは復号化と検証のためにサーバーに応答を送信します。

ユーザーのIDからいくつかのデータ要素を要求できます。

これらには、名前、住所、生年月日、写真（肖像画と呼ばれる）、IDを発行した発行機関、物理的なIDの番号と有効期限、およびIDによって付与された運転特権（ある場合）が含まれます。

IDの非常に一般的なユースケースは、誰かの年齢を確認することです。

物理的なIDで、それは彼らの生年月日を見ることを意味します。

しかし、生年月日は、年齢を確認するためだけに必要以上の情報を明らかにします。

私の年齢をチェックしているなら、実際に私が生まれた正確な日や年、あるいは私が何歳であるかを知る必要はありません。

あなたは私が十分に年をとっているかどうかを知る必要があります。

ウォレットのIDを使用すると、その質問を直接尋ねることができます。

アプリは、ユーザーが特定の年齢を超えているかどうかを示すブールデータ要素を要求することができ、完全な生年月日を確認するよりも、年齢確認を行うためのよりプライバシーを保護する方法を提供します。

アプリがAPIを呼び出すと、シートに要求している情報が表示されます。

また、その情報を保存するかどうか、どのくらいの期間保存するかも表示されます。

これにより、ユーザーはアプリと情報を共有するかどうかについて情報に基づいた決定を下すことができます。

Face IDまたはTouch IDを使用して明示的に承認するまで、情報は共有されません。

受け取った応答には、要求した要素のみが含まれています。

物理的なIDカードのスキャンなど、他の本人確認メカニズムは、IDにあるすべてのものを共有します。

共有を必要なものだけに制限することで、ウォレットのIDはユーザーのプライバシーをより保護し、サーバー上で安全に保つために必要な機密情報の量を減らします。

応答はIDの発行機関によって署名され、応答の情報が本物であることを簡単に確認できます。

発行機関はIDを作成しますが、APIを呼び出す時点では関与していないことに注意してください。

彼らは、ユーザーが自分の情報を共有するとき、または誰と共有するかを学習しません。

APIを使用するには、開発者アカウントから資格をリクエストする必要があります。

その後、マーチャントIDと暗号化証明書を設定する必要があります。

このプロセスは、Apple Payでアプリ内支払いを設定するのと非常によく似ています。

IDと証明書の使い方については、もう少し詳しくお話しします。

とりあえず、検証フローについて話しましょう。

高レベルでは、4つのステップで構成されています。

まず、アプリはPassKitフレームワークでAPIを呼び出し、要求する情報を指定します。

その後、システムはユーザーにリクエストを承認するよう促すシートを表示します。

そうすると、アプリは暗号化された応答を受け取ります。

その後、アプリは復号化と検証のためにその応答をサーバーに渡します。

まず、PassKitでAPIを使用する方法について話しましょう。

アプリがSwiftUIを使用している場合は、VerifyIdentityWithWalletButton SwiftUIビューを使用する必要があります。

これにより、押されたときに本人確認フローをトリガーするボタンが表示されます。

「Apple Payで支払う」ボタンや「ウォレットにパスを追加」ボタンと同様に、「ウォレットで身元を確認する」ボタンは、APIを使用してアプリ間で使い慣れた一貫した体験を提供します。

4つの異なるラベルから選択して、ユースケースに合ったボタンを表示できます。

利用可能なスペースに応じて、シングルラインバージョンとマルチラインバージョンを自動的に切り替えます。

ボタンを作成するときは、要求する情報と返される方法を説明するPKIdentityRequestオブジェクトを指定する必要があります。

それを作成する方法を見てみましょう。 では、作成方法を見てみましょう。

まず、探しているデータ要素を記述するPKIdentityDrivers LicenseDescriptorを作成します。

addElementsメソッドを使用して、要求する要素と、それらを保存するかどうかを指定します。

addElementsメソッドを複数回呼び出して、保存する意図が異なる要素の異なるセットを指定できます。

この例では、私はそれを2回呼んでいます。

まず、保存されないage(atLeast:要素)を追加します。

次に、addElementsメソッドを再度呼び出して、ユーザーの givenName、familyName、およびポートレートを要求します。これらはすべて最大30日間保存できます。

その後、記述子はPKIdentityRequestに入ります。

次のステップは、使用するmerchantIdentifierを指定することです。

merchantIdentifierは、API応答が暗号化される暗号化証明書を示します。

開発者アカウントを使用して、merchantIdentifierとその暗号化証明書の両方を設定します。

最後に、APIから受信した応答に関連付けられるノンスを指定する必要があります。

応答のリプレイを防ぎ、特定のユーザーセッションにバインドするために使用される重要なセキュリティ機能です。

ノンスをどのように管理するかは、あなた自身のセキュリティ要件に基づいて、あなた次第です。

多くの場合、それはあなたのサーバーから来ています。なぜなら、後で、あなたのサーバーはノンスが有効であることを強制する責任を負うからです。

これらのプロパティをすべて設定すると、PKIdentityRequestがあります。

では、ボタンに戻りましょう。

本人確認が利用可能な場合、ボタンがアプリに表示され、タップするとリクエストで本人確認フローが開始されます。

本人確認が利用できない場合は、代わりに指定したフォールバックビューが表示されます。

たとえば、このiPhoneのウォレットにIDがない場合に発生します。

フォールバックビューを使用して、身元を確認する他の方法を提供できます。

本人確認が利用可能で、ユーザーがボタンをタップしたと仮定しましょう。

その後、システムは、要求した要素とそれらを保存する意図を含む、要求を含むシートを表示します。

ユーザーは、Face IDまたはTouch IDでリクエストを承認するか、承認せずにシートを閉じることができます。

その後、コードはリクエストの結果を含む結果オブジェクトを受け取ります。

リクエストが承認された場合、成功結果が表示されます。

これには、暗号化された応答を含むPKIdentityDocumentオブジェクトが付属しており、アプリは復号化と検証のためにサーバーに送信します。

リクエストが成功しなかった場合、失敗結果が表示されます。

失敗の最も一般的な原因は、リクエストが承認されなかったことです。その場合、キャンセルされたエラーが表示されます。

それは、APIのSwiftUIバージョンであるVerifyIdentityWithWalletButtonでした。

本人確認フローを起動し、ウォレットのIDから情報を要求するボタンを表示するために使用します。

アプリでSwiftUIを使用していない場合は、PKIdentityButtonとPKIdentityAuthorization Controllerクラスを使用して同じことを達成することもできます。

さて、今、あなたは情報を要求し、ユーザーは要求を承認し、アプリは暗号化された応答をサーバーに送信しました。

それでは、サーバーがその応答を復号化して検証するために何をする必要があるかについて話しましょう。

このトピックについては表面をざっと見るだけなので、詳細については開発者のドキュメントを確認してください。

応答形式はいくつかの国際標準を使用しているので、それらにも精通することを強くお勧めします。

受信する応答データは、CBORでエンコードされた暗号化エンベロープに入っています。

CBORは、RFC 8949で定義されているデータ形式です。

JSONに似ていますが、バイナリデータを使用してオブジェクトをエンコードします。

暗号化エンベロープには、暗号化されたデータ自体とともに、復号化プロセスに必要なメタデータが含まれています。

データは、RFC 9180で定義された暗号化スキームであるHPKEを使用して暗号化されます。

サーバーは秘密鍵を使用してこのデータを復号化します。

復号化されると、mdoc応答オブジェクトを取得します。

mdoc応答は、モバイル運転免許証と州IDのISO規格であるISO 18013パート5で定義されています。

Mdocレスポンスオブジェクトには、要求したデータ要素が含まれています。

また、応答が本物であることを確認するためにサーバーが検証する必要がある多くのセキュリティ機能も含まれています。

サーバーは復号化と検証自体を実行することに注意してください。

Appleのサーバーも発行機関のサーバーも関与していません。

復号化と応答の検証について話す前に、セッションのトランスクリプトについて話す必要があります。

これは、応答ペイロードを特定のアプリからの特定の要求にバインドするCBOR構造です。

サーバーはこの構造を構築し、復号化と検証の両方で使用する必要があります。

セッションのトランスクリプトには、PKIdentityRequestで以前に使用したのと同じノンスIDとマーチャントID、開発者チームのチームID、暗号化証明書の公開鍵のSHA256ハッシュが含まれています。

セッショントランスクリプトを作成するとき、サーバーは使用している入力がすべて有効であることを確認する必要があります。

つまり、ノンスはすでに使用されるべきではなく、現在のユーザーに関連付けられている必要があります。

他の値は、開発者アカウントで期待される値と一致する必要があります。

では、暗号化されたデータの復号化について話しましょう。

作成したばかりのセッショントランスクリプトと、暗号化エンベロープのメタデータが必要です。

秘密鍵も必要です。

これは、開発者アカウントで以前に設定した証明書に対応する秘密鍵です。

ユーザー情報の機密性を保護するために、秘密鍵が非公開であることを確認する必要があります。

サーバーに安全に保存し、アプリに含めないでください。

秘密鍵が侵害された場合は、すぐに開発者アカウントの証明書を取り消してください。

暗号化されたデータを復号化した後、2つの暗号署名と要求したデータ要素を含むmdoc応答オブジェクトを受け取ります。

データ要素を使用する前に、mdocレスポンスで両方の署名を確認する必要があります。

まず、発行者の署名を確認する必要があります。

これは、ユーザーIDの発行機関からの署名です。

この署名をチェックすることで、応答のデータが実際の発行機関からのものであり、改ざんされていないことを確認します。

署名が有効であるだけでなく、信頼できる発行者証明書によって署名されていることを確認する必要があります。

ウォレットのIDで使用される発行者証明書の詳細については、ドキュメントをご覧ください。

次に、デバイスの署名を確認する必要があります。

これは、ユーザーのiPhoneのSecure Elementのキーによって作成された署名です。

あなたが受け取った応答は、発行機関が最初にIDを発行したのと同じiPhoneから来たことを証明しています。

ここでは、発行者の署名でカバーされている情報とともに、セッションのトランスクリプトを再度使用する必要があります。

最後に、要求したデータ要素を使用する準備が整いました。

最初に発行者とデバイスの署名を確認せずにこれらの要素を使用するべきではありません。そうしないと、受信したデータが本物かどうかわからないからです。

そして、これらの手順がすべて完了すれば、完了です!

アプリは情報を要求し、サーバーは応答を復号化して検証しました。

ウォレットにIDがない場合は、実装をテストする方法を疑問に思うかもしれません。

私たちはあなたがそれを行うのを助けるためにいくつかのメカニズムを提供しました。

まず、APIがモックレスポンスを返すiOSシミュレータでテストできます。

この応答は実際の応答に似ていますが、実際の署名が欠けています。

同様に、そのiPhoneのウォレットにIDがなくても、テストプロファイルを使用して実際のiPhoneで模擬応答を受け取ることができます。

これを行う方法の詳細については、ドキュメントを参照してください。

サーバーは、これらの模擬応答のいずれかを実際の応答のように扱うべきではないことに注意してください。

サーバーの実装を支援するために、ドキュメントには応答の例と、復号化と検証に必要なものがすべて含まれています。

そして、それがiOS 16のウォレットのIDで本人確認を行う方法です。

アプリでAPIを使用する方法、サーバーで応答を処理する方法、実装をテストする方法について説明しました。

Lais: 今年は、WalletとApple Payに多くの素晴らしい新機能を導入しました。

これらには、マルチマーチャント支払い、自動支払いのサポートの改善、注文追跡、本人確認が含まれます。

詳細については、開発者ドキュメントをご覧ください。

David: 見てくれてありがとう、そして素晴らしいWWDCを！

♪