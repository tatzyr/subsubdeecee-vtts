10105

♪ ♪

こんにちは、私の名前はイーです。

こんにちは、私の名前はドミニクです。

そして、私たちはGPUソフトウェアエンジニアです。

今日、ドミニクと私は、レイトレーシングアプリケーションのパフォーマンスを最大化するために、今年Metal Ray Tracing APIに追加したパフォーマンスの強化と機能について話します。

レイトレーシングアプリケーションは、シーンの周りに跳ね返る個々の光線をシミュレートします。

これは、フォトリアリスティックな反射、影、グローバルイルミネーションなどを生成するために、ゲームやオフラインレンダリングで使用されます。

これには多くの光線をシミュレートする必要があるため、これらのアプリケーションではパフォーマンスが不可欠です。

幸いなことに、MetalにはすべてのAppleデバイスに最適化されたレイトレーシングのサポートが組み込まれています。

メタルでレイトレーシングがどのように機能するかを簡単に見てみましょう。

メタルレイトレーシングAPIは、コンピューティング関数やフラグメント関数などのシェーダー関数内から利用できます。

私たちは、シーンに放出されるいくつかの光線を生成することから始めます。

次に、インターセクターオブジェクトを作成し、それを使用して、光線とシーン内のジオメトリの交差をチェックします。

少し後で、交差点検索を高速化するために今年追加した新機能のいくつかについて説明します。

このプロセスは、シーンのジオメトリも表す加速構造と呼ばれる特別なデータ構造に依存します。

また、今日は加速構造に焦点を当てたいくつかの新機能とパフォーマンスの改善についても話します。

インターセクターは、各レイヒットのプリミティブを記述する交差結果オブジェクトを返します。

交差結果は、出力画像に書き込む色を生成するために使用されます。

また、プロセスを再び通過する追加の光線を生成するためにも使用できます。

このプロセスは、シーンの周りで跳ね返る光をシミュレートしたいのと同じくらい何度でも繰り返すことができます。

メタルレイトレーシングAPIの基本についてもっと知りたい場合は、以前のWWDCセッションを確認することをお勧めします。

WWDC20でメタルレイトレーシングAPIを初めて導入し、昨年はモーションブラーのサポートを含む新機能を導入しました。

今日は3つのことを話します。私は3つのことを話します

まず、アプリケーションのレイトレーシングのパフォーマンスを向上させることができる新機能について説明します。

次に、アクセラレーション構造APIに追加した改善点と機能について説明します。

最後に、ドミニクはレイトレーシング用のGPUツールの改善について教えてくれます。

今年は、レイトレーシングのパフォーマンスを向上させるか、コードを簡素化することを目的とした3つの新機能を追加しました。

これらは、プリミティブデータ、交差関数テーブルからバッファを取得する機能、および間接コマンドバッファからのレイトレーシングのサポートです。

プリミティブごとのデータから始めましょう。

アプリケーションには、通常、頂点の色、法線、テクスチャ座標など、シーン内のプリミティブに関連付けられたデータがあります。

今年は、各プリミティブの少量のデータをアクセラレーション構造に直接保存する機能を追加しました。

このデータは、より少ないメモリ間接とキャッシュミスでアクセスでき、パフォーマンスが向上します。

これにより、プリミティブに関連するデータを検索するために通常必要となる複雑な補助データ構造を保存する必要性も減少します。

例を見てみましょう。 例を見てみましょう。

アルファテストは、三角形の数を増やすことなく、透明なジオメトリに複雑さを加えるために使用される技術です。

この手法では、三角形にマッピングされたテクスチャのアルファチャネルを使用して、光線が三角形に当たるべきか、さらに続けるべきかを判断します。

これを実現するには、三角形が光線に当たったときにカスタム交差関数を呼び出すようにインターセクターを設定する必要があります。

究極の目標は、三角形に関連付けられたテクスチャからサンプリングし、アルファ値がレイがプリミティブを続行できるかどうかをテストすることです。

そこに行くには、テクスチャオブジェクトとUV座標の2つの情報が必要です。

アルファテストの典型的な実装では、この情報を取得するには、メタルデバイスメモリ内のいくつかの中間バッファにアクセスする必要があります。

まず、プリミティブに関連するテクスチャを何らかの材料構造に保存します。

いくつかの材料がバッファーに詰め込まれます。

かなり大きく、多くのプリミティブがある可能性があるため、すべてのプリミティブの材料構造を保存することは現実的ではありません。

代わりに、各プリミティブのマテリアルIDのみをバッファに保存し、それらを使用してマテリアルを検索します。

次に、UVを計算するには、別のバッファから各頂点のUVをロードし、それらを補間する必要があります。

最後に、インスタンス化されたジオメトリを使用しているとします。

各インスタンスに独自のマテリアルとUVマッピングを持つことを望むかもしれません。

それをサポートするために、インスタンスデータバッファにUVおよびマテリアルIDバッファへのポインタを保存し、関数にさらに別のレベルの間接を追加します。

このアプローチでは、かなり複雑なバッファ設定を維持する必要があり、必要なデータにたどり着くために多くの間接層が含まれます。

これはまた、パフォーマンスに悪影響を及ぼすキャッシュミスにつながる可能性があります。

この図を実装するために必要なコードを見てみましょう。

次に、プリミティブごとのデータを使用して段階的に簡素化する方法を紹介します。

これは、アルファテスト交差関数の元の実装です。

この関数は、レイがアルファテスト済みの三角形に当たったときに呼び出されます。

この関数は、メモリからインスタンスデータをロードすることから始まります。

これは、インスタンスで使用されるUVおよびマテリアルバッファへのポインタを含むバッファです。

次に、関数はUVバッファからUV座標をロードし、それらを補間します。

これは別のメモリ負荷です。

次に、関数は別のバッファからマテリアルインデックスをロードします。

そして最後に、関数は材料をロードし、対応するテクスチャをサンプリングします。

この時点で、関数は必要なアルファ値を持ち、しきい値と比較することができます。

さて、プリミティブごとのデータを使用して、このコードを簡素化し、パフォーマンスを向上させる方法を紹介します。

複数の間接層を持つ複雑なバッファ設定を使用する代わりに、交差関数が各プリミティブに必要なデータのみをアクセラレーション構造に直接保存できます。

この例では、各プリミティブのテクスチャとUV座標を含む構造体を作成できます。

加速度構造を構築するときにこのデータを提供し、交差関数は、レイがプリミティブに当たったときにそのデータへのポインタを受け取るだけです。

プリミティブデータに好きなものを保存できますが、サイズを小さくしておくと、最高のパフォーマンスを達成するのに役立ちます。

交差関数への入力から始めます。

それらすべてにアクセスできることは、実装に関して多くの柔軟性を提供しますが、GPUのレジスタ使用量を増やすこともできます。

プリミティブごとのデータでは、すべてのバッファではなく、プリミティブデータポインタにアクセスするだけで済みます。

これは、加速構造に直接保存するデータです。

この場合、各プリミティブには独自のテクスチャオブジェクトと、すべての頂点のUVがあります。

次に、グローバルマテリアルバッファとインスタンスデータバッファからの負荷です。

あなたはそれらのどちらも必要ないでしょう。

代わりに、プリミティブごとのデータポインタから1つのロードを行うことができます。

これは、この機能に必要な唯一のデバイスメモリアクセスです。

次はUVです。

インスタンスデータから取得したポインタを逆参照する代わりに、プリミティブごとのデータ構造に埋め込まれたデータに簡単にアクセスできます。

コードの変更は微妙ですが、追加のメモリ負荷が関与しないため、パフォーマンスにとって重要です。

最後に、材料の特性があります。

必要な素材の唯一の部分はテクスチャであるため、プリミティブのテクスチャをプリミティブごとのデータ構造に直接エンコードできます。

これは、マテリアルとマテリアルインデックスバッファにアクセスする必要がなくなことを意味します。

追加のメモリ逆参照の費用を支払うことなく、単にテクスチャを直接使用できます。

これは、プリミティブごとのデータを使用する際の交差コードのシンプルさです。

すべての高価なメモリアクセスは、プリミティブデータポインタからの1つのロードに置き換えられます。

その上、コードははるかにシンプルでわかりやすいです。

次に、プリミティブデータを加速度構造に保存する方法を紹介します。

交差関数からアクセスする前に、これを行う必要があります。

加速度構造ジオメトリ記述子にいくつかのフィールドを設定する必要があります。

まず、すべてのデータが保存されているMetalバッファを設定します。

次に、各プリミティブに保存されるデータのサイズを指定します。

データがバッファにしっかりと格納されていない場合、またはバッファの先頭で開始しない場合は、ストライドとオフセットを指定することもできます。

それ以外の場合、これらの値はデフォルトで0なので、設定する必要はありません。

交差関数でプリミティブごとのデータを使用する方法をすでに見てきました。

それは単にポインタとして関数に渡されます。

しかし、それだけではありません。必要な場所でこのデータにアクセスできます。

これには、インターセクターによって返された最終的な交差結果が含まれます。

また、交差クエリを使用している場合、プリミティブデータは候補とコミットされた交差点の両方でも利用できます。

これは、交差テストに加えて、シェーディングにプリミティブデータを使用できることを意味します。

プリミティブごとのデータは、メモリアクセスと間接の数を減らすことで、交差コードとシェーディングコードの両方のパフォーマンスを向上させることができます。

実際、独自のテストアプリケーションの1つで、プリミティブごとのデータを使用すると、パフォーマンスが10%から16%向上することがわかりました。

あなたがそれを試してみて、パフォーマンスとコード品質でどのような改善が得られるかを見るのが待ちきれません。

今年は、レイトレーシングカーネルを簡素化するために、Metalシェーディング言語に別の便利な機能を追加しました。

アプリケーションは、多くの場合、交差関数とメインレイトレーシングカーネルの両方に同じバインディングセットを渡します。

たとえば、レイトレーシングサンプルコードは、交差関数を使用して球をレンダリングします。

この交差関数は、各球に関する情報を含むリソースバッファにアクセスします。

このバッファを交差関数に渡すために、アプリはバッファを交差関数テーブルにバインドします。

ただし、メインのレイトレーシングカーネルもリソースバッファへのアクセスを必要とするため、アプリはバッファもそこにバインドします。

今年は、メタルシェーディング言語を使用すると、交差関数テーブルにバインドされたバッファにアクセスできます。

この新機能を使用すると、カーネルのバッファをバインドする労力を節約し、代わりに交差関数テーブルから直接アクセスできます。

これを行うには、交差関数テーブルでget_bufferメソッドを呼び出して、ポインタタイプを指定できます。

機能タイプによって、目に見える機能テーブルにアクセスすることもできます。

間接コマンドバッファを使用すると、GPU上で独立してGPUをエンコードし、GPU駆動パイプラインの基本的な要素を表すことができます。

間接コマンドバッファとGPU駆動型レンダリングの詳細については、WWDC 2019の「Modern rendering with Metal」セッションを確認することをお勧めします。

間接コマンドバッファでレイトレーシングサポートを有効にするのは簡単です。

記述子にsupportRayTracingフラグを設定するだけです。

間接コマンドバッファは、ディスパッチグラフィックスと計算関数をバッファするので、通常どおりこれらの関数からレイトレーシングを使用できます。

これは、アプリケーションのレイトレーシングのパフォーマンスを向上させるために、今年追加したすべての新機能の概要です。

次に、加速度構造について話しましょう。

いくつかのパフォーマンス改善を実施し、加速構造の構築に焦点を当てた機能を追加しました。

それらが何に使われているのかをまとめてみましょう。

加速構造は、レイトレーシングプロセスを加速するデータ構造です。

彼らは空間を再帰的に分割することによってこれを行うので、どの三角形が光線と交差する可能性が高いかをすばやく見つけることができます。

複雑なシーンの構築をサポートするために、Metalはプリミティブとインスタンスの加速構造の2種類の加速構造をサポートしています。

個々のジオメトリは、原始的な加速度構造を使用して表現されます。

それらは、平面や立方体のような単純なもの、または球や三角形のメッシュのようなより複雑なものでもかまいます。

インスタンスアクセラレーション構造を使用して、より複雑なシーンを作成できます。

インスタンス加速構造は、原始的な加速構造のコピーを作成します。

まず、シーン内の各オブジェクトの変換行列を定義します。

次に、変換行列とプリミティブアクセラレーション構造の配列を使用して、インスタンスアクセラレーション構造を構築します。

それが、加速構造を使用して静的シーンを構築する方法です。

次に、ゲームのような動的アプリケーションが加速度構造をどのように使用するかを見てみましょう。

最初から始めましょう。最初にゲームを起動したり、新しいレベルをロードしたりするときに行う必要があるタスクがいくつかあります。

これには、モデルやテクスチャの読み込みなどの通常のタスクが含まれます。

レイトレーシングでは、使用されるすべてのモデルのプリミティブアクセラレーション構造を構築する必要があります。

メインレンダリングループの時間を節約するために、ロード時にできるだけ多くのプリミティブアクセラレーション構造を構築することをお勧めします。

インスタンスアクセラレーション構造を使用して、必要に応じてこれらのオブジェクトをシーンに追加または削除できます。

アプリの読み込みが完了すると、メインループに入ります。

すべてのフレームは、ラスタライズ、レイトレーシング、後処理の組み合わせを使用してシーンをレンダリングします。

しかし、ゲームは非常にダイナミックであるため、おそらくいくつかの加速構造を更新する必要があります。

これには、通常、スキンキャラクターなどの一握りの変形またはアニメーションモデルの再装備が含まれます。

既存の加速構造の再取り付けは、完全な再構築よりもはるかに高速であるため、このような場合に使用することをお勧めします。

また、インスタンスアクセラレーション構造を完全に再構築する必要があります。

これは、オブジェクトが最後のフレームからシーンに追加または削除されたか、大幅に移動した可能性があるため、必要です。

この場合、インスタンスの加速構造が1つしかなく、通常は最大数千のオブジェクトしか含まれていないため、完全な再構築を行うことは問題ありません。

今年は、これらすべてのケースのパフォーマンスを改善しました。

まず、加速構造の構築は、Apple Siliconで最大2.3倍高速になりました。

第二に、再装着も最大38%高速です。

これは、ロード時間とフレームあたりのオーバーヘッドの両方が削減されることを意味します。

しかし、それはさらに良くなります。

一部のアプリケーションは、数百または数千の小さな原始的な加速構造を構築します。

これらの小さなビルドは、GPUを埋めるのに十分な作業を個別に行わないため、長期間にわたってGPUの使用率が低くなります。

したがって、Apple Siliconでは、可能な限り複数のビルドが自動的に並行して実行されるようになりました。

これにより、並行して実行すると、ビルドが最大2.8倍高速になります。

これにより、負荷時間がさらに短縮されます。

そして、これはビルドだけでなく、圧縮や再取り付けを含むすべての加速構造操作に適用されるため、フレームあたりのオーバーヘッドも削減されます。

この最適化の恩恵を受けるために、従う必要があるガイドラインがいくつかあります。

これは、加速度構造の配列を構築する例です。

それらを並行して構築するには、多くのビルドで同じ加速構造コマンドエンコーダを使用することを確認する必要があります。

さらに、同じスクラッチバッファを使用するビルドは並行して実行できません。

したがって、ビルドごとに同じスクラッチバッファを使用するのではなく、スクラッチバッファの小さなプールをループしていることを確認する必要があります。

これらはすべて、加速構造を構築するために行ったパフォーマンスの改善です。

また、加速構造の構築をより簡単かつ効率的にするために、3つの新機能を追加しました。

これらは、追加の頂点形式、変換行列、およびヒープからの加速度構造の割り当てをサポートしています。

頂点形式から始めましょう。

一般的なパフォーマンスの最適化は、頂点データに量子化または低精度のフォーマットを使用することであり、その結果、メモリ使用量が減少します。

今年は、幅広い頂点フォーマットから加速構造を構築できます。

これには、半精度浮動小数点形式、平面幾何学用の2つのコンポーネント頂点形式、およびすべての通常の正規化された整数形式が含まれます。

以前は、加速度構造には3つのコンポーネント、全精度浮動小数点頂点データが必要でした。

この例では、アプリケーションは半精度の頂点形式で頂点データを持っています。

加速構造を構築するためだけに、このデータを解凍して一時的なバッファにコピーする必要があります。

新しい頂点フォーマット機能により、アクセラレーション構造ビルドは、サポートされている任意の形式で頂点データを消費できるようになり、一時コピーを作成する必要がなくなりました。

頂点形式の設定はこれ以上ないほど簡単です。

必要なのは、ジオメトリ記述子にプロパティを設定することだけです。

次に、変換行列について話しましょう。

この機能は、新しい頂点形式を補完するため、加速構造を構築する前に頂点データを事前に変換できます。

たとえば、それらを使用して、正規化された形式で保存された複雑なメッシュを解凍したい場合があります。

このシーンでレッサーパンダのモデルを考えてみましょう。

圧縮されたフォーマットの1つを使用するようにジオメトリを正規化するには、メッシュを取り、その境界を計算し、それらを0から1の範囲に拡大縮小します。

その後、正規化された整数頂点フォーマットの1つを使用してメッシュを保存し、ディスクとメモリで占有するスペースを減らすことができます。

実行時に、各頂点を最終位置までスケーリングしてオフセットする行列を提供します。

そのマトリックスを適用すると、元のモデルが取得されます。

それでは、変換行列を渡す加速度構造を設定する方法を見てみましょう。

変換バッファを作成することから始めます。

これを行う1つの方法は、スケールとオフセット変換行列を含むMTLPackedFloat4x3オブジェクトを作成することです。

次に、マトリックスを保持するのに十分な大きさのメタルバッファを作成します。

そして最後に、マトリックスをバッファにコピーします。

次に、加速度構造を設定します。

まず、三角形のジオメトリ記述子を作成します。

次に、変換マトリックスバッファを指定します。

そして最後にバッファオフセット。

変換マトリックスを設定するために必要なのはそれだけです。

これらのマトリックスは、単純な加速度構造を組み合わせてレイトレーシング性能を向上させるためにも使用できます。

サンプルシーンを見てみましょう。

ここでは、箱と球体はすべて比較的単純なメッシュです。

これは、シーンの前面でこのグループの加速構造を最適化する機会を提供します。

インスタンスの加速構造に焦点を当てると、光線が当たるインスタンスごとにオーバーヘッドがあります。

光線を変換し、インスタンスから原始的な加速構造に切り替えるにはコストがかかります。

これは、重複するインスタンスでより頻繁に発生します。

インスタンス数を減らすために、ボックスと球の両方を含む単一のプリミティブアクセラレーション構造を生成できます。

これを行うには、各オブジェクトのジオメトリ記述子を作成し、それぞれに独自の変換行列があります。

結果として得られるプリミティブ加速構造は、インスタンス加速構造の単一のインスタンスであり、ボックスと球が含まれています。

これにより、より優れた加速構造が実行されるはずです。

これをコードで設定する方法を見てみましょう。

球面ジオメトリを定義する記述子から始めます。

次に、プリミティブアクセラレーション構造の頂点バッファ、インデックスバッファ、その他のプロパティを通常どおり設定します。

違いは、球のコピーに使用される変換行列を含む変換バッファも指定することです。

ボックスには、頂点とインデックスバッファを共有する複数のジオメトリ記述子があります。

コピーごとに異なる変換バッファを指定するだけです。

最後に、プリミティブ加速度構造の記述子を作成するときは、すべてのジオメトリ記述子を追加します。

これにより、アイデンティティ変換でシーンにインスタンス化できる原始的な加速構造になります。

この原始的な加速構造は、別々の加速構造よりも構築に時間がかかり、交差するのが速くなります。

最後に、加速構造のヒープ割り当ては、最も要求された機能の1つです。

この機能により、加速度構造の割り当てをより詳細に制御できるようになりました。

また、割り当て間でヒープメモリを再利用することができ、高価なバッファ割り当てを回避できます。

ヒープは、インスタンスアクセラレーション構造を使用する際のuseResource:メソッドへの呼び出しを減らすことで、パフォーマンスの向上にも役立ちます。

例のシーンに戻ると、インスタンス加速構造は原始的な加速構造を間接的に参照します。

これは、コマンドエンコーダでインスタンスアクセラレーション構造を使用するたびに、各プリミティブアクセラレーション構造に対してuseResource:メソッドを呼び出す必要があることを意味します。

大規模なシーンの場合、インスタンスアクセラレーション構造を使用するたびに、useResource:に何千もの呼び出しが必要になる場合があります。

useResource:呼び出しが非常に多いことを知っているので、useResources:を呼び出してAPI呼び出しの数を減らすことができますが、それでも加速構造の配列を維持する必要があり、Metalはまだ配列をループする必要があります。

代わりに、これらのプリミティブな加速度構造をすべて同じヒープから割り当てることができます。

インスタンス加速構造を使用する場合は、useHeap:メソッドを1回呼び出して、すべてのプリミティブ加速構造を参照できます。

useResource:の呼び出しをuseHeap:への単一の呼び出しに置き換えるだけで、1つのアプリケーションで小さなパフォーマンス改善が見られました。

ヒープから加速度構造を割り当てる方法を見てみましょう。

加速度構造記述子を入力として取るヒープ上のメソッドを呼び出すことで、加速度構造を直接割り当てることができます。

記述子を使用して割り当てていない場合、Metalデバイスはヒープから加速度構造を割り当てるためのサイズとアライメントの要件を決定します。

記述子または加速度構造サイズを提供することで、金属デバイスからこの情報を取得できます。

最終的なサイズが決まったら、ヒープから加速度構造を割り当てることができます。

ヒープを使用する際に覚えておくべきことがいくつかあります。

まず、useHeapを呼び出すことを忘れないでください。レイトレーシングパスの期間中、ヒープ内のすべての加速構造を常駐させます。

第二に、デフォルトでは、Metalはヒープから割り当てたリソースを追跡しません。

リソースハザードトラッキングをオプトインすることも、独自の同期を手動で管理することもできます。

MTLFencesを使用してコマンドエンコーダ間で同期し、MTLEventsを使用してコマンドバッファ間で同期できます。

これらは、今年のメタルレイトレーシングAPIの新機能とパフォーマンスの向上です。

次に、ドミニクは、レイトレーシングアプリケーションを開発する際の生産性を高めるXcodeのメタルツールの改善について話します。

ドミニク：ありがとう、イー。

Xcode 14のメタルツールには多くの機能強化がありますが、ここでは、レイトレーシングアプリケーションを開発する際に特に有用ないくつかを強調したいと思います。メタルデバッガから始めて、アクセラレーション構造ビューア、シェーダープロファイラ、シェーダーデバッガーの改善について説明します。

次に、ランタイムシェーダー検証で切り上げます。

まず、加速構造ビューアを見てみましょう。 加速度構造ビューアを見てみましょう。

メタルデバッガの加速構造ビューアを使用すると、加速構造を構成するすべてのメッシュのすべてのジオメトリとインスタンスを詳細に検査できます。

Xcode 14は、プリミティブまたはインスタンス化されたモーションによる加速構造のデバッグと、プリミティブごとのデータのインスペクタでプリミティブを視覚化するための新しいハイライトモードをサポートするようになりました。

彼らが実際に行動しているのを見てみましょう。

モーションで加速構造を使用している場合は、異なる時点で加速構造を表示するためのスクラバーが下部バーにあります。

スクラバーの右側には「再生」ボタンがあります。

それを使用して、アニメーションをループで前後に再生できます。

では、加速度構造の個々のプリミティブを検査する方法をお見せしましょう。

これは、新しいプリミティブデータAPIを使用している場合に特に便利です。

そして、このためだけに新しいハイライトモードがあります。

プリミティブハイライトモードでは、すべてのプリミティブデータにアクセスできます...

また、詳細な検査のために特定のプリミティブを選択することができます。

左側のサイドバーでは、データ行の横に矢印があります。

矢印をクリックすると、プリミティブに対応するデータを表示するポップオーバーが表示されます。

加速構造ビューアへのこれらの追加により、各プリミティブまで、加速構造を構成するすべてのコンポーネントに完全にアクセスできます。

次に、シェーダープロファイラーの改善について話しましょう。

シェーダープロファイラは、シェーダーのパフォーマンスに関する洞察を提供し、パイプラインごとの実行タイミングコストを提供し、Apple GPUでは、ソースレベルでより粒度を提供し、命令カテゴリに分散された行ごとの実行コストを表示します。

Xcode 14では、プロファイリングGPUキャプチャが更新され、交差関数、可視関数、および動的ライブラリがサポートされました。

ここには、交差関数を使用したレイトレーシングカーネルがあります。

交差関数内で行ごとのプロファイリング結果を表示できるようになりました。

これには、コストに寄与する指導カテゴリの内訳が含まれます。

可視関数のプロファイリングも同じように機能します。

同様に、リンクされた動的ライブラリのシェーダーコードの詳細なプロファイリング情報が利用可能になりました。

これらの追加により、各コード行まで、パイプラインのパフォーマンスの完全な内訳が整います。

シェーダーデバッガに進みます。

シェーダーデバッガは、シェーダーコードの正確性をデバッグするためのユニークで非常に生産的なワークフローを提供します。

シェーダープロファイラと同様に、リンクされた関数と動的ライブラリのデバッグを可能にするサポートも拡張しました。

ここでは、可視関数テーブルを介して渡されたリンクされた可視関数を呼び出すレイトレーシングカーネルがあります。

これで、カーネルの実行を目に見える機能コードまで追跡して、コードが期待どおりに動作することを確認できます。

繰り返しになりますが、動的ライブラリのデバッグにも同じことが当てはまります。

また、パイプラインにリンクされている実行された動的ライブラリに出入りすることもできます。

これらの追加により、パイプライン内のリンクされた関数とライブラリにわたるシェーダーの実行の全体像がわかります。

さて、シェーダーデバッガをキャプチャして飛び込む前に、実行時にシェーダー検証を有効にすることをお勧めします。

シェーダー検証は、GPUのランタイムエラーを診断し、アウトオブバウンドメモリアクセス、ヌルテクスチャ読み取りなどの問題をキャッチするのに最適な方法です。

Xcodeでシェーダー検証を有効にするには、「スキームの編集」ダイアログに移動し、「実行」アクションを選択し、「診断」タブで「シェーダー検証」チェックボックスをオンにするだけです。

そして、あなたはすべて行く準備ができています。

Metal 3では、スタックオーバーフロー検出を追加しました。これは、未定義の動作につながる問題をすばやく見つけるのに役立ちます。

メタルシェーダーのファンクションスタックとスタックオーバーフローの問題について簡単に詳しく説明します。

コールスタックは、Metalがシェーダー関数で使用されるローカルデータの値を格納するデバイスメモリ内の領域です。

呼び出された関数がコンパイル時に不明な場合、Metalはスタックに必要なメモリ量を推定するのにあなたの助けを必要としています。

コンパイル時に不明な関数の呼び出しの例は、レイトレーシング交差関数である可能性があります。

カスタム交差関数を使用している場合は、最大コールスタックの深さを1に設定して、スペースを割り当てる必要があります。

これはデフォルト値なので、これ以上必要なことは何もありません。

ただし、関数テーブルを使用して可視関数を呼び出す場合、これはコンパイル時に未知の関数呼び出しの別の例です。

この例のように、交差関数からこのような呼び出しを実行すると、呼び出しスタックは2つのレベルの深さになります。

もう1つの例は、動的ライブラリを呼び出し、関数ポインタを使用してローカル関数を呼び出すことです。

この例では、コールスタックには4つのレベルがあり、シェーダーがコンパイルされたときに解決できないさまざまなタイプの関数へのネストされた呼び出しがあります。

適切な量のメモリを割り当てるようにMetalを適切に設定するには、最大コールスタック深度4を自分で指定する必要があります。

覚えておくべき重要なことは、最大コールスタック深度の値がプログラムに対して低すぎると、スタックオーバーフローが発生し、未定義の動作が発生する可能性があるということです。

しかし、Shader Validationを有効にして実行している場合、そのような状況は早期に捕捉され、スタックオーバーフローが発生した場所に関する情報がXcodeで表示されます。

その後、シェーダーコードを修正したり、パイプライン記述子で最大コールスタックの深さを調整したりできます。

Xcode 14のメタルツールに対するこれらの新しい改善はすべて、レイトレーシングアプリケーションのパフォーマンスと正確性について、さらに完全な全体像と洞察を得ることができます。

デバッグとプロファイリングのためのメタルツールを最大限に活用する方法の詳細については、これらの他のセッションをチェックしてください。このセッションは、アプリケーションのメタルレイトレーシングパフォーマンスを最大化することに関するものでした。

プリミティブデータなどの新機能を使用して、より多くのパフォーマンスを絞り出し、コードを簡素化する方法について話しました。

また、建物の加速構造をこれまで以上に迅速かつ便利にする最適化技術と機能についても説明しました。

最後に、開発中に深い洞察を提供するXcode 14のメタルツールのすべての新しい機能強化を取り上げました。

見てくれてありがとう。