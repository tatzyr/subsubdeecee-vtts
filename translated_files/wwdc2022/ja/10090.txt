10090

- こんにちは、TextKitとテキストビューの新機能へようこそ!

私はDonna Tomで、TextKitのエンジニアです。

iOS 15とmacOS Montereyでは、パフォーマンス、正確性、安全性が向上した強力な新しいテキストエンジンであるTextKit 2を導入しました。

TextKit 2のビューポートベースのレイアウトアーキテクチャは、特にコンテンツが大きいドキュメントに対して、高性能なテキストレイアウトを提供します。

TextKit 2は、グリフでの作業の不要な複雑さを取り除くことで、国際的な視聴者により良いテキスト体験を提供し、OpenTypeや可変フォントなどの最新のフォント技術を完全にサポートしています。

また、テキストレイアウトを制御するために高レベルのオブジェクトを操作することに焦点を当てたTextKit 2は、テキストのレイアウトを簡単にカスタマイズできるため、より少ないコードでよりクールなものを構築できます。

今後、TextKit 2エンジンは、Appleのすべてのプラットフォームでテキストレイアウトとレンダリングの基盤を形成します。

将来のパフォーマンスの向上、アップデート、改善はすべてTextKit 2エンジンに焦点を当てます。

TextKit 2にアップデートすることで、アプリはこれらの改善のメリットを得ることができます。

TextKit2の詳細な紹介については、Meet TextKit2のビデオをご覧ください。

そのビデオでは、基本と、TextKit 2を使用して独自のテキストレイアウトコンポーネントを構築する方法について説明します。

対照的に、このビデオでは、TextKit 2の最新の進歩と、TextKit 2バックのテキストビューを最大限に活用する方法について説明します。

そうです、私はテキストビュー、複数形と言いました。なぜなら、iOS 16とmacOS Venturaの時点で、UIKitとAppKitのすべてのテキストコントロールは、UITextViewを含むTextKit 2を使用しているからです。

そのため、システム全体のレイアウトとレンダリングにTextKit 2を使用しています。

すべてのアプリができるだけ早くTextKit 2に移行することが重要であり、移行を容易にするために多くのツールを追加しました。

多くのアプリでは、これはゼロコード遷移になる可能性があります。

そして、これはテキストビューに特別な変更を加えないアプリにも当てはまることを期待しています。

それについては後でもう少し話します。

しかし、まず、先ほど述べたツールのいくつかを含め、TextKit 2の新機能について述べることから始めます。

その後、テキストビューのTextKit 1互換モードの詳細を深く掘り下げます。

最後に、コードをTextKit 2に移行する準備をする際に使用できる近代化戦略について話し合います。

だから、最初はTextKit 2の新機能です。

TextKit 2は、iOS 15でUIKitに初めて登場し、UITextFieldがそれを使用するようにアップグレードされました。

iOS 16では、UIKitからTextKit 2への移行が完了し、UITextViewを含むすべてのテキストコントロールがデフォルトでTextKit 2を使用しています。

ほとんどのテキストビューは、TextKit 2に自動的にオプトインされ、採用はゼロになります。

テキストビューがオプトインされない可能性がある状況はいくつかありますが、このビデオの互換性セグメントで説明します。

そして、それはAppKitと同様の話です。

TextKit 2は、macOS Big SurでAppKitに初めて登場しました。

macOS Montereyでは、NSTextFieldはデフォルトで使用するようにアップグレードされ、オプトインすることでNSTextViewで利用可能になりました。

macOS Venturaでは、すべてのテキストコントロールがデフォルトでTextKit 2を使用します。

UITextViewと同様に、ほとんどのNSTextViewはTextKit 2に自動的にオプトインし、あなたの側の採用をゼロに要求します。

NSTextViewの薄いラッパーであるTextEditは、macOS VenturaのどこでもTextKit 2を使用します。

TextEditは、macOS Big Sur以来、プレーンテキストモードでTextKit 2を使用しています。

macOS Venturaでは、リッチテキストモードはTextKit 2も使用します。

TextKit 2は新しい標準であるため、UITextViewとNSTextViewの両方に便利なコンストラクタを追加しました。

これらの新しいコンストラクタを使用して、初期化時にどのテキストエンジンを使用するかを選択します。

TextKit 2 を使用するテキスト ビューを作成するには、新しいコンストラクタを使用し、「UsingTextLayoutManager」パラメータに true を渡します。

テキストビューが互換性のためにTextKit 1を使用する必要がある場合は、代わりに「false」を渡してください。

また、Interface Builderで作成されたテキストビューの新しいテキストレイアウトオプションがあります。

この新しいオプションを使用すると、インスタンスごとに使用するレイアウトシステムを制御できます。

デフォルト設定はシステムのデフォルトで、TextKit 2です。

TextKit 2またはTextKit 1を明示的に使用することもできます。

TextKit 2は、単純でないテキストコンテナをサポートするようになりました。

単純でないテキストコンテナには、穴や隙間がある場合があります。

これにより、テキストは画像やその他のインラインコンテンツをラップすることができます。

単純でないテキスト コンテナを作成するには、NSTextContainer の exclusionPaths プロパティを使用して、テキストをレイアウトすべきでない領域を定義します。

これを行う方法の例については、このビデオに関連付けられているリソースからTextKitAndTextViewサンプルコードをチェックしてください。

関連する例は「除外パス」タブにあります。

TextKit 2の改行エンジンを強化して、正当な段落に対してより均一な改行を選択しました。

これは、テキストの長い段落で気付きやすい微妙な変更です。

ここでは、同じ領域にレイアウトされた同じテキストの2つのバージョンがあります。

引き伸ばされた行と、従来の改行を伴う大きなインターワード間隔に注目してください。

新しい偶数ラインブレークで起こっていることははるかに少ないです。

これにより、テキストが読みやすくなり、TextKit 2で無料で入手できます。

養子縁組は必要ありません。

そして最後に、すべてのプラットフォームのTextKit 2にテキストリストのサポートを追加しました。

テキストリストを使用すると、テキストビューに表示するための番号付きまたは箇条書きのリストをプログラムで作成できます。

TextKit 2は、TextKit 1と同様に、NSTextListを使用してテキストリストを表します。

NSTextListは以前はAppKitでのみ利用可能でしたが、iOS 16ではUIKitでも利用可能です。

NSTextListをNSmutableParagraphStyleと一緒に使用して、テキストストレージ内の段落を表示リストとしてフォーマットするように指定します。

テキストビューは、テキストストレージからこれらの属性をピックアップし、段落コンテンツをリストのように再フォーマットする責任があります。

NSTextList自体は新しいものではありませんが、新しいTextKit 2の追加がいくつかあります。

リストにはネストされたアイテムを持つことができるので、それらをツリー構造として表すのは当然です。

TextKit 2では、NSTextElementを強化し、子要素と親要素にアクセスするためのプロパティを持つツリーとして構造化をサポートしました。

そして、NSTextListElementという新しい要素サブクラスを追加しました。

コンテンツマネージャーがテキストコンテンツ内のNSTextListに出くわすと、リスト内の項目を表すNSTextListElementsが生成されます。

テキストリストの作成方法とアイテムの追加方法の詳細については、TextKitAndTextViewのサンプルコードを参照してください。

関連する例は「リスト」タブで見つけることができます。

また、サンプルコードを探索している間は、TextKit 2でテキストアタッチメントビュープロバイダーAPIを使用する方法を示すテキストアタッチメントの例をお見逃しなく。

これらのAPIを使用すると、UIまたはNSViewをテキスト添付ファイルとして使用でき、イベントは添付ファイルビューで直接処理できます。

これにより、テキスト添付ファイルによるイベント処理がはるかに簡単になり、TextKit 2でのみ可能です。

よし、TextKit 2の新機能については、それだけです。

次に、TextKit 1互換モードの詳細に入ります。

TextKit 2はTextKit 1の設計から根本的に逸脱しているため、TextKit 2の完全な採用は、TextKit 1アーキテクチャに多額の投資をしているアプリには時間がかかる可能性があることを理解しています。

移行が行われるまで、これらのアプリが引き続きうまく機能することを望んでいます。そのため、UITextViewとNSTextViewに特別なTextKit 1互換モードを追加しました。

NSLayoutManager APIを明示的に呼び出すと、テキストビューはNSTextLayoutManagerをNSLayoutManagerに置き換え、TextKit 1を使用するように再構成します。

これは、テキストビューがテーブルや印刷時など、TextKit 2でまだサポートされていない属性に遭遇した場合にも発生する可能性があります。

UITextViewでTextKit 1への予期しないランタイムフォールバックに遭遇した場合は、スイッチに関するメッセージ警告のログを確認してください。

シンボルアンダースコアUITextViewEnablingCompatibilityModeにブレークポイントを設定して、スタックトレースやその他の有用なデバッグ情報をキャプチャします。

NSTextViewの場合、willSwitchまたはdidSwitchToNSLayoutManager通知を購読することで、予期しないランタイムフォールバックに関する詳細情報を取得できます。

TextKit 1に戻る必要がある場合は、プログラムで初期化されたテキストビューで初期化時にオプトアウトするのが最善です。

独自のテキストコンテナとTextKit 1レイアウトマネージャーを使用して、これを行います。

もう1つのオプションは、新しい便利なコンストラクタを使用してTextKit 1のテキストビューを初期化し、パラメータとしてfalseを渡すことです。

これにより、テキストビューはTextKit 1を使用します。

そして3番目のオプションは、Interface Builderを使用して、テキストビューで新しいテキストレイアウトオプションをTextKit 1に設定することです。

ここに注意すべきことがあります。

初期化中または初期化後にテキストコンテナのレイアウトマネージャを交換する場合、テキストビューは設計どおりにTextKit 1にフォールバックします。

初期化中にすべてのTextKit 2オブジェクトを作成し、すぐに捨てるだけでは非効率的です。

タイミングに応じて、潜在的なユーザーの副作用もあります。

入力中に発生すると、テキストビューはフォーカスを失い、入力を中断する可能性があり、再開するにはテキストビューを再度選択する必要があります。

初期化時にテキストビューアウトをオプトアウトすることで、これを回避してください。

互換性モードについてすべて知っているので、アプリをモダナイズしてTextKit 2を採用することで、それを完全に回避する方法について話す時が来ました。

そして、あなたに覚えておいてほしい本当に重要なことが1つあります。

テキストビューごとにレイアウトマネージャーは1つだけです。

テキストビューは、NSTextLayoutManagerとNSLayoutManagerの両方を同時に持つことはできません。

テキストビューがTextKit 1に切り替わると、自動で戻る方法はありません。

レイアウトシステムを切り替えるプロセスは高価であり、切り替え時に存在していたUI状態が失われます。

したがって、最適なパフォーマンスと使いやすさのために、システムはテキストビューをTextKit 1からTextKit 2に戻すことはありません。

それは一方通行の操作です。

これは、互換性モードを避けることが本当に重要であることを意味します。

そして、テキストビューが互換性モードに入る理由はいくつかあります。

テキストビューが互換性モードに入る一番の理由は、テキストビューのlayoutManagerプロパティにアクセスすることです。

他の理由はそれほど一般的ではありません。

したがって、重要な戦略は、テキストビューのレイアウトマネージャープロパティへのアクセスを避けることです。

また、テキストビューのテキストコンテナからレイアウトマネージャにアクセスすることも避けてください。

これらのプロパティの使用についてコードを監査し、それらを削除するか、同等のTextKit 2に置き換えます。

TextKit 2が搭載されていない古いOSバージョンにアプリをデプロイする場合、layoutManagerコードを完全に削除できない場合があります。

その場合は、まずテキストビューのNSTextLayoutManagerを確認する必要があります。

TextKit 2コードをif句に入れ、TextKit 1コードをlayoutManagerアクセスを含むelse句に入れます。

このようにして、TextKit 1コードはTextKit 2が利用できない場合にのみ実行され、layoutManagerクエリはTextKit 1への意図しないフォールバックを引き起こしません。

このアドバイスをすべて守っても、システムからTextKit 1への予期しないフォールバックに遭遇した場合、それは私たちの問題ですので、フィードバックアシスタントで問題を報告してください。

UIKitのアンダースコアUITextViewEnablingCompatibilityMode、またはAppKitのwillSwitchToNSLayoutManagerNotificationでブレークから取得できるフォールバック時のスタックトレースのキャプチャを含めます。

さて、NSLayoutManagerから始めて、TextKit 1タイプに関連するコードの更新の詳細について説明します。

NSLayoutManagerクエリのコードを監査したら、NSTextLayoutManagerと同等のTextKit 2を把握する必要があります。

一部のレイアウトマネージャーAPIは、TextKit 1と2の間で同様の名前を持ち、置換は簡単です。

ここにいくつかの例があります。

TextKit 1では、NSLayoutManagerでusedRect(for: textContainer)を呼び出すと、テキストコンテナ内のテキストの境界矩形を取得します。

TextKit 2では、NSTextLayoutManagerのagesageBoundsForTextContainerプロパティからこれを取得します。

TextKit 1では、レイアウトではなくレンダリングにのみ影響する属性に「一時的な属性」という名前を使用しました。

TextKit 2では、より正確にそれらを「レンダリング属性」と呼んでいます。

しかし、TextKit 2には直接同等のものを持たないTextKit 1 APIがいくつかあります。

その理由を理解するには、カンナダ語のようなインド文字の多くの単語のグリフマッピングに正しい文字がないことを理解する必要があります。

これらのスクリプトでは、グリフを分割したり、並べ替えたり、再結合したり、削除したりできます。

NSLayoutManagerのグリフベースのAPIは、連続した範囲の文字と連続した範囲のグリフを直接関連付けることができることを前提としていますが、それはすべてのスクリプトに当てはまるわけではありません。

これらのAPIを使用すると、カンナダ語などのスクリプトで書かれたテキストのレイアウトとレンダリングが破損する可能性があります。

そのため、TextKit 2にはグリフAPIはゼロです。

TextKit 1グリフAPIを単一のTextKit 2 APIに置き換えることはできません。

これらのAPIを置き換えるには、別のアプローチが必要です。

グリフベースのコードを更新する方法は次のとおりです。

最初のステップは、使用しているグリフAPIを特定することです。

次に、これらのAPIをどのように使用しているかを見て、高いレベルで何をしようとしているかを定義します。

グリフベースのコードは非常に低レベルであり、高レベルのタスクとは関係のない詳細がたくさんあります。

高レベルのタスクを定義したら、レイアウトフラグメント、行フラグメント、テキスト選択など、TextKit 2で利用可能な構造を調べます。

これらはあなたのタスクを達成するのに役立ちます。

例えば、このTextKit 1のコードを考えてみましょう。

ここで使用されているグリフAPIには、numberOfGlyphsとlineFragmentRect(forGlyphAt: index)の2つがあります。

このTextKit 1コードは、ドキュメント内のすべてのグリフを反復し、行フラグメントのレクトをカウントしています。

高レベルのタスクは、テキストビューでラップされたテキストの行数を数えることです。

このコードは行フラグメント直列で動作するため、使用するTextKit 2構造はNSTextLineFragmentとNSTextLayoutFragmentです。

そして、これはTextKit 2を使用するように書き換えられたコードです。

グリフを反復する代わりに、ドキュメント内のテキストレイアウトフラグメントを列挙し、各レイアウトフラグメント内のすべてのテキスト行フラグメントをカウントするクロージャを提供します。

TextKit 2の独自のコードを更新するときは、その例を覚えておいてください。

次に、ギアをシフトし、NSRangeに基づくコードの更新について話し合います。

TextKit 1はNSRangeを使用してテキストコンテンツにインデックスを作成し、NSRangeは文字列への線形インデックスです。

「Hello TextKit 2!」というテキストについて感嘆符、「TextKit 2感嘆符」を表すNSRangeは、6文字目から始まり、10文字の長さであるため、場所6と長さ10です。

この線形モデルは理解しやすく、文字列へのインデックス作成に最適です。

しかし、線形モデルは、文字列よりも構造を持つコンテンツへのインデックス作成には機能しません。

ここに例があります。

HTMLドキュメントはツリー構造として表され、各タグはツリー内のノードです。

私たちのハローTextKit 2なら!テキストはHTMLドキュメントの一部であり、NSRangeがテキストが3レベルの深さでネストされたスパンタグ内にあることを教えてくれる方法はありません。

線形モデルは、その情報を保存するのに十分な表現力がないため、このようなネストされた構造にインデックスを作成するために使用することはできません。

これが、TextKit 2がテキストコンテンツの範囲を表すための新しいタイプを追加した理由です。

NSTextLocationは、テキストコンテンツ内の単一の場所を表すオブジェクトです。

NSTextRangeは、開始位置と終了位置で構成されています。

終了位置は範囲から除外されます。

これらの新しいタイプは、場所をDOMノードと文字オフセットとして定義することで、このHTMLドキュメントのネストされた構造を表すことができます。

NSTextLocationはプロトコルであるため、NSTextLocationプロトコルメソッドを実装している限り、任意のカスタムオブジェクトは場所になることができます。

これは、モデルで構造化データをサポートするさまざまなタイプのバッキングストアと連携するための重要なインフラストラクチャです。

しかし、テキストビューは、この構造を持たないNSAttributedStringバッキングストア上に構築されており、あなたを含む多くのアプリを壊さずにそれを変更することはできません。

したがって、selectedRangeやscrollRangeToVisibleなどのテキストビューAPIを使用する場合は、NSRangeを引き続き使用します。

また、TextKit 2レイアウトマネージャーまたはコンテンツマネージャーと通信する場合は、NSRangeとNSTextRangeの間で変換する必要があります。

テキストビューのNSRangeをNSTextRangeに変換するには、位置を属性文字列の整数インデックスとして定義します。

NSTextRangeの開始場所としてNSRangeの場所を使用してください。

NSTextRangeの終了位置として、NSRangeの場所と長さを使用してください。

概念的には、それがNSRangeからNSTextRangeにマッピングする方法です。

実際には、NSTextLocationsはオブジェクトでなければならないため、コードは少し違って見えます。

場所を計算するには、コンテンツマネージャーを通過する必要があります。

開始場所については、ドキュメントの開始位置をコンテンツマネージャーに尋ね、NSRangeの場所で相殺します。

次に、開始位置をNSRangeの長さでオフセットして、終了位置を取得します。

他の方向に進むには、テキストコンテンツマネージャーを使用して2つの異なるオフセットを取得します。

NSRangeの場所は、ドキュメントの先頭とNSTextRangeの場所の間のオフセットです。

そして、NSRangeの長さは、NSTextRangeの開始位置と終了位置の間のオフセットです。

UITextViewsとUITextFieldsは、UITextPositionと範囲を使用するUITextInputプロトコルに準拠しています。

ほとんどの場合、UITextViewまたはUITextFieldを使用する場合、UITextRangeをNSTextRangeに直接変換する必要はありません。

ただし、その場合は、整数オフセットを2つの範囲タイプの中間として使用してください。

一方、UITextInputでカスタムビューを使用している場合は、ビューで使用されるUITextPositionとUITextRangeサブクラスを直接制御できます。

UITextPositionサブクラスをNSTextLocationに準拠させ、必要なメソッドを実装し、サブクラスを使用してNSTextRangesを直接作成できます。

最後に、両方のビューのコンテンツが似ている場合でも、異なるビュー間でUITextPositionオブジェクトを再利用しないようにするためのリマインダーです。

UITextPositionは、作成に使用されたビューに対してのみ有効です。

さて、今、あなたはあなたのコードを近代化するために自由に使える多くの戦略を持っています。

これらの戦略を適用すると、アプリはTextKit 2のメリットを享受する準備が整います。

そして、それがTextKitとテキストビューの新機能です。

私はTextKit 2の多くの大きな改善をカバーし、古いOSバージョンとの互換性を維持しながらアプリを更新するためのいくつかの戦略を共有しました。

今すぐアプリでTextKit 2を使用して、新しい改善点を最大限に活用してください。

テキストビューをチェックして、意図せずにTextKit 1にフォールバックしていないことを確認してください。

そして最後に、近代化戦略を採用して、TextKit 2でアプリを入手してください。

TextKit 2とテキストビューで作成するものを読むのが待ちきれません。

見てくれてありがとう!