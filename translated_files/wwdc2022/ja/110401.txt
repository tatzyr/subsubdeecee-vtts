110401

♪インストゥルメンタルヒップホップ音楽♪

こんにちは、私の名前はボリスです。「Swiftパッケージプラグインの作成」セッションへようこそ。

ライブラリをソースコードとして配布するための簡単なアプローチを提供するために、Xcode 11でSwiftパッケージのサポートを導入しました。

Xcode 14では、Swiftパッケージプラグインを使用して、ソースコードの生成やリリースタスクの自動化など、開発ワークフローにコンポーネントを構造化して共有するための同じ素晴らしい方法をもたらしたいと考えています。

まず、講演の簡単な概要。

プラグインの基本を学んだ後、デモで最初のカスタムコマンドプラグインを構築します。

次に、プラグインの作成に関する詳細を見て、その後、さらなるデモでビルド内とビルド前のコマンドプラグインの両方を構築します。

パッケージプラグインは、パッケージマニフェストと同様に、PackagePlugin APIを使用するSwiftコードです。

プラグインは、明確に定義された拡張ポイントを通じて、XcodeまたはSwift Package Managerの機能を拡張できます。

パッケージプラグインはどのように機能しますか?

Xcodeはプラグインをコンパイルして実行し、利用可能な実行可能ファイルと入力ファイルに関する情報を使用して、必要に応じて実行するためにXcodeに通信するコマンドを作成できます。

パッケージプラグインは、ソースコードやリソースファイルを生成するなど、ビルド前またはビルド中に実行されるカスタムビルドタスクを貢献できます。

また、SwiftPMのコマンドラインインターフェイスにカスタムコマンドを追加したり、メニュー項目をXcodeに追加することもできます。

プラグインの基本の詳細については、まず「Meet swift package plugins」を見ることをお勧めします。パッケージを完全に初めての場合は、WWDC19セッション「Swiftパッケージの作成」を見ることができます。

最初のカスタムコマンドプラグインの構築を見てみましょう。

私はSwiftオープンソースのツールサポートコアパッケージに取り組んでおり、プロジェクトへのすべての貢献者をリストするテキストファイルを追加したいと思います。

また、パッケージのGit履歴から必要に応じて再生したいです。

以前は、これを行うためにシェルスクリプトやメイクファイルを書いたかもしれませんが、Xcodeを離れることなくファイルを再生成できるように、カスタムコマンドプラグインを作成したいと思います。

まず、プラグインのディレクトリ構造を作成する必要があります。

パッケージのコンテキストメニューを開き、新しいフォルダを選択して、既存のソースとテストに似たプラグインと呼ばれるトップレベルのフォルダを作成します。

次に、「GenerateContributors」と呼ばれるプラグインターゲット用の別のネストされたフォルダを作成します。

そして、その中で新しいファイルを作成し、それを「plugin.swift」と呼びます。

次に、そこで新しいターゲットを宣言するために、パッケージマニフェストにいくつかの変更を加える必要があります。

しかし、まず、プラグインはそのバージョン以降のみ利用可能であるため、パッケージのツールバージョンを5.6にバンプする必要があります。

次に、プラグインターゲットを挿入できます。

ここで新しいマニフェストAPIを見てみましょう。

ソースモジュールのターゲットと同様に、プラグインフォルダ内のフォルダに対応するプラグインターゲットを作成しています。

フォルダの命名に関連する名前と、Xcodeのメニュー項目の両方を取得します。

機能を指定するので、どのタイプの拡張ポイントを使用するかを指定します。

この場合、カスタムコマンドを作成しています。

インテントは、SwiftPMコマンドラインの動詞とプラグインが何をするかの説明を定義することができ、最後に、プラグインが必要とする権限を宣言することができます。

この場合、パッケージのルートに新しいファイルを書きたいので、そのディレクトリに書き込む権限が必要です。

理由文字列は、OS自体で権限がどのように機能するかと同様に、許可を付与するかどうかを知るために、プラグインのユーザーに表示されます。

プラグインを宣言したので、実際に実装するために戻ってみましょう。

プラグインはGitにシェルアウトしてコミット履歴を取得します。

外部Gitコマンドの標準出力から履歴を読み取り、結果を解析し、最後にテキストファイルに書き出します。

先ほど作成したプラグインソースファイルを開き、PackagePluginをインポートします。

これはPackageDescriptionとよくよく合う組み込みモジュールで、プラグインの実装に使用できるAPIにアクセスできます。

構造体GenerateContributorsを定義し、CommandPluginに準拠します。

プロトコルを実装するための不足しているスタブを取得するために、ここで修正を受け入れます。

また、プラグイン実行可能ファイルの主な機能となるため、構造体は@mainとしてマークする必要があります。

performCommandはコマンドのエントリポイントであり、2つの引数を受け取ります。コンテキストは、解決されたパッケージグラフや、実行されているコンテキストに関するその他の情報、および引数にアクセスできます。

カスタムコマンドはユーザーによって呼び出されるため、引数の形式で入力を提供できます。

簡単なコマンドを作成しているので、現時点では実際にユーザーにオプションを提供しません。

コミット履歴に関する情報を取得するためにGitにシェルアウトしたいので、プロセスAPIを使用したいので、Foundationをインポートしています。

次に、プロセスインスタンスを定義し、いくつかの書式設定引数でGitログを実行するように設定します。

プロセス出力をキャプチャするためのパイプを作成する必要があります。

その後、私たちはそれを実行し、それが終了するまで待つことができます。

プロセスが完了したら、パイプからすべてのデータを読み取り、すべてのgitログ出力を持つ文字列に変換します。

文字列操作を実行して、出力を重複のないリストにトリミングし、最後に「CONTRIBUTORS.txt」というファイルに書き込むことができます。カスタムコマンドはパッケージのルートディレクトリで実行されるため、そこにファイルを保存します。

さて、プロジェクトナビゲーターでパッケージを保存して右クリックすると、コンテキストメニューにコマンドの新しいエントリが表示されます。

実行しよう！

次のダイアログでは、プラグインの入力となるパッケージまたはターゲットと引数を選択できますが、プラグインはこれらのオプションに反応しないため、[実行] をクリックします。

次に、先ほどマニフェストで定義したように、許可を求められます。

プラグインを自分で書いたばかりなので、先に進んで実行することができますが、信頼できるプラグインにのみ追加の許可を与えることを確認する必要があります。

実行後、CONTRIBUTORS.txtファイルがプロジェクトナビゲーターに表示されます。

それでは、最初のプラグインでXcodeを拡張した後、プラグインがどのように機能し、プラグインを作成する際に何に目を向けるべきかをもう少し深く掘り下げてみましょう。

パッケージプラグインは、パッケージの評価と同様に、サンドボックスで実行されます。

プラグイン自身の作業ディレクトリ以外の一時的な場所へのネットワークアクセスと書き込みは禁止されています。

カスタムコマンドは、先に示したように、パッケージのルートディレクトリに書き込むことをオプションで宣言できます。

既存のサードパーティツールをラップする場合は、生成されたファイルが書き込まれる場所を設定するなど、サンドボックスモデルに限定する方法を検討する必要があるかもしれません。

序文でさまざまな種類のプラグインについて話しましたが、問題がカスタムコマンドとビルドツールのどちらがよりよく解決されるかは明らかであるはずですが、ビルドツールプラグインの構造を見てみましょう。

これらのプラグインを使用すると、ビルド中に実行する実行可能ファイルの説明を提供し、ビルド中の適切なタイミングで作業をスケジュールするのに役立つ入力と出力を指定することで、ビルドシステムを拡張できます。

Xcodeプロジェクトで実行スクリプトフェーズを作成している場合は、ここでの基本に精通しているかもしれません。

ビルドツールプラグインには2つの異なるタイプもあります。

ここでの区別要因は、ツールに定義された出力セットがあるかどうかです。

その場合は、出力が入力と比較して古くない場合、ビルドシステムによって自動的に再実行されるビルド内コマンドを作成する必要があります。

明確な出力セットがない場合は、すべてのビルドの開始時に実行されるビルド前のコマンドを作成できます。

このため、ビルド前のコマンドで高価な作業を行うか、ユースケースに適した結果をキャッシュするためのカスタム戦略を考え出すことに注意する必要があります。

2回目のデモでは、作業しているさまざまなツール間で共有したいアイコンをカプセル化する新しいライブラリを作成したいと思います。

始めて、テンプレートから新しいパッケージを作成し、「IconLibrary」と呼びましょう。

そして、すでに持っているいくつかのアイコンアセットをライブラリのターゲットにドラッグします。

また、基本的なSwiftUIビューとプレビューをライブラリに追加しましょう。

まず、必要な最小展開目標をマニフェストに追加する必要があります。

次に、その基本的なビューとプレビューを実際に追加しましょう。

ここでは、以前に引き込んだ資産を使用できます。

ここで文字列を扱う代わりに、これらの画像を参照するタイプセーフな方法があればいいと思います。

これは、アセットカタログを見て、それらに基づいていくつかのSwiftコードを生成するビルド中のコマンドプラグインの素晴らしいユースケースのようです。

Finderのアセットカタログを見て、プラグインに必要な情報を抽出する方法を見つけましょう。

各画像は、アセットの名前を持つ独自の画像セットディレクトリを取得します...

そして、基本的な内容を説明するJSONファイルがあります。

ビルド中のコマンドは、実行する実行可能ファイルの説明と入力と出力を提供するという点で、カスタムコマンドとは少し異なります。

実行可能ファイルは、システム、サードパーティのパッケージによって提供されるか、プラグイン用にオーダーメイドのものを作成することができます。

私たちはここで3番目のアプローチを取りたいです。

プラグインは、ビルドグラフの計算に参加するために、ビルドプロセスの開始時に実行されます。

それに基づいて、実行可能ファイルはビルド実行の一部としてスケジュールされます。

さて、私たちが構築している実行可能ファイルに戻ります。

アセットカタログ内の各画像のコンパイル時定数を指定して、各画像の正しい文字列を記憶する代わりに、Swiftシンボルとしてオートコンプリートできるようにしたいと考えています。

アセットカタログのディレクトリ内容をループして、すべての画像セットを見つけたいです。

各画像セットについて、メタデータを解析して、実際に画像が含まれているかどうかを判断するため、生成されたコードを取得する必要があります。

その後、コードを生成してファイルに書き込むことができます。

これらのファイルをプラグインの出力として宣言したため、プラグインが適用されているターゲットのビルドに自動的に組み込まれます。

それがプラグインと実行可能ファイルの間で通信する方法であるため、議論に対処する方法が必要になります。

最初の引数は、処理しているアセットカタログへのパスであり、2番目の引数は、生成されたコードのプラグインによって提供されるパスになります。

次に、contents.jsonファイルをデコードするためのモデルオブジェクトが必要です。

私たちは、Swiftの組み込みJSONデコードを利用するためにDecodableを使用しています。

私たちが興味を持っている唯一の情報は、画像のリストとそのファイル名です。これは、各ピクセル密度の画像がない可能性があるため、オプションです。

ここでは、文字列を構築するだけで、単純な方法でコードを生成します。

必要なフレームワーク、FoundationとSwiftUIのインポートから始めます。

アセットカタログのディレクトリ内容をループして、次にJSONを解析する必要があるすべての画像セットを見つけたいです。

ファイル名は入力パラメータを使用します。

また、Foundationの「JSONDecoder」APIを使用してデコードします。

私たちが興味を持っている主な情報は、特定の画像セットに定義された画像があるかどうかです。これは、空でないファイル名を持つ少なくとも1つの画像があるかどうかをチェックすることによって判断します。

指定された画像セットに画像がある場合は、パッケージのバンドルからその画像をロードするSwiftUI画像を生成します。

これを行うには、モジュールバンドルから指定された画像をロードする各画像のベース名を持つ文字列を構築します。これは、ビルドシステムがリソースを持つ各パッケージに対して作成するリソースバンドルです。

引数によって与えられたように、生成されたコードをファイルに書き込むことで、実行可能ファイルの作業をまとめることができます。

Xcodeに戻って実行可能ファイルを作成しましょう。

私たちはそれを「AssetConstantsExec」と呼んでいます...

そして、メインファイルを追加します。

今、私たちはパッケージマニフェストでそれを宣言する必要があります。

そして、先ほど説明したコードをメインファイルに追加できます。

コードを生成できる実行可能ファイルができ、プラグインを使用してビルドシステムに持ち込むことができます。

必要なターゲットを追加し、ライブラリターゲットからプラグインの使用法を追加しましょう。

以前と同様に、PackagePluginライブラリをインポートして構造体を作成し、今回はBuildToolプラグインプロトコルに準拠しています。

エントリポイントは似ていますが、ユーザーの引数の代わりに、ここにターゲットを与えています。

これは、プラグインが適用されているターゲットであり、エントリポイントは、指定されたプラグインを使用するターゲットごとに1回呼び出されます。

このプラグインは、例えばバイナリターゲットとは対照的に、実際にソースファイルを運ぶターゲットであるソースモジュールターゲットを特に気にします。

ビルドコマンドの配列を構築するには、ターゲット内のすべてのxcassetバンドルをループします。

ビルドログに表示される表示名の文字列を抽出し、適切な入力パスと出力パスを構築します。

また、プラグインAPIを使用してここで実行可能ファイルを検索し、ビルドコマンドをまとめることもできます。

これで、私たちは再びプロジェクトを構築する準備が整いました。

起こっている新しいビルドステップのビルドログを見ることができます。

プラグインはビルドの開始時にコンパイルされ、実行され、そこから生成されたコマンドをビルドグラフに追加します。

ターゲットを見ると、新しいビルドコマンドが実行されました。

そして最後に、生成されたソースファイルは、Swiftファイルのコンパイルの一部として表示されます。

プレビューに戻りましょう。ここでは、文字列で型付けされた画像構造を新しい定数に置き換えることができます。

また、他の画像名のオートコンプリートも取得します。

これはいいですね。比較的少ないコードで、使い慣れたSwift APIを使用し、Xcodeを離れることなく、ワークフローを改善することができました。

これまでのところ、私たちはすでに取り組んでいたライブラリの一部として、私たち自身の使用のためのプラグインを作ることを検討してきましたが、プラグインのもう一つの強力な属性は、ライブラリと同様に、簡単な方法でそれらを共有できることです。

次のデモでは、Xcodeに同梱されているgenstringsツールを使用して、いくつかのビルド前処理を自動化したいと思います。

このツールは、さらに使用するために、コードからローカライズされた文字列をローカリゼーションディレクトリに抽出します。

それは一般的に役に立つように思えるので、プラグインを別のパッケージにして、独立して共有できるようにしたいと思います。

パッケージのリソースとローカリゼーションについてもっと知りたい場合は、そのトピックに関するWWDC20セッションをお勧めします。

一般的なローカリゼーションの詳細については、WWDC21のSwiftUIアプリのLocalizeをチェックしてください。

このプラグインでは、ローカリゼーション用の出力ディレクトリを計算することから始めます。

指定されたターゲット内のすべてのSwiftまたはObjective-Cソースファイルである入力ファイルを計算し、Xcodeが提供するgenstringsツールを実行するためのプレビルドコマンドを構築します。

ビルド前のコマンドとビルド中のコマンドの最大の違いは、明確に定義された出力セットを宣言しないことです。つまり、これらのコマンドはすべてのビルドで実行されます。

このツールは、ユーザーのソースコードからすべてのローカライズされた文字列を抽出し、それらのすべての文字列をローカリゼーションディレクトリに書き込みます。これは、ユーザーのプロジェクトの実際のローカリゼーション作業の基礎として使用できます。

まず、私はすでにここで足場を作成しました。

パッケージマニフェストでは、以前と同じようにターゲットを追加しますが、プラグイン製品も追加します。

ライブラリ製品と同様に、これは単にプライベートではなく、パッケージのクライアントがプラグインを利用できるようにする方法です。

先ほど話し合ったコードを書くことができます...

プラグインを構築したので、別のサンプルパッケージでテストしたいと思います。

そのために、テンプレートから新しいパッケージを作成しましょう。

ローカライズされた文字列をパッケージに提供するAPIを追加します。

そして、生成されたテストでその使用を追加します。

予想通り、APIが「World」という文字列を返すので、テストは機能します。

プラグインパッケージにパスベースの依存関係を追加しましょう...

そして、ライブラリターゲットへのプラグインの使用。

私たちは今、再び走ることができます...

ビルドログを見ると、ビルドの開始時にプラグインが実行され、生成されたファイルがターゲットに追加されるため、リソースが最初からターゲットの一部であったかのように、リソースバンドルが構築され、リソースアクセサーが生成されます。

それでは、リソースバンドルを実際に使用するようにコードを変更しましょう。

最後に、コードを変更したら...

そして、生成されたバンドルを覗いてみましょう...

私たちはここに反映された変化を見ることができます。

プラグインのテストベッドができたので、テストスイートを具体化し、最終的にプラグインパッケージを他の人と共有することができます。

要約すると、プラグインを使用して開発者ツールを自動化および共有することができ、カスタムコマンドは一般的なタスクを自動化する方法を提供し、ビルドツールを使用してビルドプロセス中にファイルを生成できます。

聞いてくれてありがとう!

♪インストゥルメンタルヒップホップ音楽♪