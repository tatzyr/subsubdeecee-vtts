110371

- こんにちは。私はXcodeチームのデザイナー、ジェイクです。

マルチプラットフォームアプリ開発は、Xcode 14で次のレベルに引き上げられています。

単一のアプリターゲットは、単一の共通のコードベースを維持し、デフォルトで設定を共有し、必要に応じて条件付けする新しい方法を可能にしながら、複数のプラットフォームでさらに多くの目的地をサポートできるようになりました。

まず、マルチプラットフォームアプリのターゲットとは何か、そしてどのケースで最も効果的かについて説明します。

次に、複数の目的地とプラットフォームをサポートするようにプロジェクトを変更し、プロジェクトを更新して新しいプラットフォームで構築して実行します。

サポートされている各プラットフォームでアプリが素晴らしく見えるようにします...

そして最後に、Xcode Cloudをプロジェクトの変更と統合します。

まず、アプリが複数のプラットフォームをサポートできるようにするために、どのテクニックを使いたいかを理解しましょう。

Xcode 14の前に、アプリがiOSとmacOSをサポートしたい場合は、2つの別々のターゲットが必要になります。

これは、プロジェクトが著しく異なるコードベースを必要とする場合、異なるプラットフォーム間で設定をほとんど共有しない場合、または各アプリターゲットが異なる基盤技術に大きく依存している場合に最適です。

それが今日のあなたのプロジェクトにまだ当てはまるなら、あなたの最善の策は、プラットフォームごとに別々のターゲットを使い続けることです。

Xcode 14では、単一のアプリターゲットがiPhone、iPad、Mac、Apple TVなどの多くの目的地のサポートを宣言できます。

これは、共通のコードベースを使用し、必要なときにカスタマイズしながら、すべての目的地でほとんどの設定を共有するアプリに最適です。

Xcode 14でマルチプラットフォームアプリがどのように機能するかを見てみましょう。

ゼロから始める場合、始めるのに最適な方法は、Xcodeで新しいプロジェクトを作成するときに、新しく改良されたマルチプラットフォームアプリテンプレートを使用することです。

マルチプラットフォームアプリテンプレートは、ライフサイクルとインターフェイスにSwiftUIを使用し、iPhone、iPad、Macをサポートするようにデフォルトで設定されたターゲットから始めます。

これは新しいプロジェクトのための素晴らしい構成です。

SwiftUIを使用しているため、各プラットフォームのSDKの完全な機能セットにアクセスでき、各プラットフォームが提供するものを利用する素晴らしい新しいアプリを作成できます。

既存のプロジェクトは、アプリターゲットの複数の宛先のサポートを宣言し、SwiftUIを使用して各プラットフォームのSDKのフルパワーにアクセスすることもできます。

既存のiOSアプリにMacのデスティネーションを追加する方法を見てみましょう。

私はフードトラックアプリを構築してきましたが、iPhoneとiPadでうまく機能します。

私はこのiOSアプリにかなり満足しています、そして今、私はそれをMacに持ち込み、プラットフォームとその機能を取り入れたいです。

私たちのプロジェクトがXcodeでどのように見えるかを見てみましょう。

私のアプリのターゲットを見ると、私のアプリがサポートしているすべての目的地のリストを見ることができます。

あなたは私がすでにMacの目的地を持っていることがわかります - iPad用に設計されています。

これにより、Appleシリコンを搭載したMacコンピュータは、私の未変更のiOSアプリを実行できます。

これはMacのサポートを始めるのに最適な方法ですが、Macのサポートを次のレベルに引き上げたいです。

いわば「Mac用に設計された」体験を追加しましょう。

サポートされている目的地のリストを簡単に編集し、Macの目的地をアプリに追加できます。

Macの目的地にはいくつかのオプションがあります：Mac、Mac Catalyst、およびDesigned for iPad、私のアプリはすでにそれをサポートしているため、最後のものはグレー表示されています。

MacとMac Catalystの選択は、主にどの技術が最も使用に興味があるかに落ち着きます。

私たちのアプリがアプリの中核でUIKitやストーリーボードを多用した場合、Mac Catalystは既存のiPadアプリを互換性のあるMacアプリに変換する素晴らしい方法です。

しかし、私たちのアプリはSwiftUIを使用しているため、「Macオプション」は、私たちのMacアプリを作成するための最良の選択になります。

制限なくmacOS SDKのフルパワーで、箱から出してすぐに素晴らしいMacのルックアンドフィールを手に入れます。

つまり、その柔軟性が必要な場合は、iOSアプリでUIKitを使用し、macOSアプリでAppKitを自由に使用できます。

そのすべてを念頭に置いて、SwiftUIで作業するための最良の選択肢であるMacを選びましょう。

私が選択すると、XcodeはMacサポートのために私のプロジェクトを準備するために必要ないくつかの変更を私に警告します。

この場合、XcodeはMacでサポートされている依存関係とフレームワークのみを含むようにターゲットを更新します。

Xcodeが私のコードを変更しないことに注意することが重要ですので、Macで利用できないAPIを呼び出している場合は、それらの問題を自分で解決する必要があります。

Macのオプションを選択すると、サポートされている目的地のリストに追加されます。

Xcodeで開発しているときに、複数のMacの目的地を持つことは完全に有効です。

これは、「Mac Catalyst」または「Designed for iPad」から完全なMacアプリに移行する場合に特に便利です。

これは、Xcode内で各Mac製品のテストを継続できることを意味します。

そして、私のアプリを開発するとき、私は必ずしも単一の選択肢に制限されているわけではありません。

ただし、ネイティブのMacアプリをApp Storeに公開すると、Designed for iPadアプリは顧客が利用できなくなるため、Xcodeはこの目的地を削除する簡単な方法を提供します。

しかし、ネイティブのMacの経験に満足したら、この目的地を削除することを検討します。

ゼロから始める場合でも、既存のアプリに新しい目的地を追加する場合でも、Xcodeで単一のターゲットを使用すると、デフォルトでコードとビルド設定を共有できます。

アプリの表示名や最小展開バージョンなど、個々の設定をカスタマイズしたい場合があります。

Xcode 14の改良されたターゲットエディタでそれを行う方法を見てみましょう。

多くのアプリのターゲット設定には、その値を条件付ける方法が含まれるようになりました。

サポートされている設定では、プロジェクトの各ビルド設定のデフォルト値を設定できるエディタを表示できます。

追加したカスタムベータ構成と、新しいXcodeプロジェクトに付属する標準のデバッグおよびリリース構成があります。

ベータ構成で構築されたときにアプリに別の表示名を付けたいので、ここで名前を編集できます。

入力すると、Xcodeのアプリの表示名が、表示名が持つことができるすべての可能な値の読み出しに置き換えられていることがわかります。

必要に応じて、条件を追加して、使用されているSDKに基づいて値を指定することもできます。

これにより、Mac用にビルドするときにベータ設定に特定の名前を設定すると言うことができます。

さて、一般タブで行いたい編集は終わったと思います。

その他の変更が必要な場合は、「署名と機能」タブを見てみましょう。 必要な変更はありません。

良いニュースは、自動署名がオンになっているので、余分な手順がないことです。

Macの宛先を追加すると、私に代わってMacに必要な署名証明書とプロビジョニングプロファイルが生成されました。

私のiOSとmacOSの両方のアプリ製品は、デフォルトで同じバンドル識別子を使用しています。これは素晴らしいです。なぜなら、App Storeに公開すると、ユニバーサル購入で利用可能になるからです。

だから、私のiOSアプリを購入する人々は、私のMacアプリも自動的に取得します。

私のアプリは、プッシュ通知などの機能も利用しています。

私のmacOSアプリに適用可能なiOSアプリに使用している機能は、私からの余分な作業なしで適用されます。

それらは単一の資格ファイルにまとめられたりもします。

アプリに複数の目的地のサポートを追加したので、次の目標はそれを構築することです。

特に新しいMacサポートのように、新しいSDKが関与している場合は、新しい目的地のアプリの構築に問題が発生するのが普通です。

では、これらの一般的な問題のいくつかを見てみましょう。

一部のフレームワークは、すべてのプラットフォームで利用できるわけではありません。

利用できないフレームワークをインポートまたはリンクしていないことを確認する必要があります。

新しい宛先のサポートを追加するとき、Xcodeはコードを変更しないので、アプリの設定を条件付けする方法と同様に、SDKに基づいてコードを条件付けする必要があることを忘れないでください。

これはAPIにも当てはまります。

一部の機能は、どのSDKで構築しているかに基づいて利用できないとマークされています。

Swiftは、コードの一部を条件付けして、構築しているSDKで利用可能な機能のみを含める方法を提供します。

Xcodeでは、一部のSDK用にビルドするときに個々のファイルをコンパイルする必要があるかどうかを指定することもできます。

もし私が今プロジェクトを構築したら...

私は何の問題も見当たりません。

それは、iOS SDKを使用するツールバーでまだ目的地が選択されているからです。

macOS SDKに対してビルドするには、リストから「My Mac」を選択する必要があります。

建物は今、いくつかの新しい問題を明らかにし、私たちが予想したように、それらは主に可用性に関連しています。

私のファイルの1つで、Macでは利用できないARKitをインポートしています。

このインポートステートメントを#if canImportでラップして、条件付き化することができます。

これは、フレームワークが利用可能な既知のプラットフォームのリストを管理したくない場合や、単に利用できない場合は含めないでくださいと言う場合に便利です。

しかし、私はまだこのファイル全体でARKitを使用しているので、SDKのファイル全体を条件付きにする方が理にかなっている場合があります。

ターゲットに戻って[ビルドフェーズ]タブに移動すると、ファイルを検索できます。

そして、iOS用にのみコンパイルする必要があると指定してください。

ビルド後、これらの変更を加えると、Xcodeは新しい問題を報告します。Macで利用可能なフレームワークであるSwiftUIには、利用できないとマークされている機能があります。

具体的には、iOSでEditModeを使用して、ユーザーが編集を行い、テーブルとリストのコンテンツを選択できるようにしていますが、macOSではEditModeは存在しません!

ユーザーはすでにMacでコンテンツの行を自由に選択して編集できるので、このコードがiOSでのみ実行されていることを確認しましょう。

私は自分の環境プロパティと、以下のEditModeを使用していた場所を条件付きにすることができます。

さて、このonChange修飾子のように、このプロパティを使用していた場所も条件付けされていることを確認する必要があります。

修飾子全体を「if os」条件でラップできます。

そして最後に、ツールバーのEditButtonビューを使用していますが、これもiOSのみです。

さて、私たちのアプリを実行してみましょう。

ああ！生きてる！私たちのアプリは現在、Mac上で構築され、実行されています!

私たちのアプリが新しいプラットフォームで構築され、実行されているからといって、私たちの仕事が終わったわけではありません。

新しいプラットフォームのユーザーが期待するものに合わせて、アプリ体験を洗練したい場合があります。

また、iOSのみの機能をトリミングすることは、私たちの旅の終わりではありません。

これで、macOS SDKのすべての機能で遊べます。

私のアプリがMacで実行されているのを見たので、新しい文脈では自然に感じられない私のアプリの癖に気づいています。

このグリッドビューのこれらのドーナツは大きすぎるようです!

それは、私たちのグリッドアイテムがタッチ用に設計されたからです。

このような状況は、UI要素のポイントサイズを宣言したり、単一のプラットフォームのみを念頭に置いてコントロールをカスタマイズしたりするときに発生します。

Macでは、はるかに正確なポインティングデバイスを持っているので、ボタンやサムネイルをそれほど大きくする必要はありません。

これは、私たちが構築しているSDKに基づいて変化するように、私たちのプロジェクトの定数を条件付ける素晴らしいケースです。

アプリを他のプラットフォームに持ち込むときは、新しいプラットフォームの期待でこれらの選択肢の多くを再考することが重要です。

構築するSDKに基づいて、別の値を指定することを見てみましょう。

私がよく使うテクニックの1つは、定数を計算されたプロパティにし、「#if os」を使用して返されるものを条件付けることです。

これを計算されたプロパティに変換し、以前は定数だったものを返しましょう...

しかし、iOSでのみその値を返します。

ああ、80はもっと自然なサイズに感じます。

さて、macOS SDKの使用については、SwiftUIには、独自のUI要素をメニューバーに追加できるクールな新機能があります。

アプリのサマリービューがあり、ユーザーがすばやく簡単にアクセスできるようにしたいと思っています。

アプリ宣言に行きましょう。ここで、メニューバーエクストラに新しいシーンを追加できます。

ただし、これはmacOSのみの機能であるため、macOS SDK用に条件付けする必要があります。

構築して実行して見てみましょう。

ああ、かっこいい、私のトラックのアイコンがメニューバーに表示されました。

素晴らしい、今、私のMacユーザーは、メニューバーから直接今日の情報を一目見ることができます。

SwiftUIを使用すると、各プラットフォームの完全なSDKにアクセスでき、その素晴らしい機能を利用することができます。

アプリを他のプラットフォームに持ち込むときは、新しいプラットフォームのコンテキストで作業する際に、多くの過去の選択肢を再考する必要があることが多いことに注意することが重要です。

SwiftUIは、プラットフォームの期待値をAPIに直接焼き込みます。

多くのインターフェイス要素は、各プラットフォームで見栄えのよい自動外観を得るでしょう。

逆に、つまり、コントロールやUIの他の部分を大量にカスタマイズすると、自動スタイリングを失う可能性があるので、UIがどこでも素晴らしく見えることを常に再確認する必要があります。

とはいえ、クールなアプリを構築する際に、ヒューマンインターフェースガイドラインで定められたベストプラクティスに従っていることを確認する必要があります。

アプリのローカル変更に満足したので、アプリ製品をアーカイブしてApp Store Connectにアップロードします。これはXcodeから行うか、Xcode Cloudで自動化することができます。

準備ができたら、TestFlightの内部および外部のテスターとアプリを共有し、App Storeにリリースすることができます。

製品をApp Store Connectにアップロードするには、製品をアーカイブする必要があります。

単一のターゲットを持っているからといって、単一の製品しかないわけではありません。

各プラットフォームをアーカイブし、個別にアップロードする必要があります。

ローカルで構築およびアーカイブする場合は、アーカイブを作成するSDKを持つ宛先を選択する必要があります。

macOSアプリを作成したい場合は、目的地のリストから「My Mac」を選択する必要があります。それ以外の場合は、iOSアプリを作成するためにiOSデバイスを選択します。

宛先を選択したら、「製品アーカイブ」を選択してアーカイブを作成できます。

アーカイブが完了したら、Xcodeのオーガナイザーウィンドウを使用してApp Store Connectにアップロードできます。

Xcode Cloudを使用している場合は、ワークフローにアクションを追加して、製品を構築、テスト、アーカイブすることができます。

ワークフローのアクションのリストでは、各製品を構築、テスト、分析、アーカイブするための新しいアイテムを作成できます。

この場合、私はiOSアプリとmacOSアプリを持っています。

さらに一歩進んで、App Store Connectへのアプリのアップロードを自動化するための展開準備を含めることができ、それらのビルドをすぐに社内のTestFlightチームに送信し、プレスからホットな変更に関するフィードバックを受け取り始めることもできます。

要約すると、Xcode 14は、複数のプラットフォームでさらに多くの目的地をサポートできる合理化されたアプリターゲットで、マルチプラットフォームアプリ開発を次のレベルに引き上げます。

単一のアプリターゲットで、デフォルトで共通のコードベースと共有設定を維持できます。

実証されたように、私たちはニーズに基づいて設定とコードを条件付けすることができ、プラットフォームの期待に最も合うようにアプリをカスタマイズすることができます。

残りはあなた次第です。

今年のXcodeの新機能と改善点の詳細については、「Xcodeの新機能」をご覧ください。

XcodeとSwiftUIの力で、あなたがどんな素晴らしいアイデアに命を吹き込むかを見るのが待ちきれません。