10117

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

ケビン・フェレル:こんにちは、私の名前はケビンで、iOS上のアプリのトランシーバーシステム体験を可能にする新しいPushToTalkフレームワークに取り組んでいるエンジニアです。

その後、同僚のトレバーと一緒に、この新しいフレームワークでアプリの音声コミュニケーションを強化する方法について話します。

まず、PushToTalkフレームワークを紹介し、それがあなたのアプリにどのように適合するかを説明します。

次に、PushToTalk用にアプリを設定する方法について説明します。

その後、トレバーはフレームワークを使用してオーディオを送受信する方法を説明します。

最後に、Trevorは、ユーザーのバッテリー寿命を維持しながら、Push To Talkのユーザーエクスペリエンスを向上させるためのベストプラクティスをまとめます。

新しいPushToTalkフレームワークの主な機能を紹介することから始めます。

PushToTalkフレームワークを使用すると、iOSで新しいクラスのオーディオ通信アプリを構築し、ユーザーにトランシーバースタイルの体験を提供することができます。

Push To Talkアプリは、医療や緊急サービスなど、迅速なコミュニケーションが不可欠な分野で多くの用途があります。

優れたプッシュ・トゥ・トーク体験を提供するために、ユーザーは誰が応答しているかを確認しながら、オーディオ伝送機能にすばやくアクセスする方法が必要です。

同時に、Push To Talkアプリは、ユーザーがアプリの使用中に終日のバッテリー寿命を維持できるように、電力効率が高くなければなりません。

PushToTalkフレームワークは、ユーザーがアプリを直接起動することなく、システム上のどこからでもアクセスできるシステムUIを利用するためのAPIを提供します。

システムUIを使用すると、ユーザーはオーディオ伝送をすばやくアクティブにすることができ、バックグラウンドでアプリを起動して、オーディオを録音してサーバーにストリーミングします。

このシステムは、アプリがサーバーから音声を再生するときに誰が話しているかを示すことで、ユーザーに透明性を提供します。

PushToTalkフレームワークは、新しいオーディオが再生可能になったときにアプリに通知する新しいプッシュ通知タイプを導入することで、これを達成します。

アプリがこの通知を受信すると、バックグラウンドで起動され、オーディオをストリーミングして再生できます。

PushToTalkフレームワークは、既存のエンドツーエンドの通信ソリューションやバックエンドインフラストラクチャと互換性があるように設計されています。

アプリにPush To Talkワークフローをすでに実装している場合は、PushToTalkフレームワークを既存のコードに簡単に統合できるはずです。

このフレームワークにより、アプリは独自のオーディオエンコーディングとストリーミングプロセスを実装して、ユーザー間でオーディオを送信できます。

これにより、オーディオ伝送がアプリによってどのように処理されるかに柔軟性が提供され、他のプラットフォームとの互換性が可能になります。

最後に、多くのPush To Talkアプリは、オーディオの録音と送信をトリガーするためにワイヤレスBluetoothアクセサリに依存しています。

アプリは、CoreBluetoothフレームワークを使用してこれらのアクセサリと引き続き統合でき、PushToTalkでオーディオ録音をトリガーできます。

最初のPush To Talkアプリを構築する場合は、コードの設計を開始する際に、これらの統合の考慮事項を念頭に置いてください。

新しいPushToTalkフレームワークのコードを進める前に、Push To Talkエクスペリエンスがアプリでどのように機能するかを実証したいと思います。

トレバーと私は、PushToTalkがどのように機能するかを示すデモアプリを構築しました。

まず、参加ボタンをタップして、チャンネルと呼ばれるPush To Talkセッションに接続します。

チャンネルに参加すると、チャンネルの他のメンバーにオーディオを送受信できます。

トレバーと数人の同僚が同じチャンネルに参加しているので、一日中コミュニケーションをとることができます。

マイクボタンを使用してアプリから直接オーディオを送信できますが、PushToTalkフレームワークを使用すると、システムのどこからでも送信機能にアクセスできます。

アクティブなPush To Talkチャンネルがある場合、ステータスバーに青い錠剤が表示されます。

そのピルをタップすると、システムUIが表示されます。

システムUIには、私が参加したPush To Talkチャンネルの名前とアプリが提供する画像が表示され、ユーザーがチャンネルをすばやく識別するのに役立ちます。

トークボタンを長押しし、システムのチャイムが私が話し始めることができることを示すのを待つことで、チャンネルにオーディオを送信できます。

ねえ、トレバー。

WWDCのスライドをカバーする準備はできていますか？オーバー。

トレバー・シェリダン：私のデバイスがケビンのメッセージを受信すると、彼の名前と画像を含む通知が表示され、誰からメッセージを受信しているかを透明にしました。

システムUIを起動すると、ケビンのメッセージにすばやく応答したり、やっていることを停止することなくチャンネルを離れることができます。

ケビンを待たせたくないので、今返信します。

ねえ、ケビン。数分で準備できます。

オーバー。

ケビン：PushToTalkシステムUIはロック画面からもアクセスできるため、ユーザーはデバイスのロックを解除することなくメッセージを受信して応答できます。

わかった、またね！オーバー。

PushToTalkの仕組みについて話し合ったので、独自のアプリにフレームワークを統合する方法を確認します。

PushToTalkフレームワークをサポートするために、Xcodeプロジェクトに加える必要がある変更がいくつかあります。

まず、新しいPush To Talkのバックグラウンドモードを追加する必要があります。

これにより、Push To Talkイベントに応答するときにアプリをバックグラウンドで実行できます。

次に、フレームワーク機能を有効にするには、アプリにPush To Talk機能を追加する必要があります。

APNSが受信したオーディオを再生するためにバックグラウンドでアプリをウェイクできるようにするには、プッシュ通知機能が必要です。

最後に、アプリはユーザーに録音許可を要求し、Info.plistファイルにマイク目的の文字列を含める必要があります。

これで、コードの統合を開始する準備が整いました。

Push To Talkワークフローの最初のステップは、チャンネルに参加することです。

チャンネルは、システムへのプッシュ・トゥ・トーク・セッションを表し、説明しています。

あなたのアプリはチャンネルマネージャーを通じてチャンネルと対話します。

チャンネルマネージャーは、アプリがチャンネルに参加し、オーディオの送受信などのアクションを実行するための主要なインターフェイスです。

チャンネルに参加すると、Push To TalkシステムUIが利用可能になり、アプリはチャンネルの生涯を通じて使用できるAPNSデバイストークンを受け取ります。

オーディオの送受信を開始する前に、チャンネルに参加する必要があります。

最初のステップは、クラス初期化子を使用してチャネルマネージャーを作成することです。

この初期化子では、チャネルマネージャーデリゲートとチャネル復元デリゲートを提供する必要があります。

イニシャライザを複数回呼び出すと、同じ共有インスタンスが返されますが、チャネルマネージャーをインスタンス変数に保存することをお勧めします。

ApplicationDelegateのdidFinishLaunchingWithOptionsメソッドで、アプリの起動時にできるだけ早くチャネルマネージャーを初期化することが重要です。

これにより、チャネルマネージャーが迅速に初期化され、既存のチャネルが復元され、バックグラウンドで起動するとプッシュ通知がアプリに配信されます。

今、私たちはチャンネルに参加する準備が整いました。

誰かがアプリからチャンネルに参加するときは、チャンネルを識別するためのUUIDと、システムへのチャンネルを説明する記述子を提供する必要があります。

このチャンネルの生涯を通じてマネージャーとやり取りする際に、同じUUIDが使用されます。

記述子には名前と画像が含まれています。

チャンネルを表すユニークな画像を提供することで、ユーザーがシステムと対話するときにチャンネルを識別しやすくなります。

アプリは、チャンネルマネージャーのrequestJoinメソッドを呼び出すことで、チャンネルに参加します。

アプリがフォアグラウンドで実行されている場合にのみ、チャンネルに参加できることに注意してください。

アプリがチャンネルに参加すると、チャンネルマネージャーデリゲートのdidJoinChannelメソッドが呼び出されます。

このデリゲートメソッドは、アプリがチャンネルに参加したことを示すものです。

さらに、デリゲートのreceivedEphemeralPushTokenメソッドは、このデバイスにPush To Talk通知を送信するために使用できるAPNSプッシュトークンで呼び出されます。

このトークンは、Push To Talkチャンネルの存分の間のみ有効になります。

APNSプッシュトークンは可変長であり、その長さをアプリにハードコードするべきではないことを覚えておいてください。

別のチャンネルがすでにアクティブなときにチャンネルに参加しようとするときなど、チャンネル参加要求が失敗する可能性があります。

これが発生すると、エラーハンドラが呼び出され、エラーは失敗の理由を示します。

ユーザーがチャンネルを離れると、デリゲートのdidLeaveChannelメソッドが呼び出されます。

アプリはプログラムで退去を要求した結果、またはユーザーがシステムUIの「チャンネルを離れる」ボタンをタップした結果、ユーザーはチャンネルを離れることができます。

チャネルマネージャーデリゲートには、関連するLeaveChannelエラー処理メソッドがあり、チャネルを離れる要求が失敗した場合に呼び出されます。

PushToTalkは、終了後、またはデバイスの再起動後にアプリが再起動されるたびに、以前のチャンネルの復元をサポートしています。

システムがこれを達成するためには、システムを更新するためのチャネル記述子を提供する必要があります。

ここには、復元デリゲートでキャッシュされたチャネル記述子を取得するヘルパーメソッドがあります。

システムの応答性を維持するために、できるだけ早くこの方法から戻る必要があり、チャネル記述子を取得するためのネットワーク要求などの長時間実行またはブロックタスクを実行しないでください。

プッシュ・トゥ・トーク・セッションのライフサイクルを通じて、チャンネルに関する情報が変更されるたびに記述子を更新する必要があります。

また、サービスステータスオブジェクトを使用して、ネットワーク接続またはサーバーの可用性の変更についてシステムに通知する必要があります。

ここでは、チャンネルの記述子を更新しています。

チャンネル名や画像を更新する必要があるときはいつでも、このメソッドを呼び出すことができます。

この例では、アプリのサーバーへの接続が再接続状態であることを示すために、システムにアップデートを提供しています。

これにより、システムUIがそれに応じて更新され、サービスステータスが接続または切断されている場合にユーザーがオーディオを送信できなくなります。

接続が再確立されたら、サービスステータスを「準備完了」に更新する必要があります。

それでは、PushToTalkを使用してオーディオを送受信する方法を確認しましょう。

トレバー、APIの残りの部分を歩く準備はできていますか？

オーバー。

トレバー：うん。それらを送ってください。オーバー。

PushToTalkフレームワークの設定方法を見たので、オーディオを送受信する方法を探りましょう。

PushToTalkフレームワークのコア機能は、ユーザーがオーディオをすばやく送信できるようにすることです。

ユーザーは、アプリ内またはシステムPush To Talk UIからオーディオ送信を開始できます。

アプリがCoreBluetoothを介してBluetoothアクセサリをサポートしている場合は、周辺機器の特性の変化に応じてバックグラウンドで送信を開始することもできます。

送信時、PushToTalkフレームワークはデバイスのマイクのロックを解除し、アプリのオーディオセッションをアクティブにして、バックグラウンドでのオーディオ録音を有効にします。

このプロセスを詳細に確認しましょう。

アプリ内から送信を開始するには、requestBeginTransmitting関数を呼び出すことができます。

これは、アプリがフォアグラウンドで実行されているとき、またはBluetooth周辺機器の特性の変化に反応するたびに呼び出すことができます。

システムが送信を開始できない場合、デリゲートのfailedToBeginTransmitting InChannelメソッドが失敗の理由で呼び出されます。

たとえば、ユーザーが進行中の携帯電話通話をアクティブにしている場合、Push To Talkの送信を開始できません。

送信を停止するには、チャネルマネージャーのstopTransmittingメソッドを呼び出します。

ユーザーが送信状態ではない場合など、送信を停止しようとするときの障害を処理するために、チャネルマネージャーデリゲートには、関連するfailedToStopTransmitting InChannelメソッドがあります。

アプリ内から送信を開始する場合でも、ユーザーがシステムUIから開始する場合でも、チャネルマネージャーのデリゲートは「送信開始」コールバックを受け取ります。

送信ソースはメソッドに渡され、送信がシステムUI、プログラマティックAPI、またはハードウェアボタンイベントから開始されたかどうかを示します。

送信が開始されると、システムはアプリのオーディオセッションをアクティブにします。

これは、録音を開始できる信号です。

独自のオーディオセッションを開始または停止すべきではありません。

送信が終了すると、チャネルマネージャーのデリゲートは終了送信とオーディオセッションの無効化イベントを受け取ります。

送信がアクティブな間は、オーディオセッションは、アプリ内で処理する必要がある電話やFaceTime通話など、他のソースによって中断される可能性があることに注意してください。

PushToTalkフレームワークでは、アプリがバックグラウンドで他のユーザーからオーディオを受信して再生することもできます。

このプロセスは、Push To Talkアプリに固有の新しいAppleプッシュ通知タイプに依存しています。

Push To Talkサーバーにユーザーが受信する新しいオーディオがある場合、チャンネルへの参加時に受信したデバイスプッシュトークンを使用して、Push To Talk通知をユーザーに送信する必要があります。

アプリがプッシュ通知を受信すると、アクティブなスピーカーをフレームワークに報告する必要があります。これにより、システムはアプリのオーディオセッションをアクティブにし、再生を開始できます。

新しいPush To Talk通知は、iOSの他の通知タイプに似ており、Push To Talkアプリへの配信を有効にするために設定する必要がある特定の属性があります。

まず、APNSプッシュタイプは、リクエストヘッダーで「pushtotalk」に設定する必要があります。

次に、APNSトピックヘッダーをアプリのバンドル識別子に設定し、末尾に「.voip-ptt」サフィックスを追加する必要があります。

プッシュペイロードには、アクティブなスピーカーの名前やセッションが終了し、アプリがPush To Talkチャンネルを離れる必要があるという表示など、アプリに関連するカスタムキーを含めることができます。

「Aps」プロパティの本文は空白のままにすることができます。

さらに、他の通信関連のプッシュタイプと同様に、Push To Talkペイロードは、すぐに配信をリクエストするためにAPNS優先度が10で、APNSの有効期限がゼロで、関連性のない古いプッシュが後で配信されるのを防ぐ必要があります。

サーバーがPush To Talk通知を送信すると、アプリはバックグラウンドで起動し、着信プッシュデリゲートメソッドが呼び出されます。

プッシュペイロードを受け取ったら、プッシュ通知の結果として実行すべきアクションを示すプッシュ結果タイプを構築する必要があります。

リモートユーザーが話していることを示すために、名前やオプションの画像など、アクティブな参加者の情報を含むプッシュ結果を返します。

これにより、システムはアクティブな参加者をチャンネルに設定し、チャンネルが受信モードになっていることを示します。

その後、システムはオーディオセッションをアクティブにし、didActivateaudioSessionデリゲートメソッドを呼び出します。

再生を開始する前に、このメソッドが呼び出されるのを待つ必要があります。

サーバーがユーザーをチャネルに参加させないように決定した場合、プッシュペイロードにこれが表示される可能性があり、そのためにはleaveChannelプッシュ結果を返すことができます。

スレッドをブロックしないように、このメソッドからできるだけ早くPTPushResultを返す必要があることに注意することが重要です。

アクティブなリモート参加者を設定しようとしていて、そのイメージがローカルに保存されていない場合は、スピーカーの名前のみでactiveRemoteParticipantを返すことができます。

次に、別のスレッドに画像をダウンロードし、画像が取得されたら、チャンネルマネージャーでsetActiveRemoteParticipantを呼び出してactiveRemoteParticipantを更新します。

リモート参加者が話し終わったら、activeRemoteParticipantをnilに設定する必要があります。

これは、チャンネルでオーディオを受信しなくなり、システムがオーディオセッションを無効にする必要があることをシステムに示します。

これにより、システムPush To Talk UIも更新され、ユーザーが再度送信できるようになります。

PushToTalkをアプリに統合する方法の基本を説明したので、ユーザーエクスペリエンスを最適化し、バッテリー寿命を維持するためのベストプラクティスを確認しましょう。

PushToTalkフレームワークは、ユーザーが送信を開始し、システム内のどこからでもチャネルを離れるためのシステムUIを提供します。

さらに、柔軟性があり、アプリがフォアグラウンドにあるときに独自のカスタムPush To Talk UIを実装できます。

PushToTalkフレームワークは、共有システムリソースを利用します。

一度にシステム上でアクティブにできるPush To Talkアプリは1つだけで、Push To Talk通信は携帯電話、FaceTime、VoIP通話に取って代わられます。

アプリはPushToTalkの障害を適切に処理し、それに応じて応答する必要があります。

前述のように、PushToTalkフレームワークは、オーディオセッションの有効化と無効化を処理します。

ただし、アプリの起動時に再生および録音するようにオーディオセッションのカテゴリを設定する必要があります。

このシステムは、送信時にマイクがアクティブおよび無効になっていることをユーザーに警告する組み込みのサウンドエフェクトを提供します。

これらのイベントに独自の効果音を提供するべきではありません。

また、アプリがセッションの中断、ルートの変更、障害などのAVAudioSession通知を監視して応答することも重要です。

Push To Talkアプリは、システム上の他のオーディオアプリと同様に、これらのオーディオセッションイベントの影響を受ける可能性があります。

バッテリーの寿命を維持するために、アプリを最適化することが重要です。

PushToTalkフレームワークは、オーディオの送受信など、必要に応じてバックグラウンドランタイムをアプリに提供します。

アプリがユーザーによって使用されていない場合、バッテリー寿命を維持するためにシステムによって一時停止されます。

独自のオーディオセッションを有効または無効にしないでください。

システムは、適切なタイミングでオーディオセッションのアクティベーションを処理します。

これにより、オーディオセッションがシステム内で適切な優先順位を持ち、使用されていないときに一時停止することができます。

プッシュ・トゥ・トーク・サーバーは、新しいプッシュ通知タイプを使用して、再生する新しいオーディオがあること、またはプッシュ・トゥ・トークセッションが終了したことをアプリに警告する必要があります。

アプリのバッテリー寿命の改善の詳細については、「パワーダウン：バッテリー消費量の改善」セッションを参照してください。

Push To Talkアプリがバックグラウンドにあり、アプリがオーディオを送受信していない場合、システムによって中断されます。

アプリが一時停止されると、ネットワーク接続が切断されます。

安全なTLS接続を確立し、初期接続速度を向上させるために必要な手順を減らすために、Network.frameworkとQUICの採用を検討する必要があります。

Network.frameworkにはQUICのサポートが組み込まれています。

QUICの使用方法の詳細については、「より応答性の高いアプリのためのネットワークの遅延を減らす」セッションをチェックしてください。

PushToTalkフレームワークを使用すると、アプリ内で堅牢で電力効率の高いトランシーバースタイルのコミュニケーション体験を構築できます。

iOSでウォークトーキースタイルのエクスペリエンスを実装するアプリをすでにお持ちの場合は、新しいAPIを使用するように既存のアプリの更新を開始する必要があります。

新しいトランシーバーアプリを実装する場合は、今すぐPushToTalkフレームワークを使用する必要があります。

最後に、新しいフレームワークのテストを開始し、アプリと統合する際にフィードバックを送信してください。

ありがとう、そして素晴らしいWWDCを!

オーバー・アンド・アウト!

♪