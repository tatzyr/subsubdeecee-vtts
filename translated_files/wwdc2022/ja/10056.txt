10056

♪ ♪

ポール：こんにちは、SwiftUIでカスタムレイアウトを作成することを歓迎します。

私はポールで、開発者のドキュメントに取り組んでいます。

SwiftUIは、アプリのインターフェースを構成するために使用する豊富なビルディングブロックセットを提供します。

テキスト、画像、グラフィックなどの要素を表示する組み込みビューを組み合わせて、カスタムコンポジットビューを作成できます。

これらすべての要素をこれまで以上に洗練されたグループに配置するために、SwiftUIはレイアウトツールを提供します。

水平スタックや垂直スタックなどのコンテナを使用すると、ビューを互いに相対的に配置する場所をSwiftUIに伝えることができますが、ビュー修飾子を使用すると、間隔や配置などをさらに制御できます。

この講演では、一般的なレイアウトの構築をさらに簡単にし、より複雑なレイアウトを可能にする新しいツールを紹介します。

その過程で、SwiftUIでレイアウトを操作するためのヒントをいくつか紹介します。

まず、静的なビューのセットを表示するときに、2次元レイアウトに最適なグリッドファミリーの新しいメンバーをお見せします。

次に、新しいレイアウトプロトコルを使用して、レイアウトエンジンと直接対話できるカスタムビューコンテナタイプを作成する方法について説明します。

次に、利用可能なスペースに収まるビューのコレクションから自動的に選択するコンテナタイプであるViewThatFitsについて話します。

そして最後に、AnyLayoutを使用してレイアウトタイプ間のシームレスなトランジションを追加する方法を紹介します。

これらすべての新機能の動作を見るために、私が取り組んでいるアプリを見てみましょう。

近年、誰が最高の毛皮のような仲間を作るかについて、私の同僚の間でいくつかの議論がありました。

私は自分の意見を持っていますが、コンセンサスに達することができるかどうか興味があったので、世論調査を受けるためのアプリを作ることにしました。

そして、毛皮アレルギーを持つ人々も含めたいので、私は1つの余分なオプションを投げています。

今、私はプレビューを使用してプロトタイプを作成するのがとても簡単なので、SwiftUIでインターフェイスデザインのほとんどを行うのが好きですが、出発点として、私が目指しているものの簡単なスケッチを描きました。

投票は一定期間続くと思うので、真ん中に現在の順位を示すリーダーボードが欲しいです。

投票用のボタンを一番下に置きます。

そして、上部には、人々が投票しているものの画像をいくつか表示します。

さて、私が最初にやりたいことは、リーダーボードを作ることです。

では、それを詳しく見てみましょう。

リーダーボードは、各候補の行と、名前、パーセンテージ、投票数を示す列を持つ要素の2次元グリッドです。

ここで達成したい具体的なことがいくつかあります。

まず、2つのテキスト列は、パーセンテージを表すプログレスビューができるだけ多くのスペースを取得したいので、それぞれのケースで最も広いセルを収容するために必要な範囲だけにしたい。

そして、これは、他の言語を話す私の友人や、自分のデバイスで異なるテキストサイズを使用する人にとって、カウントがどれほど大きくても、真実である必要があります。

第二に、名前をリーディングエッジに整列させたいが、量をトレーリングエッジに整列させたい。

現在、SwiftUIにはすでに遅延グリッドがあり、スクロール可能なコンテンツに最適です。

これらのコンテナは、表示されているビュー、または表示されようとしているビューのみをロードするため、多くのビューがある場合に非常に効率的です。

一方、コンテナは両方の次元でセルを自動的にサイズ調整できないことを意味します。

たとえば、LazyHGridは、列を描画する前に列内のすべてのビューを測定できるため、各列の幅を把握できます。

しかし、行の高さを把握するために、行内のすべてのビューを測定することはできません。

これを機能させるには、遅延グリッドは、初期化時にその次元の1つに関する情報を提供する必要があります。

遅延グリッドやその他の既存のSwiftUIレイアウトコンテナタイプを詳しく見るには、2020年のスタック、グリッド、アウトライントークを参照してください。

しかし、私の場合、スクロールする必要はなく、SwiftUIに各セルの高さと幅の両方を把握させたいと思います。

この種のレイアウトでは、SwiftUIはグリッドビューを提供しています。

遅延グリッドとは異なり、グリッドはすべてのビューを一度に読み込むため、列と行の両方でセルを自動的にサイズと整列させることができます。

これのコードを見てみましょう。なぜなら、このコードを見てみましょう

これは、グリッドとして書かれた私のリーダーボードの基本的なバージョンです。

この特定のグリッドビューには、3つのGridRowインスタンスが含まれています。

行内では、各ビューは列に対応します。

したがって、この例では、各行の最初のテキストビューは最初の列に対応し、進捗ビューは2番目の列にあり、最後のテキストビューは3番目の列です。

グリッドは、最大のビューを保持するために必要な数のスペースを各行と列に割り当てることに注意してください。

したがって、最初のテキスト列は、最も長い名前には十分な幅ですが、幅は広くはありません。

進行状況インジケータのような柔軟なビューは、グリッドが提供するのと同じくらい多くのスペースを取ります。この場合、テキスト列のスペースを割り当てた後に残っているものです。

これを少し調整したいのですが、まず、基本的なデータモデルを作成して、投票数を保存する場所を与えましょう。

ネットワーク全体でデータを管理および共有するには、より多くのロジックが必要ですが、インターフェイスをプロトタイピングしている間は、このような単純な構造が必要です。

識別可能なコンフォーマンスを含めると、このタイプをForEachで使いやすくなり、Equatableコンフォーマンスも含めて変更をアニメーション化できるようにします。

そして、プロトタイプの作成中にプレビューで使用する一連のサンプルデータを作成します。

グリッドに戻ると、状態変数を作成し、サンプルデータで初期化できます。

そして、そのデータを使用して、ForEachで行を作成できるようになりました。

レンダリングされた出力は、まだ同じデータを表示しているため、変更されていないことに注意してください。

それはすでにかなり近いですが、セルのアライメントを修正する必要があります。

現在、すべてのセルは中央に整列されており、これはグリッドのデフォルトですが、覚えていれば、名前を前縁に整列させ、値を後縁に整列させたいです。

これを行うには、リーディングエッジアライメントでグリッドを初期化します。

ここで使用する値は、グリッド内のすべてのセルに適用されます。

それは私の最初の2つのコラムでうまくいきますが、最後のコラムはどうですか？

単一の列の配置に影響を与えるために、その列の任意の1つのセルにgridColumnAlignmentビュー修飾子を適用できます。

だから、最後の列のテキストビューでそうします。

さて、それはそこに着いていますが、今それを見ていると、各行の間に仕切りがある方が良いような気がします。

仕切りでForEachに新しい行を追加すると、これは正確に私が望むものではありませんが、これはいくつかの興味深いことを示していることに注意してください。

まず、仕切りは柔軟なビューであるため、最初の列はより多くのスペースを占有します。

基本的に、グリッドは現在、最後の列に必要なものを与え、最初の2つの列の間で残りのスペースを分割しています。

第二に、他のグリッド行ほど多くのビューを持っていないグリッド行の場合、不足しているビューは後の列に空のセルを作成するだけです。

しかし、私が本当に欲しいのは、仕切りがグリッドのすべての列にまたがることであり、SwiftUIにはそれを可能にする新しいビュー修飾子があります。

gridCellColumns修飾子をビューに追加することで、1つのビューにいくつかの列にまたがるように伝えることができます。この場合、3つすべてです。

そして実際には、ビューがグリッド全体にまたがる必要がある場合、グリッド行の外側にビューを単独で書くだけでこれを単純化できます。

さて、私のリーダーボードはかなり良い状態なので、次に投票するために使用されるボタンを見てみましょう。

一見すると、ここには派手すぎるものはありません。

しかし、私には特別な要件が1つあります。

一方で、私は特定の選択肢のために小さなボタンで参加者を偏らせたくありません。

しかし、私はまた、ボタンがiPadやMacで非常に大きくなる可能性のあるコンテナほど大きくなりたくありません。

代わりに、ボタンはすべて最も広いボタンのテキストに等しい幅を持つ必要があります。

では、これをHstackで構築しようとするとどうなりますか?

私が見つけたのは、各ボタンがテキストラベルに合うようにサイズが小さくなり、HStackはこれらを水平にまとめているということです。

このデフォルトのスタック動作は、多くの場合、まさにあなたが望むものですが、このプロジェクトの私の仕様にはあまり合いません。

SwiftUIのレイアウトの基礎に関する復習については、2019年のSwiftUIトークでカスタムビューを構築するを参照してください。

そのトークの概念を使用して、このビュー階層を見て、私が望む動作を得るために何を変更できるかを見てみましょう。

まず、スタックのコンテナはスタックのサイズを提案します。

これに基づいて、スタックは3つのボタンのサイズを提案し、各ボタンはそのサイズをテキストラベルに渡します。

テキストビューは、含まれている文字列に応じて、実際に必要なサイズを計算し、これをボタンに報告します。

ボタンは情報を元に戻します。

スタックは、この情報でそれ自体をサイズし、ボタンをスペースに配置し、独自のサイズをコンテナに報告します。

さて、ボタンがテキストのサイズを取る場合、各テキストビューを柔軟なフレームでラップして成長させるとどうなりますか?

テキストは変更されていませんが、ボタンには柔軟なサブビューが表示され、HStackが提供するのと同じくらいのスペースがかかります。

その後、スタックは、含まれているビュー間でスペースを均等に分配します。

したがって、ボタンはすべて同じサイズで、これは素晴らしいことですが、実際のサイズはスタックのコンテナによって異なります。

スタックは、コンテナが提供するスペースを埋めるために拡張されますが、それは私が望むものではありません。

私が本当に欲しいのは、各ボタンの理想的なサイズを要求し、最も広いものを見つけ、それぞれにその量のスペースを提供するカスタムスタックタイプです。

幸いなことに、SwiftUIにはそれを可能にする新しいツールがあります。

レイアウトプロトコルを使用して、私のユースケースに合わせた動作でレイアウトプロセスに直接参加するカスタムレイアウトコンテナを定義できます。

これがどのように機能するか見てみましょう。

HStackをもう一度見て、特定の問題を解決するために定義するタイプをEqualWidthHStackに変更させてください。

このタイプは、最も広いボタンの理想的な幅と同じくらいの幅で、ボタンに均等に幅を割り当てます。

テキストが狭いボタンが拡張してスタックが提供するスペースを埋めることができるように、柔軟なフレームを維持します。

しかし、ボタンにはまだ私が測定できる理想的なサイズがあり、それはテキストの幅です。

では、MyEqualWidthHStackを実装する方法を見てみましょう。

レイアウトプロトコルに準拠したタイプを作成することから始めます。

基本的なレイアウトに必要なのは、必要な2つの方法だけです。

それらにスタブを追加しましょう。

最初の方法はsizeThatFitsで、レイアウトコンテナの大きさを計算して報告します。

提案されたビューサイズ入力を取得します。これは、レイアウト独自のコンテナビューからのサイズ提案です。

また、サブビューパラメータを使用して、レイアウトのサブビューにサイズを提案できます。

サブビューに直接アクセスできないことに注意してください。

代わりに、サブビューの入力は、サイズを提案するなど、サブビューと特定の方法で対話できるプロキシのコレクションです。

各プロキシは、私が行った提案に基づいて具体的なサイズを返します。

これらすべての回答を収集し、それらを使用していくつかの計算を行い、EqualWidthHStackの具体的なサイズをコンテナに返します。

私が実装しなければならない2番目の方法はplaceSubviewsです。

これを使って、レイアウトのサブビューのどこに表示するかを伝えます。

このメソッドは、同じサイズの提案とサブビューの入力を取り、サブビューを配置する必要がある領域を表す境界入力も取ります。

Boundsは、私がsizeThatFitsの実装で要求したサイズを持つ長方形です。

覚えておいて、ビューはSwiftUIで独自のサイズを選択するので、私のレイアウトコンテナはそれが要求するサイズを取得します。

領域の起源は左上にあり、正のXは右に、正のYは下にあります。

フレームワークは、その方向にビューをレイアウトするときに各ビューのx位置を自動的に反転するため、右から左の言語環境でも、すべての配置計算でこれを想定できます。

ただし、長方形の原点が値(0,0)であると仮定しないでください。

とりわけ、ゼロ以外の原点を許可すると、あるレイアウトのplaceSubviewsメソッドが別のレイアウトの同じメソッドを呼び出すレイアウト構成が可能になります。

作業を少し簡単にするために、長方形は、各次元の最小点、中心点、最大点など、領域の重要な部分にアクセスするためのプロパティを提供します。

さて、先に進む前に、これらのメソッドが両方とも持っているもう1つのパラメータに注目してください。メソッド呼び出し間で中間計算の結果を共有するために使用できる双方向キャッシュです。

多くのシンプルなレイアウトでは、これは必要ありません。今のところキャッシュを無視するだけです。

ただし、Instrumentsでアプリをプロファイリングすると、レイアウトコードの効率を向上させる必要があることが示されている場合は、追加を検討することができます。

それの詳細については、ドキュメントを確認してください。

さて、sizeThatFitsを実装しましょう。

水平に配置されたすべてのボタンを同じ幅に収まるコンテナのサイズを返したいことを覚えておいてください。

まず、各ボタンのサイズを尋ねます。これは、サイズを提案し、何が戻ってくるかを見ることです。

サブビューの柔軟性を測定するには、最小サイズ、最大サイズ、理想的なサイズの特別な提案を使用して複数の測定を行うか、特定のサイズを提案することができます。

この場合、私は不特定のサイズの提案を使用して、理想的なサイズを求めます。

その後、私が取り戻したすべてのサイズについて、各次元で最大の値を見つけます。

この場合、金魚のボタンは幅を設定し、高さはすべて同じです。

サブビューを配置するときに再び必要になるので、それをメソッドにリファクタリングさせてください。

次に、ビュー間の間隔を考慮する必要があります。

10ポイントのような一定の間隔を使用できますが、レイアウトプロトコルにより、より良くすることができます。

SwiftUIでは、すべてのビューには、ビューと次のビューの間に好むスペースの量を示す間隔設定があります。

これらの設定は、レイアウトコンテナに使用できるViewSpacingインスタンスに保存されます。

ビューは、異なるエッジで異なる値、さらには異なる種類の隣接するビューに対して異なる値を好むかもしれません。

たとえば、ビューは、それ自体と画像の間に望むよりも、自分自身とテキストビューの間に多かれ少なかれスペースが必要になる場合があります。

また、値はプラットフォームによっても異なる場合があります。

レイアウトに理にかなっている場合は、これらの設定を無視できます。これは本質的に、カスタム間隔で組み込みスタックを初期化するときに起こることですが、独自のレイアウトでこれらの設定を尊重することは、Appleのインターフェイスガイドラインに自動的に従う結果を得るための良い方法であり、その結果、システムの残りの部分の外観と一致します。

現在、すべてのビューにはすべてのエッジに環境設定があり、2つのビューをまとめると、共通のエッジの環境設定が一致しない可能性があります。

これを解決するために、組み込みのレイアウトコンテナは2つの設定のうち大きい方を使用します。

そして、私は自分のレイアウトで同じことをすることができます。

サブビュープロキシは、特定の軸に沿った他のボタンに対する各ボタンの好ましい間隔を尋ねる方法を提供します。

したがって、サブビューをスキャンし、各プロキシの間隔インスタンスの距離メソッドを呼び出して、水平軸に沿って次のビューの間隔インスタンスへの間隔を取得して、値の配列を作成させてください。

この呼び出しは、共通のエッジに関する両方のビューの好みを考慮に入れます。

この配列の最初の要素は、猫のボタンが金魚ボタンに水平にどれだけのスペースを望んでいるかを教えてくれ、次の要素は、金魚のボタンが犬のボタンにどれだけのスペースを望んでいるかを教えてくれます。

比較するボタンがもうないので、配列の最後の要素を強制的にゼロにします。

さて、それも後でメソッドにリファクタリングさせてください。

これで、間隔値を組み合わせて合計間隔を見つけ、それを幅と高さの測定値で使用してサイズ値を返すことができます。

これは、サブビューの理想的なサイズと各サブビューの好ましい間隔を考えると、私のレイアウトが必要とするサイズです。

私が実装する必要があるもう1つの方法はplaceSubviewsです。

前に述べたように、私はコンテナの境界と、ボタンを指示するために使用できるサブビュープロキシのコレクションの両方を取得します。

まず、sizeThatFitsメソッドで行ったように、maxSizeと間隔配列を計算します。なぜなら、ここでもそれらの値が必要になるからです。

次に、各サブビューに使用できるサイズ提案を作成します。今回は、理想的なサイズではなく、必要なサイズに基づいて作成します。

すべてのボタンを同じサイズにしたいので、提案は1つだけ必要です。

そして、私の境界の前縁として計算された最初のサブビューの水平寸法の開始位置と、ボタンの幅の半分を見つけます。

原点がゼロであることを頼りにしているのではなく、代わりにminX値から始めていることに注意してください。

最後に、各サブビュープロキシを調べて、ポイント、そのポイントがボタンの観点から何を表すかのステートメント、およびサイズ提案でその場所メソッドを呼び出すことができます。

ループを通過するたびに、ビューの幅と次のビューペアの間隔で水平位置を更新し、次の反復の準備をします。

そして、それだけです。

では、この新しいビューレイアウトタイプを使用するとどうなるか見てみましょう。

そして、そこにあります。

組み込みのHStackと同じように、独自のカスタムレイアウトコンテナをインスタンス化し、ボタンはすべて同じ幅で水平に配置されます。

さて、ここで少し立ち止まって、レイアウトプロトコルが過去にジオメトリリーダーを使用しようとした可能性のある問題をどのように解決するかについて話したいと思います。

ジオメトリリーダーは、結局のところ、ビューサイズを測定するためのツールです。

しかし、この場合は最良の選択ではありません。

これは、ジオメトリリーダーがコンテナビューを測定し、そのサイズをサブビューに報告するように設計されているためです。

次に、サブビューは情報を使用して独自のコンテンツを描画します。

ジオメトリリーダーの使用目的では、情報が下方に流れることに注意してください。

読者が行う測定は、独自のコンテナのレイアウトには影響しません。

これは、コンテナでスケールするパスを描くなどに最適です。

ジオメトリリーダーは、作業するスペースの量をパスロジックに伝え、サブビュー内のパスロジックはそれに応じて調整されます。

コンテナのサイズを変更すると、ジオメトリリーダーが新しいサイズを通過するため、パスも変更されます。

しかし、私のボタンについては、見やすくするためにここで1つに焦点を当てます。テキストビューを測定し、それを使用して、テキストビューのコンテナであるフレームを設定する方法を決定する必要があります。

そのため、テキストビューにオーバーレイでジオメトリリーダーを追加して、コンテナを測定し、どういうわけか通常のフローの外で測定データをフレームに送り返すことができます。

しかし、これを行うと、レイアウトエンジンをバイパスし、ループが発生する可能性があることに注意してください。

リーダーはレイアウトを測定し、フレームを変更します。これにより、レイアウトが変更される可能性があり、別の測定が必要になる可能性があります。

これでこれを機能させることは可能ですが、注意しないと、アプリをクラッシュさせる可能性があります。

その結果、この戦略は推奨されません。

幸いなことに、レイアウトプロトコルは、レイアウトエンジン内で作業できるようにすることで、この問題を解決するためのより良い方法を提供します。

さて、ボタンをもう一度見てみましょう。

ここで他にやりたいことがあります。

まず、これを少し読みやすくするために、ボタンを独自のサブビューにリファクタリングします。

今、私はたまたま私の同僚の一人が彼らのデバイスでより大きなタイプを使用していることを知っています。

デフォルトのフォントを使用しているので、私のアプリは自動的にダイナミックタイプをサポートしているので、私はほとんど無料で正しい動作を得るべきです。

タイプサイズを大きくしたらどうなるか見てみましょう。

ああ、ボタンはもう収まりません。

私のカスタムスタックはボタンの幅を制限するのではなく、理想的なサイズを持つだけで、この場合はディスプレイの幅を超えることを忘れないでください。

それで、私は何ができますか?

さて、レイアウトのコンテナからのサイズ提案を考慮して、ビューが収まらないときに、より複雑なことをするためにレイアウトを変更することができます。

しかし、この場合、新しいViewThatFitsコンテナを使用して、ほとんどの作業を行うことができます。

この新しいタイプは、私が与えるビューのリストから、利用可能なスペースに収まる最初のビューを選択します。

カスタムスタックをViewThatFits構造でラップし、同じコンテンツの垂直スタックバージョンを追加することで、SwiftUIにボタンを別の方法で配置する必要があるタイミングを把握させることができます。

もちろん、組み込みのVStackは、私のカスタム水平スタックと同じ幅プロパティを持っていないので、私は先に進み、カスタムスタックの垂直バージョンも実装しました。

すでに説明したものと非常によく似ていますが、水平軸ではなく垂直軸に沿って等しい幅の項目を配置します。

そしてもちろん、動的タイプサイズのオーバーライドを削除すると、水平レイアウトに戻ります。

さて、私が構築する必要があるアプリの最後の部分があり、それは上部の画像です。

プロフィール写真のグループを見せるなど、簡単なことをすることができますが、少し楽しめると思いました。

そこで、円形の配置でビューを描画し、ランキングに従って配置を回転させる別のカスタムレイアウトタイプを作成しました。

したがって、この構成は金魚が1位で、他の2匹が2位に並んでいることを示しています。

そして、犬が猫の前を引っ張るなら、私はそれを示すために少し回転することができます。

または、放射状のレイアウトを回転させることで、もう少し現実的な結果を示すことができます。

このレイアウトの作成は、実際にはレイアウトプロトコルで非常に簡単です。

以前と同じように、私は2つの方法が必要です。

フィットするサイズについては、ビューが利用可能なスペースを埋めたいので、コンテナビューが提案するサイズを返します。

指定されていない寸法の置き換え方法を使用して、提案を具体的なサイズに変換します。

このメソッドは、コンテナが理想的なサイズを要求した場合に存在する可能性のあるnil値を自動的に処理します。

次に、場所サブビューメソッド内で、各サブビューを中央からレイアウト領域のサイズに基づく半径でオフセットし、ビューのインデックスに依存する回転を適用します。

ベースラインとして、これはビューを円の周りの0、1、および3分の2に配置します。

現在のランキングを反映するために、すべてのビューに等しく影響するオフセットも適用します。

しかし、ランキングはどこで入手できますか?

私のレイアウトはサブビュープロキシにのみアクセスでき、ビューにアクセスできず、データモデルは言うまでもありません。

さて、レイアウトプロトコルには別のトリックがあることが判明しました。

これにより、各サブビューに値を格納し、レイアウトプロトコルメソッド内から値を読み取ることができます。

それを使ってランク情報を伝える方法を見てみましょう。

まず、LayoutValueKeyプロトコルに準拠した新しい型を宣言し、デフォルト値を与えます。

明示的に設定していないときにビューに値を提供することに加えて、デフォルト値は関連する値の型を確立します。この場合は整数です。

次に、Viewに便利なメソッドを作成して、layoutValueビュー修飾子を使用して値を設定します。

ビュー階層では、便利なランク修飾子をレイアウトのビューに適用できます。

ここでは、各ペットのランクを計算し、ラジアルレイアウト内のペットの対応するアバタービューに追加します。

最後に、私の場所のサブビューメソッドに戻って、レイアウト値キーをインデックスとして使用して、各サブビューから値を読み取るためのコードを追加できます。

そして、ランクを使ってオフセットを計算することができます。

私はここでその論理を通過しませんが、それは基本的にランキングの任意の可能なセットのための適切な角度を生成します。

まあ、1つを除いてすべて。

3ウェイタイがある場合はどうなりますか? どうなりますか?

レイアウトを回転させてすべてのビューを1行に表示する方法はないので、その場合はまったく異なるレイアウトロジックを置き換える必要があります。

しかし、これを行うレイアウトタイプはすでにあり、それは組み込みのHStackです。

だから、私が本当に欲しいのは、3方向のタイを検出したときにHStackに移行することです。

そして、そのための新しいツールもあることが判明しました。

AnyLayoutタイプを使用すると、単一のビュー階層に異なるレイアウトを適用できるため、あるレイアウトタイプから別のレイアウトタイプに移行する際にビューのアイデンティティを維持できます。

だから、ここには私たちが前に見た放射状のレイアウトがあり、私がしなければならないのは、3方向のネクタイがあるかどうかに依存する新しいレイアウトタイプに置き換えることだけです。

isThreeWayTieプロパティは状態から派生しているため、SwiftUIは変更されたときに気づき、このビューを再描画する必要があることを認識します。

しかし、ビュー階層の構造的アイデンティティは常に同じままであるため、SwiftUIはこれを新しいビューではなく、変化するビューと見なしています。

その結果、あと1行だけで、レイアウトタイプ間のスムーズなトランジションを作成できます。

実際、アニメーションビュー修飾子を追加することで、ラジアルレイアウトの構成は同じデータに依存するため、ラジアルレイアウトのすべての異なる状態間のアニメーションも取得します。

そして、これがすべての行動のように見えます。

投票数を変更するためにさまざまなボタンをタップすると、アバターがどのようにスムーズに動き回り、現在の順位を反映しているかがわかります。

したがって、これらはSwiftUIがアプリのビューレイアウトを作成するための新しいツールの一部です。

グリッドタイプを使用して、静的情報の高度にカスタマイズ可能な2次元レイアウトを構築できます。

レイアウトプロトコルを使用して、独自の汎用、再利用可能なレイアウト、または特定のユースケースをターゲットとするレイアウトを定義できます。

利用可能なスペースに最も合うようにSwiftUIがビューのグループから選択できるようにする場合は、ViewThatFitsを使用できます。

また、AnyLayoutを使用してレイアウトタイプ間をシームレスに移行できます。

今日は参加してくれてありがとう、そしてあなたが私と同じくらいこれらの新しいレイアウトツールで遊ぶのを楽しんでいることを願っています。