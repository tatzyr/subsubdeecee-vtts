10102

♪ ♪

こんにちは、ようこそ。

私はGPUソフトウェアのエンジニアリングマネージャー、ガロ・アビラです。

このセッションでは、Eylonと私は、Metal 3でアプリのGPUバイナリ生成を改善する方法を共有することに興奮しています。

まず、オフラインコンパイルがアプリのスタッター、最初の起動、新しいレベルの読み込み時間を減らすのにどのように役立つかを説明します。

その後、Eylonは、サイズコンパイラの最適化オプションを使用して、変換を拡張するコードを調整し、コンパイル時間を改善する方法を説明します。

オフラインコンパイルでは、GPUバイナリ生成をプロジェクトのビルド時間に移動できます。

採用がMetalアプリケーションにもたらす利点を完全に理解するために、GPUバイナリをすでに生成できる方法を検討することから始めます。

Metalアプリでは、GPUバイナリ生成はビルド時とランタイムの両方で行われます。

たとえば、ソースから金属ライブラリをインスタンス化するとします。

これは、アプリの実行時に、AIRとも呼ばれるAppleの中間表現が生成されます。

これはCPU集約型の操作であり、ソースをMetalライブラリに事前コンパイルし、代わりにファイルからインスタンス化することで、アプリのビルド時間に移動できます。

Metalライブラリがメモリに入ったら、状態と関数を含むパイプライン状態記述子を作成することは軽量な操作です。

パイプライン状態オブジェクトを作成するまで、これは別のCPU集約的な操作であり、タイミングのGPUバイナリ生成が行われます。

実行時のGPUバイナリ生成はCPU集約的な操作になる可能性があるため、Metalはパイプライン状態オブジェクトの作成を高速化するのに役立ちます。

PSOをインスタンス化すると、MetalはGPUバイナリをファイルシステムキャッシュに保存します。

そして、新しいPSOが作成されるたびに、新しく生成された機能が追加されます。

したがって、参照される以前に生成されたバイナリは、キャッシュから読み込まれます。

Metalでは、バイナリアーカイブを使用して、GPUバイナリがいつ、どこでキャッシュされるかを明示的に制御することもできます。

PSO記述子を使用して、GPUバイナリを必要な回数だけアーカイブにキャッシュするだけです。

その後、PSOの作成は軽量操作になります。

バイナリアーカイブは、より柔軟なキャッシュを可能にしますが、実行時に生成する必要があります。

多くの場合、あなたが本当に欲しいのは、ビルド時にそれらのアーカイブを生成することであり、今、あなたは最終的にすることができます。

オフラインバイナリ生成では、プロジェクト構築時にMetalパイプラインスクリプトと呼ばれる新しいアーティファクトを、MetalソースまたはMetalライブラリとともに指定します。

パイプラインスクリプトは、APIのパイプライン記述子のコレクションに相当するコンパイラツールチェーンです。

コンパイルプロセスの出力はバイナリアーカイブです。

アプリの実行時にこれ以上のGPUコード生成は行われません。

PSOの作成を加速するために、オフラインで構築されたバイナリアーカイブをロードする。

オフラインコンパイルは、Metalを低レベルのAPIにする中核となるランタイムCPUのオーバーヘッドを減らすことで、アプリに利益をもたらします。

さらに、採用は2つの顕著な方法でアプリのエクスペリエンスを向上させることができます。

最初の打ち上げと新しいレベルのロード時間は劇的に速くなり、エンゲージメントとインタラクションが高まる可能性があります。

ランタイムコンパイルによるスタッタやフレームレートの低下は、プレウォームフレームのメモリやCPUコストなしで、最終的に削除することができます。

次に、これらの利点について詳しく説明します。

ここには、従来のアプリランタイムバイナリ生成があります。

この例では、アプリは、操作を開始する前に、ロード画面の背後にあるGPUバイナリのコンパイルに約2/3の時間を費やしています。

しかし、オフラインコンパイルでは、ランタイムシェーダーの生成がアプリのビルド時間に移行し、PSOの作成はわずかな時間で行われ、ロード画面でアイドル状態になるのではなく、より早くアプリと対話することができます。

オフラインコンパイルは、吃音を減らすのにも役立ちます。

従来のランタイムバイナリ生成では、ロード時に作成するパイプライン状態が多すぎる可能性があるため、代わりにタイミングで作成する可能性があります。

そして、それが起こると、コンパイルがコマンドエンコーディングを一時的に中断することによって引き起こされるフレームドロップが発生する可能性があります。

オフラインコンパイルは、アプリのビルド時にさらに多くのシェーダーをコンパイルできるため、これらの厄介なバブルを削除します。

次に、オフラインコンパイルの利点を活用するのに役立つ新しい開発者ワークフローを共有します。

次のワークフローでは、新しいツールチェーン機能を使用してGPUバイナリをオフラインで構築する方法を学びます。

新しいパイプラインスクリプト入力アーティファクトを生成する方法を紹介します。

次に、ツールチェーンを呼び出してGPUバイナリを生成する方法。

パイプラインスクリプトアーティファクトは、1つ以上のAPIパイプライン状態記述子のJSON形式の説明であり、さまざまな方法で生成できます。

たとえば、お気に入りのJSONエディタで作成するか、開発とテスト中にシリアル化されたバイナリアーカイブからハーベストします。

ここには、状態と関数とその同等のJSON表現を持つレンダリングパイプライン記述子を生成するMetalコードのスニペットがあります。

まず、APIメタルライブラリファイルはライブラリパスプロパティとして指定されます。

次に、APIレンダリング記述子関数名をレンダリングパイプラインのプロパティとして使用します。

最後に、raster_sample_countやピクセル形式などの他のパイプライン状態もスクリプトプロパティとしてキャプチャされます。

Metalの開発者ドキュメントで、さらにJSONスキーマの詳細を探してください。

また、JSONスクリプトの生成をキックスタートしたいと思うかもしれませんし、Metalランタイムを使用すると役立ちます。

実行時にバイナリアーカイブを生成し、開発とテストの過程でそれらをシリアライズするだけです。

次に、Metal APIでこれを達成する方法を紹介します。

ランタイムハーベスティングプロセスを開始するには、状態と機能を備えたパイプライン記述子を作成し、GPUバイナリを生成するアーカイブに追加し、ファイルシステムにシリアライズしてアプリのバンドルにインポートしてロードします。

Metal 3ランタイムは、GPUバイナリと一緒にパイプライン記述子を保存します。

では、それらを抽出する方法を紹介します。

metal-sourceを使用すると、既存のアーカイブからJSONパイプラインスクリプトを抽出できます。

これは、バイナリ生成をランタイムからアプリビルド時間に移行するのに便利です。

フラットバッファと出力ディレクトリオプションでメタルソースを呼び出すだけです。

結果はパイプラインスクリプトファイルで、編集して追加のバイナリを生成できます。

では、ツールチェーンを呼び出す方法を紹介します。

XcodeプロジェクトのビルドフェーズからGPUバイナリを生成するのは簡単です。

ソース、パイプラインスクリプト、および出力ファイルを使用して、端末から金属を呼び出すだけです。

出力メタルライブラリにはGPUバイナリが含まれており、ツールチェーンでサポートされているどのデバイスにも展開できます。

また、ソースの代わりにMetalライブラリがある場合は、それをツールチェーンにも渡すことができます。

既存のMetalライブラリからバイナリを生成するのは、Metal翻訳ツールでも同じように簡単です。

ソース、パイプラインスクリプト、および出力ファイルを使用して端末で行うのと同じように、metal-ttを呼び出すだけです。

結果として得られるMetalライブラリには、ツールチェーンでサポートされているすべてのデバイスのGPUバイナリが含まれています。

バイナリをオフラインで作成する方法がわかったので、それらをロードする方法を確認します。

アーカイブ記述子を作成するときにバイナリURLを提供し、それを使用してアーカイブをインスタンス化するだけです。

それでおそれ！

メタルのバイナリアーカイブAPIの詳細については、前年の講演を参照してください。

最後に、Metalがオフラインで生成されたアーティファクトのGPUバイナリ互換性をどのように処理するかについての注意。

オフラインで生成されたバイナリが将来のOSバージョンや製品と前方互換性があることを確認するため。

Metalは、OSのアップデート中またはアプリのインストール時にバイナリアーカイブを優雅にアップグレードします。

それは非同期に、そしてバックグラウンドでそうします。

オフラインコンパイルの利点を活用して、ランタイムスタッターを取り除き、最初の起動と新しいレベルのロード時間を短縮するのが待ちきれません。

このような改善は、他の人にとって目に見えるものであり、全体的なアプリ体験を向上させることができます。

さて、エイロンへ。

アイロン:ありがとう、ガロ。

次に、サイズを最適化する新しいコンパイルオプションを紹介します。

Metalコンパイラは、ランタイムパフォーマンスのためにコードを積極的に最適化します。

一部の最適化により、GPUプログラムのサイズが拡大され、予期せぬコストが発生する可能性があります。

たとえば、関数インラインは、関数呼び出しのオーバーヘッドを回避するための最適化です。

これは、呼び出された関数の本体をコールサイトにインライン化することによって機能します。

このカーネルの例は、多くのコードのようには見えませんが、インライン化後、関数「f」と「g」のコピーと、ヘルパーや非プリミティブライブラリ関数など、「f」と「g」から呼び出される関数のコピーも含まれる可能性があります。

もう1つの最適化は、ループ本体の追加コピーをインライン化し、反復間で並列性を公開し、分岐オーバーヘッドを回避するループアンローリングです。

コンパイラは、ループの2つの反復、または境界が固定されているループのすべての反復を展開できます。

このような最適化が非常に大きなプログラムを作成する場合、コンパイラはコンパイルに多くの時間を費やす必要があり、状況によっては、これらのコストを回避することを好むかもしれません。

Xcode 14は、新しい金属最適化モードを導入します。サイズに合わせて最適化します。

このモードは、コンパイラがパフォーマンスの最適化を適用する場合、インラインやループ展開などのサイズ拡張変換を制限します。

意図された利点は、デフォルトの最適化が高すぎることが判明した場合に、GPUバイナリを小さくし、コンパイル時間を短くすることです。

サイズを最適化すると、ランタイムのパフォーマンスが低くなる可能性があります。

それが実際に起こるかどうかはプログラムによって異なりますので、両方の最適化モードを試して比較する必要があります。

サイズの最適化は、すべてのシェーダーのサイズとコンパイル時間を改善しない場合があります。

インライン化と展開が一般的なディープコールパスとループを持つ大規模なプログラムには利益をもたらす可能性が最も高いです。

このオプションは、デフォルトの最適化から予期せず長いコンパイル時間が発生するたびに試してみる価値があります。

このオプションは、プロジェクトのビルド時にコンパイルする場合でも、アプリの実行時にコンパイルする場合でも利用できます。

これは、サイズの最適化が違いを生むケースです。

Cyclesは、Blender 3D設計環境用のプロダクションレンダラーを実装するオープンソースプロジェクトで、最近Metalをサポートするように更新されました。

Appleは最近Blender開発基金に参加し、私たちが学んだことの1つは、Blenderのパストレーシングアルゴリズムは、多くのヘルパー関数とループを備えた大規模なコンピューティングシェーダーを使用し、そのコンパイル時間は数分まで加算できることでした。

それらはまさにMetal 3の新しいサイズ最適化オプションの恩恵を受けることができるシェーダーの種類であることが判明しました。

これらのシーンをApple Silicon GPUでレンダリングすると、シェーダーパイプラインのコンパイルを含むBlenderのセットアップ時間を最大1.4倍に最適化できます。

そして、レンダリング時間の劣化がほとんどまたはまったくないスピードアップを提供しました。

レンダリングは4%まで遅くなり、まったく遅くならなかったものもあります。

したがって、ランタイムパフォーマンスの低下が可能です。

しかし、場合によっては、サイズを最適化することで、ランタイムのパフォーマンスを向上させることもできます。

ここに例があります。

これらは、Intel GPUでサイズの最適化を可能にすることで、同じシーンのレンダリングタイムのスピードアップです。

利点は、より速いコンパイルだけでなく、最大1.6倍のより速いレンダリングでした。

どうやって？

より小さなGPUプログラムは、大きなサイズに付属するランタイムペナルティの一部を回避できるため、命令キャッシュのミスが少なくなるか、レジスタが少なくて済んだりする可能性があり、メモリへの流出が少なくなり、並行してスレッドがさらに多くなります。

これらの結果は、すべてのシェーダーやシーンに典型的なものではなく、パフォーマンスの低下が可能であることを覚えておいてください。

プロジェクトでは、コンパイル時とランタイムのパフォーマンスの両方に対する実際の影響を評価する必要があります。

3つの異なる環境で、Metalソースからコンパイルするときにサイズの最適化を有効にすることができます。

Xcode 14のユーザーインターフェイスで、ビルド設定としてサイズの最適化を指定します。

「メタルコンパイラ - ビルドオプション」で、設定「最適化レベル」を見つけます。

レベル「デフォルト」は、メタルが過去に行ったように、パフォーマンスを最適化します。

レベル「サイズ」では、サイズを最適化できます。

コマンドラインでMetalソースをコンパイルするときは、オプション'-Os'を使用してサイズの最適化を指定します。

最初の例では、単一のコンパイルとリンクコマンドのオプションを指定します。

2番目の例には2つのコンパイルコマンドがあり、そのうちの1つだけにオプションを指定して、一部のシェーダーのみで有効にします。

このオプションは、リンクコマンドまたは後続のコマンドに渡す必要はありません。

また、この講演の前半で提示したコマンドを使用して、GPUバイナリを生成するかどうかにかかわらず、サイズの最適化を使用できます。

最後に、「newLibraryWithSource」などのMetal Framework APIを使用してアプリ実行時にMetalソースをコンパイルするときは、プロパティ「optimizationLevel」を使用して「MTLCompileOptions」オブジェクトのサイズの最適化を指定します。

最適化レベルは「デフォルト」または「サイズ」です。

あなたのプロジェクトがMetalコンパイラのこの新しい最適化モードの恩恵を受けることを願っています。

Galo: 最後に、アプリ内のスタッター、最初の起動、新しいレベルのロード時間を短縮するために、アプリのビルド時にGPUバイナリを完全に生成するための新しいワークフローであるオフラインコンパイルを発表しました。

Eylon：次に、プログラムのサイズとコンパイル時間を短縮するために、ソースからコンパイルする際の新しい金属最適化モードであるサイズの最適化を提示しました。

Galo: これらの改善が、アプリやゲームがユーザーエクスペリエンスを向上させるのに役立つことを願っています。

Eylon：実行時のコンパイルコストの削減により、セットアップとロード時間が短縮され、スタッターが少なくなり、新しいワークフローが削減されます。

ご覧いただきありがとうございます。♪ ♪