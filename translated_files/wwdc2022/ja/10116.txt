10116

- こんにちは！私はケントで、CloudKitチームのエンジニアです。

CloudKitにアクセスするために使用できる新しいライブラリを紹介できることを嬉しく思います。

まず、この新しいライブラリの設定方法について説明します。

そして、スキーマを管理する方法と、CKTool JSでユーザーデータにアクセスする方法を学びます。

始めましょう！

CloudKitは、アプリのデータをコンテナ内のiCloudに保存できる永続性技術です。

アプリでCloudKitを使用することで、デバイスやウェブ上でデータを最新の状態に保つこともできます。

アプリを構築するには、Appleプラットフォーム上のCloudKitフレームワークまたはウェブ上のCloudKit JSを使用してiCloudストレージにアクセスできます。

自動化とツールを実装するために、XcodeはmacOSで使用するためのcktoolを提供します。

そして今、CKTool JSを使用して、変更を自動化し、iCloudと対話する新しい方法があります。

CKTool JSを使用すると、Xcode 13で導入されたcktoolコマンドラインユーティリティと同じ操作を実行でき、同様のユースケースをサポートしています。

実際、CKTool JSは、レコードタイプの追加やレコードのクエリなど、CloudKitコンソールの機能を実装するために使用されます。

CKTool JSを使用すると、アプリコンテナを管理し、スキーマのリセットや更新の適用などのスキーマ操作を実行できます。

これは、以前はJavaScriptではできなかったことです。

CKTool JSを使用すると、一意の識別子または複雑なクエリを使用して既存のレコードを取得できます。

また、新しいレコードを作成して更新することができます。

CKTool JSには、TypeScriptの厳密な型定義が付属しています。

これらの型定義は、クライアントライブラリの誤った使用にフラグを立て、サポートされているIDEでのコード補完を可能にするコンパイル時のチェックを可能にします。

このため、CKTool JSコードの編集が容易になります。

さらに、この新しいライブラリには、Node.jsとブラウザの両方をサポートしてすぐに付属しています。

CKTool JSはnpmパッケージのセットとして配布されており、JavaScriptビルドパイプラインの一部として統合できます。

そうすることで、ツリーシェイキングやバンドルなどの機能が可能になります。

リリース履歴はnpmから透過的に利用できるため、これらのパッケージの更新を追跡することもできます。

以下のパッケージは、CKTool JSディストリビューションの一部です。

これらのパッケージは@appleスコープ内にあり、名前の先頭にcktoolを使用する慣習に従っていることに注意してください。

使用するメインパッケージはcktool.databaseです。

iCloudとの通信を有効にするには、ターゲットプラットフォーム用の別のパッケージ、Node.js用のcktool.target.nodejs、またはWebブラウザ用のcktool.target.browserを使用する必要があります。

Cktool.databaseは、cktool.core、cktool.api.base、cktool.api.databaseの3つのパッケージを自動的に取り込みます。

CKTool JSはiCloudと直接通信するため、まず承認する必要があります。

呼び出す操作によっては、管理トークンまたはユーザートークンが必要です。

どちらの種類のトークンもCloudKitコンソールから入手できます。

管理トークンは、管理操作にアクセスするために使用され、チームとユーザーにスコープされます。

このような操作には、スキーマのインポートとエクスポートの有効化、スキーマの検証、およびコンテナを本番環境にリセットすることが含まれます。

ユーザートークンは、チームとコンテナにスコープされ、それらのコンテナ内のプライベートユーザーデータへのアクセスを可能にします。

これらの承認トークンの取得方法とCloudKitとの継続的な統合方法については、WWDC21の「cktoolと宣言型スキーマでCloudKitテストを自動化する」をチェックしてください。

スクリプトでCKTool JSを使用する場合は、まず使用するように設定する必要があります。

しかし、CKTool JSの設定に飛び込む前に、CloudKitスキーマを構成するものを簡単に確認します。

CloudKitでは、データは構造化された方法で保存されます。

同じ種類の値を持つデータは、レコードとして一緒に保存されます。

レコードはレコードタイプのインスタンスであり、レコードタイプが記述するレコードのプロパティはフィールドとして知られています。

CloudKitは、ユーザー定義のフィールドに加えて、レコードのIDであるrecordNameなどのシステムフィールドを追加します。

私が取り組んできたコインコレクションアプリの例を使います。

国のコレクションを保存したいので、保存する必要があるプロパティの種類を説明するレコードタイプがあります。

名前とISOコードを保存し、レコードタイプに「国」という名前を付けています。

ISOコードは国を一意に識別するので、私のレコードタイプにそれらを含めることが重要です。

この情報を名前と一緒に保存するために、国タイプのレコードをいくつか作成します。

私はまた、特定の国のコインの記録タイプを持っており、それらを互いに関連付けたいです。

コインレコードタイプは、コインからその国との関係を保存します。

レコードタイプと関係が組み合わさってスキーマが作成されます。

これらの要素の現在の状態は、私のスキーマの現在のバージョンであると考えることができます。

アプリを開発するにつれて、スキーマを進化させ、アプリの存続期間中、いくつかのバージョンを持つ可能性があります。

私のアプリのスキーマは、iCloudに保存したいデータの構造を説明していますが、私のアプリコンテナはそのデータが保存されている場所です。

コンテナには一意の識別子があり、開発者チームに関連付けられています。

CloudKitで作業する際に留意すべき環境は2つあります。

開発環境は、ユーザーを混乱させることなく変更を加えるのに安全な場所です。

これは、スキーマの変更をテストして開発すべき場所です。

ユーザーがアプリと対話すると、本番環境と対話します。

本番環境には、アプリのライブデータが含まれています。

CloudKitがデータを保存する方法を復習したので、CKTool JSの設定方法について説明します。

CKTool JSはiCloudと話しているので、適切なコンテナで作業する方法を知っていて、スクリプトがそうする権限を与えられるように、いくつかの情報を収集する必要があります。

チームIDと、作業したいコンテナのコンテナIDが必要です。

スキーマを操作するには管理トークンが必要で、スクリプトがデータにアクセスする場合は、ユーザートークンも必要です。

これらの値はすべて、CloudKitコンソールから取得できます。

また、スクリプトが実行される環境、開発、または本番環境を指定する必要があります。

今後、開発を例に挙げます。

使用するためにCKTool JSを設定するたびに、これらの値が必要になります。

私の例として、私はNode.jsのスクリプトを書いています。

それらを使用するために、CKTool JSからオブジェクトと関数をインポートします。

この場合、CommonJS requireステートメントを使用してこれらのシンボルをインポートできます。

設定情報を収集したら、その情報を保持するオブジェクトを作成します。

認証トークンを保存するには、管理トークンを保持するオブジェクトを作成し、ある場合はユーザートークンを作成します。

teamId、containerId、および環境はCKTool JSに渡される一般的な値であるため、これらの値を保持するオブジェクトを作成できます。

createConfigurationファクトリ関数を使用して、CKTool JSにiCloudとの会話方法を伝えるConfigurationオブジェクトをインスタンス化します。

createConfigurationはプラットフォーム固有です。

この場合、ターゲットパッケージからインポートされた関数であるため、Node.jsの適切な設定を返します。

次に、設定オブジェクトと以前に宣言されたセキュリティオブジェクトを渡して、APIオブジェクトを初期化します。

APIオブジェクトには、iCloudと通信できる非同期メソッドが含まれています。

これで、スクリプトでCKTool JSを使用する手順を完了しました。

CKTool JSを使用してコンテナのスキーマを管理する方法について学びましょう。

私のアプリでは、2007年に発行されたアメリカのダイムなどの情報を保存したいです。

このコインは銅とニッケルで構成されており、刻印された価値は1米ドルの10分の1です。

このデータの保存方法を考えた後、コインの組成に関する情報をコインに関する他の詳細とは別のレコードとして保存することにしました。

だから私はダイムの銅パーセンテージとそのニッケルパーセンテージを別々の記録に保存します。

コンテナのスキーマにしたい2つのレコードタイプを特定しました。

国の参照、発行年、名目価値を格納するコイン。

そして、それが記述するコインへの参照と、コイン内の材料とそのパーセンテージを格納するコンポーネントレコードタイプ。

アプリのスキーマを決定したので、CloudKitスキーマ言語でテキストファイルを作成して説明することができます。

慣習は、スキーマファイルに.ckdb拡張子を使用することです。

CloudKitスキーマ言語の詳細については、「テキストベースのスキーマをワークフローに統合する」のドキュメント記事を参照してください。

コンテナ用に作成したスキーマファイルは、CKTool JSを使用して適用できます。

新しいスキーマを適用する前に、通常、コンテナの開発スキーマを本番環境のものと一致するようにリセットします。

これは、resetToProductionメソッドで行うことができます。

このメソッドは、先ほど宣言したdefaultArgsオブジェクトを渡すことで呼び出します。

スキーマが本番環境にない場合は、すべてのレコードタイプが削除されます。

そうでなければ、これは開発スキーマを本番環境の状態に戻します。

これは非同期呼び出しであるため、このメソッドはpromiseオブジェクトを返すことに注意してください。

CKTool JSには、コンテナのスキーマをエクスポートおよびインポートできるメソッドがあります。

exportSchemaとimportSchemaメソッドを使用すると、これを行うことができます。コンテナの観点から名前が付けられます。

したがって、exportSchemaを使用してコンテナからエクスポートするスキーマをダウンロードし、importSchemaを使用してコンテナにインポートするスキーマをアップロードします。

これらを組み合わせることで、スキーマの進化を管理できます。

スキーマをコンテナに適用するヘルプ関数を作成できます。

まず、CKTool JSからFileオブジェクトをインポートし、Node.jsからfsとpathモジュールをインポートします。

次に、次のことを行う非同期関数を定義します。スキーマファイルの内容をNode.jsバッファに読み込みます。

アップロード用のCKTool JSファイルインスタンスを作成します。

最後に、importSchemaを使用してファイルの内容をサーバーにアップロードします。

以前に宣言されたdefaultArgsオブジェクトはimportSchemaに渡されることに注意してください。

今、あなたはそれをまとめることができます。

resetToProductionとスキーマのインポートに使用されるヘルパー関数は非同期であるため、正しい順序で実行されていることを確認する必要があります。

それをするために、あなたは約束を鎖でつなぎます。

エラーが発生した場合、約束は拒否されます。

CKTool JSの管理機能に加えて、データの読み書きもできます。

CKTool JSレコードで使用されるフィールド値は、サーバーに送信される前にクライアント側でタイプと範囲がチェックされます。

渡された値が正しい種類の値でない場合、または値の許容範囲外にある場合、例外がスローされます。

JavaScriptでネイティブに表現できない大きな数の場合、代わりに使用されるCKTool JSタイプがあります。

たとえば、CKTool JS Int64に数値を強制するには、toInt64関数を使用します。

数値をダブル浮動小数点値に強制するには、toDouble関数を使用します。

TypeScriptを書いている場合、これらの強制関数が使用されていない場合、コンパイラは誤った値型の使用法にフラグを立てます。

CKTool JSレコードのフィールド値は、フィールド値ファクトリ関数を使用して作成されます。

2007年に発行されたコインの場合、Int64を含むレコードフィールド値を作成するために、その値をmakeRecordFieldValue.int64ファクトリ関数に渡します。

一般に、ファクトリ関数が渡された値からレコードフィールド値を作成できない場合、例外がスローされます。

ここでは、レコードで動作するメソッドに送信する共通の値を保持するオブジェクトを作成しました。

containerId、environment、databaseType、zoneNameがしばしば必要であるため、このdatabaseArgsオブジェクトにそれらを含めています。

レコードを照会するには、queryRecordsメソッドを使用します。

これを簡単にするために、ユニークな3文字のISOコードに一致する国を見つけるヘルパー関数を作成します。

この場合、クエリを含む本文に加えて、databaseArgsオブジェクトの内容を渡します。

クエリオブジェクトには、recordType値と単一のフィルタオブジェクトを指定しています。

フィルタオブジェクトは、国のisoCode3がこの関数が求めているものと等しいクエリを記述します。

成功すると、見つかったレコードのコレクションはresponse.result.recordsプロパティになります。

このコレクションから最初のオブジェクトを返します。

生の値をcreateRecordが使用できるフィールド値に変換するには、これを行うためにmakeCoinFieldValuesというヘルパー関数があります。

フィールド値に変換したいコインの生のプロパティごとに、適切なRecordFieldValueファクトリ関数を呼び出します。

ただし、国のフィールドについては、参照を作成する必要があります。

渡された国別レコード名を使用して、このコインレコードから対応する国別レコードを参照します。

ここでは、コインレコードフィールドの値を取り、createRecordリクエストをサーバーに送信するヘルパー関数を作成します。

この関数では、以前に宣言されたdatabaseArgsの内容と本文を渡しています。

ボディ辞書には、recordTypeとフィールドの値が含まれています。

成功すると、response.result.recordが返されます。

ヘルパー関数を呼び出す前に、このコインから参照される正しい国レコードを取得する必要があります。

先ほど定義した国別クエリ関数を使用します。

次に、先ほど書いたmakeCoinFieldValuesヘルパー関数で作成されたフィールド値辞書を渡して、coinCreateRecordを呼び出します。

生のコインの値は、そのヘルパー関数に渡されます。

これにより、非同期にレコードが作成され、新しいレコードが返されます。

レコードを更新するには、updateRecordメソッドを使用します。

レコード名とこのヘルパーに渡されたフィールドと一致するコインを更新するヘルパー関数を作成します。

次に、databaseArgsオブジェクト、recordName、およびレコードタイプと新しいレコードのフィールド値を含むボディの内容でupdateRecordを呼び出します。

成功すると、更新されたレコードはhelper関数から返すresponse.result.recordプロパティになります。

先ほど作成したコインレコードを更新するには、このヘルパー関数を呼び出すと、レコード名とフィールド値を渡して更新します。

フィールド値はmakeCoinFieldValuesで作成されます。

レコードを削除するには、APIオブジェクトのasync deleteRecordメソッドを呼び出します。

databaseArgsオブジェクトの内容と、削除するレコードのrecordNameを渡します。

CKTool JSを知って楽しんでいただければ幸いです。

自分で試してみてください。自動化とツーリングの目的でCKTool JSを設定してください。

スキーマをリセットしてインポートし、JavaScriptを使用してデータを読み書きします。

継続的インテグレーションシナリオでのCKTool JSの使用については、GitHubのCloudKitサンプルリポジトリをチェックしてください。

また、より詳細なドキュメントについては、developer.apple.comのCKTool JSをご覧ください。

今日は参加してくれてありがとう、そしてWWDC22の残りの部分を楽しんでください。