10069

デビッド・ダンカン:こんにちは、私はデビッド・ダンカンです。このビデオでは、デスクトップクラスのiPadを紹介します。

iOS 16は、優れたアプリの設計と構築に使用されるツール、より多くのより良いツールを最前線に持ち込み、組み込みと付属の両方のすべてのハードウェアを活用するアプリに進歩をもたらします。

UIKitは、アプリのこれらの目標を達成するのに役立つ多くのツールを追加します。

UINavigationBarのアップデートにより、画面の不動産をよりよく活用し、すべてのAppleプラットフォームで素晴らしい体験を構築できます。

新しい検索と置換UIは、組み込みのビューで有効にするためのスナップであり、カスタムビューに簡単に追加できます。

編集メニューは、メニューシステムと統合する新しいインタラクションベースのAPIでオーバーホールされました。

また、コレクションビューの改善により、ユーザーがコンテンツを選択して行動できるインターフェイスの構築がこれまで以上に簡単になります。

検索と置換と編集メニューの詳細については、「デスクトップクラスの編集インタラクションを採用」を参照してください。

そして、これらすべての機能がどのように連携するかを確認するには、「デスクトップクラスのiPadアプリを構築する」をご覧ください。

このビデオでは、iOS 16用のアプリの設計方法に影響を与えるナビゲーションの変更について説明します。

1つ目は、より見つけやすいインターフェースを簡単に構築できる新機能です。

次に、ドキュメントベースのアプリにとって特に強力な機能です。

そして最後に、検索を更新して、エクスペリエンスを加速し、磨くのに役立ちます。

UINavigationBarはiOSでさまざまな目的で使用されており、iOS 16は、これらのケースの多くに新しい最適化されたUIを提供することで、それを認識しています。

UINavigationItemは、ナビゲーター、ブラウザ、エディタのスタイルから選択するために使用されるスタイルプロパティを追加します。

私は今、これらのスタイルのそれぞれに飛び込みます。

デフォルトのスタイルであるナビゲーターは、従来のUINavigationBarとまったく同じように動作します。

タイトルは中央に配置され、先頭と末尾のバーのボタンアイテムがあり、スタックに複数のアイテムがある場合には戻るボタンが表示されます。

ブラウザスタイルは、ファイルやSafariのように、履歴が場所と同じくらい重要なインターフェイスに最適化されるようにコンテンツを再配置します。

タイトルは、このスタイリングで主導的な位置に移動されます。

エディタスタイルは、主な機能がドキュメント編集の場合に最適化されています。

ブラウザのスタイルと同様に、タイトルは先頭に整列しています。

エディタUIは、多くの場合、ドキュメントピッカーでドキュメントを選択した後など、宛先であるため、そのUIに簡単にアクセスするための戻るボタンを提示します。

ブラウザとエディタのスタイルはどちらも、バーの中央に多くのスペースを解放します。

iOS 16は、この地域に追加のコントロールを配置できるようにすることで、この解放されたスペースを利用します。

センターアイテムは、画面の不動産をよりよく活用するための一連の変更の一部であり、UIBarButtonItemGroupのサポート、カスタマイズサポート、オーバーフローが含まれます。

オーバーフローサポートはすべてのモードで利用でき、ナビゲータースタイルはセンターアイテムも間接的にサポートできます。

個々のコントロールは引き続きUIBarButtonItemsとして指定されますが、現在はUIBarButtonItemGroupsとして整理されています。

これにより、スペースが限られているときに、より密度の高いプレゼンテーションが可能になります。

この例では、バーには5つの項目があり、4つのグループで構成されています。

最初のグループには単一のバーボタン項目が含まれているため、この例ではUIBarButtonItemの便利なメソッド、creatingFixedGroup（）を使用して作成します。

複数のアイテムを持つ固定グループが必要な場合は、代わりにUIBarButtonItemGroupメソッドを使用できます。

固定グループは常にバーの最初に表示され、カスタマイズによって削除または移動することはできません。

描画グループには単一のアイテムが含まれているため、便利なAPIであるcreatingMovableGroup（customizationIdentifier）も使用します。

固定グループと同様に、可動グループは削除できませんが、移動は可能です。

このため、位置を追跡して保存できるように、customizationIdentifierが必要です。

複数のアイテムを持つグループが必要な場合は、代わりにUIBarButtonItemGroupメソッドを使用できます。

図形グループには複数のアイテムが含まれているため、UIBarButtonItemGroup APIを使用してグループを作成します。

このグループは、バー内で移動可能で、取り外し可能でなければならないため、オプションのグループとして作成されます。

このグループは、representingItemも指定し、UIKitがグループを折りたたむことで、必要に応じてスペースを節約できます。

representativeItemはアクションを指定せず、さらにUIKitがグループ内のアイテムを選択できるメニューを合成できるようにします。

カスタマイズUIが呼び出されると、UIKitはグループの作成方法に基づいて指定したルールを自動的に適用します。

固定および可動グループはバーにとどまる必要がありますが、オプションのグループは任意の数で追加または削除できます。

UIKitは、バーでできるだけ多くの機能を維持するためにグループを折りたたみしようとしますが、スペースが利用できない場合、余分なアイテムはオーバーフローに移動します。

オーバーフローメニューには、カスタマイズの一部であるがバーに収まらないアイテムと、バーをカスタマイズするオプションが含まれています。

UIKitは各バーボタン項目のデフォルトのメニュー要素を合成しますが、必要に応じてメニュー表現をカスタマイズするオプションがあります。

最後に、この例ではカスタマイズを有効にし、centerItemGroupsを追加します。

UINavigationItem.customizationIdentifierを設定することで、カスタマイズを有効にします。

customizationIdentifierは、バーのユニークなカスタマイズを定義するので、アプリ内の他のカスタマイズと競合しない文字列を選択します。

UIKitは、この識別子に基づいてカスタマイズを自動的に保存および復元します。

次に、centerItemGroups自体を提供します。

私がすでにカバーした最初の4つのグループ。

フォーマットグループは、デフォルトのカスタマイズにないオプションのグループであるため、このコードはisInDefaultCustomizationパラメータのデフォルト値を上書きして除外します。

UINavigationItem.customizationIdentifierを設定しなくてもcenterItemGroupsを使用できますが、カスタマイズは利用できません。

Mac Catalystでは、UINavigationBarは自動的にコンテンツをNSToolbarに変換します。

先頭、中央、末尾のアイテムグループが順番に追加され、NSToolbarのカスタマイズを使用する場合、センターアイテムグループのカスタマイズプロパティが尊重されます。

予想されるNSToolbarの動作はすべて、タイトルやウィンドウプロキシなどの他のプロパティも利用できます。

これらはすべて、Mac用に最適化するとデフォルトで発生します。

次に、特に文書を扱うときに、強力なインタラクションに焦点を当てましょう。

UINavigationBarは、タイトルビューにメニューを追加することをサポートし、コンテンツ全体を操作するアクションを追加するための中央の場所を提供します。

さらに、共有シートのサポートを追加し、このメニューからドラッグ&ドロップすることもできます。

まず、メニュー項目自体に焦点を当てます。

有効にすると、デフォルトのタイトルメニューには、複製、移動、名前変更、エクスポート、印刷の5つのコマンドが提供されます。

これらのアイテムは、レスポンダーチェーンの特定の方法に基づいてフィルタリングされます。

UINavigationBarは名前変更を具体的にサポートしているため、renameDelegateを実装した場合にも含まれます。

タイトルメニューを有効にするには、表示する最終メニューを返すクロージャであるtitleMenuProviderを設定します。

クロージャには、提案された要素の配列が渡されます。

これらをそのまま使用したり、フィルタリングしたり、自分で追加したりできます。

この例では、メニューに1つのアクションを追加しています。

最後に、構成されたUIMenuを返します。

タイトルメニューでは、アクティビティビューコントローラーを介して共有したり、ドラッグ&ドロップをサポートしたりすることもできます。

これらの機能を有効にするには、ドキュメントを説明するUIDocumentPropertiesインスタンスを提供します。

UIDocumentPropertiesは、プレビューを含むドキュメントに関するメタデータを表します。

この例では、URLを使用して作成し、UIKitが必要なメタデータを自動的に取得できるようにします。

追加機能を有効にするために、この例では、ドキュメントを表すNSItemProviderを作成します。

dragItemsProviderを設定して、ドラッグ&ドロップを有効にします。

このクロージャはUIDragSessionを過ぎ、UIDragItemsの配列を返します。

この例では、文書を表す単一の項目を返します。

activityViewControllerProviderを設定すると、共有が可能になります。

このクロージャは、UIActivityViewControllerを設定して返します。

最後に、入力されたオブジェクトをUINavigationItem.documentPropertiesに割り当て、タイトルをタップすると、UIKitは他のtitleMenuアイテムと一緒にヘッダーを表示します。

Mac Catalystでは、titleMenuProviderに渡される提案された項目がファイルメニューにすでに存在します。

タイトルメニューに追加したアイテムは、他の手段で利用できるようにする必要があります。

UIMenuBuilder APIを使用して、これらのアイテムを追加したり、必要に応じて既存のアイテムをフィルタリングしたりできます。

ドキュメントのプロパティを指定すると、UIKitは自動的に提供されたURLを使用してmacOSプロキシアイコンを管理します。

windowSceneの representedURLを手動で設定すると、UIKitの管理に取って代わられます。

UIKitは、名前の変更を有効にするための2つのメカニズムを提供します。

インラインリネームは、UINavigationItem.renameDelegateを設定することで提供され、すべてのプラットフォームでタイトルを編集するための専用のUIを提供します。

完了すると、結果の名前がデリゲートに渡されます。

または、UIResponder.rename(_:)を実装し、お好みのUIを提供することで、名前変更体験を完全に制御することもできます。

iOSでは、UINavigationBarはタイトルビュー内で直接名前変更UIを提供します。

macOSでは、ナビゲーションバーがNSToolbarでホストされている場合、名前変更UIはウィンドウのタイトルによって提供されます。

インラインリネームを実装するには、UINavigationItemRenameDelegateプロトコルに準拠し、ナビゲーションアイテムのrenameDelegateを設定します。

ユーザーが受け入れたタイトルを受け取るために使用される、必要なメソッド、navigationItem(_:didEndRenamingWith:)は1つだけです。

ファイルベースのアプリの場合、UIDocumentBrowserViewControllerは名前が変更されたAPIを提供するようになりました。

検索は、最も重要なデータを見つけるユーザーの数であり、iOS 16の進歩により、優れた検索体験を提供することが容易になります。

最初に注意すべきことは、iPadOSのナビゲーションバーとmacOSのツールバーに並ぶことで、検索の占有スペースが少なくなるということです。

iPadOSでは、UINavigationItem .preferredSearchBarPlacementで古い動作を復元できます。

さらに、検索バーはボタンに折りたたむことで、他のコントロールのためのより多くのスペースを与えることができます。

検索を有効にすると、検索候補が表示され、更新された検索クエリと一緒に更新できるため、ユーザーの検索を支援する機会が得られます。

次に、検索候補を設定するために必要なコードについて説明します。

検索候補を管理するには、UISearchResultsUpdateatingに準拠し、searchControllerのsearchResultsUpdaterを設定します。

これにより、クエリの変更に応じて提案を更新し、選択した検索提案に基づいて行動することができます。

クエリが変更されると、updateSearchResults(for:)が呼び出され、検索候補を更新できます。

どのような提案を提供するかはあなた次第です。

空の配列を設定すると、提案UIがクリアされます。

UIKitは、提案コンテンツを指定するためのUISearchSuggestionItemを提供します。

提案の選択に対応するには、updateSearchResults(for:selecting:)を実装します。

この方法は、選択した検索提案を渡すので、適切に反応することができます。

この例では、現在のクエリを検索提案で指定されたクエリに置き換えて検索を更新します。

UISearchTextFieldにはsearchSuggestionsもあるので、そのクラスを単独で使用したい場合は、検索候補を実装できます。

しかし、UISearchControllerを使用している場合は、代わりにそのプロパティを使用する必要があります。

iOS 16では、UIKitはユーザーに生産性を高めるのに役立つ新しいAPIを提供します。

センターアイテムとタイトルメニューを使用して、高度な機能にさらなる発見可能性をもたらします。

ナビゲーションバーから直接ドラッグ&ドロップと共有を提供することで、ドキュメントのサポートを改善します。

検索の提案を提供することで、検索をより簡単かつ迅速にし、ほぼゼロの労力で箱から出してすぐに素晴らしいMac体験を得ることができます。

このビデオを見てくれてありがとう。

デスクトップクラスになるようにアプリをどのように強化するかを見るのが待ちきれません!

。