110353

♪ ♪

こんにちは、私はスウィフトコンパイラチームのスラヴァです。

スウィフトでプロトコルインターフェイスを設計することへようこそ。

Embrace Swift Genericsの話が中断したところをピックアップし、具体的なタイプを抽象化し、プロトコルを使用してタイプ関係をモデル化するための高度なテクニックを紹介します。

この講演では、既存の言語機能と、Swift 5.7で導入された新機能の両方について説明します。

この講演には3つの主要なテーマがあります。まず、「結果型消去」がどのように機能するかを説明することで、関連するタイプのプロトコルが実存的な「任意の」タイプとどのように相互作用するかを紹介します。

次に、不透明な結果タイプを使用して、インターフェイスを実装から分離してカプセル化を改善することを説明します。

最後のトピックでは、プロトコルの同じタイプの要件が、複数の異なるセットの具体的なタイプ間の関係をモデル化する方法を見ていきます。

関連する型を持つプロトコルが実存型とどのように相互作用するかを学ぶことから始めましょう。

ここでは、一対のプロトコルと4つの具体的なタイプを持つデータモデルがあります。

動物には鶏と牛の2種類と、卵と牛乳の2種類の食べ物があります。

鶏は卵を生産し、牛は牛乳を生産する。

食品の生産を抽象化するために、Animalプロトコルにproduce()メソッドを追加します。

「Embrace swift generics」の話から、CowとChickenでproduce（）の異なるリターンタイプを抽象化する最善の方法は、関連するタイプを使用することであることを覚えているかもしれません。

関連するタイプを使用することで、次のように宣言します。特定のタイプの動物が与えられた場合、produce()を呼び出すと、具体的な動物タイプに依存する特定のタイプの食品が返されます。

この関係を図で示すことができます。

プロトコル「セルフ」タイプは、「動物」プロトコルに準拠した実際の具体的なタイプを表します。

「セルフ」タイプには、関連する「商品」タイプがあり、「食品」に準拠しています。

具体的な鶏と牛のタイプの関係と、動物プロトコルの関連タイプ図を見てみましょう。

チキンタイプは、CommodityTypeの「Egg」で動物プロトコルに準拠しています。

そして、牛のタイプは「牛乳」の商品タイプの動物プロトコルに準拠しています。

さて、動物でいっぱいの農場があるとしましょう。

農場の「動物」の保管財産は、「任意の動物」の異質な配列です。

スウィフトジェネリックを取り入れて、私たちは「任意の動物」タイプが、任意の具体的なタイプの動物を動的に格納する能力を持つボックス表現を持っている方法を見ました。

異なる具体的なタイプに同じ表現を使用するこの戦略は、タイプ消去と呼ばれます。

produceCommodities()メソッドは、動物の配列をマップし、それぞれでproduce()メソッドを呼び出します。

この方法はシンプルに見えますが、型消去は動物の根底にあるタイプの静的型関係を排除することを知っているので、このコード型がチェックする理由を理解するために深く掘り下げる価値があります。

Map() クロージャの 'animal' パラメータのタイプは 'any Animal' です。

'Produce()' の戻り値の型は、関連する型です。

実存型で関連する型を返すメソッドを呼び出すと、コンパイラは型消去を使用して呼び出しの結果型を決定します。

型消去は、これらの関連する型を、同等の制約を持つ対応する実存型に置き換えます。

具体的な動物タイプと関連する商品タイプとの関係を「任意の動物」と「任意の食品」に置き換えることで消去しました。

「Any Food」というタイプは、関連するCommodityTypeの上限と呼ばれます。

Produce()メソッドは「any Animal」で呼び出されるため、戻り値は型が消去され、型「any Food」の値が与えられます。

これはまさに私たちがここで期待するタイプです。

Swift 5.7の新機能である、関連タイプの消去がどのように機能するかを詳しく見てみましょう。

矢印の右側にあるプロトコルメソッドの結果タイプに表示される関連するタイプは、メソッドを呼び出すとこのタイプの値が生成されるため、「生成位置」にあると言われています。

このメソッドを「任意の動物」で呼び出すと、コンパイル時に具体的な結果タイプはわかりませんが、それが上限のサブタイプであることはわかっています。

この例では、実行時に牛を保持する「任意の動物」でproduce()を呼び出しています。

私たちの場合、Cowのproduce()メソッドはMilkを返します。

牛乳は、関連する動物プロトコルのCommodityTypeの上限である「任意の食品」の中に保存することができます。

これは、動物のプロトコルに準拠したすべての具体的なタイプに対して常に安全です。

一方、関連するタイプがメソッドまたは初期化子のパラメータリストに表示された場合に何が起こるかを考えてみましょう。

ここでは、Animalプロトコルのeat()メソッドは、消費位置に関連付けられたFeedTypeを持っています。

メソッドを呼び出すには、このタイプの値を渡す必要があります。

変換が他の方向に進むため、タイプ消去は実行できません。

関連するタイプの上限実存タイプは、コンクリートタイプが不明であるため、安全に実際のコンクリートタイプに変換されません。

例を見てみましょう。 例を見てみましょう。

もう一度、私たちは牛を保管している「任意の動物」を持っています。

牛の「食べる」方法が干し草を取ると仮定します。

Animalプロトコルに関連する「FeedType」の上限は「any AnimalFeed」です。

しかし、任意の「任意のAnimalFeed」が与えられた場合、「Hay」コンクリートタイプを格納することを静的に保証する方法はありません。

タイプ消去では、消費位置で関連するタイプを操作することはできません。

代わりに、不透明な「some」型を取る関数に渡すことによって、実存的な「any」型をボックス解除する必要があります。

関連するタイプを使用したこのタイプの消去動作は、実際にはSwift 5.6で見た可能性のある既存の言語機能に似ています。

参照型を複製するためのプロトコルを検討してください。

このプロトコルは、Self を返す単一の clone() メソッドを定義します。

タイプ 'any Cloneable' の値で clone() を呼び出すと、結果タイプ 'Self' は上限までタイプ消去されます。

Selfタイプの上限は常にプロトコル自体であるため、タイプ「any Cloneable」の新しい値を取り戻します。

要約すると、「any」を使用して、値のタイプがプロトコルに準拠した具体的なタイプを格納する実存的なタイプであることを宣言できます。

これは、関連するタイプを持つプロトコルでも機能します。

生成位置に関連付けられた型を持つプロトコルメソッドを呼び出すとき、関連付けられた型は、関連する型の制約を運ぶ別の実存型である上限まで型消去されます。

具体的な型を抽象化することは、関数入力だけでなく、関数出力にも役立つため、具体的な型は実装からのみ表示されます。

具体的な結果型を抽象化して、コードの本質的なインターフェイスを実装の詳細から分離し、変更に直面して静的型の割り当てをよりモジュール化して堅牢にする方法を見てみましょう。

動物に餌を与えることを許可するように、動物のプロトコルを一般化しましょう。

動物は空腹になり、お腹が空いたら食べる必要があります。

AnimalプロトコルにisHungryプロパティを追加しましょう。

FarmのfeedAnimals()メソッドは、空腹の動物のサブセットを養います。

空腹の動物のこのサブセットの計算を空腹の動物プロパティに分割しました。

この hungryAnimals() の初期実装では、filter() メソッドを使用して、isHungry プロパティが true である動物のサブセットを選択します。

「Any Animal」の配列でfilter()を呼び出すと、「any Animal」の新しい配列が返されます。

これで、feedAnimals（）は hungryAnimalsの結果を一度だけ反復し、すぐにこの一時的な配列を破棄することに気付くかもしれません。

農場に多数の飢えた動物が含まれている場合、これは非効率的です。

この一時的な割り当てを回避する1つの方法は、標準ライブラリの遅延コレクション機能を使用することです。

「Filter」の呼び出しを「lazy.filter」に置き換えることで、遅延コレクションと呼ばれるものを取得します。

遅延コレクションは、「フィルター」へのプレーン呼び出しによって返される配列と同じ要素を持っていますが、一時的な割り当てを回避します。

しかし、今、「hungryAnimals」プロパティのタイプは、このかなり複雑な具体的なタイプ「LazyFilterSequence of Array of any Animal」として宣言する必要があります。

これにより、不要な実装の詳細が公開されます。

クライアントのfeedAnimals()は、「hungryAnimals」の実装で「lazy.filter」を使用したことを気にしません。反復できるコレクションを取得していることを知る必要があるだけです。

不透明な結果タイプは、コレクションの抽象的なインターフェイスの後ろに複雑な具体的なタイプを隠すために使用できます。

現在、「hungryAnimals」を呼び出すクライアントは、コレクションプロトコルに準拠した具体的なタイプを取得していることしか知りませんが、特定の具体的なタイプのコレクションは知りません。

しかし、書かれているように、これは実際にはクライアントからあまりにも多くの静的型情報を隠します。

hungryAnimalsがコレクションに準拠した具体的なタイプを出力することを宣言していますが、このコレクションの要素タイプについては何も知りません。

要素タイプが「任意の動物」であるという知識がなければ、要素タイプでできることは、それを渡すことだけです。動物プロトコルのメソッドを呼び出すことはできません。

不透明な結果タイプ「いくつかのコレクション」に焦点を当てましょう。

制約された不透明な結果タイプを使用することで、実装の詳細を隠すことと、十分に豊富なインターフェイスを公開することの間で適切なバランスを取ることができます。

制約された不透明な結果タイプは、Swift 5.7で新しいものです。

制約された不透明な結果型は、プロトコル名の後に型引数を角括弧で適用することによって記述されます。

コレクションプロトコルには、要素タイプという単一の型引数があります。

「hungryAnimals」が制約された不透明な結果タイプで宣言されると、それが実際に「任意の動物の配列のLazyFilterSequence」であるという事実はクライアントから隠されます。しかし、クライアントはまだそれがコレクションに準拠したいくつかの具体的なタイプであり、その要素に関連するタイプは「任意の動物」に等しいという知識を持っています。

これはまさに私たちがここで欲しいインターフェースです。

「feedAnimals（）」のforループ内では、「animal」変数は「any Animal」というタイプを持ち、各空腹の動物に対してAnimalプロトコルのメソッドを呼び出すことができます。

コレクションプロトコルは、要素関連タイプがプライマリ関連タイプであることを宣言しているため、これはすべて機能します。

このように、プロトコル名の後に1つ以上の関連タイプを角括弧で命名することで、プライマリ関連タイプで独自のプロトコルを宣言できます。

プライマリ関連型として最もよく機能する関連型は、コレクションのイテレータ型などの実装の詳細とは対照的に、コレクションの要素型など、通常呼び出し主によって提供される型です。

多くの場合、プロトコルの主要な関連タイプと、このプロトコルに準拠した具体的なタイプの一般的なパラメータとの間の対応が表示されます。

ここでは、「コレクション」の要素プライマリ関連タイプが、コレクションに準拠した標準ライブラリによって定義された2つの具体的なタイプである配列とセットの「要素」汎用パラメータによって実装されていることがわかります。

「要素のコレクション」は、「some」キーワードを使用した不透明な結果型と、「any」キーワードを使用した制約された実存型で使用できます。

Swift 5.7以前は、特定の一般的な引数を持つ実存型を表すために、独自のデータ型を書く必要がありました。

Swift 5.7は、この概念を制約された実存型を持つ言語に組み込みます。

hungryAnimalsに、 hungryAnimalsを怠惰に計算するか熱心に計算するかの選択肢を持ちたい場合、動物の不透明なコレクションを使用すると、関数が2つの異なる基礎となるタイプを返すというエラーが発生します。

代わりに「任意の動物の任意のコレクション」を返すことでこれを修正でき、このAPIは呼び出し間で異なるタイプを返すことができることを通知します。

主要な関連型を制限する能力は、不透明な型と実存型に新しいレベルの表現力を与えます。

これは、コレクションなどのさまざまな標準ライブラリプロトコルで使用できます。また、プライマリ関連タイプを持つように独自のプロトコルを宣言することもできます。

不透明な型を使用してジェネリックコードを書くには、抽象型関係に依存する必要があります。

関連するプロトコルを使用して、複数の抽象型間の必要な型関係を特定し、保証する方法について話し合いましょう。

この動物が食べる具体的なタイプの動物飼料の動物プロトコルに新しい関連タイプと、動物にこのタイプの飼料を消費するように指示するeat()メソッドを追加します。

物事をより面白くするために、私は追加の合併症を紹介します:動物に餌を与える前に、適切な種類の作物を栽培し、飼料を生産するために作物を収穫する必要があります。

これがコンクリートタイプの最初のセットです。

牛は干し草を食べるので、牛が与えられたら、まず干し草を育てる必要があります。

これは、牛が食べることができる干し草に収穫され、加工されるアルファルファを私たちに与えます。

これがコンクリートタイプの2番目のセットです。

鶏は傷を食べるので、鶏を持ってきたら、まずキビと呼ばれる種類の穀物を栽培し、それを収穫し、鶏の傷を生産するために処理し、それを鶏に与える必要があります。

これら2つのセットの関連する具体的なタイプを抽象化したいので、feedAnimal（）メソッドを一度実装し、牛と鶏の両方、および将来採用する可能性のある新しいタイプの動物に餌を与えることができます。

feedAnimal（）は、消費位置に関連付けられたタイプを持つAnimalプロトコルのeat（）メソッドと連携する必要があるため、feedAnimal（）メソッドがパラメータタイプとして「some Animal」を取ることを宣言することで、実存的なボックスをアンボックスします。

まず、これまでのプロトコルと関連するタイプについて知っていることを使用して、AnimalFeedとCropのプロトコルのペアを定義します。

AnimalFeedにはCropに準拠する関連するCropTypeがあり、CropにはAnimalFeedに準拠した関連するFeedTypeがあります。

以前と同様に、各プロトコルのタイプパラメータの図を見ることができます。

まず、AnimalFeedを見てみましょう。

すべてのプロトコルには「セルフ」タイプがあり、これは具体的な適合タイプを表します。

当社のプロトコルには、Cropに準拠する「CropType」が関連付けられています。

関連する「CropType」には、AnimalFeedに準拠したネストされた関連する「FeedType」があり、Cropに準拠したネストされた関連する「CropType」などがあります。

実際、この往復は、AnimalFeedとCropに準拠する関連するタイプの無限のネスティングで永遠に続きます。

クロッププロトコルでは、同様の状況があり、1つだけシフトしています。

「Self」タイプから始めて、AnimalFeedに準拠した関連する「FeedType」を持つ「Crop」に準拠します。

これにはネストされた「CropType」があり、Cropなどに準拠しています...

無限に。

これらのプロトコルが具体的なタイプ間の関係を正しくモデル化しているかどうか見てみましょう。

動物に餌を与える前に、正しい種類の動物飼料に処理される作物を栽培する必要があることを思い出してください。

grow()は、AnimalFeedプロトコルの静的メソッドです。つまり、AnimalFeedに準拠した特定の値ではなく、AnimalFeedに準拠した型で直接呼び出す必要があります。

AnimalFeedに準拠したタイプの名前を書き留める必要がありますが、私たちが持っているのは、Animalに準拠した特定の値、別のプロトコルです。

さて、この値のタイプを取得することができます。これは、Animalに準拠したタイプであり、AnimalにはAnimalFeedに準拠した関連するFeedTypeがあります。

この型は、メソッド呼び出し grow() のベースとして使用できます。

AnimalFeedの grow() メソッドは、AnimalFeed のネストされた関連する CropType 型の値を返します。

CropTypeがCropに準拠していることを知っているので、harvest()を呼び出すことができます。

でも、何に戻らいいの?

Harvest() は、Crop プロトコルの関連する FeedType を返すと宣言されています。

私たちの場合、通話のベースは(いくつかの動物)です。FeedType.CropType、harvest()はタイプ(一部の動物)の値を出力します。FeedType.CropType.FeedType。

残念ながら、これは間違ったタイプです。

(Some Animal) の eat() メソッドは (some Animal) を期待します。フィードタイプではなく(いくつかの動物)。FeedType.CropType.FeedType。

プログラムはうまく入力されていません。

これらのプロトコルの定義は、書かれているように、動物飼料の種類から始めて、この作物を栽培して収穫した場合、私たちが始めたのと同じ種類の動物飼料を取り戻すことを実際には保証するものではありません。

それについて考えるもう1つの方法は、これらのプロトコル定義が一般的すぎるということです - 彼らは私たちの具体的なタイプ間の望ましい関係を正確にモデル化しません。

理由を理解するために、干し草とアルファルファの種類を見てみましょう。

干し草を育てるとアルファルファ、アルファルファを収穫すると干し草などを手に入れます。

今、私がコードをリファクタリングしていて、Hayの代わりにScratchを返すようにAlfalfaのharvest()メソッドの戻り値タイプを誤って変更したと想像してください。

この偶発的な変更の後、具体的なタイプは、作物の栽培と収穫が私たちが始めたのと同じ種類の動物飼料を生産するという望ましい不変量に違反しているにもかかわらず、動物飼料と作物プロトコルの要件を満たしています。

AnimalFeedプロトコルをもう一度見てみましょう。

ここでの本当の問題は、ある意味では、明確な関連タイプが多すぎるということです。

これらの関連するタイプのうち2つが実際には同じ具体的なタイプであるという事実を書き留める必要があります。

これにより、誤って書かれた具体的なタイプが当社のプロトコルに準拠するのを防ぎます。また、feedAnimal（）メソッドに必要な保証を与えます。

「Where」句で書かれた同じタイプの要件を使用して、これらの関連タイプ間の関係を表現できます。

同じタイプの要件は、2つの異なる、おそらくネストされた関連タイプが実際には同じ具体的なタイプでなければならないという静的な保証を表します。

ここで同じタイプの要件を追加すると、AnimalFeedプロトコルに準拠した具体的なタイプに制限が課されます。

ここでのこの同じタイプの要件では、「Self dot CropType dot FeedType」が「Self」と同じタイプであることを宣言しています。

私たちの図では、これはどのように見えますか?

さて、それを視覚化する方法は次のとおりです。AnimalFeedに適合する各具体的なタイプには、Cropに適合するCropTypeがあります。

しかし、このCropTypeのFeedTypeは、AnimalFeedに準拠した他のタイプではなく、元のAnimalFeedと同じコンクリートタイプです。

ネストされた関連タイプの無限のタワーの代わりに、私はすべての関係を関連する関連タイプの単一のペアに崩壊させました。

「クロップ」プロトコルはどうですか?

ここでは、作物のFeedTypeは一対の型に崩壊しましたが、まだ関連するタイプが多すぎます。

クロップのフィードタイプのクロップタイプは、最初に始めたクロップと同じタイプだと言いたい。

これら2つのプロトコルに同じタイプの要件が装備されているので、「feedAnimal（）」メソッドを再検討することができます。

私たちは以前のように、いくつかの動物の種類から始めます。

そして、動物の飼料の種類を取得しますが、これはAnimalFeedプロトコルに準拠していることがわかっています。

この作物を育てるとき、私たちはいくつかの動物の飼料タイプの作物タイプを得ます。

しかし、今、この作物を収穫するとき、さらに別のネストされた関連タイプを取得する代わりに、私たちは正確に私たちの動物が期待する飼料タイプを取得し、幸せな動物は現在、私たちが育てたばかりの正しい種類の動物飼料を食べることが保証されています。

最後に、これまでに見てきたすべてをまとめるアニマルプロトコルの関連タイプ図を見てみましょう。

適合タイプの2つのセットは次のとおりです。まず、牛、干し草、アルファルファがあります。

第二に、チキン、スクラッチ、ミレーがあります。

私たちの3つのプロトコルが、3つの具体的なタイプの各セット間の関係を正確にモデル化する方法に注目してください。

データモデルを理解することで、同じタイプの要件を使用して、これらの異なるネストされた関連タイプ間の等価性を定義できます。

汎用コードは、プロトコル要件への複数の呼び出しを連鎖するときに、これらの関係に頼ることができます。

このセッションでは、タイプ消去がいつ安全か、いつタイプ関係が保証されるコンテキストにいる必要があるかを探りました。

次に、リッチ型情報を保存することと、不透明な結果型と実存型の両方で使用できるプライマリ関連型を使用して実装の詳細を隠すことの間で適切なバランスを取る方法について説明しました。

最後に、関連するタイプのセットを表すプロトコル全体で同じタイプの要件を使用して、具体的なタイプのセット間のタイプ関係を特定し、保証する方法を見ました。

参加してくれてありがとう。 

私はあなたが素晴らしいWWDCを持っていることを願っています。