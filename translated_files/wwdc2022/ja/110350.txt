110350

♪ ♪

スウィフト並行性の視覚化と最適化へようこそ。

私の名前はマイクで、スウィフトのランタイムライブラリに取り組んでいます。

こんにちは、私はHarjasで、楽器に取り組んでいます。

一緒に、Instruments 14で利用可能な新しい視覚化ツールを含め、Swift Concurrencyコードをよりよく理解し、より速くする方法について話し合います。

Swift Concurrencyのさまざまな部分とそれらがどのように連携するかを本当に簡単に要約して、スピードアップしていることを確認しましょう。

その後、新しい並行性機器をデモします。

Swift Concurrencyを使用するアプリで実際のパフォーマンスの問題を解決するために、それを使用する方法を紹介します。

最後に、スレッドプールの枯渇と継続誤用の潜在的な問題と、それらを回避する方法について説明します。

昨年、私たちはSwift Concurrencyを導入しました。

これは、非同期/待機、構造化並行性、およびアクターを含む新しい言語機能でした。

それ以来、Appleの内外で、これらの機能が大量に採用されていることを嬉しく思います。

Swiftの並行性は、同時プログラミングをより簡単かつ安全にするために連携する言語にいくつかの新機能を追加します。

Async/awaitは、同時コードの基本的な構文ビルディングブロックです。

実行の途中で作業を中断し、実行スレッドをブロックすることなく、後でその作業を再開できる関数を作成して呼び出すことができます。

タスクは、並行コードの基本的な作業単位です。

タスクは並行コードを実行し、その状態と関連するデータを管理します。

それらはローカル変数を含み、キャンセルを処理し、非同期コードの実行を開始および一時停止します。

構造化された並行性により、子タスクを生成して並行して実行し、完了するのを待つことが容易になります。

この言語は、作業をグループ化して維持し、タスクが待たれるか、使用しない場合は自動的にキャンセルされることを保証する構文を提供します。

アクターは、共有データにアクセスする必要がある複数のタスクを調整します。

彼らは外部からデータを分離し、一度に1つのタスクのみが内部状態を操作することを許可し、同時突然変異からデータレースを回避します。

Instruments 14の新機能では、アプリでこのアクティビティをすべてキャプチャして視覚化できる一連の機器を導入し、アプリが何をしているのかを理解し、問題を特定し、パフォーマンスを向上させるのに役立ちます。

Swift Concurrencyの基礎をより深く議論するために、関連ビデオセクションにリンクされているこれらの機能に関するいくつかのビデオがあります。

Swift Concurrencyコードを使用したアプリの最適化を見てみましょう。 アプリの最適化を見てみましょう。

迅速な並行性により、正しい並行コードと並列コードを簡単に書くことができます。

しかし、並行性構造を悪用するコードを書くことはまだ可能です。

それらを正しく使用することも可能ですが、あなたが目指していたパフォーマンスの利点を得られない方法で。

Swiftの並行性を使用してコードを書くときに発生する可能性のあるいくつかの一般的な問題があり、パフォーマンスの低下やバグを引き起こす可能性があります。

メインアクターのブロックにより、アプリがハングする可能性があります。

アクターの競合とスレッドプールの枯渇は、並列実行を減らすことでパフォーマンスを低下させます。

継続的な誤用は、リークやクラッシュを引き起こします。

新しいSwift並行性インストゥルメントは、これらの問題を発見して修正するのに役立ちます。

メインアクターのブロッキングから始めて、これらのそれぞれを見てみましょう。

メインアクターブロックは、ロングランのタスクがメインアクターで実行されたときに発生します。

メインアクターは、メインスレッドですべての作業を実行する特別なアクターです。

UI作業はメインスレッドで行う必要があり、メインアクターではUIコードをSwift Concurrencyに統合できます。

ただし、メインスレッドはUIにとって非常に重要であるため、利用可能である必要があり、長時間の作業ユニットで占有することはできません。

これが起こると、アプリがロックされているように見え、応答しなくなります。

メインアクターで実行されているコードは、すぐに終了し、作業を完了するか、メインアクターからバックグラウンドに計算を移動する必要があります。

作業は、通常のアクターまたは切り離されたタスクに入れることで、バックグラウンドに移動できます。

UIを更新したり、メインスレッドで実行する必要がある他のタスクを実行するために、メインアクターで小さな作業ユニットを実行できます。

これのデモを見てみましょう。 アクション。

ありがとう、マイク。

ここにファイルスクイーザアプリケーションがあります。

フォルダ内のすべてのファイルをすばやく圧縮できるように、このアプリケーションを構築しました。

小さなファイルでは問題ないようです。

ただし、より大きなファイルを使用すると、予想よりもはるかに時間がかかり、UIは完全にフリーズし、いかなるインタラクションにも応答しません。

この動作はユーザーにとって非常に不快であり、アプリケーションがクラッシュしたか、決して終わらないと思わせる可能性があります。

私たちは、最高のユーザーエクスペリエンスのために、UIが常に応答するように努力する必要があります。

このパフォーマンスの問題を調査するために、Instrumentsで新しいSwift Concurrencyテンプレートを使用できます。

Swift TasksとSwift Actorsのインストゥルメントは、並行性コードを視覚化して最適化するのに役立つツールの完全なスイートを提供します。

パフォーマンスの問題を調査し始めたばかりのときは、まずSwift Tasks機器が提供するトップレベルの統計を確認する必要があります。

1つ目は実行中のタスクで、同時に実行されているタスクの数を示します。

次に、Alive Tasksがあり、特定の時点で存在するタスクの数を示します。

そして最後に、合計タスク; その時点までに作成されたタスクの総数をグラフ化します。

アプリケーションのメモリフットプリントを削減しようとするときは、AliveとTotal Tasksの統計を詳しく調べる必要があります。

これらすべての統計を組み合わせることで、コードがどれだけ並列化されているか、どれだけのリソースを消費しているかがよくわかります。

この機器の多くの詳細ビューの1つは、タスクフォレストです。このウィンドウの下半分に示されているように、構造化された並行性コード内のタスク間の親子関係のグラフィカルな表現を提供します。

次に、タスクサマリービューがあります。

これは、各タスクが異なる州で費やす時間を示しています。

タスクを右クリックして、選択したタスクに関するすべての情報を含むトラックをタイムラインに固定できるようにすることで、ビューをスーパーチャージしました。

これにより、非常に長い間実行されているか、アクターへのアクセスを待って立ち往生している可能性のある関心のあるタスクをすばやく見つけて学ぶことができます。

Swiftタスクをタイムラインに固定すると、4つの重要な機能があります。

まず、Swiftタスクがどのような状態にあるかを示すトラックです。

次に、拡張詳細ビューのタスク作成バックトレースです。

第三に、スウィフトタスクの状態に関するより多くのコンテキストを提供する物語的なビューです。

たとえば、タスクを待っている場合は、どのタスクを待っているかを通知します。

最後に、サマリービューで行ったのと同じピンアクションにアクセスできます。

したがって、子タスク、スレッド、さらにはスウィフトアクターをタイムラインに固定することができます。

この物語のビューは、Swiftタスクが他の並行性プリミティブやCPUとどのように関連しているかを見つけるのに役立ちます。

新しい機器のいくつかの機能の概要を見たので、アプリケーションをプロファイリングし、コードを最適化しましょう。

Xcodeでプロジェクトをプルアップし、Command-Iを押すことでこれを行うことができます。

これにより、アプリケーションがコンパイルされ、機器が開かれ、File Squeezerアプリケーションにターゲットが事前に選択されます。

ここから、テンプレートピッカーでSwift並行性オプションを選択し、記録を開始できます。

もう一度、大きなファイルをアプリにドロップします。

繰り返しになりますが、アプリが回転し始め、UIが反応しないことがわかります。

インスツルメンツがアプリケーションに関するすべての情報をキャプチャできるように、これをさらに数秒間実行します。

痕跡が見つかったので、調査を開始できます。

すべての情報をよりよく見るために、このトレースをフルスクリーンにします。

オプションドラッグを使用して、関心のある領域を拡大することができます。

プロセストラックでは、Instrumentsは、このUIハングが発生した場所を正確に示しています。

これは、ハングがいつ発生したか、どのくらいの期間続いたかが明確ではない場合に役立ちます。

先に述べたように、始めるのに良い場所は、トップレベルのSwiftタスク統計です。

すぐに目を引くのは、ランニングタスクの数です。

ほとんどの場合、実行されているタスクは1つだけです。

これは、問題の一部は、私たちのすべての仕事がシリアル化を余儀なくされていることを示しています。

タスク状態の要約を使用して、最も長く実行されているタスクを見つけ、ピンアクションを使用してタイムラインにピン留めできます。

このタスクの物語ビューは、バックグラウンドスレッドで短時間実行され、その後メインスレッドで長時間実行されたことを示しています。

さらに調査するには、メインスレッドをタイムラインに固定することができます。

メインスレッドは、いくつかの長時間実行中のタスクによってブロックされています。

これは、マイクが話したメインアクターブロッキングの問題を示しています。

だから、私たちが自問しなければならない質問は、「このタスクは何をしていますか?」です。そして「このタスクはどこから来たのですか?」

これらの質問の両方に答えるために、物語のビューに戻ることができます。

拡張詳細ビューの作成バックトレースは、タスクがcompressAllFiles関数で作成されたことを示しています。

物語は、タスクが compressAllFiles でクロージャ番号1 を実行していることを示しています。

このシンボルを右クリックすると、ソースビューアで開くことができます。

この関数内のクロージャナンバーワンは、圧縮作業を呼び出しています。

このタスクがどこで作成され、何をしているのかがわかったので、Xcodeでコードを開き、メインスレッドでこれらの重い計算を実行しないように調整することができます。

圧縮ファイル機能は、CompressionStateクラス内にあります。

CompressionStateクラス全体は、@MainActorで実行するように注釈が付けられています。

これは、タスクがメインスレッドでも実行された理由を説明しています。

ここでの@Publishedプロパティはメインスレッドからのみ更新する必要があるため、このクラス全体をMainActorにする必要があります。そうしないと、ランタイムの問題が発生する可能性があります。

だから、代わりに、このクラスを独自のアクターに変換しようとすることができます。

しかし、コンパイラは、本質的にこの共有可変状態は2つの異なるアクターによって保護される必要があると言っているので、これを行うことができないことを教えてくれます。

しかし、それは私たちに本当の解決策が何であるかのヒントを与えてくれます。

このクラスには2つの異なる可変状態があります。

1つの状態である「ファイル」プロパティは、SwiftUIによって観察されるため、MainActorに分離する必要があります。

しかし、他の状態であるログへのアクセスは、同時アクセスから保護する必要がありますが、どのスレッドが任意の時点でログにアクセスするかは関係ありません。

したがって、実際には主役である必要はありません。

しかし、私たちはまだ同時アクセスから保護したいので、独自のアクターでラップします。

今必要なのは、必要に応じてタスクが2つの間をホップする方法を追加することだけです。

新しいアクターを作成し、ParallelCompressorと呼ぶことができます。

その後、ログ状態を新しいアクターにコピーし、追加のセットアップコードを追加できます。

ここから、これらの俳優同士がお互いにコミュニケーションをとる必要があります。

まず、CompressionStateクラスからログ変数を参照したコードを削除し、ParallelCompressor Actorに追加しましょう。

最後に、ParallelCompressorでcompressFileを呼び出すためにCompressionStateを更新する必要があります。

これらの変更で、アプリケーションをもう一度テストしましょう。

もう一度、大きなファイルをアプリケーションにドロップします。

UIはもはやハングアップしておらず、これは大きな改善ですが、期待するスピードは得られていません。

私たちは、この作業をできるだけ早く行うために、機械内のすべてのコアを最大限に活用したいと考えています。

マイク、他に何に気をつければいいの？

マイク：私たちはメイン俳優から仕事を移動させることでハングアップを解決しましたが、私たちはまだ私たちが望むパフォーマンスを得ていません。

理由を確認するには、俳優を詳しく調べる必要があります。

アクターは、複数のタスクが共有状態を操作することを安全にします。

しかし、彼らはその共有状態へのアクセスをシリアル化することによってこれを行います。

一度に1つのタスクのみがアクターを占有することが許可され、そのアクターを使用する必要がある他のタスクは待機します。

Swiftの並行性は、非構造化タスク、タスクグループ、およびasync letを使用した並列計算を可能にします。

理想的には、これらの構造は、多くのCPUコアを同時に使用できます。

そのようなコードからアクターを使用する場合は、これらのタスク間で共有されているアクターで大量の作業を実行することに注意してください。

複数のタスクが同じアクターを同時に使用しようとすると、アクターはそれらのタスクの実行をシリアル化します。

このため、並列計算のパフォーマンスメリットが失われます。

これは、各タスクが俳優が利用可能になるのを待たなければならないためです。

これを修正するには、アクターのデータへの排他的なアクセスが本当に必要な場合にのみ、タスクがアクターで実行されることを確認する必要があります。

他のすべては俳優から逃げるべきだ。

タスクをチャンクに分割します。

いくつかのチャンクは俳優で実行しなければならず、他のチャンクは実行しません。

非アクターの分離されたチャンクは並行して実行できます。つまり、コンピュータは作業をはるかに速く完了できます。

これのデモを見てみましょう。 アクション。

ハルジャス:ありがとう、マイク。

更新された「ファイルスクイーザー」アプリケーションの痕跡を見て、マイクが私たちに教えてくれたことを覚えておきましょう。

タスクサマリービューは、並行性コードがキューに入れられた状態で驚くべき時間を費やしていることを示しています。

これは、俳優への排他的なアクセスを得るために待っている多くのタスクがあることを意味します。

これらのタスクの1つをピン留めして、その理由を学びましょう。

このタスクは、圧縮作業を実行する前に、ParallelCompressor Actorに入るのを待つのにかなりの時間がかかります。

先に進んで、俳優を私たちのタイムラインに固定しましょう。

ここには、ParallelCompressor Actorのトップレベルのデータをいくつか紹介します。

このアクターキューは、いくつかの長時間実行中のタスクによってブロックされているようです。

タスクは、本当に必要な期間だけ俳優にとどまるべきです。

タスクの物語に戻りましょう。

ParallelCompressorのエンキューの後、タスクはcompressAllFilesのクロージャ番号1で実行されます。

では、そこで調査を始めましょう。

ソースコードは、このクロージャが主に圧縮作業を実行していることを示しています。

compressFile関数はParallelCompressor Actorの一部であるため、この関数の実行全体はActorで行われ、他のすべての圧縮作業をブロックします。

この問題を解決するには、compressFile関数をアクター隔離から切り離されたタスクに引き出す必要があります。

これにより、関連する可変状態を更新するために必要な限り、アクターでのみ切り離されたタスクを持つことができます。

したがって、圧縮機能は、アクターで保護された状態にアクセスする必要があるまで、スレッドプール内の任意のスレッドで自由に実行できます。

たとえば、「ファイル」プロパティにアクセスする必要がある場合、メインアクターに移動します。

しかし、そこで完了するとすぐに、logsプロパティにアクセスする必要があるまで、再び「並行性の海」に移動し、ParallelCompressor Actorに移動します。

しかし、再び、それがそこで行われるとすぐに、それはスレッドプールで実行されるために再び俳優を残します。

しかし、もちろん、圧縮作業を行うタスクは1つだけではありません。たくさんあります。

そして、アクターに制約されないことで、スレッドの数によってのみ制限され、すべて同時に実行できます。

もちろん、各アクターは一度に1つのタスクしか実行できませんが、ほとんどの場合、私たちのタスクはアクターである必要はありません。

マイクが説明したように、これにより、圧縮タスクを並行して実行し、利用可能なすべてのCPUコアを利用することができます。

では、今すぐこの変更を加えましょう。

compressFile関数を非分離としてマークできます。

これにより、いくつかのコンパイラエラーが発生します。

非分離としてマークすることで、このアクターの共有状態にアクセスする必要はないとSwiftコンパイラに伝えました。

しかし、それは完全に真実ではありません。

このログ関数はアクター分離されており、共有可変状態にアクセスする必要があります。

これを修正するには、この関数を非同期にし、すべてのログ呼び出しをawaitキーワードでマークする必要があります。

次に、タスクの作成を更新して、切り離されたタスクを作成する必要があります。

タスクが作成されたアクターコンテキストを継承しないようにします。

切り離されたタスクでは、明示的に自己をキャプチャする必要があります。

アプリケーションをもう一度テストしましょう。

アプリはすべてのファイルを同時に圧縮することができ、UIは応答性を維持します。

改善点を確認するために、Swift Actorsのインストゥルメントをチェックすることができます。

ParallelCompressorアクターを見ると、アクターで実行される作業のほとんどは短時間で、キューのサイズが手に負えなくなったことはありません。

要約すると、インストゥルメントを使用してUIハングの原因を分離し、並行性を向上させるために並行性コードを再構築し、データを使用してパフォーマンスの向上を検証しました。

今、マイクは、他の潜在的なパフォーマンスの問題について私たちに話すつもりです。

マイク：デモで見たものを超えて、私がカバーしたい2つの一般的な問題があります。

まず、スレッドプールの枯渇について話しましょう。

スレッドプールの枯渇は、パフォーマンスを傷つけたり、アプリケーションをデッドロックしたりする可能性があります。

迅速な並行性には、実行中に前進するタスクが必要です。

タスクが何かを待つとき、それは通常、一時停止することによってそうします。

ただし、タスク内のコードは、中断することなく、ファイルやネットワークIOのブロック、ロックの取得など、ブロッキングコールを実行する可能性があります。

これにより、タスクが前進するための要件が破れます。

これが起こると、タスクは実行されているスレッドを占有し続けますが、実際にはCPUコアを使用していません。

スレッドのプールが制限されており、一部がブロックされているため、並行性ランタイムはすべてのCPUコアを完全に使用することはできません。

これにより、実行できる並列計算の量とアプリの最大パフォーマンスが削減されます。

極端な場合、スレッドプール全体がブロックされたタスクによって占有され、スレッドプールで実行するために新しいタスクを必要とする何かを待っている場合、並行性ランタイムはデッドロックする可能性があります。

タスク内の通話をブロックしないようにしてください。

ファイルとネットワークIOは、非同期APIを使用して実行する必要があります。

条件変数やセマフォで待つことは避けてください。

きめ細かい、短時間保持されたロックは、必要に応じて許容されますが、競合の多いロックや長期間保持されるロックは避けてください。

これらのことを行う必要があるコードがある場合は、そのコードを並行性スレッドプールの外に移動します。たとえば、ディスパッチキューで実行し、継続を使用して並行性の世界にブリッジします。

可能な限り、システムを円滑に動作させるために、操作をブロックするために非同期APIを使用してください。

継続を使用するときは、それらを正しく使用するように注意する必要があります。

継続は、Swiftの並行性と他の形式の非同期コードの架け橋です。

継続は現在のタスクを一時停止し、呼び出されたときにタスクを再開するコールバックを提供します。

これは、コールバックベースの非同期APIで使用できます。

Swiftの並行性の観点から、タスクは中断され、継続が再開されると再開されます。

コールバックベースの非同期APIの観点から、作業が開始され、作業が完了するとコールバックが呼び出されます。

Swift Concurrency機器は継続について知っており、それに応じて時間間隔をマークし、タスクが呼び出される継続を待っていたことを示します。

継続コールバックには特別な要件があります。正確に一度、それ以上、それ以下で呼び出す必要があります。

これはコールバックベースのAPIの一般的な要件ですが、非公式な要件である傾向があり、言語によって強制されず、見落としが一般的です。

スウィフトの並行性は、これを難しい要件にします。

コールバックが2回呼び出されると、プログラムがクラッシュしたり、動作を間違えたりします。

コールバックが呼び出されない場合、タスクはリークされます。

このコードスニペットでは、withCheckedContinuationを使用して継続を取得します。

次に、コールバックベースのAPIを呼び出します。

コールバックでは、継続を再開します。

これは、一度だけ呼び出すという要件を満たしています。

コードがより複雑なときは注意することが重要です。

左側では、成功時に継続のみを再開するようにコールバックを変更しました。

これはバグです。

失敗すると、継続は再開されず、タスクは永久に中断されます。

右側では、継続を2回再開します。

これもバグであり、アプリは誤動作したりクラッシュしたりします。

これらのスニペットは両方とも、継続を一度だけ再開する要件に違反しています。

継続には、チェックと安全でない2種類の継続があります。

パフォーマンスが絶対に重要でない限り、継続には、常にwithCheckedContinuation APIを使用してください。

チェックされた継続は自動的に誤用を検出し、エラーにフラグを立てます。

チェックされた継続が2回呼び出されると、継続はトラップします。

継続がまったく呼び出されない場合、継続が破棄されると、継続が漏洩したことを警告するメッセージがコンソールに出力されます。

Swift Concurrencyインストゥルメントは、継続状態で無期限に立ち往している対応するタスクを表示します。

Instrumentsの新しいSwift Concurrencyテンプレートについては、さらに調べる必要があります。

構造化された並行性のグラフィック視覚化を取得し、タスク作成コールツリーを表示し、正確な組み立て手順を検査して、Swift Concurrencyランタイムの全体像を把握することができます。

Swift Concurrencyがボンネットの下でどのように機能するかの詳細については、昨年の「Swift Concurrency: Behind the Scenes」のセッションをご覧ください。

また、データレースの詳細については、「Swift Concurrencyを使用してデータレースを排除する」をご覧ください。

見てくれてありがとう!

そして、並行性コードをデバッグして楽しんでください。