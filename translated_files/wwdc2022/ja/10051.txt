10051

♪ ♪

August Joki：こんにちは、私はwatchOSのソフトウェアエンジニアであるAugust Jokiです。WidgetKitの合併症をさらに進める方法をお見せします。

素晴らしいコンプリケーションとウィジェットを見たことを願っています：最初にリローデッドトーク、WidgetKitのコンプリケーションの基本をカバーしています。

この講演では、時計の文字盤の合併症に関連して、そこで取り上げられた概念を拡張します。

そして、私のWWDC 2020トーク：SwiftUIでのコンプリケーションの構築は、コンプリケーションの着色とSwiftUIの描画に関する詳細をカバーしています。

この講演では、watchOS固有のWidgetKit機能と、既存のClockKitコンプリケーションをWidgetKitに移行する方法について説明します。

私はコーヒートラッカーのサンプルアプリからインスピレーションを得て、この講演を通して例として使用しました。

このアプリは、一日を通して飲むコーヒー、紅茶、ソーダの数を記録し、時間の経過とともに体内のカフェインの量を追跡します。

watchOSに特有のものから始めましょう。

iOS 16では、携帯電話のロック画面にコンプリケーションスタイルのウィジェットを持ち込み、watchOS 9では、時計のコンプリケーションにWidgetKitを持ち込みました。

時計の文字盤には、時計画面の隅にユニークなコンプリケーションプレゼンテーションがあります。

そして、それを説明するには、ac accessoryCorner と呼ばれるユニークな WidgetKit ファミリーが必要です。

そのユニークなプレゼンテーションの一部は、SwiftUIビューで指定された補助コンテンツですが、コンテンツの一部としてレンダリングされません。

代わりに、それは時計の文字盤によってレンダリングされます。

コーナーの円形部分は標準のSwiftUIレンダリングで、補助コンテンツはコーナーの湾曲した部分です。

または、インフォグラフの文字盤のダイヤルで。

アクセサリーインラインファミリーは、時計の文字盤でユニークな動作をしています。

顔に応じてレンダリングされる複数の方法があります。

時には平らで、時には文字盤に合わせて湾曲しています。

コーヒートラッカーアプリがWidgetKitを使用するように更新される方法を見て、これらのユニークな機能をサポートする方法について話しましょう。

iOS 16の3つの新しいコンプリケーションスタイルのウィジェットファミリー、AccessoryRectangular、accessoryCircular、accessoryInlineに加えて、watchOS 9にはaccessoryCornerと呼ばれる4番目のファミリーがあります。

accessoryCornerは、下隅に表示されている地図や心拍数の合併症のような大きな円形のコンテンツとして、または上隅に表示されているコーヒートラッカーやムーンフェイズコンプリケーションのような湾曲したラベルやゲージを持つ小さな円形のコンテンツとして表示することができます。

内部の補助コンテンツが表示されるかどうかを制御するために、watchOS 9は使用できる新しいビュー修飾子を追加しました。

私のコーヒートラッカーアプリのコーナーコンプリケーションの構築を見てみましょう。

より大きな円形のコンテンツスタイルから始めて、私はSFシンボルと背景を持つZStackを持っています。

SwiftUIのコンテンツは、他のコーナーコンプリケーションのデザインに合わせて自動的に円にクリップされます。

内側の湾曲したコンテンツを追加するには、watchOS 9の新しいウィジェットラベルビュー修飾子を使用します。

文字盤は修飾子の内容を抽出して、ファミリーと文字盤のスタイルに適したコントロールを描画します。

そして、円形のコンテンツは自動的に縮小してスペースを作ります。

accessoryCornerでは、ウィジェットのラベルにSwiftUIテキスト、ゲージ、またはプログレスビューを指定できます。

AccessoryCornerは、ウィジェットラベルをサポートする唯一のファミリーではありません。

accessoryCircularファミリーでどのように使用されているかを見てみましょう。

インフォグラフの文字盤には、コーナーコンプリケーションに加えて、文字盤の内側に4つの円形のコンプリケーションがあります。

私のコーヒートラッカーの円形のコンプリケーションは、真ん中の上部にあり、先ほど見たコーナーコンプリケーションと非常によく似ていますが、文字盤にテキストがあります。

今、そのテキストを追加する方法を紹介します。

私の円形のコンプリケーションデザインでは、コーナーコンプリケーションのウィジェットラベルにあったゲージを前面と中央に移動する方が適切だと思いました。

インフォグラフの上部中央位置を利用するために、円形のコンテンツに収まらない長いベゼル領域に追加のテキストを表示するために、ゲージにウィジェットラベルを追加します。

しかし今、私はメインビューとその上のテキストの間に冗長な情報を持っています。

コーナーコンプリケーションからその見栄えの良いコーヒーカップSFシンボルに円形の内容を切り替えることで、それをクリーンアップすることができますが、ベゼルのない円形の合併症を示す顔に切り替えると、カフェイン情報がすべて失われます。

幸いなことに、両方のケースでコンプリケーションを機能させるために追加できるAPIがあります。

コンプリケーションを更新して、showsWidgetLabelという環境プロパティをビューに追加します。

これは、コンプリケーションがウィジェットのラベルにコンテンツを表示する時計の文字盤の位置にあるときはいつでも当てはまります。

そして、showsWidgetLabelの値に応じてコンテンツを変更できるので、各コンプリケーションスポットで適切なレベルの情報を持つことができます。

私はちょうどアクセサリーサーキュラーファミリーが時計の文字盤に表示されることができる2つの異なる方法を実演しました、そしてあなたが注意する必要があるもう1つの方法があります。

特大の文字盤は、長い間、人々が特大フォーマットで時間を見るための素晴らしい方法でした。

そして、それは単一の大きな円形の合併症をサポートしています。

エクストララージフェイスは、アクセサリーサーキュラーファミリーを使用し、顔のスタイルに合わせてコンテンツを自動的にスケールアップします。

ご注意：この顔は単一の大きなコンプリケーションを持つように設計されているため、増加したキャンバスサイズをコンプリケーションを密にパックする機会として使用しないでください。

内容は、通常の円形のファミリーと同じで、より大きくする必要があります。

先に述べたように、時計の文字盤にはさらに2つのウィジェットファミリーがあります。accessmentRectangularとaccessmentInlineです。

ウィジェットラベルを示す長方形のコンプリケーションを持つ顔はありません。

そして、accessuceInlineファミリーは、すでにウィジェットラベルとして機能しています。

時計の文字盤は、インラインコンテンツから画像とテキストを抽出し、顔の外観に合わせてレンダリングします。

次は移行です。

移行には2つの部分があります。既存のClockKitコンプリケーションコードをWidgetKitで書き換えることと、人々が時計の文字盤に設定したコンプリケーションをアップグレードする方法をシステムに知らせるためのマッピングを提供することです。

WidgetKitを採用すると、システムはClockKitデータソースに新しいコンテンツを尋ねるのをやめ、顔編集ピッカーに新しい合併症のみを表示します。

ウォッチにWidgetKitを導入するだけでなく、watchOS 9は豊富なコンプリケーションをサポートするためにすべての顔を更新しました。これにより、コンプリケーションファミリーの数を12から4に劇的に減らすことができました。

長方形とコーナーマップは、アクセサリー長方形とアクセサリーコーナーに直接渡る。

3つのグラフィックサーキュラースタイルのClockKitファミリーはすべて、単一のアクセサリーCircular WidgetKitファミリーになりました。

そして、accessortisInlineファミリーは、古いutilitarianSmallFlatまたはutilitarianLargeがかつてあった場所で使用されます。

そして、以前はutilitarianSmallだった多くの場所が、accessoraccessorCornerファミリーを使用するように更新されました。

WidgetKitでは、SwiftUIビューとその状態駆動型レイアウトがClockKitのテンプレートに取って代わりました。

WidgetKitにはまだおなじみのタイムラインとエントリがあります。

実際、それらはもともとClockKit自体に触発されました。つまり、コンプリケーションデータソースは、静的またはインテントベースのWidgetKit構成のいずれかにうまく移行します。

WidgetKitがサポートする構成の種類と一般的なファミリーサポートの詳細については、元のWidgetKitトークを参照してください。

人の合併症をシステムによって自動的に移行できるように、ClockKitに最後のAPIを追加しました。

これにより、すでにウォッチフェイスにある既存のコンプリケーションは、ユーザーの操作なしで新しいWidgetKitベースのコンプリケーションに自動的にアップグレードできます。

アプリがウォッチで更新されると、ウォッチフェイスはアプリのバンドル内のウィジェットの有無をチェックします。

見つかった場合は、ClockKitコンプリケーションデータソースを起動して、既存のコンプリケーションの移行を生成します。

この時点から、CLKComplicationDataSourceは、ClockKitのコンプリケーションを含む共有顔を受け取った場合にのみ、移行を要求するために実行されます。

システムは、新しい顔が共有されるたびに移行を要求するので、一貫したエクスペリエンスを得るには、移行の一貫性を保つ必要があります。

美しいWidgetKitコンプリケーションの作成が完了したら、新しいプロパティwidgetMigratorを追加して、新しいMigratorプロトコルに準拠したオブジェクトを提供できます。

あなたのコンプリケーションデータソース自体、またはあなたが提供する他のタイプ。

CLKComplication WidgetMigratorプロトコルには、既存のCLKComplicationDescriptorsからウォッチフェイスウィジェットの移行設定を提供する単一の機能があります。

新しいAPIを採用する最も簡単な方法は、データソースを新しいMigratorプロトコルに準拠させることです。

WidgetKitコンプリケーションが静的設定を使用する場合は、静的移行設定を提供します。

また、ウィジェットのコンプリケーションでインテントを使用する場合は、同等の移行設定があります。

インテントベースの移行設定を提供する場合は、両方の場所でインテントオブジェクトを作成できるように、ウォッチアプリとウィジェット拡張機能にインテント定義を含める必要があることに注意してください。

WidgetKitは、体験を劇的に簡素化しながら、時計のコンプリケーションを作成する新しい創造的な方法を可能にします。

見てくれてありがとう。