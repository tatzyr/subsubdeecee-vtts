10062

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

こんにちは、セッション「Meet Transferable」へようこそ。

私の名前はジュリアです。私はSwiftUIのエンジニアであり、アプリのドラッグアンドドロップ、コピー/ペースト、その他の機能をサポートする宣言的な方法であるTransferableを紹介することに興奮しています。

SwiftUIやMac用のアプリケーションの開発とは別に、コンピュータサイエンスの女性の物語にも興味があります。

ヒーローを知ることは重要だと思います。

そこで、女性発明家、エンジニア、科学者のプロフィールのリストを表示、追加、編集できるカタログアプリケーションを作成することにしました。

このアプリケーションは、アプリとの間の科学者の肖像画のドラッグアンドドロップをシームレスにサポートし、クリップボードのコンテンツを使用して興味深い事実を貼り付けることができるようにしたい。

そして初めて、私のアプリはwatchOSでの共有をサポートできます!

私の潜在的なユーザーは、時計からパーソナリティプロフィールを共有したいと言っています。

また、SwiftUIを介して、共有はiOSとMacで利用可能になり、今年ShareSheetのこの真新しいデザインも手に入れました。

ボンネットの下では、これらすべての機能を有効にするには、アプリ内または他のアプリケーションで受信者に送信されることをすでにサポートしなければならないモデルが必要です。

プロフィール構造には、単一の人格に関するすべての情報が含まれています。

アーカイブにパックされたすべてのプロフィールは、友達間で共有できます。

私たちは、ひもで人格についての楽しい事実を保存し、ビデオを添付することさえできます。

そして、これらすべてのモデルタイプを共有するための素晴らしい新しい簡単な方法があります。

譲渡可能に会いましょう!

これは、共有とデータ転送のためにモデルをシリアライズおよびデシリアライズする方法を説明するスウィフトファーストの宣言的な方法です。

今日は、Transferableとは何か、それを使用するときに舞台裏で何が起こっているのかについて話します。カスタムタイプに適合する方法。最後に、必要なことを正確に行うためにTransferableをカスタマイズするのに役立ついくつかの高度なヒントとコツを共有します。

始めましょう！

2つのアプリケーションが実行されており、ユーザーがコピー/ペースト、ShareSheet、ドラッグ、または他のアプリ機能を使用して、あるアプリから別のアプリに情報を渡したいとします。

2つの異なるアプリ間で何かを送信すると、このすべてのバイナリデータがあります。

このデータを送信する際の重要な部分は、それが何に対応するかを決定することです。

それはテキスト、ビデオ、私のお気に入りの女性エンジニアのプロフィール、またはアーカイブ全体かもしれません。

そして、データの提供を記述するUTTypeがあります。

アプリがこのバイナリデータを生成する方法を詳しく見てみましょう。

他のアプリと共有できるすべてのタイプ、または単一のアプリケーション内でも、2つの情報を提供する必要があります。バイナリデータとの間で変換する方法と、バイナリデータの構造に対応し、実際に得たものを受信者に伝えるコンテンツタイプです。

コンテンツタイプ（統一型識別子とも呼ばれる）は、さまざまなバイナリ構造の識別子と抽象的な概念を記述するApple固有の技術です。

識別子はツリーを形成し、カスタム識別子を定義することもできます。

たとえば、プロファイルで使用されるバイナリ構造用です。

カスタム識別子を宣言するには、まずその宣言をInfo.plistファイルに追加します。

また、ファイル拡張子を追加するのも良い考えです。

データがディスクに保存されている場合、システムはアプリがそのファイルを開くことができることを知るでしょう。

第二に、コードで宣言します。

コンテンツタイプの詳細については、「Uniform Type Identifiers -- A reintroduction」というビデオをご覧ください。

個人的には、私はそれが大好きで、それは均一な型識別子とは何か、そしてそれらをどのように使用するかを明確に提供します。

良いニュースは、多くの標準タイプがすでにTransferableに準拠していることです。例えば、文字列、データ、URL、帰属文字列、画像。

新しいSwiftUIペーストボタンインターフェイスを使用してプロフィールに楽しい事実を貼り付けたり、ビューから画像をドラッグしたり、Finderや他のアプリからドロップされた画像を受信したりするには、数行のコードが必要です。

brと新しいShareLinkを使用して、ウォッチからの共有体験を実装できるようになりました。

私たちは基本をカバーしました、そして今、あなたはTransferableの使い方とそれが何であるかのアイデアを持っています。

アプリケーションのモデルに譲渡可能な適合性を追加する方法を見てみましょう。

先に述べたように、私たちのアプリには共有される4つのモデルタイプがあります。

そのうちの1つである文字列は、すでにTransferableに準拠しています。これ以上何もする必要はありません。

しかし、単一のプロフィール、ProfilesArchive、そして私が共有したいビデオはどうですか?

Transferableにタイプを適合させるために、実装するプロパティは1つだけです。TransferRepresentationです。

モデルがどのように転送されるかを説明しています。

CodableRepresentation、DataRepresentation、FileRepresentationの3つの重要な表現に注意する必要があります。

それぞれについて話しましょう。

しかし、まず、私たちの中心モデルであるプロファイル構造に会いましょう。

それはID、名前、略歴、おそらくいくつかの楽しい事実、肖像画、そしてビデオを持っています。

それはすでにCodableに準拠しています。

そのため、Transferable conformanceにCodableRepresentationを含めることができます。

コーディング可能な表現は、エンコーダを使用してプロファイルをバイナリデータに変換し、デコーダを使用して元に戻します。

デフォルトではJSONを使用しますが、独自のエンコーダとデコーダのペアを提供することもできます。

Codableプロトコルとエンコーダとデコーダの仕組みの詳細については、このプロトコルが最初に導入されたWWDCセッション「信頼できるデータ」をご覧ください。

私たちのプロフィールに戻ります。

Codableに必要なのは、目的のコンテンツタイプを知ることだけです。

これはカスタム形式になるため、カスタム宣言されたユニフォーム型識別子を使用します。

プロフィールのコンテンツタイプを追加したら、大丈夫です。

プロファイルがTransferableに準拠しました!

さて、別のケースを見てみましょう：ProfilesArchive。

すでにCSVデータへの変換をサポートしています。

女性プロファイルのリストをCSVファイルにエクスポートし、友人と共有したり、別のコンピュータにインポートしたりできます。

アーカイブはデータとの間で変換でき、DataRepresentationを使用できることを意味します。

中を覗くと、DataRepresentationが変換関数を使用してバイナリ表現を直接作成し、受信者の値を再構築することがわかります。

これは、DataRepresentationを使用してTransferableに準拠するのがいかに簡単かです。

必要なのは、すでに持っている2つの関数を呼び出すだけです。初期化子とCSVへのコンバーターです。

パーソナリティプロフィールにビデオが添付されている場合は、ドラッグまたは共有できるようにしたいです。

しかし、ビデオは大きくなる可能性があります。私はそれをメモリにロードしたくありません。

ここでFileRepresentationの出番です。

また、カーテンを持ち上げると、FileRepresentationが提供されたURLを受信者に渡し、それを使用して転送可能なアイテムを再構築することがわかります。

FileRepresentationを使用すると、disk: fileに書き込まれたバイナリ表現に裏打ちされたアイテムを共有できます。

要約しましょう。

単純なユースケースで単一の表現だけを選択する場合は、まずモデルにコード可能な適合性があり、特定のバイナリ形式の要件がないかどうかを確認してください。

その場合は、CodableRepresentationを使用してください。

そうでない場合は、メモリに保存されているか、ディスクに保存されているかを確認してください。

DataRepresentationは前者に最も適しており、FileRepresetnationは後者に最適です。

Transferableは、単純なユースケースだけでなく、複雑なユースケースもカバーすることを目的としています。

そして、ほとんどの場合、ほんの数行のコードで。

自分で見て！

以前は、プロファイルに譲渡可能な適合性を追加しましたが、さらに進めましょう。

プロファイルがペーストボードにコピーされ、任意のテキストフィールドに貼り付けられたら、プロファイルの名前を貼り付けます。

これは、別の表現を追加する必要があることを意味します。

ProxyRepresentationは、他のTransferableタイプが私たちのモデルを表すことを可能にします。

1行、およびプロファイルはテキストとして貼り付けることができます。

Codableの後にProxyRepresentationを追加したことに注意してください。順序は重要です。

受信者は、サポートするコンテンツタイプで最初の表現を使用します。

受信者がカスタムコンテンツタイプのプロファイルを認識している場合は、それを使用する必要があります。

そうでないが、テキストをサポートしている場合は、代わりにProxyRepresentationを使用させてください。

現在、プロファイルはエンコーダ/デコーダ変換とテキストへの変換の両方をサポートしています。

この場合のProxyRepresentationは、テキストへのエクスポートのみを記述しますが、そこからプロファイルの再構築は説明しません。

どの表現でも、両方の変換、または1つだけを記述できます。

さて、ProxyRepresentationsについて知ったら、ビデオのFileRepresentationが本当に必要ですか?

URL付きのプロキシを持つことができます。

違いは微妙です。

FileRepresentationは、ディスクに書き込まれたURLを操作し、一時的なサンドボックス拡張子を付与することにより、このファイルまたはそのコピーへの受信者のアクセスを確保することを目的としています。

ProxyRepresentationは、文字列のような他の転送可能なアイテムと同じようにURLを扱います。

ファイルに必要な追加機能はありません。これは、いかなる機能も備えていません。

それは私たちが両方を持つことができることを意味します。

最初のFileRepresentationは、受信者がその内容を含むムービーファイルにアクセスできるようにします。

2つ目は、コピーしたビデオをテキストフィールドに貼り付けると機能します。

したがって、URLはファイルとプロキシの表現によって非常に異なって扱われます。

最初のケースでは、実際のペイロードはディスク上のアセットであり、2番目のケースでは、ペイロードはリモートWebサイトを指すことができるURL構造自体です。

アップグレードしたいもう1つのモデルはProfilesArchiveです。

CSVへの変換をサポートしていない場合があり、それをコードに反映したいと思います。

見てみましょう。

CSVにエクスポートできるかどうかと、データとの間で変換関数を知らせるブールプロパティを追加します。

このアイデアをコードで表現するには、.exportingConditionを使用できます。

指定されたアーカイブがCSVをサポートしていない場合、この形式ではエクスポートされません。

このAPIを使用すると、SwiftUIのカスタムビューと同様に、カスタムTransferRepresentationを構築することもできます。

唯一の要件は、必要に応じて他の表現を構成できるボディプロパティを提供することです。

表現の組み合わせを再利用したい場合や、公開したくないプライベートデータ表現がある場合に便利です。

Transferableは、私が望んでいたすべての機能でこのアプリケーションをすばやく構築するのに役立ちました。

これまで以上に短い時間で機能豊富なアプリを構築するのに役立つことを願っています。

このセッションに参加してくれてありがとう、素晴らしいアプリを作り続けてください!

♪