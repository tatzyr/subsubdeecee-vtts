10092

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

こんにちは、認証体験チームのエンジニア、ギャレットです。

そして、このビデオでは、次世代の認証技術であるパスキーについて話すことに興奮しています。

しかし、まず、今日の認証技術、パスワードについて話す必要があります。

あなたはおそらく、ほぼすべてのアプリやウェブサイトにサインインすることに慣れているでしょう。

パスワードは安全に使用するのが本当に難しいです。

私たちは皆、すべてのアカウントに強力でユニークなパスワードを作成することになっていることを知っていますが、実際に作成する人はあまりいません。

アプリやウェブサイトを設計する際には、アカウントを安全に保つことと、良い体験を設計することの間には、絶え間ないトレードオフがあります。

また、アプリやウェブサイトがすべてを正しく行っていても、フィッシングやパスワードの再利用などの問題は、アカウントの侵害につながる可能性があります。

macOS MontereyとiOS 15では、ソリューションの開発者プレビュー（パスキー）を発表し、多くの素晴らしいフィードバックを得ました。

macOS VenturaとiOS 16では、誰もがパスキーを利用できるようにすることに興奮しています。

今が彼らを養子にする時です。

パスキーを使用すると、ユーザーエクスペリエンスがパスワードよりも優れているだけでなく、弱くて再利用された資格情報、資格情報の漏洩、フィッシングなどのセキュリティ問題のカテゴリ全体も不可能です。

そして、彼らはとても使いやすいです。

お見せしましょう。

お気に入りのデモアプリ、シャイニーから始めましょう。

このアプリでは、1日に1枚のかわいい写真を見ることができ、典型的なパスワードベースのサインインフローがあります。

ユーザー名フィールドをタップすると、アカウントの自動入力の提案が表示されます。

それを選択して、サインインします。

その後、パスワードを入力できます。

その後、ワンタイムコードと一緒にSMSメッセージが届くまで少し待ちます。

そこにあります。

そして最終的に、私はサインインしました。

いくつかの手順がかかりましたが、オートフィルとパスワードマネージャーの助けを借りて、私はそこに着くことができました。

サインインしたので、このアカウントにパスキーを追加します。

アカウント管理、パスキーを追加します。

ここでは、パスキーを作成するためのシステムシートを取得します。

続けてください。

完了！

数回タップするだけで、私のデバイスは私のアカウントのユニークで暗号的に強力なキーペアを生成し、iCloudキーチェーンに保存したので、macOS VenturaとiOS 16を実行しているすべてのデバイスで同期して動作します。

今、私はパスキーを持っているので、それがどれほど使いやすいかをお見せしましょう。

サインアウトして、先ほど使用したのと同じサインインフォームに戻ります。

以前のようにユーザー名フィールドに焦点を合わせるつもりです。

アカウント用のパスキーが保存されたので、QuickTypeバーに表示されます。

それをタップするだけで、サインインします。サインインしています。

一歩。

パスキーを保存するときは、新しいパスワードを思いついたり、複雑な要件を満たそうとしたりする必要はありませんでした。

各パスキーはシステムによって生成され、強力で単一のアカウントでのみ使用されることが保証されます。

そして、私がそれでサインインしているとき、それは私が慣れている既存のサインインフローに表示することができ、それは使用する単一のタップです。

そして、システムは、強力な組み込みのフィッシング耐性で、正しいアプリやウェブサイトでのみ使用できるようにします。

もちろん、パスキーはウェブでも機能します。

ここで私はSafariのシャイニーのウェブサイトにいます。

私の携帯電話と同じように、ユーザー名フィールドに焦点を合わせると、iCloudキーチェーンのおかげで、私のパスキーはすでにそこにあり、すぐに使用できます。

私がしなければならないのはTouch IDだけで、サインインしています。

それでおそれ。

Appleのパスキー実装は、オープンスタンダードに基づいて構築されています。

私たちは、FIDOアライアンス内の他のプラットフォームベンダーと協力して、パスキーの実装が互換性のあるクロスプラットフォームであり、できるだけ多くのデバイスで動作できることを確認しています。

パスキーを使用するようにアカウントをアップグレードした後も、友人のPCでサインインできます。

もちろん、私の友人のPCにはパスキーがローカルに保存されていませんが、ここにユーザー名を入力できます。

サインインを押すと、電話を使えるようにするシートが届きました。

それから私はQRコードを取得します。それをスキャンさせてください。

私の電話は、このQRコードがパスキーでサインインするためのものであることを認識しています。

このオプションを選択すると、私の電話とブラウザは互いに安全に接続されます。

今、私はただ続けることができ、サインインしています。

このクロスプラットフォームのサインイン体験は、パスキーの背後にある標準の一部である一流のシステム機能です。

表面的には、信じられないほどシンプルに見えますが、これは単なるQRコードではありません。

舞台裏では、デバイスはローカルキー契約を実行し、近接性を証明し、エンドツーエンドの暗号化された通信チャネルを確立し、すべて簡単ですが、パスキーの強力なフィッシング抵抗を維持する方法でサインインできるようにします。

どのデバイスでも自分のアカウントに安全にサインインできるようにするのに最適です。

パスワード交換のもう1つの重要な機能は、2人以上の間でアカウントを共有する機能です。

パスキーを他の人と共有するには、AirDropを使用できます。

私のパートナーと私はまた、私たちが共有するシャイニーのアカウントを持っていますが、私はすでにパスキーを使用するようにアップグレードしました。

パスキーを使用すると、資格情報は私が入力できるものではありませんが、それでも信頼できる人と共有することができます。

私の電話で、口座の詳細を開きます。

これは、パスワードとパスキーの両方を使用する私のすべてのアカウントです。

共有アカウントをタップして、詳細を表示できます。

ここでは、保存したパスキーに関する情報を入手したり、このアカウントにメモを追加したりできます。

パスキーも共有できます。

私のパートナーの電話があります。

私は先に進んでそれを選択します。

今、私のパートナーもパスキーを持っています。

そして、どこでもパスキーを使うのは簡単です。

パスキーを使った経験について先ほどおきました。

次に、パスキーとは何か、それらを使用する際のインターフェイスのガイドラインについて説明します。

次に、オートフィルを利用して、アプリやウェブサイトの既存のサインインフローにパスキーを統合する方法と、サインインプロセスをさらに合理化できる追加のオプションを紹介します。

その後、パスキーの仕組みについてさらに技術的な詳細を説明し、最後にパスキーと多要素認証について説明します。

まず、パスキーの設計です。

パスキーについて話すことになると、何よりもまず、パスキーはパスワードの代替品です。

サインインが速く、使いやすく、はるかに安全です。

アプリやウェブサイトでパスキーを参照する方法に関するガイドラインをいくつか紹介します。

「パスキー」は、一般的なユーザーに表示される用語です。

このビデオはAppleの実装に焦点を当てていますが、先ほど示したように、他の主要なプラットフォームはすでにパスキーに対する独自のサポートを構築し始めています。

「パスワード」も「パスワード」のような一般的な名詞です。

英語では、これは小文字で、「パスワード」のように複数形になることを意味します。

私は自分のアカウントのパスキーを持っており、設定に移動してパスキーを持つすべてのアカウントを表示することができます。

Appleプラットフォームでは、SFシンボルperson.key.badgeと.fillバリアントを使用して、システムと一致する図像を提供することもできます。

アプリやウェブサイトでパスキーを提供することに関しては、まったく新しいインターフェイスを設計する必要はありません。

ユーザー名フィールドは、今日のほとんどのアプリとウェブサイトのサインインの中心点です。

ほとんどすべての人が使い方を知っており、多くのアプリやウェブサイトがすでにそれを利用して、アカウントごとのサインイン体験を調整しています。

現在、ユーザー名フィールドには別の大きな機能があります。

パスキーはサインインの仕組みに関する新しいパラダイムをもたらしますが、パスワードからの移行もスムーズで簡単である必要があります。

自動入力を使用してパスキーをファーストクラスの機能として提示し、使い慣れ親しみ、人々が使用方法を知っているインターフェイスで、既存のサインインフローに直接ドロップできるようになりました。

自動入力でパスキーを提示することは、それらを使用すべき主な方法です。

しかし、より高度な用途のために、Appleプラットフォームには、パスキーでサインインするための幅広い追加UIオプションもあります。

パスキーの使用を開始し、自動入力で提示する方法は次のとおりです。

パスキーは、WebAuthentication（またはWebAuthn標準）に基づいて構築され、公開鍵暗号を使用します。

タイプ可能な単語や文字列を持つのではなく、アカウントごとに一意の暗号鍵のペアが生成されます。

パスキーサインインを実行するには、サーバーのバックエンドでWebAuthnを採用する必要があります。

標準のWebAuthnサーバーの実装は、パスキーで動作する必要があります。

Appleプラットフォームのアプリでは、パスキーはAuthenticationServicesフレームワークのASAuthorization APIファミリーの一部です。

これは、パスワード、セキュリティキー、Appleとのサインインなど、あらゆる種類の異なる資格情報を操作するためのAPIです。

また、このAPIをさらに柔軟にし、既存のサインインフローにシームレスに収めるために、自動入力サポートなど、使用できる新しい方法をいくつか追加しました。

アプリでパスキーの使用を開始するには、まず、webcredentialsサービスを使用して、関連するドメインを設定する必要があります。

詳細については、「アプリのパスワード自動入力の紹介」と「ユニバーサルリンクの新機能」のビデオをご覧ください。

アプリのインターフェースで、ユーザー名フィールドにユーザー名textContentTtypeが使用されていることを確認してください。

これにより、システムはパスキーの提案を提供する場所を知ることができます。

それが設定されたら、自動入力支援パスキー要求を開始するために必要なコードは次のとおりです。

あなたがそれを分解するとき、それはほんの簡単なステップです。

WebAuthnリクエストと同様に、まずサーバーからチャレンジを取得する必要があります。

次に、プロバイダーとリクエストを作成します。

ASAuthorizationPlatformPublicKey CredentialProviderは、パスキー要求を操作するためのASAuthorizationProviderです。

WebAuthn用語では、アサーションはサインイン時に使用されるため、ここでは既存のパスキーでサインインするためのアサーション要求を作成しています。

ASAuthorizationControllerは、実際に要求を処理するものです。

パスキー要求でインスタンスを作成し、そのデリゲートとpresentationContextProviderを設定します。

そして最後に、performAutoFillAssistedRequestsを呼び出すと、リクエストを開始します。

このリクエストがアプリで実行されている間、ユーザー名フィールドがフォーカスされるたびに、システムはQuickTypeバーで利用可能なパスキーを提供します。

キーボードが表示されたときにパスキーが準備できるように、ユーザー名フィールドがフォーカスされる前に、ビューの寿命の早い段階でこのリクエストを開始してください。

QuickTypeバーの項目を選択すると、Face IDが呼び出され、サインインを完了するためのASAuthorizationController Delegateコールバックを受け取ります。

テキストフィールドには実際には何も入力されません。

任意の資格情報タイプの承認が成功すると、didCompleteWithAuthorizationコールバックが返されます。

最初にすべきことは、取得した資格情報の種類を確認することです。

パスキーサインインの場合、ASAuthorizationPlatformPublicKey CredentialAssertionになります。

アサーションオブジェクトには、バックエンドでサインインを検証するために必要なフィールドが含まれます。

値を読み、サーバーで確認し、サインインを完了する必要があります。

自動入力支援パスキーリクエストは強力です。

その小さなコード変更により、アプリのサインインフローは多くの柔軟性を提供します。

もちろん、主なケースは、QuickTypeバーからパスキーの提案を選択して、そのパスキーですばやくサインインすることです。

これはあなたが最も頻繁に起こることを期待すべきことです。

しかし、他の選択肢もあります。

私が今お見せしたコードは、追加の変更なしで近くのデバイスからのパスキーサインインも許可しています。

キーアイコンをタップすると、利用可能なすべてのパスキーとパスワードを一覧表示するビューが表示され、近くのデバイスでサインインするオプションが表示されます。

その後、クロスデバイスパスキーサインインを実行できます。

どちらの場合も、パスキーを使用すると、同じASAuthorizationController Delegateコールバックを受け取ります。

これをサポートするためにあなたがする必要がある特別なことは何もありません。

ユーザーがまだパスキーを持っていない場合は、以前のようにログインフォームを使用できます。

彼らはQuickTypeバーでパスワードの提案を得るか、フィールドに入力することができます。

パスワード項目が選択されている場合、資格情報は引き続きテキストフィールドに入力され、実行中のリクエストをキャンセルできます。

既存のサインインフローに直接ドロップし、ユーザーにとって非常に簡単にできるように、このAPIを設計しました。

すでにパスキーを使用するようにアップグレードした人が、自動入力提案を使用する代わりにユーザー名を入力することを決定した場合は、自動入力要求をキャンセルし、ASAuthorizationControllerを使用してモーダルパスキーサインインシートを提示する必要があります。

ここからは、まだワンタップで、同じASAuthorizationController Delegateコールバックを受け取ります。

これが以前のコードです。

これを自動入力要求からモーダル要求に切り替えるには、この performAutoFillAssistedRequests メソッド呼び出しを performRequests() 呼び出しと交換するだけです。

これにより、利用可能なすべてのパスキーと、近くのデバイスからパスキーを使用するオプションを含むモーダルシートが表示されます。

これらは、パスキーをサポートするためにアプリで必要な唯一のコード変更です。

Webプラットフォームは、自動入力支援リクエストとモーダルパスキーリクエストの両方もサポートしています。

ウェブ上では、パスキーは標準のWebAuthn APIを介して使用され、セキュリティキーにも使用されます。

アプリと同様に、自動入力支援リクエストを採用することで、Touch IDだけですばやくサインインしたり、利用可能なすべてのパスキーとパスワードにアクセスしたり、近くのデバイスからパスキーを使用したりできます。

まず、パスワードとパスキーの両方の提案が適切な場所に表示されるように、ユーザー名とwebauthnオートコンプリート詳細トークンの両方でWebページのユーザー名フィールドに注釈を付けるようにしてください。

それが完了したら、JavaScriptの典型的なWebAuthnサインインです。

WebAuthnでは、自動入力スタイルのリクエストは条件付きメディエーションを使用して呼び出されます。

標準のJavaScript機能検出を使用して、それが利用可能かどうかを確認することから始めるべきです。

もしそうなら、リクエストを進めることができます。

ネイティブAPIと同様に、サーバーからフェッチされたチャレンジを使用してリクエストを行うことから始めます。

自動入力支援リクエストにするには、メディエーション:「条件付き」パラメータをオプションに追加します。

次に、navigator.credentials .get を使用してリクエストを開始します。

.Get呼び出しは約束を返します。

解決すると、アサーションオブジェクトを受け取り、サーバーに送り返して確認し、サインインを完了します。

アプリと同様に、誰かがパスキーを持つアカウントのユーザー名を手動で入力した場合は、APIを使用してモーダルサインインシートを表示する必要があります。

モーダルリクエストに切り替えるには、メディエーション「条件付き」パラメータを削除するだけです。

WebAuthnを使用する際に注意すべき点の1つは、Appleプラットフォームがユーザー検証（またはUVをどのように処理するかです。

UVは、オーセンティケータが現在のユーザーがデバイスの所有者であることを確認しようとしたかどうかを示すWebAuthn応答のブールフィールドです。

Appleデバイスでは、1の値は、生体認証、またはパスワードまたはパスコードが使用されたことを示します。

バイオメトリクスが利用可能な場合、Appleのプラットフォームは常にパスキーにUVを必要とするので、それについて心配する必要はありません。

WebAuthnリクエストを行う場合、ユーザー検証要件を指定するオプションがあります。

デフォルト値はuserVerification:「preferred」です。

バイオメトリクスのないデバイスで悪い体験をしないように、常にデフォルト値を使用してください。

ここでは、ウェブ上でパスキーを使用するための追加の注意事項をいくつか紹介します。

自動入力支援リクエストを行う場合は、アプリと同じように、ページの有効期間の早い段階で作成する必要があります。

モーダルWebAuthnリクエストの場合、ボタンクリックなどのユーザージェスチャーイベントからトリガーする必要があります。

モーダルリクエストは、ユーザージェスチャーイベント以外のページロードごとに1回トリガーできますが、WebKitはそのページでの後続の呼び出しを制限する場合があります。

自動入力要求はモーダルではないため、ユーザーのジェスチャーを必要とせず、タイムアウトがはるかに長くなります。

最後に、パスキーはSafariのレガシープラットフォームオーセンティケータに取って代わっています。

既存の資格情報は引き続き機能し、作成されたデバイスにバインドされますが、新しいプラットフォームの資格情報はパスキーとして作成されます。

パスキーは認証ステートメントを提供しないため、登録時にレガシー資格情報と区別することができます。

それはパスキーとオートフィルです。

次に、サインイン体験をさらに合理化できる追加のプラットフォーム機能について説明します。

自動入力支援サインインに加えて、ASAuthorization APIはより多くの便利な機能を提供します。

APIの3つの追加機能と、いつ使用したいかについて説明します。

パスキーで始まり、リストを許可します。

ユーザー名を入力した後にモーダルパスキーシートを提示すると、デバイスに保存された複数のアカウントのパスキーがある可能性があります。

利用可能なすべてのパスキーは、デフォルトでシートに表示されます。

パスキー許可リストを使用して、シートに表示されるパスキーを制限して、一致するアカウントのみを提供できます。

モーダルリクエストに許可リストを追加するには、まずユーザー名が必要です。

そのユーザー名を使用して、一致する資格情報IDのリストを取得し、許可リストに変換できます。

クレデンシャルIDは、パスキーの一意の識別子です。

Webauthnサーバーには、特定のユーザー名の資格情報IDを検索する方法があるはずです。

ここから、以前のようにリクエストを進めてください。

今、パスキーを使用して3つのシャイニーアカウントを持っている私のデバイスでは、シートは私が使用しようとしている単一のアカウントのみを提供します。

モーダルリクエストを行うときは、ユーザーがすでにユーザー名を入力している場合など、ユーザーがサインインしようとしているアカウントに関する追加のコンテキストがある場合は、許可リストを使用する必要があります。

次に、現在のデバイスにパスキーが保存されていない場合に、モーダルパスキーリクエストを行うとどうなるかについて説明します。

これは、許可リストを使用し、保存されたパスキーのいずれもそのリストと一致しない場合にも適用されます。

デフォルトでは、モーダルパスキー要求を行うと、利用可能な一致するパスキーがない場合、モーダルシートが表示され、近くのデバイスからパスキーでサインインするためのQRコードがすぐに表示されます。

これは、サインイン時に最も柔軟性を提供し、パスキーが使用されていることを知っている場合に最適なオプションです。

しかし、APIには、すぐに利用可能な資格情報を優先し、存在しない場合はデリゲートコールバックで静かにフォールバックする新しいオプションがあります。

これは、従来のサインインフォームを表示する前に、可能な限り既存の資格情報をすばやく提供するために使用できます。

デフォルトのオプションを使用したこのモーダル要求は、現在のデバイスに一致するパスキーがない場合、QRコードの表示にフォールバックします。

QRコードを取得する代わりに、preferdImmediately AvailableCredentialsオプションを使用すると、エラーを伴うデリゲートコールバックが届きます。

キャンセルされたコードでASAuthorizationErrorを受け取った場合、ユーザーがシートを見て手動で却下したか、preferdImmediately AvailableCredentialsに合格し、すぐに利用できる資格情報がないことを意味します。

ここから何をするかは、あなたがこれを呼び出していた文脈によって異なります。

たとえば、通常のサインインフォームを表示する前にローカルの資格情報をテストする方法としてこのオプションを使用している場合、これがフォームの表示をトリガーする場所です。

デバイスに少なくとも1つの一致する資格情報がある場合、使用されるオプションに関係なく、完全なモーダルシートが表示されます。

また、アプリのどこかでデフォルトのフォールバックでオートフィル支援リクエストまたはモーダルリクエストを使用していることを確認してください。現在のデバイスにパスキーがない場合でも、近くのデバイスでサインインするオプションに引き続き到達できるようにします。

私がカバーするASAuthorization APIの最後の機能は、結合された資格情報要求を行うことです。

この例では、アプリはパスキー、パスワード、およびAppleとのサインインを要求しました。

私のデバイスには、たまたま3つの異なるアカウントの3つの異なる資格情報が保存されているので、それらはすべてここに表示されます。

しかし、より可能性の高いシナリオは、誰かが1つのアカウントしか持っていないということです。

その場合、この同じ結合された資格情報要求は、シート内の1つのアカウントのみを提供します。

既存のASAuthorizationリクエストに追加の資格情報タイプを追加するのは本当に簡単です。

追加のリクエストタイプのプロバイダーとリクエストを作成し、それらの新しいリクエストをコントローラーに渡すだけです。

さて、モーダルシートは、これらの資格情報タイプのいずれかから利用可能な資格情報を提供します。

どの資格情報タイプが使用されているかに関係なく、同じデリゲートコールバックを取得します。

受け取った資格情報の種類を確認し、その資格情報の種類に応じてサインインを完了する必要があります。

そのため、ASAuthorization APIファミリのより高度な機能のいくつかをカバーしています。

さて、パスキーが実際にどのように機能し、何がそれらをとても安全にするのかについて、より技術的な詳細を掘り下げます。

今日パスワードでサインインすると、通常、実際に起こっていることは、そのパスワードを入力した後、ハッシュ化されてソルトされ、結果の難読化された値がサーバーに送信され、サーバーが保存されます。

後で、同じハッシュ化された塩漬け値を生成することができれば、アカウントに入ることが許可されます。

これは、サーバーがこのパスワードの導出を保存する責任があることを意味し、攻撃者にとって非常に価値があります。

彼らがそれを手に入れることができれば、あなたのパスワードが何であるかを把握し、あなたのアカウントにアクセスすることが可能です。

しかし、パスキーの仕組みは大きく異なります。

パスキーは、単一の入力可能な文字列を持つのではなく、実際には関連するキーのペアです。

これらのキーは、すべてのアカウントに対して、安全かつ一意にデバイスによって生成されます。

1つは公開されており、サーバーに保存されています。

もう1つは非公開で、サインインしてもデバイスにとどまります。

公開鍵は秘密ではありません。

それはあなたのユーザー名と同じくらい公開されています。

秘密鍵は、実際にサインインするために必要なものです。

サーバーはあなたの秘密鍵が何であるかを決して学習せず、あなたのデバイスはそれを安全に保ちます。

サインインすると、サーバーはデバイスにシングルユースチャレンジを送信します。

WebAuthnはさまざまなチャレンジレスポンスアルゴリズムを使用できますが、Appleプラットフォームのパスキーは標準のES256を使用します。

あなたの秘密鍵だけが、あなたのアカウントの課題に対する有効な解決策を生み出すことができます。

デバイスは、シグネチャと呼ばれるこのソリューションをローカルで生成し、ソリューションのみをサーバーに送り返します。

あなたの秘密鍵は秘密のままで、あなたのデバイスでのみです。

次に、サーバーは公開鍵を使用してソリューションを検証します。

デバイスが提供したソリューションが有効な場合は、サインインしています!

公開鍵を使用して、ソリューションが有効かどうかを確認できますが、ソリューション自体を生成することはできません。

これは、サーバーが実際に秘密鍵が何であるかを知らなくても、あなたが正しい秘密鍵を持っていることを確認できることを意味します。

また、サーバーは秘密鍵を知らないため、リークするユーザーの資格情報がないため、攻撃者にとって価値の低いターゲットです。

この暗号化と鍵保護はすべて完全に透明で、デバイスによって実行されます。

あなたの顧客はそれについて知り、考える必要はありません。

彼らの視点から見ると、パスキーは超シンプルで、どこでも機能します。

パスキーは、安全でフィッシングに強い方法でデバイス間でサインインするためにも使用できます。

これがその仕組みです。

ここには2つのデバイスがあります。

私がサインインしているデバイスまたはウェブブラウザであるクライアントと、私のパスキーを持つデバイスであるオーセンティケータ。

まず、クライアントは認証者がスキャンするQRコードを表示します。

このQRコードには、使い捨ての暗号化キーのペアをエンコードするURLが含まれています。

次に、オーセンティケータは、ネットワークリレーサーバーのルーティング情報を含むBluetooth広告を生成します。

このローカルエクスチェンジでは、サーバーを選択してルーティング情報を共有できますが、2つの追加機能も提供します。

サーバーが確認できないアウトオブバンドキー契約を実行するため、ネットワーク上のすべてのものはエンドツーエンドで暗号化され、サーバーは何も読み取ることができません。

また、これら2つのデバイスが物理的に近接しているという強い主張も提供します。

つまり、リモートの攻撃者はBluetooth広告を受信してローカル交換を完了できないため、電子メールで送信された、または偽のウェブサイトで生成されたQRコードは機能しません。

だから、それは地元の部分です。

ローカル交換とキー契約が発生すると、2つのデバイスは電話で選択したリレーサーバーに接続します。

そこから、以前のキーを使用して暗号化された標準のFIDO CTAP操作を実行するため、リレーサーバーは何が起こっているのかを見ることができません。

このプロセス全体は、デバイスとウェブブラウザによって実行されます。

ウェブサイトは、クロスデバイス通信のどの時点でも関与していません。

クロスデバイスクロスプラットフォームサインインは、パスキーを使用できる場所ならどこでも機能するシステム機能です。

したがって、これは、パスキーがどのように機能し、デバイス間でもそのような強力なセキュリティ保証をどのように行うことができるかについて、より技術的な見方です。

次に、多要素認証です。

今日の認証について考える一般的な方法は、要因の観点からです。

異なる要因は、異なる種類の攻撃に対して強いか弱いかであり、要因を組み合わせることで、より良い集団カバレッジを提供することができます。

しかし、パスキーでは、もうそのように考える必要はありません。

今日サインインするために使用される最も一般的な方法をいくつか紹介します。

あなたの頭の中のパスワードは、ほとんどすべてに対して脆弱です。

パスワードマネージャーは、ユニークで高エントロピー文字列を生成するのが得意で、デバイスの盗難に対するローカル保護があり、フィッシングに関するいくつかのヒントを提供します。

SMSまたは時間ベースのコードを追加すると、状況によっては盗難やフィッシングに役立ちますが、実際にはどちらも解決しません。

ただし、パスキーでは、すべてのパスキーは一意のデバイスで生成されたキーペアです。

Appleデバイスでは、ローカルデバイス保護の強力な基盤の上に構築されています。

パスキーはまた、フィッシングから人的要因を完全に排除します。

また、サーバーには秘密鍵がないため、アプリやウェブサイトのサーバーによって漏洩することはできません。

パスワードベースのサインインフローに要因を追加することは、パスワード単独よりも多くの種類の攻撃から保護できるため、理にかなっています。

しかし、パスキーだけでは、追加の要因を必要としないほど多くのものから保護します。

パスワードのない未来を楽しみにしています。

それを実現し始める方法は次のとおりです。 始める方法は次のとおりです。

まず、まだ採用していない場合は、サーバーにWebAuthnを採用する必要があります。

パスキーは、標準のWebAuthnサーバーの実装で動作する必要があります。

サーバーの準備ができたら、アプリやウェブサイトに新しいAPIを採用してください。

自動入力支援パスキーリクエストは、既存のサインインフローに直接ドロップできます。さらに、必要に応じて、より高度なUIオプションも用意しています。

そして最後に、ユーザーをパスワードから遠ざけます。

パスキーは、アプリやウェブサイトに安全にサインインするという利便性とセキュリティの問題に対する業界標準のソリューションです。

顧客をパスキーに誘導し、パスワードから離れることで、すべての人のセキュリティバーを上げながら、信じられないほど迅速かつ便利なサインイン体験を提供することができます。

ありがとうございます。

♪