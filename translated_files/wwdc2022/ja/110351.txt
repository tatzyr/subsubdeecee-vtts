110351

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

こんにちは。

私はSwiftチームのDougで、データレースを排除するためのSwift Concurrencyのアプローチについて話すためにここにいます。

並行プログラムを書きやすくする一連の言語機能として、Swift Concurrencyを導入しました。

これらの個々の言語機能の仕組みについては、それぞれをカバーする2021年のWWDC講演を参照してください。

この講演では、データレースを導入せずに並行性を効率的に利用するためにプログラムを構造化する方法として、Swift Concurrencyの異なる、より包括的な見方を取ります。

しかし、そうするには、私たちは素晴らしいアナロジーが必要なので、並行性の公海で私たちと一緒に航海することを勧めます。

並行性の海は予測不可能で、一度に多くのことが起こっていますが、あなたが舵取りをし、スウィフトがあなたが海をナビゲートするのを手伝って、それは素晴らしいものを生み出すことができます。

飛び込もう！

まず、Swiftの並行性モデルの重要なアイデアの1つである分離について話し、データがデータレースを導入できる方法で共有されないようにします。

タスクの分離から始めましょう。

私たちの並行性の海では、タスクはボートで表されます。

ボートは私たちの主な労働者です - 彼らはやるべき仕事があり、最初から最後まで順番に実行します。

それらは非同期であり、その作業はコードの「待機」操作で何度でも中断することができます。

最後に、それらは自己完結型です。各タスクには独自のリソースがあるので、海の他のすべてのボートとは独立して、単独で操作できます。

私たちのボートが完全に独立している場合、データレースのない並行性がありますが、何らかの通信方法がなければあまり役に立ちません。

コミュニケーションを追加しましょう!

例えば、あるボートには、別のボートと共有したいパイナップルがあるかもしれません。

だから、ボートは外洋で出会い、パイナップルをあるボートから別のボートに移します。

さて、このパイナップルは、あるボートから次のボートに移動する物理的なアイテムではないので、これは物理的なアナロジーが少し壊れる場所です。

それはデータであり、Swiftでは、そのデータを表現するいくつかの異なる方法があります。

パイナップルの種類をどのように定義しますか?

私たちはスウィフトの値タイプが好きなので、パイナップルをその重量と熟度によって定義される構造体にしましょう。

これがどのように機能するか見てみましょう。

ボートが外洋で会うとき、私たちは本当にパイナップルインスタンスのコピーを1つのボートから次のボートに渡し、各ボートは独自のコピーで消えます。

Slice() や ripen() メソッドを呼び出すなど、コピーを変異させた場合、他のメソッドには影響しません。

Swiftは、まさにこの理由で常に値型を好んできました。突然変異は局所的な影響しかありません。

その原則は、価値タイプが分離を維持するのに役立ちます。

では、データモデルを少し拡張して、鶏を追加しましょう!

食べるのに良いパイナップルとは異なり、鶏は独自の個性を持つ美しい生き物です。

だから、私たちはこのようなクラスでそれらをモデル化するつもりです。

勇敢な船員に鶏を交換してもらいましょう。

私たちのボートが会うとき、私たちはチキンを共有しますが、チキンのような参照タイプをコピーしてもチキンの別の完全なコピーは得られません、それはあなたにその特定のオブジェクトへの参照を与えます。

だから、私たちのボートが別々の道を行くと、私たちは問題を抱えていることがわかります。両方のボートは同時に仕事をしていますが、両方とも同じチキンオブジェクトを参照しているため、独立していません。

その共有可変データは、一方のボートが鶏に餌を与えようとし、もう一方のボートがそれで遊びたいときなど、データレースになりやすく、非常に混乱した鶏につながります。

パイナップルをボートで共有しても安全だったが、鶏は安全ではないことを知る方法が必要です。

そして、鶏が誤ってあるボートから別のボートに渡されないように、Swiftコンパイラでチェックインする必要があります。

Swiftプロトコルは、その動作について推論できるように、タイプを分類する素晴らしい方法です。

Sendableプロトコルは、データレースを作成することなく、異なる分離ドメイン間で安全に共有できるタイプを記述するために使用されます。

タイプは、コンフォーマンスを書くことで送信可能にすることができます。

パイナップル構造体は値型であるためSendableに準拠していますが、Chickenクラスは同期されていない参照型であるためできません。

Sendableをプロトコルとしてモデル化することで、データが分離ドメイン間で共有される場所を記述することができます。

たとえば、タスクが値を返すと、この値は、その値を待っているタスクのいずれかに提供されます。

ここでは、タスクからチキンを返そうとしていますが、チキンが送信できないため、これは安全ではないというエラーが表示されます。

実際のSendable制約は、Successと呼ばれるタスクの結果タイプがSendableプロトコルに準拠しなければならないことを指定するタスク構造体自体の定義から来ています。

値が異なる分離ドメインに渡される汎用パラメータを持つSendable制約を使用する必要があります。

さて、ボート間でデータを共有するというアイデアを再検討しましょう。

2隻のボートが公海で出会い、データを共有したい場合は、すべての商品を一貫してチェックして、安全に共有できるかどうかを確認する人が必要です。

これは、Swiftコンパイラがここで演じるフレンドリーな税関検査官の役割であり、Sendableタイプのみが交換されるようにします。

パイナップルは大丈夫で、送信可能なので自由に交換できます。

しかし、鶏肉は交換できず、私たちのフレンドリーな税関検査官は私たちがその間違いを犯すのを防ぎます。

コンパイラは、多くの異なるポイントで送信可能な正確性のチェックに関与しています。

送信可能なタイプは、構築によって正しくなければならず、共有データを密輸することはできません。

列挙型と構造体は通常、すべてのインスタンスデータをコピーして独立した値を生成する値型を定義します。

したがって、すべてのインスタンスデータも送信可能である限り、送信可能にすることができます。

Sendableは、条件付き適合を使用して、コレクションやその他のジェネリックタイプを通じて伝播できます。

Sendableタイプの配列はSendableなので、パイナップルでいっぱいのクレートもSendableです。

これらのSendableの適合性はすべて、非公開型のSwiftコンパイラによって推測することさえできるため、Ripeness、Pineapple、およびCrateはすべて暗黙的にSendableです。

しかし、鶏の群れを収容する小屋を作ったとしましょう。

このタイプは、送信可能でない状態が含まれているため、送信可能としてマークすることはできません。チキンは送信可能ではないため、鶏の配列は送信可能ではありません。

コンパイラから、このタイプを安全に共有できないことを示すエラーメッセージが表示されます。

クラスは参照型であるため、最終的なクラスに不変のストレージしかない場合など、非常に狭い状況でのみ送信可能にすることができます。

ChickenクラスをSendableにしようとすると、可変状態が含まれているため、エラーが発生します。

これで、ロックを一貫して使用することで、独自の内部同期を行う参照型を実装することが可能になります。

これらのタイプは概念的には送信可能ですが、Swiftがそれについて推論する方法はありません。

チェックされていないSendableを使用して、コンパイラのチェックを無効にします。

@Unchecked Sendableを介して変更可能な状態を密輸することは、スウィフトが提供しているデータレースの安全性を保証するため、これに注意してください。

タスクの作成には、ボートから手漕ぎボートを送り出すなど、新しい独立したタスクで閉鎖を実行することが含まれます。

これを行うと、元のタスクから値をキャプチャし、新しいタスクに渡すことができるので、データレースを導入しないようにSendableチェックが必要です。

この境界を越えて送信不可能なタイプを共有しようとすると、Swiftコンパイラが私たちをカバーし、このようなエラーメッセージを生成します。

これはタスク作成のための魔法ではありません。

クロージャは、At-Sendableで明示的に書かれた可能性のあるSendableクロージャであると推測されています。

Sendableクロージャは、Sendable関数型の値です。

At-Sendableは、関数型がSendableプロトコルに準拠していることを示すために、関数型に書き込むことができます。

これは、その関数型の値を他の分離ドメインに渡し、キャプチャされた状態にデータレースを導入することなく、そこで呼び出すことができることを意味します。

通常、関数型はプロトコルに準拠できませんが、コンパイラがセマンティック要件を検証するため、Sendableは特別です。

Sendableプロトコルに準拠したSendableタイプのタプルにも同様のサポートがあり、Sendableを言語全体で使用できます。

私たちが説明したシステムには、互いに分離された多くのタスクを同時に実行しています。

Sendableプロトコルは、タスク間で安全に共有できるタイプを記述し、Swiftコンパイラは、タスクの分離を維持するために、すべてのレベルでSendable適合性をチェックします。

しかし、どこでも共有可変データの概念がなければ、タスクが有意義な方法で調整するのは難しいです。

そのため、データレースを再導入しないタスク間でデータを共有する方法が必要です。

ここが俳優の出番です。

アクターは、さまざまなタスクでアクセスできる状態を分離する方法を提供しますが、データレースを排除する調整された方法で。

俳優は私たちの並行性の海の島です。

ボートのように、各島は自己完結型で、海の他のすべてのものから隔離された独自の状態があります。

その状態にアクセスするには、コードが島で実行されている必要があります。

たとえば、adsanceTimeメソッドはこの島に隔離されています。

それは島に住み、島の州すべてにアクセスできます。

実際に島でコードを実行するには、ボートが必要です。

ボートは島を訪れて島でコードを実行することができ、その時点でその州にアクセスできます。

一度にコードを実行するために島を訪れることができるのは1つのボートだけで、島の州への同時アクセスがないことを保証します。

他のボートが現れたら、彼らは島を訪れる順番を待たなければならない。

そして、特定のボートが島を訪れる機会を得るまでには長い時間がかかるかもしれないので、俳優に入ることは「待つ」キーワードでマークされた潜在的なサスペンションポイントです。

島が解放されると、再び、サスペンションポイントで、別のボートが訪れることができます。

2つのボートが外洋で会うのと同じように、ボートと島の間の相互作用は、送信不可能なタイプが2つの間を通過しないようにすることで、両方の分離を維持する必要があります。

例えば、おそらく私たちはボートから島の群れに鶏を追加しようとします。

これにより、異なる分離ドメインから同じチキンオブジェクトへの2つの参照が作成されるので、Swiftコンパイラはそれを拒否します。

同様に、島からペットの鶏を採用し、ボートで持ち去ろうとすると、送信可能なチェックにより、このデータレースを作成できなくなります。

アクターは参照型ですが、クラスとは異なり、同時アクセスを防ぐためにすべてのプロパティとコードを分離します。

したがって、別の分離ドメインのアクターへの参照を持つことは安全です。

それは島への地図を持っているようなものです:あなたは島を訪問するために地図を使用することができますが、あなたはまだその状態にアクセスするためにドッキング手順を通過する必要があります。

したがって、すべてのアクタータイプは暗黙的に送信可能です。

どのコードがアクターに分離され、どのコードが分離されていないかを知る方法を疑問に思うかもしれません。

俳優の隔離は、あなたがいる文脈によって決まります。

アクターのインスタンスプロパティは、そのアクターに分離されます。

アクターのインスタンスメソッドまたはアクターの拡張も、このad advanceTimeメソッドのように、デフォルトで分離されています。

削減アルゴリズムに渡されたクロージャなど、送信できないクロージャは、アクターにとどまり、アクター分離コンテキストにあるときにアクター分離されます。

タスク初期化子はまた、そのコンテキストからアクターの分離を継承するので、作成されたタスクは、開始されたのと同じアクターにスケジュールされます。

ここでは、群れへのアクセスを許可します。

一方、切り離されたタスクは、作成されたコンテキストから完全に独立しているため、コンテキストからアクターの分離を継承しません。

ここでのクロージャのコードは、孤立した「食べ物」プロパティを参照するために「await」を使用する必要があるため、アクターの外にあると考えられていることがわかります。

このクロージャには用語があります:それは非分離コードです。

分離されていないコードは、どのアクターでもまったく実行されないコードです。

非分離キーワードを使用して、アクターの外部に置くことで、アクター内の関数を明示的に非分離にすることができます。

切り離されたタスクに使用されたクロージャで暗黙的に起こったことと同じように。

つまり、俳優に隔離された州の一部を読みたい場合は、「待機」を使用して島を訪問し、必要な州のコピーを入手する必要があります。

分離されていない非同期コードは、常にグローバル協同組合プールで実行されます。

ボートが外洋に出ているときだけ走っていると考えるので、仕事をするために訪問している島を離れなければなりません。

つまり、送信不可能なデータを持ち行っていないことを確認することを意味します!

ここで、コンパイラは、送信不可能なチキンのインスタンスが島を離れようとしている潜在的なデータレースを検出します。

分離されていないコードのケースをもう1つ考えてみましょう。

「グリート」操作は、分離されていない同期コードです。

ボートや島、または一般的な並行性について何も知りません。

そして、ここで、私たちは俳優が分離したgreetOne関数からそれを呼んでいます、そしてそれは大丈夫です!

この同期コードは、島から呼び出されると、島にとどまるので、群れから鶏を自由に操作できます。

代わりに「グリート」を呼び出す非分離非同期操作があった場合、「グリート」は外洋でボートで実行されます。

ほとんどのSwiftコードは次のようになります。同期し、任意のアクターに分離せず、指定されたパラメータのみで動作するため、呼び出される分離ドメインにとどまります。

俳優は、プログラムの残りの部分から隔離された状態を保持します。

一度にアクターで実行できるタスクは1つだけなので、その状態への同時アクセスはありません。

送信可能なチェックは、タスクがアクターに出入りするときはいつでも適用され、同期されていない可変状態がエスケープされないようにします。

全体として、これは俳優をSwiftの同時プログラムの構成要素の1つにします。

私たちがよく話す、主役と呼ばれる別の特別な俳優がいます。

主人公は海の真ん中にある大きな島だと考えてください。

これは、ユーザーインターフェイスのすべての描画とインタラクションが発生するメインスレッドを表します。

したがって、何かを描きたい場合は、メイン俳優の島でコードを実行する必要があります。

それはあなたのUIにとって非常に重要なので、私たちはそれを「U-I-land」と呼ぶべきかもしれません。

主な俳優が「大きい」と言うとき、私たちが意味するのは、プログラムのユーザーインターフェイスに関連する多くの状態が含まれているということです。

UIフレームワークとアプリの両方で、実行する必要がある多くのコードがあります。その上で実行する必要があります。

しかし、それはまだ俳優なので、一度に1つのジョブしか実行しません。

したがって、UIが応答しなくなる可能性があるため、メインアクターにあまりにも多くの作業や長時間の作業をかけないように注意する必要があります。

メインアクターへの分離は、MainActor属性で表現されます。

この属性は、コードがメインアクターで実行する必要があることを示すために、関数またはクロージャに適用できます。

次に、このコードはメインアクターに分離されていると言います。

Swiftコンパイラは、他のアクターへの相互に排他的なアクセスを保証する同じメカニズムを使用して、メインアクター分離コードがメインスレッドでのみ実行されることを保証します。

メインアクターに分離されていないコンテキストからupdateViewを呼び出す場合は、メインアクターへの切り替えを説明するために「待機」を導入する必要があります。

メインアクター属性はタイプにも適用でき、その場合、これらのタイプのインスタンスはメインアクターに分離されます。

繰り返しますが、これは他のアクターと似ています。プロパティはメインアクターでのみアクセスでき、明示的にオプトアウトしない限り、メソッドはメインアクターに分離されます。

通常のアクターと同様に、メインアクタークラスへの参照自体は、データが分離されているため、送信可能です。

これにより、メインアクターの注釈は、必然的にフレームワーク自体によってメインスレッドに関連付けられているUIビューとビューコントローラーに適しています。

ビューコントローラーへの参照をプログラム内の他のタスクやアクターと共有することができ、ビューコントローラーに非同期に呼び戻して結果を投稿することができます。

これはアプリのアーキテクチャに直接影響します。

アプリでは、ビューとビューコントローラーがメインアクターになります。

他のプログラムロジックは、そのメインアクターから分離し、他のアクターを使用して共有状態とタスクを安全にモデル化し、独立した作業を記述する必要があります。

そして、これらのタスクは、必要に応じて主役と他の俳優の間を行き来することができます。

並行アプリでは多くのことが起こっているので、私たちはあなたがそれを理解するのに役立ついくつかの素晴らしいツールを構築しました。

詳細については、「スウィフト並行性の視覚化と最適化」トークをご覧ください。

原子性について話すために、より深い海に飛び込みましょう。

Swift Concurrencyモデルの目標は、データ競合を排除することです。

それが本当に意味することは、データ破損を伴う低レベルのデータレースを排除するということです。

あなたはまだ高いレベルで原子性について推論する必要があります。

前に話したように、俳優は一度に1つのタスクしか実行しません。

ただし、アクターで実行をやめると、アクターは他のタスクを実行できます。

これにより、プログラムが進歩し、デッドロックの可能性が排除されます。

ただし、待機ステートメントの周りに俳優の不変量を慎重に検討する必要があります。

そうしないと、データが実際に破損していなくても、プログラムが予期しない状態にある高レベルのデータレースに終わる可能性があります。

これの例を分解しましょう。

ここでは、島にいくつかの追加のパイナップルを堆積させる機能があります。

それは俳優の外にあるので、分離されていない非同期コードです。

それは、ここ外洋で走り出すことを意味します。

それはいくつかのパイナップルと、それらのパイナップルを預けるべき島への地図を与えられました。

ここでの最初の興味深い操作は、島から食べ物の配列のコピーを取得します。

これを行うには、ボートは「待つ」キーワードで示される島を訪れる必要があります。

食べ物のコピーがあるとすぐに、ボートは仕事を続けるために外洋に戻ります。

それは、島から得た2つにパイナップルパラメータからパイナップルを追加することを意味します。

これで、関数の最後の行に進むことができます。

私たちのボートは今、これらの3つのパイナップルに島の食べ物の配列を設定するために再び島を訪問する必要があります。

ここでは、すべてがうまくいき、島には3つのパイナップルがあります!

しかし、物事は少し違っていたかもしれません。

私たちの最初のボートが島を訪れる順番を待っている間に、海賊船が忍び込み、すべてのパイナップルを盗んだとしましょう。

今、私たちの元の船は島に3つのパイナップルを堆積し、私たちは問題に気づきます。

3つのパイナップルが突然5つのパイナップルに変わった!

ここで何があったの?

さて、同じ俳優の州へのアクセスのために2つの待機があることに注目してください、そして、私たちはここで島の食糧配列がそれらの2つの待機の間で変わらないと仮定しています。

しかし、これらは待っています。つまり、私たちのタスクはここで中断され、俳優は海賊との戦いなど、他の優先度の高い仕事をすることができます。

この特定のケースでは、Swiftコンパイラは別のアクターの状態を完全に変更しようとする試みを拒否します。

しかし、このように、入金操作をアクターの同期コードとして書き換える必要があります。

これは同期コードであるため、中断することなくアクターで実行されます。

したがって、島の状態は機能全体を通して他の誰によっても変わらないことを確信できます。

アクターを書くときは、何らかの方法でインターリーブできる同期的なトランザクション操作の観点から考えてください。

彼ら全員が、俳優が終了時に良い状態にあることを確認する必要があります。

非同期アクター操作の場合、それらをシンプルに保ち、主に同期のトランザクション操作からそれらを形成し、各待機操作でアクターが良好な状態にあるように注意してください。

このようにして、アクターを最大限に活用して、低レベルと高レベルのデータレースの両方を排除することができます。

同時プログラムでは、多くのことが一度に起こっているため、それらのことが起こる順序は、実行ごとに異なる場合があります。

しかし、プログラムは多くの場合、一貫した順序でイベントを処理することに依存しています。

たとえば、ユーザー入力やサーバーからのメッセージから入ってくるイベントのストリーム。

これらのイベントストリームが入ってくると、その効果が順番に起こると予想されます。

Swift Concurrencyは操作を順序付けするためのツールを提供しますが、アクターはそうするためのツールではありません。

俳優は、システム全体が応答性を維持するのを助けるために、最も優先度の高い作業を最初に実行します。

これにより、同じアクターで優先度の高い作業が行われる前に、優先度の低い作業が行われる優先度反転が排除されます。

これは、厳密に先入れ先出し順で実行されるシリアルディスパッチキューとは大きな違いであることに注意してください。

Swift Concurrencyには、作業を注文するためのいくつかのツールがあります。

最初に、私たちはすでに多くのことを話してきました - タスク

タスクは、慣れている通常の制御フローで最初から最後まで実行されるため、自然に作業を注文します。

AsyncStreamは、実際のイベントストリームをモデル化するために使用できます。

1つのタスクは、for-await-inループでイベントのストリームを反復し、各イベントを順番に処理できます。

AsyncStreamは、任意の数のイベントプロデューサーと共有でき、順序を維持しながらストリームに要素を追加できます。

Swiftの並行性モデルは、タスクとアクターの境界でSendableチェックによって維持される分離の概念を使用してデータレースを排除するようにどのように設計されているかについて多くのことを話しました。

しかし、私たちは皆、どこにでもすべてのSendableタイプをマークするためにやっていることを止めることはできません。

代わりに、漸進的なアプローチが必要です。

Swift 5.7では、SwiftコンパイラがSendabilityをどれだけ厳密にチェックすべきかを指定するビルド設定が導入されています。

デフォルト設定はMinimalです。つまり、コンパイラは明示的に何かをSendableとしてマークしようとした場所のみを診断します。

これはSwift 5.5と5.6の動作に似ており、上記については警告やエラーはありません。

さて、Sendableコンフォーマンスを追加すると、ChickenがSendableではないため、コンパイラはCoopタイプがSendableできないと文句を言います。

ただし、これと他のSendable関連の問題は、問題を1つずつ解決しやすくするために、エラーではなくSwift 5で警告として表示されます。

データレースの安全性に向けてさらに進むには、「ターゲットを絞った」厳格な並行性設定を有効にします。

この設定により、async/await、タスク、アクターなどのSwift並行性機能をすでに採用しているコードのSendableチェックが可能になります。

これは、たとえば、新しく作成されたタスクで送信不可能なタイプの値をキャプチャしようとする試みを識別します。

送信不可能なタイプは、別のモジュールから来ることがあります。

おそらく、それはまだSendable用に更新されていないパッケージ、またはあなたが回避していない独自のモジュールです。

それらについては、@preconcurrency属性を使用して、そのモジュールから来たタイプの送信可能な警告を一時的に無効にすることができます。

これにより、このソースファイル内のチキンタイプの送信可能な警告が消音になります。

ある時点で、FarmAnimalsモジュールはSendableコンフォーマンスで更新されます。

次に、2つのうちの1つが起こります。Chickenが何らかの形でSendableになり、その場合、preconcurrency属性をインポートから削除できます。

または、チキンは送信可能ではないことが知られており、その場合、警告が戻ってきて、チキンが送信可能であるというあなたの仮定が実際には正しくないことを示しています。

ターゲットを絞った厳格さの設定は、既存のコードとの互換性と潜在的なデータレースの特定のバランスを取ろうとします。

ただし、レースが発生する可能性のある場所をどこでも見たい場合は、もう1つのオプションがあります。完全なチェックです。

完全なチェックは、データレースを完全に排除するために、意図したSwift 6セマンティクスを近似します。

以前の2つのモードがチェックするすべてをチェックしますが、モジュール内のすべてのコードに対してチェックします。

ここでは、実際にはSwiftの並行性機能をまったく使用していません。

むしろ、そのコードを同時に実行するディスパッチキューで作業を実行しています。

ディスパッチキューでの非同期操作は、実際には送信可能なクロージャを取ることが知られているため、コンパイラは、送信不可能なボディがディスパッチキューで実行されているコードによってキャプチャされたときにデータレースがあることを示す警告を生成します。

本文パラメータを送信可能にすることで、これを修正できます。

その変更により、この警告が排除され、doWorkのすべての発信者は、Sendableクロージャを提供する必要があることを知っています。

つまり、データレースをよりよくチェックし、訪問機能がデータレースのソースであることがわかります。

完全なチェックは、プログラムの潜在的なデータレースを洗い流すのに役立ちます。

データレースを排除するというSwiftの目標を達成するためには、最終的にはチェックを完了する必要があります。

その目標に向かって段階的に取り組むことをお勧めします。Swiftの並行性モデルを採用して、データレースの安全性のためにアプリを設計し、徐々に厳格な並行性チェックを有効にして、コードからエラーのクラスを排除します。

また、インポートされたタイプの警告を抑制するために、インポートを@preconcurrencyでマークすることを心配しないでください。

これらのモジュールはより厳格な並行性チェックを採用するため、コンパイラはあなたの仮定を再チェックします。

この道の終わりに、あなたのコードはメモリの安全性とデータレースの安全性の両方から恩恵を受け、優れたアプリの構築に集中するのに役立ちます。

そして、並行性の海で私と一緒に航海してくれてありがとう。

♪