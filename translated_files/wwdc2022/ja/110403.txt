110403

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

こんにちは！私の名前はジャレッドで、アップルのソフトウェアエンジニアです。

今日は、今年iOS、iPadOS、macOSに導入する新しいフレームワークについてお話ししたいと思います。

この新しいフレームワークはバックグラウンドアセットと呼ばれ、私たち全員が知っていて愛している、そしてさらに重要なことに、あなたが開発するアプリのユーザーエクスペリエンスを大いに豊かにすると信じています。

まず、新しいバックグラウンドアセットフレームワークを紹介します。 バックグラウンドアセットフレームワークを紹介します。

その後、新しいフレームワークをアプリに採用する方法を紹介します。

その後、拡張機能とそれが提供する新機能の概要が続きます。

その後、いくつかのベストプラクティスと私たちが学んだすべてで終わります。

始める前に、ここで解決しようとしていることについて話しましょう。

真実は、待つことは楽しくないということです。

ソフトウェアを使用する人に待つように頼むたびに、私たちは欲求不満を増し、アプリに提供してほしい経験から奪っています。

例えば、どのくらいの頻度で、その完璧なアプリを探してApp Storeを際限なく閲覧していることに気づきましたか?

あなたはついにそれを見つけました、そしてああ、それはとても完璧に見えますか!

次に、そのGETボタンをタップします。

瞬間ごとに、あなたの興奮のレベルが高まります。

その後、ネットワーク接続やアプリのサイズによっては、アプリがダウンロードされるのを待たなければならないかもしれません。

その後、数秒待った後、あなたは携帯電話を置き、コーヒーを飲み、マインドフルネスを実践し、忍耐を習得することの利点についてのあなたのお気に入りの本を読んでいます。

それから数時間が経ち、あなたはついに電話を取りました。

一日中使うのを待っていた完璧なアプリに飛び込む準備ができたら、興奮レベルが上がります。

アプリを起動し、すぐにこれで迎えられるために:より多くのダウンロード。

紛らわしい。

あなたは一日中電話から離れていました。

なぜこのアプリは今、あなたをさらに長く待たせるのですか?

このアプリは、アプリがインストールされた後、このコンテンツを自動的にダウンロードできませんでしたか?

インターネット接続が遅い人にとって、これはアプリを閉じて削除することを挫折させるかもしれません。

真実は、これは私たちの誰もが望む経験ではありません。

私たちはこれがあなたのせいではないことを知っており、この経験をはるかに良くすることができると信じています!

これが、私たちが今年あなたに紹介することを誇りに思う理由です、バックグラウンドアセット。

このフレームワークは、アプリのユーザーエクスペリエンスを豊かにするために開発されました。

アプリが起動した瞬間に、驚異的な第一印象を与えています!

バックグラウンドアセットは、既存のワークフローに柔軟に対応するように設計されています。

多くの人がすでに複雑な資産管理システムを開発しており、この新しいフレームワークをすでに開発したソリューションに簡単に適合させたいと思っていました。

また、App Storeへの追加の提出を必要とせずに、更新されたコンテンツをアプリにプッシュできるようにしたいことも知っています。

アプリがすでに出荷された後、ゲームやその他のアプリが追加のコンテンツを必要とすることは珍しくありません。

更新されたアートテクスチャやゲームレベルのデータのバグ修正を考えてください。

バックグラウンドアセットは、アプリのライフサイクル外でアセットをスケジュールおよび更新する機能を提供します。

私たちは、最初のアプリの起動前、またはアプリが一晩で更新されるたびに、資産が存在することが重要だと考えています。

そのため、アプリの起動時までにコンテンツが存在することを確認するためのメカニズムの作成に取り組みました。

そして最後に、フレームワークの採用が簡単であればあるほど、アプリでの使用を奨励できます。

バックグラウンドアセットは、大規模なアセットを事前にダウンロードする必要がある場所で使用したいと考えています。

そうすれば、アプリが待機している時間を最小限に抑え、コンテンツが利用可能になる前にプログレスバーを表示することができます。

だから、この新しいフレームワークは、この問題の解決にどのように役立っているのか疑問に思うかもしれません。

さて、できるだけ拡張できるように、バックグラウンドでコンテンツをダウンロードするための新しいアプリ拡張機能を作成しました。

この新しい拡張機能は、当社のプラットフォーム上の他の拡張機能が使用する強力なアプリ拡張技術の上に構築されています。

これは、アプリのライフサイクルの外でコードを実行する機会を提供します。

たとえば、拡張機能は、ユーザーが最初にアプリをインストールしたが、まだ起動していないたびに実行されます。

拡張機能は、アプリがバックグラウンドで自動的に更新されるたびに実行されます。

これは、ユーザーが更新後にアプリケーションを開く前に、コンテンツをスケジュールしてダウンロードできるようにするのに役立ちます。

最後に、拡張機能はバックグラウンドで定期的に実行され、更新されたアセットを確認し、時間の経過とともに定期的にスケジュールすることができます。

注意することが重要ですが、その拡張ランタイムは短命であるため、すべての作業は急いで拡張機能でスケジュールする必要があります。

ダウンロードがすぐにスケジュールされない場合、システムは拡張機能を終了する可能性があります。

また、定期的に実行する拡張機能の頻度は、アプリの使用状況に基づいて後退することに注意することも重要です。

アプリがあまり使用されていない場合、拡張機能はランタイムの頻度が少なくなります。

つまり、新しいバックグラウンドアセットフレームワークの概要です。

アプリが起動されるまでにアセットが利用可能であることを確認するために必要なツールを提供します。

これは、アプリがインストールまたは更新されるたびに、ユーザーがアプリを起動する前に実行される拡張機能で行われます。

では、背景アセットフレームワークをプロジェクトに採用し、始めましょう!

フレームワーク内のダウンロードマネージャは、バックグラウンドアセットシステムサービスと通信するために使用される主要な手段です。

マネージャーは、アプリ全体で使用できるシングルトンオブジェクトです。

マネージャーを使用すると、フォアグラウンドまたはバックグラウンドでアセットのダウンロードをスケジュールできます。

また、アプリケーションが起動される前に開始された可能性のある、現在飛行中のダウンロードを取得することもできます。

ダウンロードもキャンセルできます。

これは、すでにスケジュールされている場合、またはダウンロード中であり、最初に要求したアセットが不要になった場合に便利です。

また、拡張機能とアプリケーションの両方が同時に既存のダウンロードをスケジュールまたは変更しないように、アプリと拡張機能間の排他的なアクセスを管理するための同期メカニズムを導入しました。

お見せする例がありますが、今のところ、これについては後で詳しく説明します。

バックグラウンドアセットを使い始めるのがどれほど簡単かを見てみましょう。

まず、APIの基本をいくつかご案内します。

その後、これらすべてをアプリの拡張機能に結びつける方法を示すことで、後でフォローアップします。

開始するには、バックグラウンドアセットフレームワークモジュールをインポートします。

次に、リモートアセットが配置されている場所を指すURLを定義するのと同じくらい簡単です。

次に、拡張機能とアプリの両方がメンバーであるアプリグループコンテナを定義します。

アプリと拡張機能を同じグループにまとめることで、ダウンロード中と完了後にアセットを管理できます。

アプリグループにまだ慣れていない場合は、Xcode 14の「署名と機能」セクションから簡単に追加できます。

これらは、2つ以上のアプリケーションが同じリソース、またはこの場合はアプリとその拡張機能にアクセスできるようにする強力な機能です。

次に行うことは、ダウンロードオブジェクトを作成することです。

バックグラウンドアセットフレームワークは、複数の異なるタイプのダウンロードオブジェクトをサポートするように設計されています。

ただし、この例では、最も一般的なもの、BAURLDownloadに焦点を当てます。

すぐに、初期化子がURLとアプリグループの識別子を取り込むことに気付くでしょう。

この情報は、私たちがダウンロードしているものと、結果のファイルがどこで終わるかの両方をシステムに伝えます。

また、識別子も必要です。

この識別子を使用して、アプリの複数の起動と拡張機能内でダウンロードを追跡します。

エンジンは、同じ識別子で複数のダウンロードをスケジュールすることはできません。

したがって、これらの識別子を一意にする必要があります。

次に、BADownloaderManager共有オブジェクトへの参照をつかみます。

ダウンロードマネージャは、バックグラウンドアセットへの単一のインターフェースです。

それはあなたがダウンロードを観察し、キャンセルし、スケジュールすることを可能にするものです。

次に、BADownloadManagerDelegateプロトコルに準拠したデリゲートへの弱い参照を渡します。

まもなくこのプロトコルについて詳しく行きますが、今知っておくべき最も重要な部分は、スケジュールされたダウンロードに関するメッセージを受信することです。

残っているのは、ダウンロードマネージャーにダウンロードのスケジュールを依頼することだけです。

何らかの理由でダウンロードをスケジュールできない場合は、エラーがスローされます。

バックグラウンドでダウンロードをスケジュールするだけでなく、フォアグラウンドダウンロードを行うためのAPIも提供しています。

フォアグラウンドで実行すると、優先順位が高まるだけでなく、ダウンロードをすぐに開始することもできます。

これは、URLSession内でデフォルトのセッション設定を使用するのと似ています。

アプリが拡張機能によってスケジュールされたダウンロードをバックグラウンドでフォアグラウンドに促進できるように、このAPIを提供します。

覚えておくべきことの1つは、フォアグラウンドダウンロードの実行は、拡張機能内からは利用できないことです。アプリからのみ開始できます。

拡張機能はUIを提示せず、ユーザーは実行されていることに気付かないため、拡張機能はバックグラウンドでのみダウンロードをスケジュールすることができます。

アプリが既存のバックグラウンドダウンロードをフォアグラウンドに宣伝したい場合は、マネージャーから現在アクティブなダウンロードのリストを取得することで簡単に実現できます。

返されるリストには、現在スケジュールされているすべてのダウンロードが含まれています。これには、飛行中のダウンロードやスケジューラでキューに入れられたダウンロードが含まれる場合があります。

次に、アプリはstartForegroundDownloadを呼び出すことでプロモーションプロセスを開始できます。

ダウンロードがすでにフォアグラウンドにある場合、このメソッドを呼び出すと事実上何もしません。

ただし、ダウンロードがバックグラウンドの場合、最初に一時停止され、その後、この時点まですでにダウンロードされていたコンテンツを再ダウンロードする必要なしに、フォアグラウンドで再開されます。

これは、バックグラウンドアセットを使用して、バックグラウンドでスケジュールされたダウンロードをフォアグラウンドに促進することがいかに簡単かを示す効果的で簡単な説明を提供します。

それは本当にそれと同じくらい簡単です!

ダウンロードマネージャーは、バックグラウンドダウンロードをスケジュールおよび監視するために使用される主要なインターフェイスです。

これらのダウンロードオブジェクトはシステムによって処理されるため、デリゲートオブジェクトにメッセージを受信します。

では、デリゲートを歩きましょう。

デリゲートは、拡張機能またはアプリによってスケジュールされたすべてのダウンロードに関するメッセージを受信します。

スケジュールされた多数のダウンロードがある場合、それらすべてに対してコールバックが受信されます。

これは、ダウンロードオブジェクトの一意の識別子を使用してそれらを区別する場所です。

デリゲートがBADownloadManagerに設立された瞬間に、アプリはコールバックを受信し始めます。

コールバックはシステムによってキューにされません。

アプリがデリゲートメソッドの1つを処理しない場合、またはデリゲートが確立されていない場合、拡張機能は目を覚ましてメッセージを処理します。

これは、アプリ内でBADownloadManagerにデリゲートを確立していない場合は、拡張機能にメッセージが送信されることを完全に期待する必要があることを意味します。

アプリが現在ユーザーに提示されているフォアグラウンドにあり、そのデリゲートが確立されている場合、コールバックはアプリに送信され、拡張機能は起こされません。

拡張機能は、アプリがデリゲートコールバックを処理しない場合にのみ起動します。

ダウンロードが終了または失敗し、アプリがこのメッセージを処理しない場合、拡張機能はスリープ解除されます。

拡張機能はすべてのタイプのコールバックで目覚めるわけではないことを覚えておいてください。

BADownloadManagerDelegateとBADownloaderExtensionプロトコル間の共通インターフェイスを共有するコールバックのみ。

ダウンロードの成功または失敗は、デリゲートとプロトコルの間の共通のインターフェイスの例です。

アプリ拡張機能には、スリープ解除を引き起こす独自のエントリポイントがありますが、拡張機能が現在実行されている場合は、BADownloadManagerを使用してデリゲートを確立できます。

これにより、アプリと拡張機能の両方がデリゲートに重複したメッセージを受信できるようになります。

拡張機能は、デリゲートメッセージを処理するためにスリープ解除されないことを覚えておいてください。

それらは、BADownloaderExtensionプロトコルで定義された拡張エントリポイントでのみ起動します。

ダウンロードマネージャーのデリゲートのプロトコルを見てみましょう。

最初の機能は、ダウンロードが始まるたびにメッセージを受信することです。

これは、デバイスが最終的に特定のダウンロードをスケジュールすることを選択したときの追跡に役立ちます。

ダウンロードが一時停止した場合にも通知される場合があります。

一時停止が発生する例は、拡張機能がバックグラウンドでダウンロードを開始し、アプリがそれをフォアグラウンドに昇格するように要求した場合です。

このプロモーションでは、ダウンロードが再開される前に一時停止する小さなウィンドウがあります。

ダウンロードマネージャーでは、フォアグラウンドでダウンロードされているダウンロードのアクティブな進行状況を監視することもできます。

また、チャレンジリクエストに答えるメカニズムも提供しています。これは、接続の信頼性を検証したり、接続を承認するための資格情報を提供するのに役立ちます。

最も重要な機能は、ダウンロードの失敗または終了したダウンロードに対処することです。

ダウンロードに失敗した場合は、スケジュールを変更するか、原因を特定する必要があるかもしれません。

ダウンロードを成功させるために、システムはオペレーティングシステムによって管理されている場所にファイルを配置しました。

デバイスの容量が足りなくなった場合、システムはファイルを削除します。

システムが提供した場所にファイルを残すことを強くお勧めします。

絶対に必要である場合にのみファイルを移動し、後で元のファイルを削除しない限り、ファイルを複製しないでください。

念のため、ダウンロードマネージャーの代理人のプロトコルは、アプリや拡張機能がスケジュールしたダウンロードに関連するメッセージを受信するためのものです。

それはあなたの拡張機能のエントリポイントではないので、次のトピックに進みます。

次に、バックグラウンドアセットの最もエキサイティングな部分、拡張機能を見ていきます!

この拡張機能を使用すると、ユーザーがアプリを起動する前に、アセットのダウンロードをスケジュールできます。

これにより、最小限の待ち時間でアプリで可能な限り最高のエクスペリエンスを提供するために、資産が配置され、準備ができていることを確認できます。

先に説明したように、新しいアプリ拡張機能を導入しています。

この拡張機能は、既存のプロジェクト内のXcode内から作成できます。

簡単なリマインダーとして、拡張機能はアプリがインストールまたは更新されるたびに実行されます。

アプリの変更に常に最新の資産があることを確認する柔軟性を提供します。

この拡張機能は、ユーザーがアプリを使用する頻度に基づいて定期的に実行されます。

誰かがあなたのアプリを毎日使用している場合、システムはこの動作を学習し、拡張機能はより頻繁に実行されます。

ただし、アプリが起動しない場合、この定期的なチェックの頻度は収まります。

新しい拡張機能には、短いライフサイクルとタイトなサンドボックスもあり、その使用がアセットをダウンロードするだけに制限されていることを保証します。

拡張機能で迅速な決定を下し、拡張機能をバックグラウンドアセットフレームワークに制限することをお勧めします。

拡張機能のナビゲートを開始する前に、拡張機能を起動する前に作成する必要がある設定がいくつかあります。

これらの変更は、アプリがApp Storeでの配布を承認するための要件でもあります。

アプリの情報プロパティリストでは、いくつかの追加キーを定義する必要があります。

これらのキーは、拡張機能のInfo.plistではなく、アプリのみに配置する必要があります。

最初のキーはBAInitialDownloadRestrictionsです。

これは、拡張機能に課される制限を指定する辞書です。

これらの制限はApp Reviewによってレビューされるので、できるだけ正確であるようにしてください。

では、辞書内の個々のキーを掘り下げてみましょう。

最初の制限はダウンロード許容量です。

これはバイト単位で表され、最初のアプリのインストール中に拡張機能内で要求する最大ダウンロードサイズです。

このサイズは、個々のファイルのサイズではなく、ダウンロードをリクエストするすべてのファイルの合計に関係します。

次の項目は、文字列として表されるドメインの配列を取るドメインAllowListです。

ドメインAllowListはプレフィックスワイルドカードをサポートし、拡張機能がダウンロードが許可されているホスト名のリストを取り込みます。

DownloadAllowanceやAllowListなどのBAInitialDownloadRestrictionsのキーは、最初のアプリのインストール後にのみ強制されることに注意することが重要です。

アプリが起動するたびに、これらの制限は適用されなくなります。

Info.plistのルートにある最後の必要なキーは、アプリがこれらのアセットの追加ストレージに必要な最大サイズです。

圧縮されたアセットをダウンロードしたいかもしれないので、この値は最終的な抽出された非圧縮サイズである必要があります。

ここに置かれた番号は、アプリがダウンロードされる前にApp Storeに表示されます。

ハウスキーピングについて説明しましたので、拡張機能へのエントリポイントについて詳しく話しましょう。

プロトコルから定義した関数は、アプリではなくシステムによって呼び出されます。

アプリケーションが拡張機能と会話する責任を負う他のアプリ拡張機能とは異なり、バックグラウンドダウンロード拡張機能はシステムによって仲介されます。

システムは拡張機能のライフサイクルを維持しているため、一時的なサービスと見なされるべきです。

プロトコル内の機能のいずれかが呼び出されるたびに、そこで行われる作業を最小限に抑えることが重要です。

拡張機能は、起動後すぐに終了します。

ここは、しばらく時間がかかる可能性のある減圧やその他の複雑な操作を開始する場所ではありません。

拡張機能での作業の大きな部分の1つは、アプリで利用可能なすべてのBackgroundAssets APIが拡張機能内でも利用可能であることです。

唯一の例外はForegroundDownload APIです。

これは、アプリと同じようにBADownloadManagerを使用することを意味します。

実際のところ、アプリとその拡張機能の両方で資産をスケジュールおよび管理するために同じコードを使用するものを作成する機能を発見する可能性が十分にあります。

また、拡張機能を作成するときは、両方が共通のアプリグループにあることを確認することが重要です。

アプリとその拡張機能でコンテンツを読み書きできるように、同じグループ識別子を使用する必要があります。

それでは、拡張機能に適合するダウンローダ拡張プロトコルを見てみましょう。

最初に気付くのは、ダウンロードマネージャーのデリゲートプロトコルにどれほど似ているかです。

先に述べたように、BADownloadManagerを使用して、拡張機能内からデリゲートを構築できます。

しかし、これらのエントリポイントだけが実際に拡張機能を目覚めさせることができます。

最初の機能は、アプリケーションが最初にインストールされるたびに呼び出されます。

アプリはまだ起動していませんが、あなたの拡張機能は起動しています。

これは、アプリが起動したら、アプリが最高の体験を提供するために必要なダウンロードのスケジューリングを開始する絶好の機会です。

また、最初のアプリのインストール中に、ダウンロード制限が有効であることを思い出すことも重要です。

Info.plistで定義したBADownloadRestrictionsキーを参照して、最大許可されたダウンロードサイズと許可されたドメインが何であるかを知る必要があります。

この次の機能は、App Storeがアプリを更新するたびに呼び出されます。

ユーザーがアプリスイッチャーでアプリを終了していない限り、新しく更新された拡張機能がスリープし、作業のスケジューリングを開始できます。

checkForUpdates機能は、拡張機能がシステムによって定期的に起動されるのをサポートしているため、バックグラウンドでダウンロードする必要があるアップデートを確認できます。

この機能は、ユーザーがアプリを使用する頻度に基づいてシステムによって呼び出されます。

また、認証チャレンジリクエストへの対応もサポートしています。

そのため、ダウンロードしているファイルが信頼できるソースから来ていることをよりよく制限し、確認することができます。

最後に、デリゲートと同様に、ダウンロードが失敗または成功した場合に通知されます。

バックグラウンドDownloadDidFail関数では、エラーが返されていないことに気付くでしょう。

エラーは、返されたBADownloadオブジェクト内の変数で、その状態とともに取得できます。

また、拡張機能がダウンロードをスケジュールしたものでなくても、最後の3つの機能を呼び出すことができることに注意することも重要です。

アプリがダウンロードをスケジュールしたが、バックグラウンドになっていない場合、拡張機能はダウンロードにサービスを提供することが期待されます。

アプリとその拡張機能からBADownloaderManagerを使用する方法を理解したので、アプリとその拡張機能の両方が同時に実行されている場合の意味を考え始める必要があります。

たとえば、システムが拡張機能をウェイクして定期的に更新をチェックする時が来たと判断したとしましょう。

そしてもちろん、拡張機能はこのチェックを行うためにネットワークにアクセスする必要があるため、BADownloaderManagerを使用して、利用可能な更新されたアセットのリストを提供するカタログまたはその他のタイプのメタデータのダウンロードをスケジュールします。

たとえば、ファイルが、ダウンロードする必要がある大規模なマルチギガバイトアセットのリストを含む小さな100KBのカタログであるとします。

拡張機能は、スケジュールされたダウンロードがいつ終了したか、または失敗したかを知る必要があるため、ダウンロードマネージャーにデリゲートを添付します。

ダウンロードマネージャーのデリゲートは、スケジュールするより大きな資産を決定するために小さなファイルをダウンロードするため、拡張エントリポイントで使用され、拡張エントリポイントがすぐに呼び出されることは保証されません。

ダウンロードが完了すると、拡張機能はデリゲートを通じてこのメッセージを受信します。

これで、拡張子はカタログファイルにアクセスでき、ダウンロードしたファイルで何をする予定かを選択する必要があります。

拡張機能がファイルを読み込んで、カタログのどのアセットをデバイスにダウンロードする必要があるかを判断すると想像できます。

その後、拡張機能は、これらのより大きな資産のバックグラウンドダウンロードをスケジュールすることができます。

ダウンロードしたファイルが不要になったので、拡張子はファイルを削除する必要があります。

これは適切と思われますが、拡張機能の実行中にアプリが起動し、独自のBADownloadManagerを作成するとどうなりますか?

さて、見てみましょう! !

アプリは起動し、コンテンツが更新されたかどうかをすぐに知りたがっています。

おそらく、バージョン番号はアプリグループに保存され、両方ともアセットが最新かどうかを判断するために相談します。

新しいカタログのダウンロードが終了する前にアプリが起動されたため、マネージャーから現在のダウンロードを取得し、カタログのダウンロードが現在飛行中であることを認識し、デリゲートで完了するのを待ちます。

しかし、私たちには問題があります。

拡張機能とアプリの両方が、ダウンロードマネージャーに接続されたそれぞれのデリゲートでダウンロード終了メッセージを受け取ります。

これは、ダウンロードされているファイルにデータレースがあることを意味します。

アプリと拡張機能の両方が同時にファイルを読み取り、削除しようとします。これは良くありません。

これは、アプリまたは拡張機能のいずれかがファイルを読み取ろうとし、欠落している可能性があることを意味します。

これは、アプリ内の2つのスレッドについて考えるのと同様の方法でアプリと拡張機能について考える必要があることを意味します。

幸いなことに、バックグラウンドアセットは、アプリとその拡張機能の間で同期する方法を提供します。

今、それについて話しましょう!

アプリとその拡張機能の同期は、バックグラウンドアセットで非常に簡単です。

私たちが現在見ているのは、ダウンロードが完了したときのダウンロードマネージャーのデリゲート機能です。

アプリまたは拡張機能がアクセスできるファイルへのローカルパスを含むURLが提供されます。

この例では、このファイルを相互に除外します。

次に、ダウンロードマネージャーへの参照をつかみ、完了ハンドラを取るwithExclusiveControl関数を使用します。

完了ハンドラスコープ内で実行されるすべてのコードは、排他的制御を必要とする他の呼び出しと相互に排他的であることが保証されています。

つまり、アプリが完了ハンドラから戻っていない間に拡張機能がExclusiveControlを呼び出す場合、拡張機能は待機します。

これは他の方向にも当てはまります。

拡張機能が最初に排他的な制御を取得した場合、アプリは拡張機能が終了するか、スコープを終了して制御を解放するまで待ちます。

心に留めておくべき重要なことは、排他的な制御の取得が失敗する可能性があるということです。

これが発生する可能性は非常に低いですが、その場合は、コードがそれを処理する必要があります。

関数によって提供されるエラーがnilではないかどうかを確認することで、排他的制御を取得できなかったかどうかを検出できます。

この時点から、アプリまたは拡張機能がそのコンテキスト内で独占的なアクセスを持っていることが保証されます。

したがって、以前の例に基づいて、ファイルの内容を読み上げてからクリーンアップすることが完全に有効になりました。

他のアプリや拡張機能が排他的なコントロールに入る機会を得たとき、あなたがすでにファイルを処理したことを知っていることに注意してください。

これを達成する1つの方法は、まずファイルが存在するかどうかを確認するか、データベースまたはplistに書き込むことです。

リマインダーとして、バックグラウンドダウンローダー拡張機能は、アプリの大規模なアセットのダウンロードを収集してスケジュールするためのものです。

ランタイムは短命なので、拡張機能内で行われる作業は最小限に抑えてください。

また、拡張機能とアプリを共有アプリグループに配置して、両方が互いにダウンロードしたファイルにアクセスできるようにする必要があります。

そして最後に、拡張機能はアプリではなくシステムによって仲介されます。

基本的なバックグラウンドダウンロード拡張機能を開発する方法がわかったので、アプリにバックグラウンドアセットを実装するために必要なものがすべて揃っています。

では、私たちが学んだことをやり直しましょう。

ダウンロードマネージャーは、アプリとその拡張機能間のダウンロードを調整してスケジュールするために使用されるため、両方の場所でダウンロードマネージャーを使用する必要があります。

アプリがフォアグラウンドになくても、拡張機能は実行されます。

これは、アプリのインストール、更新中、またはシステムによって決定された間隔で定期的に発生する可能性があります。

アプリが起動され、バックグラウンドでダウンロードされていたコンテンツが待機されている場合は、すぐにそれらのダウンロードをフォアグラウンドに宣伝してください。

拡張機能は、バックグラウンドでのみダウンロードをスケジュールできます。

アプリをフォアグラウンドに宣伝することで、コンテンツができるだけ早く届くようにします。

ダウンロードマネージャーへの排他的なアクセスが必要な場合は、排他的なコントロールAPIを使用してください。

これにより、アプリまたは拡張機能のみがそのウィンドウ内にランタイムを持つことが保証されます。

これは非常に便利なので、コンテナにアクセスしたり、ダウンロードを管理したりする際に、アプリをレースする拡張機能について考える必要はありません。

このプレゼンテーションから取るべきものがあれば、それは待つことが貧弱なアプリ体験をもたらすということです。

待っているタスクが進行している間にアプリを使用できるようにすることで、待ち時間を最小限に抑えます。

アプリでの待ち時間を最小限に抑える方法の1つは、新しいバックグラウンドアセットフレームワークと基礎となるバックグラウンドダウンロード拡張機能を採用することです。

これは、アプリが起動する前に、アプリがすべてのコンテンツの準備ができていることを確認するのに役立ちます。

また、このプレゼンテーションに組み込まれていない可能性のある追加情報を含むドキュメントも必ず確認してください。拡張機能のテスト方法やエントリーポイントのシミュレーション方法など。

私たちはあなたとバックグラウンドアセットを共有できることを本当に楽しみにしており、あなたのフィードバックを大切にしています。

フィードバックアシスタントを使用して、何があなたのために働いているのか、何を改善したいのかをお知らせください。

これは新しいフレームワークであり、播種中に調整する機会があります。

私たちは、あなたが面白いと思うかもしれないと思ういくつかの追加のセッションがあり、それらをチェックアウトすることをお勧めします。

「HTTP3でネットワーキングを加速する」は、バックグラウンドアセットとうまく組み合わせる素晴らしいセッションです。

また、別のセッションをチェックすることをお勧めします。「オンデマンドリソースの紹介」プレゼンテーションでは、コンテンツがAppleによってホストされ、リクエストに応じてファイルがダウンロードされるバックグラウンドアセットの代替手段について説明します。

これらのセッションは両方とも本当に魅力的で、提供できるものがたくさんあります。

私と一緒に時間を過ごしてくれてありがとう、そしてアップルのみんなを代表して、あなたが素晴らしいWWDCを過ごせることを願っています!

♪