110358

♪ ♪

こんにちは、私はリチャードです。Swift Standard Libraryチームのエンジニアです。

今日は、Swift Regexの基本を超えた旅に乗り出しましょう。

Swift 5.7は、文字列処理のための強力な新機能を獲得しています。

それらは、Swift Standard Libraryの新しいタイプである「Regex」タイプから始まります。

言語に組み込まれた正規表現リテラル構文は、この強力で馴染みのある概念をさらにファーストクラスにします。

そして最後に、RegexBuilderと呼ばれる結果ビルダーAPI。

これは、結果ビルダーの構文的なシンプルさと構成可能性を活用し、Regexの読みやすさをまったく新しいレベルに押し上げるドメイン固有の言語（DSL）です。

Swift Regexが文字列の処理を容易にする理由については、同僚のMichaelによるMeet Swift Regexセッションをチェックしてください。

Swift Regexの非常に簡単な例を見てみましょう。

データの文字列があり、この文字列からユーザーIDを照合して抽出したいとします。

通常の「NSRegularExpression」のように、テキストから正規表現を作成できます。

「user_id」コロンに続いて0個以上の空白とそれに続く1つ以上の数字と一致します。今回違うのは、Regex型の値を作成していることです。

これはSwift Standard Libraryの新しいタイプです。

次に、文字列の「firstMatch」アルゴリズムを使用して、この正規表現で定義されたパターンの最初の出現を見つけ、そのようにマッチ全体を印刷することができます。

私の正規表現文字列はコンパイル時に知られているので、コンパイラが構文エラーをチェックし、Xcodeが構文ハイライトを表示できるように、正規表現リテラルの使用に切り替えることができます。

しかし、究極の読みやすさとカスタマイズのために、私はRegexビルダーDSLを使用することができます。

Regexビルダーを使用すると、Regexのコンテンツを読むことは、ネイティブのSwift APIを読むのと同じくらい簡単です。

このセッションでは、Regexの仕組みと、ワークフローにRegexを適用する方法を紹介します。

Regexは、基礎となるRegexエンジンによって実行されるプログラムです。

Regexを実行するとき、Regexエンジンは入力文字列を受け取り、文字列の先頭から末尾までマッチングを実行します。

とてもシンプルな正規表現を見てみましょう。 

この正規表現は、1つ以上の文字「a」で始まり、1つ以上の数字が続く文字列と一致します。

入力「aaa12」を照合するために、マッチングアルゴリズムの1つである「wholeMatch」を使用します。

正規表現エンジンは、入力の最初の文字から起動します。

まず、1つ以上の文字aと一致します。

この時点で、文字「1」に到達し、この文字と文字「a」を一致させようとします。

しかし、それは一致しません。

したがって、正規表現エンジンは、1つ以上の数字を一致させるために、正規表現の次のパターンに移動します。

文字列の末尾に達すると、マッチングが成功します。

このセッションの残りの部分では、この実行モデルについてもう少し説明します。

Regexを基盤とするRegexエンジン上に構築されているため、RegexビルダーDSLとRegexを搭載したアルゴリズムは、Regexのパワーと表現力を拡張します。

正規表現を搭載したアルゴリズムは、文字列内の正規表現の最初の出現を見つける最初の一致、正規表現に対して文字列全体を一致する「wholeMatch」、正規表現に対する文字列の接頭辞に一致する「prefixMatch」など、最も一般的な操作のいくつかを提供するコレクションベースのAPIです。

マッチングに加えて、Swift標準ライブラリは、Regexベースの述語、置換、トリミング、および分割のためのAPIも追加しました。

また、Regexは、制御フローステートメントのSwiftのパターンマッチング構文で使用できるようになりました。

最後に、RegexビルダーとRegexを搭載したアルゴリズムに加えて、今年、FoundationはRegexビルダーとシームレスに連携する独自のRegexサポートを導入しました。

FoundationのRegexサポートは、日付や番号など、おそらくすでに使用しているフォーマッタとパーサーに他なりません。

これらのAPIについて詳しく知りたい場合は、WWDC21の「What's new in Foundation」セッションをご覧ください。

今年、FoundationはURLの書式設定と解析のサポートも追加します。

FoundationのRegexサポートにより、FoundationパーサーをRegexビルダーに直接埋め込むことができます。

たとえば、このような銀行取引明細書を解析するには、カスタムフォーマットを持つ財団が提供する日付パーサーと、ドメイン固有の解析戦略を持つ通貨パーサーを使用できます。

コーナーケースを処理し、ローカリゼーションをサポートする既存のバトルテスト済みのパーサーからRegexesを作成し、RegexビルダーDSLの表現力で作成できるため、これは本当に大きな問題です。

Swift Regexをワークフローに適用する方法を示すために、一緒に例を考えてみましょう。

XCTestベースの単体テストの実行からログを解析するスクリプトを書いています。

テストログは、テストスイートのステータスで始まり、テストスイートのステータスで終わります。

その後、XCTestはすべてのテストケースを実行し、テストケースのステータスを報告します。

今日は、ログの最初と最後の行を解析しましょう。

テストスイートに関する情報です。

まず、RegexBuilderをインポートします。

RegexBuilderは、RegexBuilder DSLを提供するSwift標準ライブラリの新しいモジュールです。

正規表現は、正規表現の本体を表すトレーリングクロージャで初期化できます。

ログメッセージの例を見てみましょう。

このログには、テストスイートの名前、ステータス、開始、合格、または失敗したかどうか、およびタイムスタンプの3つの変数部分文字列があります。

3つの変数部分文字列を解析するパターンを考えながら、この行の他の部分を逐語的に解析することができます。

ログメッセージは「テストスイート」という単語で始まり、その後にスペースと1つの引用符が続きます。

次に、テストスイートの名前を解析します。

名前は識別子で、小文字または大文字または数字を含めることができますが、最初の文字は決して数字にすることはできません。

そのため、最初の文字として文字を一致させるカスタムキャラクタークラスを作成します。

次に、ゼロから9までの文字または数字のいずれかであるゼロ以上の文字を一致させます。

これは非常に明確で読みやすいですが、少し面倒です。

多くの人がテキストの正規表現構文に精通しているかもしれません。

RegexBuilderでは、実際に簡潔なregexリテラルを本文に直接埋め込むことができます。

正規表現リテラルはスラッシュで始まり、スラッシュで終わります。

スウィフトは正しい強いタイプを推測する。

たとえば、この正規表現は「Hello, WWDC!」という部分文字列と一致します。

したがって、その出力タイプは部分文字列です。

しかし、ファーストクラスのレジェックスリテラルについて本当にクールなのは、強く型付けされたキャプチャグループです。

たとえば、年として2桁をキャプチャするキャプチャグループを書くことができます。

そして、この捕獲グループに「年」という名前を付けてください。

これを行うと、出力タイプに別の部分文字列が表示されます。

この講演の後半では、キャプチャを使用して文字列から情報を抽出する方法を紹介します。

標準的な正規表現リテラルに加えて、Swiftはポンドスラッシュから始まり、スラッシュポンドで終わる拡張正規表現リテラルもサポートしています。

拡張リテラルは、非セマンティックな空白を可能にします。

このモードでは、パターンを複数の行に分割できます。

私のRegexBuilderにRegexリテラルが埋め込まれており、クリーンでありながら馴染みがあります。

テスト名を解析した後、単一の引用符と空白を解析します。

今、私はテストステータスに達しました。

テストステータスには、開始、失敗、合格の複数のタイプがあります。

これらのオプションの1つを一致させるために、「ChoiceOf」を使用します。

「ChoiceOf」は複数のサブパターンの1つに一致し、それはまさに私たちが必要とするものです。

次に、ステータスの直後に来るもの、スペースの後に「at」の後にスペースが続くものを解析します。

文字列の残りの部分はタイムスタンプです。

私たちはこれを任意のキャラクターの1つ以上として一致させることができます。

しかし、さらにいくつかの例を見ると、ログメッセージはピリオドで終わることがあります。

私たちはまだ、それが存在する期間を一致させるために「オプション」を使用したいと考えています。

入力を正規表現と照合するには、提供された照合アルゴリズムの1つを使用します。

文字列全体を正規表現と照合する「wholeMatch」を使いましょう。

「wholeMatch」では、これらの各ログメッセージを照合し、一致したコンテンツを印刷します。

一致しました！

しかし、それが文字列と一致するかどうかを知りたいだけではありません。

また、テスト名、ステータス、タイムスタンプなど、関心のある情報を抽出したいと考えています。

だから、Regexの最もクールな機能の1つであるCapturesでこれをやりましょう!

キャプチャは、マッチング中に入力の一部を保存します。

RegexBuilderでは「キャプチャ」として、正規表現構文では括弧のペアとして利用できます。

キャプチャは、一致した部分文字列を出力タプルタイプに追加します。

出力タプルタイプは、正規表現全体に一致する部分文字列全体から始まり、最初のキャプチャ、2番目のキャプチャなどが続きます。

マッチングアルゴリズムは正規表現マッチを返し、そこから出力タプルを取得できます。

試合全体、最初のキャプチャー、および2番目のキャプチャー。

テストスイートのログRegexでキャプチャを使用させてください。

テストスイートの名前、ステータス、タイムスタンプをキャプチャします。

もう一度、いくつかの入力でこの正規表現を実行し、キャプチャした3つのものを印刷しましょう。

それは成功した試合のように見えます!

名前、ステータス、タイムスタンプが印刷されました。

しかし、よく見ると、日付の何かが少しずれています。

キャプチャの一部として入力に期間が含まれていました。

では、戻ってRegexにエラーがないか確認させてください。

タイムスタンプRegexに集中して、何が悪いのか見てみたい。

そして、パターン「任意の文字の1つ以上」は、タイムスタンプの最初の桁から行の終わりまですべてを消費することに気づきました。

したがって、その下の「オプションで期間」パターンは決して一致しませんでした。

私はこのOneOrMoreを消極的にすることで、これを修正することができます。

「消極的」は反復行動のケースです。

1つ以上、0以上、オプションで繰り返しは、Swift Regexが繰り返しと呼ぶものです。

繰り返しはデフォルトで熱心です。

できるだけ多くの出来事と一致します。

先ほどの例を使用させてください。

正規表現エンジンが任意の文字のOneOrMoreを熱心に一致させようとすると、最初の文字から始まり、入力の終わりまで途中で任意の文字を受け入れます。

その後、正規表現エンジンはオプションの期間と一致するように移動します。

一致する期間はもうありませんが、とにかくオプションなので、成功します。

「wholeMatch」アルゴリズムを実行しており、入力と正規表現パターンの両方が終了に達するため、マッチングは成功します。

マッチングは成功しましたが、その期間はすでにOneOrMoreの一部として予期せずキャプチャされていました。

繰り返し動作を消極的に変更すると、Regexエンジンは繰り返しと少し異なります。

できるだけ少ない文字にマッチします。

したがって、Regexエンジンが今回入力文字列と一致すると、繰り返しが発生する前に、常に最初にRegexの残りの部分を一致させようとすることで、慎重に前進します。

正規表現の残りの部分が一致しない場合、エンジンは繰り返しにバックトラックし、追加の出現を消費します。

最後の文字、ピリオドに早送りしましょう。

熱心な動作とは異なり、Regexエンジンは当初OneOrMoreの一部として期間を消費しませんでしたが、代わりに「オプションの期間」パターンを一致させようとします。

これは一致し、正規表現エンジンはパターンの最後に到達します。

したがって、マッチングは成功し、後続の期間なしで正しいキャプチャを生成します。

熱心はデフォルトの動作であるため、繰り返しを使用して正規表現を作成する場合は、意図した一致への影響について考える必要があります。

余分な引数を渡すことで、繰り返しごとのレベルで動作を指定するか、「repetitionBehavior」修飾子を使用して、動作を指定しなかったすべての繰り返しに対してオーバーライドすることができます。

タイムスタンプが消極的になるように繰り返し動作を変更したため、マッチングはピリオドを含めずに適切なタイムスタンプを抽出するようになりました。

正規表現に戻りましょう。

Captureを使用して入力からテストステータスを抽出すると、そのタイプはSubstringです。

しかし、サブストリングをカスタムデータ構造など、よりプログラミングに優しいものに変換できれば、はるかに良いでしょう。

これを行うには、変換キャプチャを使用できます。

変換キャプチャは、変換クロージャ付きのキャプチャです。

一致すると、正規表現エンジンは、一致した部分文字列の変換クロージャを呼び出し、目的のタイプの結果を生成します。

対応する正規表現出力タイプは、クロージャの戻り値タイプになります。

ここでは、StringからIntの初期化子でキャプチャを変換することで、出力タプルタイプのオプションのIntを取得します。

オプション以外の出力を取得するには、TryCaptureが役立ちます。

TryCaptureは、オプションを返し、出力タイプのオプション性を削除する変換を受け入れるCaptureのバリアントです。

マッチング中にnを返すと、Regexエンジンがバックトラックして別のパスを試すようになります。

TryCaptureは、失敗可能な初期化子でキャプチャを変換する場合に最も便利です。

キャプチャされたテストステータスを保存するための自然な適合は、列挙です。

では、1つを定義しましょう。

開始、合格、失敗の3つのケースでTestStatus列挙型を定義しました。

生の文字列値は、この列挙型を文字列から初期化可能にします。

正規表現では、変換で「TryCapture」に切り替えます。

変換クロージャでは、TestStatus初期化子を呼び呼び出して、一致した部分文字列をTestStatus値に変換します。

これで、対応する出力タイプはTestStatusです。

このようなカスタムデータ構造を使用すると、正規表現一致出力タイプが安全になります。

正規表現に戻る。

私がしたい追加の改善が1つあります。

現在、ワイルドカードパターンを使用してタイムスタンプを照合しています。

それは部分文字列を生成するつもりです。

これは、私のアプリがタイムスタンプを理解したい場合は、部分文字列を別のデータ構造に再度解析する必要があることを意味します。

セッションの前半で、FoundationがSwift Regexをサポートし、業界強度のパーサーをRegexesとして提供していることに言及しました。

したがって、日付を部分文字列として解析する代わりに、FoundationのISO 8601日付パーサーに切り替えて、タイムスタンプを日付として解析することができます。

今、推論された型は、この正規表現が日付を出力することを示しています。

入力で「wholeMatch」を実行すると、日付文字列がFoundation Date値に解析されたことがわかります。

財団の日付パーサーのように、正規表現として戦闘でテストされたパーサーにアクセスできることは、日々の文字列処理タスクで非常に便利です。

次に、Swift Regexの他の場所で定義された既存のパーサーを再利用する高度な機能を紹介します。

テストケースの期間を解析したい例を見てみましょう。

持続時間は、0.001などの浮動小数点数です。

これを行う最善の方法は、もちろん、ローカリゼーションを完全にサポートするFoundationが提供する浮動小数点パーサーを使用することです。

しかし、今日は、ボンネットの下にあるものと、既存のパーサーを活用して期間の浮動小数点数を解析するために、自分でRegexエンジンにフックする方法をお見せしたいと思います。

「strtod」はC標準ライブラリの関数です。

文字列ポインタを受け取り、基礎となる文字列を解析し、一致の終了位置をエンドポインタに割り当てます。

期間、Cの道を解析しましょう。

これを行うには、パーサータイプを自分で定義し、CustomConsumingRegexComponentプロトコルに準拠させることができます。

CDoubleParserという名前の構造を定義します。

ダブル数を解析しているので、その「RegexOutput」はダブルです。

「消費」メソッドでは、C標準ライブラリからダブルパーサーを呼び出し、文字列ポインタを渡し、番号を取り戻します。

メソッド本体では、withCStringメソッドを使用して開始アドレスを取得します。

次に、「strtod」C関数を呼び出し、開始アドレスとポインタを渡して結果の終了アドレスを受け取ります。

その後、エラーをチェックします。

解析が成功すると、終了アドレスは開始アドレスよりも大きくなります。

そうでなければ、それは解析の失敗なので、私はnilを返します。

C APIによって生成されたポインタから一致の上限を計算します。

そして最後に、一致の上限と数値出力を返します。

Regexに戻って、Regexで直接「CDoubleParser」を使用できます。

出力タイプはダブルと推測されます。

「wholeMatch」を呼び、解析された番号を印刷すると、予想通り0.001が出力されます。

要約すると、今日は、文字列処理の力をアプリに統合できるSwift 5.7の新機能であるSwift Regexの一般的で高度な使用について話しました。

Swift Regexを使用する際の良い習慣は、特にRegexBuilder DSLとRegexリテラルを混在させるときに、簡潔さと読みやすさのバランスを取ることです。

日付やURLなどの一般的なパターンに遭遇した場合、カスタムコードでこれらのパターンを解析するとエラーが発生しやすいため、常にFoundationが提供する業界強度のパーサーを優先してください。

Swift Regexの詳細については、Swift Evolutionに関する一連の宣言的文字列処理提案をご覧ください。

Swiftで文字列を処理するのを楽しんでいただければ幸いです。

ありがとう、そして素晴らしいWWDCをお過ごしください。