10104

♪インストゥルメンタルヒップホップ音楽♪

♪

こんにちは、私の名前はJaideep Joshiで、AppleのGPUソフトウェアエンジニアです。

このセッションでは、ゲームやアプリのリソース読み込みを簡素化および最適化するMetal 3の新機能を紹介します。

まず、高速リソースロード機能がアプリのアセットローディングパイプラインにどのように適合するかをお見せします。

Apple製品の新しいストレージ技術を活用するいくつかの重要な機能があります。

高速リソースの読み込みには、アプリケーションが遭遇する可能性のある興味深いシナリオを解決するいくつかの高度な機能があります。

アプリでこれらの機能を効果的に使用するのに役立つ、知っておくべきベストプラクティスの推奨事項がいくつかあります。

アプリに高速なリソースロードを追加すると、Metal System TraceやGPUデバッガなどのツールは、遭遇する可能性のある問題のプロファイリングと修正に役立ちます。

最後に、高速なリソースの読み込みを示す例を見ていきます。

メタル3の高速リソースローディングでできることは次のとおりです。

Metal 3の高速リソースロードにより、ゲームやアプリは、AppleシリコンユニファイドメモリアーキテクチャとAppleプラットフォームに含まれている高速SSDストレージを活用することで、低レイテンシと高スループットでアセットをロードできます。

ゲームの資産が時間通りに準備ができていることを確認するために、データをストリーミングし、ロード時間を短縮する最良の方法を学びます。

ロード時間を短縮する重要な側面は、可能な限り最小の粒度で必要なものだけをロードすることです。

Metal 3の高スループットと低レイテンシにより、アプリはテクスチャ、オーディオ、ジオメトリデータなど、より高品質のアセットをストリーミングできます。

次に、ゲームでのアセットロードの例を説明します。

ゲームは通常、最初の起動時、または新しいレベルの開始時にロード画面が表示されるので、ゲームのアセットをメモリにロードできます。

プレイヤーがレベルを移動するにつれて、ゲームはシーンのより多くのアセットをロードします。

欠点は、ゲームがアセットを事前にロードするためにストレージシステムに複数の要求をしている間、プレイヤーが長時間待たなければならないことです。

さらに、これらの資産は大きなメモリフットプリントを持つことができます。

この経験を改善する方法はいくつかあります。

ゲームは、プレイヤーがオブジェクトに近づくにつれてオブジェクトを動的にストリーミングすることで、この体験を向上させることができます。

このようにして、ゲームは最初に必要なものだけをロードし、プレイヤーがレベルを移動するにつれて徐々に他のリソースをストリーミングします。

たとえば、ゲームは最初にこの黒板を低解像度でロードしますが、プレイヤーがそれに向かって歩くと、ゲームは高解像度バージョンをロードします。

このアプローチは、プレイヤーがロード画面で待つ時間を短縮します。

ただし、プレイヤーは、高解像度バージョンを読み込むのに時間がかかりすぎるため、近くにいてもシーン内の低解像度のアイテムが表示される場合があります。

これに対処する1つの方法は、各資産の小さな部分をストリーミングすることです。

たとえば、ゲームは、全体のミップレベルではなく、タイルをストリーミングするまばらなテクスチャでシーンの可視領域のみを読み込むことができます。

これにより、アプリがストリーミングする必要があるデータ量が大幅に削減されます。

そのアプローチでは、負荷要求は小さくなり、より多くのものがあります。

しかし、最新のストレージハードウェアは一度に複数のロード要求を実行できるので、それは大丈夫です。

これは、ゲームプレイを損なうことなく、シーンの解像度とスケールを上げることができることを意味します。

多数の少量のリクエストを発行するだけでなく、負荷リクエストに優先順位を付けて、優先度の高いリクエストが時間内に完了するようにすることもできます。

ロード時間を短縮しながらゲームの視覚的忠実度を高める方法を取り上げたので、Metal 3の高速リソースロードがこれを行うのにどのように役立つかをお見せします。

高速リソースロードは、ストレージからリソースをロードする非同期APIです。

既存のロードAPIとは異なり、ロードを発行するスレッドは、ロードが完了するのを待つ必要はありません。

負荷操作は、より高速なストレージのスループットをよりよく活用するために同時に実行されます。

バッチロード操作により、リソースロードのオーバーヘッドをさらに最小限に抑えることができます。

そして最後に、Metal 3では、低レイテンシのために負荷操作に優先順位を付けることができます。

次に、リソースをロードする手順から始めて、アセットローディングパイプラインを構築するのに役立つ主な機能を紹介します。

リソースをロードするには、ファイルを開き、必要なロードコマンドを発行し、これらのロードコマンドをレンダリング作業と同期させる3つのステップがあります。

ファイルを開くことから始めて、その方法は次のとおりです。

既存のファイルは、Metalデバイスインスタンスでファイルハンドルを作成することで開きます。

たとえば、このコードはMetalデバイスインスタンスを使用して、ファイルパスURLを使用して新しいmakeIOHandleメソッドを呼び出してファイルハンドルを作成します。

ファイルハンドルを取得したら、それを使用してロードコマンドを発行できます。

これは、ロード操作を実行し、GPU作業をエンコードするアプリケーションの典型的なシナリオです。

既存のロードAPIでは、アプリはレンダリング作業をエンコードする前に、ロード作業が完了するのを待たなければなりません。

Metal 3を使用すると、アプリがロードコマンドを非同期に実行できます。

Metal IOコマンドキューを作成することから始めます。

次に、そのキューを使用してIOコマンドバッファを作成し、それらのバッファにロードコマンドをエンコードします。

ただし、コマンドバッファはコマンドキューで非同期に実行されるため、アプリはロード操作が終了するのを待つ必要はありません。

実際、IOコマンドバッファ内のすべてのコマンドが同時に実行されるだけでなく、IOコマンドバッファ自体が同時に実行され、順不同で完了します。

この同時実行モデルは、スループットを最大化することで、より高速なストレージハードウェアをよりよく利用します。

3種類のIOコマンドをコマンドバッファにエンコードできます。テクスチャストリーミング用のMetalテクスチャにロードされるloadTexture、シーンまたはジオメトリデータをストリーミングするためのMetalバッファにロードされるloadBuffer、およびCPUアクセス可能なメモリにロードされるloadBytesです。

IOコマンドキューからIOコマンドバッファを作成します。

キューを作成するには、まずIOコマンドキュー記述子を作成して設定します。

デフォルトでは、キューは並行していますが、コマンドバッファを連続して完全に順番に実行するように設定することもできます。

次に、キュー記述子をMetalデバイスインスタンスのmakeIOCommandQueueメソッドに渡します。

コマンドキューのmakeCommandBufferメソッドを呼び出して、IOコマンドバッファを作成します。

次に、そのコマンドバッファを使用して、テクスチャとバッファをロードするロードコマンドをエンコードします。

Metalの検証レイヤーは、実行時にエンコーディングエラーをキャッチします。

loadコマンドは、以前に作成されたfileHandleインスタンスを使用するものです。

コマンドバッファへのロードコマンドの追加が完了したら、コマンドバッファのコミットメソッドを呼び出して、実行のためにキューに送信します。

IOコマンドキュー、コマンドバッファを作成し、ロードコマンドを発行し、キューに送信する方法を説明したので、ロード作業を他のGPU作業と同期させる方法を紹介したいと思います。

アプリは通常、そのレンダリングのリソースの読み込みが完了した後、レンダリング作業を開始します。

しかし、高速リソースロードを使用するアプリでは、IOコマンドキューをレンダリングコマンドキューと同期させる方法が必要です。

これらのキューをMetal共有イベントと同期させることができます。

Metal haredイベントでは、IOキューのコマンドバッファをレンダリングキューのコマンドバッファと同期させることができます。

waitEventコマンドをエンコードすることで、共有イベントを待つようにコマンドバッファに指示できます。

同様に、signalEventコマンドをエンコードすることで、そのコマンドバッファに共有イベントを通知するように指示できます。

Metalは、共有イベントに信号を送る前に、コマンドバッファ内のすべてのIOコマンドが完了していることを確認します。

コマンドバッファ間で同期するには、まずMetal共有イベントが必要です。

waitForEventメソッドを呼び出すことで、共有イベントを待つようにコマンドバッファに指示できます。

同様に、signalEventメソッドを呼び出すことで、共有イベントにシグナルを送るようにコマンドバッファに指示することができます。

対応するGPUコマンドバッファに同様のロジックを追加して、IOコマンドバッファが同じ共有イベントにシグナルを送るのを待つことができます。

要約すると、Metalアプリにリソースをロードする主な機能とAPIを次に示します。

Metalファイルハンドルを作成してファイルを開きます。

IOコマンドキューとIOコマンドバッファを作成して、ロードコマンドを発行します。

次に、ロードコマンドをコマンドバッファにエンコードして、キューで実行します。

最後に、Metal共有イベントでwaitとsignalEventコマンドを使用して、ロードとレンダリングを同期します。

さて、あなたが役に立つかもしれないいくつかの高度な機能について説明します。

これは、ゲームがマップ全体をメモリに収めることができない典型的なシナリオであり、それがマップを地域に細分化する理由です。

プレイヤーがマップを進むと、ゲームはマップの領域をプリロードし始めます。

プレイヤーの方向性に基づいて、ゲームはプリロードするのに最適な領域が北西、西、南西の地域であると判断します。

しかし、プレイヤーが西部地域に移動して南に向かい始めると、北西部地域をプリロードすることはもはや有益ではありません。

将来の負荷の待ち時間を減らすために、Metal 3では負荷操作のキャンセルを試みることができます。

実際にそれを行う方法を見てみましょう。

プレーヤーが中央領域にいるときは、3つの領域のIOコマンドバッファをエンコードしてコミットします。

次に、プレイヤーが西部地域にいて南に向かうときは、tryCancelメソッドを使用して北西部地域の負荷をキャンセルします。

キャンセルはコマンドバッファの粒度にあるため、コマンドバッファの実行中にキャンセルできます。

後で、リージョンが完全にロードされたかどうかを知りたい場合は、コマンドバッファのステータスを確認できます。

Metal 3では、IO作業に優先順位を付けることもできます。

プレイヤーがシーンの新しい部分にテレポートし、ゲームが大量のグラフィックアセットでストリーミングを開始するゲームのシナリオを考えてみましょう。

同時に、ゲームはテレポーテーション効果音を再生する必要があります。

高速リソース読み込みにより、オーディオデータを含むすべてのアプリのアセットをロードできます。

オーディオをロードするには、前述のloadBytesコマンドを使用して、アプリケーションに割り当てられたメモリにロードできます。

この例では、テクスチャとオーディオIOコマンドバッファが単一のIOコマンドキューで同時に実行されています。

この簡略化された図は、ストレージ層での要求を示しています。

ストレージシステムは、オーディオとテクスチャの両方のロード要求を並行して実行できます。

オーディオの遅延を避けるために、ストリーミングシステムがテクスチャ要求よりもオーディオ要求を優先できることが重要です。

オーディオ要求に優先順位を付けるには、別のIOコマンドキューを作成し、その優先順位を高く設定できます。

ストレージシステムは、優先度の高いIOリクエストのレイテンシが低く、他のリクエストよりも優先されることを保証します。

オーディオアセット用に別の優先度の高いキューを作成した後、オーディオロード要求の実行時間は小さくなり、並列テクスチャロード要求の実行時間は大きくなりました。

優先度の高いキューを作成する方法は次のとおりです。

コマンドキュー記述子の優先度プロパティをhighに設定するだけです。

優先順位を通常または低に設定し、通常どおり記述子から新しいIOコマンドキューを作成することもできます。

作成後にキューの優先度を変更できないことを覚えておいてください。

アプリに高速なリソース読み込みを追加すると、心に留めておくべきベストプラクティスがいくつかあります。

まず、資産を圧縮することを検討してください。

組み込み圧縮またはカスタム圧縮を使用して、アプリのディスクフットプリントを削減できます。

圧縮を使用すると、ランタイムパフォーマンスをより小さなディスクフットプリントと交換できます。

さらに、スパーステクスチャを使用するときにスパースページサイズを調整することで、ストレージのスループットを向上させることができます。

圧縮から始めて、これらのそれぞれをより詳細に説明します。

Metals 3のAPIを使用して、アセットファイルをオフラインで圧縮できます。

まず、圧縮コンテキストを作成し、チャンクサイズと圧縮方法で設定します。

次に、アセットファイルの一部をコンテキストに渡して、すべてのファイルの単一の圧縮バージョンを生成します。

圧縮コンテキストは、すべてのデータをチャンクすることで機能し、選択したコーデックで圧縮し、パックファイルに保存します。

この例では、コンテキストは64Kチャンクでデータを圧縮しますが、圧縮するデータのサイズとタイプに基づいて適切なチャンクサイズを選択できます。

Metal 3での圧縮APIの使用方法は次のとおりです。

まず、圧縮ファイルを作成するためのパス、圧縮方法、およびチャンクサイズを提供して、圧縮コンテキストを作成します。

次に、ファイルデータを取得し、コンテキストに追加します。

ここでは、ファイルデータはNSDataオブジェクトにあります。

データを追加するために複数の呼び出しを行うことで、異なるファイルからデータを追加できます。

データの追加が完了したら、フラッシュアンドデバイズ圧縮コンテキスト関数を呼び出して、圧縮ファイルを確定して保存します。

ファイルハンドルを作成することで、圧縮ファイルを開いてアクセスできます。

このファイルハンドルは、ロードコマンドを発行するときに使用されます。

圧縮ファイルの場合、Metal 3は、オフセットを解凍する必要があるチャンクのリストに変換してインライン解凍を実行し、リソースにロードします。

メタルデバイスインスタンスでファイルハンドルを作成します。

たとえば、このコードはMetalデバイスインスタンスを使用して、先ほど説明したmakeIOHandleメソッドに圧縮ファイルパスを提供することで、ファイルハンドルを作成します。

圧縮ファイルの場合、追加のパラメータは圧縮方法です。

これは、圧縮ファイルの作成時に使用したのと同じ圧縮方法です。

次に、サポートされているさまざまな圧縮方法とそれぞれの特性について説明しますので、それらの間で選択する方法をよりよく理解できます。

解凍速度が重要であり、アプリが大きなディスクフットプリントを買える場合は、LZ4を使用してください。

コーデックの速度と圧縮率のバランスが重要な場合は、ZLib、LZBitmap、またはLZFSEを使用してください。

バランスの取れたコーデックの中で、ZLibはApple以外のデバイスでよりうまく機能します。

LZBitmapはエンコードとデコードが速く、LZFSEは圧縮率が高い。

最適な圧縮率が必要な場合は、アプリがアセットをデコードするのにかかる余分な時間余裕がある場合は、LZMAコーデックの使用を検討してください。

独自の圧縮スキームを使用することも可能です。

データがカスタム圧縮コーデックの恩恵を受ける場合があります。

その場合、圧縮コンテキストを独自のコンプレッサーに置き換え、オフセットを変換し、実行時に解凍を実行できます。

圧縮を使用してディスクフットプリントを削減する方法を見たので、スパースページサイズのチューニングを見てみましょう。

以前のバージョンのMetalは、16Kの粒度で希薄なテクスチャにタイルをロードすることをサポートしています。

メタル3では、64と256Kの2つの新しいスパースタイルサイズを指定できます。

これらの新しいサイズにより、より大きな粒度でテクスチャをストリーミングして、ストレージハードウェアをより有効に活用し、飽和させることができます。

より大きなタイルサイズのストリーミングとストリーミングするデータ量の間にはトレードオフがあるため、どのサイズがアプリとそのまばらなテクスチャに最も適しているかを試してみる必要があることに注意してください。

次に、Metal Developer Toolsのセットを使用して、アプリの高速リソース読み込みをプロファイリングおよびデバッグする方法を見てみましょう。

Xcode 14には、高速リソース読み込みのフルサポートが含まれています。

Metal System Traceによるランタイムプロファイリングから、MetalデバッガによるAPIインスペクションと高度な依存関係分析まで。

ランタイムプロファイリングから始めましょう。

Xcode 14では、InstrumentsはMetal System Traceテンプレートを使用して高速リソースロードをプロファイリングできます。

Instrumentsは、Metalアプリで最高のパフォーマンスを達成するのに役立つ強力な分析およびプロファイリングツールです。

Metal System Traceテンプレートを使用すると、ロード操作がいつエンコードされ、実行されるかを確認できます。

アプリがCPUとGPUの両方で実行しているアクティビティとどのように相関しているかを理解することができます。

InstrumentsでMetalアプリをプロファイリングする方法については、以前のセッション「GPUカウンターでMetalアプリとゲームを最適化する」と「Apple GPU用のハイエンドゲームを最適化する」をご覧ください。

では、ギアをデバッグに切り替えましょう。

Xcode 14のMetalデバッガを使用すると、新しい高速リソースロードAPIのゲームの使用を分析できるようになりました。

フレームキャプチャを取得すると、すべての高速リソースロードAPI呼び出しを検査できるようになります。

作成されたIOコマンドバッファから、発行されたロード操作まで。

新しい依存関係ビューアを使用して、高速リソース読み込みの依存関係を目視で検査できるようになりました。

依存関係ビューアは、IOコマンドバッファとMetalパス間のリソース依存関係の詳細な概要を提供します。

ここから、新しい同期エッジやグラフフィルタリングなど、新しい依存関係ビューアのすべての機能を使用して、リソースの読み込み依存関係を深く掘り下げ、最適化することができます。

Xcode 14の新しい依存関係ビューアの詳細については、今年の「Go bindless with Metal 3」セッションをご覧ください。

では、動作中の高速リソースロードを見てみましょう。

これは、新しい高速リソースロードAPIを使用して、16キロバイトのタイルサイズのスパーステクスチャを使用してテクスチャデータをストリーミングするテストシーンです。

このビデオは、M1 Proチップを搭載したMacBook Proからのものです。

ストリーミングシステムは、GPUのスパーステクスチャアクセスカウンタを照会して、サンプリングしたがロードされていないタイルと、アプリが使用していないロードされたタイルの2つのものを識別します。

アプリはこの情報を使用して、必要なタイルのロードのリストと、必要のないタイルの立ち退きのリストをエンコードします。

そうすれば、作業セットには、アプリが使用する可能性が高いタイルのみが含まれています。

プレイヤーがシーンの別の部分に移動することを決定した場合、アプリはまったく新しい高解像度テクスチャのセットでストリーミングする必要があります。

ストリーミングシステムが十分に高速であれば、プレイヤーはこのストリーミングが発生していることに気付かないでしょう。

シーンを一時停止すると、画像の違いをより明確に観察できます。

左側は、pread APIを使用して1つのスレッドにスパースタイルをロードしています。

右側は、高速リソースロードAPIを使用してスパースタイルをロードしています。

プレイヤーがシーンに入ると、ほとんどのテクスチャが完全に読み込まれていません。

ロードが完了すると、テクスチャの最終的な高解像度バージョンが表示されます。

このシーンの冒頭に戻って速度を落とすと、高速リソースの読み込みが提供する改善に気づきやすくなります。

違いを強調するために、このレンダリングは、アプリがまだ赤い色合いでロードされていないタイルをマークします。

最初は、シーンはアプリがほとんどのタイルをロードしていないことを示しています。

ただし、プレイヤーがシーンに入ると、高速リソースロードは、高解像度タイルのロードを改善し、シングルスレッドのプリアドバージョンと比較して遅延を最小限に抑えます。

Metal 3の高速リソースロードは、アプリが最新のストレージ技術を活用できる強力で効率的なアセットストリーミングシステムを構築するのに役立ちます。

高品質の画像を含め、アセットをちょうど間に合うようにストリーミングすることで、ロード時間を短縮するために使用します。

GPUがシーンをレンダリングしている間、Metalの共有イベントを使用してアセットを非同期にロードします。

アプリが急いで必要とするアセットについては、優先度の高いコマンドキューを作成することで、待ち時間を最小限に抑えます。

そして、ロードコマンドを早期に送信することで、ストレージシステムをビジー状態に保つことを忘れないでください。

必要のないものはいつでもキャンセルできます。

Metal 3の高速リソースロードは、高スループットの資産ロードのために最新のストレージハードウェアのパワーを活用する新しい方法を導入します。

これらの機能を使用して、アプリの視覚的な品質と応答性を向上させる方法を見るのが待ちきれません。

見てくれてありがとう。

♪