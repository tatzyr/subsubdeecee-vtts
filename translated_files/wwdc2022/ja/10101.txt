10101

♪インストゥルメンタルヒップホップ音楽♪

こんにちは、ようこそ。

私の名前はAppleのGPUソフトウェアチームのAlè Segovia Azapianです。

そして、私もGPUソフトウェアチームのMayurです。

Alè：このセッションでは、バインドレスレンダリングについて話します。

バインドレスバインディングモデルは、シェーダーにリソースを提供する最新の方法であり、レイトレーシングなどの高度なレンダリング技術のロックを解除します。

今日は、バインドレスバインディングモデルがどのように機能するか、そしてMetal 3でゲームやアプリにバインドレスを簡単に採用する方法の簡単な要約から始めます。

バインドレスレンダリングはデータを集約し、CPUとGPUのパフォーマンスを向上させる新たな機会を開きます。

今日は、CPUとGPUの時間を改善するための2つの具体的なヒントを紹介します。

その後、私はそれをMayurに渡し、彼はツールがバインドレスモデルを採用するのにどのように役立つかをあなたに示します。

バインドレスモデルでは、リソースは集約され、引数バッファと一緒にリンクされます。

概念的には、これがこのように見えます。

この例では、配列はシーン内のすべてのメッシュを集約します。

各リソースをパイプライン内の特定のスロットに独立してバインドする従来のバインディングモデルとは異なり、バインドレスモデルでは、リソースは最初にメモリ内でリンクされます。

これにより、シェーダーが自由にナビゲートし、精巧な表面と照明を計算するために必要なリソースにアクセスできる単一のバッファをバインドできます。

アプリがバインドレスになった後、レイトレーシングシェーダーは反射を美しくシェーディングするために必要なすべてのデータにアクセスできます。

このアプリは、すべてのデータを引数バッファに配置することで、床、トラック、その材料、さらには空を含む3Dモデルとテクスチャをレイトレーシングシェーダーが利用できるようにします。

さらに良いことに、バインドレスレンダリングがヒープなどの他のメタル機能とペアになっている場合、CPUへの圧力が少ないため、アプリやゲームはより良いパフォーマンスを享受します。

メタル3の4つの特定の機能強化について、バインドレスレンダリングに役立つかもしれません。

引数バッファは、リソースをリンクできる基本的なメタル構造です。

テクスチャやその他のバッファなどのリソースを参照します。

Metal 3は、引数エンコーダオブジェクトが不要になったため、引数バッファの書き込みをこれまで以上に簡単にします。

そして、同じことが無制限の配列にも当てはまります。

メタルヒープから加速構造を割り当てることができ、リソースがGPUメモリに常駐していないときにシェーダーバリデーションレイヤーが警告します。

これら4つの機能を組み合わせることで、これまで以上に簡単にバインドレスになります。

特に、Metal 3で引数バッファを書くことは喜びです。

シーンを引数バッファにエンコードするには、インスタンス、メッシュ、マテリアル、テクスチャなどのシーンデータをこれらのバッファに書き込みます。

Metal 2では、これは引数エンコーダで達成されます。

まず、これらのオブジェクトがどのように機能するかを要約してから、Metal 3がコードを簡素化する方法を紹介します。

引数エンコーダでは、最初のステップはエンコーダインスタンスを作成することです。

シェーダー関数の反射を介して、または構造体メンバーをMetalに記述することによってこれを行います。

エンコーダインスタンスで、その記録先とオフセットをターゲット引数バッファに設定します。

そして、そのメソッドを使用してバッファにデータを書き込みます。

引数バッファと引数エンコーダに関する詳細な復習については、昨年のバインドレスセッションをチェックしてください。

今、このメカニズムは素晴らしいですが、エンコーダオブジェクトは時々管理が難しい場合があります。

メタルは、引数エンコーダを作成するための2つのメカニズムを提供します。

どちらがあなたのアプリに適しているかは明らかではないかもしれません。

さらに、複数のスレッドから引数エンコーダを使用するには注意が必要です。

開発者は、C構造体を書く方法を直感的に理解し、Metal 3を使用すると、引数バッファに対してそれを行うことができます。

Metal 3は、他のCPU側構造のように直接書き込むことで、引数バッファの書き込みを簡素化します。

これで、リソースの仮想GPUアドレスとリソースIDにアクセスできます。

これらを引数バッファに直接書き込むと、Metalは参照しているリソースを理解できるようになりました。

エンコーダが不要になったことを除いて、以前は引数エンコーダを使用して参照をエンコードするのと機能的に同じです。

この機能は、引数バッファティア2をサポートするすべてのデバイスでサポートされています。

つまり、2016年以降のMacと、A13バイオニックチップ以降を搭載したiOSデバイスです。

デバイスが引数バッファティア2をサポートしているかどうかわからない場合は、使用できるMTLDeviceオブジェクトに便利な機能クエリがあります。

これが今、Metal 3のプロセスがどのように見えるかです。

まず、バッファアドレスには64ビット型、テクスチャにはMTLResourceIDを使用して、CPU可視構造体を定義します。

次に、引数バッファを割り当てます。

MTLDeviceから直接、またはMTLHeapからバッファを割り当てます。

バッファの内容を取得し、それを引数バッファ構造体型にキャストします。

そして最後に、アドレスとリソースIDを構造体メンバーに書き込みます。

ハイブリッドレンダリングのデモでこれがどのように行われるかを見てみましょう。

これがコードです。それがどれほど簡単かに注目してください。

ホスト側の構造体は、法線バッファのGPUアドレスを直接保存します。

これは64ビットの符号なし整数なので、uint64_tを使いました。

エンコーダオブジェクトがないので、引数バッファに構造体のサイズを使用するだけです。

Metalは、GPUとCPU構造体のサイズとアライメントがclangとMetalシェーダーコンパイラ間で一致することを保証します。

次に、通常どおりバッファを割り当てます。

また、バッファのストレージモードが管理または共有されている場合は、バッファへの直接ポインタを取得し、それを構造体タイプにキャストします。

そして最後に、ノーマルメンバーをgpuAddressに設定し、オプションで、GPUのメモリ要件に合わせる必要があるオフセットを設定します。

私が強調したいことの1つは、金属シェーディング言語とC宣言の間で構造宣言がどのように変化するかです。

この例では、これらは別々に保持されますが、必要に応じて、共有ヘッダーに単一の構造体宣言を持ち、条件付きコンパイルを使用してシェーダーコンパイラ型とC型を区別できます。

これはCの統一宣言です。

__METAL_VERSION__マクロは、シェーダーコードをコンパイルするときにのみ定義されます。

ヘッダー宣言でGPUとCPUコードを分離するために使用します。

アプリがC++をターゲットにしている場合は、これをさらに進め、テンプレートを使用して宣言をさらに均一にすることができます。

ベストプラクティスについては、引数バッファのサンプルコードを確認してください。

これで1つの構造体を書く方法ですが、無制限の配列を使用して多くの構造体を書くこともできます。

引数エンコーダを使用してMetalに無制限の配列を実装することはできますが、Metal 3は、構造体の配列を埋めることに近づくことで、プロセスをさらに簡素化します。

1つの構造体を書くこととの違いは次のとおりです。

これで、保存するすべての構造体に十分なストレージを割り当てる必要があります。

そして、配列を反復し、各構造体のデータを書き込む。

コードサンプルに戻り、まず、バッファのサイズを展開して、シーン内のメッシュと同じくらい多くの構造体を保存します。

これがCPUバッファとまったく同じであることに注目してください。構造体のサイズにメッシュ数を掛けます。

これがどれほど強力であるかに注目したいと思います。

この単一の変数は、配列のサイズを完全に制御します。

シェーダーは、任意の時点でこのサイズをメタルシェーダーコンパイラに宣言する必要がなく、任意の位置に自由にインデックスを付けることができます。

これは、制約なしで任意のサイズの配列にアクセスするシェーダーを書くため、バインドレスモデルがMetalで非常に柔軟である理由の一部です。

それはちょうど動作します!

次に、このサイズのバッファを割り当て、正しいメッシュ構造体タイプにコンテンツへのポインタをキャストします。

バッファが十分に大きくなったので、メッシュ構造体のサイズにまたがって、シンプルなforループで歩きます。

そして最後に、配列内の各構造体のGPUAddressを直接設定し、オプションで整列されたオフセットを設定します。

シェーダーのGPU側から、これは無制限の配列を表す1つの方法です。

ここでは、シェーダーに渡すメッシュポインタパラメータとして宣言します。

これにより、C配列と同様に、コンテンツに直接自由にアクセスできるようになります。

もう1つのオプションは、すべての無制限の配列を構造体に引き込むことです。

これは、データを1か所に集約することで、シェーダーをきれいに保つのに役立ちます。

この例では、すべてのメッシュとマテリアルがシーン構造体でまとめられています。

シーン構造体を使用すると、シーンは、すべての無制限の配列を別々に渡すのではなく、単一のバッファをバインドすることによってシェーダーに直接渡されます。

そして、アクセスは以前と似ていますが、今、メッシュ配列はシーン構造体を介して到達されます。

そして、それがMetal 3で引数バッファと無制限配列を書く方法です。

完全に刷新されたAPIにより、より直感的になり、CPU構造体や構造体の配列に対して行うことと一致します。

今年のレイトレーシングアップデートでは、バッファーやテクスチャとともに、メタルヒープからレイトレーシングアクセラレーション構造を割り当てることができます。

これは、それらが自分自身の間で、そして他のリソースタイプと一緒に集約できることを意味します。

これは素晴らしいことです。なぜなら、すべての加速構造をヒープに集約すると、Heapを使用するための単一の呼び出しですべての常駐フラグを付けることができるからです。

これは、アプリケーションのレンダリングスレッドでCPUを大幅に節約するための大きな機会です。

ここでは、ヒープで加速構造を操作するためのヒントをいくつか紹介します。

まず、ヒープから割り当てられると、加速度構造には、デバイスごとに異なるアライメントとサイズの要件があります。

ヒープ割り当てのアクセラレーション構造のサイズとアライメントをチェックする新しいクエリがあります。

MTLDeviceのheapAccelerationStructureSizeとAlignWithDescriptorメソッドを使用して、構造記述子のSizeAndAlignmentを決定します。

これは、MTLDeviceの accelerationStructureSizes WithDescriptorメソッドとは異なることを覚えておいてください。

加速度構造がMTLHeapオブジェクトにあるので、useHeapを呼び出し、それらをすべて1回の呼び出しに常駐させます。

これは、個々のリソースでuseResourceを呼び出すよりも高速です。

そして、ハザードトラッキングにヒープを選択しない限り、Metalはそれらから割り当てられたリソースの競合条件を妨げないため、互いに構築される加速構造を同期し、レイトレーシング作業と同期する必要があることを覚えておいてください。

しかし、心配しないでください、私はすぐにこれについてもっと話します。

メタル3のこれと他のレイトレーシングパフォーマンスの進歩の詳細については、今年の「メタルレイトレーシングパフォーマンスを最大化する」トークをチェックしてください。

ヒープに割り当てられたアクセラレーション構造を使用すると、最も重要なときにアプリのCPU使用率を減らす機会が得られます。

最後になりましたが、今年の私のお気に入りの機能の1つは、シェーダー検証の強化です。

useResourceとuseHeapのトピックでは、アプリが間接的にアクセスされたすべてのリソースに対してMetalにレジデンシーにフラグを付けることが非常に重要です。

それを忘れることは、これらのリソースをバックアップするメモリページがレンダリング時に存在しない可能性があることを意味します。

これは、コマンドバッファの失敗、GPUの再起動、さらには画像の破損を引き起こす可能性があります。

残念ながら、バインドレスジャーニーを開始するときにこれらの問題に遭遇することは非常に一般的です。なぜなら、バインドレスでは、シーンリソースの大部分が間接的にアクセスされ、シェーダーが実行時にポインタナビゲーションの決定を行うからです。

今年、Metal 3は、コマンドバッファの実行中にリソースの欠落しているレジデンシーを追跡するのに役立つシェーダー検証レイヤーに新機能を導入しました。

具体的な例をお見せします。

ハイブリッドレンダリングアプリの更新プロセス中に、反射が時々正しくないように見える本当の問題に遭遇しました。

検証層がこの問題の診断と修正にどのように役立ったかをお見せします。

レジデンシーをMetalにフラグを付けるために、アプリはヒープによってバックアップされていないすべての個々のリソースをロード時に適用可能なセットに保存します。

アプリはバッファを追加し、テクスチャを追加します。

レンダリング時に、アプリがレイトレーシングカーネルをディスパッチする前に、セット内のすべてのリソースを使用することをMetalに示します。

これは、アプリがセットを反復し、各要素でuseResourceを呼び出す簡単なプロセスです。

金属は、レイトレーシング作業を開始する前に、これらすべてのリソースを常駐させます。

これは、アプリがこのセットにリソースを収集するコードの一部です。

アプリは、引数バッファ書き込みプロセスの一部としてこれを行います。

アプリの読み込み機能は、各サブメッシュを反復します。

引数バッファに書き込む必要があるデータ、つまりマテリアルのインデックスデータとテクスチャデータを取り込み、インデックスバッファのアドレスを引数バッファに格納します。

マテリアルの場合、テクスチャ配列をループし、テクスチャGPUリソースIDを引数バッファに書き込みます。

そして最後に、サブメッシュ素材からすべての個々のテクスチャをsceneResourcesセットに追加するので、ディスパッチ時に居住者にフラグを立てることができます。

残念ながら、ここには微妙なバグがあります。

アプリはコマンドバッファを実行し、場合によっては反射が欠落します。

以前は、これを追跡することは困難でした。

メタル3では、シェーダー検証レイヤーが救助に来ます。

この種の問題は、コマンドバッファの実行中にエラーが発生し、問題が何であるかを示すようになりました。

エラーメッセージは、問題を引き起こしたシェーダー関数の名前、パスの名前、アクセスを検出した金属ファイルとコード行、さらにはバッファのラベル、そのサイズ、およびそれが常駐していないという事実を示します。

プロのヒントとして、これは金属オブジェクトにラベルを付けることが常に良い習慣である理由です。

このツールはラベルを使用します。これは、アプリのデバッグ中にどのオブジェクトがどのオブジェクトであるかを特定しようとするときに役立ちます。

このすべての詳細情報が手元にあるので、シェーダーコードで不足しているリソースを簡単に見つけることができます。

さらに良いのは、デバッグブレークポイントが有効になっている場合、Xcodeはシェーダー検証が問題を検出するシェーダーコードの正確な行を便利に表示することです。

デモアプリの場合、常駐していないのはインデックスバッファです。

修正は今や簡単です。

コードに戻ると、アプリは不足しているインデックスバッファを常駐リソースセットに保存するようになりました。

これらの変更により、後でレイトレーシング時に、MetalはインデックスバッファをGPUが利用できるようにし、問題を解決することを知っています。

これは不可欠なツールであり、完全なゲームチェンジャーであり、バインドレスの旅で何時間ものデバッグ時間を節約できる可能性があります。

したがって、これらは、メタル3がもたらす機能強化であり、バインドレスリソースを整理して参照するのに役立ちます。

今、私はギアを切り替えて、バインドレスになったときにゲームのパフォーマンスを最大化する方法について話します。

このセクションでは、保持されていないリソースと追跡されていないリソースの2つのトピックを取り上げます。

これらのヒントは、長寿命で集約されたリソースがある場合に、CPUとGPUの両方からより多くのパフォーマンスを引き出すのに役立ちます。

さて、長寿命のリソースでCPUのパフォーマンスを向上させる方法については、まずメタルリソースのライフサイクルを要約します。

Objective-CとSwiftは、参照カウントを介してオブジェクトのライフサイクルを処理します。

金属資源はこのモデルに従います。

リソースは1のretainCountで始まり、すべての強力な参照が消えたときにランタイムはそれらを割り当て解除します。

CPUとGPUは並行して動作するため、GPUがまだ使用している間にRetainCountが0に達するようにすることで、CPUがリソースの割り当てを解除した場合、問題になります。

これを防ぐために、Metalコマンドバッファは、使用するすべてのリソースへの強力な参照を作成し、retainCountが常に少なくとも1であることを確認します。

Metalは、setVertexBufferやsetFragmentTextureなどの関数を使用してパイプラインに直接バインドするリソースの強力な参照を作成します。これには、レンダリングアタッチメントも含まれます。useHeap APIを介して常駐フラグを付けるMetalヒープオブジェクト、およびheapの一部である場合でも、useResource APIを介して常駐する間接リソース。

Metalオブジェクトのライフサイクルの詳細については、今年の「Program Metal in C++ with metal-cpp」の講演をご覧ください。

今、Metalがこれらの参照を作成することは非常に便利です。なぜなら、プログラマーとして、GPUがまだ使用している間にオブジェクトの割り当てを解除する可能性があることを心配する必要がないからです。

メタルが提供するこの安全保証は、実行が非常に高速ですが、小さなCPUコストが付属しています。

現在、バインドレスモデルでは、アプリはリソースをヒープに集約し、これらはアプリケーションのドメインと一致して長生きする傾向があります。

たとえば、ゲームでは、リソースはレベル全体の期間にわたって生きています。

この場合、Metalがリソースのライフサイクルに関する追加の保証を提供する必要がなくなります。

次にできることは、Metalコマンドバッファを参照するリソースを保持しないように依頼することで、このCPUコストを回収することです。

Metalの自動リソース保持をオフにするには、保持されていない参照を含むコマンドバッファを作成するだけです。

通常のコマンドバッファを作成するのと同じように、MTLCommandQueueから直接これを行います。

リソースのライフサイクルをすでに保証している限り、アプリに他の変更を加える必要はありません。

この設定の粒度レベルは、コマンドバッファ全体であることを覚えておいてください。

参照されたすべてのリソースを保持するか、どれも保持しません。

小さなマイクロベンチマークでは、保持されていない参照を持つコマンドバッファに切り替えるだけで、コマンドバッファのライフサイクルにおける2%のCPU使用率の減少を測定しました。

しかし、この時間は不必要な強力な参照の作成と破壊に完全に費やされました。

要約すると、保持されていないリソースは、すでにリソースのライフサイクルを保証している場合に、追加のCPU節約の機会を提供します。

保持されていないリソースと同様に、追跡されていないリソースは、より多くのパフォーマンスを得るために安全機能を無効にする機会を提供します。

多くの視覚的なテクニックは、中間テクスチャにレンダリングし、バッファに書き込み、後でそれらを消費することで構成されています。

シャドウマッピング、スキニング、後処理は、この良い例です。

現在、リソースの生産と即時消費は、読み取り/書き込みの危険性をもたらします。

さらに、2つのレンダーパスが同じアタッチメントに次々と描画したり、2つのブリットエンコーダが同じリソースに書き込んだりするなど、複数のパスが同じリソースに書き込むと、MetalスケジュールがGPUで機能するため、書き込み後の危険が生じます。

追跡されたリソースを使用すると、Metalは自動的に同期プリミティブを使用してGPUタイムラインの危険を回避します。

たとえば、MetalはGPUに、同じバッファから読み込むシーンレンダリングパスを開始する前に、コンピューティングスキニングパスがバッファへの書き込みを完了するのを待ちます。

これは素晴らしいことであり、Metalがこのような親しみやすいグラフィックスAPIである理由の大きな部分ですが、リソースをヒープに集約するアプリにはいくつかのパフォーマンス上の考慮事項があります。

この例を考えてみましょう。

ここでは、GPUはビジーで、頂点スキニングを行い、シーンをレンダリングし、トーンマッピングを適用する2つのフレームを次々に描画します。

アプリはGPUを忙しく保つため、Metalはリソースの依存関係に基づいて、レンダリングと計算作業が重複する可能性のある機会を特定します。

依存関係がなく、条件が正しい場合、金属スケジュールは重複して並行して実行されます。

これはGPUを飽和させ、同じ量のウォールクロック時間でより多くの作業を行うことができます。

これで、アプリがリソースをヒープに集約すると、すべてのサブリソースがMetalに1つ表示されます。

これは、ヒープを非常に効率的に作業する理由です。

しかし、これは、Metalが同じリソースで読み取りと書き込みの作業を見て、実際の危険が存在しない場合でも、レース条件を避けるために作業を保守的にスケジュールしなければならないことを意味します。

この状況は「偽の共有」と呼ばれ、予想通り、GPU作業の実行ウォールクロック時間が長くなります。

だから、これがパフォーマンスのヒントです。

ヒープ内のリソース間に依存関係がないことを知っている場合は、この動作を避けることができます。

誤った共有を避けるために、ハザードトラッキングからリソースをオプトアウトし、金属へのきめ細かい依存関係を直接通知することができます。

リソース記述子の hazardTracking プロパティを Untracked に設定することで、リソース追跡をオプトアウトします。

これは非常に重要であるため、GPUがゲートのすぐ外で並行して作業を実行するためのより多くの機会のロックを解除できるため、ヒープのデフォルトの動作です。

追跡されていないリソースの使用を開始すると、次のプリミティブを使用して依存関係を表現します。

状況に応じて、フェンス、イベント、共有イベント、またはメモリバリアを使用します。

メタルフェンスは、単一のコマンドキューのコンテキスト内で、異なるレンダリングとコンピューティングパスにまたがる1つ以上のリソースへのアクセスを同期します。

これはスプリットバリアのような原始的であるため、消費者パスは生産者がフェンスに信号を送るまで待ちます。

Fencesを使用する際に留意する必要がある唯一の要件は、コマンドバッファを消費する前に、プロデューサーコマンドバッファをコミットまたはキューに入れることです。

この注文を保証できない場合、または同じデバイス上の複数のキュー間で同期する必要がある場合は、MTLイベントを使用してください。

イベントを使用して、コンシューマコマンドバッファは、プロデューサーコマンドバッファが指定された値でイベントにシグナルを送るのを待ちます。

値を通知した後は、リソースを読み取るのが安全です。

イベントを使用して、コマンドがイベントに信号を送るまで作業を一時停止するようにGPUに指示します。

MTLSharedEventsは、通常のイベントと非常によく似ていますが、単一のGPUを超えたより大きなスコープで動作します。

これらを使用して、さまざまなMetalデバイス、さらにはCPUとのリソースへのアクセスを同期します。

たとえば、共有イベントを使用して、CPUからGPU計算の結果を処理します。

ここに例があります。

この場合、GPUはコンピューティングパスでメッシュをスキンし、CPUはポーズをディスクに保存します。

これら2つは独立したデバイスであるため、共有イベントを使用して、GPUがリソースを生成するまでCPUを待機させます。

最初は、CPUはGPUが共有イベントに信号を送るのを無条件に待ち始めます。

GPUがリソースを生成してユニファイドメモリに配置すると、共有イベントに信号を送ります。

この時点で、CPUの待機スレッドが起動し、リソースを安全に消費します。

最後のプリミティブタイプはメモリバリアです。

メモリバリアは、単一のレンダリングまたは計算パス内の後続のすべてのコマンドを強制して、以前のすべてのコマンドが終了するまで待機させます。

バリアのコストは、ほとんどすべてのケースでフェンスのコストに似ています。

しかし、1つの例外があります。

その例外は、レンダリングパスのフラグメントステージの後の障壁です。

これらの障壁は、レンダリングパスを分割するのと同様の非常に高いコストがかかります。

Metalは、Apple GPUのフラグメントステージの後に障壁を無効にし、アプリが最速のドライバーパスにとどまるのに役立ちます。

Metalデバッグレイヤーは、Apple GPUにフラグメント後のバリアを追加すると、検証エラーも発生します。

フラグメントステージの後にリソースを同期するためにフェンスを使用することをお勧めします。

同期プリミティブの簡単な要約と、いつ使用するかを次に示します。

プロデューサーの単一のコマンドキューに作業をコミットまたはキューに入れるときに、最も低いオーバーヘッドにフェンスを使用することを好み、次に消費者の注文。

フェンスは、一般的なケースの大半に最適です。

提出注文を保証できない場合、または複数のコマンドキューがある場合は、Metal Eventsを使用してください。

共有イベントは、自分自身とCPUとの間で複数のGPUを同期させることができます。

これらの特定のマルチデバイスのケースでのみ使用してください。

パス内で同期したい場合は、メモリバリアを使用してください。 メモリバリア

バリアは、ほとんどの場合、同時計算パスやドローコール間の頂点ステージなど、高速プリミティブです。

しかし、フレンドリーなリマインダーは、これらの障壁は非常に高価であり、Apple GPUはそれを許可していないため、フラグメントステージの後に同期するためのバリアの代わりにパスの間にフェンスを使用してください。

追跡されていないリソースと手動のきめ細かい追跡を使用して、GPUの並列性を最大化しながら、データ集約のすべての利点を持つことができます。

そして、これらはバインドレスになるときにCPUとGPUを最大限に活用するためのパフォーマンスのヒントです。

Metal 3がシンプルで効率的なバインドレスワークフローのロックを解除する方法についてたくさん話しました。

しかし、コードを書くことは方程式の半分にすぎません。

残りの半分は、利用可能なツールがGPUがどのように動作を見て実行するかを確認するのにどのように役立つかです。

私は今、それをMayurに引き渡して、バインドレス用のMetal 3ツーリングの新機能について話します。

マユール：ありがとう、アレ。

今日は、バインドレスアプリのデバッグと最適化に役立つMetal Debuggerの素晴らしい新機能のいくつかをお見せできることを嬉しく思います。

Alèがあなたに見せたHybridRenderingアプリのフレームキャプチャを撮ったところです。

メタルデバッガでフレームをキャプチャすると、概要ページが表示され、アプリのパフォーマンスを向上させる方法に関する有用な洞察とともに、フレームの概要が表示されます。

しかし、今日、私はあなたに新しい依存関係ビューアを見せることに興奮しています。

それを開くには、左側の依存関係をクリックしてください。

ここに新しい依存関係ビューアがあり、強力な新機能が満載の真新しいデザインが特徴です。

依存関係ビューアは、ワークロードのグラフベースの表現を表示します。

グラフの各ノードは、コマンドエンコーダによってエンコードされたパスとその出力リソースを表します。

エッジは、パス間のリソース依存関係を表します。

今年の新機能では、2種類の依存関係に焦点を当てることで、ワークロードを分析できます。

データフローと同期。

実線はデータフローを表し、アプリでデータがどのように流れるかを示します。

点線は同期を表し、パス間のGPU同期を導入する依存関係を示します。

詳細については、任意のエンコーダ、リソース、またはエッジをクリックすると、デバッガは新しいサイドバーに多くの詳細情報が表示されます。

たとえば、このエッジは同期を追加し、これらのパス間のデータフローもあります。

デフォルトでは、依存関係ビューアはデータフローと同期依存関係の両方を表示しますが、下部にあるこのメニューを使用して、依存関係タイプの1つだけに焦点を当てることができます。

ここでは、同期だけに焦点を当てます。

Alèが先に述べたように、追跡されたヒープから異なるリソースを読み書きするとき、誤った共有は一般的な問題です。

依存関係ビューアを使用すると、これらの問題を簡単にキャッチできます。

私がキャプチャしたこのデモは、この問題がある初期の開発バージョンからのものです。

このヒープをクリックすると、依存関係ビューアは、このヒープが追跡されていることを示し、したがって、これら2つのパス間の同期を追加します。

依存関係ビューアは、レンダリングエンコーダが保存するこのレンダリングターゲットテクスチャや、コンピューティングエンコーダが読み書きするバッファなど、ヒープ内に割り当てられたリソースも強調表示します。

問題は、コンピューティングエンコーダが以前のエンコーダのリソースを使用していないため、これら2つのパス間の同期が不要なことです。

この依存関係を削除するには、追跡されていないヒープを使用するようにアプリを変更し、同期が必要な場所にフェンスを挿入することができます。

その変更により、これら2つのパスを並行して実行できるようになりました。

バインドレスアプリのデバッグに役立つXcode 14のもう1つの大きな改善点は、新しいリソースリストです。

デバッグして開きたいドローコールに移動できます。

バインドレスを使用すると、数百または数千のリソースがいつでもGPUで利用できます。

今年、Metalデバッガは、上部の「アクセス」モードをクリックするだけで、これらのリソースのどれがドローコールにアクセスしたかを確認できます。

今、デバッガは、このドローコールがアクセスする一握りのリソースと各アクセスの種類だけを表示します。

これは、シェーダーが引数バッファからアクセスしたリソースを理解するのに非常に役立ちます。

ドローコールが使用するリソースを知ることは素晴らしいことですが、期待していなかったリソースが表示されている場合は、シェーダーデバッガを使用して何が起こっているのかを把握できます。

シェーダーデバッガを起動するには、下のバーのデバッグボタンをクリックし、デバッグするピクセルを選択し、デバッグボタンを押すだけです。

そして今、あなたはシェーダーデバッガにいます。

シェーダーデバッガは、どのリソースがアクセスされたかなど、コードがどのように行ごとに実行されたかを示します。

これらの行の場合、このシェーダーは引数バッファからテクスチャを読み取ります。

右側のサイドバーの詳細なビューを展開して、どのリソースが読み込まれたかを確認できます。

これは、シェーダーが間違った引数バッファ要素にアクセスする問題を特定するのに役立ちます。

このデモでは、新しい依存関係ビューアを使用してリソースの依存関係を分析および検証する方法、新しいリソースリストを使用してドロー呼び出しがアクセスしたリソースを理解する方法、シェーダーデバッガを使用してシェーダーがどのように実行されたかを行ごとに分析する方法を示しました。

これらの新機能を使用して、素晴らしいMetalバインドレスアプリを作成する方法を見るのが待ちきれません。

君に戻るよ、アレー。

アレー:ありがとう、マユール。それは素晴らしいデモでした。

まとめると、メタル3はバインドレスになるためのテーブルに多くをもたらします。

簡略化された引数バッファエンコーディング、ヒープからの加速構造、検証レイヤーとツールの改善により、Metal 3はゲームやアプリに効果的でパフォーマンスの高いバインドレスをもたらす優れたAPIです。

今年の機能強化により、ハイブリッドレンダリングアプリはこれまで以上に良くなっています。

メタルのサンプルコードギャラリーで、完全なソースコードを含むこの更新されたバージョンのアプリをリリースします。

あなたはそれをダウンロードし、研究し、修正することができ、演習として、私はそれをさらに進め、鏡面に再帰反射を追加することに挑戦します。

あなたがそれで何をするかを見るのが待ちきれません。

メタル3でバインドレスになるのにこれほど良い時期はありません。

ご覧いただきありがとうございます。

♪インストゥルメンタルヒップホップ音楽♪