110355

♪インストゥルメンタルヒップホップ音楽♪

こんにちは、私の名前はフィリップです。

Swiftには、オープンソースパッケージのカタログが増えています。

最新の追加案の1つであるSwift Async Algorithmsをご紹介します。

このパッケージは、Swift CollectionsやSwift Algorithmsなどの他のパッケージと並んでいます。

Swift Async Algorithmsパッケージは、AsyncSequenceを使用して時間の経過とともに値を処理することに特に焦点を当てた一連のアルゴリズムです。

しかし、それに入る前に、少し時間を取ってAsyncSequenceを要約しましょう。

AsyncSequenceは、非同期に生成された値を記述できるプロトコルです。

基本的にはシーケンスに似ていますが、2つの重要な違いがあります。

イテレータの次の関数は非同期で、Swift並行性を使用して値を配信できます。

また、Swiftのスロー効果を使用して、潜在的な失敗を処理することもできます。

そして、シーケンスと同様に、for-await-in構文を使用して反復することができます。

要するに、Sequenceの使い方を知っていれば、すでにAsyncSequenceの使い方を知っています。

さて、AsyncSequenceが導入されたとき、非同期バージョンでSequenceで見つけることが期待されるほとんどすべてのツールを追加しました。

マップ、フィルター、縮小などのアルゴリズムがあります。

Swift Async Algorithmsパッケージは、より高度なアルゴリズムを組み込むだけでなく、クロックと相互運用して本当に強力なものを提供することで、これをさらに一歩進めます。

これは、Swiftの並行性を増強するAsyncSequenceアルゴリズムのオープンソースパッケージです。

昨年、私たちはSwift Algorithmsパッケージを導入しました。

これらのアルゴリズムの使用を実証するために、私たちはメッセージングアプリを作りました。

これは、そのパッケージでできる豊かで強力なことのいくつかの素晴らしい例でした。

私たちは、Swift並行性を使用するようにアプリを移行することを利用する多くの本当に良い機会があると判断しました。

非同期アルゴリズムのいくつかを強調するために、私たちが使用したもののいくつかとそれらがどのように機能するかを説明します。

まず、複数の入力AsyncSequencesを操作するためのアルゴリズムのファミリーがあります。

これらは、AsyncSequencesをさまざまな方法で組み合わせることに焦点を当てたアルゴリズムです。

しかし、それらはすべて1つの特徴を共有しています。複数の入力AsyncSequencesを取り、1つの出力AsyncSequenceを生成します。

あなたがすでによく知っているかもしれないのはZipです。

Zipアルゴリズムは複数の入力を受け取り、それらを反復して、各ベースから結果のタプルを生成します。

Zipへの各入力は、Zipが構築されるベースです。

非同期Zipアルゴリズムは、標準ライブラリのZipアルゴリズムと同じように機能しますが、各ベースを同時に反復し、反復処理中に障害が発生した場合にエラーを再度スローします。

さて、再スローエラーでその同時反復を達成することは、むしろ関与する可能性があります。

しかし、Swift Async Algorithmsパッケージは、私たちのメッセージングアプリで私たちのためにそのすべてを処理しました。

以前は、ビデオ録画のプレビューを非同期に生成し、効率的なストレージと伝送のためにビデオを複数のサイズにトランスコードする多くのコードを調整していました。

Zipを使用することで、トランスコードされたビデオをサーバーに送信するときにプレビューを取得できます。

Zipは並行しているため、トランスコーディングもプレビューもお互いを遅らせません。

しかし、これはもう少し進みます。

Zip自体は、どちらの側が最初に値を生成するかどうかの好みがないため、ビデオを最初に作成するか、プレビューを作成することができ、どちら側であっても、もう一方が完全なタプルを送信するのを待ちます。

Zipは各側が同時に値のタプルを構築するのを待っているので、一緒にアップロードできるようにペアを待つことができます。

受信メッセージをAsyncSequenceとしてモデル化することは非常に理にかなっているという結論に達しました。

そこで、順序を維持し、コールバックをメッセージのAsyncSequenceに変えるため、AsyncStreamを使用してこれらのメッセージを処理することにしました。

私たちが取り組む必要のある要求された機能の1つは、複数のアカウントをサポートしたかったことです。

したがって、各アカウントは受信メッセージのAsyncStreamを作成しますが、これを実装するときは、それらをすべて1つの単一のAsyncSequenceとして一緒に処理する必要があります。

これは、これらのAsyncSequencesをマージするためのアルゴリズムが必要だったことを意味します。

ありがたいことに、Swift Async Algorithmsパッケージには、まさにそのためのアルゴリズムがあり、適切に「Merge」と名付けられています。

複数のAsyncSequencesを同時に反復するという点で、Zipと同様に機能します。しかし、ペアのタプルを作成する代わりに、ベースが同じ要素タイプを共有し、ベースAsyncSequencesをそれらの要素の1つの単一のAsyncSequenceにマージする必要があります。

マージは、反復時に側面のいずれかによって生成された最初の要素を取ることによって動作します。

特に、すべての基本AsyncSequencesがイテレータからnilを返す場合、生成できる値がなくなるまで反復を続けます。

ベースのいずれかがエラーが発生した場合、他の反復はキャンセルされます。

これにより、メッセージのAsyncSequencesを取り、それらをマージすることができます。

これらの組み合わせアルゴリズムは、値が生成されるときに同時に機能しますが、時には実際に時間自体と対話することが有用です。

Swift Async Algorithmsパッケージは、Swiftの新しいClock APIを活用することで、時間とともに動作するアルゴリズムのファミリーをもたらします。

時間自体は本当に複雑な主題になる可能性があり、Swift（5.7）の新機能には、時計、インスタント、持続時間など、安全で一貫性のあるAPIのセットがあります。

クロックプロトコルは、与えられた瞬間の後に目を覚ます方法と、今の概念を生成する方法の2つのプリミティブを定義します。

内蔵の時計がいくつかあります。

より一般的なものの2つは、ContinuousClockとSuspendingClockです。

ContinuousClockを使用して、測定されているものの状態に関係なく時間が進むストップウォッチのように時間を測定することができます。

一方、SuspendingClockは、その名前が示すことを行います。マシンがスリープ状態になると一時停止します。

アプリで新しいクロックAPIを使用して、既存のコールバックイベントからクロックスリープ機能に移行し、締め切り後のアラートの却下を処理しました。

遅延させたい秒数を具体的に示す期間値を追加することで、締め切りを作成することができました。

時計には、作業の実行の経過時間を測定するための便利な方法もあります。

ここには、先に述べた2つの一般的な時計、SuspendingClockとContinuousClockがあります。

以下は、測定される作業の潜在的な経過時間を示すディスプレイです。

これら2つの時計の主な違いは、機械が眠っているときの動作から来ています。

このような長時間の作業では、ここで行ったのと同じように作業を一時停止できますが、実行を再開すると、マシンが眠っている間にContinuousClockは進行しましたが、SuspendingClockは進行しませんでした。

一般的に、この違いは、実行のタイミングを一時停止することで、アニメーションのようなものが期待どおりに機能するようにするための重要な詳細になる可能性があります。

アニメーションなど、マシンに関連して時間とやり取りする必要がある場合は、SuspendingClockを使用してください。

デバイスの前の人間に関連するタスクを測定することは、ContinuousClockにより適しています。

したがって、人間に関連する絶対的な期間で遅延する必要がある場合は、ContinuousClockを使用してください。

Swift Async Algorithmsパッケージは、これらの新しいClock、Instant、およびDurationタイプを使用して、時間に関するイベントの処理方法に関する多くの概念に対処するための一般的なアルゴリズムを構築します。

私たちのメッセージングアプリでは、これらがイベントの正確な制御を提供するのに本当に役立つことがわかりました。

制限されたインタラクションをレートし、メッセージを効率的にバッファリングすることができます。

おそらく、私たちが時間を利用した最も顕著な分野は、メッセージの検索でした。

結果のチャネルを管理するコントローラーを作成しました。

チャンネルは、検索タスクから検索結果をUIにマーシャリングします。

検索タスク自体は、時間に関していくつかの特定の特性を持つ必要がありました。

サーバー上で送信されたメッセージの検索制限を確実に評価したかった。

アルゴリズムDebounceは、反復時に次の値を放出する前に、静止期間を待ちます。

それは、イベントが速く入ってくる可能性があることを意味しますが、価値を扱う前に静かな期間を待つようにしたいと考えています。

検索フィールドからのユーザー入力が急速に変更される場合、検索コントローラーが変更ごとに検索要求を発生させたくありません。

代わりに、タイピングが完了した可能性が高いと確信している静かな期間を待つようにしたいと考えています。

デフォルトでは、DebounceアルゴリズムはContinuousClockを使用します。

この場合、何も起こっていない間に指定された期間を待つように入力をデバウンスすることができます。

クロックと持続時間はデバウンスに使用されるだけでなく、他のアルゴリズムにも使用されます。

本当に有用であることがわかった領域の1つは、サーバーにメッセージのバッチを送信することでした。

Swiftアルゴリズムパッケージには、チャンク値に一連のアルゴリズムがあります。

Swift Async Algorithmsパッケージはこれらを提供しますが、クロックと持続時間と相互運用する一連のバージョンも追加します。

チャンキングアルゴリズムのファミリは、カウント、時間、またはコンテンツによってチャンクを制御できます。

これらのいずれかでエラーが発生した場合、そのエラーは再スローされるため、失敗に関してはコードは安全です。

「chunked(by:)」APIを使用して、メッセージのチャンクがシリアル化され、特定の経過期間によって送信されるようにしました。

そうすれば、私たちのサーバーはクライアントから送信された効率的なパケットを取得します。

このAPIを使用して、500ミリ秒ごとにメッセージのバッチを構築することができました。

そうすれば、誰かが本当に興奮して本当に速く入力すると、サーバーに送信されたリクエストがグループ化されます。

コレクションとシーケンスを扱うとき、要素を怠惰に処理することはしばしば有用で高性能です。

AsyncSequenceは、スウィフト標準ライブラリでの遅延アルゴリズムの仕組みとよく似ています。

しかし、これらの怠惰なアルゴリズムと同様に、コレクションの世界に戻る必要があることがよくあります。

Swift Async Algorithmsパッケージは、AsyncSequenceを使用してコレクションを構築するための初期化子のセットを提供します。

これらは、有限であることが知られている入力AsyncSequencesで辞書、セット、または配列を構築することができます。

コレクション初期化子を使用すると、メッセージの初期化への変換を組み込み、データ型を配列として保持できます。

Swiftの並行性を使用するためにいくつかの更新を本当に使用できる多くの機能があったので、これは本当に役に立ちました。

また、既存のデータ構造を維持することで、アプリの一部を段階的に移行し、理にかなっている場所に移動することができます。

これまでのところ、Swift Async Algorithmsパッケージのハイライトをほんの一握りにしました。

今日取り上げたもの以外にも多くのものがあります。

複数のAsyncSequencesの組み合わせ、時間によるレート制限、物事をチャンクに分割することに至るまでのアルゴリズムがありますが、これらは私たちがアプリで広範囲に使用することになったハイライトに過ぎませんでした。

このパッケージには、それらだけではありません。

バッファリング、削減、結合、断続的に値を注入することなど多岐にわたります。

Swift Async Algorithmsパッケージは、時間の経過とともに物事に対処するためのアルゴリズムのセットを取り、アプリで役立つ幅広い高度な機能に拡張します。

試してみてください。

私たちは、あなたがこれらで構築するものを発見することに本当に興奮しており、その興奮は共有されています。

このパッケージはあなたと一緒にオープンに開発されています。

見てくれてありがとう、そして会議の残りを楽しんでください。

♪インストゥルメンタルヒップホップ音楽♪