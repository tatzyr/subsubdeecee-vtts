10162

- こんにちは！私の名前はアンドレイです。

私はMetal FrameworksチームのGPUソフトウェアエンジニアです。

今日は、メタルメッシュシェーダーをご紹介できることを嬉しく思います。

メッシュシェーダーは、GPU主導のジオメトリの作成と処理のためのMetalの新しい柔軟なパイプラインです。

頂点/フラグメントパイプラインを改善し、多くの柔軟性を追加し、頂点ごとの処理の制限を取り除きます。

複数のアプリケーションがありますが、きめ細かいジオメトリの淘汰、GPUでのスケーラブルな手続き型ジオメトリの作成、圧縮された頂点ストリーム、メッシュレット、複雑な手続き型アルゴリズムなどのカスタムジオメトリ入力の許可など、これらに限定されません。

今日はこの3つのことを取り上げたいと思います。

まず、メタルメッシュシェーダーとは何かについて確認します。

次に、2つのメッシュシェーダーのユースケースについてお話ししたいと思います。

メッシュシェーダーは、手続き型毛のレンダリングなどの手続き型ジオメトリを生成するのに最適です。

メッシュシェーダーは、シーンの処理とレンダリングの改善にも役立ちます。

これの主な例は、メッシュシェーダーを使用してGPU駆動のメッシュレットカリングを実装することです。

メッシュシェーダーの導入から始めましょう。

これはスタンフォードバニーで、GPUでレンダリングできる典型的なメッシュを表しています。

このメッシュをレンダリングするには、まず頂点とインデックスデータをデバイスのメモリに配置する必要があります。

次に、レンダリングコマンドエンコーダを使用してドローコールを実行する必要があります。

従来のレンダリングパイプラインは、プログラム可能な頂点シェーダーステージ、固定機能ラスタライズステージ、プログラム可能なフラグメントシェーダーステージの3つの基本段階で構成されています。

頂点シェーダーステージは、デバイスメモリからジオメトリを入力として取り、それを処理します。

ラスタライザはスクリーンスペースのフラグメントを生成し、フラグメントシェーダーはそれらをシェーディングして最終的な画像を生成します。

このパイプラインは、その目的に非常によく役立っています。

しかし、柔軟性に欠け、一定の制限があります。

例を踏んでみましょう。

GPUでいくつかの手続き型ジオメトリを生成したいと想像してみてください。

例えば、あなたはこのバニーに手続き的な毛皮を追加することにしました。

このタスクが従来のジオメトリパイプラインでどのように処理されるかをお見せしましょう。

従来、手続き型ジオメトリを生成するには、コンピューティングカーネルディスパッチを実行するコンピューティングコマンドエンコーダも必要です。

コンピューティングカーネルは、元のメッシュを入力として取り、手続き型ジオメトリを生成し、デバイスメモリに出力します。

次に、レンダリングコマンドエンコーダを使用して、手続き型ジオメトリを入力として取り、最終的な画像を生成する描画呼び出しを実行します。

このアプローチでは、2つのコマンドエンコーダを必要とするだけでなく、手続き型ジオメトリを格納するために追加のメモリを割り当てる必要があります。

間接的なドローコールや高い拡張係数の場合、このメモリの量は非常に高く、予測が難しい場合があります。

2つのエンコーダの間には障壁もあり、GPU全体で作業をシリアル化します。

メタルメッシュシェーダーは、これらすべての問題に対処します。

メッシュシェーダーは、頂点シェーダーステージをオブジェクトシェーダーステージとメッシュシェーダーステージの2つの新しいプログラム可能なステージに置き換える新しいジオメトリパイプラインです。

この例では、オブジェクトシェーダーはジオメトリを入力として取り、それを処理し、「ペイロード」と呼ばれるデータをメッシュシェーダーに出力します。

このデータが何であるかを決めるのはあなた次第です。

メッシュシェーダーは、順番に、このデータを使用して手続き型ジオメトリを生成します。

この手続き型ジオメトリはドローコール内にのみ存在するので、デバイスメモリを割り当てる必要はありません。

ラスタライザに直接パイプライン化され、その後、最終的な画像を生成するフラグメントシェーダーにパイプラインされます。

メッシュドロー呼び出しは、従来のドロー呼び出しと同じタイプのレンダリングコマンドエンコーダを使用して実行されます。

メッシュドローコールと従来のドローコールを混合して一致させることができます。

では、2つの新しいプログラム可能なステージを見てみましょう。

頂点シェーダーとは対照的に、オブジェクトとメッシュシェーダーは計算カーネルに似ています。

それらはスレッドグループのグリッドで起動されます。

各スレッドグループは、コンピューティングスレッドと同様に、相互に通信できる個々のスレッドのグリッドです。

さらに、各オブジェクトスレッドグループはメッシュグリッドを生成し、起動するメッシュグリッドのサイズをプログラムで定義し、十分な柔軟性を提供します。

各オブジェクトスレッドグループは、ペイロードデータを生成するメッシュグリッドに渡します。

名前が示すように、オブジェクトステージはオブジェクトを処理します。

オブジェクトは、ニーズに応じて定義できる抽象的な概念です。

これは、シーンモデル、シーンモデルの一部、またはたとえば、手続き型ジオメトリを生成するスペースの領域にすることができます。

メッシュステージは、メッシュを構築し、ジオメトリデータをラスタライザに直接送信するように設計されています。

次の2つの例では、オブジェクトとメッシュの関係について説明します。

1つ目は、メッシュシェーダーを使用してヘアレンダリングを実装することです。

この作業を簡素化するために、バニーモデルの代わりに、単純な平面を使用します。

髪のパッチを生成するには、入力ジオメトリをタイルに分割し、各タイルは詳細のレベルと生成する必要があるストランドの数を計算し、個々の髪のストランドを生成します。

メッシュシェーダーを使用して、この平面上で手続き的に髪を生成する方法をお見せしましょう。

平面はタイルに分割することができ、各タイルはオブジェクトのスレッドグループに対応します。

各オブジェクトスレッドグループは、ヘアストランドの数を計算し、各ストランドのカーブコントロールポイントを生成します。

これがペイロードになります。

その後、オブジェクトスレッドグループはメッシュグリッドを起動し、各メッシュスレッドグループは1本の髪の毛を表します。

各メッシュスレッドグループは、メッシュをラスタライザーに出力します。

新しいジオメトリパイプラインを使用すると、ジオメトリ処理をハードウェアに密接にマッピングでき、GPUが提供するすべてのスレッドを最大限に活用できます。

メッシュレンダリングパイプラインでは、入力ジオメトリはオブジェクトシェーダーグリッドのタイルに分割されます。

各オブジェクトシェーダースレッドグループは、独立してペイロードを生成し、メッシュグリッドを起動できます。

グリッドからの各メッシュシェーダースレッドグループは、レンダリングパイプラインの残りの部分でさらに処理される金属::メッシュを生成します。

これらの各段階で生成されたデータを詳しく見てみましょう。

ペイロードはオブジェクトシェーダーで定義されています。

各オブジェクトスレッドグループは、カスタマイズされたペイロードを、オブジェクトスレッドグループが生成する生成されたメッシュグリッドに渡します。

ヘアレンダリングの場合、ペイロードはカーブコントロールポイントで構成されています。

一方、メッシュシェーダーは、新しいmetal::meshタイプを介して頂点とプリミティブデータを出力し、これについて少し詳しく説明します。

オブジェクトとメッシュステージは、パイプラインの残りの部分によって消費されるメッシュデータを出力します。

従来のパイプラインからの頂点出力と同様に、メッシュデータは最初にラスタライザーによって消費され、次にフラグメントシェーダーが実行されます。

ヘアレンダリングメッシュパイプラインの設定方法を深く掘り下げてみましょう。

まず、髪で覆われる平面はタイルに分割され、各タイルはオブジェクトのスレッドグループに対応します。

オブジェクトスレッドグループは、メッシュグリッドのサイズを決定し、メッシュグリッドに渡すペイロードデータを初期化します。

この場合、タイルには6本の髪の毛があり、各ストランドの曲線ペイロードデータとともに3x2メッシュグリッドを生成します。

各スレッドグループは、独自のメッシュグリッドサイズを生成できます。

次のスレッドグループでは、4本の髪の毛のみを生成する必要があるため、4本のストランドの曲線ペイロードデータの初期化とともに、2x2メッシュグリッドが設定されます。

これは、このアプローチを実装するオブジェクトシェーダーがどのように見えるかです。

オブジェクト属性がMetalに追加され、オブジェクトシェーダーのコードが指定されました。

ペイロード属性とobject_dataアドレス空間に加えて、ペイロード引数をシェーダーで使用できるようにします。

メッシュグリッドプロパティ引数は、メッシュグリッドサイズをエンコードするために使用されます。

次のステップはパイプラインの初期化です。

まず、メッシュレンダリングパイプライン記述子を割り当て、次にオブジェクト関数を初期化し、スレッドグループあたりのスレッドの最大数とともに、目的のペイロード長を指定します。

オブジェクトシェーダーには一定の制約があります。

ペイロードの形式とコンテンツは完全にカスタマイズ可能です。

ただし、ペイロードサイズは16キロバイトの制限を超えることはできません。

また、各オブジェクトスレッドグループが生成するメッシュスレッドグループの最大数は1024を超えることはできません。

オブジェクトシェーダーステージを準備した後の次のステップは、メッシュシェーダーステージを初期化することです。

メッシュシェーダーには、ユーザーが入力として定義したペイロードがあります。

この例では、ペイロードはカーブコントロールポイントのセットです。

各メッシュスレッドグループは、髪の毛の一本である金属::メッシュを生成します。

メッシュシェーダーの出力メッシュは、metal::meshタイプである必要があります。

metal::meshは、頂点とプリミティブデータをラスタライザとフラグメントシェーダーに出力するためのインターフェースを提供するMetalの組み込み構造です。

各metal::meshは、頂点シェーダーの出力タイプ、プリミティブデータ型、頂点の最大数、プリミティブの最大数、そして最後に、点、線、または三角形のいずれかのメッシュトポロジと同様に、頂点データ型を定義します。

メッシュ属性は、メッシュシェーダーのコードを指定するためにメタルシェーディング言語に追加されました。

Metal::meshは、メッシュシェーダーの出力構造として使用されます。

メッシュシェーダーは、これらの金属::メッシュをその場で生産できるため、GPU駆動のジオメトリ処理に最適です。

メッシュシェーダーは、金属::meshを有利に活用するため、追加のコンピューティングパスなしでレンダリングコマンドにより多くの処理を入れることができます。

メッシュのエンコードは、同じスレッドグループ内のスレッド間で行われます。

この例では、スレッドグループの最初の9つのスレッドは、このヘアストランドの頂点、インデックス、およびプリミティブデータをエンコードします。

スレッド0から4まで、それぞれメッシュ内の1つの頂点をエンコードします。

スレッドグループの残りのスレッドは、メッシュ内の頂点をエンコードしません。

次に、9つのスレッドすべてが1つのインデックスをメッシュインデックスにエンコードします。

次に、最初の3つのスレッドは、3つの三角形のプリミティブデータをエンコードします。

残りのスレッドはプリミティブデータをエンコードしません。

そして最後に、1つのスレッドは、metal::meshのプリミティブカウントをエンコードします。

このメッシュシェーダーのソースコードをお見せしましょう。

メッシュシェーダーは、頂点、インデックス、プリミティブデータ、そして最後にプリミティブカウントをエンコードするために同じ手順に従って、スレッドのできるだけ多くの発散を避けるために編成されています。

メッシュパイプライン記述子の初期化に戻りましょう。

メッシュパイプライン記述子では、メッシュスレッドグループごとの最大スレッドとともにメッシュ関数が設定されます。

金属::メッシュ構造が遵守する必要がある制限があります。

Metal::meshシェーダーには、次の制限があります。metal::meshは、最大256の頂点と最大512のプリミティブをサポートします。

金属::メッシュの合計サイズは16キロバイトを超えることはできません。

メッシュグリッドが金属::メッシュを生成したので、これらはラスタライザに供給され、最後にフラグメントシェーダーが実行されます。

したがって、従来のレンダリングパイプラインと同様に、フラグメント関数はメッシュパイプライン記述子に設定されます。

記述子が初期化されたので、Metalデバイスの「メッシュ記述子でパイプライン状態をレンダリングする」メソッドを使用してパイプライン状態が作成されます。

メッシュパイプラインのエンコードは、従来のドローコールのエンコードと非常によく似ています。

パイプラインの状態はエンコーダに設定されています。

パイプラインの各段階では、リソースにバインドすることができます。

この例では、バインドされたリソースは、オブジェクトステージへのオブジェクトバッファ、メッシュステージへのテクスチャ、フラグメントステージへのフラグメントバッファです。

次に、メッシュパイプラインを起動するために必要ないくつかの定数を定義します。オブジェクトグリッドの寸法、オブジェクトスレッドグループごとのスレッド数、メッシュスレッドグループごとのスレッド数、およびこれらの定数を使用して、新しい「draw mesh threadgroups」メソッドを使用して描画をエンコードします。

髪の平面をレンダリングするために使用されるのと同じアプローチは、メッシュパイプラインを介して手続き的に毛皮を生成するためにバニー全体に適用することができます。

次に、メッシュシェーダーを使用する別の方法を見てみましょう。

メッシュシェーダーは、メッシュレットカリングを使用して大量のジオメトリを効率的に処理およびレンダリングするために使用できます。

このテクニックの基礎は、シーンのメッシュをメッシュレットと呼ばれる小さな部分に分割することです。

シーンのジオメトリをメッシュレットに分割すると、シーンの粒度が高まり、より効率的できめ細かいカリングが可能になります。

これにより、ジオメトリのオーバーヘッドを大幅に削減できます。

メッシュレット粒度処理を活用することで、スクリーンスペースオクルージョンカリングや通常のフィルタリングなどの効率的なオクルージョンおよびカリングアルゴリズムが可能になります。

メッシュシェーダーを使用して、完全にGPU駆動のカリングとレンダリングパイプラインを実装できます。

これは、1つのコンピューティングと1つのレンダリングパスを使用してシーン処理とレンダリングを実行する従来のGPU駆動のパイプラインです。

シーンデータはメッシュレットに分割され、フラスタムカリング、LOD選択、およびデバイスメモリへの描画のエンコードを担当するコンピューティングパスに供給されます。

レンダリングパスは、シーンの描画コマンドを実行し、最終的な画像を生成します。

メッシュシェーダーを使用すると、2つのパスを1つのメッシュシェーダーディスパッチにマージすることで、同期ポイントを削除し、中間描画コマンドを回避できます。

それがどのようにできるかをお見せしましょう。

これは、メッシュシェーダーディスパッチを実行する単一のレンダリングパスです。

オブジェクトシェーダーは、フルスタムカルリングを実行し、目に見えるメッシュレットごとにLODを計算します。

メッシュシェーダーへのペイロードは、エンコードする必要があるメッシュレットIDのリストです。

次に、メッシュシェーダーは、ラスタライズされ、シェーディングされるmetal::meshオブジェクトをエンコードします。

その後、最終的な画像は、従来のパイプラインと同じフラグメントシェーダーでシェーディングされます。

ジオメトリ処理は、完全にメッシュスレッドグループコマンド内と単一のエンコーダ内で行われます。

三角形データがメッシュシェーダーにエンコードされるため、これらの描画コマンドを保存するための中間バッファはもはや必要ありません。

今、淘汰に注意を向けましょう。具体的には、メッシュレット淘汰の実装です。

シーンは、ここの図形で表されるモデルで構成されています。

この実装では、シーンの各モデルがオブジェクトグリッドの一部になります。

オブジェクトシェーダースレッドグループによって生成されるメッシュグリッドは、モデルの表面を構成する三角形のパッチであるメッシュレットで構成されます。

新しいジオメトリパイプラインは非常に柔軟です。

シーンをオブジェクトグリッドにマッピングする方法を決めるのはあなた次第です。

この例では、各モデルをオブジェクトスレッドグループにマッピングしていますが、タスクに適したマッピングを使用できます。

これで、オブジェクトシェーダーは、表示フラスタムを使用してメッシュレットの可視性を決定し、最終的な画像に表示されるものに対してのみディスパッチ作業を行います。

現場の2つのモデルに焦点を当てましょう。

オブジェクトシェーダーは、決定された可視性に基づいてメッシュグリッドを起動します。

次に、メッシュシェーダーはメッシュレットを処理し、metal::meshesを構築します。

プログラム可能なメッシュグリッドサイズにより、柔軟なディスパッチが可能になるため、目に見えるメッシュレットのみがメッシュシェーダーによって処理されます。

これにより、パイプラインの後半で目に見えないジオメトリの処理に費やす時間が短縮されます。

固定機能ラスタライザは、目に見えることが知られているサーフェスのみを受け取り、目に見えないジオメトリの処理とクリッピングに費やす時間を短縮します。

最後に、プログラム可能なフラグメントシェーダーが呼び出され、最終的な画像が生成されます。

ご覧のとおり、このメッシュレットカリングの例に示されているように、手続き型メッシュを作成したり、ドローコールをより効率的にしたりするなど、新しいジオメトリパイプラインで対処できるさまざまな問題があります。

金属には、モダンで柔軟な新しいジオメトリパイプラインが含まれています。

ヘアレンダリングの例に示されているように、手続き型ジオメトリの作成がこれまで以上に簡単になりました。

さらに、メッシュレットの淘汰デモに見られるように、単一のレンダリングパスでのGPU駆動作業の可能性は、追加のコンピューティングパスや中間バッファを必要とせずに拡大しました。

この新しいジオメトリパイプラインは、Family7およびMac2デバイスで利用できます。

メッシュシェーダーの学習と実験を開始するために、新しいAPIの使用方法を示すサンプルコードがApple開発者Webサイトで入手できます。

この機能をどのように使用し、ジオメトリ処理のニーズに合わせてApple GPUの大規模な並列性を活用する方法に興奮しています。

見てくれてありがとう!