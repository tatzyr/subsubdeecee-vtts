10114

♪インストゥルメンタルヒップホップ音楽♪

ようこそ、皆さん。私の名前はデビッド・ヘイワードで、コアイメージチームのソフトウェアエンジニアです。

今日は、Core Imageアプリケーションで拡張ダイナミックレンジのコンテンツを表示する方法について説明します。

私の話は4つの部分に分かれます。

まず、私たちのプラットフォームでEDRの重要な用語をいくつか紹介します。

次に、新しいCore Imageサンプルプロジェクトについて説明します。その後、EDRのサポートを追加する方法を実演します。

最後に、CIFiltersを使用してEDRコンテンツを生成する画像を作成する方法を紹介します。

では、いくつかの重要な用語から始めましょう。

SDR、または標準ダイナミックレンジは、黒の0から白の1の正規化された範囲を使用してRGB色を表す伝統的な方法です。

対照的に、EDRまたは拡張ダイナミックレンジは、正常範囲を超えてRGB色を表す推奨される方法です。

SDRと同様に、0は黒を表し、1はSDR白と同じ明るさを表します。

しかし、EDRでは、1より大きい値を使用して、さらに明るいピクセルを表すことができます。

しかし、1より大きい値は許可されていますが、ヘッドルームの上の値は切り取られることを覚えておいてください。

ヘッドルームは、ディスプレイの現在の最大ニットをSDRホワイトのニットで割った値から派生します。

ヘッドルームの値は、ディスプレイ間、または周囲の条件やディスプレイの明るさの変化に応じて変化する可能性があることに注意してください。

これらの概念をより深く議論するために、「iOSでEDRを探索する」プレゼンテーションを見ることをお勧めします。

アプリケーションに提示できるEDRコンテンツのソースはいくつかあります。

まず、TIFFやOpenEXRなどの一部のファイル形式は、EDRの浮動小数点値を保存できます。

また、AVFoundationを使用して、HDRビデオフォーマットからフレームを取得することもできます。

Metal APIは、EDR環境をテクスチャにレンダリングするために使用できます。

また、ProRAW DNGファイルをレンダリングしてEDRのハイライトを表示することもできます。

2021年のプレゼンテーション「ProRAW画像をキャプチャして処理する」では、これを詳細に説明しています。

プレゼンテーションの次の部分では、SwiftUIアプリケーションでMetalでCore Imageを使用する方法について説明します。

後で、このアプリケーションにEDRサポートを追加する方法を概説します。

私たちは最近、SwiftUIマルチプラットフォームアプリでCore ImageとMetal Kit Viewを組み合わせる方法のベストプラクティスを示す新しいサンプルコードプロジェクトをリリースしました。

サンプルをダウンロードしてコードを見ることをお勧めしますが、この機会にそれがどのように見え、どのように機能するかをお見せしましょう。

サンプルは、メタルビューに表示されるアニメーション化された手続き型CIImageを描画します。

最適なパフォーマンスを得るには、サンプルはMTKViewを使用します。

コードをシンプルに保つために、アプリはアニメーションチェッカーボードCIImageをアプリが望むコンテンツのプロキシとして表示します。

また、このアプリはSwiftUIを使用しているため、macOS、iOS、iPadOSプラットフォームで共通のコードベースを使用できます。

このプロジェクトはいくつかの短いソースファイルから構築されているので、クラスがどのように相互作用するかを説明しましょう。

このアプリケーションには3つの重要な部分があります。

最初で最も重要なのは「MetalView」です。

MTKViewクラスをラップするSwiftUI互換のView実装を提供します。

MTKViewクラスはmacOSのNSViewと他のプラットフォームのUIViewに基づいているため、MetalViewの実装ではViewRepresentableを使用してSwiswisUIとプラットフォーム固有のMTKViewクラスをブリッジします。

ただし、MTKViewはレンダリングに直接責任を負いません。

代わりに、そのデリゲートを使用してその作業を行います。

このアプリでは、RendererクラスはMTKViewのデリゲートです。

MetalコマンドキューやCore Imageコンテキストなどのグラフィック状態オブジェクトの初期化を担当します。

また、MetalViewデリゲートであるために必要なdraw()メソッドも実装しています。

ただし、レンダラーは、どの画像を描くかを決定する直接的な責任を負いません。

代わりに、imageProviderブロックを使用してCIImageを描画します。

このアプリでは、ContentViewクラスは、レンダリングするCIImageを提供するコードブロックを実装します。

簡単に要約すると、MetalViewはデリゲートに描画を呼び出します。

Renderer draw() メソッドは、描画する画像を提供するために ContentView を呼び出します。

MetalViewクラスのmakeView()コードから始めて、これら3つのクラスのコードについてもう少し詳しく説明しましょう。

makeView() が MTKView を作成するために呼び出されると、ビューのデリゲートをレンダラー状態オブジェクトに設定します。

これは、NSViewまたはUIViewをラップするSwiftUIビューを実装するための標準的なアプローチです。

次に、viewをレンダリングする頻度を指定するためにpreferredFramesPerSecondを設定します。

このプロパティは、ビューの描画を駆動するものを決定するため、重要です。

これがどのように機能するかを説明しましょう。

このサンプルはアニメーション化されたアプリケーションなので、コードはview.preferredFramesPerSecondを目的のフレームレートに設定します。

これを設定すると、MTKViewは、ビュー自体が描画イベントのタイミングを駆動するように設定されます。

これにより、ビューのレンダリングデリゲートは定期的にdraw（）し、コンテンツプロバイダーに現在のCIImageを作成するように要求します。

そして、アニメーションが一時停止されるまで、プロセスは繰り返されます。

画像編集アプリなどの他のケースでは、ビューを描画する必要があるときに駆動するコントロールとのユーザーインタラクションに最適です。

enableSetNeedsDisplayをtrueに設定すると、MTKViewはコントロールが描画イベントのタイミングを駆動できるように設定されます。

コントロールが移動されると、updateView()メソッドを呼び出す必要があります。

その後、ビューのデリゲートは一度draw()に呼び出されます。

そして、各ドローは、現在の制御状態のCIImageを作成するようにコンテンツプロバイダーに依頼します。

このアプローチは、ビデオのフレームの到着がドローイベントを駆動する場合にも適切です。

それで、MetalViewクラスについての私の議論を締めくくります。

次に、レンダラーデリゲートで最も重要なコードはdraw()メソッドです。

レンダラーのdraw()メソッドは、定期的なフレームレートで呼び出されます。

Draw() メソッドが呼び出されると、ビューがオンになっているディスプレイの解像度を反映するコンテンツスケールファクターを決定する必要があります。

CIImagesはポイントではなくピクセルで測定されるため、これは必要です。

ビューを別のディスプレイに移動すると、このプロパティが変更される可能性があるため、draw()メソッドが呼び出されるたびにこれを行うことが重要です。

次に、mtlTextureProviderでCIRenderDestinationを作成します。

次に、コンテンツプロバイダーを呼び出して、現在の時間とスケールファクターに使用するCIImageを作ります。

この返された画像は、ビューの可視領域の中央に配置され、不透明な背景にブレンドされ、CIImageをビューの宛先にレンダリングするタスクを開始します。

ContentView クラスで最も重要なコードは init() メソッドです。

Init() メソッドは、コンテンツ ビューの本文を作成する責任があります。

これを行うと、RendererとMetalViewクラスへの接続が確立されます。

まず、イメージプロバイダーブロックを持つレンダラーオブジェクトを作成します。

そのブロックは、要求された時間とスケールのCIImageを返す責任があります。

そして最後に、ContentViewの本体を、そのレンダラーを使用するMetalViewに設定します。

さて、これで完了です。Core Imageを使用してレンダリングできるシンプルなSwiftUIアプリがあります。

次に、EDRヘッドルームでレンダリングをサポートするためにこのアプリを変更する方法を見てみましょう。

このアプリケーションにEDRサポートを追加するのは本当に簡単です。

ステップ1はEDRのビューを初期化し、ステップ2はすべてのレンダリングの前にヘッドルームを計算し、ステップ3は利用可能なヘッドルームを使用するCIImageを構築することです。

これらの追加のための実際のコードをお見せしましょう。

まず、MetalViewクラスで1つの小さな追加が必要です。

ビューを作成するときは、拡張DynamicRangeContent が必要なレイヤーに伝え、その pixelFormat は .rgba16Float で、色空間は拡張され、線形である必要があることをビューに伝える必要があります。

第二に、Rendererクラスのdraw()メソッドにいくつかの変更が必要です。

Draw() メソッドでは、ビューの現在の画面を取得し、現在のEDRヘッドルームを画面に要求するコードを追加する必要があります。

その後、ヘッドルームはパラメータとしてイメージプロバイダーブロックに渡されます。

Draw() メソッドが呼び出されるたびにこれを行うことが重要であることに注意してください。

ヘッドルームは、周囲の条件やディスプレイの明るさがどのように変化するかによって変化する動的特性です。

そして3番目の変更は、ContentViewクラスのプロバイダブロックです。

ここでは、イメージプロバイダーブロック宣言にヘッドルーム引数を追加する必要があります。

その後、CIFiltersでヘッドルームを使用して、ユーザーのEDRディスプレイで素晴らしく見えるCIImageを返すことができます。

要約すると、これらはこのアプリケーションにEDRサポートを追加するための3つの簡単なステップでした。EDRのビューを初期化し、すべてのレンダリングの前にヘッドルームを決定し、ヘッドルームを考慮して表示するCIImageを構築します。

これがこのプレゼンテーションの残りの部分のトピックになります。

アプリがEDRをサポートしたので、CIImagesを作成するためにCIFiltersを使用していくつかのEDRコンテンツを表示させましょう。

Core Imageに組み込まれた150以上のフィルターがEDRをサポートしています。

これは、これらすべてのフィルタがEDRコンテンツを含む画像を生成するか、EDRコンテンツを含む画像を処理できることを意味します。

たとえば、CIColorControlsとCIExposureAdjustフィルターを使用すると、アプリがEDRカラーで画像の明るさ、色相、彩度、コントラストを変更できます。

また、グラデーションフィルターなどのいくつかのフィルターは、EDRカラーパラメータを指定して画像を生成できます。

今年追加した3つの新しいフィルターは、EDR画像もサポートしています。

最も注目すべきは、CIAreaLogarithmicHistogramは、任意の範囲の明るさ値のヒストグラムを生成することができます。

CIColorCubeフィルターは、EDR入力画像でよりよく機能するように今年更新したフィルターの例です。

これらの組み込みフィルタはすべて、Core Imageの作業色空間がクランプされておらず線形であるため、0から1の範囲外のRGB値を可能にするため、機能します。

アプリを開発する際に、特定のフィルターがEDRをサポートしているかどうかを確認できます。

これを行うには、フィルタのインスタンスを作成し、フィルタの属性にそのカテゴリを尋ね、配列にkCICategoryHighDynamicRangeが含まれているかどうかを確認します。

また、私たちが追加した新機能は、CIFilter変数のXcode QuickLookデバッグサポートです。

これにより、各入力パラメータのカテゴリと要件を含む、各フィルタークラスのドキュメントが表示されます。

これらすべてのEDRフィルターを考えると、アプリがコンテンツに適用できるさまざまな効果があります。

今日説明する例では、サンプルアプリからチェッカーボードパターンに明るい鏡面反射を伴う波及効果を追加します。

この効果を作成するには、rippleTransitionフィルタのインスタンスが必要です。

次に、入力画像とターゲット画像の両方をチェッカー画像に設定します。

次に、リップルの中心と遷移時間を制御するフィルタ入力を設定します。

そして、shadingImageをリップルに鏡面ハイライトを生成するグラデーションに設定します。

そして最後に、設定したすべてのフィルタ入力が与えられた出力画像のフィルタを求めます。

また、リップル効果の鏡面ハイライトを作成するために使用されるシェーディングイメージを作成する方法も説明しましょう。

ビットマップデータからこのイメージを作成できますが、さらに優れたパフォーマンスを得るために、このCIImageを手続き的に生成できます。

これを行うには、linearGradientフィルタのインスタンスを作成します。

このフィルタは、2つの点と2つのCIColorsが与えられたグラデーションを作成します。

鏡面は白で、明るさは現在のヘッドルームに基づいていますが、合理的な最大値に制限されています。

使用する制限は、適用したい効果の外観によって異なります。

Color0は、クランプされていない線形色空間でその白色レベルを使用して作成する必要があります。

Color1はクリアカラーに設定されています。

点0と点1は、鏡面が左上方向から表示されるように座標に設定されています。

そして、フィルターの出力画像は、リップルフィルターに必要なサイズにトリミングされます。

結果として生じる鏡面効果のリップルは、アプリでできることの単純なプロキシにすぎません。

しかし、それは重要な原則を示しています。

通常、明るいピクセルを適度に使用するのが最善です。

少ないほど多い。

明るいピクセルは、その方法でよりインパクトがあります。

私たちは今、EDR効果のために2つの組み込みシフィターを使用する作業アプリを持っています。

他の内蔵EDRフィルターで自由に試してみてください。

次に、CIColorCubeフィルターの最適な使用方法と、独自のカスタムフィルターを書く際の注意事項について少しお話ししたいと思います。

非常に人気のあるフィルターの1つはCIColorCubeWithColorSpaceです。

従来、このフィルターはSDR画像にルックスを適用するために使用されます。

このフィルターは、プロセス、インスタント、トーンなどの写真アプリにエフェクトを実装するためにも使用されます。

伝統的に、このように見える立方体データには重大な制限があります。データは0対1の範囲のRGB色のみを入力および出力します。

この制限を回避する1つの方法は、CIColorCubeWithColorSpaceフィルターにHLGやPQなどのEDR色空間を使用するように指示することです。

これにより、EDRコンテンツに最適な結果が得られますが、これには色空間範囲で有効な新しいキューブデータを作成する必要があります。

また、キューブの寸法を増やす必要があるかもしれません。

代わりに、EDR画像にSDRキューブデータを引き続き使用することをお勧めします。今年の新機能では、フィルターにSDRキューブデータを推定するように指示できます。

この機能を有効にするには、通常どおりSDRキューブデータを設定します。

次に、フィルタの新しい外挿プロパティを設定します。

この設定を「true」にすると、フィルターにEDR入力画像を与え、EDR出力画像を取得できます。

今日取り上げたい最後のトピックは、独自のカスタムCIKernelsを作成する場合のベストプラクティスです。

まず、クランプ、最小、最大などの関数を使用して、RGB値を0対1の範囲に制限する数学のカーネルコードを確認します。

多くの場合、これらの制限は安全に削除でき、カーネルは正しく動作します。

第二に、RGB値は0から1の範囲を超える可能性がありますが、アルファ値は0から1の間でなければなりません。そうしないと、画像をブレンドまたは表示するときに未定義の動作になります。

この例では、正しい動作がRGB値に5を掛けるだけである場合、カーネルは誤ってアルファチャンネルに5を掛けています。

これで私のプレゼンテーションは終わりです。

最後に、今日は、Core Image SwiftUIアプリケーションにEDRヘッドルームのサポートを追加する方法と、さまざまな組み込みシピルターを使用してEDRコンテンツを作成および変更する方法を学びました。

見てくれてありがとう!

♪インストゥルメンタルヒップホップ音楽♪