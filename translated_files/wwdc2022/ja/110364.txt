110364

♪ ♪

こんにちは、WWDC 2022へようこそ。

私の名前はベンで、Xcodeビルドシステムチームのエンジニアです。

こんにちは、私の名前はArtemで、Swift Compilerチームのエンジニアです。

この講演では、ビルド内の並列化を解明するために、Xcodeのビルドプロセスを深く掘り下げます。

ベンは、ビルドに関するコアコンセプトの紹介から始め、ビルドパフォーマンスの問題を調査するためにXcodeが提供する利用可能なツールを見ていきます。

次に、Xcodeがターゲットの構築中に並列化をどのように増加させるかを説明します。

それに加えて、多くのターゲットで構成されるプロジェクトを構築しながら、Xcodeがどのように構築を総合的に並列化するかを説明し、最後にテイクアウトを要約します。

ベン？

XcodeでCMD+Bを押してアプリを構築するときに何が起こるかをもう一度繰り返しましょう。

ビルドシステムは、Xcodeの一部として、すべてのソースファイル、アセット、ビルド設定、および実行先などの他の構成を含むプロジェクト全体の表現で呼び出されます。

ビルドシステムは、アプリの構築方法に関する真実の唯一の情報源です。

最終的にアプリを作成するために、どの設定とどの中間ファイルを使用してどのツールを呼び出すかを知っています。

次のステップでは、ビルドシステムは、コンパイラなど、プロジェクトの入力ファイルを処理するためのツールを呼び出します。

ClangとSwiftの両方のコンパイラは、リンカがアプリを表す実行可能プログラムをリンクするために必要なオブジェクトファイルを生成します。

この注文は理にかなっていますが、それがどこから来たのかは明らかではありません。

それでは、そのプロセスの1つの例と、ビルドシステムがすべてのタスクを実行する順序を決定する方法を見てみましょう。

入力ソースファイルを使用して、Swiftコンパイラはプログラマーの意図をキャプチャし、それを機械実行可能なバイナリに変換し、途中でソースコードのエラーをチェックします。

このプロセスは失敗する可能性があり、ビルドはキャンセルされますが、成功すると、入力ごとにオブジェクトファイルが作成されます。

これらのオブジェクトファイルは、それらを組み合わせたリンカを呼び出すために使用され、外部にリンクされたライブラリへの参照を追加して実行可能ファイルを生成します。

2つのタスクは、消費するものと生産するものに基づいて依存関係があります。

コンパイラによって生成されたオブジェクトファイルは、リンカーによって消費されます。

これにより、ビルドシステムグラフへの依存関係が作成されます。

ファイルの内容自体はビルドシステムには興味がありませんが、タスク間の依存関係は。

ビルドの実行中に、別のタスクの入力を生成するタスクが、そのタスクが開始される前に終了することを確認する必要があります。

そして、このコアコンセプトはあらゆる種類のタスクに有効であるため、タスクAとタスクBの間の依存関係を示す、より一般的な視覚化に切り替えましょう。

この場合、AはBの入力の一部または全部を生成します。

コンパイルとリンクは、ターゲット全体を構築するために実行する必要がある多くの異なるタスクタイプのほんの一部ですので、アセットのコンパイル、ファイルのコピー、共同設計など、他のタイプを表すより一般的なタスクをグラフに追加しましょう。

一緒に、彼らはフレームワークターゲットの構築を表しています。

繰り返しますが、これらのタスクは、入力と出力に基づいて依存関係を定義しています。

したがって、タスクAの実行を完了すると、実行中のタスクBとCのブロックが解除され、タスクBの終了はタスクDとEのブロックを解除します。

ブロックを解除するタスクは「ダウンストリーム」と呼ばれ、「アップストリーム」をブロックするタスクと呼ばれます。

多くのプロジェクトには複数のフレームワークターゲットが含まれているので、アプリとアプリ拡張機能を表すターゲットを2つ追加しましょう。

ターゲットは、明示的または暗黙の依存関係を介して、プロジェクト内の相互の依存関係を定義します。

たとえば、「Link Binary with Libraries」のビルドフェーズに追加されます。

この場合、アプリはアプリの拡張機能を埋め込み、フレームワークにリンクします。

アプリの拡張機能はフレームワークを使用していないため、依存関係はありません。

ビルドグラフを実行すると、タスクによって異なる時間がかかります。

これは、必要な計算と入力のサイズに応じて、作業を完了するために必要な複雑さのレベルに帰着します。

多くのファイルをコンパイルするには、通常、いくつかのヘッダーファイルをコピーするよりもはるかに時間がかかり、これを考慮に入れると、このようなものになります。

ビルドシステムがこのビルドを実行すると、依存関係のないタスクを実行することから始めます。

そして、それらが完了すると、すべての計画されたタスクが完了するまで、このプロセスに従って、ダウンストリームタスクなどのブロックを解除します。

次のビルドでは、ビルドシステムは、出力がまだ最新である間に入力が変更されていないタスクをスキップすることができます。

この場合、アプリターゲットのBのように、入力が変更されたためにタスクを再実行する必要がある場合、出力が変更された場合、ダウンストリームのタスクも再実行する必要があります。

他のすべてのタスクをスキップすると、プロジェクトに反復的に取り組むときに非常に速いターンアラウンドタイムが可能になります。

これは増分ビルドと呼ばれていますが、今のところはフルビルドに固執しましょう。

タスク実行の依存関係と期間は、ダウンストリームタスクが開始できる最初の可能な時間を定義します。

この情報を使用すると、ビルドが理論的な無制限のリソースで実行する必要がある最短時間であるクリティカルパスを計算することができます。

この講演を通して共通のパターンは、このパスを短縮して、高度に並列化可能でスケーラブルなビルドグラフを作成することです。

クリティカルパスが短くなると、必ずしも全体的なビルド時間が短くなるとは限りませんが、ビルドがハードウェアでスケーリングされることを保証します。

クリティカルビルドパスは、ビルドの速度の制限要因を定義します。ハードウェアが許可したとしても、より速く完了することはできません。

クリティカルパスの短縮は、その中の依存関係を分割することによって行われます。

ビルドがどのように実行されたかを見て、その実行についてもっと理解するために、実行された時間に基づいてデータをプロットする必要があります。

幅は依然としてタスクの長さを示します。

これら2つのような広い要素はロングランニングタスクを示し、このような狭い要素は高速仕上げタスクを表します。

グラフの高さは、特定の時間に並行して実行するタスクの数を示しています。

これはCPUやメモリ使用率に直接マッピングされないことに注意してください。

空のスペースは、これら2つのシナリオのように下流のタスクをブロックするタスクによって発生します。

そして最後に、要素の色は関連するターゲットを表します。

このビジュアライゼーションがXcode 14で新しく、完了後のビルドのパフォーマンスを理解するのに役立つことを発表できることを非常に嬉しく思います。

Xcodeビルドタイムラインは、ビルドログへの素晴らしい新しい追加です。

ビルドのパフォーマンスを理解するために、階層ではなく並列化に基づいて視覚化します。

指定された時刻の行数は、その期間中の並列性のレベルを表します。

個々のタスクの水平方向の長さは、作業を完了するために必要な期間を表します。

グラフの空のスペースは、未完成のタスクが下流のタスクの実行開始を妨げた場所を示しています。

タイムライン要素に適用される異なる色は、ビルドの一部であった異なるターゲットを区別するのに役立ちます。

また、増分ビルドでは、タイムラインには実際に実行されたタスクのみが含まれ、長時間実行されるタスク、特にこのビルド中に実行されると予想されなかったタスクを見つけることができます。

これはXcode 14のビルドタイムラインのデモです。

このウィンドウで、ドキュメントコンパイラを構築するGithubのswift-doccプロジェクトのコピーを開きました。

スキーム用に構築されたターゲットの概要を知るには、スキームエディターをチェックしてみましょう。

それを開くには、スキームをクリックし、「スキームの編集」を選択します。

「ビルド」タブには、すべてのターゲットのリストが含まれています。

ターゲットは、スキームに明示的に追加することも、すでにスキームの一部であるターゲットの依存関係であることによって暗黙的に追加することもできます。

この場合、パッケージに自動的に生成されたスキームを持つSwiftパッケージを使用しているため、マニフェストのすべてのターゲットが明示的に定義されています。

このログは、私が以前に実行したスキームのビルドを表しています。

ビルドシステムが実行したすべてのタスクのエントリが含まれています。

エントリは、ここでの「docc」ターゲットのように、所属するターゲットに基づいて階層に整理されています。

そのターゲットの実行可能ファイルを正常に構築するために、Xcodeはこのノードの子によって表されるすべてのタスクを実行しました。

ビルドログは現在「すべて」状態であるため、増分ビルドで再実行する必要がなかった以前のビルドのタスクも表示されます。

「最近」を選択すると、実際に実行されたタスクのみが表示され、スキップされたすべてのタスクが非表示になります。

それに加えて、ビルドログは、問題があったタスクや失敗したタスクのみを表示するフィルターもサポートしています。

このビルドのビルドタイムラインを開くには、エディタオプションに移動してアシスタントを開きます。

ビルドタイムラインはビルドログの横に開きます。

いつものように、エディタオプションは、右側または下部にアシスタントを表示する設定を提供します。

今のところはボトムにとどまります。

タイムラインは、ビルドの並列化に基づいて「最近の」ビルドログと同じデータを視覚化します。

一方の要素を選択すると、もう一方の要素も選択されます。

これにより、コンテキスト内でタスクの実行を確認できます。

ここでのタイムラインは、選択したタスクと並行して実行されたタスクについての感覚を与えます。

トラックパッドでピンチジェスチャーを使って再びズームアウトしています。

タイムラインで要素を選択すると、ビルドログに表示されます。

また、ビルドログは階層構造に基づいて視覚化されるため、このコンパイラ呼び出しの一部としてコンパイルされたファイルを表示できます。

また、その呼び出しのコマンドライン全体を表示することもできます。

ビルドタイムラインで領域を選択しながらOptionキーを押したままにすると、この時間枠に合わせてビューポートが調整されます。

ここでは、ターゲットArgumentParserのリンクが実際に同じターゲットのコンパイルを待っていることを確認できます。

上にスクロールしながらOptionキーを押したままにすると、すばやくズームアウトできます。

タイムラインの行数は、その時点で並行して実行されたタスクの数を表します。

このような空のスペースは、未生成の入力を待っているタスクを示します。

理想的には、タイムラインは垂直に塗りつぶされ、空きスペースはできるだけ少ないです。

これにより、ビルドグラフが最適にスケーリングされ、ビルドが速くなり、ハードウェアが速くなります。

これを達成するために、Xcodeは今年、クリティカルパスを短縮するために多くの改善が付属しています。

次に、Xcodeが個々のターゲットをどのように定義して構築するか、そしてどのように並列化を高めることができるかを確認しましょう。

ターゲットを設定するとき、ビルドフェーズは、そのターゲットの製品を生産するために必要な作業を記述します。

それらはプロジェクトエディタで定義され、コンパイルするソースコードファイルとアセットのセット、ヘッダーやリソースのようにコピーする必要があるファイル、リンクする必要があるライブラリ、または実行する必要があるスクリプトを含めることができます。

多くのビルドフェーズは、他のビルドフェーズからの入力または出力を使用してタスクを記述し、それら間の依存関係を作成します。

たとえば、ターゲットのソースファイルは、リンクされる前にコンパイルする必要があります。

ただし、これはすべてのビルドフェーズに適用されるわけではありません。

各ビルドフェーズからタスクを直線的な順序で実行するのではなく、ビルドシステムはビルドフェーズの入力と出力を考慮して、並行して実行できるかどうかを判断します。

たとえば、コンパイルとリソースのコピーは、どちらも他方の出力に依存しないため、並行して実行できます。

ただし、リンクは、そのフェーズによって生成されたオブジェクトファイルに依存するため、コンパイルに従う必要があります。

では、「スクリプトの実行」ビルドフェーズを含む別のターゲットを考えてみましょう。

他のビルドフェーズとは異なり、スクリプトフェーズの入力と出力はターゲットエディタで手動で設定する必要があります。

その結果、ビルドシステムは、ビルドプロセスにデータレースを導入しないように、連続したスクリプトフェーズを一度に1つずつ実行します。

ターゲットのスクリプトが依存関係分析に基づいて実行され、入力と出力の完全なリストを指定するように構成されている場合、ビルド設定FUSE_BUILD_SCRIPT_PHASESをYESに設定して、ビルドシステムがそれらを並行して実行する必要があることを示すことができます。

ただし、スクリプトフェーズを並行して実行する場合、ビルドシステムは指定された入力と出力に依存する必要があります。

したがって、スクリプトフェーズの入力または出力の不完全なリストは、デバッグが非常に難しいデータレースにつながる可能性があることに注意してください。

これを軽減するために、Xcodeは各スクリプトフェーズの依存関係を正確に宣言するユーザースクリプトサンドボックスをサポートしています。

サンドボックスは、フェーズの入力または出力として明示的に宣言されていない限り、シェルスクリプトが誤ってソースファイルや中間ビルドオブジェクトにアクセスするのをブロックするオプトイン機能です。

この例では、inputもoutput.txtも、そのスクリプトフェーズの依存関係として宣言されていません。

サンドボックスは、プロジェクトを構築するときに、スクリプトが両方のファイルを読み書きするのをブロックします。

スクリプトがサンドボックスに違反すると、ゼロ以外の終了コードで失敗し、ビルドが失敗します。

それに加えて、Xcodeは、スクリプトフェーズが適切に宣言せずにアクセスしようとしたすべてのパスを一覧表示します。

このスクリプトフェーズに依存関係情報として両方のファイルを追加すると、この問題が修正されます。

このようにして、サンドボックスは、スクリプトが宣言された入力と出力以外のファイルに誤ってアクセスしていないことを保証します。

では、複数のスクリプトフェーズを持つ例を探り、サンドボックスがデータレースや誤ったビルドを防ぐ方法を見てみましょう。

スクリプトフェーズは2つあります。

最初のものは、テキストファイルを読み取り、その内容のチェックサムを計算し、その値をDERIVED_FILE_DIRの中間ファイルに書き込みます。

他のスクリプトは、同じテキストファイルと生成されたチェックサムを読み取り、後でアプリに表示するためにhtmlファイルに注入します。

これらのフェーズの入力と出力の依存関係の正確なセットが宣言されていない場合、XcodeはFUSE_BUILD_SCRIPT_PHASESがオンになっているときに2つのスクリプトを並行して実行します。

この問題のあるシナリオを詳細に調べましょう。

「HTMLの生成」に「checksum.txt」の入力宣言が欠落しているが、両方のスクリプトの他のすべての入力と出力が正しく宣言されていると仮定しましょう。

サンドボックスがなければ、この設定ミスは気づかれず、ビルドに問題を引き起こす可能性があります。

これは、Xcodeが両方のフェーズ間の依存関係を推測することに失敗し、FUSE_BUILD_SCRIPT_PHASESがオンになっているときにそれらを並行して実行するようにスケジュールすることを意味します。

ここにはいくつかの危険があります。

checksum.txtはクリーンビルド中に「生成HTML」の入力依存関係としてリストされていないため、スクリプトはファイルシステムで使用できないままファイルを読み取ろうとします。

もう1つの危険は、「Checksumの計算」の以前の実行のためにchecksum.txtがディスク上で利用可能な場合、「HTMLの生成」は、2つのスクリプトが並行して実行されたときに古いファイルを拾う可能性があります。

これはユーザーエラーであり、サンドボックスでスクリプトを実行すると、この問題を防ぐのに役立ちます。

サンドボックスをオンにすると、「HTMLの生成」は「checksum.txt」を読み取ろうとするとすぐに失敗します。

エラーメッセージは、そのビルドフェーズに不足している入力を追加することをガイドします。

入力と出力が正しく定義されているため、Xcodeは両方のフェーズ間の依存関係を尊重し、「計算チェックサム」が「HTMLの生成」の前に実行されます。

無関係なビルドフェーズは依然として並行して実行できますが。

ターゲットのサンドボックスシェルスクリプトを有効にするには、ビルド設定エディタまたはxcconfigファイルでENABLE_USER_SCRIPT_SANDBOXINGをYESに設定します。

要約すると、サンドボックス化されたシェルスクリプトは、入力が変更されておらず、出力がまだ有効な場合、ビルドシステムはスクリプトフェーズをスキップする自信があり、そうでない場合はスクリプトを再実行するため、より高速で堅牢な増分ビルドを可能にする正しい依存関係情報を持つことができます。

スクリプトのターゲットのビルド設定を有効にすると、プロジェクトのソースルート内のファイルと、プロジェクト内のスクリプトの入力または出力として明示的に定義されていない場合は、派生データディレクトリへのアクセスがブロックされます。

サンドボックスは、他のディレクトリへの不正アクセスを防ぐことはできませんので、これをセキュリティ機能と考えないでください。

この機能を使用すると、既存のスクリプトフェーズの不足している入力または出力をデバッグして、有効な構成を確保することができます。以前に説明したビルド設定FUSE_BUILD_SCRIPT_PHASESと組み合わせて、サンドボックスを介して正しく定義された依存関係エッジを持つスクリプトフェーズは、ビルドのクリティカルパスを減らすために並行して実行できます。

それは、ターゲットを構築するステップを並列化するためのものです。

今、アルテムは多くのターゲットを構築する並列化の謎を解くつもりです。

アルテム:ありがとう、ベン。

プロジェクトでターゲットを構築する可能性のあるビルドシステムタスクとフェーズの基本をカバーしたので、よりグローバルなビューを取り、XcodeがSwiftターゲット間の依存関係を使用してビルドから最大量の並列性を抽出する方法と、プロジェクトの構造と組織がビルド時間にどのように影響するかを探りましょう。

プロジェクトを構成するいくつかのレベルの階層がある可能性があります。

たとえば、ローカルライブラリのコレクションに応じて、アプリターゲットは、セマンティック境界に沿って、いくつかのフレームワークでターゲットに分割されます。

各ターゲットには、多くの異なるビルドフェーズとステップが含まれており、他のターゲットのビルドフェーズとの間でファイルの依存関係を生成および消費します。

プロジェクトのサイズが大きくなるにつれて、これらのタスクグラフはサイズと複雑さが増す傾向があります。

Xcodeビルドシステムはこれらの階層を平坦化しながら、すべてのターゲットの構築フェーズに対応するタスクの海にビルドを分解します。

Swiftターゲットにとって特別なタスクの1つは、コンパイルです。

Swiftターゲットのソースコードをバイナリ製品に構築することは、通常、ビルド計画、コンパイル、およびリンクのための多くのサブタスクで構成される複雑な操作です。

これらのタスクの調整は、Xcodeツールチェーンの専用ツールであるSwift Driverに委任されます。

ドライバーは、ターゲットのソースコードに必要なコンパイラとリンカーの呼び出しをいつ、どのように構築するかについての専門的な知識を持っています。

Swiftコードを含むターゲットは、コード配布の単位であるモジュールにも対応します。

このターゲットのパブリックインターフェイスをキャプチャするバイナリモジュールファイルは、ダウンストリームターゲットがコンパイルを開始するために必要なビルド製品です。

Swift Driverがターゲットの1つを構築するために何をするかの例を詳しく見てみましょう。

あなたのターゲットは、おそらくいくつかのソースファイルのコレクションで構成されています。

リリースまたは最適化されたビルドでは、ドライバーは最適化の機会を最大化するために、すべてのソースファイルを含む1つのコンパイラタスクをスケジュールします。

この単一のコンパイルタスクは、ターゲットのSwiftモジュールも生成します。

デバッグまたは増分コンパイルモードでは、Swift Driverは必要なコンパイル作業を並行して実行できる小さなサブタスクに分解し、そのうちのいくつかは増分ビルドで再実行する必要がない場合があります。

Swiftモジュールを作成するには、各コンパイルタスクの部分的な中間製品をマージするための追加のステップが必要です。

この例のように、ターゲット内のソースファイルの数が多い場合、ビルドシステムのヒューリスティックに従って、個々のファイルがバッチコンパイルサブタスクに割り当てられることもあります。

ビルドログは、どのソースファイルがバッチコンパイルジョブに割り当てられるかを強調表示し、各ファイルの診断に個別のエントリがあります。

ターゲットのビルドを異なるソースファイル間で並列化できることは、より高速で小規模な増分ビルドの両方にとって非常に重要ですので、デバッグビルドが増分コンパイルモード設定を使用していることを確認してください。

Xcode 14の前に、XcodeビルドシステムとSwiftドライバーの境界のために、ターゲットビルドフェーズのオーケストレーション、および各ターゲットのドライバーインスタンスによって生成されたコンパイルサブタスクは、互いに独立して発生し、各コンポーネントは利用可能なシステムリソースを最大限に活用するために最善を尽くしました。

この例では、グラフを構築し、お互いに関してコンパイルフェーズのスケジューリングに入るものを深く掘り下げてみましょう。

先に学んだように、Swiftのターゲット依存関係は、扶養家族に扶養家族のパブリックインターフェイスをキャプチャするバイナリモジュールファイルを提供させることによって解決されます。

これらの依存関係を解決すると、各ターゲットのトップレベルのSwift Driverタスクと個々のサブタスクを示すタイムラインでキャプチャされた次の順序につながります。

Xcode 14では、Swift Driverのまったく新しい実装（それ自体がSwiftで書かれている）のおかげで、ビルドシステムとコンパイラは完全に統合されています。

Xcodeビルドシステムは、コードをコンパイルするために実行する必要があるすべてのタスクの中央スケジューラとして機能します。

この中央計画メカニズムにより、Xcodeはきめ細かいスケジューリングの決定を行うことができ、プロジェクトの構築がCPUを過剰購読し、システム全体のパフォーマンスを低下させることなく、利用可能なリソースのみを使用することを保証します。

そして、以前はXcode Build Systemの範囲外のサブタスクの島のコレクションだったものが、現在は完全にビルドシステムのスケジューラのドメインにあります。

中央タスクプール内のすべての個々のサブタスクでは、ビルドスケジューラによって行われたトレードオフを考慮することが重要です。

たとえば、8コアマシンでは、スケジューラのデフォルトは、利用可能なタスク（依存関係が満たされ、準備ができているタスク）を8つの利用可能な実行スロットの1つに割り当てることです。

スロットの1つが解放されるとすぐに、ビルドシステムはより優れた作業でそれを埋めようとします。

より高いコアカウントのマシンでは、より多くの同時作業を実行できます。

しかし、それは、より多くの作業を実行するために利用可能なアイドルコアを持つ可能性が高いことを意味しますが、未処理のタスクはすべて、現在飛行中または待機している他のタスクによって生成されるように、まだ入力を待っています。

新しい統合ビルドシステムにより、スケジューラはこのアイドル時間を大幅に短縮できます。

方法を確認するために、コンパイル、バイナリモジュールファイルに対するターゲットの依存関係がどのように解決されるかを再検討しましょう。

先に説明したように、コンパイルサブタスクの部分的な結果は、ターゲットの最終モジュール製品にマージされます。

この製品が利用可能になると、ダウンストリームターゲットがコンパイルを開始する可能性があります。

Xcode 14とSwift 5.7の新機能で、ターゲットのモジュールの構築は、すべてのプログラムソースファイルから直接別のエミッタモジュールタスクで行われます。

これは、ターゲットの依存関係が、依存関係ターゲットの他のすべてのコンパイラタスクを待つことなく、エミトモジュールタスクが完了するとすぐにコンパイルを開始できることを意味します。

ダウンストリームターゲットコンパイルのブロックをはるかに早く解除できるため、アイドルCPUコアで利用可能な作業を待つ時間を短縮できます。これは、ビルドタイムラインのアクティビティの拍車の間の空きスペースです。

これをプロジェクトの残りの部分に拡張すると、同様の量の全体的な作業を行っていますが、ビルドシステムはコンピュータのリソースをより効率的に使用でき、多くの場合、ビルドを大幅に迅速に完了することができます。

次に、Swift-Eager Linkingを構築するときにビルドシステムが実行できる2番目のクロスターゲット最適化を見てみましょう。

前の例に基づいて、ビルドの重要なパスにある各ターゲットのリンカータスクを追加しました。

この場合、ターゲットBはターゲットAをリンクするため、ターゲットBのリンクタスクは、ターゲットAのリンク出力が生成され、独自のコンパイルタスクが完了してから実行されるのを待つ必要があります。

しかし、熱心なリンクでは、ターゲットBのリンクタスクは、代わりにターゲットAのエミトモジュールタスクに依存することができます。

その結果、ターゲットBはビルドの早い段階でリンクを開始し、ターゲットAをリンクしてクリティカルパスを短縮することと並行して実行できます。

これはどのように機能しますか?

通常、リンクされた製品依存関係を持つ2つのターゲットの依存関係グラフは次のようになります。

依存ターゲットをリンクするには、ターゲット独自のコンパイル出力に加えて、その依存関係のリンクされた製品が必要です。

熱心にリンクすると、この依存関係は壊れ、依存ターゲットが早期にリンクを開始できます。

依存関係のリンクされた生成物に依存するのではなく、エミッタモジュールタスクによってビルドプロセスの早い段階で生成されたテキストベースの動的ライブラリスタブに依存するようになりました。

このスタブには、扶養家族が使用するためにリンクされた製品に表示されるシンボルのリストが含まれています。

画面に表示されるXcodeビルド設定を使用して、この最適化を有効にできます。

Eager Linkingは、扶養家族によって動的にリンクされているすべての純粋なSwiftターゲットに適用されます。

要約すると、Xcodeビルドシステムは、ビルドフェーズを並行して実行することで、できるだけ多くの並列性を抽出しようとする洗練されたスケジューリングエンジンです。

また、スクリプトサンドボックスなどの機能により、ビルドが最大限に並列で信頼性が高いことを確認できます。

XcodeとSwiftはこれまで以上に統合されています。

そして、プロジェクト構造：そのモジュール化、ターゲット製品間の依存関係で構成されるグラフの全体的な形状、およびそれらの中のビルドフェーズの数と複雑さ、マシンの利用可能な計算リソースと組み合わせる - これらはすべて、Xcodeがビルドを並列化して高速化できる程度に寄与する要因です。

この知識とビルドタイムラインなどの強力な新しいツールを使用すると、プロジェクトを調査し、ビルドに関する洞察を得ることができます。

そして、舞台裏の技術的な詳細をさらに知りたい場合は、Xcodeで使用されている私たちが説明した技術の多くはオープンソースで開発されています。

以下のリンクで、GitHubでSwift Driverのリポジトリを見つけることができます。

Xcodeに関するより素晴らしいセッションについては、「Xcodeの新機能」で今年のすべての新機能と改善点をチェックしてください。

そして、Xcode 14のリンカーがセッション「リンク高速：ビルドと起動時間を改善する」でリンク時間を最大2回改善する方法を学びます。

フォローしてくれてありがとう。

Xcodeのビルドに関する新しい洞察を学んでいただければ幸いです。

あなたが何を作るのかを見るのが待ちきれません。

会議の素晴らしい残りをお過ごしください。