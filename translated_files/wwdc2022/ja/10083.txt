10083

♪ ♪

Vaibhav Gautam：こんにちは、私はVaibhav Gautamで、ソフトウェアパワーチームのエンジニアです。

アプリは、使用日を通してさまざまな重要な機能を提供するため、人々の生活を豊かにします。

しかし、この使用には、バッテリーの消耗というコストがかかる可能性があります。

したがって、ユーザーがデバイスとアプリをより長く使用できるように、アプリのバッテリー寿命を向上させるために特別な注意を払うことが重要です。

消費電力を理解するために、さまざまなシステムコンポーネントを深く研究しています。このセッションでは、アプリのバッテリー寿命を大幅に向上させるために実行できる、特定した4つの重要なアクションについて説明します。

これらは、アプリのダークモード、フレームレートの監査、バックグラウンド時間の制限、アプリの作業の延期です。

まず、ダークモードについて話します。

ダークモードはiOS 13で導入され、誰かがより暗いプレゼンテーションでデバイスを設定することができます。

ダークモードのパーソナライゼーションの利点に精通しているかもしれませんが、バッテリーの寿命にも劇的に影響する可能性があります。

これは、iPhone 13や13 ProなどのOLEDディスプレイを搭載したデバイスでは、暗いコンテンツが軽いコンテンツよりも消費電力が少ないためです。

OLEDスクリーンでは、各ピクセルは個々の電力を必要とし、暗い色の場合、ピクセルを照らすのに必要な電力は少なくなります。

システム内のすべてのコンポーネントの中で、ディスプレイは主要な消費電力源の1つです。

実際、一般的なユースケースでは、ディスプレイがバッテリーの消耗の主な要因になる可能性があります。

ディスプレイの消費電力に影響を与える方法があります。

そして1つの方法は、ダークモードを採用することです。

私のチームが取り組んでいるフードトラックアプリを例として使用します。

このアプリは、画面の大部分を占める非常に目立つ背景色を持っています。

ダークモードで表示すると、この背景色はライトモードバージョンよりもはるかに暗くなり、バッテリーの節約に大きく貢献します。

実際、このような場合、結果として最大70%のディスプレイ電力節約が予想されます。

これは大きな節約です!

そして、画面の明るさが高いと、バッテリーの節約はさらに高くなります。

ダークモードを好むユーザーにとって、これはバッテリーの消耗を節約する絶好の機会であり、熱負荷も減らすことができます。

ダークモードを採用するには、ダークモードが有効になっているときにアプリが現在どのように表示されるかを確認することから始めます。

システムUIによりよく適合するために、アプリのどのコンポーネントを更新する必要があるかを把握してください。

Xcodeは、アプリを構築するときに外観機能を使用することで、これを簡単にします。

あなたのアプリはライトモードのみをサポートしているため、色にハードコードされている可能性があります。

Xcodeで動的色を使用して、ライトモードとダークモードで背景色、画像、テキストをサポートします。

システムは自動的に正しい色の値を使用し、モードが変更されると更新されます。

アプリは、ライトモードとダークモードの代替画像もサポートする必要があります。

ダークモード用のアプリのカスタマイズの詳細については、WWDC 2019の「iOSでのダークモードの実装」をご覧ください。

アプリでダークモードを採用する方法がわかったので、ウェブコンテンツにダークモードを採用する方法も考える必要があります。

Safariはウェブコンテンツを自動暗くしないので、ウェブコンテンツにもダークモードを採用してください。

これを行うには、ウェブサイトのスタイルシートにカラースキームプロパティを実装します。

これにより、Webページのデフォルトのテキストと背景色が、現在のシステムの外観、標準フォームコントロール、およびスクロールバーに一致させることができます。

他の名前のシステムカラーは外観を変え、ライトモードとダークモードを切り替えます。

スタイルシートで色が参照されている場所ならどこでも、スタイルシート変数の使用を開始します。

これにより、デバイスがライトとダークを切り替えると、ウェブコンテンツの色を更新できます。

異なるモードごとに異なるバリアントを使用して、Webページ上の画像やその他のメディアアセットに同じロジックを適用します。

ウェブコンテンツにダークモードを実装する方法の詳細については、WWDC 2019の「ウェブコンテンツでダークモードをサポートする」を参照してください。

アプリの電力使用量を減らすもう1つの方法は、フレームレートを監査することです。

ProMotionディスプレイを搭載したデバイスでは、リフレッシュレートが消費電力に影響を与える可能性があります。

より高いリフレッシュレートは、より高い電力を使用します。

アプリ内のアニメーションのフレームレートは、ディスプレイのリフレッシュレートを決定します。

アプリ内のすべてのコンテンツが高フレームレートを必要とするわけではないため、アプリの主要なコンテンツと必要なフレームレートを考慮してください。

ディスプレイのリフレッシュレートは、アプリでフレームレートが最も高いアニメーションによって決まります。

アプリには、必要以上に高い速度で更新される二次要素があり、アプリ全体が予想よりも多くのバッテリーを消費する可能性があります。

ここに再びフードトラックアプリがあります。

上部の主要なトラックのシーンは、毎秒30フレームでレンダリングされています。

トラックの下には、水平にスクロールするテキストオーバーレイ「フードトラック」があります。

このセカンダリテキストは毎秒60フレームでレンダリングされています。

その結果、画面全体が毎秒60フレームでレンダリングされるようになりました。

テキストアニメーションを30fpsに変更すると、画面全体が30fpsでレンダリングでき、バッテリーの消耗を最大20%節約できます。

すごい！

デバッグし、アプリのフレームレートに関する詳細情報を取得するには、Instrumentsを使用してください。

CoreAnimation FPSインストゥルメントを使用して、時間の経過とともにアプリのフレームレートを示すタイムラインを表示します。

主なユーザーシナリオを監査することから始めます。

フレームが期待どおりにレンダリングされているかどうかを識別するには、画面上の二次要素がプライマリコンテンツよりも高いフレームレートを持っているかどうかを判断します。

アプリは、iOSのCoreAnimationが提供するCADisplayLinkを使用して、カスタムアニメーションとカスタムレンダリングループを推進している可能性があります。

CADisplayLinkは、ディスプレイのリフレッシュレートと同期したタイマーです。

カスタム図面がリフレッシュイベントを認識できるように、必要なタイミング情報をアプリに提供します。

アプリは、目的の画面のリフレッシュレートについてCADisplayLinkオブジェクトにヒントを与えることができます。

CADisplayLinkのpreferredFrameRateRangeを設定し、最小、最大、および優先フレームレートを指定します。

ディスプレイリンクは、システムが処理できるものに基づいて、好みのレートに最も近い利用可能なフレームレートを選択します。

そのレートを提供できない場合は、指定された範囲内にとどまろうとします。

表示リンクを設定するには、ターゲットとセレクタで初期化します。

提供されたセレクターは、カスタムアニメーションを実行し、次に表示するビデオフレームを計算するために使用されます。

表示リンクが初期化されたら、好みのフレームレート範囲を設定します。

この例では、優先レートは30ですが、範囲は10から60の間のものを処理できます。

最後に、現在の実行ループに表示リンクを追加します。

アプリのバッテリー消費量について考えるときは、リフレッシュレートを念頭に置いてください。

これは、非常にダイナミックなリフレッシュレートをサポートするProMotionディスプレイを搭載したデバイスにとって特に重要です。

Instrumentsでアプリのフレームレートを監視し、アプリをリリースする前に問題を検出します。

最後に、CADisplayLinkを使用してアプリのコンテンツのリフレッシュレートを制限して、システムに情報を提供します。

フレームレートの最適化の詳細については、WWDC 2021の「可変リフレッシュレート表示の最適化」を参照してください。

では、バックグラウンドで実行されているときにアプリの電源をダウンする方法について話しましょう。

誰かがあなたのアプリから別のアプリに切り替えると、あなたのアプリはバックグラウンドで実行し続けるためにバックグラウンド実行APIに依存するかもしれません。

バックグラウンドで実行している間、アプリは位置情報やオーディオなどの一般的なサービスを引き続き使用する可能性があります。

これらのサービスを長時間実行するとバッテリーが消耗するので、アプリがバックグラウンドでこれらのサービスを使用している場合は、特に注意する必要があります!

それでは、これらのモードを使用するときに余分なドレインを回避する方法について話しましょう。ロケーションサービスは、デバイスをスリープ状態に保ち、場所を継続的にストリーミングします。

アプリはユーザーには見えませんが、バックグラウンドで場所を継続的にストリーミングし、余分なバッテリー消耗を引き起こす可能性があります。

アプリのバックグラウンドロケーションセッションランタイムの上にいることを確認することが重要です。

セッションが不要になった場合は、アプリがstopUpdatingLocation()を呼び出してセッションを停止することを確認してください。

アプリ開発のさまざまな段階では、さまざまなツールを使用して、期待できない背景の場所の使用状況を調べることができます。

アプリの構築とテスト中に、Xcodeゲージを使用して、システムのエネルギー使用量とバックグラウンドの場所の使用状況を調べることができます。

リリース前にアプリをテストするときは、MetricKitを使用して、使用日の診断情報を収集できます。

iOS 16の新機能は、コントロールセンターでの場所の使用です。

Xcodeゲージは、CPU、ネットワーク、ロケーションの使用状況などのシステム使用状況に関する情報を提供します。

Xcodeゲージは、アプリの場所の使用状況とエネルギーへの影響のタイムラインを表示します。

このタイムラインビューを見ることは、停止が予想されるときに場所のランタイムが停止することを確認するのに最適な方法です。

もう1つのツールは、アプリをテストするときにMetric Kitを使用することです。

cumulativeBackgroundLocationTimeプロパティを使用して、アプリがバックグラウンドで位置情報サービスを積極的に使用していた期間を調べます。

iOS 16の新機能で、ユーザーはコントロールセンターに移動することで、現在位置情報サービスを使用しているアプリを監視できます。

上部のテキストをタップすると、位置情報を使用してアプリを詳細に表示できます。

これを使用して、ロケーションランタイムに関するデスクからの洞察を得ることができます。

ここにアプリが表示され、予期しない場合は、アプリにアクティブなロケーションストリーミングセッションがあることを示す指標です。

オーディオセッションにも同じ原則を適用できます。

オーディオプレーヤーを使用してファイルを再生し、ユーザーが再生を停止する音楽アプリがあるとしましょう。

アプリはサウンドを一時停止または停止するだけでなく、アイドル状態の実行を防ぐためにオーディオエンジンを一時停止または停止する必要があります。

AVAudioEngineクラスのautoShutdownEnabledプロパティを設定することで有効にできる自動シャットダウンモードを使用することをお勧めします。

このモードでは、オーディオエンジンは一定期間アイドル状態かどうかを継続的に監視し、検出します。

アイドル状態になると、エンジンはオーディオハードウェアをシャットダウンします。

そして後で、いずれかのソースが再びアクティブになると、オーディオハードウェアが動的に起動します。

そして、これはすべてボンネットの下で起こります。

watchOSの自動シャットダウンモードは強制的な動作です。

電力を節約するために、使用していないときはオーディオエンジンを必ず停止してください。

バックグラウンドランタイムを制限する鍵は、完了したらシステムに伝えることを覚えておくことです。

バッテリー寿命を改善するために取ることができる最後の行動は、作業を延期することです。

一日を通して、あなたのアプリは多くの異なるタスクやデータを処理するかもしれません。

この作業の一部は、画面上のコンテンツのレンダリングや、ユーザーがタップするオーディオやビデオの再生など、ユーザーのアクションにサービスを提供するためにすぐに行う必要があります。

機械学習タスク、分析のアップロード、バックアップなどの他の作業は、それほど時間に敏感ではありません。

この時間の無神経な作業を、デバイスが充電されているときに、より良い時間に延期すると、バッテリーを節約し、ユーザーが開始したインタラクティブな作業と競合することを避けることができます。

これを達成するために使用できる3つのAPIについて話しましょう。

BGProcessingTaskは、長時間実行されるタスクを延期するのに良い選択です。

裁量的なURLSessionは、遅延可能なネットワーキングをスケジュールするのに最適です。

また、適切なプッシュ優先度を活用することで、サーバーが適切なタイミングでプッシュを配信するのに役立ちます。

それぞれについて詳しく説明しましょう。

まずはBGProcessingTaskです。

BGProcessingTaskを使用すると、デバイスが充電されているときなど、長時間の処理タスクをより良い時間に延期できます。

データベースのクリーンアップ、バックアップの作成、機械学習トレーニングの実行などのタスクに最適です。

それを使用するには、BGProcessingTaskRequest APIを使用してリクエストを作成し、アプリケーション識別子を提供するだけです。

次に、タスクに外部電源やネットワークが必要かどうかなど、詳細情報を提供します。

より多くの情報を提供することは、システムがより良い時間枠でタスクをスケジュールするのに役立ちます。

その後、システムは適切なタイミングでバックグラウンドでアプリを起動し、遅延作業を完了するために数分のランタイムを許可します。

次は裁量URLSessionです。

あなたのアプリはすでに一般的なネットワーキングにバックグラウンドURLSessionsを使用している可能性があります。

バックグラウンドURLセッションは、裁量フラグを使用するとさらに良くなります。

裁量フラグ付きのURLSessionsは、デバイスが接続されてWi-Fiに接続されている場合など、より最適なタイミングでネットワーキングを実行するためにシステムにオフロードされたネットワークトランザクションです。

裁量フラグは、テレメトリの収集やテレビ番組の次のエピソードのダウンロードなど、非ユーザーが開始した長時間のネットワーキングに最適です。

また、ネットワークがオフロードされたため、ネットワークトランザクションが完了している間にアプリを実行する必要がないことを意味します。

裁量URLセッションを使用するには、バックグラウンドURLセッションを設定し、isDiscretionaryをtrueに設定するだけです。

システムが適切なタイミングでダウンロードをスケジュールするのに役立つ追加情報を提供できます。

システムが永遠にダウンロードしようとしないようにタイムアウト間隔を渡し、バッテリーの消耗を引き起こします。

後でどこかの時点までデータをアップロードまたはダウンロードしたくない場合は、最も早い開始日を渡してください。

最後に、システムがさまざまなダウンロードタスク間でインテリジェントにロードバランスできるように、予想されるワークロードサイズを渡します。

BGProcessingTaskと裁量URLセッションで特定の操作の即時性を制御する方法と同様に、異なるプッシュ優先順位を使用することで、プッシュ配信の即時性に影響を与えることができます。

プッシュの優先順位は、プッシュをデバイスにどれだけ緊急に配信する必要があるかを決定します。

優先度の高いプッシュの場合、サーバーはすぐにプッシュをデバイスに送信し、デバイスをスリープ解除してバッテリーの消耗を引き起こす可能性があります。

低優先度プッシュの場合、サーバーは、デバイスが起動しているときや優先度の高いプッシュが通過するなど、適切な時間までプッシュの送信を遅らせます。

優先度の高いプッシュは、厳しい気象警報のような緊急のメッセージに最適です。

優先順位の低いプッシュは、緊急ではなく、延期できるより受動的な通知に最適です。

優先度の低いプッシュを活用して、遅延メッセージの配信を遅らせると、デバイスが頻繁にスリープ状態から目を覚ます必要がないため、バッテリーを節約できます。

低優先度のプッシュを設定するには、プッシュペイロードでapns-priorityを5に設定するだけです。

サーバーが残りを処理し、ユーザーはバッテリー寿命の節約に感謝するでしょう。

それでは、いくつかの最終的な考えと次のステップで締めくくりましょう。

アプリでダークモードのオプションを提供します。

ユーザーがダークモードを選択した場合、意図を尊重することでバッテリーを節約できます。

アニメーションを見直し、フレームレートを必要なものに減らす機会を探してください。

1つの小さなアニメーションが大きな影響を与える可能性があります。

完了したらシステムに知らせることで、バックグラウンドランタイムを注意深く監視してください。

最後に、デバイスが充電器に接続されている場合など、長時間のバックグラウンド作業をより良い時間に延期することを検討してください。

これらすべてを行うと、本当にアプリの電源が切れます。

どうもありがとうございます。