10068

♪インストゥルメンタルヒップホップ音楽♪

- iOS 16の「UIKitの新機能」へようこそ。

私はDimaで、UIKitチームのエンジニアリングマネージャーです。

UIKitは、アプリの中核となる強力なフレームワークです。

iOS 16の新機能をサポートするために更新されました。

このビデオでは、生産性、コントロールの強化、APIの改良のためのUIの改善を取り上げ、UIKitとSwiftUIを一緒に使用するエキサイティングな新しい方法について話します。

UIKitでは、新しいタイトルメニュー、検索と置換、カット、コピー、ペーストの編集インタラクションを再考した改良されたナビゲーションバーを備えた、合理化された検出可能なユーザーインターフェイスの開発をさらに簡単にしました。

ドキュメントベースのアプリケーションを強化できます。

まず、デスクトップクラスのツールバー機能をサポートするように更新されたナビゲーションバーを詳しく見ていきます。

iOS 16では、UIKitは、ドキュメントベースのアプリのニーズをよりよくサポートするために、ブラウザとエディタの2つの新しいナビゲーションスタイルを導入しています。

ブラウザスタイルは、ウェブやドキュメントブラウザなど、ナビゲーションに履歴やフォルダ構造を使用するアプリ向けに設計されています。

エディタは、ドキュメントの編集を中心としたインターフェイスを対象としています。

iOS 16では、さまざまなバーボタンアイテムをアプリに追加でき、そのサブセットがナビゲーションバーの中央に表示されます。

メニューの「ツールバーのカスタマイズ」エントリをタップすると、アイテムのポップアップとの間でドラッグしてアイテムを並べ替えることができます。

結果として生じる新しい設定は、アプリの起動中も持続します。

サイズ変更に対応するために、たとえば、別のアプリでサイドバイサイドモードに入ると、システムは自動的にオーバーフローメニューを提供し、合わないアイテムにアクセスします。

新しいナビゲーションスタイルで動作し、複製、移動、名前変更、エクスポート、印刷など、いくつかの標準機能をサポートするタイトルメニューを追加しました。

これらは、対応するデリゲートメソッドが実装されると、自動的にメニューに表示されます。

タイトルメニューに完全にカスタムアイテムを追加することも可能です。

さらに、Mac Catalystで構築されたアプリは、追加のコードを必要とせず、NSToolbarとシームレスに統合することで、改良されたナビゲーションバーを活用します。

iOS 16では、さまざまなアプリで一貫してテキストを操作する新しい方法が導入されています。

1つ目は、新しい発見と置換です。

概念的には、写真やカレンダーイベントなどのデータモデルオブジェクトで動作する、より高レベルのアプリ内検索とは異なります。

代わりに、検索と置換はテキストで動作するように意図的に構築されています。

UITextViewやWKWebViewなどの組み込みUIKitビューの機能をアクティブにするには、フラグを設定するだけです。

さらに、このシステムを選択した複数のビューやドキュメントでシームレスに機能します。

次に、編集メニューが大幅にアップグレードされました。

今では、使用される入力方法によって異なって見えます。

タッチインタラクションでは、よりインタラクティブな再設計されたメニューが表示されます。

ポインタを使用すると、よりフル機能のコンテキストメニューが表示されます。

これらの両方のエクスペリエンスをシームレスな方法で提供するために、現在非推奨のUIMenuControllerの完全な代替品としてUIEditMenuInteractionを導入しました。

テキストビューのメニューにアクションを挿入する新しいAPIもあります。

「デスクトップクラスの編集インタラクションを採用する」を見て、新しい編集メニューのすべての詳細を学び、カスタムビューの検索インタラクションを採用する方法を学びます。

カバーしたいビジュアルUIアップデートが1つあります。

iOS 16では、スライドオーバーモードのサイドバーは、追加のコードなしで自動的に鮮やかになります。

これを達成するために、UIKitはあなたに代わって一連のプライベートビューを管理します。

これらは、UIKitの新しい生産性機能です。新しいカスタマイズ可能なナビゲーションバー、検索と置換、インタラクションの編集、強力なタイトルメニューです。

私はここで表面を引っ掻いているだけです。

さらに多くのことを学ぶには、「Meet desktop class iPad」セッションと、iOS 16の新しい高度なUIKit機能を備えたサンプルアプリの改善について、より詳細な「デスクトップクラスのiPadアプリを構築する」を確認してください。

次に、追加した2つの新しいコントロールを紹介し、UIPageControlの機能強化について説明します。

UIDatePickerのインラインカレンダースタイルは、UICalendarViewの形で、スタンドアロンのフル機能コンポーネントとして利用可能になりました。

UICalendarViewは、オプションの単一の日付や複数の日付の選択など、さまざまな種類の選択動作をサポートしています。

利用可能な日付範囲に加えて、選択から個々の日付を無効にすることもサポートしています。

さらに、個々の日付に装飾で注釈を付けることができます。

UICalendarViewとUIDatePickerの主な違いの1つは、UICalendarViewが日付をNSDateではなくNSDateComponentsとして表していることです。

NSDateとは異なり、日付コンポーネントは日付のより良く、より正しい表現ですが、NSDateは時点の表現です。

NSDateComponentsは多くの柔軟性を提供するため、コンポーネントがどのNSCalendarで表されるかを非常に明確にする必要があります。

現在のカレンダーの種類について仮定すべきではないことに注意してください。

カレンダーをグレゴリオ暦にする必要がある場合は、グレゴリオ暦を明示的に指定してください。

先に示したようなカレンダービューを設定するには、まずカレンダービューを作成し、そのデリゲートを設定します。

カレンダーがグレゴリアンNSCalendarによってバックアップされていることを確認するには、calenalViewのカレンダープロパティをグレゴリアンNSCalendarに設定します。

次に、マルチ日付の選択を設定します。

UICalendarSelectionMultiDateオブジェクトを作成し、選択オブジェクトの選択した日付プロパティを、カレンダービューに表示するデータモデルから既存の日付に設定します。

次に、選択オブジェクトをカレンダービューの選択動作に設定します。

カレンダーで個々の日付の選択を防ぐために、カレンダーの選択のデリゲートからmultiDateSelection:canSelectDate:メソッドを実装して、どの日付を選択できるかを制御します。

選択できない日付は、カレンダービューでグレー表示になります。

個々の日付に装飾で注釈を付けるには、カレンダーデリゲートのcalendarView:decorationForDateComponents:メソッドを実装します。

装飾が無の場合は、単にゼロを返します。

デフォルトの灰色の円の場合は、デフォルトの装飾を返します。

また、色をカスタマイズするオプションを使用して、画像の装飾を作成することもできます。

さらに必要な場合は、customViewデコレーションを使用して、ビュープロバイダーにビューを返します。

カスタムビューの装飾はインタラクションを許可せず、利用可能なスペースにクリップされることに注意してください。

ページコントロールも改善されました。

現在のページのカスタムインジケーター画像のサポートを追加したので、ページが選択されているかどうかに応じて異なる画像を選択できるようになりました。

これで、ページコントロールの向きと方向の両方を完全にカスタマイズすることもできます。

以下は、現在のページと非現在のページの間でインジケータが変化する垂直ページコントロールを設定する例です。

ページコントロールの方向を上から下に設定し、優先インジケーター画像と優先現在のインジケーター画像を設定しました。それだけです!

Appleは、ユーザーのプライバシーとセキュリティを保護することにコミットしています。

iOS 15では、システムが提供するペーストインターフェイスを使用せずにアプリケーションがプログラムでペーストボードにアクセスすると、ペーストボードがアクセスされたことを示すバナーが表示されます。

iOS 16の新機能により、システムの動作が変わりました。

次に、バナーの代わりに、ペーストボードを使用する許可を求めるアラートを表示します。

ユーザーが対話するシステムペーストインターフェイスは、ペーストボードへの暗黙のアクセスを提供し、アラートを回避します。

カスタムペーストコントロールがある場合は、塗りつぶされたUIButtonのように見え、動作する新しいUIPasteControlに置き換えることができます。

ペーストボードがコントロールの貼り付けターゲットと互換性のあるコンテンツを取得するたびに有効になります。

したがって、これらは新しい強力なUICalendarView、改良されたUIPageControl、およびセキュリティ指向のUIPasteControlです。

さあ、それらを試してみてください。

それでは、私たちが行ったいくつかのAPIの改良をご案内します。

iOS 15では、柔軟でダイナミックなUIの構築を可能にするシートにデテントが追加されました。

iOS 16では、任意のサイズのシートを作成できるように、カスタムディテントのサポートを追加しました。

この機能を利用するには、新しい「.custom」デテントを使用し、シートの高さを関連するブロックのポイントで指定します。

一定の値、または最大ディテント高さのパーセンテージを返すことができます。

また、カスタムディテントの上の調光を無効にするなど、他のAPIから参照する必要がある場合は、カスタムディテントに識別子を与えることもできます。

カスタムブロックから返す値は、ボトムセーフエリアインセットを考慮に入れるべきではないことに注意してください。

これは、フローティングシートとエッジアタッチシートの両方で同じ計算が機能します。

システムデテントやその他のオプションを使用したシートのカスタマイズの詳細については、UIKitビデオのシートのカスタマイズとサイズ変更をご覧ください。

そのビデオのサンプルコードも更新され、これらの新しいカスタムディテントAPIが表示されます。

UIKitにはSFシンボルの新機能があります。

シンボルは、モノクロ、マルチカラー、階層、パレットの4つのレンダリングモードをサポートしています。

UIKitは、シンボルが異なるレンダリングモードで設定されていない限り、デフォルトでモノクロレンダリングを使用します。

iOS 16では、レンダリングモードが指定されていない場合、UIKitはモノクロ以外のモードで個々のシンボルをレンダリングすることがあります。

例えば、これらのデバイスシンボルを見てみましょう。

iOS 15以前では、レンダリングモードが指定されていない場合、これらのシンボルはモノクロレンダリングを使用します。

iOS 16では、これらのシンボルは代わりに階層的なレンダリングにデフォルト設定されています。

一般的に、シンボルのデフォルトのレンダリングモードは、シンボルを表示するための好ましい方法です。

したがって、この場合、デフォルトの階層レンダリングを有効にする必要があります。

ただし、モノクロレンダリングは、新しいUIImage.SymbolConfiguration. preferringMonochrome() APIで明示的に要求できます。

UIKitは、アプリが0から1までの値に基づいてシンボルのバリエーションを表示できるように、可変シンボルのサポートを追加しました。

アプリが現在の音量レベルをシンボルで描写したいとします。

このアプリは、可変レンダリングをサポートするように更新されたspeaker.3.wave.fillシンボルを使用できます。

0の値で、スピーカーの波はフェードアウトされ、最も低い音量レベルを示します。

値が最大1まで増加すると、スピーカーの波は徐々に塗りつぶし、より高い音量レベルを示します。

シンボルが変数レンダリングをサポートしている場合、アプリは0から1の間の値を反映したシンボルのバージョンを要求できます。

可変記号を使うのは簡単です。

UIImageの標準SFシンボルAPIを使用して、シンボルの通常の非変数バージョンを取得できます。

特定の変数値を持つそのシンボルのバージョンを取得するには、variableValueパラメータを追加するだけです。

可変レンダリングをパレットなどの他のレンダリングモードと混在させることで、シンボルのスタイルをさらに高めることができます。

多くのシステムシンボルは現在、変数レンダリングをサポートしており、アプリはカスタムシンボルを更新して変動性もサポートできます。

カスタム変数シンボルの作成方法を学ぶには、「SFシンボルで可変色を採用」と「SFシンボル4の新機能」のセッションをチェックしてください。

UIImageやUIColorなどの不変型をSendableに準拠させるなど、新しいSwift並行性機能で動作するようにUIKitを近代化したので、コンパイラの警告なしにMainActorとカスタムアクターの間で送信できます。

たとえば、ここにはProcessorというカスタムアクターと、MainActorにバインドされているImageViewerというビューコントローラーがあります。

sendImageForProcessingメソッドでは、ImageViewerは処理のためにプロセッサアクターに画像を送信し、キラキラと虹を追加するようにファンシーにします。

UIImageは不変であるため、これは安全であるため、プロセッサは虹とキラキラを追加するために新しいコピーを作成する必要があります。

元の画像への参照を持つコードは、これらの変更を表示せず、共有状態は安全でない変異ではありません。

これをUIBezierPathと対比してください。UIBezierPathは変更可能であるため、送信できません。

以前はドキュメントでしか表現できなかったものが、コンパイラでチェックできるようになったのは、どれほどクールですか?

SendableとSwiftの並行性の詳細については、「Swift並行性を使用してデータレースを排除する」と「Swift並行性の視覚化と最適化」のビデオをご覧ください。

iOS 16は、外部ディスプレイの新しい強力なサポートを備えています。

素晴らしいニュースは、古いUIScreen APIを使用していない限り、これを利用するためにアプリを更新する必要がないことです。

アプリがメイン画面に表示されていると仮定できなくなりました。

代わりに、トレイトコレクションやUIScene APIなど、より具体的なAPIを参照して、必要な情報を入手してください。

アプリがまだUISceneを使用していない場合は、アップグレードして複数のウィンドウをサポートする理由がさらに増えます。

UICollectionViewとUITableViewのセルフサイジングセルが大幅にアップグレードされました。

今、細胞も自己サイズ変更しています!

iOS 16では、可視セル内のコンテンツが変更されると、新しいコンテンツに合わせてセルのサイズが自動的に変更されます。

この新しい動作はデフォルトで有効になっており、UICollectionViewとUITableViewにはそれぞれ新しいselfSizingInvalidationプロパティがあり、この新しい機能を制御できます。

仕組みは次のとおりです。selfSizingInvalidationが有効になっている場合、セルは包含コレクションまたはテーブルビューによってサイズ変更を要求できます。

UIListContentConfigurationを使用してセルを設定する場合、セルの設定が変更されるたびに無効化が自動的に行われます。

それ以外の場合は、セルまたはその contentView で invalidateIntrinsicContentSize メソッドを呼び出して、セルのサイズを変更できます。

デフォルトでは、セルはアニメーションでサイズ変更されますが、performWithoutAnimation内でindinateIntrinsicContentSizeの呼び出しをラップして、アニメーションなしでサイズを変更することができます。

UICollectionViewとUITableViewは、最適なタイミングで実行された単一の更新に、セルからのサイズ無効化をインテリジェントに結合します。

セルで自動レイアウトを使用している場合は、enabledIncludingConstraintsを選択することで、さらに包括的な動作にオプトインできます。

つまり、セルがcontentView内の自動レイアウト変更を検出すると、自動的にinvalidateIntrinsicContentSizeを呼び出すため、含まれているコレクションまたはテーブルビューは必要に応じてサイズを変更できます。

これにより、コンテンツやレイアウトの更新に応じて自動的にサイズを調整するセルを持つことが非常に簡単になります。

UIKitはパワフルで柔軟です。

また、SwiftUIを使用してUIを実装する表現力を活用することもできます。

両方のフレームワークを同じアプリに組み込むことがはるかに簡単になりました。

iOS 16では、SwiftUIを使用してコレクションとテーブルビューのセルを構築するまったく新しい方法があります。

これは、UIHostingConfigurationという名前の新しいコンテンツ構成タイプによって可能になります。

たった1行のコードで、セル内でSwiftUIを書き始めることができます。余分なビューやビューコントローラーはまったく必要ありません。

これは、UIHostingConfigurationを使用してSwiftUIで書かれたシンプルなカスタムセルです。

このセルを構築するのは非常に簡単です。

これは、SwiftUIをアプリに統合し始めるのに最適な方法であるだけでなく、SwiftUIの表現力豊かな性質は、UIKitでカスタムセルを構築するためのこれほど強力な方法がなかったことを意味します。

このトピックにはもっと多くのことがあるので、ビデオ「UIKitでSwiftUIを使用する」を必ずチェックしてください。

注意すべき小さな、しかし重要な変更がいくつかあります。

ユーザーがフィンガープリントされるのを防ぐために、UIDevice.nameはユーザーのカスタムデバイス名ではなくモデル名を報告するようになりました。

カスタマイズされた名前を使用するには、資格を取得する必要があります。

UIDevice.orientationの設定はサポートされなくなりました。

代わりに、preferredInterfaceOrientationなどのUIViewController APIを使用して、インターフェイスの意図した向きを表現します。

次は何ですか?

iOS 16 SDKを使用してアプリをコンパイルします。

テキスト編集メニューや検索と置換などの新機能をテストします。

新しいUIKit APIを採用して、新しい強化されたコントロールと生産性機能を使用します。

そして、UIKitアプリにSwiftUIを組み込む新しいエキサイティングな方法を試してみてください。

ありがとうございます。♪ ♪