10121

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

こんにちは、私はiOSシステムエクスペリエンスチームのエンジニアであるテジャです。このセッションでは、フォーカスフィルターを満たすことができます。

フォーカスはiOS 15、macOS Monterey、watchOS 8で導入されました。

これは、システム動作を一定期間設定することで、人々が重要なことに集中する方法です。

フォーカスは、コントロールセンターに入り、システムフォーカスまたはカスタムフォーカスのいずれかから選択するだけで有効になります。

フォーカスが有効になっている間は、通知の動作をカスタマイズできます。

たとえば、ワークフォーカス中、誰かが同僚からの通知のみを許可するか、仕事に関連する選択したいくつかのアプリの通知のみを許可する場合があります。

フォーカスごとに、システムの動作を設定および設定でスケジュールできます。

iOS 16とmacOS Venturaは、フォーカスフィルターでフォーカス機能を強化します。

まず、フォーカスフィルターとその振る舞いを紹介します。

次に、アプリでフォーカスフィルターを定義する方法について説明します。

その後、フォーカスフィルターで行動することの意味について説明します。

そして最後に、あなたのアプリがシステムに追加のコンテキストを提供する方法について説明します。

フォーカスフィルターは、現在有効になっているフォーカスに基づいてアプリの動作をカスタマイズする方法です。

フォーカスフィルターを採用したシステムアプリの素晴らしい例がいくつかあります。

カレンダーアプリを使用すると、フォーカスが有効になっているときにデフォルトで表示するカレンダーをフィルタリングできます。

これが私のカレンダーの通常の姿です。

そして、ご覧のとおり、私は仕事と個人的なカレンダーイベントが混在しています。

パーソナルフォーカス中にカレンダーのフォーカスフィルターを設定して、個人のカレンダーのみを表示できます。

フォーカスフィルターを設定した後、これが私のカレンダーの様子です。

カレンダーは、これがフォーカスでフィルタリングされていることを示し、フィルタリングを切り替える方法を提供しました。

今、私は個人的な時間を楽しもうとして、仕事のカレンダーに圧倒されることはありません。

メールアプリの受信トレイは、フォーカス中に関連するメールボックスのみを表示するようにフィルタリングできます。

メール通知もフィルタリングされ、関連する通知のみが目立つように表示されます。

これは、ワークフォーカス中に仕事関連のメール通知のみを配信し、個人的なメール通知が私を中断するのを防ぐようにメールを設定することができることを意味します。

アプリがフォーカスフィルターを実装したい理由はたくさんあります。

おそらく、あなたのアプリは複数のアカウントを管理しており、フォーカスを特定のアカウントに関連付けるのが適切です。

大量のデータを持つアプリは、フォーカスのためにコンテンツをフィルタリングする必要があるかもしれません。

ユーザーが集中している間に気を散らさないようにしたい場合は、バッジ数、アプリ内アラート、および有効なフォーカスにとって顕著なものへの通知を減らすことによってこれを行うことができます。

外観に関しては、アプリは有効なフォーカスに基づいてテーマやレイアウトを表示したい場合があります。

基本的に、アプリがコンテキストに基づいて異なるコンテンツを表示できる場合は、フォーカスフィルターを使用してユーザーエクスペリエンスを強化できる場合があります。

フォーカスフィルターの仕組みを説明しましょう。

アプリは、フォーカスごとにユーザーがカスタマイズできるものを定義し、これはAppIntentを使用して行われます。

システムは、フォーカスごとに設定できるものを公開します。

AppIntentで定義されたプロパティを設定するUIは、フォーカス設定でフォーカスフィルターとして公開されます。

ユーザーは、フォーカス設定に移動し、アプリのフォーカスフィルターを設定することで、特定の方法で動作するようにアプリを設定できます。

では、フォーカスフィルターをコードベースに組み込む方法について説明します。

フォーカスフィルターを定義するにはいくつかの部分があります。

1つ目は、SetFocusFilterIntentの実装です。

これは、アプリがフォーカスごとにカスタム設定を持つことに興味を持っていることをシステムに示します。

2番目のステップは、アプリのパラメータを定義することです。

これらは、ユーザーがアプリ内で設定できるものを表します。

最後のステップは、フォーカスフィルターが正しいコンテンツでシステム設定に表示されるように、表示表現を設定することです。

このようにして、ユーザーは何が設定されているかを認識できます。

私はいくつかのコードに飛び込みます。

最初にする必要があるのは、AppIntentsをインポートし、SetFocusFilterIntentを実装する構造体を定義することです。

これがあなたのフォーカスフィルターです。

タイトルと説明を設定すると、ユーザーがあなたのフォーカスが何であるかを発見するのに役立ちます。

フォーカスフィルターは、設定のグリッドビューに表示されます。

フォーカスフィルターが設定される前に、この外観でユーザーに表面化されます。

ここのアイコンはアプリのアイコンで、プライマリテキストはアプリの名前で、セカンダリテキストはフォーカスフィルターで設定したタイトル変数と一致します。

ユーザーがタップしてフィルターを設定すると、同じコンテンツが表示されます。

今回は、追加のコンテキストのために、あなたが提供した説明文字列も含まれています。

タイトルと説明の文字列はどちらも静的であり、アプリがインストールされた時点でシステムによって読み取られます。

フォーカスフィルターを定義するときは、パラメータとして装飾された一連のプロパティを提供することで、人がカスタマイズできるものを指定する必要があります。

パラメータを指定するときは、名前とデータ型を指定する必要があります。

パラメータは、Bool、string、floatなどの標準データ型にすることができます。

設定したいカスタムデータ型がある場合は、それをエンティティにすることができ、パラメータとして飾ることができます。

エンティティとアプリインテントの詳細については、「アプリインテントに飛び込む」セッションをご覧ください。

フォーカスフィルターを定義するときは、各パラメータのデータ型と名前のみを指定します。

各フォーカス中に適用されるパラメータの値を設定するのはユーザー次第です。

パラメータはオプションとしてマークできるため、設定する必要はありません。

オプションではないパラメータは、デフォルト値を指定する必要があります。

コードでは、フォーカスフィルターで必要なタイプの変数を定義し、パラメータとして装飾することで、パラメータまたはオプションのパラメータを指定します。

ここでは、フォーカスフィルターが常にダークモードを使用するかどうかを表す必要なブールパラメータを作成しました。

デフォルトをfalseに設定しました。

また、このフォーカス中にユーザーのステータスメッセージを表すオプションの文字列パラメータも作成しました。

最後に、私のアプリによって定義されたエンティティであるオプションのアカウントパラメータを含めました。特定のアカウントに関する情報が含まれています。

これら3つのパラメータすべてに設定されているタイトルは、ユーザーにパラメータを記述するために設定に表示されます。

フォーカス設定では、ユーザーがアプリのフォーカスフィルターを設定すると、先ほど示したものと同様のグリッドで表示されます。

しかし、今回は、フィルターがすでに設定されているため、構成されたものを反映するためにコンテンツは動的です。

ここのアイコンはまだあなたのアプリのアイコンです。

プライマリテキストとセカンダリテキストは、FocusFilterIntentの表示表現プロパティを使用してカスタマイズできます。

プライマリテキストは、アカウントの選択、ステータスの設定など、設定されたパラメータを表す必要があります。

セカンダリテキストは、ワークアカウントやワーキングなど、パラメータが何に設定されているかを表す必要があります。

私のコードでは、表示表現を動的に生成するように設定しました。

アカウントとステータスはオプションのパラメータであるため、実際に設定されている場合にのみ、動的なプライマリテキストとセカンダリテキストに含まれます。

alwaysUseDarkModeは必須のパラメータであるため、常にプライマリテキストとセカンダリテキストに含まれています。

さて、フォーカスフィルターを定義したので、ユーザーはフォーカス設定に移動し、特定のフォーカスの特定の値をカスタマイズできます。

しかし、あなたのアプリは誰かがカスタマイズしたものをどうやって知ることができますか?

そして、あなたのアプリはどのようにそれに応じて自分自身を更新できますか?

システムからの変更に対して行動しなければならない。

フォーカスの変更が発生し、システムがアプリがこの変更について知ることが重要であると判断した場合、2つの方法のいずれかでこの情報を配信します。

アプリが実行されている場合、それを実装している場合は、FocusFilterIntentでperformメソッドへの呼び出しを受け取ります。

アプリが実行されていない場合は、スピンアップする拡張機能を実装できます。

繰り返しますが、FocusFilterIntentで実行を実装している場合は、拡張機能で呼び出されます。

実行はアプリまたは拡張機能のいずれかで呼び出される可能性があるため、すべてのアプリが拡張機能を必要とするわけではありません。

通常、アプリがフォーカス遷移に応答して独自のビューを更新している場合は、アプリ内だけでパフォーマンスを実装するだけで十分です。

アプリのウィジェット、通知、またはバッジをフォーカスの移行に基づいて変更する必要がある場合は、拡張機能の実装を検討することをお勧めします。

基本的に、アプリが独自のビュー以外のものを更新したい場合は、拡張機能を実装する必要があります。

このセッションの残りの部分では、「あなたのアプリ」を参照するかもしれませんが、このコンテキストに応じて、アプリまたは拡張機能のいずれかを意味する場合があります。

フォーカスフィルターに応答するには、実行機能を実装し、設定を介して提供されたパラメータの入力された値にアクセスし、これらの値を使用してアプリのビューと動作を更新します。

実行の実装は、システムがアプリがフォーカス遷移に応答する必要があると判断したときに呼び出されます。

実行は、システムが以前に配信された値がもはや関連性がないと判断したときに呼び出されます。

この場合、フォーカスフィルターパラメータはデフォルト値で設定されます。

アプリのフォーカスフィルターで実行が呼び出されると、設定で設定されたものと一致するように、すべてのパラメータの値が入力されます。

名前付きパラメータの値は、self.「パラメータの名前」を呼び出すことで読み取ることができます。

この例では、実行の最後に、受信したデータでアプリを更新します。

場合によっては、現在のフォーカスフィルターパラメータを照会する必要があるかもしれません。

私の場合、私のフィルターはExampleChatAppFocusFilterと呼ばれているので、ExampleChatAppFocus Filter.currentにアクセスします。

アプリがフォーカスフィルターで機能できるようになったので、次のステップは、アプリの動作がどのようにシステムに戻ったかについて追加のコンテキストを提供することで、ユーザーエクスペリエンスをさらに高めることです。

追加のコンテキストを提供することで、アプリのビューの外でアプリの動作に影響を与えることができます。

この例としては、通知のフィルタリングやアプリの通知バッジ数の設定などがあります。

システム情報を提供する1つの方法は、App Contextオブジェクトを使用することです。

これは、実行関数の結果の一部として返すことができるオブジェクトです。

または、フォーカスフィルターでいつでもアプリコンテキストを返し、invalidateを呼び出すことでシステムに更新された値を強制的に取得することもできます。

フォーカスフィルターがアクティブな場合、アプリは特定の通知がユーザーを中断すべきではないかどうかを判断するための追加のコンテキストを持つ場合があります。

この情報を渡すには、アプリはAppContextでfilterPredicateプロパティを設定する必要があります。

このフィルタ述語は、UNNotificationのfilterCriteriaと呼ばれる新しい文字列プロパティと連携して機能します。

通知のフィルター基準がフィルター述語と一致しない場合、通知は消音されます。

FocusFilterIntentからフィルター述語を設定するには、アプリコンテキストに含めます。

デバイスでパーソナルフォーカスが有効になっており、ユーザーが個人アカウントのみが選択されるように設定したとします。この場合、フィルター述語を個人アカウントの識別子に設定します。

受信通知が個人アカウントからのものでない場合は、ユーザーを中断すべきではありません。

ここでは、この通知を設定するときに、filterCriteriaを作業アカウントの識別子に設定します。

これは、この通知が仕事用アカウントに送信されていることを知っているためであり、アカウント識別子が個人アカウントの識別子とのみ一致する設定した述語と一致しないため、この通知が消音されることを期待しています。

この例はローカル通知用ですが、リモート通知のJSONペイロードでフィルター基準を設定することもできます。

システムに追加のコンテキストを提供するもう1つの方法は、現在有効になっているフォーカス中に重要なことを反映するようにアプリのバッジ数を更新することです。

これにより、ユーザーの気を散らすのを防ぎます。

この目的のために、UserNotificationsに新しいAPIがあります。

UNUserNotificationCenterでは、新しいバッジ値を表す符号なし整数でsetBadgeCountを呼び出すだけです。

これで、通知をフィルタリングしたり、バッジ数を設定したりするための追加のコンテキストを提供する方法を知っています。

この機能の目標は、ユーザーが集中しているときに、ユーザーにとって最も関連性の高いものを表面化することです。

フォーカスが有効になっているときに気晴らしを防ぐために、無関係なコンテンツを最小限に抑える必要がある場合があります。

次のステップでは、アプリのどの部分がフォーカスフィルターの恩恵を受けるかを検討し、設定できるプロパティを決定し、これを処理するためにアプリと拡張機能を設定し、追加のコンテキストを提供するかどうかを評価してさらに一歩進めることをお勧めします。

フォーカスフィルターはそれだけです!

このセッションにご参加いただきありがとうございます。WWDCの残りの時間をお過ごしください。

♪