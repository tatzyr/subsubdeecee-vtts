10093

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

デヴィン・クラリー:こんにちは。私はメッセージチームのエンジニア、デビンです。

ランス・パーカー:そして、私はランスで、メッセージエンジニアでもあります。

デヴィン：「カスタムコラボレーションアプリをメッセージと統合する」へようこそ。

コラボレーションは会話から始まり、iOS 16とmacOS Venturaでは、アプリのカスタムコラボレーション体験を会話のファブリックに直接組み込むことができます。

このビデオでは、コラボレーションのライフサイクルについていきます。

次に、メッセージを通じて共有するアプリの共同コンテンツを準備する方法を紹介します。

次に、プライバシーを損なうことなく、受信者のアクセスを即座に確認し、参加者の変更に対応するために必要なすべてを提供します。

最後に、アプリがメッセージの会話にコンテンツに関する通知を投稿する方法を紹介します。

このビデオは、アプリに既存のコラボレーションインフラストラクチャがあり、すでにユニバーサルリンクを採用していることを前提としています。

また、「アプリへの共有の追加」と「メッセージとのコラボレーション体験の強化」で導入されたいくつかの概念に基づいて構築します。

まず、カスタムコラボレーションメッセージのライフサイクルを経て、このAPIにより、ユーザーがこれまで以上に迅速にコラボレーションを開始する方法を説明します。

ユーザーがメッセージを通じてアプリからのコラボレーションを共有することを決定した場合、まずコンテンツを表すメタデータを作成します。

メタデータには、ユーザーがメッセージを送信する前に設定できる共有オプションと、カスタマイズできる他の多くのプロパティが含まれています。

次に、そのメタデータを共有シートに提供するか、ドラッグアンドドロップします。

これにより、メッセージの作成フィールドでコンテンツの下書きを演出できます。

コラボレーションは普遍的なリンクで表される必要があります。

それはすぐに作成できますが、メッセージが送信される直前まで延期するのが最善です。

これは、アプリのリンク作成が、メッセージ作成フィールドで設定された選択した共有オプションまたは受信者に依存する場合に便利です。

ユーザーは受信者と共有オプションを選択し、送信ボタンをタップします。

メッセージが送信される前に、メッセージはアプリにユニバーサルリンクとコンテンツのデバイスに依存しない識別子を要求します。

その識別子を使用して、メッセージは、その特定のコラボレーションメッセージの受信者を表す一連の暗号化IDを提供します。

アプリは後でこれらのアイデンティティを使用して、受信者が任意のデバイスでリンクをすぐに開くようにします。

アプリはこれらのIDをサーバーに保存し、共有コンテンツに関連付けます。

アプリがこのステップを完了すると、メッセージが受信者に送信されます。

さて、受信デバイスで起こることは次のとおりです。

目標は、アクセスを即座に確認し、受信者の身元をサーバー上のアカウントとペアリングすることです。

受信者がリンクを開くと、アプリは他のリンクと同じようにURLを開くための呼び出しを受け取ります。

アプリは、ユーザーアカウントがまだドキュメントにアクセスできないことを検出すると、受信者デバイスによって暗号的に署名されたユーザーIDの証明をシステムに照会します。

アプリは、検証のために署名された身分証明書をサーバーに送信します。

署名が有効な場合、サーバーは送信デバイスによって以前に提供されたIDと証明を比較します。

一致する場合、サーバーはユーザーのアカウントへのアクセスを許可します。

そして、それにより、受信者はアカウント情報を交換することなく、コンテンツへの即時かつ安全なアクセスを得ました!

そして、それがコラボレーションメッセージのライフサイクルです!

次に、コラボレーションを開始するためのAPIをより詳しく見てみましょう。

システムには、コラボレーションに関するメタデータが必要です。

そのために、Shared with YouフレームワークでSWCollaborationMetadataと呼ばれる新しいクラスを使用します。

このクラスには、設定するためのいくつかのプロパティがあります。コンテンツのタイトル、共有される前にコンテンツを参照するためのローカル識別子。イニシエータ名とアカウントハンドルは、ユーザーが共有しているアカウントに関する透明性をユーザーに提供します。ユーザーが設定するためのデフォルトの共有オプション。

メタデータオブジェクトを作成し、そのプロパティを設定する方法は次のとおりです。

文字列で初期化されたSWLocalCollaborationIdentifierを使用してローカル識別子を作成します。

文字列は、アプリがデバイス間でではなく、ローカルでコンテンツを識別するのに十分である必要があります。

ローカル識別子を使用して新しいメタデータインスタンスを初期化します。

ファンデーションフレームワークのPersonNameComponentsを使用して、コンテンツタイトル、イニシエータのアカウントハンドル、および名前を設定します。

ハンドルと名前はローカルでのみ表示されるため、ユーザーは共有しているアカウントを確認できます。

次に、defaultShareOptionsを設定します。

その方法をお見せする前に、まずオプションの仕組みを説明します。

共有オプションは、ユーザーがメッセージまたは共有シートのコラボレーションで構成する設定です。

ユーザーが選択したオプションは、メッセージが送信される前に提供されます。

共有オプションには、誰がコラボレーションを編集できるか、誰がコンテンツにアクセスできるかなどの設定が含まれる場合があります。

SWCollaborationOptionから始めて、いくつかのクラスを使用してオプションを定義します。

グループ化方法に応じて、オプションは個々のスイッチ、または設定の相互に排他的な値を表します。

オプションにはタイトルと識別子があり、選択または未選択のいずれかです。

オプションのグループを表すには、SWCollaborationOptionsGroupとSWCollaborationOptions PickerGroupの2つのクラスがあります。

SWCollaborationOptionsGroupを使用してスイッチのコレクションを表し、SWCollaborationOptions PickerGroupは設定の相互に排他的な値を表します。

最後に、SWCollaborationShareOptionsは、メタデータのdefaultShareOptionsプロパティに設定するオプショングループのフルセットを定義します。

オプションを記述するための要約文字列を指定することもできます。

オプションクラスについて説明したので、使用方法を示す例を次に示します。

このコードは2つのオプショングループを定義します。

最初のグループは、識別子と2つの可能なオプションで初期化されます。

識別子は、後でユーザーが選択したオプションを識別するために使用する任意の文字列です。

これはピッカーグループなので、オプションは相互に排他的です。

このグループは、コンテンツの許可設定を表します: 読み取り書き込みまたは読み取り専用。

次に、そのグループの最初のオプションがデフォルトで選択されます。

そして、タイトルはこのグループを記述する文字列に設定されています。

2番目のオプショングループも同じように初期化され、2つのオプションも含まれています。

しかし、これは一般的なオプショングループであるため、ユーザーはメンションとコメントを個別に許可するかどうかを設定できます。

最後に、2つのオプショングループを使用してSWCollaborationShareOptionsのインスタンスを初期化し、メタデータに設定します。

次に、ユーザーがコンテンツの共有を決定する方法に応じて、メタデータが共有シートまたはドラッグアンドドロップに提供されます。

アプリがSwiftUIを使用している場合、SWCollaborationMetadataは新しいShareLink APIと互換性があります。

TransferableとShareLinkの詳細については、「Meet Transferable」と「SwiftUIの新機能」をご覧ください。

SwiftUIでプロキシ表現でのコラボレーションをサポートするのがいかに簡単かをご紹介します!

転送可能なモデルオブジェクト内から、コラボレーションメタデータインスタンスを返すようにProxyRepresentationを設定します。

次に、ビューから、そのモデルオブジェクトでShareLinkを初期化します。

UIKitアプリとAppKitアプリでは、NSItemProviderを使用して共有をサポートします。

また、SWCollaborationMetadataはNSItemProviderReading and writingに準拠しています。

そのため、コラボレーションをサポートするために、アイテムプロバイダーにメタデータインスタンスを登録するだけです。

また、できるだけ多くのチャネルを通じて共有をサポートするために、コンテンツの複数の表現を登録することも良い習慣です。

たとえば、メッセージは、ファイル表現を提供する場合、コンテンツをコピーとして送信するオプションを自動的に提供します。

iOSとiPadOSではUIActivityViewControllerとUIDragItem、macOSではNSSharingServicePickerでNSItemProvider APIを使用します。

iOSの共有シートでそれを設定する方法は次のとおりです。

NSItemProviderインスタンスを作成します。

前の例で作成したコラボレーションメタデータを登録し、可視性をシステム上のすべてのプロセスに設定します。

アイテムプロバイダーでUIActivityItemsConfigurationを初期化し、その設定でUIActivityViewControllerを初期化します。

そして最後に、ビューコントローラーを提示します。

ドラッグ&ドロップをサポートするのと同じくらい簡単です。

NSItemProviderを初期化し、同じ方法でメタデータを登録し、ドラッグアンドドロップAPIで使用するアイテムプロバイダーでUIDragItemを作成します。

APIは、共有ポップオーバーのmacOSで似ています。

繰り返しますが、アイテムプロバイダーを設定します。

そして今回は、それを使ってNSSharingServicePickerを初期化します。

そして、ターゲットビューに対するピッカーを表示します。

macOSでのドラッグアンドドロップは、NSItemProviderではなくNSPasteboardItemを利用します。

これをサポートするために、SharedWithYouはNSPasteboardItem拡張機能をエクスポートします。

その拡張機能を使用して、ドラッグアンドドロップをサポートするために、新しいNSPasteboardItemインスタンスでコラボレーションメタデータを直接設定します。

そして、コラボレーションコンテンツのドラフトがメッセージで上演されるために必要なのはそれだけです!

次に、ユーザーが送信ボタンをタップすると、システムはアプリと連携して共有を設定します。

これは、SWCollaborationCoordinatorと呼ばれる新しいクラスを通じて行います。

SWCollaborationCoordinatorはシングルトンであり、グローバルな共有インスタンスがあることを意味します。

その共有インスタンスは、actionHandlerと呼ばれる定義したデリゲートを通じてコラボレーションを調整します。

コラボレーションを調整するためにアプリが常に利用可能であることを確認するために、必要に応じてバックグラウンドで起動されます。

したがって、タイムアウトを避けるために、起動後すぐにデリゲートを登録し、すぐにアクションを処理する必要があります。

アプリの起動終了後にコラボレーションコーディネーターを設定する方法は次のとおりです。

共有プロパティからシングルトンコーディネーターインスタンスにアクセスします。

次に、アプリデリゲートのdidFinishLaunchingWithOptionsメソッドで、actionHandlerプロパティをSWCollaborationActionHandlerプロトコルに準拠したオブジェクトに設定します。

アクションハンドラプロトコルは、SWActionという新しいクラスを使用します。

SWActionsは、アプリが実行することが期待される作業を表します。

完了としてマークするアクションを実行し、そうでない場合は失敗します。

アプリが処理する必要がある最初のアクションは、コラボレーションアクションの開始です。

SWStartCollaborationActionには、ユーザーが選択した共有オプションで更新された、以前に設定したコラボレーションメタデータが含まれています。

必要なセットアップを実行したら、ユニバーサルリンクとコラボレーションのデバイスに依存しない識別子を使用して開始アクションを実行します。

明示的に開始アクションに失敗すると、メッセージはキャンセルされます。

これは、サーバーリクエストの例を使用して開始アクションを処理するための実装です。

まず、アクションのメタデータプロパティからローカル識別子とユーザーが選択した共有オプションを取得します。

識別子とオプションを使用してコラボレーションを準備するためのサーバーリクエストを設定します。

次に、リクエストをサーバーに送信します。

この例では、async awaitを使用しています。

最後に、ユニバーサルリンクと応答からのデバイスに依存しない識別子でアクションを実行します。

または、エラーが発生した場合は、メッセージをキャンセルするアクションに失敗します。

開始アクションが成功した場合、システムはコラボレーション参加者を更新するための2番目のアクションをアプリに送信します。

SWUpdateCollaboration ParticipantsActionには、参加者の暗号IDが含まれています。

アイデンティティは、前のステップの開始アクションによって満たされたコラボレーション識別子から派生します。

コンテンツに関連付けられたIDをサーバーに保存します。

このデータを使用して、受信者のデバイスでのアクセスを検証します。

最後に、このアクションを実行すると、メッセージのユニバーサルリンクが送信されます。

この例は、参加者の更新アクションを処理する方法を示しています。

アクションのメタデータからコラボレーション識別子を取得します。

これは、開始アクションの処理中に達成した識別子です。

次に、アクションのaddedIdentitiesプロパティを使用して、サーバーに保存する参加者データを取得します。

各アイデンティティには、ルートハッシュと呼ばれるデータプロパティがあります。

これは、後で使用するためにサーバーに保存すべきデータです。

ランスは、このプロパティの詳細を「アクセスの確認」セクションで確認します。

別のサーバーリクエストを設定し、今回は参加者をターゲット識別子とのコラボレーションに追加します。

そして、以前と同じように、リクエストをサーバーに送信し、アクションを実行または失敗します。

今回、フルフィルメントメソッドはパラメータを取りません。

コラボレーションを設定したので、アプリにはメッセージの受信者への即時アクセスを許可するために必要なものがすべて揃っています。

ランスに渡して、その方法をお見せします。

ランス:ありがとう、デヴィン。このセクションでは、前の手順でサーバーに保存したIDデータを使用して、受信者に即時アクセスを提供する方法を紹介します。

SWPersonIdentityのrootHashプロパティは、この検証を行うために使用されます。

rootHashは、デバイス上の参加者を一意に識別するために使用される安全な値です。

検証を実行するには、ルートハッシュの計算方法を理解する必要があります。

今からそれを案内します。

コラボレーションメッセージが送信されると、実際には各人のデバイスに個別に送信されます。

メッセージは、暗号化された公開鍵を使用して各デバイスを識別します。

目標は、この一連のデバイスでのみアクセスを許可することであるため、ルートハッシュは各受信者に登録された公開鍵のセットから派生します。

ルートハッシュは、マークルツリーと呼ばれるデータ構造のルートノードです。

マークルツリーは、一連のハッシュ操作を実行することによって構築されるバイナリツリーです。

公開鍵に基づいてユーザーのアイデンティティを導き出すために、キーはこのツリーの葉として使用されます。

Merkleツリーで使用されるハッシュアルゴリズムは、ルートノードがそのキーセットからのみ計算できることを保証します。

この例では、このユーザーは3つのデバイスと3つの公開鍵を持っています。

キーは、キーの多様化と呼ばれるプロセスを使用して、アプリが提供するコラボレーション識別子ごとに一意になります。

ユーザーに登録されたデバイスの数の追跡を防ぐために、セットには固定サイズまでのランダムなキーが埋め込まれています。

ツリーのリーフノードは、多様なキーのパッド入りセットをハッシュすることによって作成されます。

SHA256アルゴリズムは、このツリーのハッシュ操作に使用されます。

次に、各リーフノードのペアが連結され、ハッシュ化され、親ノードが導出されます。

このプロセスは親ノードで繰り返され、単一のルートノードが残るまで繰り返されます。

これは、デバイス間でこの受信者の身元を一意に表現するために使用されるルートハッシュです。

完全なマークルツリーからノードのサブセットを使用してルートハッシュを生成できることに注意してください。

このツリーのルートハッシュは、多様な公開鍵P3とともに、ハッシュH4、7、および11のみを使用して再現できます。

まず、公開鍵をハッシュして、不足しているリーフノードH3を取得します。

H3とH4を使用してH8を生成します。

H8で指定されたH7ノードを使用してH10を生成します。

そして最後に、H10とH11はルートハッシュを生成します。

ツリー全体を再構築することなく、公開鍵P3が指定されたルートハッシュを生成するために使用されたことを証明できることに注意することが重要です。

これを行うために必要なノードのサブセットは、包含の証明と呼ばれます。

検証は、アプリでユニバーサルリンクが開かれたときに開始されます。

これを行うには、まずリンクが共同作業であることを確認する必要があります。

SWCollaborationHighlightは共同リンクを表し、SWHighlightCenterから取得されます。

そのコラボレーションのハイライトを使用して、包含の証明を生成します。

包含の証明を表すには、SWPersonIdentityProofというクラスを使用します。

検証を実行するには、まずこのオブジェクトと暗号化署名を生成してサーバーに送信します。

SWHighlightCenterのgetSignedIdentityProofメソッドを使用して証明を取得します。

デバイスによって署名するには、SWCollaborationHighlightといくつかの任意のデータが必要です。

署名を使用して、悪いアクターがリクエストを再生してコラボレーションにアクセスできないようにします。

データは、サーバーに要求するチャレンジ、またはデバイスで生成されたノンスである可能性があります。

この例では、チャレンジアプローチを使用しています。

URLは、アプリのUIApplicationDelegateでこのメソッドに渡されます。

このURLは、コラボレーションに関連するユニバーサルリンクです。

URLは、関連するSWCollaborationHighlightをSWHighlightCenterから取得するために使用されます。

次に、サーバーからチャレンジをリクエストし、取得したデータをハイライトとともにSWHighlightCenterのgetSignedIdentityProofメソッドに渡します。

このメソッドは、署名された身分証明書を返します。

このデータを検証するためにサーバーが何をすべきかについては、後で説明します。

これで、署名された証明をサーバーに送信して確認することができます。

最後に、結果でユーザーインターフェイスを更新します。

アプリは、公開鍵と署名されたデータとともに、証明をサーバーに送信します。

データは、ハッシュ関数としてSHA256を使用して、P-256楕円曲線上の楕円曲線デジタル署名アルゴリズムを使用して署名されます。

身分証明書の公開鍵を使用して、データの署名を確認します。

これは、最も一般的に使用される暗号化ライブラリで行うことができます。

署名を確認したら、その公開鍵に関連付けられたデバイスから身分証明書が送信されたことを信頼できます。

次に、身分証明書を使用してルートハッシュを再計算します。

これは、以前に見た例木を使用して、SWPersonIdentityProofに含まれるものの例です。

マークルツリーのルートハッシュを再構築するために使用します。

公開鍵はP3です。

包含ハッシュはH4、7、11です。

2のローカルキーインデックスは、ツリー内の公開鍵の位置を示します。

プルーフのプロパティからルートハッシュを再構築する実装例を次に示します。

再帰アルゴリズムは、ツリーデータ構造を操作するときにうまく機能するので、それは私がここでやったことです。

最初の呼び出し時に、公開鍵のハッシュ、包含ハッシュのセット、および公開鍵インデックスを渡します。

次に、最初の包含ハッシュが引き出されます。

公開鍵インデックスは、キーが兄弟の左側にあるか右にあるかを確認します。

選択したハッシュは正しい順序で連結され、ハッシュ化されます。

次に、inclusionHashes配列の消費されたノードが削除され、残りはこの同じ関数への再帰呼び出しに渡されます。

公開鍵インデックスも更新され、ツリー内の次のノードの準備が整います。

このシンプルな関数を使用すると、身分証明書が与えられたルートハッシュをすばやく計算できます。

サーバーは、この生成されたルートハッシュが、送信中にアップロードされたドキュメントの所有者のルートハッシュのリストにあることを確認できるようになりました。

ハッシュは既知のハッシュのリストに存在するため、サーバーはドキュメントへのアクセスを許可できます。

これで、自信を持って文書へのアクセスを許可することができます!

身元を確認するために従う手順を要約するには、まず、ユニバーサルリンクを処理しながら、コンテンツのコラボレーションのハイライトを調べます。

次に、いくつかのデータに署名し、包含の証明を取得します。

署名されたデータと証明をサーバーに送信します。

データの署名を確認します。

包含の証明を使用して、ルートハッシュを生成します。

最後に、ルートハッシュをそのコンテンツに関連付けられた既知のアイデンティティのリストと比較します。

コラボレーションリンクへのアクセスの検証についてすべてわかったので、参加者の変更をメッセージで調整する方法について説明します。

メッセージグループの参加者が変更され、そのグループが一緒に共同作業している場合、ユーザーはメッセージスレッドのバナーから直接、それらの変更をアプリに伝播することを選択できます。

このシナリオでは、アプリは追加および削除されたIDを含む別のSWUpdateCollaboration ParticipantsActionを受け取ります。

コラボレーションを設定するときに、このアクションを処理するために書いたのと同じコードを使用しますが、削除された参加者も処理する必要があります。

削除するには、削除されたIDに関連付けられているアカウントを検索し、アクセスを取り消すだけです。

アカウントがまだ関連付けられていない場合は、データベースからルートハッシュを削除するだけです。

これは、Devinが以前に実施した更新参加者アクションの実装です。

この例では、アクションで削除されたアイデンティティプロパティを使用し、同様の削除APIリクエストに渡します。

このコードは削除されたアイデンティティの処理のみを示していますが、完全な実装では、追加されたアイデンティティと削除されたアイデンティティの両方を処理する必要があることに注意してください。

そして、参加者の変更を処理するために必要なのはそれだけです!

最後に、コラボレーションに変更が加えられると、アプリはそれらの変更について通知し、メッセージに直接表示されます。

このセクションで確認する、サポートされている通知にはいくつかの種類があります。

通知は、リンクが共有された会話の中でバナーとして表示されます。

バナーには、変更された内容と、誰が変更したかの説明が含まれています。

この会話では、チャーリーはベーキングレシピの文書を編集しました。

ショーボタンをタップすると、コンテンツにすぐに接続されます。

通知を表すために、SharedWithYouフレームワークにはSWHighlightEventという名前のプロトコルがあります。

ハイライトイベントは、SWHighlightCenter APIから取得したSWHighlightsで初期化されます。

メッセージは、いくつかのカテゴリのイベントをサポートしています。

コンテンツの更新またはコメントの変更イベント、参加者が参加または退出したときのメンバーシップイベント、ユーザーがコラボレーションで言及されたときのメンションイベント、コンテンツが移動または削除されたときの永続性イベント。

以下は、コラボレーションを編集するための変更イベントを投稿する方法を示す例です。

ハイライトセンターAPIを使用して、ターゲット識別子のコラボレーションハイライトを取得します。

この識別子は、コラボレーションの開始時に定義した識別子であるため、コンテンツの変更が行われたときにアプリが使用できるようにする必要があります。

次に、ハイライト変更イベントインスタンスを作成します。

イニシャライザはハイライトとトリガー列挙値を取ります。この場合、編集タイプに設定します。

最後に、再びハイライトセンターを使用して、そのイベントの通知を投稿します。

同様に、メンバーシップの変更については、メンバーシップイベントを投稿し、今回は追加されたコラボレータまたは削除されたコラボレータのトリガータイプを渡します。

次に、アプリがユーザーのメンションをサポートしている場合は、メンションイベントを投稿できます。

言及されたユーザーのルートハッシュで個人のアイデンティティを初期化します。

アクセスを検証中に、人の身元をアプリのユーザーアカウントに関連付けたことを思い出してください。

次に、同じ方法でメンションイベントを投稿し、今回は言及されたアイデンティティをパラメータとして渡します。

この通知は、言及されたユーザーへのメッセージにのみ表示されます。

最後に、コンテンツが移動、名前変更、または削除されたときに、永続性イベントタイプを使用します。

ここでは、ユーザーがコンテンツの名前を変更したことを示すために、名前が変更されたトリガータイプが使用されます。

そして、それはあなたのアプリが共同作業者に通知する方法であり、彼らはメッセージでそれらの更新を取得します。

Devin: そして、いくつかの手順に従うことで、アプリのコラボレーション体験をメッセージと統合する準備が整いました。

共同で共有するコンテンツを設定し、参加者のアクセスを暗号的に検証し、参加者の変更を追跡し、メッセージに通知を投稿して、ユーザーをコンテンツに直接接続します。

コラボレーション用に表示できる新しいUI要素の詳細については、「メッセージでコラボレーション体験を強化する」ビデオを必ず確認してください。

ランス:あなたのアプリとコラボレーションするのが待ちきれません!

デビンとランス、暗号的にサインオフ。

デヴィン：見てくれてありがとう！

♪