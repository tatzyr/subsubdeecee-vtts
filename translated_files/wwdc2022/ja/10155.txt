10155

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

Meng Yang: こんにちは、私の名前はMeng Yangです。ここAppleのGPUソフトウェアのエンジニアです。

今日は、ScreenCaptureKitに関するいくつかの高度なトピックと、アプリの画面共有体験を次のレベルに引き上げる方法について説明します。

後で、私の同僚のドリューは、このエキサイティングな新しいAPIを実際に実演します。

スクリーンキャプチャは、Zoom、Google Meet、SharePlayなどの画面共有アプリケーション、さらにはTwitchなどの人気のあるゲームストリーミングサービスの中心であり、過去数年間で私たちの働き方、勉強、コラボレーション、社交の新しい規範となっています。

ScreenCaptureKitは、強力な機能セットでゼロから構築された、まったく新しい高性能スクリーンキャプチャフレームワークです。

豊富な機能セットには、高度にカスタマイズ可能なコンテンツコントロールが含まれており、キャプチャするウィンドウ、アプリケーション、ディスプレイの任意の組み合わせを簡単に選択して選択できます。

画面コンテンツのネイティブ解像度とフレームレートまでキャプチャする機能。

解像度、フレームレート、ピクセルフォーマットなどの動的ストリームプロパティコントロール。

そして、これらのコントロールは、ストリームを再作成することなく、その場で変更することができます。

メモリコピーを減らすために、GPUメモリバックアップのバッファをキャプチャします。

ハードウェアで加速されたコンテンツキャプチャ、スケーリング、ピクセル、カラーフォーマット変換により、CPU使用率を削減した高性能キャプチャを実現します。

最後になりましたが、ビデオとオーディオの両方のキャプチャをサポートします。

始める前に、この講演では、フレームワークの仕組みの基本的な概念、ビルディングブロック、ワークフローにすでに精通していることを前提としています。

詳細については、イントロセッション「Meet ScreenCaptureKit」をご覧ください。

このセッションでは、単一のウィンドウをキャプチャして表示する方法について説明します。

次に、フルディスプレイキャプチャに画面コンテンツを追加する方法。

ディスプレイキャプチャからコンテンツを削除する方法。

次に、さまざまなユースケース用にストリームを設定する方法をいくつか紹介します。

そして最後に、ScreenCaptureKitが人気のあるオープンソースのスクリーンキャプチャアプリであるOBS Studioの画面とオーディオのキャプチャ体験をどのように変えたかのデモを見ることができます。

さて、最初の例から始めましょう。おそらく最も一般的なユースケースは、単一のウィンドウをキャプチャすることです。

この例では、単一のウィンドウフィルターを設定する方法について説明します。キャプチャされたウィンドウがサイズ変更、閉塞、画面外、または最小化されているときに、ストリーム出力から何を期待するかについて説明します。

また、フレームごとのメタデータの使用方法と、キャプチャされたウィンドウを適切に表示する方法も学びます。

飛び込みましょう。

どのディスプレイに依存しない単一のウィンドウをキャプチャするには、単一のウィンドウフィルターを使用して開始し、1つのウィンドウでフィルターを初期化できます。

この例では、フィルターは単一のSafariウィンドウを含むように設定されています。

ビデオ出力には、そのウィンドウだけが含まれており、他には何も含まれていません。

Safariの子供、ポップアップ、その他のウィンドウは含まれません。

一方、ScreenCaptureKitのオーディオキャプチャポリシーは、常にアプリレベルで機能します。

単一のウィンドウフィルターを使用すると、ビデオ出力に存在しないウィンドウからでも、ウィンドウを含むアプリケーションからのすべてのオーディオコンテンツがキャプチャされます。

では、コードサンプルを見てみましょう。

単一のウィンドウでストリームを作成するには、利用可能なすべてのコンテンツをSCShareableContent経由で共有することから始めます。

次に、windowIDと一致して、SCShareableContentから共有するウィンドウを取得します。

次に、指定されたSCWindowでdesktopIndependentWindowタイプのSCContentFilterを作成します。

ストリーム出力の一部としてオーディオを含めるようにストリームをさらに設定できます。

これで、contentFilterとstreamConfigでストリームを作成する準備が整いました。

その後、StreamOutputを追加してストリームを開始できます。

次に、ストリーム出力を見てみましょう。 

この例では、ソース表示は左側に、ストリーム出力は右側にあります。

ストリームフィルターには、単一のSafariウィンドウが含まれています。

今から、キャプチャされているSafariウィンドウをスクロールし始めます。

ストリーム出力には、単一のSafariウィンドウからのライブコンテンツが含まれており、ソースウィンドウと同じケイデンスで、ソースディスプレイのネイティブフレームレートまで更新されます。

たとえば、ソースウィンドウが120Hzディスプレイで常に更新されている場合、ストリーム出力は最大120fpsの更新も実現できます。

ウィンドウのサイズが変更されるとどうなるのか疑問に思うかもしれません。

ストリームの出力ディメンションを頻繁に変更すると、追加のメモリ割り当てにつながる可能性があるため、推奨されないことに注意してください。

ストリームの出力ディメンションはほとんど固定されており、ソースウィンドウでサイズを変更しません。

では、ソースウィンドウのサイズを変更して、ストリームの出力がどうなるか見てみましょう。

ScreenCaptureKitは常にキャプチャされたウィンドウでハードウェアスケーリングを実行するため、ソースウィンドウのサイズが変更されるときにフレーム出力を超えることはありません。

他の窓で覆われている窓はどうですか？

ソースウィンドウがオクルードまたは部分的にオクルードされている場合、ストリーム出力には常にウィンドウの完全なコンテンツが含まれます。

また、これは、ウィンドウが完全に画面から外れたり、他のディスプレイに移動したりした場合にも当てはまります。

また、最小化されたウィンドウの場合、ソースウィンドウが最小化されると、ストリーム出力は一時停止され、ソースウィンドウが最小化されなくなったときに再開されます。

次に、オーディオ出力に移りましょう。

この例では、オーディオトラック付きの2つのSafariウィンドウがあり、左側のウィンドウがキャプチャされています。

ビデオ出力には最初のウィンドウのみが含まれ、両方のSafariウィンドウのオーディオトラックがオーディオ出力に含まれます。

見て聞いてみましょう。

♪エレクトロニックダンスミュージック♪

シェフ：そして、私はお気に入りのワカモレのレシピを書き留めました。

4つのアボカドが必要です。

Meng: ストリームが稼働すると、新しいフレームが利用可能になるたびに、アプリはフレームの更新を受け取ります。

フレームの出力には、キャプチャされたフレームとフレームごとのメタデータを表すIOSurfaceが含まれています。

メタデータについて話すのに時間を費やしたいと思います。

アプリに非常に役立つメタデータの例をお見せします。

そして、これらには、ダーティレクト、コンテンツレクト、コンテンツスケール、スケールファクターが含まれます。

汚い直腸から始めましょう。

汚いrectsは、新しいコンテンツが前のフレームのどこにあるかを示します。

この例では、フレーム更新の領域を説明するために、汚れた直腸が強調表示されています。

常にフレーム全体をエンコードしたり、エンコーダ内の2つのフレーム間のデルタを計算したりする代わりに、ダーティレクトを使用して、新しい更新で領域のみをエンコードして送信し、更新をレシーバー側の前のフレームにコピーして新しいフレームを生成することができます。

汚れたrectsは、マッチングキーを使用して、出力CMSampleBufferのメタデータ辞書から取得できます。

では、コンテンツrectとコンテンツスケールに移りましょう。

キャプチャするソースウィンドウは左側にあり、ストリーム出力は右側にあります。

ウィンドウのサイズを変更できるため、ソースウィンドウのネイティブバッキングサーフェスサイズは、ストリーム出力のディメンションと一致しないことがよくあります。

この例では、キャプチャされたウィンドウはフレームの出力とは異なるアスペクト比を持ち、より大きくなっています。

キャプチャされたウィンドウは、出力に収まるように縮小されます。

ここで緑色で強調表示されているコンテンツrectは、ストリーム出力でキャプチャされたコンテンツの関心のある領域を示します。

そして、コンテンツのスケールは、コンテンツがどれだけ適合するようにスケーリングされているかを示します。

ここでは、キャプチャされたSafariウィンドウは、フレーム内に収まるように0.77縮小されます。

これで、先ほど説明したメタデータを使用して、キャプチャされたウィンドウをできるだけネイティブの外観に正しく表示できます。

まず、コンテンツrectを使用して出力からコンテンツをトリミングすることから始めましょう。

次に、コンテンツのスケールを分割してコンテンツをスケールアップします。

これで、キャプチャされたコンテンツは、ソースウィンドウとして1対1のピクセルサイズに一致するようにスケーリングされます。

しかし、キャプチャされたウィンドウはターゲットディスプレイでどのように見えますか?

その質問に答えるために、スケールファクターがどのように機能するかを説明することから始めたいと思います。

ディスプレイのスケールファクターは、ディスプレイまたはウィンドウの論理ポイントサイズとそのバッキングサーフェスのピクセルサイズの間のスケール比を示します。

スケールファクター2、または2倍モードは、画面上のすべてのポイントがバッキングサーフェスの4ピクセルに等しいことを意味します。

ウィンドウは、この例のようにスケールファクター2のRetinaディスプレイから、キャプチャ中にスケールファクター1の非Retinaディスプレイに移動できます。

スケールファクター1では、画面上の各論理ポイントは、裏面上の1ピクセルに対応します。

さらに、ソースディスプレイには、キャプチャされたコンテンツが表示されるターゲットディスプレイとのスケールファクターが一致しない可能性があります。

この例では、ウィンドウはスケールファクター2で左側のRetinaディスプレイからキャプチャされ、右側の非Retinaディスプレイに表示されます。

キャプチャされたウィンドウが、1ポイントから1ピクセルのマッピングでターゲットの非Retinaディスプレイにスケーリングせずにそのまま表示される場合、ウィンドウは4倍の大きさに見えます。

これを修正するには、常にフレームのメタデータのスケールファクターをターゲットディスプレイのスケールファクターと照合する必要があります。

不一致がある場合は、表示する前に、キャプチャしたコンテンツのサイズをスケールファクターで拡大縮小します。

スケーリング後、ターゲットディスプレイのキャプチャされたウィンドウは、ソースウィンドウと同じサイズに見えるようになりました。

さて、コードを見てみましょう、それは非常に簡単です。それは非常に簡単です。

コンテンツrect、コンテンツスケール、およびスケールファクターは、出力CMSampleBufferのメタデータ添付ファイルから取得することもできます。

その後、これらのメタデータを使用して、キャプチャしたコンテンツをトリミングして拡大縮小し、正しく表示することができます。

要約すると、単一のウィンドウフィルターには、ソースウィンドウがオフスクリーンまたは閉塞している場合でも、常に完全なウィンドウコンテンツが含まれています。

ディスプレイとスペースに依存しません。

出力は常に左上隅でオフセットされます。

ポップアップウィンドウや子ウィンドウは含まれていません。

メタデータを使用してコンテンツを最適に表示することを検討してください。

また、オーディオには、含まれているアプリ全体のトラックが含まれています。

単一のウィンドウをキャプチャして表示する方法を学んだばかりなので、表示ベースのコンテンツフィルタの次のクラスに移りましょう。

この次の例では、ウィンドウやアプリでディスプレイベースのフィルターを作成する方法を学び、ビデオフィルタリングとオーディオフィルタリングのルールの違いをいくつか示します。

ディスプレイベースのインクルージョンフィルターは、コンテンツをキャプチャするディスプレイを指定します。

デフォルトでは、ウィンドウはキャプチャされません。

キャプチャするコンテンツをウィンドウで選択できます。

この例では、SafariウィンドウとKeynoteウィンドウが表示フィルターに追加されています。

ビデオ出力には、ディスプレイスペースに配置されたこれら2つのウィンドウのみが含まれ、オーディオ出力にはKeynoteとSafariアプリのすべてのサウンドトラックが含まれています。

このコードサンプルは、付属のウィンドウでディスプレイベースのフィルターを作成する方法を示しています。

SCShareableContentとwindowIDを使用してSCWindowsのリストを作成することから始めます。

次に、指定されたディスプレイと含まれているウィンドウのリストを使用して、ディスプレイベースのSCContentFilterを作成します。

その後、デスクトップに依存しないウィンドウと同じ方法でフィルターと設定を使用してストリームを作成し、ストリームを開始できます。

ストリームを稼働させたら、ストリームの出力を見てみましょう。

フィルターは、2つのSafariウィンドウ、メニューバー、壁紙ウィンドウを含むように設定されています。

ウィンドウが画面から移動されると、ストリーム出力から削除されます。

新しいSafariウィンドウが作成されると、新しいウィンドウがフィルターにないため、新しいウィンドウはストリーム出力に表示されません。

同じルールは、ストリームの出力に表示されない子ウィンドウまたはポップアップウィンドウにも適用されます。

子ウィンドウがストリーム出力に自動的に含まれていることを確認したい場合は、付属のアプリでディスプレイベースのフィルターを使用できます。

この例では、SafariアプリとKeynoteアプリをフィルターに追加すると、これらの2つのアプリのすべてのウィンドウとサウンドトラックからのオーディオとビデオ出力が出力ウィンドウ例外フィルターに含まれることが、フィルターが付属のアプリでディスプレイとして指定されている場合に、出力から特定のウィンドウを除外する強力な方法です。

たとえば、単一のSafariウィンドウが出力から削除されます。

ScreenCaptureKitはアプリレベルでのオーディオキャプチャを可能にするため、単一のSafariウィンドウからオーディオを除外することは、すべてのSafariアプリのオーディオトラックを削除するのと同じです。

ストリームのビデオ出力にはまだSafariウィンドウが含まれていますが、Safariアプリのすべてのサウンドトラックが削除され、オーディオ出力にはKeynoteのサウンドトラックのみが含まれています。

ここのコード例では、SCContentFilterをSCWindowsの代わりにSCRunningApplicationsのリストを含むように変更します。

さらに除外したい個々のウィンドウがある場合は、SCWindowsのリストを作成し、除外するウィンドウのリストを持つSCApplicationsのリストを使用してSCContentFilterを作成します。

含まれているアプリを指定して、新しいウィンドウまたは子ウィンドウが作成されると、ストリーム出力がどのように見えるかを見てみましょう。

今回は、Safariアプリとシステムウィンドウがフィルターに追加されます。

新しいSafariウィンドウがストリーム出力に自動的に含まれるようになり、子ウィンドウとポップアップウィンドウにも同じルールが適用されます。

これは、チュートリアルを行っていて、ポップアップや新しいウィンドウを呼び出すなど、完全なアクションを実演したいときに非常に便利です。

いくつかの異なる方法でストリーム出力にコンテンツを追加する方法を実演しました。

次の例では、ストリーム出力からコンテンツを削除する方法を説明します。

この例には、共有されているディスプレイのプレビューを含むビデオ会議アプリをエミュレートするテストアプリが含まれています。

テストアプリはプレビューに再帰的に表示されるため、いわゆるミラーホール効果を生み出しています。

フルディスプレイ共有中でも、画面共有アプリケーションが独自のウィンドウ、キャプチャプレビュー、ミラーホール効果を回避するための参加者カメラビュー、または通知ウィンドウなどの他のシステムUIを削除するのが一般的です。

ScreenCaptureKitは、ディスプレイキャプチャからコンテンツをすばやく削除できる一連の除外ベースのフィルターを提供します。

除外ベースのディスプレイフィルタは、デフォルトで指定されたディスプレイからすべてのウィンドウをキャプチャします。

その後、除外フィルターに追加することで、個々のウィンドウやアプリの削除を開始できます。

たとえば、コンテンツキャプチャテストアプリと通知センターを除外されたアプリケーションのリストに追加できます。

アプリケーションのリストを除外する表示ベースのフィルタを作成するには、まずSCApplicationsを取得してバンドルIDを一致させて除外します。

ストリーム出力に戻りたい個々のウィンドウがある場合は、SCWindows以外のオプションリストを作成することもできます。

そして、特定のディスプレイ、除外するアプリケーションのリスト、および除外ウィンドウのリストを使用して、コンテンツフィルターを作成します。

結果を見てみましょう。 見ていきましょう。

ミラーホールの問題を引き起こしているコンテンツキャプチャテストアプリと通知ウィンドウは、どちらもストリーム出力から削除されます。

これらのアプリから新しいウィンドウまたは子ウィンドウも自動的に削除されます。

これらの削除されたアプリにオーディオが含まれている場合、そのオーディオはオーディオ出力から削除されます。

単一のウィンドウをキャプチャする方法、ディスプレイフィルターからウィンドウを追加および削除する方法を見ました。

次にストリーム設定に移りましょう。

次のいくつかの例では、設定できるさまざまなストリームプロパティ、スクリーンキャプチャとストリーミング用のストリームの設定方法、ライブプレビューでウィンドウピッカーを構築する方法について学びます。

設定プロパティから始めましょう。

これらは、ストリーム出力寸法、送信元と宛先のrects、色空間、カラーマトリックス、ピクセル形式、カーソルを含めるかどうか、フレームレート制御など、設定できる一般的なストリームプロパティの一部です。

次に、各物件の詳細を見ていきます。

幅と高さをピクセル単位で指定できる出力寸法から始めましょう。

ソースディスプレイのディメンションとアスペクト比は、必ずしも出力ディメンションと一致するとは限りません。

そして、フルディスプレイのキャプチャ中にこのミスマッチが発生すると、ストリーム出力にピラーまたはレターボックスがあります。

また、キャプチャする領域を定義するソースrectを指定して、結果がレンダリングされ、フレーム出力の宛先rectにスケーリングされることもできます。

ScreenCaptureKitは、ハードウェアアクセラレーション色空間、カラーマトリックス、ピクセルフォーマット変換をサポートしています。

一般的なBGRAとYUVフォーマットがサポートされています。

完全なリストについては、開発者ページをご覧ください。

ショーカーソルが有効になっている場合、ストリーム出力にはフレームにプリレンダリングされたカーソルが含まれます。

これは、カメラ型のカーソルのようなカスタムカーソルでも、すべてのシステムカーソルに適用されます。

最小フレーム間隔を使用して、目的の出力フレームレートを制御できます。

たとえば、60 fpsをリクエストする場合は、最小間隔を1/60に設定します。

フレーム更新は60fps以下で、コンテンツのネイティブフレームレート以下です。

キューの深さを指定して、サーバー側のサーフェスプール内のサーフェスの数を決定できます。

プール内のサーフェスが増えると、フレームレートとパフォーマンスが向上しますが、システムメモリの使用率が高くなり、レイテンシのトレードオフが発生する可能性があります。これについては後で詳しく説明します。

ScreenCaptureKitは、デフォルトのキューの深さが3で3から8の間のキューの深さ範囲を受け入れます。

この例では、サーフェスプールは、ScreenCaptureKitがレンダリングできる4つのサーフェスを含むように構成されています。

現在のアクティブサーフェスはサーフェス1で、ScreenCaptureKitは次のフレームをレンダリングしています。

サーフェス1が完了すると、ScreenCaptureKitはサーフェス1をアプリに送信します。

アプリはサーフェス1を処理して保持していますが、ScreenCaptureKitはサーフェス2にレンダリングされています。

Surface 1は、アプリがまだ使用中であるため、プールで使用不可としてマークされるようになりました。

サーフェス2が完了すると、アプリに送信され、ScreenCaptureKitがサーフェス3にレンダリングされるようになりました。

しかし、アプリがまだサーフェス1を処理している場合は、フレームが処理できるよりも速く提供されるため、遅れ始めます。

サーフェスプールに多数のサーフェスが含まれている場合、新しいサーフェスが積み重なり始め、追いつくためにフレームをドロップし始めることを検討する必要があるかもしれません。

この場合、プール内のより多くのサーフェスが、より高いレイテンシにつながる可能性があります。

ScreenCaptureKitが使用するプールに残っているサーフェスの数は、キューの深さからアプリが保持するサーフェスの数を差し引いたものと同じです。

この例では、サーフェス1と2の両方がまだアプリによって保持されています。

表面プールには2つの表面が残っています。

サーフェス3が完了し、アプリに送信された後、プールに残っている唯一の利用可能なサーフェスはサーフェス4です。

アプリがサーフェス1、2、3を保持し続けると、ScreenCaptureKitはすぐにレンダリングするサーフェスを使い果たし、フレームの損失とグリッチが見られます。

フレームの損失を避けるために、ScreenCaptureKitがサーフェス4の後に次のフレームをレンダリングし始める前に、アプリはサーフェス1を終了してリリースする必要があります。

これで、アプリはサーフェス1をリリースし、ScreenCaptureKitが再び使用できるようになりました。

要約すると、フレームレイテンシとフレーム損失を避けるために、アプリが従う必要がある2つのルールがあります。

フレームの遅延を回避するには、MinimumFrameInterval内でフレームを処理できる必要があります。

フレームの損失を避けるために、アプリがサーフェスをプールに戻すのにかかる時間は、MinimumFrameInterval時間QueueDepthマイナス1未満でなければなりません。その後、ScreenCaptureKitは使用するサーフェスを使い果たし、ストールに入り、新しいフレームを見逃し始めます。

設定できるさまざまなプロパティを見たので、スクリーンキャプチャとストリーミング用のストリームを設定するためのいくつかの例を掘り下げてみましょう。

一部の画面コンテンツには、常に更新され、より高いフレームレートを必要とするビデオ、ゲーム、またはアニメーションが含まれています。

他のものには、フレームレートよりも高解像度を優先する基調講演ウィンドウのような主に静的なテキストが含まれていますが、共有されるコンテンツとネットワーク状態に基づいてストリームの設定をライブ調整できます。

このコード例では、4K、60fpsのゲームをストリーミングするようにキャプチャを設定する方法を見て回ります。

ストリーム出力の寸法をピクセルサイズで4Kに設定することから始めることができます。

そして、最小フレーム間隔を1/60に設定して、出力フレームレートを60fpsに設定します。

次に、エンコードとストリーミングにピクセル形式のYUV420を使用します。

オプションのソースrectを設定して、画面の一部だけをキャプチャします。

次に、背景塗りつぶし色を黒に変更し、フレーム出力にカーソルを含めます。

最適なフレームレートとパフォーマンスのために、サーフェスキューの深さを5に設定します。

最後に、出力ストリームでオーディオを有効にします。

前の例で見たすべてのストリーム構成は、ストリームを再作成することなく、その場で動的に変更できます。

たとえば、出力ディメンションなどの一部のプロパティをライブ調整したり、フレームレートを動的に変更したり、ストリームフィルタを更新したりできます。

出力寸法を4Kから720pに切り替える例を次に示します。

そして、フレームレートを60fpsから15fpsにダウングレードします。

その後、updateConfigurationを呼び出すだけで、ストリームを中断することなく、その場で新しい設定を適用できます。

最後の例では、ライブプレビュー付きのウィンドウピッカーの構築をご案内したいと思います。

以下は、典型的なウィンドウピッカーがどのように見えるかの例です。

ウェブ会議の画面共有アプリは、共有する正確なウィンドウを選択するオプションをユーザーに提供するのが一般的です。

ScreenCaptureKitは、ライブコンテンツの更新で多数のサムネイルサイズのストリームを作成するための効率的で高性能なソリューションを提供し、実装が簡単です。

それを分解して、ScreenCaptureKitを使用してこのようなウィンドウピッカーを構築するために何が必要かを見てみましょう。

ピッカーを設定するには、アプリがユーザーがデスクトップに依存しないウィンドウをフィルタータイプとして選択できる対象ウィンドウごとに1つのウィンドウフィルターを作成することから始めることができます。

次に、オンスクリーン表示用のBGRAピクセルフォーマット、デフォルトのキューの深さ、カーソルやオーディオなしで、サムネイルサイズの5 fpsのストリーム構成を設定します。

単一のウィンドウフィルターとここでのストリーム構成を使用して、各ウィンドウに1つのストリームを作成します。

コードでこれを行うには、デスクトップとシステムウィンドウを除外してSCShareableContentを取得することから始めることができます。

次に、対象となるウィンドウごとにデスクトップに依存しないウィンドウタイプのコンテンツフィルターを作成します。

次に、ストリーム設定部分に移動します。

適切なサムネイルサイズ（この例では、284×182）を選択し、最小フレーム間隔を1対5に設定します。

画面表示用のBGRAのピクセル形式では、プレビューでそれらを必要としないため、オーディオとカーソルを無効にします。

そして、あまりにも頻繁な更新を期待していないので、キューの深さを3に設定します。

ストリームコンテンツフィルターと構成が作成されると、ストリームを作成する準備が整いました。

ウィンドウごとに1つのストリームを作成し、各ストリームにストリーム出力を追加し、ストリームを開始します。

最後に、ストリームリストに追加します。

これは、先ほど見たサンプルコードを使用して作成されたライブプレビュー付きのウィンドウピッカーです。

各サムネイルはライブ更新され、シングルウィンドウフィルターを備えた個々のストリームによってバックアップされます。

ScreenCaptureKitを使用すると、このようなライブプレビューピッカーを簡単に構築できます。これにより、システムに負担をかけることなく、同時に多くのライブ画面コンテンツを同時にキャプチャできます。

それでは、同僚のドリューに渡しましょう。ドリューは、ScreenCaptureKitのOBS採用に関するエキサイティングなデモを提供します。

ドリュー・ミルズ:ありがとう、メン。

こんにちは、私の名前はドリューで、アップルのパートナーエンジニアです。

OBS Studioは、ユーザーが自分のコンピュータから録画やストリーミングコンテンツを管理できるオープンソースアプリケーションです。

これには、この春に統合するプロジェクトに協力したScreenCaptureKitの実装が含まれています。

ScreenCaptureKitは、OBSの既存のCGDisplayStreamベースのキャプチャと同様のコードを利用したため、簡単に実装できました。

ScreenCaptureKitの実装は、「Meet ScreenCaptureKit」セッションで議論された多くの機能を示しています。

これには、デスクトップ全体、アプリケーションのすべてのウィンドウ、または1つの特定のウィンドウのキャプチャが含まれます。

ScreenCaptureKitは、OBSのCGWindowListCreateImageベースのキャプチャよりもオーバーヘッドが低い。

これは、画面の一部をキャプチャすると、コンテンツの制作に使用できるリソースが増えることを意味します。

デモに飛び込んで、私たちが実際に議論してきたことを見てみましょう。

左側には、OBSのウィンドウキャプチャの最悪の例があります。

このキャプチャはCGWindowListCreateImage APIを使用しており、大きな吃音があります。

私たちのテストでは、フレームレートが7fpsまで低下するのを見ました。

一方、右側のScreenCaptureKitの実装は、はるかにスムーズな結果をもたらし、大幅に滑らかな動きで出力ビデオを提供します。

この場合、60fpsを提供します。

OBSはウィンドウキャプチャよりも最大15%少ないRAMを使用します。

また、OBSのウィンドウキャプチャの代わりにScreenCaptureKitを使用すると、OBSのCPU使用率が最大半分に削減されます。

ScreenCaptureKitがOBSユーザーに提供しなければならないその他の改善点を見てみましょう。

私はまだサヨナラワイルドハーツのすべてのゴールドランクを追跡しようとしています。

最高の走りを見せびらかしたいので、ゲームプレイを録画しています。

ScreenCaptureKitのおかげで、ゲームから直接オーディオストリームをキャプチャできるようになったので、Macで通知を受け取ったときに、録画のオーディオやビデオが台無しになることはありません。

そして、これは追加のオーディオルーティングソフトウェアをインストールしなくても可能です。

♪

現在、AppleシリコンでScreenCaptureKitが提供するすべての機能強化を使用して、Taiko no Tatsujin Pop Tap BeatのようなゲームをMacから人気のあるストリーミングサービスにストリーミングできます。

Appleシリコンのハードウェアエンコーダの新しい定数ビットレートオプションは、ゲームのパフォーマンスに大きな影響を与えることなく、一定のビットレートを必要とするサービスのためにストリーミングコンテンツをエンコードできることを意味します。

現在、ScreenCaptureKitのリソース使用量の削減とエンコーディングのオフロードのおかげで、重要なコンテンツでさらに多くのパフォーマンスを利用できます。

あなたに戻って、メン。

メン:ありがとう、ドリュー。

デモと例を通して、高度な画面コンテンツフィルターについて学びました。

さまざまなユースケースのためにストリームを設定するいくつかの方法。

そして、フレームごとのメタデータを使用し、キャプチャされたコンテンツを正しく表示する方法。

最高のパフォーマンスを達成するのに役立ついくつかのベストプラクティス。

そして最後に、ドリューはScreenCaptureKitがOBSにもたらした重要な機能とパフォーマンスの向上を紹介しました。

ScreenCaptureKitを使用して、アプリの画面共有、ストリーミング、コラボレーション体験をどのように再定義するかを見るのが待ちきれません。

見てくれてありがとう!

♪