10006

♪まろやかなインストゥルメンタルヒップホップ音楽♪

♪

みなさん、こんにちは！私の名前はアンクル・ソニです。

私はAppleのマップサービスチームのエンジニアリングマネージャーです。

今日は、マップ開発者エコシステムに登場するエキサイティングな新機能を見ていきます。

では、始めましょう。

当社のマップアプリは、世界中のAppleのお客様にさまざまなエンドユーザー体験を提供します。

私たちは、MapKitとMapKit JS製品を通じて、開発者がアプリやウェブサイトに美しい位置情報体験を作成できるようにします。

しかし、Apple Maps開発者の提供は、常に非常にクライアント中心でした。

私たちはあなたのすべての素晴らしいフィードバックに注意深く耳を傾けました。

あなたは、パフォーマンスやパワーを損なうことなく、MapKitで自分のデータを拡張する方法を望んでいました。

だから、私たちのエコシステムを締めくくるために、私たちはApple Maps Server APIを導入することに興奮しています。

ジオコーディング、リバースジオコーディング、検索、到着予定時刻、またはETAの4つの新しいサーバーAPIを導入しています。

これらのAPIは、マップをアプリケーションに統合しながら、さまざまなユースケースに取り組むのに役立ちます。

ジオコーディングAPIを使用すると、アドレスを地理座標の緯度と経度に変換できます。

同様に、リバースジオコーディングでは、地理座標からアドレスに移動して、逆に行うことができます。

検索APIを使用すると、ユーザーに検索文字列を入力して、ビジネスや興味のある場所などを見つける機能を与えることができます。

独自のデータの一部をオーバーレイしてユーザーに提示したいのかもしれません。

ETA APIを使用すると、顧客があなたのビジネスが彼らからどれだけ離れているかを知るのを助けたり、最寄りの店舗を見つけるためにいくつかの計算を行うことができます。

可能性は無限大です!

3つの重要な理由から、サーバーAPIを気に入ると思います。

MapKit、MapKit JS、および新しいApple Maps Server APIを活用することで、シームレスな体験を提供できるようになりました。

これにより、アプリケーションアーキテクチャが簡素化され、完全なAppleマップスタックが得られます。

これはあなたの人生をはるかに楽にするでしょう。

確かに、それは私を助けてくれました。

しかし、ねえ、私は偏っています!

次の利点は、ネットワーク通話の削減です。

多くの場合、私たちはiPhone、iPad、ウェブサイトなどのユーザーのデバイスから反復的で冗長な要求をしている状況に陥っています。

異なるユーザーデバイスで実行されているアプリから、同じアドレスを何度も何度も調べているかもしれません。

これにより、多くのネットワーク通話が発生し、帯域幅が無駄になります。

この一般的な操作をサーバーに委任し、サーバーAPIを使用してバックエンドで一度だけ行うと、アプリケーションがより少ない帯域幅を消費するのに役立ちます。

これの良い副作用は、一部の処理がApple Maps Server APIを使用してサーバーに委任されるようになったため、アプリケーションも電力効率が良いようになったことです。

では、これらのAPIのいくつかをスピンしてみましょう。

店舗検索アプリケーション用にこれらの連絡先カードを作成しているとしましょう。

ここでは、住所と顧客の場所からの距離を持つ3つの店舗が見えます。

この例では、お客様が自分の場所を提供したと仮定します。

とりあえず、これらのコンタクトカードの1つを構築することに集中しましょう。

これらのアドレスは、コミック書店の場所を保管し、サービスを提供するサーバー上にあると仮定します。

これを構築する方法はたくさんありますが、少しの間、これらの新しいサーバーAPIがないと仮定しましょう。

基本的な建築はどのようなものになるでしょうか?

クライアントアプリケーションはこのデータをどのように取得しますか?

この図では、アプリケーションがサーバーに呼び出してストアアドレスのリストを取得しています。

バックエンドサーバーは、ストアアドレスのリストをクライアントデバイスに返します。

この例ではサーバーAPIがないため、クライアントアプリケーションは連絡先カードを構築するためにアドレスに対してさまざまなアクションを実行する必要があります。

1つのタスクを実行するには、クライアントはさまざまなバックエンドサービスに複数の電話をかける必要があるかもしれません。

ここでは、MapKitまたはMapKit JSを使用して、クライアントアプリがApple Maps Serverに直接電話をかけていることがわかります。

クライアントとバックエンドの間のこのおしゃべりは、アプリケーションのパフォーマンスと規模に悪影響を及ぼす可能性があります。

一般的にレイテンシの高いセルラーネットワークでは、この方法で個々の要求を使用することは非効率的であり、接続の破損や不完全な要求につながる可能性があります。

各リクエストは並行して実行できますが、アプリケーションは各リクエストのデータを送信、待機、処理し、すべて別々の接続で失敗の可能性を高めなければなりません。

最後に、クライアント上のすべての応答をマージする必要があります。

そして、これらすべての呼び出しが発生する間、あなたはユーザーにスピナーを表示しています。

さらに、クライアントデバイスは、これらの余分な通話により多くの帯域幅と電力を使用しています。

それは良いユーザーエクスペリエンスではありません。

では、Apple Maps Server APIにアクセスできるモデルアーキテクチャを見てみましょう。

バックエンドサーバーをゲートウェイとして使用して、クライアントとサービス間のチャット性を減らすことができます。

以前と同じように、ここではクライアントから店舗のリストを表示するように要求します。

次に、サーバーからジオコーディングを行うように要求します。

その後、Apple Maps Serverから各APIの回答を受け取ります。

コミックブックサーバーは、各サービスからの応答を組み合わせて、アプリケーションに応答を送信します。

このパターンは、アプリケーションがバックエンドサービスに対して行う要求の数を減らし、高遅延ネットワーク上のアプリケーションのパフォーマンスを向上させることができます。

要約すると、クライアントはサーバーに1回電話をかけて、ストアのリストを取得します。

その後、サーバーは、ユーザーに最も適した応答を作成するために適切なAPI呼び出しを行うために重い作業を行います。

では、ここでケーススタディの例に戻りましょう。

ジオコーディングとETA APIを使用して、店舗までの距離を取得します。

Geocode APIを使用して、ストアアドレスの緯度と経度を検索でき、後でETA計算に使用します。

この例では、まず、コミックブックストアのアドレスを取り、URLでエンコードします。

次に、Geocode APIを使用し、このURLエンコードされたアドレスをクエリパラメータとして渡します。

今のところ、認証の詳細をスキップして、いくつかのスライドでそれに戻ります。

応答では、返されたアドレスの緯度と経度を確認できます。

お客様の住所の緯度と経度を見つけるために、同じプロセスを繰り返します。

これは後でETAの計算に使用されます。

ご覧のとおり、応答にはより多くのフィールドがあります。

以下のリソースセクションで詳細なドキュメントをリンクします。

これで、Geocode APIから取得したデータを使用して、ETA APIの出発地と目的地を設定できます。

前に述べたように、原点の緯度、経度、目的地の緯度、経度があります。

必要に応じて、ここで最大10の目的地を指定できます。

それをETA APIで原点として、URLエンコードされた宛先クエリパラメータとしてフィードします。

APIへの応答は、提供された目的地ごとに1つずつ、ETAのリストです。

この場合、目的地を1つ提供したので、私たちは1つしか持っていません。

ここでは、私たちの例では、店舗までの距離を計算するための距離メーターに興味があります。

これにより、必要な部品がすべて手になります。店舗の住所と、ユーザーが店舗に到着するまでの距離です。

また、店舗の営業時間など、独自の店舗情報を使用して、このデータを拡張またはオーバーレイすることもできます。

このようにして、さまざまなサーバーAPIを活用してアプリケーションを構築できます。

その他のAPIについては、この講演の下にリンクされているドキュメントを参照してください。

私たちが話していない重要な部分の1つは認証です。

すべてのApple Maps Server APIが認証されています。

MapKit JSを使用している場合は、すでに途中です。

Apple Maps Server APIは、MapKit JSと同じメカニズムを使用して認証します。

まず、開発者アカウントから秘密鍵をダウンロードします。

次に、この秘密鍵を使用して、JWT形式でマップ認証トークンを生成します。

以下にリンクされている作成方法に関する詳細なドキュメントがあります。

その後、トークンAPIを使用してこのマップ認証トークンを交換して、マップアクセストークンを取得できます。

バックエンドでマップ認証トークンを認証し、マップアクセストークンを返送します。

これはJWT形式であり、すべてのAPIインタラクションに使用されます。

このアクセストークンは、ここで強調表示されたプロセスを繰り返すことで、30分ごとに更新する必要があります。

認証フローがどのように見えるかを見たので、トークンAPIを使用してアクセストークンを取得する方法の簡単な例を次に示します。

ここではトークンAPIを使用しています。

マップ認証トークンをヘッダーとして渡しています。

APIへのアクセスに使用できるマップアクセストークンが戻ってきます。

これはJWT形式で、有効期限、発行済みなどの標準フィールドがあります。

便宜上、expiresInSecondsフィールドには、トークンの有効期間が表示されます。

この場合、30分です。 分です。

マップ認証トークンはマップアクセストークンと同じではないことを覚えておいてください。

マップ認証トークンを交換して、サーバーAPIにアクセスするための30分間のマップアクセストークンを取得します。

マップアクセストークンとのAPIインタラクションがどのように見えるかを簡単に見てみましょう。

サーバーAPI呼び出しとともにマップアクセストークンを渡します。

数枚のスライドで見たように、API呼び出しのヘッダーとして追加されます。

Apple Maps Serverは、マップのアクセストークンを検証します。

検証が成功すると、Apple Maps ServerはAPI応答で応答します。

APIと認証を取り上げたので、使用制限について話しましょう。

大きな力には大きな責任が伴うので、クォータを賢く使用してください。

あなたが行うことができるAPI呼び出しの数には1日の上限があり、それは大きいです!

1日あたり合計25,000件のサービスコールのクォータを取得します。

MapKit JSとサーバーAPIを介してサービスを呼び出すと、同じクォータを使用することに注意してください。

もっと必要な場合は、私たちに手を差し伸べてください。

では、これをすべてどのように追跡しますか?

マップ開発者ダッシュボードで使用統計を表示できます。

MapKit JSを使っている人はいますか？

これはあなたにとても見覚えがあるでしょう。

サーバーAPIの使用状況はサービスに分類され、ここで強調表示されます。

1日のクォータを超えた場合、つまり25,000以上のサーバーAPI呼び出しは、新しいサービスコールを拒否し始め、HTTPステータス429で応答します。これは、リクエストが多すぎることを意味します。

そのようなシナリオでは、アプリのエクスペリエンスが優雅に劣化することを確認する必要があります。

まれに、サービスが異常な量のリクエストを行う場合、おそらくコードやインフラストラクチャのバグが原因で、HTTPステータス429を取得することもできます。

HTTP 429を受信するときは、単にリクエストを行う際に繰り返しループしないことが重要です。

より良いアプローチは、試行の合間に遅延を増やして再試行することです。

このアプローチは指数関数的なバックオフとして知られています。

それで、私たちは今日何を学びましたか?

4つの新しいサーバーAPIをリリースします。

これらのAPIは、ジオコーディング、リバースジオコーディング、検索、およびETAです。

これらのAPIをMapKitおよびMapKit JSと組み合わせて使用すると、Apple Mapsスタックを使用してアプリをよりよく設計するのに役立ちます。

Apple Maps Server APIを使用して、これらのタスクをバックエンドサーバーに委任することで、冗長で反復的な呼び出しを最適化できます。

これらのAPIの1日のクォータは25,000で、MapKit JSサービスの使用量と共有されます。

そして、それがあなたのための新しいApple Maps Server APIです。

ここで言及されている他のセッションと、以下にリンクされている詳細なドキュメントを必ずチェックしてください。

私たちは、あなたがそれらをどのように利用するかを楽しみにしています。

ありがとう！

♪