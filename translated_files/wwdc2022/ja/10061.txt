10061

♪まろやかなインストゥルメンタルヒップヒップミュージック♪

♪

みなさん、こんにちは。

SwiftUIチームのエンジニア、ジェフです。

今日は、iPadOSとmacOSのSwiftUIアプリに複数のウィンドウを導入することについてお話しできることを嬉しく思います。

このセッションでは、導入するいくつかの新しいタイプを含む、SwiftUIライフサイクルのさまざまなシーンタイプの概要を説明します。

続いて、補助シーンを追加して、これらのシーンタイプをどのように構成できるかを示します。

次に、アプリで特定のシーンのウィンドウを開くための新しいAPIをいくつか取り上げます。

そして、アプリのシーンをカスタマイズするためのいくつかの方法で物事をまとめます。

新しいシーンタイプを掘り下げる前に、既存のシーンタイプの概要から始めましょう。

以前のセッションから、SwiftUIのアプリはシーンとビューで構成されていることを思い出すでしょう。

シーンは通常、画面上のウィンドウで内容を表します。

例えば、これは私が読んでいる本を追跡するために作ったアプリです。

これは、プラットフォームに適した方法で私の読書リストを表示する単一のウィンドウグループとして定義されています。

iPadOSやmacOSなど、複数のウィンドウをサポートするプラットフォームでは、シーンはそのようないくつかのウィンドウで自分自身を表現できます。

シーンの動作と表現は、使用されるタイプによって異なります。

たとえば、シーンは、プラットフォームの機能に関係なく、単一のインスタンスでのみ表現できます。

SwiftUIのシーンタイプの現在のリストを見てみましょう。

WindowGroupは、Appleのすべてのプラットフォームでデータ駆動型アプリケーションを構築する方法を提供します。

DocumentGroupでは、iOSとmacOSでドキュメントベースのアプリを構築できます。

そして、設定は、macOSのアプリ内設定値を表すためのインターフェースを定義します。

これらのシーンタイプは、アプリの機能を拡張するために一緒に構成できます。

2つの新しい追加でシーンのリストを拡張しています。

1つ目はウィンドウで、すべてのプラットフォームで単一のユニークなウィンドウを表すシーンです。また、macOSの新しいシーンタイプ：MenuBarExtraは、システムメニューバーの永続的なコントロールとしてレンダリングされます。

他のシーンタイプと同様に、WindowとMenuBarExtraの両方をスタンドアロンシーンとして使用したり、アプリ内の他のシーンで構成したりできます。

WindowGroupとは異なり、ウィンドウシーンは、その内容を1つのユニークなウィンドウインスタンスでのみ表現します。

この特性は、シーンの内容が、macOSとiPadOSのWindowGroupsのマルチウィンドウプレゼンテーションスタイルに必ずしも適合しないグローバルなアプリの状態を表す場合に役立ちます。

たとえば、ゲームは、そのコンテンツをレンダリングするために単一のメインウィンドウのみを許可したい場合があります。

MenuBarExtraは、他のシーンとは少し異なる動作をする新しいmacOSのみのシーンタイプです。

ウィンドウに内容をレンダリングするのではなく、メニューバーにラベルを配置し、ラベルに固定されているメニューまたはウィンドウに内容を表示します。

さらに、そのアプリが最前面にあるかどうかに関係なく、関連するアプリが実行されている限り使用できます。

MenuBarExtraは、その機能に簡単にアクセスできるスタンドアロンのユーティリティアプリを作成するのに最適です。

または、アプリの機能にアクセスする別の方法を提供するために、他のシーンと構成することもできます。

また、メニューバーからプルダウンするメニューの内容を表示するデフォルトのスタイルと、メニューバーに固定されたクロムレスウィンドウに内容を表示するスタイルという2つのレンダリングスタイルもサポートしています。

これら2つの新しいシーンタイプを追加することで、SwiftUIアプリは、すべてのプラットフォームでさらに豊富な機能セットを表すことができます。

これらの新しいAPIを既存のシーンタイプと組み合わせてどのように使用できるかを見てみましょう。

これは私が以前に示した私のBookClubアプリの定義です。

現在、単一のウィンドウグループで構成されています。

macOSでは、私のBookClubアプリは、時間の経過とともに読書活動を表示するための追加のウィンドウの恩恵を受けることができます。

これは、macOSアプリがそのプラットフォームに存在する追加の画面の不動産と柔軟なウィンドウの配置をどのように活用できるかの素晴らしい例です。

このインターフェイスを表現するために、アプリに補助シーンを追加します。

アクティビティウィンドウのデータは、アプリ全体の状態から派生しているため、ウィンドウシーンが理想的な選択です。

同じ状態で複数の窓を開けると、私たちのデザインにはうまく収まりません。

シーンに提供されたタイトルは、ウィンドウメニューのセクションに追加されるメニュー項目のラベルとして使用されます。

この項目を選択すると、まだ開いていなくても、シーンのウィンドウが開きます。

そうでなければ、それは正面に持ち込まれるでしょう。

BookClubアプリに補助シーンを追加することを取り上げたので、追加している新しいシーンプレゼンテーションAPIのいくつかと、それらをアプリに統合してより豊かな体験を提供する方法について議論したいと思います。

BookClubアプリには、コンテンツリストペインの任意のブックに対して呼び出すことができるコンテキストメニューがあります。

このコンテキストメニューには、ウィンドウプレゼンテーションをトリガーするためのボタンが含まれます。

まもなく詳細を記入します。

SwiftUIは、アプリが定義するシーンに関連付けられたウィンドウを表示するための環境を介していくつかの新しい呼び出し可能なタイプを提供します。

1つ目はopenWindowアクションで、WindowGroupまたはウィンドウシーンのいずれかのウィンドウを表示できます。

アクションに渡される識別子は、アプリで定義されたシーンの識別子と一致する必要があります。

openWindowアクションは、提示されたシーンがその内容を表示するために使用するプレゼンテーション値を取ることもできます。

この形式のアクションは、まもなく確認する新しい初期化子を使用して、WindowGroupによってのみサポートされます。

値のタイプは、シーンの初期化子に提供されたタイプと一致する必要があります。

また、ドキュメントウィンドウを表示するための環境には、FileDocumentsとReferenceFileDocumentsの両方で新しいドキュメントウィンドウを開くことをサポートするnewDocumentアクションの2つの呼び出し可能なタイプもあります。

このアクションでは、アプリ内の対応するDocumentGroupがエディターの役割で定義されている必要があります。

このアクションに提供されたドキュメントは、ウィンドウが表示されるたびに作成されます。

ディスク上の既存のファイルによってコンテンツが提供されているドキュメントウィンドウを表示するには、openDocumentアクションがあります。

このアクションは、開きたいファイルのURLを取ります。

アプリはウィンドウを表示するためのDocumentGroupを定義する必要があり、そのグループのドキュメントタイプは、提供されたURLでファイルのタイプを読み取ることができる必要があります。

ボタンを再訪して、openWindow環境プロパティをビューに追加します。

このタイプは呼び出し可能なので、ボタンのアクションから直接呼び出すことができます。

私たちのブックタイプは識別可能なものに準拠しているため、提示する値としてその識別子を渡します。

さて、先に進む前に、openWindowアクションに渡された値について話し合いたいと思います。

UUIDタイプの値である本の識別子を渡していることに気づきました。

一般的に、値自体ではなく、モデルの識別子をこのように使用したいと思うでしょう。

ブックタイプは値タイプであることに注意してください。

そのため、提示された値として使用すると、新しいウィンドウはプレゼンテーションを開始したもののコピーを取得します。

どちらか一方の編集は、もう一方には影響しません。

本の識別子を使用すると、モデルストアは、単一の値に複数のバインディングを提供することで、代わりにこれらの値の真実の源になります。

値型セマンティクスの詳細については、開発者ドキュメントを参照してください。

提示されるタイプは、HashableプロトコルとCodableプロトコルの両方に準拠している必要があります。

提示された値を開いているウィンドウに関連付けるには、ハッシュ可能な適合性が必要です。状態復元のために提示された値を永続化するには、コード可能な適合性が必要です。

近いうちに、これらの両方の行動について詳しく説明します。

最後に、可能であれば、軽量値を渡すことを好みます。

私たちの本の識別子は、これのもう一つの素晴らしい例です。

値は状態復元のためにSwiftUIによって保持されるため、より小さな値を使用すると、アプリの応答性が向上します。

今、私たちのボタンは今、私たちの詳細ウィンドウを表示するために必要な部分を持っていますが、それが選択されると何も表示されません。

これは、SwiftUIに特定のデータタイプのウィンドウを表示するように指示したが、それを反映したシーンをアプリで定義していないためです。

私たちのアプリに戻って、今すぐその変更を加えましょう。

プライマリウィンドウグループと補助ウィンドウに加えて、本の詳細を処理するための追加のウィンドウグループを追加します。

私たちの本の詳細WindowGroupは新しい初期化子を使用しています。

タイトルに加えて、このグループはBook.IDタイプのデータを提示しています。私たちの場合はUUIDです。

このタイプは、先ほど追加したopenWindowアクションに渡す値と一致する必要があります。

プレゼンテーション用に指定された値がWindowGroupに提供されると、SwiftUIはその値の新しい子シーンを作成し、そのシーンのウィンドウのルートコンテンツは、グループのビュービルダーを使用してその値によって定義されます。

それぞれのユニークな提示された価値は、新しいシーンを作成します。

値の等価性は、新しいウィンドウを作成するか、既存のウィンドウを再利用できるかを判断するために使用されます。

openWindowがウィンドウがすでに存在する値を提示すると、グループは新しいウィンドウを作成するのではなく、そのウィンドウを使用します。

BookClubアプリを例として、すでにウィンドウに表示されているブックのコンテキストメニューアクションを選択すると、同じブックを表示する2番目のウィンドウではなく、そのウィンドウが前面に並べられます。

提示された値は、状態復元の目的でSwiftUIによって自動的に保持されます。

あなたのビューには、最初に提示された値へのバインディングが与えられます。

このバインディングは、ウィンドウが開いている間はいつでも変更できます。

状態復元のためにシーンが再作成されると、SwiftUIは最新の値をウィンドウのコンテンツビューに渡します。

ここでは、詳細ビューにBook.IDバインディングを与え、モデルストアで指定されたアイテムを検索して表示することができます。

すべての作品が整った状態で、コンテキストメニュー項目を選択し、独自のウィンドウで本の詳細を表示できるようになりました。

最後に、アプリでシーンをカスタマイズする方法をいくつか確認したいと思います。 では、いくつかのシーンをカスタマイズできますか？

メインビューアウィンドウ用と詳細ウィンドウ用の2つのWindowGroupシーンでアプリを定義したため、SwiftUIはデフォルトでファイルメニューに各グループのメニュー項目を追加します。

しかし、詳細ウィンドウのメニュー項目は、私たちのユースケースにはあまり合いません。

ウィンドウは、以前に追加されたコンテキストメニューからのみ開くことができることを望みます。

新しいシーン修飾子「commandsRemoved」を使用すると、ファイルメニューのようなデフォルトのコマンドを提供しなくなるようにシーンを変更できます。

この修飾子を適用した後、ファイルメニューには、プライマリウィンドウグループのウィンドウを開くための項目のみが含まれるようになりました。

私の読書活動を示すための補助ウィンドウシーンの現在のプレゼンテーションにはあまり満足していないので、次はそれに焦点を当てましょう。

いくつかの修飾子を適用するので、アプリの定義をよりクリーンに保つカスタムシーンに抽出します。 

ウィンドウの以前の状態がない場合、SwiftUIはデフォルトでそれを画面の中央に配置します。

ただし、読書アクティビティがデフォルトで別の場所に配置されている場合は、その方がいいと思います。

新しいdefaultPosition修飾子を追加することで、以前の状態が利用できない場合に使用する位置を指定できます。

この位置は画面サイズに相対的であり、現在のロケールを考慮してウィンドウを適切な場所に配置します。

この新しい位置は、私のアクティビティウィンドウを画面上の他の表示ウィンドウと区別するのに役立ちます。

また、アクティビティウィンドウをデフォルトで特定のサイズで表示したいのですが、それでもサイズ変更可能です。

defaultPositionと並んで、defaultSize修飾子を追加します。

提供された値は、レイアウトシステムに与えられ、ウィンドウの初期サイズを導き出します。

ウィンドウのプレゼンテーションをカスタマイズしたので、その動作をカスタマイズするためにもう1つの修飾子を追加しましょう。

keyboardShortcut修飾子は、シーンタイプでも機能するように拡張されました。

シーンレベルで使用すると、この修飾子は新しいウィンドウを作成するコマンドに影響します。

ここでは、ショートカットOption-Command-0で開くことができるように、アクティビティウィンドウを変更しました。

これは、一般的に使用されるシーンへのショートカットを提供することでアプリをカスタマイズする素晴らしい方法であり、アプリのプライマリWindowGroupに追加されるCommand-Nのデフォルトのショートカットをカスタマイズするためにも使用できます。

これにより、SwiftUIの新しいシーンとウィンドウ機能のツアーが終了します。

私たちはこれらの新しいAPIの可能性に本当に興奮しており、あなたもそうであることを願っています!

iPadOSとmacOSアプリに機能を追加する方法の詳細については、「iPadのSwiftUI：インターフェイスを整理する」と「iPadのSwiftUI：ツールバー、タイトルなどを追加する」という他のセッションをチェックしてください。

見てくれてありがとう。

♪