110404

♪インストゥルメンタルヒップホップ音楽♪

こんにちは、App StoreのCommerce Technical AdvocateのDavid Wendlandです。

今日は、顧客が行動を起こすことなく、顧客の新規、現在、過去の購入を積極的に特定することで、アプリがファーストクラスの体験を提供する方法を紹介します。

StoreKit 2とオリジナルのStoreKitでこれを行う方法について説明しますので、すべての顧客に対してアプリのオンボーディングエクスペリエンスを最適化できます。

積極的なアプリ内購入の復元を定義することから始めましょう。

これは、顧客がアプリを起動すると、デバイス上ですぐに利用可能なデータを使用して、新規または既存の顧客であるかどうかを判断するためにトランザクションを積極的にチェックし、「購入を復元」ボタンをタップしたり、パスワードを入力したりすることなく、顧客のアクションを必要とせずにそうすることを意味します。

これにより、アプリの経験は顧客の購入履歴と状態に合わせて調整できるため、アプリは現在の顧客向けの製品やサービスのロックを解除したり、アプリは最新の製品を新規顧客に提供したり、過去の購読者のために、サブスクリプションオファーを提示して取り戻すことができます。

これは、プロアクティブな復元であり、StoreKitを使用して、すべてのデバイスで新規、既存、過去の顧客のアプリのエクスペリエンスを自動的に最適化することです。

この例を見てみましょう。 

ここにオーシャンジャーナルアプリがあります。

これは一般的なマーチャンダイジング体験であり、顧客はいくつかの異なる行動の呼びかけから選択することができます。

アプリ内購入を購入してFaceIDなどのバイオメトリクスで認証するか、アプリアカウントを作成した場合は、サインインしてキーチェーンを使用してパスワードを入力するか、アクティブな加入者であると思われる場合は、「購入を復元」ボタンを使用できます。

新しいデバイスのアクティブな加入者にとって、どのオプションを選択するかを知ることは必ずしも明確ではありません。

また、アプリですぐに利用できるデータにより、このエクスペリエンスは、プロアクティブなアプリ内購入の復元のベストプラクティスで合理化できます。

したがって、私が新しいデバイスでこのアプリを起動したが、すでにアクティブな加入者であった場合、起動時に、アプリは私からのアクションを必要とせずに、自動的に私のサービスを積極的に復元します。

だから、ここでアプリは私のプロサブスクリプションを認識し、私のお気に入りのビーチをロードし、サーフコンディションを完了し、ライブカム機能を有効にしました。

この経験は、あなたのアプリを他のアプリと区別し、iOS 15以降のStoreKit 2でこれを行う方法について説明します。

さらに、アプリが以前のバージョンのiOSをサポートしている場合は、オリジナルのStoreKitとverifyReceiptエンドポイントで同じ素晴らしい体験を作成する方法について説明します。

その背景で、私がカバーするものは次のとおりです。

まず、アプリがStoreKitを使用した顧客のアプリ内購入に基づいてパーソナライズされたエクスペリエンスを生成するために使用するコア顧客製品の状態を詳細に説明します。

次に、StoreKit 2を使用して実装手順を確認し、SKデモアプリを使用してサンプルコードを完成させます。

各アプリ内購入タイプ、そのコア顧客製品の状態を見て、パーソナライズされたオンボーディングエクスペリエンスのいくつかの例を見てみましょう。

まず、プロアクティブな復元に適用されるアプリ内購入タイプは、非消耗品、非更新サブスクリプション、および自動更新サブスクリプションです。それらはすべて顧客の取引履歴に永続的であり、StoreKitで常に利用できます。

したがって、アプリは顧客ごとに各製品またはサブスクリプショングループの購入状態を識別できます。

非更新および自動更新サブスクリプションの場合、顧客の製品の状態を確認する際に、両方を参照するために「サブスクリプション」という用語を使用します。

アプリがパーソナライズできる3つのコアステートを以下に示します。

新規顧客を詳しく確認しましょう。

この状態は、現在または過去のアプリ内購入取引がない、サインインしているApp Store Apple IDを表します。

この状態は通常、アプリのデフォルトのマーチャンダイジングエクスペリエンスとして使用されます。

私たちのオーシャンジャーナルアプリは、1ヶ月の無料トライアルで月間および年間のサブスクリプションをマーチャンダイジングしています。

2番目のコア状態を見ると、購入とアクティブサブスクライバーがあります。

この状態では、顧客はアクティブなトランザクションを持ち、アプリは購入した製品またはサービスへのアクセスを顧客に与える義務があります。

ここでは、私たちのオーシャンジャーナルアプリは、すぐにプレミアムライブビーチカムで顧客に彼らの好みのビーチを提示します。

サービスが積極的に復元されたため、購入ボタンは表示されません。

購入した製品またはアクティブなサブスクリプションごとに、トランザクションには静的で一意の元のトランザクションIDがあり、顧客のApple IDとストアフロントに持続します。

顧客の取引のステータスを維持するために、元の取引IDをシステム上のアカウントに関連付けます。

匿名アカウントでも、ユーザーがシステムで作成したアカウントでもかまいません。

元のトランザクションIDを知ることは、App Storeサーバー通知の力を活用して、サーバーがトランザクションステータスを最新の状態に保つことを可能にする場合に重要です。

強調すべきシナリオの1つは、顧客のサブスクリプションが自動更新に失敗した場合です。したがって、請求再試行状態と呼ばれるもので、最大60日間サブスクリプションを回復しようとします。

App Store Connectの請求猶予期間機能をオプトインした場合、猶予期間で請求を再試行する加入者は、サブスクリプションを回復しようとする間、サブスクリプションサービスに引き続きアクセスできます。

そして、彼らがまだあなたのサービスにアクセスできる間、支払いの問題を解決するための簡単な行動を促すフレーズを必ず提示してください。

請求の再試行と請求猶予期間の詳細については、不本意な加入者の損失を減らすためのセッションリンクとリソースをご覧ください。

最終的なコア状態は、非アクティブな購入または非アクティブな加入者です。

この状態は、以前にアプリ内購入を行ったが、有効期限のため、または取り消された場合、その製品やサービスを受ける資格がなくなった顧客を表します。

これらのトランザクションは永続的であり、デバイスやプラットフォーム間でステータスを維持できる元のトランザクションIDが含まれています。

サブスクリプションの場合、非アクティブは有効期限によって決定されます。

また、すべてのアプリ内購入タイプについて、失効日がある場合、それらは非アクティブになる可能性があります。

これは、トランザクションが返金された場合、またはファミリー共有を通じて付与されたアクセスが取り消された場合に発生します。

非アクティブな加入者の場合、有効期限または取り消されたため、それらを取り戻すためにサブスクリプションオファーを提示することを検討してください。

また、請求再試行状態の人は、支払いの詳細を解決するための同じ行動を促すフレーズを提示することを忘れないでください。

レビューでは、アプリがアプリ内購入を積極的に復元し、アプリのエクスペリエンスを顧客に合わせて調整するために使用する3つのコア顧客製品の状態を以下に示します。

これらの経験がオーシャンジャーナルアプリと並んでどのように見えるかを見てみましょう。

新規顧客は、最新の製品提供と入門オファーを見るでしょう。

現在のアクティブな顧客は、アプリがすべてのデバイスで製品やサービスへのアクセスを合理化したため、それが機能していると感じるでしょう。

また、非アクティブな購読者には、オファーコードまたはプロモーションオファーを使用して、最新のウィンバックオファーを提示できます。

さて、私たちは3つのコア顧客製品の状態をカバーし、これらの状態をサポートするだけで顧客にとって大きな勝利です。

しかし、もちろん、経験をさらに進める機会があります。

アプリは、製品の提供、ビジネスモデル、ポリシー、および優先順位に合わせて、顧客体験を拡張または洗練することができます。

しかし、アプリにプロアクティブな復元を実装する準備をする際に考慮すべきことがいくつかあります。

複数の製品またはサブスクリプショングループをサポートしている場合、顧客の状態は各製品と各サブスクリプショングループごとに決定されます。

したがって、ハイブリッド状態やその他の依存関係を考慮する必要があるかもしれません。

プラットフォーム外でのアクティビティと、それが顧客の製品状態にどのように影響するかを検討してください。

また、すべてのアプリ内購入タイプについて、サーバーからサーバーへのステータスを維持するために不可欠であるため、App Storeサーバー通知を必ず確認してください。

また、バージョン2では、新しい通知タイプとサブタイプは28のユニークなイベントをサポートし、ほぼリアルタイムでサーバーに安全に送信されます。

セッション「アプリ内購入の統合と移行を探索する」で、バージョン2への統合または移行の詳細については、こちらをご覧ください。

アレックスとガブリエルは、StoreKit 2とオリジナルのStoreKitフレームワークとの互換性、およびベストプラクティスもカバーしています。

私たちは、サポートする顧客の製品の状態と、その経験が顧客にとってどのようなものになるかについて話し合いました。

では、実装の詳細について説明しましょう。

StoreKit 2を使用してプロアクティブな復元で更新したSKデモアプリを使用します。

SKデモアプリは、このセッションでダウンロード可能になることに注意してください。

アクティブなアプリ内購入のない新規顧客向けのSKデモのデフォルトエクスペリエンスを確認しましょう。

当社の製品を表示するには、「ショップ」ボタンをタップします。上部には、非消耗型アプリ内購入として利用可能な車の在庫があります。

そして、毎月の自動更新サブスクリプションとしてナビゲーションサービスがあり、顧客が選択できる3つの異なるレベルのサービスを提供しています。

そして、下には、1回限りのアクセスを提供する非更新サブスクリプションオプションがあります。

これは、製品が購入されていないときのアプリの新しい顧客体験をカバーしています。

それでは、私たちのアプリが、顧客が現在または過去の購入を持っているかどうかを判断する方法を見てみましょう。

アプリは、アプリの起動時にすぐに3つのステップを実行する必要があります。

最も重要なことは、「購入」ボタンが顧客に商品化される前に、これらの手順が完了することです。

最初のステップは、アプリがApp Storeからの取引をリッスンし始める必要があることです。

これは、ファミリー共有の購入依頼、コードの引き換え、サブスクリプションの自動更新、または購入が中断されたときなどの機能からいつでも取引が表示される可能性があるため、App Storeのベストプラクティスです。

さらに、アプリは、払い戻しのためにアクセスが失われたり、ファミリー共有を介して共有されなくなったりする、取り消されたトランザクションを受け取ることができます。

これは、アクセスがすでに許可され、その状態がアクティブから非アクティブに移行している場合、その後のアプリの起動でさらに適用されます。

トランザクションが見つかった場合、それらは未完了のトランザクションと見なされ、検証され、顧客に配信され、完了としてマークされる必要があります。

これにより、アプリがトランザクションを見逃すことはなく、優れた顧客体験を提供します。

それでは、SKデモアプリがStoreKit 2で取引をどのようにリッスンするかを見てみましょう。

ここでは、listenForTransactions関数を使用しています。

サインインしているApp Storeの顧客の未完了のトランザクションまたは更新が返されます。

見つかったトランザクションについては、ここで、StoreKit 2はこれらのトランザクションの真正性を検証します。

そして、私のアプリがコンテンツを配信したり、アクセスを許可したり、顧客の製品ステータスを更新したりした後、購入が配信されたことをApp Storeに示すために取引を終了します。

トランザクションが完了すると、StoreKitを介してどのデバイスでもアプリに返されなくなります。

その最初のステップは、すべてのアプリにとって重要であり、今後すべてのアプリの起動時に発生します。

ステップ2は、顧客の製品の状態を決定することであり、これはcurrentEntitlementsを使用して顧客のアクティブなトランザクションを積極的に要求することによって行われます。

また、特に自動更新サブスクリプションの場合、キャンセル、請求再試行、保留中のダウングレードなど、顧客の更新状態を説明するために、さらにProduct.SubscriptionInfo.RenewalStateを使用します。

SKデモアプリを見て、これをどのように達成するかを見てみましょう。

これは、永続的なアプリ内購入タイプごとに顧客の製品の状態を追跡する機能updateCustomerProductStatusから始まります。

次に、StoreKit 2のcurrentEntitlementsメソッドを使用して、各購入タイプをループします。

これは、顧客が権利を有する可能性のある製品の取引を返します。

そして、製品タイプごとにこれらの取引を記録します。

ここでは、非消耗品製品、非更新サブスクリプション製品です。

アクティブな加入者か非アクティブな加入者かを判断するために、非更新サブスクリプションの有効期限を計算するためのロジックを追加しました。

そして最後に、アクティブな自動更新サブスクリプションを確認し、その状態をサブスクリプショングループに適用します。

請求の再試行、期限切れ、取り消しなどの非アクティブな状態を説明するために、当社の可変サブスクリプショングループステータスはProduct.SubscriptionInfo.RenewalStateを使用します。ユーザーのトランザクションを取得して、各製品またはサブスクリプショングループの顧客ステータスを決定したので、当社のアプリには、さまざまなユースケースのアプリエクスペリエンスをパーソナライズするロジックがあります。

SKデモアプリのソースコードを見てみましょう。 では。

3つのアプリ内購入製品タイプすべてでアクティブなトランザクションが決定されない場合、顧客は先ほどレビューしたデフォルトの新しい顧客体験が表示され、「ショップ」ページへの簡単な行動を促すことができます。

お客様が有効な購入を行った場合、アプリの起動時に購入が表示され、それに応じてすべての製品の「購入」ボタンが更新されます。

したがって、ここでは非消耗品については、彼らが購入したものを提示し、アプリは購入した非消耗品を表示するか、アプリは顧客がショップ体験を訪問するための行動を促すフレーズを提供します。

アクティブな製品については、お客様が非更新サブスクリプションおよび自動更新サブスクリプションのナビゲーションサービスのアクティブな加入者であるかどうかをここで処理します。

そして、最後の部分では、非アクティブな加入者を考慮しています。

サブスクリプションの有効期限が切れているもの、取り消されたもの、または請求再試行状態にあるもの。

さて、それではSKデモアプリに行きましょう。

非消耗型サブスクリプションと自動更新サブスクリプションの両方でアクティブな顧客をシミュレートしたいと考えています。

したがって、レースカーを購入し、プロナビゲーションを購読すると、デモアプリは緑色のチェックマークを適用して、アプリがそれらの購入が成功したことを確認し、検証し、有効にしたことを示します。

これらの購入では、非消耗品の顧客製品の状態が購入されます。

そして、私たちのサブスクリプションのために、私はアクティブな購読者です。

さて、新しいデバイスにアプリをインストールすると、SKデモアプリを初めて起動すると、ステップ1、2、3を積極的に実行します。

ここでは、私たちのデモアプリが、私からのアクションなしに、私の両方の購入へのアクセスを積極的に復元したことがわかります。

これはデモアプリなので、それが配信される製品の範囲です。

しかし、あなたのアプリでは、このプロセスにより、これらのアクティブな顧客には、すでに所有している製品を購入する製品が提供されず、それらの製品やサービスが自動的に有効になります。

あなたの現在の顧客にとって、これは素晴らしいことです。

お客様がサインインしたり、「購入を復元」をタップしたりする必要はありません。

それはちょうどうまくいった。

アプリは、すぐに利用できるAPIとデータを使用できます。

そこで、StoreKit 2でこれを行うための3つのステップを取り上げました。

さて、StoreKit 2のパワーを活用できない以前のバージョンのiOSで、この同じエクスペリエンスを顧客に実装する方法について議論したいと思います。

オリジナルのStoreKitでは、StoreKit 2と同じ手順を実行して、iOS 7以降でアプリ内購入を積極的に復元することで、顧客の製品の状態を判断します。

これを行うには、サーバーがverifyReceiptエンドポイントを使用して、顧客の製品状態を判断するために最新のトランザクションを検証および取得する必要があります。

アプリの領収書は、アプリがApp Storeからインストールされたときにデバイス上に存在します。

しかし、SandboxまたはTestFlightでテストする場合、アプリの領収書はアプリ内購入が完了または復元された後にのみ存在することを覚えておいてください。

アプリにアプリの領収書が見つからない場合、これはサンドボックスでのみ発生し、アプリはこのシナリオをアプリ内購入が見つからない新規顧客と同じと見なすことができます。

過去に作成されたアプリの領収書は、App Storeから最新のトランザクションを取得するのに十分です。

したがって、「Restore Purchase」やreceiptRefreshのような顧客の行動は必要ありません。

非消耗品、非更新サブスクリプション、および自動更新サブスクリプションの取引を受信するために、verifyReceiptのリクエストに共有秘密を含めるだけです。

先ほどレビューした3つの実装ステップを振り返ってみましょう。

違いは、顧客の製品の状態を特定するステップ2にあります。

顧客の製品の状態を判断する方法は、デバイス上のアプリレシートから始まり、サーバーはApp Store verifyReceiptエンドポイントで検証されます。

このプロセスを見てみましょう。 

まず、アプリレシートを取得し、開発者ドキュメントのこのサンプルでわかるように、appStoreReceiptURLプロパティを使用していることを確認する必要があります。

アプリの領収書で、これがデバイスからサーバーとApp Storeにどのように送信されるかを見てみましょう。

デバイス上のアプリは左側にあります。

まず、アプリのレシートを取得してサーバーに送信し、App Store verifyReceiptエンドポイントで検証します。

その応答から、顧客の製品の状態を決定し、それらの状態をアプリに送信します。

お客様の製品の状態を判断するために、WWDC2020のエンタイトルメントエンジンを使用しました。

非消耗品と非更新サブスクリプションをサポートするように更新され、アプリ内購入がない場合に新しい顧客状態を処理するようになりました。

エンタイトルメントエンジンの使用の詳細については、「サブスクリプションのアーキテクチャ」セッションをチェックして、サンプルプロジェクトをダウンロードすることをお勧めします。

このビデオのリソースで、このセッションへのリンクなどを見つけることができます。

これにより、アプリがサーバーから顧客製品の状態を受け取るステップ2が完了します。

これで、アプリはStoreKit 2とオリジナルのStoreKitフレームワークを使用して、起動時にすぐにアプリ体験をパーソナライズします。

私はいくつかの最終的なベストプラクティスを共有したい。

まず、アプリ内で「購入を復元」ボタンを提供し続けます。

頻繁には使用されませんが、問題が発生した場合、または顧客が別のApple IDを使用している場合に、アプリにApple IDの取引を強制的に復元する機会を顧客に提供します。

アプリが最初にデバイスの顧客のアプリ内購入を積極的に復元するときは、アプリを最適化し、データを安全に保存して、顧客の製品の状態を判断するのに役立つことをお勧めします。

CloudKitは、その柔軟性、セキュリティ、および顧客のデバイス間で同期する機能で考慮すべき機能です。

StoreKitを使用する場合は、実装をテストすることが重要です。

また、StoreKit 2を使用すると、Sandbox、TestFlight、Xcode StoreKitテストを使用して、プロアクティブな復元実装をテストできます。

また、オリジナルのStoreKitを使用している場合は、アプリがApp Storeからインストールされたときに常に存在している間、SandboxとTestFlightでテストするときにアプリの領収書が存在しない可能性があることを覚えておくことが重要です。

アプリの領収書がない場合は、アプリがデフォルトの新しい顧客体験を使用し、購入の復元ボタンをすぐに利用できることを確認することをお勧めします。

結論として、アプリの更新は、顧客の行動、タップ、認証なしで購入を積極的にチェックします。

アプリが起動時にすぐに顧客体験を調整できるようにして、新しい、アクティブ、および非アクティブな顧客の製品の状態に合わせてください。

App Storeサーバー通知バージョン2を実装することにより、すべてのアプリ内購入タイプについて、すべての顧客のトランザクション、サーバー間、サーバー間のステータスを維持します。

これにより、バックエンドは、払い戻し、取り消されたトランザクション、サブスクリプションの更新、請求の再試行、有効期限など、トランザクションで発生した変更をほぼリアルタイムで知ることができます。

ご覧いただきありがとうございます。この追加セッション「アプリ内購入の新機能」を必ずチェックしてください。ここでは、ダニとイアンがStoreKit、サーバーAPI、サーバー通知バージョン2のすべての素晴らしいアップデートについて説明します。

ありがとうございます。気をつけて。

♪ ♪