110360

♪ ♪

こんにちは！私の名前はトムで、アップルのスウィフトチームの一員です。

今日は、iOSアプリケーションをクラウドに拡張するために必要なことを共有したいと思います。

私たちのアプリケーションの多くは、単一のデバイス、通常はiPhoneに焦点を当てて始まります。

使用量が増えるにつれて、Mac、時計、その他のAppleプラットフォームやデバイスなどの追加のデバイスに持ち込みたいと考えています。

Xcodeは、これらのプラットフォーム用のアプリケーションを整理して構築するのに役立ちます。

プラットフォーム固有のアプリケーションコードで各デバイスのユニークな側面を取り入れながら、パッケージを使用してコードを共有できます。

システムが成長し進化し続けるにつれて、アプリケーションは多くの場合、サーバーコンポーネントでクライアントアプリケーションを補完する必要があります。

これらのサーバーコンポーネントは、クライアントアプリケーションがその機能をクラウドに拡張することを可能にします。

たとえば、バックグラウンドで実行できるタスクのオフロード、計算上の重いタスクのオフロード、またはデバイスで利用できないデータへのアクセスを必要とするタスクなどです。

多くの場合、サーバーコンポーネントは、クライアントとは異なるツールや方法論を使用して構築する必要があり、重複作業と統合の課題が生じます。

サーバーコンポーネントの構築にSwiftを使用すると、このテクノロジーのギャップを埋めるのに役立ち、スタック全体に使い慣れた環境を提供します。

Swiftでのサーバーアプリケーションの構築がどのようなものか見てみましょう。

サーバーアプリケーションはSwiftパッケージとしてモデル化されています。

このパッケージは、アプリケーションのエントリポイントをマッピングする実行可能ターゲットを定義します。

アプリケーションをWebアプリケーションにするには、コードを構造化し、ルーティングなどの基本的なユーティリティを提供するWebフレームワークへの依存関係を追加できます。

この例では、Webサービスの構築に人気のあるオープンソースのコミュニティプロジェクトであるVapor Webフレームワークを使用しています。

他のSwiftベースの実行可能ファイルと同様に、プログラムのエントリポイントは@mainアノテーションを使用してモデル化するのが最善です。

Webフレームワークを統合するために、関連するブートストラップコードをメイン機能に追加します。

この例で使用されているアプリケーションタイプは、Vapor Webフレームワークによって提供されます。

基本的なブートストラップを導入することで、アプリケーションに何か便利なことをさせることができます。

たとえば、サーバーにリクエストを行うユーザーに挨拶するコードを追加しましょう。

Webフレームワークを使用してHTTPエンドポイントを定義し、挨拶を提供するメソッドにポイントします。

さらに一歩進んで、2番目のHTTPエンドポイントを追加します。これはHTTPポストリクエストを処理し、リクエストボディの内容を発信者にエコーします。

これを実際に見てみましょう。

ここにはXcodeのサーバーアプリケーションがあります。

始めたばかりなので、自分のマシンでサーバーをローカルに実行してテストすることができます。

ローカルで実行するには、Xcodeによって生成された「MyServer」スキームを選択し、「My Mac」を宛先として使用し、「実行」を押します。

アプリケーションが起動したら、Xcodeコンソールを使用して、サーバーから発行されたログメッセージを調べることができます。

この場合、サーバーがローカルホストアドレス(127.0.0.1)ポート8080で起動し、リッスンしていることがわかります。

この情報を使用してサーバーをテストできます。

ターミナルに切り替えて、広告されたサーバーアドレスにリクエストをしましょう。

「Curl」というユーティリティを使用してリクエストを行います。

最初のエンドポイントを使用してください。

そして、私たちの2番目。

エコーにいくつかのデータを渡します。

いいね！

ターミナルを使うのは確かに楽しかったですが、私たちが本当に知りたいのは、iOSアプリからサーバーを呼び出す方法です。

それを掘り下げてみましょう。

以下は、サーバーとの相互作用を抽象化するために使用できるSwiftデータ構造の例です。

ネットワークは本質的に非同期であるため、サーバーAPIを抽象化の非同期メソッドとしてモデル化します。

URLSessionを使用して非同期要求を行い、サーバーの応答を解析し、最後に呼び出し元に返します。

この場合、サーバーの応答はプレーンな文字列ですが、実際にはより洗練されている可能性があります。

たとえば、応答はJSONでエンコードされる可能性があり、その場合、SwiftのCodableシステムを使用してデコードできます。

これをすべてXcodeにまとめましょう。

Xcodeワークスペースを使用して、iOSとサーバーアプリケーションを並べて構築およびテストしています。

私たちはすでにiOSアプリケーションサーバーの抽象化の準備ができています。

デフォルトのSwiftUI ContentViewを変更して、まとめたコードを使用してサーバーの挨拶を取得しましょう。

まず、serverGreetingという状態変数を作成します。

次に、serverGreetingをテキスト表示にバインドします。

最後に、サーバーAPIを呼び出すタスクを追加し、状態を設定します。

コードの準備ができたら、シミュレータでアプリケーションを実行できます。

「MyApp」スキーム、シミュレーターを選択し、「実行」を押します。

ああ、いや！エラーが発生しました!

うーん、これはある種の接続エラーのようです。

アドレスは正しいように見えるので、ローカルサーバーを起動するのを忘れたに違いない。

Xcodeに戻り、サーバースキームを選択し、サーバーを実行しましょう。

さあ、アプリケーションを再起動して、幸運を祈りましょう...

そして、フーフー！うまくいった！

デモのこの部分を完了するために、アプリケーションをクラウドにデプロイしましょう。

AWS、Google Cloud、Azure、Herokuなど、多くのクラウドプロバイダーから選択できます。

この例では、Herokuを使用します。

Herokuは、このデモアプリケーションのような小さなプロジェクトのためのシステムを展開するための便利なgitプッシュを持っています。

ターミナルに切り替えて展開を開始しましょう。

アカウントを設定し、Herokuサービスでアプリケーションを設定した後、コードをHerokuリモートにプッシュすることができます。

そして、それは行きます!

Herokuは、ビルドパックと呼ばれる技術を使用してアプリケーションをリモートでコンパイルし、バイナリアーティファクトを一時的なホストにデプロイします。

Heroku swift buildpackは、Swiftオープンソースコミュニティのメンバーによって構築され、すべてのSwift on Serverユーザーが利用できます。

アプリケーションをデプロイすると、ローカルサーバーで行ったように、curlを使用してテストできます。

最初のエンドポイントをテストしましょう。

ここに住所をコピーしてください。

そして、私たちの2番目。

今回は、別のペイロードを送信します。

スウィート、私たちのアプリケーションは正常に展開されました!

続ける前に、ここで一時停止して、トークのこの部分からの主なポイントを確認しましょう。

すでにSwiftを使用してiOSまたはmacOSアプリケーションを構築している場合は、システムのサーバー側の開発にも使用できます。

Xcodeは、クライアントとサーバーの両方のシステムのさまざまなコンポーネントを1つのワークスペースで開発およびデバッグするのに役立ちます。

そして最後に、Swiftベースのサーバーアプリケーションを展開するためのクラウドプロバイダーを選択できます。

これらのクラウドプラットフォームへの展開に関する追加情報は、swift.orgのSwift Serverのドキュメントに記載されています。

基本的なセットアップを見たので、より現実的な例を見てみましょう - フードトラック!

あなたはおそらく、私たちのセッションの多くでこのアプリケーションが使用されているのを見たことがあるでしょう。

ボンネットの下を覗いて、データがどのように管理されているかを見てみましょう。

うーん、ドーナツリストはハードコード化されているようです。

これは、アプリケーションのユーザーが実際に利用可能なものとは異なるドーナツのメニューを見る可能性があることを意味します。

これは、その場であらゆる種類のドーナツを作ることができる小さなフードトラック操作に役立つかもしれませんが、メニューが一元化され、トラックがすべて顧客サービスに関するドーナツ帝国を構築したいと考えています。

一元化されたフードトラックシステムがどのように見えるかを設計しましょう。

私たちは、インメモリストレージを備えたiOSアプリから始めています。

メニューを一元化するために、iOSアプリからストレージを抽出してサーバーに移動できます。

これにより、アプリのすべてのユーザーが同じストレージを共有できるため、同じドーナツメニューを共有できます。

トークの最初の部分の例と同様に、私たちのサーバーはHTTPベースのAPIを公開します。

iOSアプリは、これらのAPIを操作するために抽象化を使用し、この例ではSwiftUIのプレゼンテーション層に結び付けます。

私たちのデザインは完成しました。

甘いコードを書く時間です。

開発者リソースキットからフードトラックのサンプルアプリをダウンロードすることで、フォローできます。

アプリケーションスケルトンを使用してサーバーの構築を開始し、「donuts」Web APIのHTTPエンドポイントを定義し、サーバー抽象化の「listDonuts」メソッドにポイントします。

APIがDonutsタイプのResponseを返し、Response.DonutsがContentと呼ばれるプロトコルに準拠していることに気付いたかもしれません。

コンテンツプロトコルはWebフレームワークによって定義され、応答をワイヤ上のJSONとしてエンコードするのに役立ちます。

また、APIには神秘的なモデルの配列が含まれていることに気づいたかもしれません。ドーナツ、私たちはまだ定義していないので、ここに、その栄光のすべてのデータモデルがあります：ドーナツ、生地、グレーズ、トッピング。

ここで興味深い点の1つは、サーバーとクライアントのデータモデルを大まかに整列させる必要があるため、フードトラックiOSアプリからこのモデルの定義をコピーしたことです。

もう1つの興味深い点は、Encodableプロトコルへの準拠です。

これは、サーバーがモデルオブジェクトをワイヤ上でJSONとしてエンコードできるようにする必要があります。

データモデルと基本的なAPIを導入することで、ロジックを拡張してストレージの抽象化を含めることができます。

ストレージは、利用可能なドーナツのリストをアプリケーションに提供します。

この時点で、私たちは完全に機能するサーバーを持っているはずです。

でも待って！私たちのドーナツメニューは空です!

集中メニューはどこから入手できますか？

サーバー側のアプリケーションを設計するとき、ストレージは常に興味深いトピックです。

ユースケースに応じて、いくつかの戦略から選択できます。

アプリケーションデータが静的である場合、または非常にゆっくりと手動で変更される場合、ディスク上のファイルは十分な解決策を提供する可能性があります。

ユーザー中心のデータまたはグローバルデータセットの場合、iCloudは、専用サーバーを展開せずに、iOSアプリケーションから直接使用できる一連のAPIを提供します。

動的データまたはトランザクションデータを扱う場合、データベースは優れたソリューションを提供します。

サーバーサイドアプリケーションには、さまざまなデータベース技術が用意されています。

各テクノロジーは、特定のパフォーマンス、データの一貫性、およびデータモデリングのニーズに合わせて設計されています。

長年にわたり、Swiftオープンソースコミュニティは、ほとんどのデータベース技術とネイティブに対話するのに役立つデータベースドライバを開発しました。

部分的なリストには、Postgres、MySQL、MongoDB、Redis、DynamoDBなどが含まれます。

このデモを簡素化するために、静的ファイルストレージ戦略のみを実演しますが、swift.orgのSwift Serverドキュメントでデータベースの使用について詳しく知ることができます。

静的ファイルストレージ戦略を使用しているため、ドーナツメニューをキャプチャするJSONファイルを作成することから始めます。

このファイルを作成した後、SwiftPMのリソースサポートを使用してアプリケーションにアクセスできるようにします。

それがあれば、ストレージの抽象化をより洗練されたものにする時が来ました。

つまり、「ロード」メソッドを追加します。

このメソッドは、SwiftPMの生成されたリソースアクセサを使用してリソースファイルパスを検索し、FileManager APIを使用してファイルの内容をメモリにロードします。

最後に、JSONDecoderを使用して、JSONコンテンツをサーバーアプリケーションデータモデルにデコードします。

興味深い変更の1つは、ストレージがアクターとして定義されていることです。

ストレージには変更可能な「ドーナツ」変数があり、「load」メソッドと「listDonuts」メソッドが同時にアクセスする可能性があるため、アクターを使用することを選択しました。

Swift 5.5で最初に導入されたアクターは、データレースを回避し、安全で簡単な方法で共有ミュータブル状態に対処するのに役立ちます。

アクターの導入前に、ロックやキューなどのAPIを使用して変更可能な状態にアクセスするときに、同期ブロックを記憶して追加する必要がありました。

ストレージの更新が完了すれば、それをすべて結びつけることができます。

サーバーの抽象化に「ブートストラップ」メソッドを追加し、そこからストレージをロードします。

次に、ブートストラップを実行可能ファイルのエントリポイントに配線します。

ストレージはアクターになったため、非同期コンテキストでアクセスすることに注意してください。

私たちのサーバーは準備ができています。

クライアント側に切り替えましょう。

まず、サーバーAPIをカプセル化するのに役立つサーバーの抽象化を追加することから始めます。

URLSessionを使用してHTTPリクエストを作成し、JSONDecoderを使用してサーバーの応答をデコードし、JSONからiOSアプリケーションモデルに変換します。

この時点で、ハードコードされたメニューを削除して、サーバーからの非同期フェッチに置き換えることができます。

最後に、ContentViewロードタスクからサーバーに呼び出します。

テストの時間だ！

今回は、サーバーを起動することを忘れないでください。

ここで「FoodTruckServer」スキームを選択します。

ヒットラン。

そして、アプリケーションが実行されているので、ターミナルにジャンプして、APIにアクセスできるようにしましょう。

住所をもう一度コピーしてください。

今回は、jqというユーティリティを使用して、JSON出力をよりきれいに印刷します。

これはかなり良さそうです。

さて、私たちのアプリでテストする時間です。

Xcodeに切り替えます。

ここでフードトラックスキームを選んでください。

シミュレーター。

そして、それを実行します。

そして、そこには、私たちの集中メニューから3つのドーナツがあります。

サーバーから見たものとそれを相互参照することができます。

ターミナルに戻りましょう。

比較を簡単にするために、jqを使用してドーナツの名前だけを照会します。

ディープスペース、チョコレート2、コーヒーキャラメル-まさに私たちが期待していたものです。

すごかった！

しかし、私たちはさらに良くすることができます。

現状では、当社のサーバーとクライアントアプリケーションはどちらもデータモデルコードの同一のコピーを持っています。

iOSとサーバーアプリケーション間でモデルを共有することで、繰り返しを避け、シリアル化をより安全にすることができます。

これを高いレベルで設定する方法を確認しましょう。

まず、「共有」という名前のライブラリの別のパッケージを作成し、Xcodeワークスペースに追加します。

次に、ターゲットフレームワークとライブラリの設定を使用して、データモデルコードを共有パッケージに移動し、サーバーアプリケーションの依存関係として、およびiOSアプリケーションの依存関係として共有を追加できます。

その時点で、クライアントコードをリファクタリングして共有モデルを使用し、サーバーコードにも同じことをすることができます。

今、物事はずっと良く見えます。

締めくくる前に、次にアプリケーションをどこに持っていくことができるかについてのアイデアがいくつかあります。

集中型サーバーがあるという事実を最大限に活用するために、メニューからドーナツを追加、編集、または削除するためのAPIを望み、定義する可能性があります。

これには、ストレージを静的ファイルからデータベースに移動する必要があります。

データベースを導入することで、購入および注文APIを実装することもできます。

このようなAPIは、ドーナツビジネスの収益化に役立ちます。

また、あまり人気のないドーナツの販売や割引など、動的な価格設定を実装するために使用できるシグナルも提供します。

機会は無限大です。

最後に、このセッションでは、Swiftが汎用言語であり、クライアントとサーバーアプリケーションの両方に有用であることがわかります。サーバーとクライアントアプリケーション間でコードを共有すると、ボイラープレートを減らし、システムのシリアル化をより安全にすることができます。URLSessionは、サーバーと非同期に対話するための重要なツールであり、最後に、Xcodeはシステム全体の強力な開発環境です。

ご覧いただきありがとうございます。残りの会議を楽しんでください。