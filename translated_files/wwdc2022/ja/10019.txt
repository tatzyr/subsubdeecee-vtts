10019

♪インストゥルメンタルヒップホップ音楽♪

♪

こんにちは、私はアレハンドロです。

私はCreateMLチームのエンジニアです。

今日は、コンポーネントを使用して機械学習モデルを構築するためのまったく新しいAPIについて話します。

Create MLは、機械学習モデルをトレーニングするためのシンプルなAPIを提供します。

これは、画像分類、音声分類など、サポートされている一連のタスクに基づいています。

WWDC 2021では、Create MLフレームワークに関する2つの素晴らしい講演を行いました。

まだチェックしていない場合は、必ずチェックしてください。

しかし、私は事前に定義されたタスクを超えることについて話したいと思います。

Create MLが提供するものを超えて、特定の問題に合わせてタスクをカスタマイズしたい場合はどうなりますか?

または、別のタイプのタスクを構築したい場合はどうなりますか?

コンポーネントを使用して、新しい創造的な方法でタスクを作成できるようになりました。

掘り下げましょう。

MLタスクを分割し、各コンポーネントが何をするかを説明することから始めます。

次に、コンポーネントをつなぎ合わせる方法について話します。

カスタム画像タスクの例が続きます。

次に、表形式のタスクについて話します。

そして、私は展開戦略で終わります。

機械学習タスクの内部を探求することから始めて、何が入り、どのように機能するかを理解しましょう。

このようにして、カスタムタスクを構築し始めるとき、あなたは私が何を言っているのか知っています。

例として画像分類器を使います。

画像分類器は、ラベル付き画像のリストを使用してモデルをトレーニングします。

この例では、それぞれのラベルが付いた猫と犬の画像があります。

しかし、各ステップで画像がどのように変換されるかを探りましょう。

これを行うには、画像分類タスクを展開して、中身を確認します。

概念的には、画像分類器は非常に簡単です。

これは、特徴抽出器と分類器で構成されています。

しかし、重要な部分は、Create MLコンポーネントがこれらのコンポーネントに独立してアクセスできるということです。

コンポーネントを追加、削除、または切り替えて、新しいタスクを作成できます。

コンポーネントをボックスとして表現します。

矢印はデータの流れを表しています。

画像分類器の最初のステップである特徴抽出にズームインしましょう。

一般的に、特徴抽出器は、興味深い部分、つまり特徴のみを保持することで、入力の次元を減らします。

画像の場合、特徴抽出器は画像内のパターンを探します。

Create MLは、Vision Frameworkが提供する優れた画像機能抽出器であるVision Feature Printを使用しています。

さて、2番目の作品、分類器について話しましょう。

分類器は、一連の例を使用して分類を学習します。

いくつかの一般的な実装は、ロジスティック回帰、ブーストツリー、およびニューラルネットワークです。

したがって、画像分類器のトレーニングは、注釈付き画像から始まり、注釈付き機能に行き、分類器で終わります。

しかし、なぜ私たちはそれを粉々にしたいのですか?

その理由は、可能性を広げたいからです。

コントラストを増やして前処理をしたいのかもしれません。

または、機能を抽出する前に、すべての画像を均一な明るさになるように正規化したいかもしれません。

あるいは、別のフィーチャー抽出器を試してみたいかもしれません。

あるいは、別の分類器を試してみたいかもしれません。

可能性は無限大です。

これらはオプションのほんの一部です。

そのため、macOS、iOS、iPadOS、tvOSでMLコンポーネントのサポートを追加しました。

私たちの希望は、私たちが独自のコンポーネントと一緒に提供するコンポーネントの一部、またはコミュニティの他の人によって構築されたコンポーネントを使用して、新しいモデルを作成できることです。

そして、あなたは私たちのすべてのプラットフォームでそれを活用することができます。

以下は、Create ML Componentsに組み込まれているコンポーネントの一部です。

しかし、一歩下がって、いくつかの概念を紹介しましょう。

コンポーネントには、変圧器と見積もりの2種類があります。

トランスフォーマーは、単に何らかの変換を実行できるタイプです。

入力タイプと出力タイプを定義します。

たとえば、画像機能抽出器は、入力画像を取り、形状形状の特徴の配列を生成します。

一方、見積もりはデータから学ぶ必要があります。

入力例を取り、いくつかの処理を行い、変圧器を生成します。

私たちはこのプロセスを「フィッティング」と呼んでいます。

すごい。これらの概念を邪魔にならないように、Create ML Componentsを使用すると、コンポジションを使用して個々のコンポーネントから画像分類器を構築する方法について説明しましょう。

これは、コンポーネントを使用した画像分類器です。

特徴抽出器としてImageFeaturePrint、分類器としてLogisticRegressionClassifierがあります。

コンポーネントがトランスフォーマーか見積もりかにかかわらず、追加方法を使用してそれらを組み合わせます。

そして、これはコンポーネントが無限の可能性を提供する場所です。

簡単な変更でロジスティック回帰ではなく、完全に接続されたニューラルネットワークを分類器として使用できます。

または、CoreMLモデルでカスタム機能抽出器を使用することもできます。

たとえば、ヘッドレスResNet-50モデルは、モデルギャラリーで見つけることができます。

2つのコンポーネントを構成する場合、最初のコンポーネントの出力は2番目のコンポーネントの入力と一致する必要があります。

画像分類器の場合、フィーチャーエクストラクタの出力は、CoreMLフレームワークからの形状の配列です。

これは、ロジスティック回帰分類器の入力でもあります。

追加メソッドを使用するときにコンパイラエラーが発生した場合、これは最初に確認するものです。

タイプが一致していることを確認してください。

しかし、フィッティングに関する重要な点を明確にさせてください。

私は前に、フィッティングは見積もりから変圧器に行くプロセスだと言いました。

これを構成された推定者の観点から見てみましょう。

画像分類器の場合のように、構成された推定器がトランスと推定器の両方を持っている場合、推定器のピースのみが取り付けられます。

しかし、変圧器は、推定器の適合方法に正しい特徴を供給するために使用されるため、プロセスの重要な部分です。

これがコードです。

画像分類器には、特徴が画像であり、注釈が文字列である注釈付き機能のコレクションが必要です。

デモに入るときに、機能の読み込みについて話します。

データを取得したら、フィットメソッドを呼び出すことができます。

これは、訓練されたモデルである変圧器を返します。

また、フィッティング時に使用されるタイプは関連しているが、結果の変圧器のタイプとは異なることに注意することが重要です。

特に、適合メソッドで使用されるタイプは常にコレクションです。

また、監督された見積もりの場合、機能には注釈を含める必要があります。

Create ML Componentsは、AnnotatedFeatureタイプを使用して、その注釈とともに機能を表します。

モデルを手に入れたら、予測をすることができます。

装着したばかりのモデルなのか、それともディスクからパラメータをロードしているのかは関係ありません。

APIはどちらの場合でも同じです。

私は分類器を訓練しているので、結果は分類分布です。

分布には、各ラベルの確率が含まれています。

この場合、画像の最も可能性の高いラベルを印刷しているだけです。

適合メソッドは、検証メトリックを含むトレーニングイベントを観察するメカニズムも提供します。

この例では、検証データを渡し、検証精度を印刷しています。

監視対象の見積もりのみが検証メトリックを提供することに注意してください。

モデルをトレーニングしたら、学習したパラメータを保存して、後で再利用するか、アプリにデプロイすることができます。

書き込みメソッドを使用してこれを行います。

後で、readメソッドを使用して読むことができます。

そして、それは構図です。

ここが面白くなるところです。

Create MLが今までサポートしていなかった新しいタスクを書くことについて話しましょう。

画像を採点するためにモデルを訓練したい場合はどうなりますか?

あなたが果物の写真を持っているとしましょうが、果物を分類する代わりに、あなたはそれを評価したいと思いました。

熟度に基づいてスコアをつけてください。

これを行うには、分類の代わりに回帰を行う必要があります。

だから、熟度に基づいてバナナの画像にスコアを与える画像回帰を書いてみましょう。

各画像に1から10の間の熟度値を与えます。

画像回帰器は画像分類器と非常によく似ています。

唯一の違いは、推定値が分類器ではなく回帰者になることです。

すでに推測しているかもしれませんが、これは簡単でしょう。

あなたの記憶をリフレッシュするために、ここに私たちの画像分類器があります。

そして、これは画像回帰です。

ロジスティック回帰分類器を線形回帰器に置き換えました。

この単純な変更により、予想される入力が適合メソッドにも変更されます。

以前は、画像とラベルを期待していました。

今、それは画像とスコアを期待しています。

しかし、概念については十分です。

実際のコードでこれをデモさせてください。

カスタム画像回帰の書き方をお見せしましょう。

コードをカプセル化するためにImageRegressor構造体を定義することから始めます。

私はさまざまなレベルの熟度にあるバナナの画像が入ったフォルダを持っています。

そのURLを定義することから始めます。

次のステップは、列車の方法を追加することです。

これは、トレーニングデータを使用してモデルを作成する場所です。

構成された見積もりでステップを追加または変更しても戻り値が変更されないように、戻り値の型に「some」キーワードを使用します。

さて、見積もりを定義します。 見積もりを定義します

これは単に線形回帰器が追加された特徴抽出器です。

そして今、私は彼らのスコアでトレーニング画像をロードする必要があります。

URLと文字列ラベルを含むAnnotatedFeaturesのコレクションであるAnnotatedFilesを使用できます。

それは私のニーズに合った便利な初期化子を提供します。

私のファイルは、名前の後にダッシュ、そして熟度値が続きます。

したがって、セパレータはダッシュで、注釈はファイル名コンポーネントのインデックス1にあることを指定します。

また、type引数を使用して画像ファイルのみをリクエストします。

URLがわかったので、画像をロードする必要があります。

これを行うには、mapFeaturesメソッドとImageReaderを使用できます。

また、スコアを文字列から浮動小数点値に変換する必要があります。

mapAnnotationsメソッドを使用してこれを行うことができます。

そして、それで、私はトレーニングデータを持っています。

しかし、私は検証のためにその一部を脇に置きたいです。

これを行うには、randomSplitメソッドを使用できます。

トレーニングのために80%を維持し、残りは検証に使用します。

今、私はフィットする準備ができています。

そして、自分のアプリにデプロイできるように、トレーニングされたパラメータを保存します。

保存する場所を選択します。

そして、私は書き込みメソッドを呼び出します。

最後に、変圧器を返します。

これは、コンポーネントを使用してモデルを定義し、トレーニングすることの本質です。

構成された見積もりを定義し、トレーニングデータをロードし、フィットメソッドを呼び出し、書き込みを使用してパラメータを保存しました。

しかし、私が改善できることがいくつかあります。

まず第一に、私は検証データセットを渡していますが、検証エラーを観察していないので、そうします。

適合されたメソッドは、メトリクスを収集するために使用できるイベントハンドラを取ります。

とりあえず、トレーニングと検証の最大エラー値の両方を印刷します。

また、最終モデルの平均絶対誤差も欲しいです。

取り付けられたトランスフォーマーを検証機能に適用し、それを実際のスコアと一緒にmeanAbsoluteError関数に渡すことで計算します。

私はこれを実行しましたが、私は素晴らしいモデルを手に入れませんでした - エラーは高かったです。

これは、バナナの画像がそれほど多くありません。

より多くの画像を取得する必要がありますが、その前に、データセットを拡張してみることができます。

画像を回転させて拡大縮小して、より多くの例を得ることができます。

これを行うには、注釈付きの画像を取り、それを拡張する新しい方法を書くつもりです。

注釈付きの画像の配列を返します。

私が行う最初の増強はローテーションです。

-Piとpiの間の角度をランダムに選択し、それを使って画像を回転させます。

ランダムスケールもやります。

そして、オリジナル、回転した画像、スケーリングされた画像の3つの画像を返します。

拡張機能があるので、flatMapを使用してトレーニング画像を拡張します。

私のデータセットの各要素は配列に変換されます。

FlatMapは、その配列の配列を単一の配列に平坦化します。これは、適合メソッドに必要なものです。

拡張は、予測を行うときではなく、フィッティング時にのみ適用されることに注意してください。

さて、これは私の精度を高めました。

しかし、私のモデルをさらに良くするもう1つの改善について話しましょう。

ビジョンフレームワークを使用して、画像を顕著なオブジェクトにトリミングしたいです。

これは私のトレーニングデータの画像の1つです。

誰かが背景に他の果物と一緒にバナナを持っている。

モデルは写真の他のオブジェクトによって混乱する可能性があります。

ビジョンフレームワークAPIを使用すると、画像を最も顕著なオブジェクトに自動的にトリミングできます。

これを行うには、WWDC 2019のビジョントークをチェックしてください。

カスタムトランスフォーマーを書くと、フィッティング時と予測を取得するときの両方で、この変換をすべての画像に簡単に適用できます。

やり方をお見せしましょう。

トランスフォーマープロトコルに準拠するために必要なのは、適用された方法を実装することだけです。

そしてこの場合、画像を撮って画像を返してほしい。

顕著なオブジェクトを取得しない場合は、元の画像を返すと言うことを除いて、このコードに入るつもりはありません。

カスタムトランスを持っているので、イメージリグレッサーに追加します。

特徴を抽出する前に、カスタムトランスを使用する必要があります。

顕著性が私のタスク定義の一部になった今、それはすべてのトレーニング画像をトリミングするために使用され、推論を行うときにも使用されます。

これは、トレーニングと推論の間でタスク定義を共有する利点の1つです。

次のタスクに進む前に、いくつかの重要なポイントを強調させてください。

コンポーネントを使用して、カスタムタスクを作成できるようになりました。

私は追加方法を使ってこれをしました。

AnnotatedFilesを使用して、注釈付きのファイル名でファイルをロードしましたが、ディレクトリによって注釈されたファイルを読み込むこともできます。

ImageReaderを使用してURLを画像にマッピングし、注釈を文字列から値にマッピングしました。

randomSplitを使用して検証データセットを脇に置き、後で使用するために訓練されたパラメータを保存しました。

その後、拡張を追加し、モデルを改善するためにカスタムトランスを定義しました。

しかし、これは単なる画像以上のもののために働きます。

ギアを切り替えて、別のタイプのタスクについて話します。表形式のタスクです。

これらは表形式のデータを使用するタスクです。

表形式データは、異なるタイプの複数の機能を持つことによって特徴付けられる。

数値データとカテゴリデータの両方を含めることができます。

人気のある例は、住宅価格データです。

地域や年齢などもありますが、近所や建物の種類などもあります。

そして、あなたは値を予測することを学びたいです。例えば、販売価格。

2021年、私たちはTaboularDataフレームワークを導入しました。

これで、Create ML Componentsと一緒にTabularDataフレームワークを使用して、表形式の分類器と回帰器を構築およびトレーニングできます。

TabularDataに関する技術講演もお勧めします。

これは、表形式のタスクを構築する際に必要となるデータ探索の素晴らしい紹介です。

飛び込みましょう。

表形式のデータを扱う場合、テーブルの各列には異なるタイプの機能があります。

また、含まれている情報の種類、分布、値の範囲、その他の要因に基づいて、各列を異なる方法で処理することもできます。

MLコンポーネントを作成すると、ColumnSelectorを使用してこれを行うことができます。

ここに例があります。

私は住宅価格について言及しましたが、それらはばかげています。

代わりにアボカドの価格を使うつもりです。

私はこのアボカドの価格表を持っています。

これに基づいてアボカドの価格を予測するための表形式の回帰を構築したい。

バッグ、年、ボリュームなどの数値データを含む列と、タイプや地域などのカテゴリデータを含む列が含まれています。

一部の回帰者は、これらの値をよりよく表現することで利益を得ます。

たとえば、これはデータセット内のボリューム値の分布です。

それは正規分布に近いですが、15,000を中心に大きな値を持っています。

これは、正規化の恩恵を受けることができるデータセットの素晴らしい例だと思います。

だから、私が最初にやりたいことは、これらの値を正規化することです。

これを行うには、正規化したい列名をColumnSelectorに渡し、標準のスケーラーを使用できます。

これがコードです。

まず、列セレクタを作成します。

次に、拡大縮小したい列名を渡します。

すべての列に同じタイプの要素が含まれている必要があります。この場合、Doubleです。

次に、オプションのラップを解除します。

欠けている値がないことを知っているので、これを行うことができます。

しかし、不足している値を置き換えるインペーターを使用することもできます。

そして、アンラッパーにStandardScalerを追加します。

そこで、バッグの番号が数万で、ボリュームが数十万だったこのテーブルから始めました。

そして、これらの列をスケーリングした後、私は1に近い大きさを持つ値になり、モデルのパフォーマンスを向上させることができます。

より具体的に、私の値は平均がゼロで、標準偏差が1になりました。

これは同様の例ですが、この例では、文字列型の型と領域の列を選択し、ワンホットエンコーディングを実行しています。

ワンホットエンコーディングとは、各カテゴリの存在を示す配列を使用してカテゴリデータをエンコードすることを指します。

この例では、ブロンズ、シルバー、ゴールドの3つのカテゴリーがあります。

それぞれが配列内の一意の位置を取得し、その位置の1で示されます。

代替案は、各カテゴリに連続した番号を与える序数エンコーダを使用することです。

カテゴリがいくつかしかない場合はワンホットエンコーダを使用し、それ以外の場合はオーディナルエンコーダを使用してください。

さて、これらすべてをまとめて、表形式の回帰を構築しましょう。

以前と同様に、構造体を作成し、データURLとパラメータURLの定義を開始します。

また、予測したい列の列IDを定義したい：価格。

列車法と予測法の両方から使用できるように、タスクを別々に定義します。

前述したように、ボリュームを正規化します。

次に、ブーストされたツリーリグレクターを使用して価格を予測します。

これは、結果の予測の列でもある注釈列の名前を取り、3つの特徴列すべての名前を取ります。

この3つのコラムから始めます。

次に、追加メソッドを使用してピースを結合し、タスクを返します。

タスクの定義がわかったので、以前と同じように列車の方法を追加します。

そして、以前と同様に、リターンタイプがモデルの詳細に依存しないようにしたい。

最初のステップは、CSVファイルをデータフレームにロードすることです。

私はこれを行うためにTabularDataフレームワークを使用しています。

そして、以前と同じように、検証のためにデータの一部を分割したいと思います。

トレーニングと検証データセットをフィットメソッドに渡します。

また、以前と同じように検証エラーを報告し、後で使用するために訓練されたパラメータを保存します。

最後に、変圧器を返します。

訓練された変圧器を手に入れたら、それを使ってデータフレームの価格予測を行うことができます。

私はこれを行うための予測方法を書くつもりです。

タスク定義とパラメータURLからモデルをロードすることから始めます。

予測に使用するデータフレームに、タイプ、地域、ボリュームなどの機能として使用した列があることを確認する必要があります。

予測値は価格列になります。

上部で定義した列IDを使用します。

そして、私の表形式の回帰はこれで終わりです。

訓練されたパラメータを生成するために一度だけ呼び出す必要がある列車方法と、アボカドの価格、アボカドの種類、地域、量に基づく予測を返す予測方法があります。

私のアプリでこれを使用するために必要なのはそれだけです。

表形式のタスクに取り組む際に留意すべきことがいくつかあります。

ColumnSelector操作を使用して、特定の列を処理できます。

ツリー分類器と回帰器はすべて表形式であることは注目に値しますが、AnnotatedFeatureProviderを使用した表形式のタスクでは、線形回帰器などの非表形式の推定器を使用することもできます。

ドキュメントを参照してください。

予測を行うときは、必要な列でデータフレームを構築し、正しいタイプを使用するようにしてください。

カスタムタスクを構築する方法がわかったので、展開について話しましょう。

これまでのところ、私はトレーニングと推論に同じAPIを使用してきました。

Create ML Componentsを使用する場合、あなたのモデルはあなたのコードであることを指摘したいと思います。

ファイルからトレーニングされたパラメータをロードする場合でも、タスク定義が必要です。

これは状況によっては便利ですが、展開にCore MLを使用したい場合があります。

Core MLを使用する場合は、コードを残します。

モデルはモデルファイルで完全に表されます。

Core MLを使用する準備ができているなら、これは良いワークフローかもしれません。

そして、それは最適化されたテンソル演算の利点を持っています。

しかし、心に留めておくべき考慮事項がいくつかあります。

すべての操作がCore MLでサポートされているわけではありません。

具体的には、カスタムトランスと見積もりはサポートされていません。

また、Core MLは、画像や形状配列などのいくつかのタイプしかサポートしていません。

カスタムタイプを使用している場合は、Core MLモデルを使用するときにアプリでそれらを変換する必要があるかもしれません。

これは、変圧器をCore MLモデルとしてエクスポートする方法です。

トランスフォーマーにサポートされていない操作が含まれている場合、エラーがスローされます。

トレーニングされたパラメータと一緒にタスク定義をデプロイしたい場合は、それらをSwiftパッケージにバンドルすることを検討する必要があります。

このようにして、パラメータをロードして予測を実行する簡単な方法を提供できます。

Swiftパッケージリソースの詳細については、WWDC 2020のSwiftパッケージトークをご覧ください。

私が持っているのはそれだけです。

覚えておくべき主なことは、コンポジションでカスタムタスクを作成できるようになったことです。

可能性は無限大です。

あなたが何を作るかを見るのを楽しみにしています。

オーディオやビデオのタスクを含むより高度なテクニックについては、同僚のDavidがより高度なカスタムタスクを提示する「Create ML Componentsで高度なモデルを作成する」をチェックしてください。

ありがとう、WWDC 2022の残りを楽しんでください!

♪