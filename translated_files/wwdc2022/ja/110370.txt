110370

♪ ♪

みなさん、こんにちは。

私の名前はエイドリアンです。LLDBでの素晴らしいデバッグ体験のためにプロジェクトを設定する方法についてお話しします。

LLDBは、Xcodeに同梱されている基礎となるデバッグ技術です。

LLDBを使用すると、アプリケーションにブレークポイントを設定したり、実行を一時停止したり、変数やオブジェクトの状態を検査したり、コードを探索したりできます。

LLDBは、コードが何をしているのかを理解するのに役立ち、コードの動作が期待から逸脱するポイントを見つけることができます。

これは、コードを理解し、探索するための強力なツールです。

LLDBについてもっと知りたい場合は、WWDC21の「ブレークポイントの改善を発見する」など、以前のビデオをチェックしてください。

今日は、Swiftコードのデバッグに独自の意味を持ついくつかの高度なワークフローを見ていきます。

サードパーティのフレームワークをアプリに統合しているのかもしれません。

おそらく、あなたのアプリとあなたのチームは、あなたのコードのほとんどが継続的インテグレーションシステムによって構築されているところまで成長しました。

カスタムビルドシステムを使用して、会社のインフラストラクチャと統合しているかもしれません。

たぶん、あなたは他のソフトウェア開発者のためのソフトウェアを構築しています。

または、LLDBについてもっと知りたいだけです。

私の目標は、LLDBがどのように機能し、機能するためにビルドシステムからどのような情報が必要かをよりよく理解することです。

ここに小さなプロジェクトがあり、実行例として使用する予定です。

私はコンパイラエンジニアで、ゲームが好きなので、余暇にはテキストアドベンチャー用のパーサーを書きます。

これは私が最近純粋なスウィフトで始めたものです。

私がこれまでに持っているものをお見せしましょう。

ゲームはテキストインターフェースを使用しているので、ターミナルで実行しています。

すべての良い冒険と同様に、私たちは在庫を確認することから始めます。

このゲームは現代的な環境で行われます。

私はiPhoneを持っているのを見ました。

次に、私たちの周囲を見てみましょう。 

うーん、このセンサーは興味をそそられます。

センサーでiPhoneを使えるかな？

iPhoneを落としたの？

ええと、それは私があなたに見せたかったものではありません。

私のゲームにはバグがあると思います。

これがデバッガトークでよかった。

パーサーにブレークポイントを設定し、コマンドをもう一度実行しましょう。

まず、コマンドが正しく読み込まれたことを確認する必要があります。

「Words」変数には、トークン化されたコマンドが含まれています。

ああ、これは期待通りにいかなかった。

ここで何が起こっているのかわかりません。 わかりません。

昨日は問題なくデバッガを使用していましたが、昨夜はターミナルでテキストをスタイリングするためにこのUIフレームワークを統合しました。

そのフレームワークの開発者は、フレームワークの毎晩のビルドをクランクアウトする継続的インテグレーションシステムを持っており、私は最新のものと直接リンクしています。

このフレームワークは私のデバッグのトラブルと関係があるのだろうか。

例を挙げると、デバッグビルドを明示的にダウンロードしたにもかかわらず、フレームワークのソースコードに足を踏み入れることができないことにすでに気づきました。

それを見てください。

分解しか見えません。

そこで何が起こったのかを理解しようとし、なぜソースコードを見ることができなかったのかを理解することから始めましょう。

LLDBはソースコードを表示するために何が必要ですか?

コンパイラが関数をコンパイルすると、マシンコードが生成されます。

また、デバッガ用のブレッドクラムを残すため、実行可能ファイルのアドレスをソースファイルと行番号にマッピングでき、その逆も同様です。

これらのブレッドクラムはデバッグ情報と呼ばれます。

Appleプラットフォームでは、デバッグ情報はオブジェクトファイルに保存されます。

アーカイブと配布のために、デバッグ情報を.dSYMバンドルにリンクすることができます。

デバッグ情報リンカーはdsymutilと呼ばれています。

LLDBはSpotlightを使用して.dSYMバンドルを見つけるので、ディスク上のどこにあるかという点で非常に柔軟です。

デバッグ情報の仕組みがわかったので、例に戻りましょう。

まず、LLDBが実際にフレームワークのdSYMを見つけたことを確認しましょう。

画像リストコマンドでこれを行うことができます。

UIフレームワークは「TerminalInterface」と呼ばれています。

はい、LLDBはフレームワークのdSYMを見つけました。

つまり、デバッグ情報にアクセスできるということです。

「画像検索」を使用して、現在の住所に関する詳細情報を取得できます。

ところで、さまざまなオプションについてもっと知りたい場合は、LLDBには優れた組み込みヘルプがあります。

ああ、ソースコードがない理由がわかると思います。このソースパスは、ソースがビルドサーバーのどこにあるかを指し、ローカルマシンのどこにあるかを示しています。

私たちはそれを修正することができます。

LLDBには、これらのパスをリダイレクトするために使用できるソースマップが組み込まれています。

今すぐコマンドを入力できますが、この変更をより永続的にしたいと思います。

スキームエディタでは、製品、スキーム、スキームの編集、または再生ボタンをオプションでクリックするだけで、プロジェクトごとのLLDB initファイルを定義できます。

私はすでにこのプロジェクトのために1つ追加しました。

LLDBを設定したので、プロジェクトを再び実行しましょう。

そして、私たちはソースコードを持っています。

LLDBは、「settings set target.source-map」を使用してソースパスを再マップできます。

このコマンドをプロジェクトの.lldbinitファイルに入れて、自動的に実行させることができます。

あるいは、各 .dSYM バンドルには、パス プレフィックス再マッピング辞書を置くことができる XML .plist ファイルが含まれています。

サーバーから最新のビルドを取得するダウンロードスクリプトがある場合は、そのスクリプトを変更して、ダウンロードした.dSYMに適切なリマップ辞書を自動的に注入できます。

このプロセスの詳細については、LLDBのウェブサイトをご覧ください。

ソースパスはまったく言語固有ではないため、このメソッドはSwift、C++、およびObjective-Cプロジェクトでも同様に機能します。

Appleプラットフォームのシンボルの詳細については、WWDC21の「Symbolication: Beyond the basics」をご覧ください。

ソースコードがビルドサーバーファームでコンパイルされると、ソースファイルへのリモートパスはマシンごとに異なる場合があります。

マシンごとに1つのリマッププレフィックスを定義する必要がないように、デバッグ情報に入れる前にソースパスを正規化するようにコンパイラに指示することができます。

これは、-debug-prefix-mapオプションを使用して行われます。

これにより、マシン固有のパスプレフィックスを一意の正規のプレースホルダ名に置き換えることができ、LLDBのローカルパスに再マッピングできます。

ソースタンジェントに行く前に、私は「単語」のオブジェクト記述を印刷しようとしていました。

それはうまくいかなかった。

実際、「単語」という表現を評価するだけでもうまくいかなかった。

少なくとも、変数ビューで変数を見ることができます。

Xcode変数ビューに相当するコンソールは、「フレーム変数」または「v」コマンドです。

これらのコマンドのニュアンスについてもっと知りたい場合は、WWDC19の「LLDB: Beyond 'po'」をチェックしてください。

では、poとは何ですか、なぜまだ機能していないのですか?

これが何を意味するのかを理解するには、LLDBについてもっと学ぶ必要があります。

リマインダーとして、LLDBはデバッガです。

しかし、LLDBは単なるデバッガではありません。

それはまた、コンパイラです!

デバッガの機能に加えて、LLDBにはSwiftおよびClangコンパイラの完全に機能するコピーも含まれています。

これらのコンパイラは、pおよびpoコマンドエイリアスを通じて知ることができるLLDBの式評価者を強化します。

式評価者を使用すると、変数を見るだけでなく、計算を実行したり、関数を呼び出したり、プログラムの状態を変更したりできます。

WWDC18の「XcodeとLLDBによる高度なデバッグ」をチェックして、これらのコマンドで何が可能かについてのアイデアを入手してください。

デバッガはローカル変数をどのようにフォーマットしますか?

コンパイラによって提供されるデバッグ情報は、変数がメモリに格納されている場所をデバッガに伝えます。

しかし、その情報だけでは、LLDBは生のバイトのランダムな品揃えしか表示できません。

では、LLDBはどのようにしてそれをうまくフォーマットされた出力に変えるのでしょうか?

答えはタイプです。

タイプ情報により、LLDBはソース変数の構造とメモリレイアウトを理解できます。

タイプ情報を使用すると、LLDBは集計タイプがどのようなフィールドを持っているかを知っており、タイプはLLDBが適切なデータフォーマッタを使用してそれらをきれいに印刷できるようにします。

では、型情報がどこから来るのかを見てみましょう。

フレーム変数とvコマンドが存在するデバッガ側では、LLDBはDebug Infoから型情報を取得します。

また、LLDBはSwiftリフレクションメタデータから型を取得します。

式評価者とpoが生きているコンパイラ側では、LLDBはモジュールから型情報を取得します。

このクリーンな分離はXcode 14で新しく、式評価者がなくても可変ビューが完全に機能する理由を説明しています。

モジュールは、コンパイラが型宣言を整理する方法です。

Swiftコンパイラはモジュールをインポートする多くの方法を知っていますが、それに飛び込む前に、便利な新機能を紹介したいと思います。

コンパイラ側で起こっている問題の診断を開始するにはどうすればよいですか?

今年、LLDBは新しい「swift-healthcheck」コマンドを追加しました。

モジュールのインポートに失敗したかどうかを把握するための最初の停留所です。

これがどのように機能するかをお見せしましょう。

問題が発生した後にスウィフトヘルスチェックを実行することで、Swift式評価者設定のログにアクセスできます。

ログの最後に、LLDBが「TerminalUI」Swiftモジュールのインポートに問題があったことがわかります。

名前に基づいて、これはTerminalInterfaceフレームワークの実装の詳細であると仮定します。

この不足しているモジュールは、selfのタイプがUI実装上で一般的であり、その型を含むモジュールがなければ、式評価者は「self」の動的型を実現できないため、問題です。

フレームワークの開発者にメッセージを送り、調査を依頼します。

私の経験では、彼らはいつも非常に敏感でした。

誰が知っているか、多分私たちはこのビデオの終わりの前に解決策を見つけることさえできます。

それまでの間、LLDBのコンパイラがSwiftモジュールを見つける方法を見てみましょう。

私のアプリには独自のSwiftモジュールがあります。

Foundationなどのシステムフレームワークをインポートする可能性があります。

システムフレームワークは、SDKに存在するテキストの安定したSwiftインターフェイスファイルです。

Swiftモジュールは、モジュールマップファイルの助けを借りてグループ化された1つ以上のヘッダーファイルの派手な名前であるClangモジュールをインポートする可能性があります。

Clangモジュールは、他のClangモジュールに依存することができます。

私のアプリは、ローカルに構築されたフレームワークに属するSwiftモジュールをインポートすることもあります。

また、SDKの一部ではないテキストのSwiftインターフェイスファイルをインポートすることもできます。

方法を知りたい場合は、WWDC19の「Binary Frameworks in Swift」をチェックしてください。

私のアプリは、Swiftコードを含む静的ライブラリとリンクする可能性があり、それにはSwiftモジュールも付属しています。

うーん、まだ終わってないけどね。

Clangモジュールをインポートできるブリッジングヘッダーもあることに言及する必要があります。

最後に、LLDBのみの特別な機能として、一部のモジュールの内容はデバッグ情報だけで再構築できます。

それは多くの情報源です!

LLDBはそれらをすべてどのように見つけますか?

LLDBがモジュールを見つけることができるようにモジュールをパッケージ化するのは、ビルドシステムの仕事です。

システムフレームワークのモジュールはSDKにとどまります。

LLDBは、プログラムに添付されているときに読み取るために一致するSDKを見つけます。

オブジェクトファイルから直接デバッグする場合、LLDBはビルド時にあったすべての非SDKモジュールを見つけます。

Dsymutilは、aと呼ばれるデバッグ情報アーカイブをパッケージ化できます。すべての動的ライブラリ、フレームワークまたはdylib、および実行可能ファイルのDSYMバンドル。

各.dSYMバンドルには、ブリッジングヘッダー、テキストSwiftインターフェイスファイル、および最も重要なデバッグ情報を含むバイナリSwiftモジュールを含めることができます。

それはすべてをカバーしています。

すべて？

静的アーカイブに属するSwiftモジュールを除くすべて。

Swiftモジュールをdsymutilがピックアップするには、リンカーに登録する必要があります。

動的ライブラリと実行可能ファイルの場合、ビルドシステムは自動的にこれを行います。

しかし、静的アーカイブはリンカーによって生成されるのではなく、zipファイルのようなオブジェクトファイルのコレクションにすぎません。

つまり、リンカにSwiftモジュールを登録する責任は、静的アーカイブをリンクするすべての実行可能または動的ライブラリにあります。

多くの場合、Xcodeのビルドシステムはあなたのためにこれを行います。

しかし、独自のカスタムビルドシステムを維持している場合、またはカスタムビルドルールを定義している場合、これは注意すべきことです。

Appleリンカーを使用する場合、Swiftモジュールは-add-ast-pathオプションで登録する必要があります。

ビルドログを確認して、これが当てはまることを確認してください。

また、dsymutilを使用して実行可能ファイルのシンボルテーブルをダンプし、「swiftmodule」をgrepして、それが機能したことを確認することもできます。

Linuxなどの他のプラットフォームでは、swiftドライバーは、バイナリSwiftモジュールファイルを残りのデバッグ情報と一緒にバイナリにリンクできるオブジェクトに変換する-modulewrapアクションをサポートしています。

LLDBはそこでそれを見つけるでしょう。

フレームワークの開発者は信じられないほど反応が良かったです。

私たちが疑ったように、フレームワークのビルドシステムの一部として静的アーカイブが使用されていることがわかりました。

そして、dSYMバンドルから欠けていた静的アーカイブに属するのはSwiftモジュールでした。

私は今、フレームワークの固定バージョンをインストールしました。

不足している静的モジュールをリンカーに登録したので、dsymutilはそれを収集することができました。

今、自己は解決することができます。

そして、「単語」のオブジェクトの説明を印刷することができます。

とにかくコンソールを使用しているので、sエイリアスを使用してparseFrom関数に足を踏み入れています。

そして今、私たちはまた、ここで単なるコピーアンドペーストエラーであるバグを簡単に見つけることができます。

そして、私たちは行方不明のSwiftモジュールのパズルだけでなく、ゲームの最初のパズルも解決しました。

締めくくる前に、注意すべき詳細がもう1つあります。

Swiftコンパイラは、Clangヘッダーの検索パスやその他の関連オプションをバイナリ.swiftmoduleファイルにシリアル化します。

Clangモジュールの依存関係のインポートがビルド中に機能するので、これは素晴らしいことです。

しかし、別のマシンで構築する場合、これらのローカルパスは有害になる可能性があります。

したがって、バイナリ.swiftmoduleを別のマシンに出荷する前に、-no-serialize-debugging-optionsコンパイラフラグを使用して構築することを検討してください。

Xcodeでは、これはSWIFT_SERIALIZE_DEBUGGING_OPTIONS設定で制御されます。

次のいずれかの設定で、これらの検索パスをLLDBに再導入できます。

私たちが学んだことをまとめましょう。

あるマシンから別のマシンにコードを出荷したい場合は、どのレベルのデバッグを行うことを期待しているかを自問する必要があります。

たとえば、バイナリフレームワークを別の開発者に出荷し、デバッガでコードに足を踏み入れることを期待していない場合は、Swiftモジュールをテキストの.swiftinterfaceファイルとして出荷するのが最善です。

しかし、開発者がダウンロードしたビルドアーティファクトをデバッグすることが期待されるビルドサーバーまたは継続的インテグレーションシステムを設定する場合は、バイナリSwiftモジュールを構築し、検索パスのシリアル化をオフにすることを検討する必要があります。

また、-debug-prefix-mapオプションを使用して、デバッグ情報でサーバー上のソースパスを正規化することもできます。

私があなたのために持っているのはそれだけです。

今日は、デバッガとコンパイラとしてのLLDBの二重の性質について学びました。

デバッガは、機能するためにデバッグ情報とリフレクションメタデータを必要とし、Xcode変数ビューとvコマンドを提供します。

コンパイラはモジュールを必要とし、検索パスに敏感です。

Expr、p、poコマンドの背後にあります。

コンパイラ診断を取得する良い方法は、LLDBの新しいswift-healthcheckコマンドです。

見てくれてありがとう!♪ ♪