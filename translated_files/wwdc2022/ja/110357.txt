110357

- こんにちは、私はMichael Ilsemanで、Swift標準ライブラリチームのエンジニアです。

私と会って、SwiftでRegexを知ってください。

Swift Regexにはたくさんのことがあり、私たちはそれが提供しなければならないすべてのものを味わうでしょう。

不正取引を分析するツールで、一部の金融調査員と協力している開発者だとしましょう。

さて、この重要なタスクでは、よく構造化されたデータを処理することだと思うでしょう。

しかし、代わりに、私たちはたくさんの文字列を持っています。

ここでは、最初のフィールドには取引の種類、2番目のフィールドには取引日、3番目のフィールドには個人または機関、4番目の最後のフィールドには米ドルの金額があります。

フィールドは、関係者が覚えておくことができない非常に重要な技術的な理由から、2つ以上のスペースまたはタブで区切られています。

そして、はい、その日付フィールドは完全に曖昧です。

私たちはそれが月/日/年であることを願って、何が起こるかを見るつもりです。

これらのトランザクションの処理には文字列の処理が含まれ、文字列はコレクションであり、汎用コレクションアルゴリズムにアクセスできます。

これらのアルゴリズムには、基本的に要素を操作するものとインデックスを操作するアルゴリズムの2種類があります。

トランザクションフィールドを分割して要素ベースのアルゴリズムを使用しようとすることができますが、フィールドの区切り文字がタブまたは2つ以上のスペースであるため、これは困難になります。

空白を分割するだけでは、それをカットすることはできません。

もう1つのアプローチは、低レベルのインデックス操作コードにドロップダウンすることです。

しかし、正しく行うことは難しく、自分が何をしているのかを知っていても、まだ多くのコードが必要です。

スプリットに戻りましょう。

このアプローチが機能しない理由は、要素ベースであり、フィールドセパレータはより複雑なパターンであるためです。

多種多様な言語で見られる解決策は、正規表現を書くことです。

正規表現は、正規言語を定義する形式言語理論から生まれました。

彼らは、エディタやコマンドラインツールでの検索、およびコンパイラの語彙分析のための実用的なアプリケーションに入りました。

これらのアプリケーションは、入力、制御、直接実行の一部を抽出し、表現力を追加する必要があるため、理論的なルーツを超えて正規表現を取ります。

そして、スウィフトは彼らをさらに進めています。

私たちはこれをデリバティブ正規表現と呼んでいます。

正規表現は、その出力に対する構造体ジェネリックであり、キャプチャを含むそれを適用した結果です。

スラッシュ区切り文字の間に正規表現構文を含むリテラルを使用して作成できます。

Swiftの正規表現構文は、Perl、Python、Ruby、Java、NSRegularExpression、その他多くのものと互換性があります。

この正規表現は1つ以上の数字と一致します。

コンパイラは正規表現構文を知っているので、構文の強調表示、コンパイル時のエラー、さらには強く型付けされたキャプチャを取得し、後で会う予定です。

正規表現は、同じ正規表現構文を含む文字列から実行時に作成できます。

これは、エディタやコマンドラインツールの検索フィールドに便利です。

入力に無効な構文が含まれている場合、実行時にエラーがスローされます。

キャプチャの種類と数は実行時までわからないため、出力タイプは実存的なAnyRegexOutputです。

そして、同じ正規表現は、より冗長ではありますが、宣言的でよく構造化された正規表現ビルダーを使用して書くことができます。

以前の分割アプローチを、正規表現リテラルを使用するように適応させましょう。

最初の部分は、任意の空白文字の2つ以上の出現と一致します。

2番目の部分は、単一の水平タブと一致します。

そして、パイプ文字は選択肢の間の選択を示し、2つ以上のスペースまたは単一のタブのフィールドセパレータを与えます。

フィールドが分割されたので、文明自体に貢献し、そのフィールドの区切り文字を1つのタブに正規化して、それで終わりましょう。

分割後の結果に「join」を呼び出すことができますが、そのためのより良いアルゴリズムがあります。「replacecing」を使用すると、すべてのフィールドセパレータを1つのタブに置き換えることができます。

だから私たちは外に出て、耳を傾ける人に私たちの明らかに優れたアプローチを伝道します。

養子縁組は...遅いが有望だ。

正規表現に精通している場合は、それらの複雑な評判も知っているかもしれません。

古いことわざにあるように、「私は問題を抱えていたので、正規表現を書きました。

今、私は2つの問題を抱えています。

しかし、スウィフト正規表現は違います。

スウィフトは4つの重要な分野で芸術を進歩させる。

正規表現構文は簡潔で表現力豊かですが、簡潔で読みにくくなることがあります。

そして、新しい機能はますます不可解な構文を使用する必要があります。

Swift正規表現は、Regexビルダーを通じてソースコードを構造化および整理する方法で構造化および整理できます。

リテラルは簡潔で、ビルダーは構造を与え、リテラルはビルダー内でその完璧なバランスを見つけるために使用できます。

データのテキスト表現ははるかに複雑になり、それらを正しく処理するには標準に準拠したパーサーが必要です。

Swift正規表現を使用すると、工業強度のパーサーを正規表現の個々のコンポーネントとして織り交ぜることができます。

これはライブラリ拡張可能な方法で行われ、任意のパーサーが参加できることを意味します。

適用された正規表現の歴史の多くは、コンピュータシステム全体が単一の言語とエンコーディング、特にASCIIのみをサポートする世界で起こりました。

しかし、現代世界はUnicodeです。

Swift regexは、表現力を損なうことなくUnicodeを行います。

そして最後に、正規表現の力は、徹底的に探求しなければならない幅広い検索スペースを開くことができます。

これにより、彼らの実行を推論するのが難しくなります。

一部の言語はコントロールをサポートしていますが、不可解な構文の背後にあるため、あいまいな傾向があります。

Swift regexは予測可能な実行を提供し、表面制御を目立つようにします。

私たちが取り組んできた財務諸表に戻り、Swiftでの文字列処理に対する宣言的アプローチであるRegexビルダーを使用して各トランザクションを完全に解析しましょう。

始めるためにRegexBuilderモジュールをインポートします。

先ほど定義したフィールドセパレータ正規表現を再利用することができます。

最初のフィールドは簡単です。クレジットまたはデビットのいずれかです。

すでに見た正規表現のリテラル構文を使って書くことができます。

その後、フィールドセパレータと日付が来ます。

日付を手で解析するのは悪い考えです。

Foundationには、日付、数値、URLなどのタイプの非常に優れたパーサーがあり、Regex Builderで直接使用できます。

私たちは、著者の意図に対する最善の推測である明示的なロケールを提供します。

システムの現在のロケールを暗黙的に使用するのではなく、これを行います。

後でいつでも変更でき、コードで_explicit_を仮定したので、簡単に行うことができます。

3番目のフィールドは「何でも」になる可能性があるので、「何かの1つ以上」と書くのは魅力的です。

そして、それは私たちに正しい答えを与えるでしょうが、それはその後に来る他のものを一致させることから始まるので、それは最初に多くの不必要な作業を行います。

正規表現は一度に1文字ずつバックアップし、残りのパターンを試します。

終端フィールドセパレータが表示されたら、正規表現に停止するように指示したい。

これを達成する方法はたくさんあります。 かなりの数あります。

これを行う良い方法の1つは、実際に消費せずに入力の次の部分を覗くNegativeLookaheadを使用することです。

ここでは、入力を覗いて、文字を一致させる前にフィールドセパレータが出てこないことを確認します。

NegativeLookaheadは、Regexがコンポーネントとどのように一致するかを正確に制御できるツールファミリーの1つです。

最後に、今回は通貨のために、再び財団のパーサーの1つを使用して、金額を一致させます。

コンマは千の区切り文字であり、ピリオドは小数点の区切り文字であると仮定しており、この仮定を明確にしています。

トランザクション台帳から行を解析できる正規表現を構築しました。

私たちは線を認識したいだけではありません。このデータの一部を抽出したい。

これを行うには、後で処理するために入力の一部を抽出するキャプチャを使用します。

慣習的に、「0番目の」キャプチャは、正規表現全体が一致した入力の一部であり、各明示的なキャプチャが続きます。

トランザクションの種類は、入力のスライスである部分文字列としてキャプチャされます。

日付については、テキストを後処理することなく、解析された強く型付けされた値を実際にキャプチャします。

個人または機関は再び入力の一部としてキャプチャされ、10進キャプチャは別の強く型付けされた値です。

それを使用するには、一致結果から日付と小数点の値を抽出し、研究者はここからそれを取ります。

この時点で、構造化されたクエリのような明らかな利点のために、データを実際のデータベースにダンプすることをお勧めします。

彼らは...異なる意見を持っています。

彼らはすべてをひもとして保ちたいと思っている。

Swift Regexをさらに見ることができるので、この講演には良いニュースです。

突然うまくいかないまで、すべてがうまくいっています。

取引テキストの日付順序は、私たちが皆に完全に曖昧であると言ったが、実際には曖昧であることを知りました。

それは必ずしも同じではなく、主要な理論は、それが取引で使用される通貨に依存するということです。

もちろんそうだから。

これは、米ドルが月/日/年であり、英ポンドが日/月/年であることを意味します。

では、これを曖昧にするために、sedのようなスクリプトを書きましょう。

正規表現では、拡張区切り文字を使用します。

これにより、私たちはそれらから逃れることなく、内部にスラッシュを持つことができます。

これにより、空白が無視される拡張構文モードにもアクセスできます。つまり、通常のコードと同じように、読みやすさのために空白を使用できます。

Regexの出力にタプルラベルとして表示される名前付きキャプチャを使用しました。

また、Unicodeプロパティを使用して通貨記号を認識します。

これにより、正規表現の適応性が高くなります。アプリケーションロジックで特定のシンボルを処理します。

テキストを手動でカットしてスプライスするのではなく、再びFoundationの日付パーサーを使用します。

pickStrategyは通貨シンボルを受け取り、それに基づいて解析戦略を決定します。

私たちの仮定はすべてコードで明示的であり、適応と進化が容易になり、ほぼ確実に必要になります。

キャプチャを含む一致結果を使用して置換文字列を構築するクロージャを提供することで、検索置換アルゴリズムで正規表現とヘルパー関数を使用しましょう。

キャプチャされた通貨に基づいて戦略を選択し、キャプチャされた日付を解析します。

位置だけでではなく、名前でキャプチャにアクセスできます。

出力については、明確な業界標準であるISO-8601を使用して新しい日付をフォーマットします。

私たちのツールは、この台帳を明確なものに変換します。

実際の日付パーサーとフォーマッタを使用しているため、変化する要件にはるかに適応できます。

そして、Unicodeプロパティを使用して通貨記号を認識することは、私たちがはるかに速く進化するのに役立ちます。

正規表現は、文字列のいくつかのモデルに対してアルゴリズムを宣言します。

SwiftのStringは、Unicodeを操作するための複数のモデルを提示します。

年齢のためのラブストーリーを表すこの文字列には、3つの文字が含まれています。

これらの文字は、正式にはUnicode拡張書記素クラスタと呼ばれる複雑なエンティティです。

1つの文字は、1つ以上のUnicodeスカラー値で構成されています。

Stringは、その内容のこの下位レベルの表現にアクセスするためのUnicodeScalarViewを提供します。

これにより、高度な使用だけでなく、他のシステムとの互換性が可能になります。

私たちの物語の主人公である私たちの最初のキャラクターは、4つのUnicodeスカラーで構成されています：ZOMBIE、Zero Width Joiner、FEMALE SIGN、そして...

この文脈では、絵文字としてレンダリングされる好みを示すVARIATION SELECTOR-16。

もちろんです！

これらのスカラーは、私たちが視覚的に見る単一の絵文字を生成します。

文字列がメモリに保存されると、UTF-8バイトとしてエンコードされます。

UTF-8ビューを使用して、これらのバイトを表示できます。

UTF-8は可変幅エンコーディングです。つまり、単一のスカラーに複数のバイトが必要になる可能性があり、私たちが見たように、1つの文字に複数のスカラーが必要になる場合があります。

4つのUnicodeスカラーで表される私たちの物語の主人公は、13 UTF-8バイトを使用してエンコードされています。

複数のスカラーで構成されていることに加えて、同じ正確な文字が異なるスカラーのセットで表されることがあります。

これは、英語以外の言語を扱うときによく出てきます。

この例では、急性アクセントを持つ「e」は、単一のスカラー、急性アクセントを持つ事前に構成された「e」、またはASCII「e」とそれに続く結合急性アクセントのいずれかとして表すことができます。

これらは同じ文字なので、文字列比較はtrueを返します。

これは、Stringが正式にUnicode Canonical Equivalenceと呼ばれるものに従うためです。

UnicodeScalarView、またはUTF-8ビューの観点から見ると、内容は異なり、これらの低レベルのビュー内で比較すると、この違いがわかります。

Stringと同様に、Swift regexはデフォルトで強迫的に正しいUnicodeです。

しかし、それは表現力を損なうことなくこれを行います。

文字列のペアを切り替えましょう。

最初の文字列では、ドット(.)で示される文字で囲まれた名前付きUnicode Scalar SPARKLING HEARTを一致させます。

任意の文字クラスは、任意のSwift文字と一致します。つまり、任意のUnicode拡張書記素クラスタです。

2番目の文字列では、等しい文字は等しいものとして比較されます...

そして、私たちはケースを無視することができます。

そして今、私たちのシンプルなラブストーリーはもっと複雑になりました。

時には人生、またはこの場合は非人生には、私たちが処理する必要がある複雑さがあります。

Stringと同様に、互換性またはサブグラフクラスタの精度のためにUnicodeスカラー値を自分で処理する必要がある場合は、「unicodeScalar」セマンティクスと照合することができます。

Unicode Scalarレベルで一致すると、ドットは完全なSwift文字ではなく、単一のUnicode Scalar値と一致します。

これは、私たちが再び友人に会えることを意味します：VARIATION-SELECTOR 16。

このフレンドリーな小さなセレクターはドットで一致し、それがすべて一人でいるとき、それは空の空白としてレンダリングされるので、あなたはそれを見ることができません。

とても助かります。

精度と正確性で作業したので、少し違うことをして、財務に戻りましょう。

調査員が戻ってきて、今回は興味深い要求があります。

彼らは、事後に元帳を処理するのではなく、ワイヤからライブトランザクションを嗅ぐようにトランザクションマッチングツールを変更しました。

彼らのコードを見ると、彼らは実際に合理的に良い仕事をしましたが、スケーリングの問題に直面しており、私たちの助けを必要としています。

彼らが処理しているトランザクションは非常に似ていますが、わずかな違いがあります。

日付の代わりに、彼らは代わりに正確なタイムスタンプを持っています。

これは、明確で、明確で、衝撃的に独自の形式で表されます。

彼らは前世紀に書かれた正規表現を持っていて、これに一致します。

大丈夫です。

次に、個人と識別コードを含む詳細フィールドがあります。

入力から派生したランタイムコンパイルされた正規表現を使用して、このフィールドに対してトランザクションをフィルタリングします。

これはライブであり、後でより多くのフィールドがあるので、彼らは興味のない取引を早期に保釈するのが好きです。

次に、金額とチェックサムのような他のフィールドが来て、彼らは自分でうまく処理します。

そしてもちろん、フィールドはまだ2つ以上のスペースまたはタブで区切られています。

彼らのトランザクションマッチャーは私たちのものによく似ています。

タイムスタンプには独自の正規表現があり、詳細正規表現は入力からコンパイルされ、残りのフィールドを処理します。

彼らは合理的に良い仕事をした。すべてが技術的に機能します。

うまくスケーリングされていないだけです。

彼らは、タイムスタンプと詳細の正規表現が、フィールドよりもはるかに多くの入力と一致することが多いことに気づきます。

理想的には、これらの正規表現は単一のフィールドのみを実行するように制約されます。

ネガティブな先読みを使用して、プロジェクトで同様の問題を処理したので、その正規表現を引き出しましょう。

「フィールド」は、フィールドセパレータに遭遇するまで、任意の文字に効率的に一致し、その正規表現を含めるために使用したいと思います。

これは後処理ステップとして行うことができますが、これはライブで実行されているため、これらの正規表現がフィールドと一致しない場合は、早期に保釈したいと考えています。

TryCaptureを使用してこれを行うことができます。

TryCaptureは、一致したフィールドをクロージャに渡し、研究者のタイムスタンプと詳細正規表現に対してテストします。

それらが一致する場合は、フィールドの値を返します。つまり、一致が成功し、フィールドがキャプチャされます。

それ以外の場合は、マッチングが失敗したことを示すnilを返します。

TryCaptureの閉鎖はマッチングに積極的に参加しており、これはまさに私たちが必要としているものです。

そして、これで、私たちは大きなスケーリングの問題を解決しました。

しかし、まだもう1つの問題があります。トランザクションマッチャーの後半で何かが失敗すると、終了に長い時間がかかることがあります。

冒頭で定義したfieldSeparator正規表現は、2つ以上の空白またはタブと一致します。

8つの空白文字がある場合、残りの正規表現を試す前に、それらすべてと一致します。

しかし、後で正規表現が失敗した場合、バックアップされ、再試行する前に7つの空白文字のみが一致します。

そして、それが失敗した場合、それは6つの空白文字だけに一致します。

すべての選択肢を試した後にのみ、マッチングは失敗します。

代替案を試すためのこのバックアップは、グローバルバックトラック、または正式な論理ではKleeneクロージャと呼ばれます。

それは正規表現に特徴的な力を与えるものです。

しかし、それは探索するための幅広い検索スペースを開き、ここではより直線的な検索スペースが必要です。

私たちはすべての空白を一致させ、決してあきらめないようにしたい。

使用できるツールがいくつかあります。より一般的なツールは、フィールドセパレータをグローバルスコープではなくローカルバックトラッキングスコープに置くことです。

ローカルビルダーは、含まれている正規表現が正常に一致した場合、未試行の選択肢が破棄されるスコープを作成します。

トランザクションマッチャーが後で失敗したとしても、より少ないスペースを消費するために戻らない。

正規表現のデフォルトであるグローバルバックトラッキングは、検索とファジーマッチングに最適です。

ローカルは、正確に指定されたトークンを一致させるのに便利です。

フィールドセパレータは、それが厄介なように、正確です。

ローカルは、原子非捕獲グループとして他の場所で知られており、それは...恐ろしい名前になる可能性があります。

あなたの正規表現が爆発するかもしれないように見えます。

しかし、実際には逆のことをします-検索スペースが含まれています。

そして、これで、私たちは彼らがスケーリングの問題を解決するのを助けました。

今日はSwift Regexに会うことができましたが、カバーできなかったことがたくさんあります。

同僚のリチャードによるSwift Regex: Beyond the Basicsを必ずチェックしてください。

出発する前に、いくつかの点を強調したいと思います。

正規表現ビルダーは構造を与えます。正規表現リテラルは簡潔です。

いつ一方を他方よりも使用するかの選択は、最終的には主観的になります。

可能な限り、必ず実際のパーサーを使用してください。

これにより、膨大な時間を節約し、頭痛を避けることができます。

Swiftのデフォルトを使用するだけで、他のどこよりもはるかに多くのUnicodeサポートと良さを得ることができます。

通貨記号を照合したときなど、文字のプロパティなどを効果的に使用する方法を探してください。

そして最後に、先読みやローカルバックトラックスコープなどのコントロールを使用して、検索と処理アルゴリズムを簡素化します。

ご覧いただきありがとうございます。