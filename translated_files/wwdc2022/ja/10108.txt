10108

♪ ♪

フェリックス・アセロ：こんにちは、私の名前はフェリックス・アセロで、セキュリティエンジニアリングおよびアーキテクチャチームのソフトウェアエンジニアです。

このビデオでは、LocalAuthenticationフレームワークを使用して、アプリの認証と承認フローを改善する方法を紹介します。

まず、認証と承認の一般的な概念と、それらがアプリケーションにどのように適用されるかを見てみましょう。

次に、既存のLocalAuthentication API、特にLAContextが、幅広い承認スキームの実装にどのように役立つかを確認します。

そして最後に、今年LocalAuthenticationに追加する新しいAPIが、認証コードをさらに合理化するのにどのように役立つかを見ていきます。

では、認証と承認について話すことから始めましょう。

認証と承認は明確でありながら密接に関連するセキュリティ概念です。

一方では、認証はユーザーの身元を確認する行為です。

一方、承認とは、特定のユーザーが具体的なリソースに対して特定の操作を実行できるかどうかを検証する行為です。

まとめると、利用可能なリソースと操作を評価する前に、まずユーザーが主張する人であることを確認する必要があるため、認証が実際に承認を可能にすると言えます。

これらの概念を説明するために、Secure Enclaveキーなど、アプリケーションによって管理される共通のセキュリティリソースを含む具体的な例を見てみましょう。

セキュアエンクレーブキーは、特定のデバイスにバインドされ、メインプロセッサから分離されたハードウェアベースのキーマネージャーによって保護されている特別なタイプの非対称キーです。

これらのキーを特別なものにしているのは、Secure Enclaveに秘密鍵を保存すると、実際にキーを扱うことはなく、代わりにSecure Enclaveに操作を実行するように指示することです。

Secure Enclaveキーは、アクセス制御リストまたは略してACLに関連付けることができます。

アクセス制御リストは、ブロブの署名や復号化などの特定の操作を実行するために満たす必要がある要件を指定します。

デバイスのロック解除後など、特定のアイテムがいつ利用可能か、および特定の操作の実行を許可するために必要な認証要件を指定できます。

この例では、アプリがバイオメトリック認証でキーの署名と復号操作を保護し、デバイスのロックが解除された後にのみキーが利用可能であることを確認したいとします。

それでは、このキーを含む符号操作の承認フローがどのように見えるかを見てみましょう。

まず、アプリケーションは秘密鍵を使用してブロブに署名する要求を発行します。

次に、アプリケーションがキーにアクセスできることを確認した後、システムは署名操作の承認要件を特定します。

この場合、署名操作には、現在登録されているユーザーのいずれかからの生体認証が成功する必要があります。

その後、システムは標準のUIを介してバイオメトリック認証プロセスをユーザーに案内します。

認証が成功すると、システムは、最終的に署名操作を実行し、署名されたブロブをアプリに返す前に、残りのすべての承認要件が満たされていることを確認します。

このフローに関与する主なコンポーネントを分解して、それらが最初の定義にどのように適合するかを見てみましょう。

まず、リソースがあります。Secure Enclaveキーです。

第二に、キーで実行できる操作があります。

そして第三に、とりわけ、誰が操作を実行することが許可されているか、および身元を確認するために使用する認証手段を指定する一連の要件があります。

この例のパラメータを定義に差し込むと、認証の場合、これが正しいユーザーであるかどうかという質問は、生体認証によって回答されることがわかります。承認の場合、ユーザーが秘密鍵を使用して署名操作を実行できるかどうかという質問は、アクセス制御リストで指定された要件を検証することによって回答されます。

これが高いレベルでどのように機能するかを見たので、LocalAuthenticationの現在のAPIを使用して、このようなフローを実装する方法を見てみましょう。

フレームワークのコアコンポーネントの1つであるLAContextが提供する機能をすばやく確認することから始めましょう。

LAContextは、ユーザーの身元を評価するために使用できます。

生体認証またはパスコード認証が必要な場合、ユーザーインタラクションを処理します。

また、Secure Enclaveと連携して、生体認証データの安全な管理を可能にします。

この観点から、LAContextは認証のユースケースをサポートするために使用できます。

LAContextは、承認フローをサポートするために、他のフレームワークと連携して使用することもできます。

たとえば、前の例で見たようなアクセス制御リストを評価するために使用できます。

詳しく見てみましょう。 

最初にする必要があるのは、秘密鍵に関連付けられたACLにアクセスすることです。

セキュリティフレームワークが提供するSecItemCopyMatching APIの助けを借りてこれを行うことができ、クエリ内でreturn-attributesキーを確実に提供します。

アクセス制御リストへのアクセスを取得したら、LAContextと evaluateAccessControl APIを使用して直接評価できます。

このアプローチがもとる最大の利点は、アプリケーション内の適切なタイミングと適切な場所を決定して、ユーザーにこの承認を求めることができることです。

この場合、アクセス制御リストは署名操作に生体認証を必要とするため、LAContextは使い慣れたFace IDまたはTouch ID UIを表示します。

ACLがLAContext内で承認されると、キーへの参照を取得するためのクエリの一部として使用できます。

これを行うには、use-authentication-context キーの下の SecItem クエリに LAContext を追加します。

LAContextを秘密鍵参照にバインドすることで、署名操作の実行が別の認証をトリガーしないようにし、不要なプロンプトなしで操作を続行できるようにします。

これらのバインディングはまた、LAContextが無効になるまで、将来の署名に追加のユーザーインタラクションを必要としないことを意味します。

LAContextは大きな柔軟性を提供し、承認フローに関連する各ステップとパラメータを制御できます。

セキュリティフレームワークなどの他のフレームワークと組み合わせて使用でき、幅広いユースケースのロックを解除できます。

しかし、この汎用性は、より高いコードの複雑さを犠牲にし、いくつかのフレームワークによって提供されるAPIを慎重に調整する必要があります。

ユースケースによっては、特にアプリの主な価値提案がキー、シークレット、コンテキスト、およびアクセス制御リストへの低レベルのアクセスを必要とする場合、LAContextが適切なツールである可能性があります。

ただし、アプリに必要なのがコンテンツや機密性の高いリソースへのアクセスを許可する方法だけであれば、この柔軟性の一部をよりシンプルなAPIにトレードオフすることをお勧めします。

これにより、アプリを合理化する最後のトピックに導きます。

iOS 16とmacOS 13の新機能であるLocalAuthenticationは、より高いレベルの認証に焦点を当てたAPIを導入しています。

新しいAPIは、LAContextなどのLocalAuthenticationの既存の概念の上に構築され、共通の承認フローの実装を簡素化し、アプリのコアバリュープロポジションにすべてのエネルギーを集中できるようにします。

新しいAPIによって導入された最も重要な抽象化はLARightです。

LARightを与えることができる最も簡単なユースケースは、アプリケーション定義リソースの操作を承認するのに役立ちます。

たとえば、最初にユーザーからの生体認証を成功させることで、アプリケーションのユーザープロファイルセクションへのアクセスを支援する権利を使用できます。

デフォルトでは、権利は、ユーザーが使用しているデバイスに応じて、Touch ID、Face ID、Apple Watch、またはデバイスのパスコードを使用して認証できる一連の認証要件によって保護されています。

また、より詳細な要件に権利を関連付けることを選択することもできます。これにより、認証手段をさらに制限することができます。

コードでLARightsを使用する方法を見てみましょう。

私たちが最初にすべきことは、私たちの権利をインスタンス化することです。

私たちは、その要件を指定することによってこれを行います。

この場合、当社のログイン権では、ユーザーはバイオメトリを使用して認証するか、デバイスのパスコードを提供する必要があります。

次に、現在のユーザーがログイン権を取得できることを確認します。

この情報を使用して、ログイン操作を続行できるかどうか、または代わりにユーザーをアプリの公開セクションにリダイレクトする必要があるかどうかを判断します。

最後に、承認UIでユーザーに表示されるローカライズされた理由を提供して、実際の承認操作を進めることができます。

このように権利を承認すると、まったく新しいシステム主導のUIが表示されます。

UIはアプリケーションウィンドウ内にレンダリングされ、操作の起源と目的を理解するのに役立つ関連情報をユーザーに提供します。

新しい外観により、アプリケーションとよりシームレスに統合され、ユーザーにより多くのコンテキストと情報を提供する承認フローを作成できると信じています。

権利を作成して承認する方法を見たので、そのライフサイクルを詳しく見てみましょう。

権利は未知の状態でライフサイクルを開始します。

アプリケーションが承認要求を発行するとすぐに、権利の状態は承認に変わります。

この時点で、前のスライドで見た承認UIがユーザーに提示されます。

操作の成功または失敗に応じて、権利は許可された状態または許可されていない状態に移行する可能性があります。

これは、アプリケーションにとって最も重要な状態遷移です。

最後に、権利は許可された状態から許可されていない状態に移動することもできます。

これは、アプリケーションが右側で明示的に承認解除要求を発行した場合、または適切なインスタンスが割り当て解除されたときに発生します。

許可された状態を維持するために、あなたの権利を強く参照してください。

権利が承認解除された後、アプリケーションはサイクルを再開するための承認要求を引き続き発行できます。

以前の状態遷移はすべて照会して観察できます。

LARightインスタンスにアクセスできる場合は、その状態プロパティを直接照会できます。

KVOまたはコンバインを使用して、すべての状態遷移を観察することもできます。

さらに、アプリケーションが複数の権利を処理する場合は、承認状態の変更が検出された後にデフォルトのNotificationCenterに公開されるdidBecomeAuthorizedおよびdidBecomeUnauthorized通知を聞くことで、すべての状態を1か所から観察できます。

先に進む前に、例に戻り、ログイン権の認証を解除するためのログアウト操作を追加しましょう。

これにより、ユーザーが次回ログインしたいときに新しい承認が必要になることを保証します。

これまでのところ、適切なインスタンスを使用して、アプリケーション定義リソースの操作を承認する方法を見てきました。

また、これらの権利のライフサイクルと状態が最終的にランタイムにどのように結びついているかを見てきました。つまり、アプリケーションのすべてのセッションで、これらの権利を正しくインスタンス化して設定する必要があります。

それでは、権利がどのように持続できるか、そしてこれがあなたのアプリにどのような可能性を可能にするかを見てみましょう。

LARightsは、適切な店舗の助けを借りて持続することができます。

永続化されると、権利は、権利の承認要件に一致するアクセス制御リストまたはACLで保護された一意のSecure Enclaveキーによってバックアップされます。

このアプローチは、権利が持続した後も承認要件が不変であることを保証するのに役立ちます。

また、権利を裏返す秘密鍵にアクセスし、それを使用して、復号化、署名、鍵交換などの保護された暗号化操作を実行することもできます。

対応する公開鍵もアクセス可能で、暗号化や署名検証などの操作を実行するために使用できます。

これは公開鍵なので、それに関連付けられたバイトをエクスポートすることもできます。

秘密鍵操作は、権利が正常に承認された後にのみ許可されます。

対照的に、公開鍵操作は常に許可されています。

あなたの権利を保持するとき、あなたはそれと一緒に単一の不変の秘密を保存する機会もあります。

この秘密は、お客様の権利の承認要件に一致するアクセス制御リストにも関連付けられており、権利が承認された後にのみアクセス可能になります。

要約すると、LAPersistedRightsは適切なストアの助けを借りて作成されます。

それらは一度だけ設定され、その承認要件は不変です。

それらは保存されているため、アプリケーションのさまざまなセッションで使用できます。

内部的には、それらは特定のデバイスにバインドされており、権利の承認ステータスに応じて、さまざまな暗号化操作を実行するために使用できる一意のSecure Enclaveキーによってバックアップされています。

最後に、権利が承認された後にのみ利用可能になる単一の不変の秘密を保護するために使用できます。

永続的な権利によって提供される機能のいくつかを理解したので、署名操作を承認したいプレゼンテーションの冒頭で説明したシナリオを実装するのにどのように役立つかを見てみましょう。

私たちは、その承認要件を指定する通常の権利のインスタンス化から始めます。

この場合、権利が権利の作成時にデバイスに生体認証登録を持っているユーザーにのみ権利が付与されるようにしたいと考えています。

したがって、biometryCurrentSetの要件を使用します。

その後、適切なストアの助けを借りて権利を保持し、一意の識別子を提供することができます。

この識別子は、次回アプリケーションの将来のセッションで権利を取得する必要があるときに役立ちます。

権利が保持されると、その公開鍵にすぐにアクセスでき、明示的な許可を必要とせずに、保護されていない操作を実行し始めることができます。

この例では、単にそのパブリックバイトをエクスポートしているだけです。

後で、署名操作を実行するときは、作成時に提供した一意の識別子を使用して、ストアから権利を取得できます。

その後、権利の承認操作を通じて、現在のユーザーの承認に進むことができます。

この時点で、システムはユーザーに認証プロセスを案内し、すべての承認要件が満たされていることを確認します。

権利が承認された後、その秘密鍵を使用して保護された暗号化操作を実行できます。

この場合、秘密鍵を使用して、アプリケーションのバックエンドサーバーによって発行されたチャレンジに署名しています。

最後に、認証と承認の一般的な概念の間に存在する関係、特に認証がどのように承認を可能にするかについて話しました。

LAContextが提供する機能のいくつかと、セキュリティなどのフレームワークと組み合わせて、非常に強力で拡張可能な承認フローのロックを解除する方法について説明しました。

そして最後に、新しく追加されたLARightが、特定の承認ユースケースを実装するためのコードを合理化するのにどのように役立つかを調べました。

アプリのLocalAuthenticationの既存の使用法を見て、今日説明した機能のいくつかが、ユーザーのプライバシーとセキュリティを保護しながらコードを簡素化するのに役立つかどうかを検討してください。

ありがとう。